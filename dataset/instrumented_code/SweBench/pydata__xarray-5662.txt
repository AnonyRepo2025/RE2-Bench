diff --git a/xarray/core/formatting.py b/xarray/core/formatting.py
index 3f65cce..1311088 100644
--- a/xarray/core/formatting.py
+++ b/xarray/core/formatting.py
@@ -1,10 +1,203 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/pydata__xarray-5662/xarray/core/formatting.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 """String formatting routines for __repr__.
 """
 import contextlib
 import functools
 from datetime import datetime, timedelta
 from itertools import chain, zip_longest
-from typing import Hashable
+from typing import Collection, Hashable, Optional
 
 import numpy as np
 import pandas as pd
@@ -97,6 +290,17 @@ def last_item(array):
     return np.ravel(np.asarray(array[indexer])).tolist()
 
 
+@inspect_code
+def calc_max_rows_first(max_rows: int) -> int:
+    """Calculate the first rows to maintain the max number of rows."""
+    return max_rows // 2 + max_rows % 2
+
+
+def calc_max_rows_last(max_rows: int) -> int:
+    """Calculate the last rows to maintain the max number of rows."""
+    return max_rows // 2
+
+
 def format_timestamp(t):
     """Cast given object to a Timestamp and return a nicely formatted string"""
     # Timestamp is only valid for 1678 to 2262
@@ -384,11 +588,11 @@ def _mapping_repr(
             summary = [f"{summary[0]} ({len_mapping})"]
         elif max_rows is not None and len_mapping > max_rows:
             summary = [f"{summary[0]} ({max_rows}/{len_mapping})"]
-            first_rows = max_rows // 2 + max_rows % 2
+            first_rows = calc_max_rows_first(max_rows)
             keys = list(mapping.keys())
             summary += [summarizer(k, mapping[k], col_width) for k in keys[:first_rows]]
             if max_rows > 1:
-                last_rows = max_rows // 2
+                last_rows = calc_max_rows_last(max_rows)
                 summary += [pretty_print("    ...", col_width) + " ..."]
                 summary += [
                     summarizer(k, mapping[k], col_width) for k in keys[-last_rows:]
@@ -441,11 +645,75 @@ def dim_summary(obj):
     return ", ".join(elements)
 
 
-def unindexed_dims_repr(dims, coords):
+@inspect_code
+def _element_formatter(
+    elements: Collection[Hashable],
+    col_width: int,
+    max_rows: Optional[int] = None,
+    delimiter: str = ", ",
+) -> str:
+    """
+    Formats elements for better readability.
+
+    Once it becomes wider than the display width it will create a newline and
+    continue indented to col_width.
+    Once there are more rows than the maximum displayed rows it will start
+    removing rows.
+
+    Parameters
+    ----------
+    elements : Collection of hashable
+        Elements to join together.
+    col_width : int
+        The width to indent to if a newline has been made.
+    max_rows : int, optional
+        The maximum number of allowed rows. The default is None.
+    delimiter : str, optional
+        Delimiter to use between each element. The default is ", ".
+    """
+    elements_len = len(elements)
+    out = [""]
+    length_row = 0
+    for i, v in enumerate(elements):
+        delim = delimiter if i < elements_len - 1 else ""
+        v_delim = f"{v}{delim}"
+        length_element = len(v_delim)
+        length_row += length_element
+
+        # Create a new row if the next elements makes the print wider than
+        # the maximum display width:
+        if col_width + length_row > OPTIONS["display_width"]:
+            out[-1] = out[-1].rstrip()  # Remove trailing whitespace.
+            out.append("\n" + pretty_print("", col_width) + v_delim)
+            length_row = length_element
+        else:
+            out[-1] += v_delim
+
+    # If there are too many rows of dimensions trim some away:
+    if max_rows and (len(out) > max_rows):
+        first_rows = calc_max_rows_first(max_rows)
+        last_rows = calc_max_rows_last(max_rows)
+        out = (
+            out[:first_rows]
+            + ["\n" + pretty_print("", col_width) + "..."]
+            + (out[-last_rows:] if max_rows > 1 else [])
+        )
+    return "".join(out)
+
+
+def dim_summary_limited(obj, col_width: int, max_rows: Optional[int] = None) -> str:
+    elements = [f"{k}: {v}" for k, v in obj.sizes.items()]
+    return _element_formatter(elements, col_width, max_rows)
+
+
+def unindexed_dims_repr(dims, coords, max_rows: Optional[int] = None):
     unindexed_dims = [d for d in dims if d not in coords]
     if unindexed_dims:
-        dims_str = ", ".join(f"{d}" for d in unindexed_dims)
-        return "Dimensions without coordinates: " + dims_str
+        dims_start = "Dimensions without coordinates: "
+        dims_str = _element_formatter(
+            unindexed_dims, col_width=len(dims_start), max_rows=max_rows
+        )
+        return dims_start + dims_str
     else:
         return None
 
@@ -502,9 +770,12 @@ def short_data_repr(array):
         return f"[{array.size} values with dtype={array.dtype}]"
 
 
+@inspect_code
 def array_repr(arr):
     from .variable import Variable
 
+    max_rows = OPTIONS["display_max_rows"]
+
     # used for DataArray, Variable and IndexVariable
     if hasattr(arr, "name") and arr.name is not None:
         name_str = f"{arr.name!r} "
@@ -520,16 +791,23 @@ def array_repr(arr):
     else:
         data_repr = inline_variable_array_repr(arr.variable, OPTIONS["display_width"])
 
+    start = f"<xarray.{type(arr).__name__} {name_str}"
+    dims = dim_summary_limited(arr, col_width=len(start) + 1, max_rows=max_rows)
     summary = [
-        "<xarray.{} {}({})>".format(type(arr).__name__, name_str, dim_summary(arr)),
+        f"{start}({dims})>",
         data_repr,
     ]
 
     if hasattr(arr, "coords"):
         if arr.coords:
-            summary.append(repr(arr.coords))
+            col_width = _calculate_col_width(_get_col_items(arr.coords))
+            summary.append(
+                coords_repr(arr.coords, col_width=col_width, max_rows=max_rows)
+            )
 
-        unindexed_dims_str = unindexed_dims_repr(arr.dims, arr.coords)
+        unindexed_dims_str = unindexed_dims_repr(
+            arr.dims, arr.coords, max_rows=max_rows
+        )
         if unindexed_dims_str:
             summary.append(unindexed_dims_str)
 
@@ -546,12 +824,13 @@ def dataset_repr(ds):
     max_rows = OPTIONS["display_max_rows"]
 
     dims_start = pretty_print("Dimensions:", col_width)
-    summary.append("{}({})".format(dims_start, dim_summary(ds)))
+    dims_values = dim_summary_limited(ds, col_width=col_width + 1, max_rows=max_rows)
+    summary.append(f"{dims_start}({dims_values})")
 
     if ds.coords:
         summary.append(coords_repr(ds.coords, col_width=col_width, max_rows=max_rows))
 
-    unindexed_dims_str = unindexed_dims_repr(ds.dims, ds.coords)
+    unindexed_dims_str = unindexed_dims_repr(ds.dims, ds.coords, max_rows=max_rows)
     if unindexed_dims_str:
         summary.append(unindexed_dims_str)
 
diff --git a/xarray/tests/test_formatting.py b/xarray/tests/test_formatting.py
index aa4c0c4..5293822 100644
--- a/xarray/tests/test_formatting.py
+++ b/xarray/tests/test_formatting.py
@@ -552,18 +552,52 @@ def test__mapping_repr(display_max_rows, n_vars, n_attr) -> None:
         assert len_summary == n_vars
 
     with xr.set_options(
+        display_max_rows=display_max_rows,
         display_expand_coords=False,
         display_expand_data_vars=False,
         display_expand_attrs=False,
     ):
         actual = formatting.dataset_repr(ds)
-        coord_s = ", ".join([f"{c}: {len(v)}" for c, v in coords.items()])
-        expected = dedent(
-            f"""\
-            <xarray.Dataset>
-            Dimensions:      ({coord_s})
-            Coordinates: ({n_vars})
-            Data variables: ({n_vars})
-            Attributes: ({n_attr})"""
+        col_width = formatting._calculate_col_width(
+            formatting._get_col_items(ds.variables)
+        )
+        dims_start = formatting.pretty_print("Dimensions:", col_width)
+        dims_values = formatting.dim_summary_limited(
+            ds, col_width=col_width + 1, max_rows=display_max_rows
         )
+        expected = f"""\
+<xarray.Dataset>
+{dims_start}({dims_values})
+Coordinates: ({n_vars})
+Data variables: ({n_vars})
+Attributes: ({n_attr})"""
+        expected = dedent(expected)
         assert actual == expected
+
+
+def test__element_formatter(n_elements: int = 100) -> None:
+    expected = """\
+    Dimensions without coordinates: dim_0: 3, dim_1: 3, dim_2: 3, dim_3: 3,
+                                    dim_4: 3, dim_5: 3, dim_6: 3, dim_7: 3,
+                                    dim_8: 3, dim_9: 3, dim_10: 3, dim_11: 3,
+                                    dim_12: 3, dim_13: 3, dim_14: 3, dim_15: 3,
+                                    dim_16: 3, dim_17: 3, dim_18: 3, dim_19: 3,
+                                    dim_20: 3, dim_21: 3, dim_22: 3, dim_23: 3,
+                                    ...
+                                    dim_76: 3, dim_77: 3, dim_78: 3, dim_79: 3,
+                                    dim_80: 3, dim_81: 3, dim_82: 3, dim_83: 3,
+                                    dim_84: 3, dim_85: 3, dim_86: 3, dim_87: 3,
+                                    dim_88: 3, dim_89: 3, dim_90: 3, dim_91: 3,
+                                    dim_92: 3, dim_93: 3, dim_94: 3, dim_95: 3,
+                                    dim_96: 3, dim_97: 3, dim_98: 3, dim_99: 3"""
+    expected = dedent(expected)
+
+    intro = "Dimensions without coordinates: "
+    elements = [
+        f"{k}: {v}" for k, v in {f"dim_{k}": 3 for k in np.arange(n_elements)}.items()
+    ]
+    values = xr.core.formatting._element_formatter(
+        elements, col_width=len(intro), max_rows=12
+    )
+    actual = intro + values
+    assert expected == actual
