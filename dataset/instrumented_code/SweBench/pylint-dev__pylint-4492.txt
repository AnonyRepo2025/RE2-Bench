diff --git a/pylint/lint/pylinter.py b/pylint/lint/pylinter.py
index 392b188..464865b 100644
--- a/pylint/lint/pylinter.py
+++ b/pylint/lint/pylinter.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/pylint-dev__pylint-4492/pylint/lint/pylinter.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 # For details: https://github.com/PyCQA/pylint/blob/master/LICENSE
 
@@ -43,6 +236,15 @@ def _read_stdin():
     return sys.stdin.read()
 
 
+@inspect_code
+def _load_reporter_by_class(reporter_class: str) -> type:
+    qname = reporter_class
+    module_part = astroid.modutils.get_module_part(qname)
+    module = astroid.modutils.load_module_from_name(module_part)
+    class_name = qname.split(".")[-1]
+    return getattr(module, class_name)
+
+
 # Python Linter class #########################################################
 
 MSGS = {
@@ -446,12 +648,13 @@ class PyLinter(
         ("Reports", "Options related to output formatting and reporting"),
     )
 
+    @inspect_code
     def __init__(self, options=(), reporter=None, option_groups=(), pylintrc=None):
         """Some stuff has to be done before ancestors initialization...
         messages store / checkers / reporter / astroid manager"""
         self.msgs_store = MessageDefinitionStore()
         self.reporter = None
-        self._reporter_name = None
+        self._reporter_names = None
         self._reporters = {}
         self._checkers = collections.defaultdict(list)
         self._pragma_lineno = {}
@@ -496,13 +699,14 @@ class PyLinter(
         if reporter:
             self.set_reporter(reporter)
 
+    @inspect_code
     def load_default_plugins(self):
         checkers.initialize(self)
         reporters.initialize(self)
         # Make sure to load the default reporter, because
         # the option has been set before the plugins had been loaded.
         if not self.reporter:
-            self._load_reporter()
+            self._load_reporters()
 
     def load_plugin_modules(self, modnames):
         """take a list of module names which are pylint plugins and load
@@ -527,25 +731,49 @@ class PyLinter(
             if hasattr(module, "load_configuration"):
                 module.load_configuration(self)
 
-    def _load_reporter(self):
-        name = self._reporter_name.lower()
-        if name in self._reporters:
-            self.set_reporter(self._reporters[name]())
+    def _load_reporters(self) -> None:
+        sub_reporters = []
+        output_files = []
+        with contextlib.ExitStack() as stack:
+            for reporter_name in self._reporter_names.split(","):
+                reporter_name, *reporter_output = reporter_name.split(":", 1)
+
+                reporter = self._load_reporter_by_name(reporter_name)
+                sub_reporters.append(reporter)
+
+                if reporter_output:
+                    (reporter_output,) = reporter_output
+
+                    # pylint: disable=consider-using-with
+                    output_file = stack.enter_context(open(reporter_output, "w"))
+
+                    reporter.set_output(output_file)
+                    output_files.append(output_file)
+
+            # Extend the lifetime of all opened output files
+            close_output_files = stack.pop_all().close
+
+        if len(sub_reporters) > 1 or output_files:
+            self.set_reporter(
+                reporters.MultiReporter(
+                    sub_reporters,
+                    close_output_files,
+                )
+            )
         else:
-            try:
-                reporter_class = self._load_reporter_class()
-            except (ImportError, AttributeError) as e:
-                raise exceptions.InvalidReporterError(name) from e
-            else:
-                self.set_reporter(reporter_class())
+            self.set_reporter(sub_reporters[0])
 
-    def _load_reporter_class(self):
-        qname = self._reporter_name
-        module_part = astroid.modutils.get_module_part(qname)
-        module = astroid.modutils.load_module_from_name(module_part)
-        class_name = qname.split(".")[-1]
-        reporter_class = getattr(module, class_name)
-        return reporter_class
+    def _load_reporter_by_name(self, reporter_name: str) -> reporters.BaseReporter:
+        name = reporter_name.lower()
+        if name in self._reporters:
+            return self._reporters[name]()
+
+        try:
+            reporter_class = _load_reporter_by_class(reporter_name)
+        except (ImportError, AttributeError) as e:
+            raise exceptions.InvalidReporterError(name) from e
+        else:
+            return reporter_class()
 
     def set_reporter(self, reporter):
         """set the reporter used to display messages and reports"""
@@ -575,11 +803,11 @@ class PyLinter(
                     meth(value)
                 return  # no need to call set_option, disable/enable methods do it
         elif optname == "output-format":
-            self._reporter_name = value
+            self._reporter_names = value
             # If the reporters are already available, load
             # the reporter class.
             if self._reporters:
-                self._load_reporter()
+                self._load_reporters()
 
         try:
             checkers.BaseTokenChecker.set_option(self, optname, value, action, optdict)
diff --git a/pylint/reporters/__init__.py b/pylint/reporters/__init__.py
index d5433f2..1721be7 100644
--- a/pylint/reporters/__init__.py
+++ b/pylint/reporters/__init__.py
@@ -26,6 +26,7 @@ from pylint import utils
 from pylint.reporters.base_reporter import BaseReporter
 from pylint.reporters.collecting_reporter import CollectingReporter
 from pylint.reporters.json_reporter import JSONReporter
+from pylint.reporters.multi_reporter import MultiReporter
 from pylint.reporters.reports_handler_mix_in import ReportsHandlerMixIn
 
 
@@ -34,4 +35,10 @@ def initialize(linter):
     utils.register_plugins(linter, __path__[0])
 
 
-__all__ = ["BaseReporter", "ReportsHandlerMixIn", "JSONReporter", "CollectingReporter"]
+__all__ = [
+    "BaseReporter",
+    "ReportsHandlerMixIn",
+    "JSONReporter",
+    "CollectingReporter",
+    "MultiReporter",
+]
diff --git a/tests/unittest_reporting.py b/tests/unittest_reporting.py
index abd912b..554f325 100644
--- a/tests/unittest_reporting.py
+++ b/tests/unittest_reporting.py
@@ -15,12 +15,16 @@
 # pylint: disable=redefined-outer-name
 
 import warnings
+from contextlib import redirect_stdout
 from io import StringIO
+from json import dumps
 
 import pytest
 
 from pylint import checkers
+from pylint.interfaces import IReporter
 from pylint.lint import PyLinter
+from pylint.reporters import BaseReporter
 from pylint.reporters.text import ParseableTextReporter, TextReporter
 
 
@@ -73,6 +77,180 @@ def test_parseable_output_regression():
     )
 
 
+class NopReporter(BaseReporter):
+    __implements__ = IReporter
+    name = "nop-reporter"
+    extension = ""
+
+    def __init__(self, output=None):
+        super().__init__(output)
+        print("A NopReporter was initialized.", file=self.out)
+
+    def writeln(self, string=""):
+        pass
+
+    def _display(self, layout):
+        pass
+
+
+def test_multi_format_output(tmp_path):
+    text = StringIO(newline=None)
+    json = tmp_path / "somefile.json"
+
+    source_file = tmp_path / "somemodule.py"
+    source_file.write_text('NOT_EMPTY = "This module is not empty"\n')
+    escaped_source_file = dumps(str(source_file))
+
+    nop_format = NopReporter.__module__ + "." + NopReporter.__name__
+    formats = ",".join(["json:" + str(json), "text", nop_format])
+
+    with redirect_stdout(text):
+        linter = PyLinter()
+        linter.set_option("persistent", False)
+        linter.set_option("output-format", formats)
+        linter.set_option("reports", True)
+        linter.set_option("score", True)
+        linter.load_default_plugins()
+
+        assert linter.reporter.linter is linter
+        with pytest.raises(NotImplementedError):
+            linter.reporter.set_output(text)
+
+        linter.open()
+        linter.check_single_file("somemodule", source_file, "somemodule")
+        linter.add_message("line-too-long", line=1, args=(1, 2))
+        linter.generate_reports()
+        linter.reporter.writeln("direct output")
+
+        # Ensure the output files are flushed and closed
+        linter.reporter.close_output_files()
+        del linter.reporter
+
+    with open(json) as f:
+        assert (
+            f.read() == "[\n"
+            "    {\n"
+            '        "type": "convention",\n'
+            '        "module": "somemodule",\n'
+            '        "obj": "",\n'
+            '        "line": 1,\n'
+            '        "column": 0,\n'
+            f'        "path": {escaped_source_file},\n'
+            '        "symbol": "missing-module-docstring",\n'
+            '        "message": "Missing module docstring",\n'
+            '        "message-id": "C0114"\n'
+            "    },\n"
+            "    {\n"
+            '        "type": "convention",\n'
+            '        "module": "somemodule",\n'
+            '        "obj": "",\n'
+            '        "line": 1,\n'
+            '        "column": 0,\n'
+            f'        "path": {escaped_source_file},\n'
+            '        "symbol": "line-too-long",\n'
+            '        "message": "Line too long (1/2)",\n'
+            '        "message-id": "C0301"\n'
+            "    }\n"
+            "]\n"
+            "direct output\n"
+        )
+
+    assert (
+        text.getvalue() == "A NopReporter was initialized.\n"
+        "************* Module somemodule\n"
+        f"{source_file}:1:0: C0114: Missing module docstring (missing-module-docstring)\n"
+        f"{source_file}:1:0: C0301: Line too long (1/2) (line-too-long)\n"
+        "\n"
+        "\n"
+        "Report\n"
+        "======\n"
+        "1 statements analysed.\n"
+        "\n"
+        "Statistics by type\n"
+        "------------------\n"
+        "\n"
+        "+---------+-------+-----------+-----------+------------+---------+\n"
+        "|type     |number |old number |difference |%documented |%badname |\n"
+        "+=========+=======+===========+===========+============+=========+\n"
+        "|module   |1      |NC         |NC         |0.00        |0.00     |\n"
+        "+---------+-------+-----------+-----------+------------+---------+\n"
+        "|class    |0      |NC         |NC         |0           |0        |\n"
+        "+---------+-------+-----------+-----------+------------+---------+\n"
+        "|method   |0      |NC         |NC         |0           |0        |\n"
+        "+---------+-------+-----------+-----------+------------+---------+\n"
+        "|function |0      |NC         |NC         |0           |0        |\n"
+        "+---------+-------+-----------+-----------+------------+---------+\n"
+        "\n"
+        "\n"
+        "\n"
+        "Raw metrics\n"
+        "-----------\n"
+        "\n"
+        "+----------+-------+------+---------+-----------+\n"
+        "|type      |number |%     |previous |difference |\n"
+        "+==========+=======+======+=========+===========+\n"
+        "|code      |2      |66.67 |NC       |NC         |\n"
+        "+----------+-------+------+---------+-----------+\n"
+        "|docstring |0      |0.00  |NC       |NC         |\n"
+        "+----------+-------+------+---------+-----------+\n"
+        "|comment   |0      |0.00  |NC       |NC         |\n"
+        "+----------+-------+------+---------+-----------+\n"
+        "|empty     |1      |33.33 |NC       |NC         |\n"
+        "+----------+-------+------+---------+-----------+\n"
+        "\n"
+        "\n"
+        "\n"
+        "Duplication\n"
+        "-----------\n"
+        "\n"
+        "+-------------------------+------+---------+-----------+\n"
+        "|                         |now   |previous |difference |\n"
+        "+=========================+======+=========+===========+\n"
+        "|nb duplicated lines      |0     |NC       |NC         |\n"
+        "+-------------------------+------+---------+-----------+\n"
+        "|percent duplicated lines |0.000 |NC       |NC         |\n"
+        "+-------------------------+------+---------+-----------+\n"
+        "\n"
+        "\n"
+        "\n"
+        "Messages by category\n"
+        "--------------------\n"
+        "\n"
+        "+-----------+-------+---------+-----------+\n"
+        "|type       |number |previous |difference |\n"
+        "+===========+=======+=========+===========+\n"
+        "|convention |2      |NC       |NC         |\n"
+        "+-----------+-------+---------+-----------+\n"
+        "|refactor   |0      |NC       |NC         |\n"
+        "+-----------+-------+---------+-----------+\n"
+        "|warning    |0      |NC       |NC         |\n"
+        "+-----------+-------+---------+-----------+\n"
+        "|error      |0      |NC       |NC         |\n"
+        "+-----------+-------+---------+-----------+\n"
+        "\n"
+        "\n"
+        "\n"
+        "Messages\n"
+        "--------\n"
+        "\n"
+        "+-------------------------+------------+\n"
+        "|message id               |occurrences |\n"
+        "+=========================+============+\n"
+        "|missing-module-docstring |1           |\n"
+        "+-------------------------+------------+\n"
+        "|line-too-long            |1           |\n"
+        "+-------------------------+------------+\n"
+        "\n"
+        "\n"
+        "\n"
+        "\n"
+        "-------------------------------------\n"
+        "Your code has been rated at -10.00/10\n"
+        "\n"
+        "direct output\n"
+    )
+
+
 def test_display_results_is_renamed():
     class CustomReporter(TextReporter):
         def _display(self, layout):
