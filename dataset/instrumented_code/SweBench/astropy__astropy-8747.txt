diff --git a/astropy/units/function/core.py b/astropy/units/function/core.py
index 0195770..50cca5b 100644
--- a/astropy/units/function/core.py
+++ b/astropy/units/function/core.py
@@ -683,3 +683,7 @@ class FunctionQuantity(Quantity):
 
     def cumsum(self, axis=None, dtype=None, out=None):
         return self._wrap_function(np.cumsum, axis, dtype, out=out)
+
+    def clip(self, a_min, a_max, out=None):
+        return self._wrap_function(np.clip, self._to_own_unit(a_min),
+                                   self._to_own_unit(a_max), out=out)
diff --git a/astropy/units/quantity.py b/astropy/units/quantity.py
index b6dab63..23055c0 100644
--- a/astropy/units/quantity.py
+++ b/astropy/units/quantity.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-8747/astropy/units/quantity.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # -*- coding: utf-8 -*-
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 """
@@ -20,7 +213,7 @@ from .core import (Unit, dimensionless_unscaled, get_current_unit_registry,
                    UnitBase, UnitsError, UnitConversionError, UnitTypeError)
 from .utils import is_effectively_unity
 from .format.latex import Latex
-from astropy.utils.compat import NUMPY_LT_1_14, NUMPY_LT_1_16
+from astropy.utils.compat import NUMPY_LT_1_14, NUMPY_LT_1_16, NUMPY_LT_1_17
 from astropy.utils.compat.misc import override__dir__
 from astropy.utils.exceptions import AstropyDeprecationWarning, AstropyWarning
 from astropy.utils.misc import isiterable, InheritDocstrings
@@ -418,6 +611,7 @@ class Quantity(np.ndarray, metaclass=InheritDocstrings):
                                   'numpy >=1.13.  Please raise an issue on '
                                   'https://github.com/astropy/astropy')
 
+    @inspect_code
     def __array_ufunc__(self, function, method, *inputs, **kwargs):
         """Wrap numpy ufuncs, taking care of units.
 
@@ -455,9 +649,10 @@ class Quantity(np.ndarray, metaclass=InheritDocstrings):
             kwargs['out'] = (out_array,) if function.nout == 1 else out_array
 
         # Same for inputs, but here also convert if necessary.
-        arrays = [(converter(input_.value) if converter else
-                   getattr(input_, 'value', input_))
-                  for input_, converter in zip(inputs, converters)]
+        arrays = []
+        for input_, converter in zip(inputs, converters):
+            input_ = getattr(input_, 'value', input_)
+            arrays.append(converter(input_) if converter else input_)
 
         # Call our superclass's __array_ufunc__
         result = super().__array_ufunc__(function, method, *arrays, **kwargs)
@@ -1502,9 +1697,10 @@ class Quantity(np.ndarray, metaclass=InheritDocstrings):
         result = function(*args, **kwargs)
         return self._result_as_quantity(result, unit, out)
 
-    def clip(self, a_min, a_max, out=None):
-        return self._wrap_function(np.clip, self._to_own_unit(a_min),
-                                   self._to_own_unit(a_max), out=out)
+    if NUMPY_LT_1_17:
+        def clip(self, a_min, a_max, out=None):
+            return self._wrap_function(np.clip, self._to_own_unit(a_min),
+                                       self._to_own_unit(a_max), out=out)
 
     def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None):
         return self._wrap_function(np.trace, offset, axis1, axis2, dtype,
diff --git a/astropy/units/quantity_helper/converters.py b/astropy/units/quantity_helper/converters.py
index 570655b..cfcd744 100644
--- a/astropy/units/quantity_helper/converters.py
+++ b/astropy/units/quantity_helper/converters.py
@@ -166,31 +166,34 @@ def converters_and_unit(function, method, *args):
         converters, result_unit = ufunc_helper(function, *units)
 
         if any(converter is False for converter in converters):
-            # for two-argument ufuncs with a quantity and a non-quantity,
+            # for multi-argument ufuncs with a quantity and a non-quantity,
             # the quantity normally needs to be dimensionless, *except*
             # if the non-quantity can have arbitrary unit, i.e., when it
             # is all zero, infinity or NaN.  In that case, the non-quantity
             # can just have the unit of the quantity
             # (this allows, e.g., `q > 0.` independent of unit)
-            maybe_arbitrary_arg = args[converters.index(False)]
             try:
-                if can_have_arbitrary_unit(maybe_arbitrary_arg):
-                    converters = [None, None]
-                else:
-                    raise UnitConversionError(
-                        "Can only apply '{0}' function to "
-                        "dimensionless quantities when other "
-                        "argument is not a quantity (unless the "
-                        "latter is all zero/infinity/nan)"
-                        .format(function.__name__))
+                # Don't fold this loop in the test above: this rare case
+                # should not make the common case slower.
+                for i, converter in enumerate(converters):
+                    if converter is not False:
+                        continue
+                    if can_have_arbitrary_unit(args[i]):
+                        converters[i] = None
+                    else:
+                        raise UnitConversionError(
+                            "Can only apply '{0}' function to "
+                            "dimensionless quantities when other "
+                            "argument is not a quantity (unless the "
+                            "latter is all zero/infinity/nan)"
+                            .format(function.__name__))
             except TypeError:
                 # _can_have_arbitrary_unit failed: arg could not be compared
                 # with zero or checked to be finite. Then, ufunc will fail too.
                 raise TypeError("Unsupported operand type(s) for ufunc {0}: "
-                                "'{1}' and '{2}'"
-                                .format(function.__name__,
-                                        args[0].__class__.__name__,
-                                        args[1].__class__.__name__))
+                                "'{1}'".format(function.__name__,
+                                               ','.join([arg.__class__.__name__
+                                                         for arg in args])))
 
         # In the case of np.power and np.float_power, the unit itself needs to
         # be modified by an amount that depends on one of the input values,
diff --git a/astropy/units/quantity_helper/helpers.py b/astropy/units/quantity_helper/helpers.py
index 5bbd4d0..012fda7 100644
--- a/astropy/units/quantity_helper/helpers.py
+++ b/astropy/units/quantity_helper/helpers.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-8747/astropy/units/quantity_helper/helpers.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # -*- coding: utf-8 -*-
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 # The idea for this module (but no code) was borrowed from the
@@ -296,6 +489,40 @@ def helper_divmod(f, unit1, unit2):
     return converters, (dimensionless_unscaled, result_unit)
 
 
+@inspect_code
+def helper_clip(f, unit1, unit2, unit3):
+    # Treat the array being clipped as primary.
+    converters = [None]
+    if unit1 is None:
+        result_unit = dimensionless_unscaled
+        try:
+            converters += [(None if unit is None else
+                            get_converter(unit, dimensionless_unscaled))
+                           for unit in (unit2, unit3)]
+        except UnitsError:
+            raise UnitConversionError(
+                "Can only apply '{0}' function to quantities with "
+                "compatible dimensions".format(f.__name__))
+
+    else:
+        result_unit = unit1
+        for unit in unit2, unit3:
+            try:
+                converter = get_converter(_d(unit), result_unit)
+            except UnitsError:
+                if unit is None:
+                    # special case: OK if unitless number is zero, inf, nan
+                    converters.append(False)
+                else:
+                    raise UnitConversionError(
+                        "Can only apply '{0}' function to quantities with "
+                        "compatible dimensions".format(f.__name__))
+            else:
+                converters.append(converter)
+
+    return converters, result_unit
+
+
 # list of ufuncs:
 # http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs
 
@@ -407,3 +634,6 @@ UFUNC_HELPERS[np.floor_divide] = helper_twoarg_floor_divide
 UFUNC_HELPERS[np.heaviside] = helper_heaviside
 UFUNC_HELPERS[np.float_power] = helper_power
 UFUNC_HELPERS[np.divmod] = helper_divmod
+# Check for clip ufunc; note that np.clip is a wrapper function, not the ufunc.
+if isinstance(getattr(np.core.umath, 'clip', None), np.ufunc):
+    UFUNC_HELPERS[np.core.umath.clip] = helper_clip
diff --git a/astropy/units/tests/test_quantity.py b/astropy/units/tests/test_quantity.py
index 081c002..95dd9bd 100644
--- a/astropy/units/tests/test_quantity.py
+++ b/astropy/units/tests/test_quantity.py
@@ -496,11 +496,10 @@ class TestQuantityOperations:
 
     def test_non_number_type(self):
         q1 = u.Quantity(11.412, unit=u.meter)
-        type_err_msg = ("Unsupported operand type(s) for ufunc add: "
-                        "'Quantity' and 'dict'")
         with pytest.raises(TypeError) as exc:
             q1 + {'a': 1}
-        assert exc.value.args[0] == type_err_msg
+        assert exc.value.args[0].startswith(
+            "Unsupported operand type(s) for ufunc add:")
 
         with pytest.raises(TypeError):
             q1 + u.meter
diff --git a/astropy/units/tests/test_quantity_ufuncs.py b/astropy/units/tests/test_quantity_ufuncs.py
index 49ffe4e..ac0db53 100644
--- a/astropy/units/tests/test_quantity_ufuncs.py
+++ b/astropy/units/tests/test_quantity_ufuncs.py
@@ -868,6 +868,92 @@ class TestInplaceUfuncs:
             a4 += u.Quantity(10, u.mm, dtype=np.int64)
 
 
+@pytest.mark.skipif(not hasattr(np.core.umath, 'clip'),
+                    reason='no clip ufunc available')
+class TestClip:
+    """Test the clip ufunc.
+
+    In numpy, this is hidden behind a function that does not backwards
+    compatibility checks.  We explicitly test the ufunc here.
+    """
+    def setup(self):
+        self.clip = np.core.umath.clip
+
+    def test_clip_simple(self):
+        q = np.arange(-1., 10.) * u.m
+        q_min = 125 * u.cm
+        q_max = 0.0055 * u.km
+        result = self.clip(q, q_min, q_max)
+        assert result.unit == q.unit
+        expected = self.clip(q.value, q_min.to_value(q.unit),
+                             q_max.to_value(q.unit)) * q.unit
+        assert np.all(result == expected)
+
+    def test_clip_unitless_parts(self):
+        q = np.arange(-1., 10.) * u.m
+        qlim = 0.0055 * u.km
+        # one-sided
+        result1 = self.clip(q, -np.inf, qlim)
+        expected1 = self.clip(q.value, -np.inf, qlim.to_value(q.unit)) * q.unit
+        assert np.all(result1 == expected1)
+        result2 = self.clip(q, qlim, np.inf)
+        expected2 = self.clip(q.value, qlim.to_value(q.unit), np.inf) * q.unit
+        assert np.all(result2 == expected2)
+        # Zero
+        result3 = self.clip(q, np.zeros(q.shape), qlim)
+        expected3 = self.clip(q.value, 0, qlim.to_value(q.unit)) * q.unit
+        assert np.all(result3 == expected3)
+        # Two unitless parts, array-shaped.
+        result4 = self.clip(q, np.zeros(q.shape), np.full(q.shape, np.inf))
+        expected4 = self.clip(q.value, 0, np.inf) * q.unit
+        assert np.all(result4 == expected4)
+
+    def test_clip_dimensionless(self):
+        q = np.arange(-1., 10.) * u.dimensionless_unscaled
+        result = self.clip(q, 200 * u.percent, 5.)
+        expected = self.clip(q, 2., 5.)
+        assert result.unit == u.dimensionless_unscaled
+        assert np.all(result == expected)
+
+    def test_clip_ndarray(self):
+        a = np.arange(-1., 10.)
+        result = self.clip(a, 200 * u.percent, 5. * u.dimensionless_unscaled)
+        assert isinstance(result, u.Quantity)
+        expected = self.clip(a, 2., 5.) * u.dimensionless_unscaled
+        assert np.all(result == expected)
+
+    def test_clip_quantity_inplace(self):
+        q = np.arange(-1., 10.) * u.m
+        q_min = 125 * u.cm
+        q_max = 0.0055 * u.km
+        expected = self.clip(q.value, q_min.to_value(q.unit),
+                             q_max.to_value(q.unit)) * q.unit
+        result = self.clip(q, q_min, q_max, out=q)
+        assert result is q
+        assert np.all(result == expected)
+
+    def test_clip_ndarray_dimensionless_output(self):
+        a = np.arange(-1., 10.)
+        q = np.zeros_like(a) * u.m
+        expected = self.clip(a, 2., 5.) * u.dimensionless_unscaled
+        result = self.clip(a, 200 * u.percent, 5. * u.dimensionless_unscaled,
+                           out=q)
+        assert result is q
+        assert result.unit == u.dimensionless_unscaled
+        assert np.all(result == expected)
+
+    def test_clip_errors(self):
+        q = np.arange(-1., 10.) * u.m
+        with pytest.raises(u.UnitsError):
+            self.clip(q, 0, 1*u.s)
+        with pytest.raises(u.UnitsError):
+            self.clip(q.value, 0, 1*u.s)
+        with pytest.raises(u.UnitsError):
+            self.clip(q, -1, 0.)
+        with pytest.raises(u.UnitsError):
+            self.clip(q, 0., 1.)
+
+
 class TestUfuncAt:
     """Test that 'at' method for ufuncs (calculates in-place at given indices)
 
diff --git a/astropy/utils/compat/numpycompat.py b/astropy/utils/compat/numpycompat.py
index 23d3a4d..7db0748 100644
--- a/astropy/utils/compat/numpycompat.py
+++ b/astropy/utils/compat/numpycompat.py
@@ -7,7 +7,7 @@ from astropy.utils import minversion
 
 
 __all__ = ['NUMPY_LT_1_14', 'NUMPY_LT_1_14_1', 'NUMPY_LT_1_14_2',
-           'NUMPY_LT_1_16']
+           'NUMPY_LT_1_16', 'NUMPY_LT_1_17']
 
 # TODO: It might also be nice to have aliases to these named for specific
 # features/bugs we're checking for (ex:
@@ -16,3 +16,4 @@ NUMPY_LT_1_14 = not minversion('numpy', '1.14')
 NUMPY_LT_1_14_1 = not minversion('numpy', '1.14.1')
 NUMPY_LT_1_14_2 = not minversion('numpy', '1.14.2')
 NUMPY_LT_1_16 = not minversion('numpy', '1.16')
+NUMPY_LT_1_17 = not minversion('numpy', '1.17')
