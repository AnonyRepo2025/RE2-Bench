diff --git a/pylint/checkers/spelling.py b/pylint/checkers/spelling.py
index 95b46cd..a4fa523 100644
--- a/pylint/checkers/spelling.py
+++ b/pylint/checkers/spelling.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/pylint-dev__pylint-4330/pylint/checkers/spelling.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Copyright (c) 2014-2020 Claudiu Popa <pcmanticore@gmail.com>
 # Copyright (c) 2014 Michal Nowikowski <godfryd@gmail.com>
 # Copyright (c) 2014 LOGILAB S.A. (Paris, FRANCE) <contact@logilab.fr>
@@ -17,6 +210,7 @@
 # Copyright (c) 2020 Ganden Schaffner <gschaffner@pm.me>
 # Copyright (c) 2020 hippo91 <guillaume.peillex@gmail.com>
 # Copyright (c) 2020 Damien Baty <damien.baty@polyconseil.fr>
+# Copyright (c) 2021 Eli Fine <ejfine@gmail.com>
 
 # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 # For details: https://github.com/PyCQA/pylint/blob/master/COPYING
@@ -26,6 +220,7 @@
 import os
 import re
 import tokenize
+from typing import Pattern
 
 from pylint.checkers import BaseTokenChecker
 from pylint.checkers.utils import check_messages
@@ -79,7 +274,7 @@ else:
     instr = " To make it work, install the 'python-enchant' package."
 
 
-class WordsWithDigigtsFilter(Filter):
+class WordsWithDigitsFilter(Filter):
     """Skips words with digits."""
 
     def _skip(self, word):
@@ -99,7 +294,21 @@ class WordsWithUnderscores(Filter):
         return "_" in word
 
 
-class CamelCasedWord(Filter):
+class RegExFilter(Filter):
+    """Parent class for filters using regular expressions.
+
+    This filter skips any words the match the expression
+    assigned to the class attribute ``_pattern``.
+
+    """
+
+    _pattern: Pattern[str]
+
+    def _skip(self, word) -> bool:
+        return bool(self._pattern.match(word))
+
+
+class CamelCasedWord(RegExFilter):
     r"""Filter skipping over camelCasedWords.
     This filter skips any words matching the following regular expression:
 
@@ -109,11 +318,8 @@ class CamelCasedWord(Filter):
     """
     _pattern = re.compile(r"^([a-z]+([\d]|[A-Z])(?:\w+)?)")
 
-    def _skip(self, word):
-        return bool(self._pattern.match(word))
-
 
-class SphinxDirectives(Filter):
+class SphinxDirectives(RegExFilter):
     r"""Filter skipping over Sphinx Directives.
     This filter skips any words matching the following regular expression:
 
@@ -124,11 +330,8 @@ class SphinxDirectives(Filter):
     # The final ` in the pattern is optional because enchant strips it out
     _pattern = re.compile(r"^(:([a-z]+)){1,2}:`([^`]+)(`)?")
 
-    def _skip(self, word):
-        return bool(self._pattern.match(word))
-
 
-class ForwardSlashChunkder(Chunker):
+class ForwardSlashChunker(Chunker):
     """
     This chunker allows splitting words like 'before/after' into 'before' and 'after'
     """
@@ -169,6 +372,23 @@ class ForwardSlashChunkder(Chunker):
         raise StopIteration()
 
 
+CODE_FLANKED_IN_BACKTICK_REGEX = re.compile(r"(\s|^)(`{1,2})([^`]+)(\2)([^`]|$)")
+
+
+def _strip_code_flanked_in_backticks(line: str) -> str:
+    """Alter line so code flanked in backticks is ignored.
+
+    Pyenchant automatically strips backticks when parsing tokens,
+    so this cannot be done at the individual filter level."""
+
+    def replace_code_but_leave_surrounding_characters(match_obj) -> str:
+        return match_obj.group(1) + match_obj.group(5)
+
+    return CODE_FLANKED_IN_BACKTICK_REGEX.sub(
+        replace_code_but_leave_surrounding_characters, line
+    )
+
+
 class SpellingChecker(BaseTokenChecker):
     """Check spelling in comments and docstrings"""
 
@@ -245,8 +465,18 @@ class SpellingChecker(BaseTokenChecker):
                 "help": "Limits count of emitted suggestions for spelling mistakes.",
             },
         ),
+        (
+            "spelling-ignore-comment-directives",
+            {
+                "default": "fmt: on,fmt: off,noqa:,noqa,nosec,isort:skip,mypy:",
+                "type": "string",
+                "metavar": "<comma separated words>",
+                "help": "List of comma separated words that should be considered directives if they appear and the beginning of a comment and should not be checked.",
+            },
+        ),
     )
 
+    @inspect_code
     def open(self):
         self.initialized = False
         self.private_dict_file = None
@@ -264,6 +494,10 @@ class SpellingChecker(BaseTokenChecker):
         # "pylint" appears in comments in pylint pragmas.
         self.ignore_list.extend(["param", "pylint"])
 
+        self.ignore_comment_directive_list = [
+            w.strip() for w in self.config.spelling_ignore_comment_directives.split(",")
+        ]
+
         # Expand tilde to allow e.g. spelling-private-dict-file = ~/.pylintdict
         if self.config.spelling_private_dict_file:
             self.config.spelling_private_dict_file = os.path.expanduser(
@@ -283,12 +517,12 @@ class SpellingChecker(BaseTokenChecker):
 
         self.tokenizer = get_tokenizer(
             dict_name,
-            chunkers=[ForwardSlashChunkder],
+            chunkers=[ForwardSlashChunker],
             filters=[
                 EmailFilter,
                 URLFilter,
                 WikiWordFilter,
-                WordsWithDigigtsFilter,
+                WordsWithDigitsFilter,
                 WordsWithUnderscores,
                 CamelCasedWord,
                 SphinxDirectives,
@@ -308,9 +542,19 @@ class SpellingChecker(BaseTokenChecker):
             initial_space = 0
         if line.strip().startswith("#") and "docstring" not in msgid:
             line = line.strip()[1:]
+            # A ``Filter`` cannot determine if the directive is at the beginning of a line,
+            #   nor determine if a colon is present or not (``pyenchant`` strips trailing colons).
+            #   So implementing this here.
+            for iter_directive in self.ignore_comment_directive_list:
+                if line.startswith(" " + iter_directive):
+                    line = line[(len(iter_directive) + 1) :]
+                    break
             starts_with_comment = True
         else:
             starts_with_comment = False
+
+        line = _strip_code_flanked_in_backticks(line)
+
         for word, word_start_at in self.tokenizer(line.strip()):
             word_start_at += initial_space
             lower_cased_word = word.casefold()
diff --git a/pylint/testutils/decorator.py b/pylint/testutils/decorator.py
index 3b70867..5e5077e 100644
--- a/pylint/testutils/decorator.py
+++ b/pylint/testutils/decorator.py
@@ -7,17 +7,21 @@ from pylint.testutils.checker_test_case import CheckerTestCase
 
 
 def set_config(**kwargs):
-    """Decorator for setting config values on a checker."""
+    """Decorator for setting config values on a checker.
+
+    Passing the args and kwargs back to the test function itself
+    allows this decorator to be used on parametrized test cases.
+    """
 
     def _wrapper(fun):
         @functools.wraps(fun)
-        def _forward(self):
+        def _forward(self, *args, **test_function_kwargs):
             for key, value in kwargs.items():
                 setattr(self.checker.config, key, value)
             if isinstance(self, CheckerTestCase):
                 # reopen checker in case, it may be interested in configuration change
                 self.checker.open()
-            fun(self)
+            fun(self, *args, **test_function_kwargs)
 
         return _forward
 
diff --git a/tests/checkers/unittest_spelling.py b/tests/checkers/unittest_spelling.py
index c14062d..2d48670 100644
--- a/tests/checkers/unittest_spelling.py
+++ b/tests/checkers/unittest_spelling.py
@@ -37,7 +37,9 @@ if enchant is not None:
         pass
 
 
-class TestSpellingChecker(CheckerTestCase):
+class TestSpellingChecker(CheckerTestCase):  # pylint:disable=too-many-public-methods
+    # This is a test case class, not sure why it would be relevant to have
+    #   this pylint rule enforced for test case classes.
     CHECKER_CLASS = spelling.SpellingChecker
 
     skip_on_missing_package_or_dict = pytest.mark.skipif(
@@ -303,6 +305,107 @@ class TestSpellingChecker(CheckerTestCase):
         ):
             self.checker.visit_classdef(stmt)
 
+    @skip_on_missing_package_or_dict
+    @set_config(spelling_dict=spell_dict)
+    @pytest.mark.parametrize(
+        ",".join(
+            (
+                "misspelled_portion_of_directive",
+                "second_portion_of_directive",
+                "description",
+            )
+        ),
+        (
+            ("fmt", ": on", "black directive to turn on formatting"),
+            ("fmt", ": off", "black directive to turn off formatting"),
+            ("noqa", "", "pycharm directive"),
+            ("noqa", ":", "flake8 / zimports directive"),
+            ("nosec", "", "bandit directive"),
+            ("isort", ":skip", "isort directive"),
+            ("mypy", ":", "mypy directive"),
+        ),
+    )
+    def test_skip_tool_directives_at_beginning_of_comments_but_still_raise_error_if_directive_appears_later_in_comment(  # pylint:disable=unused-argument
+        # Having the extra description parameter allows the description
+        #   to show up in the pytest output as part of the test name
+        #   when running parametrized tests.
+        self,
+        misspelled_portion_of_directive,
+        second_portion_of_directive,
+        description,
+    ):
+        full_comment = f"# {misspelled_portion_of_directive}{second_portion_of_directive} {misspelled_portion_of_directive}"
+        with self.assertAddsMessages(
+            Message(
+                "wrong-spelling-in-comment",
+                line=1,
+                args=(
+                    misspelled_portion_of_directive,
+                    full_comment,
+                    f"  {'^'*len(misspelled_portion_of_directive)}",
+                    self._get_msg_suggestions(misspelled_portion_of_directive),
+                ),
+            )
+        ):
+            self.checker.process_tokens(_tokenize_str(full_comment))
+
+    @skip_on_missing_package_or_dict
+    @set_config(spelling_dict=spell_dict)
+    def test_skip_code_flanked_in_double_backticks(self):
+        full_comment = "# The function ``.qsize()`` .qsize()"
+        with self.assertAddsMessages(
+            Message(
+                "wrong-spelling-in-comment",
+                line=1,
+                args=(
+                    "qsize",
+                    full_comment,
+                    "                 ^^^^^",
+                    self._get_msg_suggestions("qsize"),
+                ),
+            )
+        ):
+            self.checker.process_tokens(_tokenize_str(full_comment))
+
+    @skip_on_missing_package_or_dict
+    @set_config(spelling_dict=spell_dict)
+    def test_skip_code_flanked_in_single_backticks(self):
+        full_comment = "# The function `.qsize()` .qsize()"
+        with self.assertAddsMessages(
+            Message(
+                "wrong-spelling-in-comment",
+                line=1,
+                args=(
+                    "qsize",
+                    full_comment,
+                    "                 ^^^^^",
+                    self._get_msg_suggestions("qsize"),
+                ),
+            )
+        ):
+            self.checker.process_tokens(_tokenize_str(full_comment))
+
+    @skip_on_missing_package_or_dict
+    @set_config(
+        spelling_dict=spell_dict,
+        spelling_ignore_comment_directives="newdirective:,noqa",
+    )
+    def test_skip_directives_specified_in_pylintrc(self):
+        full_comment = "# newdirective: do this newdirective"
+        with self.assertAddsMessages(
+            Message(
+                "wrong-spelling-in-comment",
+                line=1,
+                args=(
+                    "newdirective",
+                    full_comment,
+                    "          ^^^^^^^^^^^^",
+                    self._get_msg_suggestions("newdirective"),
+                ),
+            )
+        ):
+            self.checker.process_tokens(_tokenize_str(full_comment))
+
     @skip_on_missing_package_or_dict
     @set_config(spelling_dict=spell_dict)
     def test_handle_words_joined_by_forward_slash(self):
