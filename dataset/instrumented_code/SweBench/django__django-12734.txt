diff --git a/django/db/backends/sqlite3/schema.py b/django/db/backends/sqlite3/schema.py
index a4885c5..0a0044d 100644
--- a/django/db/backends/sqlite3/schema.py
+++ b/django/db/backends/sqlite3/schema.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/django__django-12734/django/db/backends/sqlite3/schema.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 import copy
 from decimal import Decimal
 
@@ -345,6 +538,7 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
                 return
             self._remake_table(model, delete_field=field)
 
+    @inspect_code
     def _alter_field(self, model, old_field, new_field, old_type, new_type,
                      old_db_params, new_db_params, strict=False):
         """Perform a "physical" (non-ManyToMany) field update."""
@@ -358,11 +552,28 @@ class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
             return self.execute(self._rename_field_sql(model._meta.db_table, old_field, new_field, new_type))
         # Alter by remaking table
         self._remake_table(model, alter_field=(old_field, new_field))
-        # Rebuild tables with FKs pointing to this field if the PK type changed.
-        if old_field.primary_key and new_field.primary_key and old_type != new_type:
-            for rel in new_field.model._meta.related_objects:
-                if not rel.many_to_many:
-                    self._remake_table(rel.related_model)
+        # Rebuild tables with FKs pointing to this field.
+        if new_field.unique and old_type != new_type:
+            related_models = set()
+            opts = new_field.model._meta
+            for remote_field in opts.related_objects:
+                # Ignore self-relationship since the table was already rebuilt.
+                if remote_field.related_model == model:
+                    continue
+                if not remote_field.many_to_many:
+                    if remote_field.field_name == new_field.name:
+                        related_models.add(remote_field.related_model)
+                elif new_field.primary_key and remote_field.through._meta.auto_created:
+                    related_models.add(remote_field.through)
+            if new_field.primary_key:
+                for many_to_many in opts.many_to_many:
+                    # Ignore self-relationship since the table was already rebuilt.
+                    if many_to_many.related_model == model:
+                        continue
+                    if many_to_many.remote_field.through._meta.auto_created:
+                        related_models.add(many_to_many.remote_field.through)
+            for related_model in related_models:
+                self._remake_table(related_model)
 
     def _alter_many_to_many(self, model, old_field, new_field, strict):
         """Alter M2Ms to repoint their to= endpoints."""
diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py
index 3908a64..bb4b74e 100644
--- a/tests/migrations/test_operations.py
+++ b/tests/migrations/test_operations.py
@@ -3,7 +3,6 @@ from django.db import (
     IntegrityError, connection, migrations, models, transaction,
 )
 from django.db.migrations.migration import Migration
-from django.db.migrations.operations import CreateModel
 from django.db.migrations.operations.fields import FieldOperation
 from django.db.migrations.state import ModelState, ProjectState
 from django.db.transaction import atomic
@@ -1276,6 +1275,16 @@ class OperationTests(OperationTestBase):
         Tests the AlterField operation on primary keys changes any FKs pointing to it.
         """
         project_state = self.set_up_test_model("test_alflpkfk", related_model=True)
+        project_state = self.apply_operations('test_alflpkfk', project_state, [
+            migrations.CreateModel('Stable', fields=[
+                ('ponies', models.ManyToManyField('Pony')),
+            ]),
+            migrations.AddField(
+                'Pony',
+                'stables',
+                models.ManyToManyField('Stable'),
+            ),
+        ])
         # Test the state alteration
         operation = migrations.AlterField("Pony", "id", models.FloatField(primary_key=True))
         new_state = project_state.clone()
@@ -1295,8 +1304,26 @@ class OperationTests(OperationTestBase):
                     for c in connection.introspection.get_table_description(cursor, "test_alflpkfk_rider")
                     if c.name == "pony_id"
                 ][0]
+                m2m_fk_type, m2m_fk_null = [
+                    (c.type_code, c.null_ok)
+                    for c in connection.introspection.get_table_description(
+                        cursor,
+                        'test_alflpkfk_pony_stables',
+                    ) if c.name == 'pony_id'
+                ][0]
+                remote_m2m_fk_type, remote_m2m_fk_null = [
+                    (c.type_code, c.null_ok)
+                    for c in connection.introspection.get_table_description(
+                        cursor,
+                        'test_alflpkfk_stable_ponies',
+                    ) if c.name == 'pony_id'
+                ][0]
             self.assertEqual(id_type, fk_type)
+            self.assertEqual(id_type, m2m_fk_type)
+            self.assertEqual(id_type, remote_m2m_fk_type)
             self.assertEqual(id_null, fk_null)
+            self.assertEqual(id_null, m2m_fk_null)
+            self.assertEqual(id_null, remote_m2m_fk_null)
 
         assertIdTypeEqualsFkType()
         # Test the database alteration
@@ -1314,7 +1341,7 @@ class OperationTests(OperationTestBase):
         project_state = self.apply_operations(app_label, ProjectState(), operations=[
             migrations.CreateModel('Rider', fields=[
                 ('id', models.AutoField(primary_key=True)),
-                ('code', models.PositiveIntegerField(unique=True)),
+                ('code', models.IntegerField(unique=True)),
             ]),
             migrations.CreateModel('Pony', fields=[
                 ('id', models.AutoField(primary_key=True)),
@@ -1327,6 +1354,18 @@ class OperationTests(OperationTestBase):
             models.CharField(max_length=100, unique=True),
         )
         self.apply_operations(app_label, project_state, operations=[operation])
+        id_type, id_null = [
+            (c.type_code, c.null_ok)
+            for c in self.get_table_description('%s_rider' % app_label)
+            if c.name == 'code'
+        ][0]
+        fk_type, fk_null = [
+            (c.type_code, c.null_ok)
+            for c in self.get_table_description('%s_pony' % app_label)
+            if c.name == 'rider_id'
+        ][0]
+        self.assertEqual(id_type, fk_type)
+        self.assertEqual(id_null, fk_null)
 
     @skipUnlessDBFeature('supports_foreign_keys')
     def test_alter_field_reloads_state_on_fk_with_to_field_related_name_target_type_change(self):
@@ -1754,7 +1793,7 @@ class OperationTests(OperationTestBase):
     def test_add_constraint_percent_escaping(self):
         app_label = 'add_constraint_string_quoting'
         operations = [
-            CreateModel(
+            migrations.CreateModel(
                 'Author',
                 fields=[
                     ('id', models.AutoField(primary_key=True)),
@@ -1820,7 +1859,7 @@ class OperationTests(OperationTestBase):
     def test_add_constraint_combinable(self):
         app_label = 'test_addconstraint_combinable'
         operations = [
-            CreateModel(
+            migrations.CreateModel(
                 'Book',
                 fields=[
                     ('id', models.AutoField(primary_key=True)),
@@ -2917,7 +2956,11 @@ class SwappableOperationTests(OperationTestBase):
 class TestCreateModel(SimpleTestCase):
 
     def test_references_model_mixin(self):
-        CreateModel('name', [], bases=(Mixin, models.Model)).references_model('other_model', 'migrations')
+        migrations.CreateModel(
+            'name',
+            fields=[],
+            bases=(Mixin, models.Model),
+        ).references_model('other_model', 'migrations')
 
 
 class FieldOperationTests(SimpleTestCase):
