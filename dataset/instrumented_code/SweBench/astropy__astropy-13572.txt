diff --git a/astropy/coordinates/earth_orientation.py b/astropy/coordinates/earth_orientation.py
index 94dbc56..f6181ac 100644
--- a/astropy/coordinates/earth_orientation.py
+++ b/astropy/coordinates/earth_orientation.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-13572/astropy/coordinates/earth_orientation.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 
 """
@@ -10,15 +203,15 @@ is instead primarily for internal use in `coordinates`
 
 
 import numpy as np
+import erfa
 
 from astropy.time import Time
-from astropy import units as u
+from .builtin_frames.utils import get_jd12
 from .matrix_utilities import rotation_matrix, matrix_product, matrix_transpose
 
 
 jd1950 = Time('B1950').jd
 jd2000 = Time('J2000').jd
-_asecperrad = u.radian.to(u.arcsec)
 
 
 def eccentricity(jd):
@@ -81,14 +274,14 @@ def obliquity(jd, algorithm=2006):
     Parameters
     ----------
     jd : scalar or array-like
-        Julian date at which to compute the obliquity
+        Julian date (TT) at which to compute the obliquity
     algorithm : int
-        Year of algorithm based on IAU adoption. Can be 2006, 2000 or 1980. The
-        2006 algorithm is mentioned in Circular 179, but the canonical reference
-        for the IAU adoption is apparently Hilton et al. 06 is composed of the
-        1980 algorithm with a precession-rate correction due to the 2000
-        precession models, and a description of the 1980 algorithm can be found
-        in the Explanatory Supplement to the Astronomical Almanac.
+        Year of algorithm based on IAU adoption. Can be 2006, 2000 or 1980.
+        The IAU 2006 algorithm is based on Hilton et al. 2006.
+        The IAU 1980 algorithm is based on the Explanatory Supplement to the
+        Astronomical Almanac (1992).
+        The IAU 2000 algorithm starts with the IAU 1980 algorithm and applies a
+        precession-rate correction from the IAU 2000 precession model.
 
     Returns
     -------
@@ -97,34 +290,24 @@ def obliquity(jd, algorithm=2006):
 
     References
     ----------
-    * Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351. 2000
-    * USNO Circular 179
+    * Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351
+    * Capitaine, N., et al., 2003, Astron.Astrophys. 400, 1145-1154
     * Explanatory Supplement to the Astronomical Almanac: P. Kenneth
       Seidelmann (ed), University Science Books (1992).
     """
-    T = (jd - jd2000) / 36525.0
-
     if algorithm == 2006:
-        p = (-0.0000000434, -0.000000576, 0.00200340, -0.0001831, -46.836769, 84381.406)
-        corr = 0
+        return np.rad2deg(erfa.obl06(jd, 0))
     elif algorithm == 2000:
-        p = (0.001813, -0.00059, -46.8150, 84381.448)
-        corr = -0.02524 * T
+        return np.rad2deg(erfa.obl80(jd, 0) + erfa.pr00(jd, 0)[1])
     elif algorithm == 1980:
-        p = (0.001813, -0.00059, -46.8150, 84381.448)
-        corr = 0
+        return np.rad2deg(erfa.obl80(jd, 0))
     else:
         raise ValueError('invalid algorithm year for computing obliquity')
 
-    return (np.polyval(p, T) + corr) / 3600.
-
 
-# TODO: replace this with SOFA equivalent
 def precession_matrix_Capitaine(fromepoch, toepoch):
     """
-    Computes the precession matrix from one Julian epoch to another.
-    The exact method is based on Capitaine et al. 2003, which should
-    match the IAU 2006 standard.
+    Computes the precession matrix from one Julian epoch to another, per IAU 2006.
 
     Parameters
     ----------
@@ -140,39 +323,12 @@ def precession_matrix_Capitaine(fromepoch, toepoch):
 
     References
     ----------
-    USNO Circular 179
+    Hilton, J. et al., 2006, Celest.Mech.Dyn.Astron. 94, 351
     """
-    mat_fromto2000 = matrix_transpose(
-        _precess_from_J2000_Capitaine(fromepoch.jyear))
-    mat_2000toto = _precess_from_J2000_Capitaine(toepoch.jyear)
-
-    return np.dot(mat_2000toto, mat_fromto2000)
-
-
-def _precess_from_J2000_Capitaine(epoch):
-    """
-    Computes the precession matrix from J2000 to the given Julian Epoch.
-    Expression from from Capitaine et al. 2003 as expressed in the USNO
-    Circular 179.  This should match the IAU 2006 standard from SOFA.
-
-    Parameters
-    ----------
-    epoch : scalar
-        The epoch as a Julian year number (e.g. J2000 is 2000.0)
-
-    """
-    T = (epoch - 2000.0) / 100.0
-    # from USNO circular
-    pzeta = (-0.0000003173, -0.000005971, 0.01801828, 0.2988499, 2306.083227, 2.650545)
-    pz = (-0.0000002904, -0.000028596, 0.01826837, 1.0927348, 2306.077181, -2.650545)
-    ptheta = (-0.0000001274, -0.000007089, -0.04182264, -0.4294934, 2004.191903, 0)
-    zeta = np.polyval(pzeta, T) / 3600.0
-    z = np.polyval(pz, T) / 3600.0
-    theta = np.polyval(ptheta, T) / 3600.0
-
-    return matrix_product(rotation_matrix(-z, 'z'),
-                          rotation_matrix(theta, 'y'),
-                          rotation_matrix(-zeta, 'z'))
+    # Multiply the two precession matrices (without frame bias) through J2000.0
+    fromepoch_to_J2000 = matrix_transpose(erfa.bp06(*get_jd12(fromepoch, 'tt'))[1])
+    J2000_to_toepoch = erfa.bp06(*get_jd12(toepoch, 'tt'))[1]
+    return J2000_to_toepoch @ fromepoch_to_J2000
 
 
 def _precession_matrix_besselian(epoch1, epoch2):
@@ -210,142 +366,7 @@ def _precession_matrix_besselian(epoch1, epoch2):
                           rotation_matrix(-zeta, 'z'))
 
 
-def _load_nutation_data(datastr, seriestype):
-    """
-    Loads nutation series from data stored in string form.
-
-    Seriestype can be 'lunisolar' or 'planetary'
-    """
-
-    if seriestype == 'lunisolar':
-        dtypes = [('nl', int),
-                  ('nlp', int),
-                  ('nF', int),
-                  ('nD', int),
-                  ('nOm', int),
-                  ('ps', float),
-                  ('pst', float),
-                  ('pc', float),
-                  ('ec', float),
-                  ('ect', float),
-                  ('es', float)]
-    elif seriestype == 'planetary':
-        dtypes = [('nl', int),
-                  ('nF', int),
-                  ('nD', int),
-                  ('nOm', int),
-                  ('nme', int),
-                  ('nve', int),
-                  ('nea', int),
-                  ('nma', int),
-                  ('nju', int),
-                  ('nsa', int),
-                  ('nur', int),
-                  ('nne', int),
-                  ('npa', int),
-                  ('sp', int),
-                  ('cp', int),
-                  ('se', int),
-                  ('ce', int)]
-    else:
-        raise ValueError('requested invalid nutation series type')
-
-    lines = [l for l in datastr.split('\n')
-             if not l.startswith('#') if not l.strip() == '']
-
-    lists = [[] for _ in dtypes]
-    for l in lines:
-        for i, e in enumerate(l.split(' ')):
-            lists[i].append(dtypes[i][1](e))
-    return np.rec.fromarrays(lists, names=[e[0] for e in dtypes])
-
-
-_nut_data_00b = """
-#l lprime F D Omega longitude_sin longitude_sin*t longitude_cos obliquity_cos obliquity_cos*t,obliquity_sin
-
-0 0 0 0 1 -172064161.0 -174666.0 33386.0 92052331.0 9086.0 15377.0
-0 0 2 -2 2 -13170906.0 -1675.0 -13696.0 5730336.0 -3015.0 -4587.0
-0 0 2 0 2 -2276413.0 -234.0 2796.0 978459.0 -485.0 1374.0
-0 0 0 0 2 2074554.0 207.0 -698.0 -897492.0 470.0 -291.0
-0 1 0 0 0 1475877.0 -3633.0 11817.0 73871.0 -184.0 -1924.0
-0 1 2 -2 2 -516821.0 1226.0 -524.0 224386.0 -677.0 -174.0
-1 0 0 0 0 711159.0 73.0 -872.0 -6750.0 0.0 358.0
-0 0 2 0 1 -387298.0 -367.0 380.0 200728.0 18.0 318.0
-1 0 2 0 2 -301461.0 -36.0 816.0 129025.0 -63.0 367.0
-0 -1 2 -2 2 215829.0 -494.0 111.0 -95929.0 299.0 132.0
-0 0 2 -2 1 128227.0 137.0 181.0 -68982.0 -9.0 39.0
--1 0 2 0 2 123457.0 11.0 19.0 -53311.0 32.0 -4.0
--1 0 0 2 0 156994.0 10.0 -168.0 -1235.0 0.0 82.0
-1 0 0 0 1 63110.0 63.0 27.0 -33228.0 0.0 -9.0
--1 0 0 0 1 -57976.0 -63.0 -189.0 31429.0 0.0 -75.0
--1 0 2 2 2 -59641.0 -11.0 149.0 25543.0 -11.0 66.0
-1 0 2 0 1 -51613.0 -42.0 129.0 26366.0 0.0 78.0
--2 0 2 0 1 45893.0 50.0 31.0 -24236.0 -10.0 20.0
-0 0 0 2 0 63384.0 11.0 -150.0 -1220.0 0.0 29.0
-0 0 2 2 2 -38571.0 -1.0 158.0 16452.0 -11.0 68.0
-0 -2 2 -2 2 32481.0 0.0 0.0 -13870.0 0.0 0.0
--2 0 0 2 0 -47722.0 0.0 -18.0 477.0 0.0 -25.0
-2 0 2 0 2 -31046.0 -1.0 131.0 13238.0 -11.0 59.0
-1 0 2 -2 2 28593.0 0.0 -1.0 -12338.0 10.0 -3.0
--1 0 2 0 1 20441.0 21.0 10.0 -10758.0 0.0 -3.0
-2 0 0 0 0 29243.0 0.0 -74.0 -609.0 0.0 13.0
-0 0 2 0 0 25887.0 0.0 -66.0 -550.0 0.0 11.0
-0 1 0 0 1 -14053.0 -25.0 79.0 8551.0 -2.0 -45.0
--1 0 0 2 1 15164.0 10.0 11.0 -8001.0 0.0 -1.0
-0 2 2 -2 2 -15794.0 72.0 -16.0 6850.0 -42.0 -5.0
-0 0 -2 2 0 21783.0 0.0 13.0 -167.0 0.0 13.0
-1 0 0 -2 1 -12873.0 -10.0 -37.0 6953.0 0.0 -14.0
-0 -1 0 0 1 -12654.0 11.0 63.0 6415.0 0.0 26.0
--1 0 2 2 1 -10204.0 0.0 25.0 5222.0 0.0 15.0
-0 2 0 0 0 16707.0 -85.0 -10.0 168.0 -1.0 10.0
-1 0 2 2 2 -7691.0 0.0 44.0 3268.0 0.0 19.0
--2 0 2 0 0 -11024.0 0.0 -14.0 104.0 0.0 2.0
-0 1 2 0 2 7566.0 -21.0 -11.0 -3250.0 0.0 -5.0
-0 0 2 2 1 -6637.0 -11.0 25.0 3353.0 0.0 14.0
-0 -1 2 0 2 -7141.0 21.0 8.0 3070.0 0.0 4.0
-0 0 0 2 1 -6302.0 -11.0 2.0 3272.0 0.0 4.0
-1 0 2 -2 1 5800.0 10.0 2.0 -3045.0 0.0 -1.0
-2 0 2 -2 2 6443.0 0.0 -7.0 -2768.0 0.0 -4.0
--2 0 0 2 1 -5774.0 -11.0 -15.0 3041.0 0.0 -5.0
-2 0 2 0 1 -5350.0 0.0 21.0 2695.0 0.0 12.0
-0 -1 2 -2 1 -4752.0 -11.0 -3.0 2719.0 0.0 -3.0
-0 0 0 -2 1 -4940.0 -11.0 -21.0 2720.0 0.0 -9.0
--1 -1 0 2 0 7350.0 0.0 -8.0 -51.0 0.0 4.0
-2 0 0 -2 1 4065.0 0.0 6.0 -2206.0 0.0 1.0
-1 0 0 2 0 6579.0 0.0 -24.0 -199.0 0.0 2.0
-0 1 2 -2 1 3579.0 0.0 5.0 -1900.0 0.0 1.0
-1 -1 0 0 0 4725.0 0.0 -6.0 -41.0 0.0 3.0
--2 0 2 0 2 -3075.0 0.0 -2.0 1313.0 0.0 -1.0
-3 0 2 0 2 -2904.0 0.0 15.0 1233.0 0.0 7.0
-0 -1 0 2 0 4348.0 0.0 -10.0 -81.0 0.0 2.0
-1 -1 2 0 2 -2878.0 0.0 8.0 1232.0 0.0 4.0
-0 0 0 1 0 -4230.0 0.0 5.0 -20.0 0.0 -2.0
--1 -1 2 2 2 -2819.0 0.0 7.0 1207.0 0.0 3.0
--1 0 2 0 0 -4056.0 0.0 5.0 40.0 0.0 -2.0
-0 -1 2 2 2 -2647.0 0.0 11.0 1129.0 0.0 5.0
--2 0 0 0 1 -2294.0 0.0 -10.0 1266.0 0.0 -4.0
-1 1 2 0 2 2481.0 0.0 -7.0 -1062.0 0.0 -3.0
-2 0 0 0 1 2179.0 0.0 -2.0 -1129.0 0.0 -2.0
--1 1 0 1 0 3276.0 0.0 1.0 -9.0 0.0 0.0
-1 1 0 0 0 -3389.0 0.0 5.0 35.0 0.0 -2.0
-1 0 2 0 0 3339.0 0.0 -13.0 -107.0 0.0 1.0
--1 0 2 -2 1 -1987.0 0.0 -6.0 1073.0 0.0 -2.0
-1 0 0 0 2 -1981.0 0.0 0.0 854.0 0.0 0.0
--1 0 0 1 0 4026.0 0.0 -353.0 -553.0 0.0 -139.0
-0 0 2 1 2 1660.0 0.0 -5.0 -710.0 0.0 -2.0
--1 0 2 4 2 -1521.0 0.0 9.0 647.0 0.0 4.0
--1 1 0 1 1 1314.0 0.0 0.0 -700.0 0.0 0.0
-0 -2 2 -2 1 -1283.0 0.0 0.0 672.0 0.0 0.0
-1 0 2 2 1 -1331.0 0.0 8.0 663.0 0.0 4.0
--2 0 2 2 2 1383.0 0.0 -2.0 -594.0 0.0 -2.0
--1 0 0 0 2 1405.0 0.0 4.0 -610.0 0.0 2.0
-1 1 2 -2 2 1290.0 0.0 0.0 -556.0 0.0 0.0
-"""[1:-1]
-_nut_data_00b = _load_nutation_data(_nut_data_00b, 'lunisolar')
-
-# TODO: replace w/SOFA equivalent
-
-
+@inspect_code
 def nutation_components2000B(jd):
     """
     Computes nutation components following the IAU 2000B specification
@@ -353,7 +374,7 @@ def nutation_components2000B(jd):
     Parameters
     ----------
     jd : scalar
-        epoch at which to compute the nutation components as a JD
+        Julian date (TT) at which to compute the nutation components
 
     Returns
     -------
@@ -364,48 +385,31 @@ def nutation_components2000B(jd):
     deps : float
         depsilon in raidans
     """
-    epsa = np.radians(obliquity(jd, 2000))
-    t = (jd - jd2000) / 36525
-
-    # Fundamental (Delaunay) arguments from Simon et al. (1994) via SOFA
-    # Mean anomaly of moon
-    el = ((485868.249036 + 1717915923.2178 * t) % 1296000) / _asecperrad
-    # Mean anomaly of sun
-    elp = ((1287104.79305 + 129596581.0481 * t) % 1296000) / _asecperrad
-    # Mean argument of the latitude of Moon
-    F = ((335779.526232 + 1739527262.8478 * t) % 1296000) / _asecperrad
-    # Mean elongation of the Moon from Sun
-    D = ((1072260.70369 + 1602961601.2090 * t) % 1296000) / _asecperrad
-    # Mean longitude of the ascending node of Moon
-    Om = ((450160.398036 + -6962890.5431 * t) % 1296000) / _asecperrad
-
-    # compute nutation series using array loaded from data directory
-    dat = _nut_data_00b
-    arg = dat.nl * el + dat.nlp * elp + dat.nF * F + dat.nD * D + dat.nOm * Om
-    sarg = np.sin(arg)
-    carg = np.cos(arg)
-
-    p1u_asecperrad = _asecperrad * 1e7  # 0.1 microasrcsecperrad
-    dpsils = np.sum((dat.ps + dat.pst * t) * sarg + dat.pc * carg) / p1u_asecperrad
-    depsls = np.sum((dat.ec + dat.ect * t) * carg + dat.es * sarg) / p1u_asecperrad
-    # fixed offset in place of planetary tersm
-    m_asecperrad = _asecperrad * 1e3  # milliarcsec per rad
-    dpsipl = -0.135 / m_asecperrad
-    depspl = 0.388 / m_asecperrad
-
-    return epsa, dpsils + dpsipl, depsls + depspl  # all in radians
+    dpsi, deps, epsa, _, _, _, _, _ = erfa.pn00b(jd, 0)
+    return epsa, dpsi, deps
 
 
 def nutation_matrix(epoch):
     """
-    Nutation matrix generated from nutation components.
+    Nutation matrix generated from nutation components, IAU 2000B model.
 
     Matrix converts from mean coordinate to true coordinate as
     r_true = M * r_mean
+
+    Parameters
+    ----------
+    epoch : `~astropy.time.Time`
+        The epoch at which to compute the nutation matrix
+
+    Returns
+    -------
+    nmatrix : 3x3 array
+        Nutation matrix for the specified epoch
+
+    References
+    ----------
+    * Explanatory Supplement to the Astronomical Almanac: P. Kenneth
+      Seidelmann (ed), University Science Books (1992).
     """
     # TODO: implement higher precision 2006/2000A model if requested/needed
-    epsa, dpsi, deps = nutation_components2000B(epoch.jd)  # all in radians
-
-    return matrix_product(rotation_matrix(-(epsa + deps), 'x', False),
-                          rotation_matrix(-dpsi, 'z', False),
-                          rotation_matrix(epsa, 'x', False))
+    return erfa.num00b(*get_jd12(epoch, 'tt'))
diff --git a/astropy/coordinates/tests/test_sky_coord.py b/astropy/coordinates/tests/test_sky_coord.py
index f0d4d46..21a7d74 100644
--- a/astropy/coordinates/tests/test_sky_coord.py
+++ b/astropy/coordinates/tests/test_sky_coord.py
@@ -1885,10 +1885,10 @@ def test_match_to_catalog_3d_and_sky():
 
     idx, angle, quantity = cfk5_J1950.match_to_catalog_3d(cfk5_default)
     npt.assert_array_equal(idx, [0, 1, 2, 3])
-    assert_allclose(angle, 0*u.deg, atol=2e-15*u.deg, rtol=0)
-    assert_allclose(quantity, 0*u.kpc, atol=1e-15*u.kpc, rtol=0)
+    assert_allclose(angle, 0*u.deg, atol=1e-14*u.deg, rtol=0)
+    assert_allclose(quantity, 0*u.kpc, atol=1e-14*u.kpc, rtol=0)
 
     idx, angle, distance = cfk5_J1950.match_to_catalog_sky(cfk5_default)
     npt.assert_array_equal(idx, [0, 1, 2, 3])
-    assert_allclose(angle, 0 * u.deg, atol=2e-15*u.deg, rtol=0)
-    assert_allclose(distance, 0*u.kpc, atol=2e-15*u.kpc, rtol=0)
+    assert_allclose(angle, 0 * u.deg, atol=1e-14*u.deg, rtol=0)
+    assert_allclose(distance, 0*u.kpc, atol=1e-14*u.kpc, rtol=0)
