diff --git a/astropy/units/format/console.py b/astropy/units/format/console.py
index 491833e..063cc2a 100644
--- a/astropy/units/format/console.py
+++ b/astropy/units/format/console.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-14413/astropy/units/format/console.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 
 """
@@ -17,7 +210,7 @@ class Console(base.Base):
 
       >>> import astropy.units as u
       >>> print(u.Ry.decompose().to_string('console'))  # doctest: +FLOAT_CMP
-      2.1798721*10^-18m^2 kg s^-2
+      2.1798721*10^-18 m^2 kg s^-2
       >>> print(u.Ry.decompose().to_string('console', inline=False))  # doctest: +FLOAT_CMP
                        m^2 kg
       2.1798721*10^-18 ------
@@ -31,6 +224,10 @@ class Console(base.Base):
     def _get_unit_name(cls, unit):
         return unit.get_format_name("console")
 
+    @classmethod
+    def _format_mantissa(cls, m):
+        return m
+
     @classmethod
     def _format_superscript(cls, number):
         return f"^{number}"
@@ -49,12 +246,13 @@ class Console(base.Base):
         return " ".join(out)
 
     @classmethod
+    @inspect_code
     def format_exponential_notation(cls, val):
         m, ex = utils.split_mantissa_exponent(val)
 
         parts = []
         if m:
-            parts.append(m)
+            parts.append(cls._format_mantissa(m))
 
         if ex:
             parts.append(f"10{cls._format_superscript(ex)}")
@@ -62,6 +260,7 @@ class Console(base.Base):
         return cls._times.join(parts)
 
     @classmethod
+    @inspect_code
     def to_string(cls, unit, inline=True):
         if isinstance(unit, core.CompositeUnit):
             if unit.scale == 1:
@@ -70,6 +269,8 @@ class Console(base.Base):
                 s = cls.format_exponential_notation(unit.scale)
 
             if len(unit.bases):
+                if s:
+                    s += " "
                 if inline:
                     nominator = zip(unit.bases, unit.powers)
                     denominator = []
@@ -84,7 +285,7 @@ class Console(base.Base):
                         nominator = "1"
                     denominator = cls._format_unit_list(denominator)
                     fraclength = max(len(nominator), len(denominator))
-                    f = f"{{0:^{len(s)}s}} {{1:^{fraclength}s}}"
+                    f = f"{{0:<{len(s)}s}}{{1:^{fraclength}s}}"
 
                     lines = [
                         f.format("", nominator),
diff --git a/astropy/units/format/latex.py b/astropy/units/format/latex.py
index b56262c..89e83ee 100644
--- a/astropy/units/format/latex.py
+++ b/astropy/units/format/latex.py
@@ -62,9 +62,11 @@ class Latex(base.Base):
             if unit.scale == 1:
                 s = ""
             else:
-                s = cls.format_exponential_notation(unit.scale) + r"\,"
+                s = cls.format_exponential_notation(unit.scale)
 
             if len(unit.bases):
+                if s:
+                    s += r"\,"
                 if inline:
                     nominator = zip(unit.bases, unit.powers)
                     denominator = []
diff --git a/astropy/units/format/unicode_format.py b/astropy/units/format/unicode_format.py
index 97d9205..e87ef01 100644
--- a/astropy/units/format/unicode_format.py
+++ b/astropy/units/format/unicode_format.py
@@ -5,7 +5,7 @@ Handles the "Unicode" unit format.
 """
 
 
-from . import console, utils
+from . import console
 
 
 class Unicode(console.Console):
@@ -17,7 +17,7 @@ class Unicode(console.Console):
 
       >>> import astropy.units as u
       >>> print(u.bar.decompose().to_string('unicode'))
-      100000kg m⁻¹ s⁻²
+      100000 kg m⁻¹ s⁻²
       >>> print(u.bar.decompose().to_string('unicode', inline=False))
               kg
       100000 ────
@@ -32,38 +32,28 @@ class Unicode(console.Console):
         return unit.get_format_name("unicode")
 
     @classmethod
-    def format_exponential_notation(cls, val):
-        m, ex = utils.split_mantissa_exponent(val)
-
-        parts = []
-        if m:
-            parts.append(m.replace("-", "−"))
-
-        if ex:
-            parts.append(f"10{cls._format_superscript(ex)}")
-
-        return cls._times.join(parts)
+    def _format_mantissa(cls, m):
+        return m.replace("-", "−")
 
     @classmethod
     def _format_superscript(cls, number):
-        mapping = {
-            "0": "⁰",
-            "1": "¹",
-            "2": "²",
-            "3": "³",
-            "4": "⁴",
-            "5": "⁵",
-            "6": "⁶",
-            "7": "⁷",
-            "8": "⁸",
-            "9": "⁹",
-            "-": "⁻",
-            "−": "⁻",
-            # This is actually a "raised omission bracket", but it's
-            # the closest thing I could find to a superscript solidus.
-            "/": "⸍",
-        }
-        output = []
-        for c in number:
-            output.append(mapping[c])
-        return "".join(output)
+        mapping = str.maketrans(
+            {
+                "0": "⁰",
+                "1": "¹",
+                "2": "²",
+                "3": "³",
+                "4": "⁴",
+                "5": "⁵",
+                "6": "⁶",
+                "7": "⁷",
+                "8": "⁸",
+                "9": "⁹",
+                "-": "⁻",
+                "−": "⁻",
+                # This is actually a "raised omission bracket", but it's
+                # the closest thing I could find to a superscript solidus.
+                "/": "⸍",
+            }
+        )
+        return number.translate(mapping)
diff --git a/astropy/units/tests/test_format.py b/astropy/units/tests/test_format.py
index 51ec90d..e18af54 100644
--- a/astropy/units/tests/test_format.py
+++ b/astropy/units/tests/test_format.py
@@ -425,38 +425,55 @@ def test_latex_scale():
 
 def test_latex_inline_scale():
     fluxunit = u.Unit(1.0e-24 * u.erg / (u.cm**2 * u.s * u.Hz))
-    latex_inline = r"$\mathrm{1 \times 10^{-24}\,erg" r"\,Hz^{-1}\,s^{-1}\,cm^{-2}}$"
+    latex_inline = r"$\mathrm{1 \times 10^{-24}\,erg\,Hz^{-1}\,s^{-1}\,cm^{-2}}$"
     assert fluxunit.to_string("latex_inline") == latex_inline
 
 
 @pytest.mark.parametrize(
-    "format_spec, string",
+    "format_spec, string, decomposed",
     [
-        ("generic", "erg / (cm2 s)"),
-        ("s", "erg / (cm2 s)"),
-        ("console", "erg s^-1 cm^-2"),
-        ("latex", "$\\mathrm{\\frac{erg}{s\\,cm^{2}}}$"),
-        ("latex_inline", "$\\mathrm{erg\\,s^{-1}\\,cm^{-2}}$"),
-        ("unicode", "erg s⁻¹ cm⁻²"),
-        (">20s", "       erg / (cm2 s)"),
+        ("generic", "erg / (cm2 s)", "0.001 kg / s3"),
+        ("s", "erg / (cm2 s)", "0.001 kg / s3"),
+        ("console", "erg s^-1 cm^-2", "0.001 kg s^-3"),
+        (
+            "latex",
+            r"$\mathrm{\frac{erg}{s\,cm^{2}}}$",
+            r"$\mathrm{0.001\,\frac{kg}{s^{3}}}$",
+        ),
+        (
+            "latex_inline",
+            r"$\mathrm{erg\,s^{-1}\,cm^{-2}}$",
+            r"$\mathrm{0.001\,kg\,s^{-3}}$",
+        ),
+        ("unicode", "erg s⁻¹ cm⁻²", "0.001 kg s⁻³"),
+        (">20s", "       erg / (cm2 s)", "       0.001 kg / s3"),
     ],
 )
-def test_format_styles(format_spec, string):
+def test_format_styles(format_spec, string, decomposed):
     fluxunit = u.erg / (u.cm**2 * u.s)
     assert format(fluxunit, format_spec) == string
+    # Decomposed mostly to test that scale factors are dealt with properly
+    # in the various formats.
+    assert format(fluxunit.decompose(), format_spec) == decomposed
 
 
 @pytest.mark.parametrize(
-    "format_spec, inline, string",
+    "format_spec, inline, string, decomposed",
     [
-        ("console", False, "  erg  \n ------\n s cm^2"),
-        ("unicode", False, "  erg \n ─────\n s cm²"),
-        ("latex", True, "$\\mathrm{erg\\,s^{-1}\\,cm^{-2}}$"),
+        ("console", False, " erg  \n------\ns cm^2", "      kg \n0.001 ---\n      s^3"),
+        ("unicode", False, " erg \n─────\ns cm²", "      kg\n0.001 ──\n      s³"),
+        (
+            "latex",
+            True,
+            r"$\mathrm{erg\,s^{-1}\,cm^{-2}}$",
+            r"$\mathrm{0.001\,kg\,s^{-3}}$",
+        ),
     ],
 )
-def test_format_styles_inline(format_spec, inline, string):
+def test_format_styles_inline(format_spec, inline, string, decomposed):
     fluxunit = u.erg / (u.cm**2 * u.s)
     assert fluxunit.to_string(format_spec, inline=inline) == string
+    assert fluxunit.decompose().to_string(format_spec, inline=inline) == decomposed
 
 
 def test_flatten_to_known():
@@ -479,6 +496,21 @@ def test_console_out():
     u.Jy.decompose().to_string("console")
 
 
+@pytest.mark.parametrize(
+    "format,string",
+    [
+        ("generic", "10"),
+        ("console", "10"),
+        ("unicode", "10"),
+        ("cds", "10"),
+        ("latex", r"$\mathrm{10}$"),
+    ],
+)
+def test_scale_only(format, string):
+    unit = u.Unit(10)
+    assert unit.to_string(format) == string
+
+
 def test_flexible_float():
     assert u.min._represents.to_string("latex") == r"$\mathrm{60\,s}$"
 
@@ -840,8 +872,8 @@ def test_function_format_styles(format_spec, string):
 @pytest.mark.parametrize(
     "format_spec, inline, string",
     [
-        ("console", False, "    1\ndB( -)\n    m"),
-        ("unicode", False, "    1\ndB( ─)\n    m"),
+        ("console", False, "   1\ndB(-)\n   m"),
+        ("unicode", False, "   1\ndB(─)\n   m"),
         ("latex", True, r"$\mathrm{dB}$$\mathrm{\left( \mathrm{m^{-1}} \right)}$"),
     ],
 )
