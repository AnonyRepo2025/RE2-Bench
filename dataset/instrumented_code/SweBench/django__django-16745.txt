diff --git a/django/core/validators.py b/django/core/validators.py
index 6c622f5..0f6515f 100644
--- a/django/core/validators.py
+++ b/django/core/validators.py
@@ -397,8 +397,37 @@ class StepValueValidator(BaseValidator):
     message = _("Ensure this value is a multiple of step size %(limit_value)s.")
     code = "step_size"
 
+    def __init__(self, limit_value, message=None, offset=None):
+        super().__init__(limit_value, message)
+        if offset is not None:
+            self.message = _(
+                "Ensure this value is a multiple of step size %(limit_value)s, "
+                "starting from %(offset)s, e.g. %(offset)s, %(valid_value1)s, "
+                "%(valid_value2)s, and so on."
+            )
+        self.offset = offset
+
+    def __call__(self, value):
+        if self.offset is None:
+            super().__call__(value)
+        else:
+            cleaned = self.clean(value)
+            limit_value = (
+                self.limit_value() if callable(self.limit_value) else self.limit_value
+            )
+            if self.compare(cleaned, limit_value):
+                offset = cleaned.__class__(self.offset)
+                params = {
+                    "limit_value": limit_value,
+                    "offset": offset,
+                    "valid_value1": offset + limit_value,
+                    "valid_value2": offset + 2 * limit_value,
+                }
+                raise ValidationError(self.message, code=self.code, params=params)
+
     def compare(self, a, b):
-        return not math.isclose(math.remainder(a, b), 0, abs_tol=1e-9)
+        offset = 0 if self.offset is None else self.offset
+        return not math.isclose(math.remainder(a - offset, b), 0, abs_tol=1e-9)
 
 
 @deconstructible
diff --git a/django/forms/fields.py b/django/forms/fields.py
index d759da7..cb44ad1 100644
--- a/django/forms/fields.py
+++ b/django/forms/fields.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/django__django-16745/django/forms/fields.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 """
 Field classes.
 """
@@ -304,6 +497,7 @@ class IntegerField(Field):
     }
     re_decimal = _lazy_re_compile(r"\.0*\s*$")
 
+    @inspect_code
     def __init__(self, *, max_value=None, min_value=None, step_size=None, **kwargs):
         self.max_value, self.min_value, self.step_size = max_value, min_value, step_size
         if kwargs.get("localize") and self.widget == NumberInput:
@@ -316,7 +510,9 @@ class IntegerField(Field):
         if min_value is not None:
             self.validators.append(validators.MinValueValidator(min_value))
         if step_size is not None:
-            self.validators.append(validators.StepValueValidator(step_size))
+            self.validators.append(
+                validators.StepValueValidator(step_size, offset=min_value)
+            )
 
     def to_python(self, value):
         """
diff --git a/tests/forms_tests/field_tests/test_decimalfield.py b/tests/forms_tests/field_tests/test_decimalfield.py
index 4e24d55..9d26bc8 100644
--- a/tests/forms_tests/field_tests/test_decimalfield.py
+++ b/tests/forms_tests/field_tests/test_decimalfield.py
@@ -152,6 +152,25 @@ class DecimalFieldTest(FormFieldAssertionsMixin, SimpleTestCase):
         with self.assertRaisesMessage(ValidationError, msg):
             f.clean("1.1")
 
+    def test_decimalfield_step_size_min_value(self):
+        f = DecimalField(
+            step_size=decimal.Decimal("0.3"),
+            min_value=decimal.Decimal("-0.4"),
+        )
+        self.assertWidgetRendersTo(
+            f,
+            '<input name="f" min="-0.4" step="0.3" type="number" id="id_f" required>',
+        )
+        msg = (
+            "Ensure this value is a multiple of step size 0.3, starting from -0.4, "
+            "e.g. -0.4, -0.1, 0.2, and so on."
+        )
+        with self.assertRaisesMessage(ValidationError, msg):
+            f.clean("1")
+        self.assertEqual(f.clean("0.2"), decimal.Decimal("0.2"))
+        self.assertEqual(f.clean(2), decimal.Decimal(2))
+        self.assertEqual(f.step_size, decimal.Decimal("0.3"))
+
     def test_decimalfield_scientific(self):
         f = DecimalField(max_digits=4, decimal_places=2)
         with self.assertRaisesMessage(ValidationError, "Ensure that there are no more"):
diff --git a/tests/forms_tests/field_tests/test_floatfield.py b/tests/forms_tests/field_tests/test_floatfield.py
index 276520f..77b4041 100644
--- a/tests/forms_tests/field_tests/test_floatfield.py
+++ b/tests/forms_tests/field_tests/test_floatfield.py
@@ -84,6 +84,18 @@ class FloatFieldTest(FormFieldAssertionsMixin, SimpleTestCase):
         self.assertEqual(-1.26, f.clean("-1.26"))
         self.assertEqual(f.step_size, 0.02)
 
+    def test_floatfield_step_size_min_value(self):
+        f = FloatField(step_size=0.02, min_value=0.01)
+        msg = (
+            "Ensure this value is a multiple of step size 0.02, starting from 0.01, "
+            "e.g. 0.01, 0.03, 0.05, and so on."
+        )
+        with self.assertRaisesMessage(ValidationError, msg):
+            f.clean("0.02")
+        self.assertEqual(f.clean("2.33"), 2.33)
+        self.assertEqual(f.clean("0.11"), 0.11)
+        self.assertEqual(f.step_size, 0.02)
+
     def test_floatfield_widget_attrs(self):
         f = FloatField(widget=NumberInput(attrs={"step": 0.01, "max": 1.0, "min": 0.0}))
         self.assertWidgetRendersTo(
diff --git a/tests/forms_tests/field_tests/test_integerfield.py b/tests/forms_tests/field_tests/test_integerfield.py
index 1361b5c..a76c2fd 100644
--- a/tests/forms_tests/field_tests/test_integerfield.py
+++ b/tests/forms_tests/field_tests/test_integerfield.py
@@ -126,6 +126,22 @@ class IntegerFieldTest(FormFieldAssertionsMixin, SimpleTestCase):
         self.assertEqual(12, f.clean("12"))
         self.assertEqual(f.step_size, 3)
 
+    def test_integerfield_step_size_min_value(self):
+        f = IntegerField(step_size=3, min_value=-1)
+        self.assertWidgetRendersTo(
+            f,
+            '<input name="f" min="-1" step="3" type="number" id="id_f" required>',
+        )
+        msg = (
+            "Ensure this value is a multiple of step size 3, starting from -1, e.g. "
+            "-1, 2, 5, and so on."
+        )
+        with self.assertRaisesMessage(ValidationError, msg):
+            f.clean("9")
+        self.assertEqual(f.clean("2"), 2)
+        self.assertEqual(f.clean("-1"), -1)
+        self.assertEqual(f.step_size, 3)
+
     def test_integerfield_localized(self):
         """
         A localized IntegerField's widget renders to a text input without any
diff --git a/tests/validators/tests.py b/tests/validators/tests.py
index 02bee30..af08a78 100644
--- a/tests/validators/tests.py
+++ b/tests/validators/tests.py
@@ -451,11 +451,39 @@ TEST_DATA = [
     (StepValueValidator(3), 1, ValidationError),
     (StepValueValidator(3), 8, ValidationError),
     (StepValueValidator(3), 9, None),
+    (StepValueValidator(2), 4, None),
+    (StepValueValidator(2, offset=1), 3, None),
+    (StepValueValidator(2, offset=1), 4, ValidationError),
     (StepValueValidator(0.001), 0.55, None),
     (StepValueValidator(0.001), 0.5555, ValidationError),
+    (StepValueValidator(0.001, offset=0.0005), 0.5555, None),
+    (StepValueValidator(0.001, offset=0.0005), 0.555, ValidationError),
     (StepValueValidator(Decimal(0.02)), 0.88, None),
     (StepValueValidator(Decimal(0.02)), Decimal(0.88), None),
     (StepValueValidator(Decimal(0.02)), Decimal(0.77), ValidationError),
+    (StepValueValidator(Decimal(0.02), offset=Decimal(0.01)), Decimal(0.77), None),
+    (StepValueValidator(Decimal(2.0), offset=Decimal(0.1)), Decimal(0.1), None),
+    (
+        StepValueValidator(Decimal(0.02), offset=Decimal(0.01)),
+        Decimal(0.88),
+        ValidationError,
+    ),
+    (StepValueValidator(Decimal("1.2"), offset=Decimal("2.2")), Decimal("3.4"), None),
+    (
+        StepValueValidator(Decimal("1.2"), offset=Decimal("2.2")),
+        Decimal("1.2"),
+        ValidationError,
+    ),
+    (
+        StepValueValidator(Decimal("-1.2"), offset=Decimal("2.2")),
+        Decimal("1.1"),
+        ValidationError,
+    ),
+    (
+        StepValueValidator(Decimal("-1.2"), offset=Decimal("2.2")),
+        Decimal("1.0"),
+        None,
+    ),
     (URLValidator(EXTENDED_SCHEMES), "file://localhost/path", None),
     (URLValidator(EXTENDED_SCHEMES), "git://example.com/", None),
     (
