diff --git a/sympy/geometry/ellipse.py b/sympy/geometry/ellipse.py
index 93766e2..b5f0191 100644
--- a/sympy/geometry/ellipse.py
+++ b/sympy/geometry/ellipse.py
@@ -7,11 +7,205 @@
 """
 
 from __future__ import division, print_function
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-15273/sympy/geometry/ellipse.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
+from sympy import Expr, Eq
 from sympy.core import S, pi, sympify
 from sympy.core.logic import fuzzy_bool
 from sympy.core.numbers import Rational, oo
-from sympy.core.compatibility import range, ordered
+from sympy.core.compatibility import ordered
 from sympy.core.symbol import Dummy, _uniquely_named_symbol, _symbol
 from sympy.simplify import simplify, trigsimp
 from sympy.functions.elementary.miscellaneous import sqrt
@@ -22,6 +216,7 @@
 from sympy.polys import DomainError, Poly, PolynomialError
 from sympy.polys.polyutils import _not_a_coeff, _nsort
 from sympy.solvers import solve
+from sympy.solvers.solveset import linear_coeffs
 from sympy.utilities.misc import filldedent, func_name
 
 from .entity import GeometryEntity, GeometrySet
@@ -112,15 +307,15 @@ def __contains__(self, o):
     def __eq__(self, o):
         """Is the other GeometryEntity the same as this ellipse?"""
         return isinstance(o, Ellipse) and (self.center == o.center and
-                                                  self.hradius == o.hradius and
-                                                  self.vradius == o.vradius)
+                                           self.hradius == o.hradius and
+                                           self.vradius == o.vradius)
 
     def __hash__(self):
         return super(Ellipse, self).__hash__()
 
+    @inspect_code
     def __new__(
-        cls, center=None, hradius=None, vradius=None, eccentricity=None,
-            **kwargs):
+        cls, center=None, hradius=None, vradius=None, eccentricity=None, **kwargs):
         hradius = sympify(hradius)
         vradius = sympify(vradius)
 
@@ -135,8 +330,9 @@ def __new__(
             raise ValueError('The center of "{0}" must be a two dimensional point'.format(cls))
 
         if len(list(filter(lambda x: x is not None, (hradius, vradius, eccentricity)))) != 2:
-            raise ValueError('Exactly two arguments of "hradius", '
-                '"vradius", and "eccentricity" must not be None."')
+            raise ValueError(filldedent('''
+                Exactly two arguments of "hradius", "vradius", and
+                "eccentricity" must not be None.'''))
 
         if eccentricity is not None:
             if hradius is None:
@@ -149,6 +345,7 @@ def __new__(
 
         return GeometryEntity.__new__(cls, center, hradius, vradius, **kwargs)
 
+    @inspect_code
     def _svg(self, scale_factor=1., fill_color="#66cc99"):
         """Returns SVG ellipse element for the Ellipse.
 
@@ -168,7 +365,7 @@ def _svg(self, scale_factor=1., fill_color="#66cc99"):
         return (
             '<ellipse fill="{1}" stroke="#555555" '
             'stroke-width="{0}" opacity="0.6" cx="{2}" cy="{3}" rx="{4}" ry="{5}"/>'
-            ).format(2. * scale_factor, fill_color, c.x, c.y, h, v)
+        ).format(2. * scale_factor, fill_color, c.x, c.y, h, v)
 
     @property
     def ambient_dimension(self):
@@ -202,6 +399,7 @@ def apoapsis(self):
         """
         return self.major * (1 + self.eccentricity)
 
+    @inspect_code
     def arbitrary_point(self, parameter='t'):
         """A parameterized point on the ellipse.
 
@@ -239,7 +437,7 @@ def arbitrary_point(self, parameter='t'):
         t = _symbol(parameter, real=True)
         if t.name in (f.name for f in self.free_symbols):
             raise ValueError(filldedent('Symbol %s already appears in object '
-                'and cannot be used as a parameter.' % t.name))
+                                        'and cannot be used as a parameter.' % t.name))
         return Point(self.center.x + self.hradius*cos(t),
                      self.center.y + self.vradius*sin(t))
 
@@ -316,12 +514,12 @@ def circumference(self):
         """
         if self.eccentricity == 1:
             # degenerate
-            return 4 * self.major
+            return 4*self.major
         elif self.eccentricity == 0:
             # circle
-            return 2 * pi * self.hradius
+            return 2*pi*self.hradius
         else:
-            return 4 * self.major * elliptic_e(self.eccentricity**2)
+            return 4*self.major*elliptic_e(self.eccentricity**2)
 
     @property
     def eccentricity(self):
@@ -564,6 +762,7 @@ def hradius(self):
         """
         return self.args[1]
 
+    @inspect_code
     def intersection(self, o):
         """The intersection of this ellipse and another geometrical entity
         `o`.
@@ -640,10 +839,11 @@ def intersection(self, o):
                 ellipse_equation = self.equation(x, y)
                 return list(ordered([Point(i) for i in solve([ellipse_equation, o.equation(x, y)], [x, y])]))
         elif isinstance(o, LinearEntity3D):
-                raise TypeError('Entity must be two dimensional, not three dimensional')
+            raise TypeError('Entity must be two dimensional, not three dimensional')
         else:
             raise TypeError('Intersection not handled for %s' % func_name(o))
 
+    @inspect_code
     def is_tangent(self, o):
         """Is `o` tangent to the ellipse?
 
@@ -705,8 +905,8 @@ def is_tangent(self, o):
             for segment in segments:
                 intersect = self.intersection(segment)
                 if len(intersect) == 1:
-                    if not any(intersect[0] in i for i in segment.points)\
-                                   and all(not self.encloses_point(i) for i in segment.points):
+                    if not any(intersect[0] in i for i in segment.points) \
+                        and all(not self.encloses_point(i) for i in segment.points):
                         all_tangents = True
                         continue
                     else:
@@ -813,6 +1013,7 @@ def minor(self):
             return b
         return self.vradius
 
+    @inspect_code
     def normal_lines(self, p, prec=None):
         """Normal lines between `p` and the ellipse.
 
@@ -892,8 +1093,7 @@ def normal_lines(self, p, prec=None):
         if prec is not None:
             points = [pt.n(prec) for pt in points]
             slopes = [i if _not_a_coeff(i) else i.n(prec) for i in slopes]
-        return [Line(pt, slope=s) for pt,s in zip(points, slopes)]
-
+        return [Line(pt, slope=s) for pt, s in zip(points, slopes)]
 
     @property
     def periapsis(self):
@@ -923,7 +1123,6 @@ def periapsis(self):
         """
         return self.major * (1 - self.eccentricity)
 
-
     @property
     def semilatus_rectum(self):
         """
@@ -962,7 +1161,6 @@ def semilatus_rectum(self):
         """
         return self.major * (1 - self.eccentricity ** 2)
 
-
     def plot_interval(self, parameter='t'):
         """The plot interval for the default geometric plot of the Ellipse.
 
@@ -1047,6 +1245,7 @@ def random_point(self, seed=None):
         s = sqrt(1 - c**2)
         return Point(x.subs(cos(t), c), y.subs(sin(t), s))
 
+    @inspect_code
     def reflect(self, line):
         """Override GeometryEntity.reflect since the radius
         is not a GeometryEntity.
@@ -1085,7 +1284,7 @@ def reflect(self, line):
             expr = self.equation(x, y)
             p = Point(x, y).reflect(line)
             result = expr.subs(zip((x, y), p.args
-                               ), simultaneous=True)
+                                   ), simultaneous=True)
             raise NotImplementedError(filldedent(
                 'General Ellipse is not supported but the equation '
                 'of the reflected Ellipse is given by the zeros of: ' +
@@ -1115,7 +1314,6 @@ def rotate(self, angle=0, pt=None):
         # XXX see https://github.com/sympy/sympy/issues/2815 for general ellipes
         raise NotImplementedError('Only rotations of pi/2 are currently supported for Ellipse.')
 
-
     def scale(self, x=1, y=1, pt=None):
         """Override GeometryEntity.scale since it is the major and minor
         axes which must be scaled and they are not GeometryEntities.
@@ -1137,7 +1335,7 @@ def scale(self, x=1, y=1, pt=None):
         v = self.vradius
         return self.func(c.scale(x, y), hradius=h*x, vradius=v*y)
 
-
+    @inspect_code
     def tangent_lines(self, p):
         """Tangent lines between `p` and the ellipse.
 
@@ -1181,8 +1379,8 @@ def tangent_lines(self, p):
 
         if p in self:
             delta = self.center - p
-            rise = (self.vradius ** 2)*delta.x
-            run = -(self.hradius ** 2)*delta.y
+            rise = (self.vradius**2)*delta.x
+            run = -(self.hradius**2)*delta.y
             p2 = Point(simplify(p.x + run),
                        simplify(p.y + rise))
             return [Line(p, p2)]
@@ -1211,7 +1409,7 @@ def tangent_lines(self, p):
             # handle horizontal and vertical tangent lines
             if len(tangent_points) == 1:
                 assert tangent_points[0][
-                    0] == p.x or tangent_points[0][1] == p.y
+                           0] == p.x or tangent_points[0][1] == p.y
                 return [Line(p, p + Point(1, 0)), Line(p, p + Point(0, 1))]
 
             # others
@@ -1243,7 +1441,6 @@ def vradius(self):
         """
         return self.args[2]
 
-
     def second_moment_of_area(self, point=None):
         """Returns the second moment and product moment area of an ellipse.
 
@@ -1296,8 +1493,8 @@ def second_moment_of_area(self, point=None):
 class Circle(Ellipse):
     """A circle in space.
 
-    Constructed simply from a center and a radius, or from three
-    non-collinear points.
+    Constructed simply from a center and a radius, from three
+    non-collinear points, or the equation of a circle.
 
     Parameters
     ==========
@@ -1305,6 +1502,7 @@ class Circle(Ellipse):
     center : Point
     radius : number or sympy expression
     points : sequence of three Points
+    equation : equation of a circle
 
     Attributes
     ==========
@@ -1317,7 +1515,7 @@ class Circle(Ellipse):
     ======
 
     GeometryError
-        When trying to construct circle from three collinear points.
+        When the given equation is not that of a circle.
         When trying to construct circle from incorrect parameters.
 
     See Also
@@ -1328,41 +1526,84 @@ class Circle(Ellipse):
     Examples
     ========
 
+    >>> from sympy import Eq
     >>> from sympy.geometry import Point, Circle
-    >>> # a circle constructed from a center and radius
+    >>> from sympy.abc import x, y, a, b
+
+    A circle constructed from a center and radius:
+
     >>> c1 = Circle(Point(0, 0), 5)
     >>> c1.hradius, c1.vradius, c1.radius
     (5, 5, 5)
 
-    >>> # a circle constructed from three points
+    A circle constructed from three points:
+
     >>> c2 = Circle(Point(0, 0), Point(1, 1), Point(1, 0))
     >>> c2.hradius, c2.vradius, c2.radius, c2.center
     (sqrt(2)/2, sqrt(2)/2, sqrt(2)/2, Point2D(1/2, 1/2))
 
+    A circle can be constructed from an equation in the form
+    `a*x**2 + by**2 + gx + hy + c = 0`, too:
+
+    >>> Circle(x**2 + y**2 - 25)
+    Circle(Point2D(0, 0), 5)
+
+    If the variables corresponding to x and y are named something
+    else, their name or symbol can be supplied:
+
+    >>> Circle(Eq(a**2 + b**2, 25), x='a', y=b)
+    Circle(Point2D(0, 0), 5)
     """
 
     def __new__(cls, *args, **kwargs):
-        c, r = None, None
-        if len(args) == 3:
-            args = [Point(a, dim=2) for a in args]
-            if Point.is_collinear(*args):
-                raise GeometryError(
-                    "Cannot construct a circle from three collinear points")
-            from .polygon import Triangle
-            t = Triangle(*args)
-            c = t.circumcenter
-            r = t.circumradius
-        elif len(args) == 2:
-            # Assume (center, radius) pair
-            c = Point(args[0], dim=2)
-            r = sympify(args[1])
-
-        if not (c is None or r is None):
-            if r == 0:
-                return c
-            return GeometryEntity.__new__(cls, c, r, **kwargs)
-
-        raise GeometryError("Circle.__new__ received unknown arguments")
+        from sympy.geometry.util import find
+        from .polygon import Triangle
+
+        if len(args) == 1 and isinstance(args[0], Expr):
+            x = kwargs.get('x', 'x')
+            y = kwargs.get('y', 'y')
+            equation = args[0]
+            if isinstance(equation, Eq):
+                equation = equation.lhs - equation.rhs
+            x = find(x, equation)
+            y = find(y, equation)
+
+            try:
+                co = linear_coeffs(equation, x**2, y**2, x, y)
+            except ValueError:
+                raise GeometryError("The given equation is not that of a circle.")
+
+            a, b, c, d, e = [co[i] for i in (x**2, y**2, x, y, 0)]
+
+            if a == 0 or b == 0 or a != b:
+                raise GeometryError("The given equation is not that of a circle.")
+
+            center_x = -c/a/2
+            center_y = -d/b/2
+            r2 = (center_x**2) + (center_y**2) - e
+
+            return Circle((center_x, center_y), sqrt(r2))
+
+        else:
+            c, r = None, None
+            if len(args) == 3:
+                args = [Point(a, dim=2) for a in args]
+                t = Triangle(*args)
+                if not isinstance(t, Triangle):
+                    return t
+                c = t.circumcenter
+                r = t.circumradius
+            elif len(args) == 2:
+                # Assume (center, radius) pair
+                c = Point(args[0], dim=2)
+                r = sympify(args[1])
+
+            if not (c is None or r is None):
+                if r == 0:
+                    return c
+                return GeometryEntity.__new__(cls, c, r, **kwargs)
+
+            raise GeometryError("Circle.__new__ received unknown arguments")
 
     @property
     def circumference(self):
diff --git a/sympy/geometry/line.py b/sympy/geometry/line.py
index 1411bdd..1d63a33 100644
--- a/sympy/geometry/line.py
+++ b/sympy/geometry/line.py
@@ -18,11 +18,11 @@
 """
 from __future__ import division, print_function
 
-import warnings
 
+from sympy import Expr
 from sympy.core import S, sympify
 from sympy.core.compatibility import ordered
-from sympy.core.numbers import Rational
+from sympy.core.numbers import Rational, oo
 from sympy.core.relational import Eq
 from sympy.core.symbol import _symbol, Dummy
 from sympy.functions.elementary.trigonometric import (_pi_coeff as pi_coeff, acos, tan, atan2)
@@ -34,7 +34,7 @@
 from sympy.core.decorators import deprecated
 from sympy.sets import Intersection
 from sympy.matrices import Matrix
-
+from sympy.solvers.solveset import linear_coeffs
 from .entity import GeometryEntity, GeometrySet
 from .point import Point, Point3D
 from sympy.utilities.misc import Undecidable, filldedent
@@ -1031,9 +1031,8 @@ def random_point(self, seed=None):
 class Line(LinearEntity):
     """An infinite line in space.
 
-    A line is declared with two distinct points.
-    A 2D line may be declared with a point and slope
-    and a 3D line may be defined with a point and a direction ratio.
+    A 2D line is declared with two distinct points, point and slope, or
+    an equation. A 3D line may be defined with a point and a direction ratio.
 
     Parameters
     ==========
@@ -1042,6 +1041,7 @@ class Line(LinearEntity):
     p2 : Point
     slope : sympy expression
     direction_ratio : list
+    equation : equation of a line
 
     Notes
     =====
@@ -1061,8 +1061,10 @@ class Line(LinearEntity):
     Examples
     ========
 
-    >>> from sympy import Point
+    >>> from sympy import Point, Eq
     >>> from sympy.geometry import Line, Segment
+    >>> from sympy.abc import x, y, a, b
+
     >>> L = Line(Point(2,3), Point(3,5))
     >>> L
     Line2D(Point2D(2, 3), Point2D(3, 5))
@@ -1083,24 +1085,65 @@ class Line(LinearEntity):
     >>> s = Segment((0, 0), (0, 1))
     >>> Line(s).equation()
     x
+
+    The line corresponding to an equation in the for `ax + by + c = 0`,
+    can be entered:
+
+    >>> Line(3*x + y + 18)
+    Line2D(Point2D(0, -18), Point2D(1, -21))
+
+    If `x` or `y` has a different name, then they can be specified, too,
+    as a string (to match the name) or symbol:
+
+    >>> Line(Eq(3*a + b, -18), x='a', y=b)
+    Line2D(Point2D(0, -18), Point2D(1, -21))
     """
 
-    def __new__(cls, p1, p2=None, **kwargs):
-        if isinstance(p1, LinearEntity):
-            if p2:
-                raise ValueError('If p1 is a LinearEntity, p2 must be None.')
-            dim = len(p1.p1)
-        else:
-            p1 = Point(p1)
-            dim = len(p1)
-            if p2 is not None or isinstance(p2, Point) and p2.ambient_dimension != dim:
-                p2 = Point(p2)
+    def __new__(cls, *args, **kwargs):
+        from sympy.geometry.util import find
 
-        if dim == 2:
-            return Line2D(p1, p2, **kwargs)
-        elif dim == 3:
-            return Line3D(p1, p2, **kwargs)
-        return LinearEntity.__new__(cls, p1, p2, **kwargs)
+        if len(args) == 1 and isinstance(args[0], Expr):
+            x = kwargs.get('x', 'x')
+            y = kwargs.get('y', 'y')
+            equation = args[0]
+            if isinstance(equation, Eq):
+                equation = equation.lhs - equation.rhs
+            xin, yin = x, y
+            x = find(x, equation) or Dummy()
+            y = find(y, equation) or Dummy()
+
+            co = linear_coeffs(equation, x, y)
+            a, b, c = [co[i] for i in (x, y, 0)]
+
+            if b:
+                return Line((0, -c/b), slope=-a/b)
+            if a:
+                return Line((-c/a, 0), slope=oo)
+            raise ValueError('neither %s nor %s were found in the equation' % (xin, yin))
+
+        else:
+            if len(args) > 0:
+                p1 = args[0]
+                if len(args) > 1:
+                    p2 = args[1]
+                else:
+                    p2=None
+
+                if isinstance(p1, LinearEntity):
+                    if p2:
+                        raise ValueError('If p1 is a LinearEntity, p2 must be None.')
+                    dim = len(p1.p1)
+                else:
+                    p1 = Point(p1)
+                    dim = len(p1)
+                    if p2 is not None or isinstance(p2, Point) and p2.ambient_dimension != dim:
+                        p2 = Point(p2)
+
+                if dim == 2:
+                    return Line2D(p1, p2, **kwargs)
+                elif dim == 3:
+                    return Line3D(p1, p2, **kwargs)
+                return LinearEntity.__new__(cls, p1, p2, **kwargs)
 
     def contains(self, other):
         """
diff --git a/sympy/geometry/tests/test_ellipse.py b/sympy/geometry/tests/test_ellipse.py
index 01756ff..1a69bc4 100644
--- a/sympy/geometry/tests/test_ellipse.py
+++ b/sympy/geometry/tests/test_ellipse.py
@@ -1,14 +1,32 @@
 from __future__ import division
 
-from sympy import Dummy, Rational, S, Symbol, symbols, pi, sqrt, oo
+from sympy import Rational, S, Symbol, symbols, pi, sqrt, oo, Point2D, Segment2D, I
 from sympy.core.compatibility import range
 from sympy.geometry import (Circle, Ellipse, GeometryError, Line, Point, Polygon, Ray, RegularPolygon, Segment,
                             Triangle, intersection)
-from sympy.integrals.integrals import Integral
-from sympy.utilities.pytest import raises, slow
+from sympy.utilities.pytest import raises
 from sympy import integrate
 from sympy.functions.special.elliptic_integrals import elliptic_e
 
+def test_object_from_equation():
+    from sympy.abc import x, y, a, b
+    assert Circle(x**2 + y**2 + 3*x + 4*y - 8) == Circle(Point2D(S(-3) / 2, -2),
+                                                                                      sqrt(57) / 2)
+    assert Circle(x**2 + y**2 + 6*x + 8*y + 25) == Circle(Point2D(-3, -4), 0)
+    assert Circle(a**2 + b**2 + 6*a + 8*b + 25, x='a', y='b') == Circle(Point2D(-3, -4), 0)
+    assert Circle(x**2 + y**2 - 25) == Circle(Point2D(0, 0), 5)
+    assert Circle(x**2 + y**2) == Circle(Point2D(0, 0), 0)
+    assert Circle(a**2 + b**2, x='a', y='b') == Circle(Point2D(0, 0), 0)
+    assert Circle(x**2 + y**2 + 6*x + 8) == Circle(Point2D(-3, 0), 1)
+    assert Circle(x**2 + y**2 + 6*y + 8) == Circle(Point2D(0, -3), 1)
+    assert Circle(6*(x**2) + 6*(y**2) + 6*x + 8*y - 25) == Circle(Point2D(-1/2, -2/3), 5*sqrt(37)/6)
+    assert Circle(x**2 + y**2 + 3*x + 4*y + 26) == Circle(Point2D(-3/2, -2), sqrt(79)*I/2)
+    assert Circle(x**2 + y**2 + 25) == Circle(Point2D(0, 0), 5*I)
+    assert Circle(a**2 + b**2 + 25, x='a', y='b') == Circle(Point2D(0, 0), 5*I)
+    raises(GeometryError, lambda: Circle(x**2 + 6*y + 8))
+    raises(GeometryError, lambda: Circle(6*(x ** 2) + 4*(y**2) + 6*x + 8*y + 25))
+    raises(ValueError, lambda: Circle(a**2 + b**2 + 3*a + 4*b - 8))
+
 
 def test_ellipse_geom():
     x = Symbol('x', real=True)
@@ -31,8 +49,7 @@ def test_ellipse_geom():
     # Test creation with three points
     cen, rad = Point(3*half, 2), 5*half
     assert Circle(Point(0, 0), Point(3, 0), Point(0, 4)) == Circle(cen, rad)
-    raises(
-        GeometryError, lambda: Circle(Point(0, 0), Point(1, 1), Point(2, 2)))
+    assert Circle(Point(0, 0), Point(1, 1), Point(2, 2)) == Segment2D(Point2D(0, 0), Point2D(2, 2))
 
     raises(ValueError, lambda: Ellipse(None, None, None, 1))
     raises(GeometryError, lambda: Circle(Point(0, 0)))
diff --git a/sympy/geometry/tests/test_line.py b/sympy/geometry/tests/test_line.py
index b70523f..713e6bf 100644
--- a/sympy/geometry/tests/test_line.py
+++ b/sympy/geometry/tests/test_line.py
@@ -38,6 +38,22 @@ def warn_with_traceback(message, category, filename, lineno, file=None, line=Non
 warnings.simplefilter('always', UserWarning)  # make sure to show warnings every time they occur
 
 
+def test_object_from_equation():
+    from sympy.abc import x, y, a, b
+    assert Line(3*x + y + 18) == Line2D(Point2D(0, -18), Point2D(1, -21))
+    assert Line(3*x + 5 * y + 1) == Line2D(Point2D(0, -1/5), Point2D(1, -4/5))
+    assert Line(3*a + b + 18, x='a', y='b') == Line2D(Point2D(0, -18), Point2D(1, -21))
+    assert Line(3*x + y) == Line2D(Point2D(0, 0), Point2D(1, -3))
+    assert Line(x + y) == Line2D(Point2D(0, 0), Point2D(1, -1))
+    raises(ValueError, lambda: Line(x))
+    raises(ValueError, lambda: Line(y))
+    raises(ValueError, lambda: Line(x/y))
+    raises(ValueError, lambda: Line(a/b, x='a', y='b'))
+    raises(ValueError, lambda: Line(y/x))
+    raises(ValueError, lambda: Line(b/a, x='a', y='b'))
+    raises(ValueError, lambda: Line((x + 1)**2 + y))
+
+
 def feq(a, b):
     """Test if two floating point values are 'equal'."""
     t_float = Float("1.0E-10")
@@ -52,7 +68,7 @@ def test_angle_between():
                                   Line(Point(0, 0), Point(5, 0))).evalf(), pi.evalf() / 4)
     assert Line(a, o).angle_between(Line(b, o)) == pi / 2
     assert Line3D.angle_between(Line3D(Point3D(0, 0, 0), Point3D(1, 1, 1)),
-                                Line3D(Point3D(0, 0, 0), Point3D(5, 0, 0))), acos(sqrt(3) / 3)
+                                Line3D(Point3D(0, 0, 0), Point3D(5, 0, 0))) == acos(sqrt(3) / 3)
 
 
 def test_closing_angle():
diff --git a/sympy/geometry/util.py b/sympy/geometry/util.py
index 03a0576..a1e8c07 100644
--- a/sympy/geometry/util.py
+++ b/sympy/geometry/util.py
@@ -11,6 +11,199 @@
 
 """
 from __future__ import division, print_function
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-15273/sympy/geometry/util.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 from sympy import Function, Symbol, solve
 from sympy.core.compatibility import (
@@ -19,6 +212,23 @@
 from .point import Point, Point2D
 
 
+@inspect_code
+def find(x, equation):
+    """
+    Checks whether the parameter 'x' is present in 'equation' or not.
+    If it is present then it returns the passed parameter 'x' as a free
+    symbol, else, it returns a ValueError.
+    """
+
+    free = equation.free_symbols
+    xs = [i for i in free if (i.name if type(x) is str else i) == x]
+    if not xs:
+        raise ValueError('could not find %s' % x)
+    if len(xs) != 1:
+        raise ValueError('ambiguous %s' % x)
+    return xs[0]
+
+
 def _ordered_points(p):
     """Return the tuple of points sorted numerically according to args"""
     return tuple(sorted(p, key=lambda x: x.args))
