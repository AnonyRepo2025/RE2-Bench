diff --git a/sympy/core/power.py b/sympy/core/power.py
index 57544fe..017d0df 100644
--- a/sympy/core/power.py
+++ b/sympy/core/power.py
@@ -1,4 +1,197 @@
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-18728/sympy/core/power.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 from math import log as _log
 
@@ -561,18 +754,20 @@ def _eval_is_zero(self):
             elif self.exp.is_extended_nonpositive:
                 return False
         elif self.base.is_zero is False:
-            if self.exp.is_negative:
+            if self.base.is_finite and self.exp.is_finite:
+                return False
+            elif self.exp.is_negative:
                 return self.base.is_infinite
             elif self.exp.is_nonnegative:
                 return False
-            elif self.exp.is_infinite:
+            elif self.exp.is_infinite and self.exp.is_extended_real:
                 if (1 - abs(self.base)).is_extended_positive:
                     return self.exp.is_extended_positive
                 elif (1 - abs(self.base)).is_extended_negative:
                     return self.exp.is_extended_negative
-        else:
-            # when self.base.is_zero is None
-            return None
+        else: # when self.base.is_zero is None
+            if self.base.is_finite and self.exp.is_negative:
+                return False
 
     def _eval_is_integer(self):
         b, e = self.args
@@ -591,6 +786,7 @@ def _eval_is_integer(self):
             check = self.func(*self.args)
             return check.is_Integer
 
+    @inspect_code
     def _eval_is_extended_real(self):
         from sympy import arg, exp, log, Mul
         real_b = self.base.is_extended_real
@@ -647,7 +843,8 @@ def _eval_is_extended_real(self):
 
         if real_b is False:  # we already know it's not imag
             i = arg(self.base)*self.exp/S.Pi
-            return i.is_integer
+            if i.is_complex: # finite
+                return i.is_integer
 
     def _eval_is_complex(self):
 
diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py
index 6b05362..ef970bb 100644
--- a/sympy/core/tests/test_arit.py
+++ b/sympy/core/tests/test_arit.py
@@ -1200,6 +1200,108 @@ def test_Pow_is_zero():
     assert Pow(S.Half, oo, evaluate=False).is_zero
     assert Pow(S.Half, -oo, evaluate=False).is_zero is False
 
+    # All combinations of real/complex base/exponent
+    h = S.Half
+    T = True
+    F = False
+    N = None
+
+    pow_iszero = [
+        ['**',  0,  h,  1,  2, -h, -1,-2,-2*I,-I/2,I/2,1+I,oo,-oo,zoo],
+        [   0,  F,  T,  T,  T,  F,  F,  F,  F,  F,  F,  N,  T,  F,  N],
+        [   h,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  F,  N],
+        [   1,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  N],
+        [   2,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  N],
+        [  -h,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  F,  N],
+        [  -1,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  N],
+        [  -2,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  N],
+        [-2*I,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  N],
+        [-I/2,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  F,  N],
+        [ I/2,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  F,  N],
+        [ 1+I,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  F,  T,  N],
+        [  oo,  F,  F,  F,  F,  T,  T,  T,  F,  F,  F,  F,  F,  T,  N],
+        [ -oo,  F,  F,  F,  F,  T,  T,  T,  F,  F,  F,  F,  F,  T,  N],
+        [ zoo,  F,  F,  F,  F,  T,  T,  T,  N,  N,  N,  N,  F,  T,  N]
+    ]
+
+    def test_table(table):
+        n = len(table[0])
+        for row in range(1, n):
+            base = table[row][0]
+            for col in range(1, n):
+                exp = table[0][col]
+                is_zero = table[row][col]
+                # The actual test here:
+                assert Pow(base, exp, evaluate=False).is_zero is is_zero
+
+    test_table(pow_iszero)
+
+    # A zero symbol...
+    zo, zo2 = symbols('zo, zo2', zero=True)
+
+    # All combinations of finite symbols
+    zf, zf2 = symbols('zf, zf2', finite=True)
+    wf, wf2 = symbols('wf, wf2', nonzero=True)
+    xf, xf2 = symbols('xf, xf2', real=True)
+    yf, yf2 = symbols('yf, yf2', nonzero=True)
+    af, af2 = symbols('af, af2', positive=True)
+    bf, bf2 = symbols('bf, bf2', nonnegative=True)
+    cf, cf2 = symbols('cf, cf2', negative=True)
+    df, df2 = symbols('df, df2', nonpositive=True)
+
+    # Without finiteness:
+    zi, zi2 = symbols('zi, zi2')
+    wi, wi2 = symbols('wi, wi2', zero=False)
+    xi, xi2 = symbols('xi, xi2', extended_real=True)
+    yi, yi2 = symbols('yi, yi2', zero=False, extended_real=True)
+    ai, ai2 = symbols('ai, ai2', extended_positive=True)
+    bi, bi2 = symbols('bi, bi2', extended_nonnegative=True)
+    ci, ci2 = symbols('ci, ci2', extended_negative=True)
+    di, di2 = symbols('di, di2', extended_nonpositive=True)
+
+    pow_iszero_sym = [
+        ['**',zo,wf,yf,af,cf,zf,xf,bf,df,zi,wi,xi,yi,ai,bi,ci,di],
+        [ zo2, F, N, N, T, F, N, N, N, F, N, N, N, N, T, N, F, F],
+        [ wf2, F, F, F, F, F, F, F, F, F, N, N, N, N, N, N, N, N],
+        [ yf2, F, F, F, F, F, F, F, F, F, N, N, N, N, N, N, N, N],
+        [ af2, F, F, F, F, F, F, F, F, F, N, N, N, N, N, N, N, N],
+        [ cf2, F, F, F, F, F, F, F, F, F, N, N, N, N, N, N, N, N],
+        [ zf2, N, N, N, N, F, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ xf2, N, N, N, N, F, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ bf2, N, N, N, N, F, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ df2, N, N, N, N, F, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ zi2, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ wi2, F, N, N, F, N, N, N, F, N, N, N, N, N, N, N, N, N],
+        [ xi2, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ yi2, F, N, N, F, N, N, N, F, N, N, N, N, N, N, N, N, N],
+        [ ai2, F, N, N, F, N, N, N, F, N, N, N, N, N, N, N, N, N],
+        [ bi2, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N],
+        [ ci2, F, N, N, F, N, N, N, F, N, N, N, N, N, N, N, N, N],
+        [ di2, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N, N]
+    ]
+
+    test_table(pow_iszero_sym)
+
+    # In some cases (x**x).is_zero is different from (x**y).is_zero even if y
+    # has the same assumptions as x.
+    assert (zo ** zo).is_zero is False
+    assert (wf ** wf).is_zero is False
+    assert (yf ** yf).is_zero is False
+    assert (af ** af).is_zero is False
+    assert (cf ** cf).is_zero is False
+    assert (zf ** zf).is_zero is None
+    assert (xf ** xf).is_zero is None
+    assert (bf ** bf).is_zero is False # None in table
+    assert (df ** df).is_zero is None
+    assert (zi ** zi).is_zero is None
+    assert (wi ** wi).is_zero is None
+    assert (xi ** xi).is_zero is None
+    assert (yi ** yi).is_zero is None
+    assert (ai ** ai).is_zero is False # None in table
+    assert (bi ** bi).is_zero is False # None in table
+    assert (ci ** ci).is_zero is None
+    assert (di ** di).is_zero is None
+
 
 def test_Pow_is_nonpositive_nonnegative():
     x = Symbol('x', real=True)
