diff --git a/astropy/coordinates/builtin_frames/__init__.py b/astropy/coordinates/builtin_frames/__init__.py
index 6fd688c..17b5244 100644
--- a/astropy/coordinates/builtin_frames/__init__.py
+++ b/astropy/coordinates/builtin_frames/__init__.py
@@ -48,6 +48,7 @@ from . import supergalactic_transforms
 from . import icrs_cirs_transforms
 from . import cirs_observed_transforms
 from . import icrs_observed_transforms
+from . import itrs_observed_transforms
 from . import intermediate_rotation_transforms
 from . import ecliptic_transforms
 
diff --git a/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py b/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py
index a15248c..16e1468 100644
--- a/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py
+++ b/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-13398/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 """
 Contains the transformation functions for getting to/from ITRS, TEME, GCRS, and CIRS.
@@ -61,6 +254,7 @@ def cirs_to_itrs_mat(time):
     return erfa.c2tcio(np.eye(3), era, pmmat)
 
 
+@inspect_code
 def tete_to_itrs_mat(time, rbpn=None):
     """Compute the polar motion p-matrix at the given time.
 
@@ -71,7 +265,7 @@ def tete_to_itrs_mat(time, rbpn=None):
     sp = erfa.sp00(*get_jd12(time, 'tt'))
     pmmat = erfa.pom00(xp, yp, sp)
 
-    # now determine the greenwich apparent siderial time for the input obstime
+    # now determine the greenwich apparent sidereal time for the input obstime
     # we use the 2006A model for consistency with RBPN matrix use in GCRS <-> TETE
     ujd1, ujd2 = get_jd12(time, 'ut1')
     jd1, jd2 = get_jd12(time, 'tt')
@@ -146,9 +340,9 @@ def tete_to_gcrs(tete_coo, gcrs_frame):
 
 @frame_transform_graph.transform(FunctionTransformWithFiniteDifference, TETE, ITRS)
 def tete_to_itrs(tete_coo, itrs_frame):
-    # first get us to TETE at the target obstime, and geocentric position
+    # first get us to TETE at the target obstime, and location (no-op if same)
     tete_coo2 = tete_coo.transform_to(TETE(obstime=itrs_frame.obstime,
-                                           location=EARTH_CENTER))
+                                           location=itrs_frame.location))
 
     # now get the pmatrix
     pmat = tete_to_itrs_mat(itrs_frame.obstime)
@@ -161,9 +355,9 @@ def itrs_to_tete(itrs_coo, tete_frame):
     # compute the pmatrix, and then multiply by its transpose
     pmat = tete_to_itrs_mat(itrs_coo.obstime)
     newrepr = itrs_coo.cartesian.transform(matrix_transpose(pmat))
-    tete = TETE(newrepr, obstime=itrs_coo.obstime)
+    tete = TETE(newrepr, obstime=itrs_coo.obstime, location=itrs_coo.location)
 
-    # now do any needed offsets (no-op if same obstime)
+    # now do any needed offsets (no-op if same obstime and location)
     return tete.transform_to(tete_frame)
 
 
@@ -196,9 +390,9 @@ def cirs_to_gcrs(cirs_coo, gcrs_frame):
 
 @frame_transform_graph.transform(FunctionTransformWithFiniteDifference, CIRS, ITRS)
 def cirs_to_itrs(cirs_coo, itrs_frame):
-    # first get us to geocentric CIRS at the target obstime
+    # first get us to CIRS at the target obstime, and location (no-op if same)
     cirs_coo2 = cirs_coo.transform_to(CIRS(obstime=itrs_frame.obstime,
-                                           location=EARTH_CENTER))
+                                           location=itrs_frame.location))
 
     # now get the pmatrix
     pmat = cirs_to_itrs_mat(itrs_frame.obstime)
@@ -211,9 +405,9 @@ def itrs_to_cirs(itrs_coo, cirs_frame):
     # compute the pmatrix, and then multiply by its transpose
     pmat = cirs_to_itrs_mat(itrs_coo.obstime)
     newrepr = itrs_coo.cartesian.transform(matrix_transpose(pmat))
-    cirs = CIRS(newrepr, obstime=itrs_coo.obstime)
+    cirs = CIRS(newrepr, obstime=itrs_coo.obstime, location=itrs_coo.location)
 
-    # now do any needed offsets (no-op if same obstime)
+    # now do any needed offsets (no-op if same obstime and location)
     return cirs.transform_to(cirs_frame)
 
 
diff --git a/astropy/coordinates/builtin_frames/itrs.py b/astropy/coordinates/builtin_frames/itrs.py
index e121ec9..ce6c1b6 100644
--- a/astropy/coordinates/builtin_frames/itrs.py
+++ b/astropy/coordinates/builtin_frames/itrs.py
@@ -3,26 +3,69 @@
 from astropy.utils.decorators import format_doc
 from astropy.coordinates.representation import CartesianRepresentation, CartesianDifferential
 from astropy.coordinates.baseframe import BaseCoordinateFrame, base_doc
-from astropy.coordinates.attributes import TimeAttribute
-from .utils import DEFAULT_OBSTIME
+from astropy.coordinates.attributes import (TimeAttribute,
+                                            EarthLocationAttribute)
+from .utils import DEFAULT_OBSTIME, EARTH_CENTER
 
 __all__ = ['ITRS']
 
+doc_footer = """
+    Other parameters
+    ----------------
+    obstime : `~astropy.time.Time`
+        The time at which the observation is taken.  Used for determining the
+        position of the Earth and its precession.
+    location : `~astropy.coordinates.EarthLocation`
+        The location on the Earth.  This can be specified either as an
+        `~astropy.coordinates.EarthLocation` object or as anything that can be
+        transformed to an `~astropy.coordinates.ITRS` frame. The default is the
+        centre of the Earth.
+"""
 
-@format_doc(base_doc, components="", footer="")
+
+@format_doc(base_doc, components="", footer=doc_footer)
 class ITRS(BaseCoordinateFrame):
     """
     A coordinate or frame in the International Terrestrial Reference System
     (ITRS).  This is approximately a geocentric system, although strictly it is
-    defined by a series of reference locations near the surface of the Earth.
+    defined by a series of reference locations near the surface of the Earth (the ITRF).
     For more background on the ITRS, see the references provided in the
     :ref:`astropy:astropy-coordinates-seealso` section of the documentation.
+
+    This frame also includes frames that are defined *relative* to the center of the Earth,
+    but that are offset (in both position and velocity) from the center of the Earth. You
+    may see such non-geocentric coordinates referred to as "topocentric".
+
+    Topocentric ITRS frames are convenient for observations of near Earth objects where
+    stellar aberration is not included. One can merely subtract the observing site's
+    EarthLocation geocentric ITRS coordinates from the object's geocentric ITRS coordinates,
+    put the resulting vector into a topocentric ITRS frame and then transform to
+    `~astropy.coordinates.AltAz` or `~astropy.coordinates.HADec`. The other way around is
+    to transform an observed `~astropy.coordinates.AltAz` or `~astropy.coordinates.HADec`
+    position to a topocentric ITRS frame and add the observing site's EarthLocation geocentric
+    ITRS coordinates to yield the object's geocentric ITRS coordinates.
+
+    On the other hand, using ``transform_to`` to transform geocentric ITRS coordinates to
+    topocentric ITRS, observed `~astropy.coordinates.AltAz`, or observed
+    `~astropy.coordinates.HADec` coordinates includes the difference between stellar aberration
+    from the point of view of an observer at the geocenter and stellar aberration from the
+    point of view of an observer on the surface of the Earth. If the geocentric ITRS
+    coordinates of the object include stellar aberration at the geocenter (e.g. certain ILRS
+    ephemerides), then this is the way to go.
+
+    Note to ILRS ephemeris users: Astropy does not currently consider relativistic
+    effects of the Earth's gravatational field. Nor do the `~astropy.coordinates.AltAz`
+    or `~astropy.coordinates.HADec` refraction corrections compute the change in the
+    range due to the curved path of light through the atmosphere, so Astropy is no
+    substitute for the ILRS software in these respects.
+
     """
 
     default_representation = CartesianRepresentation
     default_differential = CartesianDifferential
 
     obstime = TimeAttribute(default=DEFAULT_OBSTIME)
+    location = EarthLocationAttribute(default=EARTH_CENTER)
 
     @property
     def earth_location(self):
diff --git a/astropy/coordinates/tests/test_intermediate_transformations.py b/astropy/coordinates/tests/test_intermediate_transformations.py
index 007ccc0..e7ec90f 100644
--- a/astropy/coordinates/tests/test_intermediate_transformations.py
+++ b/astropy/coordinates/tests/test_intermediate_transformations.py
@@ -194,6 +194,116 @@ def test_cirs_to_hadec():
     assert_allclose(cirs.dec, cirs3.dec)
 
 
+def test_itrs_topo_to_altaz_with_refraction():
+
+    loc = EarthLocation(lat=0*u.deg, lon=0*u.deg, height=0*u.m)
+    usph = golden_spiral_grid(200)
+    dist = np.linspace(1., 1000.0, len(usph)) * u.au
+    icrs = ICRS(ra=usph.lon, dec=usph.lat, distance=dist)
+    altaz_frame1 = AltAz(obstime = 'J2000', location=loc)
+    altaz_frame2 = AltAz(obstime = 'J2000', location=loc, pressure=1000.0 * u.hPa,
+                         relative_humidity=0.5)
+    cirs_frame = CIRS(obstime = 'J2000', location=loc)
+    itrs_frame = ITRS(location=loc)
+
+    # Normal route
+    # No Refraction
+    altaz1 = icrs.transform_to(altaz_frame1)
+
+    # Refraction added
+    altaz2 = icrs.transform_to(altaz_frame2)
+
+    # Refraction removed
+    cirs = altaz2.transform_to(cirs_frame)
+    altaz3 = cirs.transform_to(altaz_frame1)
+
+    # Through ITRS
+    # No Refraction
+    itrs = icrs.transform_to(itrs_frame)
+    altaz11 = itrs.transform_to(altaz_frame1)
+
+    assert_allclose(altaz11.az - altaz1.az, 0*u.mas, atol=0.1*u.mas)
+    assert_allclose(altaz11.alt - altaz1.alt, 0*u.mas, atol=0.1*u.mas)
+    assert_allclose(altaz11.distance - altaz1.distance, 0*u.cm, atol=10.0*u.cm)
+
+    # Round trip
+    itrs11 = altaz11.transform_to(itrs_frame)
+
+    assert_allclose(itrs11.x, itrs.x)
+    assert_allclose(itrs11.y, itrs.y)
+    assert_allclose(itrs11.z, itrs.z)
+
+    # Refraction added
+    altaz22 = itrs.transform_to(altaz_frame2)
+
+    assert_allclose(altaz22.az - altaz2.az, 0*u.mas, atol=0.1*u.mas)
+    assert_allclose(altaz22.alt - altaz2.alt, 0*u.mas, atol=0.1*u.mas)
+    assert_allclose(altaz22.distance - altaz2.distance, 0*u.cm, atol=10.0*u.cm)
+
+    # Refraction removed
+    itrs = altaz22.transform_to(itrs_frame)
+    altaz33 = itrs.transform_to(altaz_frame1)
+
+    assert_allclose(altaz33.az - altaz3.az, 0*u.mas, atol=0.1*u.mas)
+    assert_allclose(altaz33.alt - altaz3.alt, 0*u.mas, atol=0.1*u.mas)
+    assert_allclose(altaz33.distance - altaz3.distance, 0*u.cm, atol=10.0*u.cm)
+
+
+def test_itrs_topo_to_hadec_with_refraction():
+
+    loc = EarthLocation(lat=0*u.deg, lon=0*u.deg, height=0*u.m)
+    usph = golden_spiral_grid(200)
+    dist = np.linspace(1., 1000.0, len(usph)) * u.au
+    icrs = ICRS(ra=usph.lon, dec=usph.lat, distance=dist)
+    hadec_frame1 = HADec(obstime = 'J2000', location=loc)
+    hadec_frame2 = HADec(obstime = 'J2000', location=loc, pressure=1000.0 * u.hPa,
+                         relative_humidity=0.5)
+    cirs_frame = CIRS(obstime = 'J2000', location=loc)
+    itrs_frame = ITRS(location=loc)
+
+    # Normal route
+    # No Refraction
+    hadec1 = icrs.transform_to(hadec_frame1)
+
+    # Refraction added
+    hadec2 = icrs.transform_to(hadec_frame2)
+
+    # Refraction removed
+    cirs = hadec2.transform_to(cirs_frame)
+    hadec3 = cirs.transform_to(hadec_frame1)
+
+    # Through ITRS
+    # No Refraction
+    itrs = icrs.transform_to(itrs_frame)
+    hadec11 = itrs.transform_to(hadec_frame1)
+
+    assert_allclose(hadec11.ha - hadec1.ha, 0*u.mas, atol=0.1*u.mas)
+    assert_allclose(hadec11.dec - hadec1.dec, 0*u.mas, atol=0.1*u.mas)
+    assert_allclose(hadec11.distance - hadec1.distance, 0*u.cm, atol=10.0*u.cm)
+
+    # Round trip
+    itrs11 = hadec11.transform_to(itrs_frame)
+
+    assert_allclose(itrs11.x, itrs.x)
+    assert_allclose(itrs11.y, itrs.y)
+    assert_allclose(itrs11.z, itrs.z)
+
+    # Refraction added
+    hadec22 = itrs.transform_to(hadec_frame2)
+
+    assert_allclose(hadec22.ha - hadec2.ha, 0*u.mas, atol=0.1*u.mas)
+    assert_allclose(hadec22.dec - hadec2.dec, 0*u.mas, atol=0.1*u.mas)
+    assert_allclose(hadec22.distance - hadec2.distance, 0*u.cm, atol=10.0*u.cm)
+
+    # Refraction removed
+    itrs = hadec22.transform_to(itrs_frame)
+    hadec33 = itrs.transform_to(hadec_frame1)
+
+    assert_allclose(hadec33.ha - hadec3.ha, 0*u.mas, atol=0.1*u.mas)
+    assert_allclose(hadec33.dec - hadec3.dec, 0*u.mas, atol=0.1*u.mas)
+    assert_allclose(hadec33.distance - hadec3.distance, 0*u.cm, atol=10.0*u.cm)
+
+
 def test_gcrs_itrs():
     """
     Check basic GCRS<->ITRS transforms for round-tripping.
@@ -221,7 +331,7 @@ def test_gcrs_itrs():
 
 def test_cirs_itrs():
     """
-    Check basic CIRS<->ITRS transforms for round-tripping.
+    Check basic CIRS<->ITRS geocentric transforms for round-tripping.
     """
     usph = golden_spiral_grid(200)
     cirs = CIRS(usph, obstime='J2000')
@@ -237,6 +347,25 @@ def test_cirs_itrs():
     assert not allclose(cirs.dec, cirs6_2.dec)
 
 
+def test_cirs_itrs_topo():
+    """
+    Check basic CIRS<->ITRS topocentric transforms for round-tripping.
+    """
+    loc = EarthLocation(lat=0*u.deg, lon=0*u.deg, height=0*u.m)
+    usph = golden_spiral_grid(200)
+    cirs = CIRS(usph, obstime='J2000', location=loc)
+    cirs6 = CIRS(usph, obstime='J2006', location=loc)
+
+    cirs2 = cirs.transform_to(ITRS(location=loc)).transform_to(cirs)
+    cirs6_2 = cirs6.transform_to(ITRS(location=loc)).transform_to(cirs)  # different obstime
+
+    # just check round-tripping
+    assert_allclose(cirs.ra, cirs2.ra)
+    assert_allclose(cirs.dec, cirs2.dec)
+    assert not allclose(cirs.ra, cirs6_2.ra)
+    assert not allclose(cirs.dec, cirs6_2.dec)
+
+
 def test_gcrs_cirs():
     """
     Check GCRS<->CIRS transforms for round-tripping.  More complicated than the
@@ -773,7 +902,7 @@ def test_tete_transforms():
 
 def test_straight_overhead():
     """
-    With a precise CIRS<->AltAz transformation this should give Alt=90 exactly
+    With a precise CIRS<->Observed transformation this should give Alt=90 exactly
 
     If the CIRS self-transform breaks it won't, due to improper treatment of aberration
     """
@@ -806,6 +935,37 @@ def test_straight_overhead():
     assert_allclose(hd.dec, 52*u.deg, atol=1*u.uas, rtol=0)
 
 
+def test_itrs_straight_overhead():
+    """
+    With a precise ITRS<->Observed transformation this should give Alt=90 exactly
+
+    """
+    t = Time('J2010')
+    obj = EarthLocation(-1*u.deg, 52*u.deg, height=10.*u.km)
+    home = EarthLocation(-1*u.deg, 52*u.deg, height=0.*u.km)
+
+    # An object that appears straight overhead - FOR A GEOCENTRIC OBSERVER.
+    itrs_geo = obj.get_itrs(t).cartesian
+
+    # now get the Geocentric ITRS position of observatory
+    obsrepr = home.get_itrs(t).cartesian
+
+    # topocentric ITRS position of a straight overhead object
+    itrs_repr = itrs_geo - obsrepr
+
+    # create a ITRS object that appears straight overhead for a TOPOCENTRIC OBSERVER
+    itrs_topo = ITRS(itrs_repr, obstime=t, location=home)
+
+    # Check AltAz (though Azimuth can be anything so is not tested).
+    aa = itrs_topo.transform_to(AltAz(obstime=t, location=home))
+    assert_allclose(aa.alt, 90*u.deg, atol=1*u.uas, rtol=0)
+
+    # Check HADec.
+    hd = itrs_topo.transform_to(HADec(obstime=t, location=home))
+    assert_allclose(hd.ha, 0*u.hourangle, atol=1*u.uas, rtol=0)
+    assert_allclose(hd.dec, 52*u.deg, atol=1*u.uas, rtol=0)
+
+
 def jplephem_ge(minversion):
     """Check if jplephem is installed and has version >= minversion."""
     # This is a separate routine since somehow with pyinstaller the stanza
