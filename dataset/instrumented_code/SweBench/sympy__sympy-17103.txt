diff --git a/sympy/printing/tensorflow.py b/sympy/printing/tensorflow.py
index 46b9f7e..c4a292b 100644
--- a/sympy/printing/tensorflow.py
+++ b/sympy/printing/tensorflow.py
@@ -1,12 +1,207 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-17103/sympy/printing/tensorflow.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 from distutils.version import LooseVersion as V
 
-from sympy import Mul
+from sympy import Mul, S
+from sympy.codegen.cfunctions import Sqrt
 from sympy.core.compatibility import Iterable
 from sympy.external import import_module
 from sympy.printing.precedence import PRECEDENCE
 from sympy.printing.pycode import AbstractPythonCodePrinter
 import sympy
 
+tensorflow = import_module('tensorflow')
 
 class TensorflowPrinter(AbstractPythonCodePrinter):
     """
@@ -16,52 +211,73 @@ class TensorflowPrinter(AbstractPythonCodePrinter):
     printmethod = "_tensorflowcode"
 
     mapping = {
-        sympy.Abs: "tensorflow.abs",
-        sympy.sign: "tensorflow.sign",
-        sympy.ceiling: "tensorflow.ceil",
-        sympy.floor: "tensorflow.floor",
-        sympy.log: "tensorflow.log",
-        sympy.exp: "tensorflow.exp",
-        sympy.sqrt: "tensorflow.sqrt",
-        sympy.cos: "tensorflow.cos",
-        sympy.acos: "tensorflow.acos",
-        sympy.sin: "tensorflow.sin",
-        sympy.asin: "tensorflow.asin",
-        sympy.tan: "tensorflow.tan",
-        sympy.atan: "tensorflow.atan",
-        sympy.atan2: "tensorflow.atan2",
-        sympy.cosh: "tensorflow.cosh",
-        sympy.acosh: "tensorflow.acosh",
-        sympy.sinh: "tensorflow.sinh",
-        sympy.asinh: "tensorflow.asinh",
-        sympy.tanh: "tensorflow.tanh",
-        sympy.atanh: "tensorflow.atanh",
-        sympy.re: "tensorflow.real",
-        sympy.im: "tensorflow.imag",
-        sympy.arg: "tensorflow.angle",
-        sympy.erf: "tensorflow.erf",
-        sympy.loggamma: "tensorflow.gammaln",
-        sympy.Pow: "tensorflow.pow",
-        sympy.Eq: "tensorflow.equal",
-        sympy.Ne: "tensorflow.not_equal",
-        sympy.StrictGreaterThan: "tensorflow.greater",
-        sympy.StrictLessThan: "tensorflow.less",
-        sympy.LessThan: "tensorflow.less_equal",
-        sympy.GreaterThan: "tensorflow.greater_equal",
-        sympy.And: "tensorflow.logical_and",
-        sympy.Or: "tensorflow.logical_or",
-        sympy.Not: "tensorflow.logical_not",
-        sympy.Max: "tensorflow.maximum",
-        sympy.Min: "tensorflow.minimum",
+        sympy.Abs: "tensorflow.math.abs",
+        sympy.sign: "tensorflow.math.sign",
+
+        # XXX May raise error for ints.
+        sympy.ceiling: "tensorflow.math.ceil",
+        sympy.floor: "tensorflow.math.floor",
+        sympy.log: "tensorflow.math.log",
+        sympy.exp: "tensorflow.math.exp",
+        Sqrt: "tensorflow.math.sqrt",
+        sympy.cos: "tensorflow.math.cos",
+        sympy.acos: "tensorflow.math.acos",
+        sympy.sin: "tensorflow.math.sin",
+        sympy.asin: "tensorflow.math.asin",
+        sympy.tan: "tensorflow.math.tan",
+        sympy.atan: "tensorflow.math.atan",
+        sympy.atan2: "tensorflow.math.atan2",
+        # XXX Also may give NaN for complex results.
+        sympy.cosh: "tensorflow.math.cosh",
+        sympy.acosh: "tensorflow.math.acosh",
+        sympy.sinh: "tensorflow.math.sinh",
+        sympy.asinh: "tensorflow.math.asinh",
+        sympy.tanh: "tensorflow.math.tanh",
+        sympy.atanh: "tensorflow.math.atanh",
+
+        sympy.re: "tensorflow.math.real",
+        sympy.im: "tensorflow.math.imag",
+        sympy.arg: "tensorflow.math.angle",
+
+        # XXX May raise error for ints and complexes
+        sympy.erf: "tensorflow.math.erf",
+        sympy.loggamma: "tensorflow.math.lgamma",
+
+        sympy.Eq: "tensorflow.math.equal",
+        sympy.Ne: "tensorflow.math.not_equal",
+        sympy.StrictGreaterThan: "tensorflow.math.greater",
+        sympy.StrictLessThan: "tensorflow.math.less",
+        sympy.LessThan: "tensorflow.math.less_equal",
+        sympy.GreaterThan: "tensorflow.math.greater_equal",
+
+        sympy.And: "tensorflow.math.logical_and",
+        sympy.Or: "tensorflow.math.logical_or",
+        sympy.Not: "tensorflow.math.logical_not",
+        sympy.Max: "tensorflow.math.maximum",
+        sympy.Min: "tensorflow.math.minimum",
+
         # Matrices
-        sympy.MatAdd: "tensorflow.add",
-        sympy.HadamardProduct: "tensorflow.multiply",
-        sympy.Trace: "tensorflow.trace",
-        sympy.Determinant : "tensorflow.matrix_determinant",
-        sympy.Inverse: "tensorflow.matrix_inverse",
-        sympy.Transpose: "tensorflow.matrix_transpose",
+        sympy.MatAdd: "tensorflow.math.add",
+        sympy.HadamardProduct: "tensorflow.math.multiply",
+        sympy.Trace: "tensorflow.linalg.trace",
+
+        # XXX May raise error for integer matrices.
+        sympy.Determinant : "tensorflow.linalg.det",
     }
 
+    _default_settings = dict(
+        AbstractPythonCodePrinter._default_settings,
+        tensorflow_version=None
+    )
+
+    def __init__(self, settings=None):
+        super(TensorflowPrinter, self).__init__(settings)
+
+        version = self._settings['tensorflow_version']
+        if version is None and tensorflow:
+            version = tensorflow.__version__
+        self.tensorflow_version = version
+
     def _print_Function(self, expr):
         op = self.mapping.get(type(expr), None)
         if op is None:
@@ -79,11 +295,25 @@ def _print_Function(self, expr):
     _print_Application = _print_Function
     _print_MatrixExpr = _print_Function
     # TODO: a better class structure would avoid this mess:
+    _print_Relational = _print_Function
     _print_Not = _print_Function
     _print_And = _print_Function
     _print_Or = _print_Function
-    _print_Transpose = _print_Function
+    _print_HadamardProduct = _print_Function
     _print_Trace = _print_Function
+    _print_Determinant = _print_Function
+
+    def _print_Inverse(self, expr):
+        op = self._module_format('tensorflow.linalg.inv')
+        return "{}({})".format(op, self._print(expr.arg))
+
+    def _print_Transpose(self, expr):
+        version = self.tensorflow_version
+        if version and V(version) < V('1.14'):
+            op = self._module_format('tensorflow.matrix_transpose')
+        else:
+            op = self._module_format('tensorflow.linalg.matrix_transpose')
+        return "{}({})".format(op, self._print(expr.arg))
 
     def _print_Derivative(self, expr):
         variables = expr.variables
@@ -100,27 +330,38 @@ def unfold(expr, args):
         return unfold(expr.expr, variables)
 
     def _print_Piecewise(self, expr):
-        tensorflow = import_module('tensorflow')
-        if tensorflow and V(tensorflow.__version__) < '1.0':
-            tensorflow_piecewise = "select"
+        version = self.tensorflow_version
+        if version and V(version) < V('1.0'):
+            tensorflow_piecewise = "tensorflow.select"
         else:
-            tensorflow_piecewise = "where"
+            tensorflow_piecewise = "tensorflow.where"
 
         from sympy import Piecewise
         e, cond = expr.args[0].args
         if len(expr.args) == 1:
             return '{0}({1}, {2}, {3})'.format(
-                tensorflow_piecewise,
+                self._module_format(tensorflow_piecewise),
                 self._print(cond),
                 self._print(e),
                 0)
 
         return '{0}({1}, {2}, {3})'.format(
-            tensorflow_piecewise,
+            self._module_format(tensorflow_piecewise),
             self._print(cond),
             self._print(e),
             self._print(Piecewise(*expr.args[1:])))
 
+    def _print_Pow(self, expr):
+        # XXX May raise error for
+        # int**float or int**complex or float**complex
+        base, exp = expr.args
+        if expr.exp == S.Half:
+            return "{}({})".format(
+                self._module_format("tensorflow.math.sqrt"), self._print(base))
+        return "{}({}, {})".format(
+            self._module_format("tensorflow.math.pow"),
+            self._print(base), self._print(exp))
+
     def _print_MatrixBase(self, expr):
         tensorflow_f = "tensorflow.Variable" if expr.free_symbols else "tensorflow.constant"
         data = "["+", ".join(["["+", ".join([self._print(j) for j in i])+"]" for i in expr.tolist()])+"]"
@@ -136,13 +377,16 @@ def _print_MatMul(self, expr):
         if args:
             return "%s*%s" % (
                 self.parenthesize(Mul.fromiter(args), PRECEDENCE["Mul"]),
-                self._expand_fold_binary_op("tensorflow.matmul", mat_args)
+                self._expand_fold_binary_op(
+                    "tensorflow.linalg.matmul", mat_args)
             )
         else:
-            return self._expand_fold_binary_op("tensorflow.matmul", mat_args)
+            return self._expand_fold_binary_op(
+                "tensorflow.linalg.matmul", mat_args)
 
     def _print_MatPow(self, expr):
-        return self._expand_fold_binary_op("tensorflow.matmul", [expr.base]*expr.exp)
+        return self._expand_fold_binary_op(
+            "tensorflow.linalg.matmul", [expr.base]*expr.exp)
 
     def _print_Assignment(self, expr):
         # TODO: is this necessary?
@@ -165,15 +409,17 @@ def _get_letter_generator_for_einsum(self):
             yield chr(i)
         raise ValueError("out of letters")
 
+    @inspect_code
     def _print_CodegenArrayTensorProduct(self, expr):
         letters = self._get_letter_generator_for_einsum()
         contraction_string = ",".join(["".join([next(letters) for j in range(i)]) for i in expr.subranks])
         return '%s("%s", %s)' % (
-                self._module_format('tensorflow.einsum'),
+                self._module_format('tensorflow.linalg.einsum'),
                 contraction_string,
                 ", ".join([self._print(arg) for arg in expr.args])
         )
 
+    @inspect_code
     def _print_CodegenArrayContraction(self, expr):
         from sympy.codegen.array_utils import CodegenArrayTensorProduct
         base = expr.expr
@@ -185,7 +431,7 @@ def _print_CodegenArrayContraction(self, expr):
         if isinstance(base, CodegenArrayTensorProduct):
             elems = ["%s" % (self._print(arg)) for arg in base.args]
             return "%s(\"%s\", %s)" % (
-                self._module_format("tensorflow.einsum"),
+                self._module_format("tensorflow.linalg.einsum"),
                 contraction_string,
                 ", ".join(elems)
             )
@@ -211,7 +457,7 @@ def _print_CodegenArrayDiagonal(self, expr):
         diagonal_string, letters_free, letters_dum = self._get_einsum_string(subranks, diagonal_indices)
         elems = [self._print(i) for i in elems]
         return '%s("%s", %s)' % (
-            self._module_format("tensorflow.einsum"),
+            self._module_format("tensorflow.linalg.einsum"),
             "{0}->{1}{2}".format(diagonal_string, "".join(letters_free), "".join(letters_dum)),
             ", ".join(elems)
         )
@@ -224,9 +470,9 @@ def _print_CodegenArrayPermuteDims(self, expr):
         )
 
     def _print_CodegenArrayElementwiseAdd(self, expr):
-        return self._expand_fold_binary_op('tensorflow.add', expr.args)
+        return self._expand_fold_binary_op('tensorflow.math.add', expr.args)
 
 
-def tensorflow_code(expr):
-    printer = TensorflowPrinter()
+def tensorflow_code(expr, **settings):
+    printer = TensorflowPrinter(settings)
     return printer.doprint(expr)
diff --git a/sympy/printing/tests/test_tensorflow.py b/sympy/printing/tests/test_tensorflow.py
index 0a1d085..2b0c0a4 100644
--- a/sympy/printing/tests/test_tensorflow.py
+++ b/sympy/printing/tests/test_tensorflow.py
@@ -1,19 +1,31 @@
 import random
 
-from sympy.printing.tensorflow import TensorflowPrinter
-from sympy.printing.tensorflow import tensorflow_code
-from sympy import (eye, symbols, MatrixSymbol, Symbol, Matrix, symbols, sin,
-        exp, Function, Derivative, Trace)
+from sympy import symbols, Symbol, Function, Derivative
 from sympy.codegen.array_utils import (CodegenArrayContraction,
         CodegenArrayTensorProduct, CodegenArrayElementwiseAdd,
         CodegenArrayPermuteDims, CodegenArrayDiagonal)
+from sympy.core.relational import Eq, Ne, Ge, Gt, Le, Lt
+from sympy.external import import_module
+from sympy.functions import \
+    Abs, Max, Min, ceiling, exp, floor, sign, sin, asin, sqrt, cos, \
+    acos, tan, atan, atan2, cosh, acosh, sinh, asinh, tanh, atanh, \
+    re, im, arg, erf, loggamma, log
+from sympy.matrices import Matrix, MatrixBase, eye, randMatrix
+from sympy.matrices.expressions import \
+    Determinant, HadamardProduct, Inverse, MatrixSymbol, Trace
+from sympy.printing.tensorflow import TensorflowPrinter, tensorflow_code
 from sympy.utilities.lambdify import lambdify
-
 from sympy.utilities.pytest import skip
-from sympy.external import import_module
+
 
 tf = tensorflow = import_module("tensorflow")
 
+if tensorflow:
+    # Hide Tensorflow warnings
+    import os
+    os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
+
+
 M = MatrixSymbol("M", 3, 3)
 N = MatrixSymbol("N", 3, 3)
 P = MatrixSymbol("P", 3, 3)
@@ -25,57 +37,279 @@
     llo = [[j for j in range(i, i+3)] for i in range(0, 9, 3)]
     m3x3 = tf.constant(llo)
     m3x3sympy = Matrix(llo)
-    session = tf.Session()
 
 
-def _compare_tensorflow_matrix(variables, expr):
+def _compare_tensorflow_matrix(variables, expr, use_float=False):
     f = lambdify(variables, expr, 'tensorflow')
-    random_matrices = [Matrix([[random.randint(0, 10) for k in
-        range(i.shape[1])] for j in range(i.shape[0])]) for i in variables]
-    random_variables = [eval(tensorflow_code(i)) for i in
-            random_matrices]
-    r = session.run(f(*random_variables))
-    e = expr.subs({k: v for k, v in zip(variables, random_matrices)}).doit()
+    if not use_float:
+        random_matrices = [randMatrix(v.rows, v.cols) for v in variables]
+    else:
+        random_matrices = [randMatrix(v.rows, v.cols)/100. for v in variables]
+
+    graph = tf.Graph()
+    r = None
+    with graph.as_default():
+        random_variables = [eval(tensorflow_code(i)) for i in random_matrices]
+        session = tf.compat.v1.Session(graph=graph)
+        r = session.run(f(*random_variables))
+
+    e = expr.subs({k: v for k, v in zip(variables, random_matrices)})
+    e = e.doit()
     if e.is_Matrix:
+        if not isinstance(e, MatrixBase):
+            e = e.as_explicit()
         e = e.tolist()
-    assert (r == e).all()
 
+    if not use_float:
+        assert (r == e).all()
+    else:
+        r = [i for row in r for i in row]
+        e = [i for row in e for i in row]
+        assert all(
+            abs(a-b) < 10**-(4-int(log(abs(a), 10))) for a, b in zip(r, e))
+
+
+def _compare_tensorflow_matrix_scalar(variables, expr):
+    f = lambdify(variables, expr, 'tensorflow')
+    random_matrices = [
+        randMatrix(v.rows, v.cols).evalf() / 100 for v in variables]
+
+    graph = tf.Graph()
+    r = None
+    with graph.as_default():
+        random_variables = [eval(tensorflow_code(i)) for i in random_matrices]
+        session = tf.compat.v1.Session(graph=graph)
+        r = session.run(f(*random_variables))
+
+    e = expr.subs({k: v for k, v in zip(variables, random_matrices)})
+    e = e.doit()
+    assert abs(r-e) < 10**-6
+
+
+def _compare_tensorflow_scalar(
+    variables, expr, rng=lambda: random.randint(0, 10)):
+    f = lambdify(variables, expr, 'tensorflow')
+    rvs = [rng() for v in variables]
+
+    graph = tf.Graph()
+    r = None
+    with graph.as_default():
+        tf_rvs = [eval(tensorflow_code(i)) for i in rvs]
+        session = tf.compat.v1.Session(graph=graph)
+        r = session.run(f(*tf_rvs))
+
+    e = expr.subs({k: v for k, v in zip(variables, rvs)}).evalf().doit()
+    assert abs(r-e) < 10**-6
+
+
+def _compare_tensorflow_relational(
+    variables, expr, rng=lambda: random.randint(0, 10)):
+    f = lambdify(variables, expr, 'tensorflow')
+    rvs = [rng() for v in variables]
 
-def test_tensorflow_matrix():
+    graph = tf.Graph()
+    r = None
+    with graph.as_default():
+        tf_rvs = [eval(tensorflow_code(i)) for i in rvs]
+        session = tf.compat.v1.Session(graph=graph)
+        r = session.run(f(*tf_rvs))
+
+    e = expr.subs({k: v for k, v in zip(variables, rvs)}).doit()
+    assert r == e
+
+
+def test_tensorflow_printing():
+    assert tensorflow_code(eye(3)) == \
+        "tensorflow.constant([[1, 0, 0], [0, 1, 0], [0, 0, 1]])"
+
+    expr = Matrix([[x, sin(y)], [exp(z), -t]])
+    assert tensorflow_code(expr) == \
+        "tensorflow.Variable(" \
+            "[[x, tensorflow.math.sin(y)]," \
+            " [tensorflow.math.exp(z), -t]])"
+
+
+def test_tensorflow_math():
     if not tf:
         skip("TensorFlow not installed")
 
-    assert tensorflow_code(eye(3)) == "tensorflow.constant([[1, 0, 0], [0, 1, 0], [0, 0, 1]])"
+    expr = Abs(x)
+    assert tensorflow_code(expr) == "tensorflow.math.abs(x)"
+    _compare_tensorflow_scalar((x,), expr)
 
-    expr = Matrix([[x, sin(y)], [exp(z), -t]])
-    assert tensorflow_code(expr) == "tensorflow.Variable([[x, tensorflow.sin(y)], [tensorflow.exp(z), -t]])"
+    expr = sign(x)
+    assert tensorflow_code(expr) == "tensorflow.math.sign(x)"
+    _compare_tensorflow_scalar((x,), expr)
+
+    expr = ceiling(x)
+    assert tensorflow_code(expr) == "tensorflow.math.ceil(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.random())
+
+    expr = floor(x)
+    assert tensorflow_code(expr) == "tensorflow.math.floor(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.random())
+
+    expr = exp(x)
+    assert tensorflow_code(expr) == "tensorflow.math.exp(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.random())
+
+    expr = sqrt(x)
+    assert tensorflow_code(expr) == "tensorflow.math.sqrt(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.random())
+
+    expr = x ** 4
+    assert tensorflow_code(expr) == "tensorflow.math.pow(x, 4)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.random())
+
+    expr = cos(x)
+    assert tensorflow_code(expr) == "tensorflow.math.cos(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.random())
+
+    expr = acos(x)
+    assert tensorflow_code(expr) == "tensorflow.math.acos(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.random())
+
+    expr = sin(x)
+    assert tensorflow_code(expr) == "tensorflow.math.sin(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.random())
+
+    expr = asin(x)
+    assert tensorflow_code(expr) == "tensorflow.math.asin(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.random())
+
+    expr = tan(x)
+    assert tensorflow_code(expr) == "tensorflow.math.tan(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.random())
+
+    expr = atan(x)
+    assert tensorflow_code(expr) == "tensorflow.math.atan(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.random())
+
+    expr = atan2(y, x)
+    assert tensorflow_code(expr) == "tensorflow.math.atan2(y, x)"
+    _compare_tensorflow_scalar((y, x), expr, rng=lambda: random.random())
+
+    expr = cosh(x)
+    assert tensorflow_code(expr) == "tensorflow.math.cosh(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.random())
+
+    expr = acosh(x)
+    assert tensorflow_code(expr) == "tensorflow.math.acosh(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.uniform(1, 2))
+
+    expr = sinh(x)
+    assert tensorflow_code(expr) == "tensorflow.math.sinh(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.uniform(1, 2))
+
+    expr = asinh(x)
+    assert tensorflow_code(expr) == "tensorflow.math.asinh(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.uniform(1, 2))
+
+    expr = tanh(x)
+    assert tensorflow_code(expr) == "tensorflow.math.tanh(x)"
+    _compare_tensorflow_scalar((x,), expr, rng=lambda: random.uniform(1, 2))
+
+    expr = atanh(x)
+    assert tensorflow_code(expr) == "tensorflow.math.atanh(x)"
+    _compare_tensorflow_scalar(
+        (x,), expr, rng=lambda: random.uniform(-.5, .5))
+
+    expr = erf(x)
+    assert tensorflow_code(expr) == "tensorflow.math.erf(x)"
+    _compare_tensorflow_scalar(
+        (x,), expr, rng=lambda: random.random())
+
+    expr = loggamma(x)
+    assert tensorflow_code(expr) == "tensorflow.math.lgamma(x)"
+    _compare_tensorflow_scalar(
+        (x,), expr, rng=lambda: random.random())
+
+
+def test_tensorflow_complexes():
+    assert tensorflow_code(re(x)) == "tensorflow.math.real(x)"
+    assert tensorflow_code(im(x)) == "tensorflow.math.imag(x)"
+    assert tensorflow_code(arg(x)) == "tensorflow.math.angle(x)"
+
+
+def test_tensorflow_relational():
+    if not tf:
+        skip("TensorFlow not installed")
+
+    expr = Eq(x, y)
+    assert tensorflow_code(expr) == "tensorflow.math.equal(x, y)"
+    _compare_tensorflow_relational((x, y), expr)
+
+    expr = Ne(x, y)
+    assert tensorflow_code(expr) == "tensorflow.math.not_equal(x, y)"
+    _compare_tensorflow_relational((x, y), expr)
+
+    expr = Ge(x, y)
+    assert tensorflow_code(expr) == "tensorflow.math.greater_equal(x, y)"
+    _compare_tensorflow_relational((x, y), expr)
+
+    expr = Gt(x, y)
+    assert tensorflow_code(expr) == "tensorflow.math.greater(x, y)"
+    _compare_tensorflow_relational((x, y), expr)
+
+    expr = Le(x, y)
+    assert tensorflow_code(expr) == "tensorflow.math.less_equal(x, y)"
+    _compare_tensorflow_relational((x, y), expr)
+
+    expr = Lt(x, y)
+    assert tensorflow_code(expr) == "tensorflow.math.less(x, y)"
+    _compare_tensorflow_relational((x, y), expr)
+
+
+def test_tensorflow_matrices():
+    if not tf:
+        skip("TensorFlow not installed")
 
     expr = M
     assert tensorflow_code(expr) == "M"
     _compare_tensorflow_matrix((M,), expr)
 
     expr = M + N
-    assert tensorflow_code(expr) == "tensorflow.add(M, N)"
+    assert tensorflow_code(expr) == "tensorflow.math.add(M, N)"
+    _compare_tensorflow_matrix((M, N), expr)
+
+    expr = M * N
+    assert tensorflow_code(expr) == "tensorflow.linalg.matmul(M, N)"
     _compare_tensorflow_matrix((M, N), expr)
 
-    expr = M*N
-    assert tensorflow_code(expr) == "tensorflow.matmul(M, N)"
+    expr = HadamardProduct(M, N)
+    assert tensorflow_code(expr) == "tensorflow.math.multiply(M, N)"
     _compare_tensorflow_matrix((M, N), expr)
 
     expr = M*N*P*Q
-    assert tensorflow_code(expr) == "tensorflow.matmul(tensorflow.matmul(tensorflow.matmul(M, N), P), Q)"
+    assert tensorflow_code(expr) == \
+        "tensorflow.linalg.matmul(" \
+            "tensorflow.linalg.matmul(" \
+                "tensorflow.linalg.matmul(M, N), P), Q)"
     _compare_tensorflow_matrix((M, N, P, Q), expr)
 
     expr = M**3
-    assert tensorflow_code(expr) == "tensorflow.matmul(tensorflow.matmul(M, M), M)"
+    assert tensorflow_code(expr) == \
+        "tensorflow.linalg.matmul(tensorflow.linalg.matmul(M, M), M)"
     _compare_tensorflow_matrix((M,), expr)
 
-    expr = M.T
-    assert tensorflow_code(expr) == "tensorflow.matrix_transpose(M)"
+    expr = Trace(M)
+    assert tensorflow_code(expr) == "tensorflow.linalg.trace(M)"
     _compare_tensorflow_matrix((M,), expr)
 
-    expr = Trace(M)
-    assert tensorflow_code(expr) == "tensorflow.trace(M)"
+    expr = Determinant(M)
+    assert tensorflow_code(expr) == "tensorflow.linalg.det(M)"
+    _compare_tensorflow_matrix_scalar((M,), expr)
+
+    expr = Inverse(M)
+    assert tensorflow_code(expr) == "tensorflow.linalg.inv(M)"
+    _compare_tensorflow_matrix((M,), expr, use_float=True)
+
+    expr = M.T
+    assert tensorflow_code(expr, tensorflow_version='1.14') == \
+        "tensorflow.linalg.matrix_transpose(M)"
+    assert tensorflow_code(expr, tensorflow_version='1.13') == \
+        "tensorflow.matrix_transpose(M)"
+
     _compare_tensorflow_matrix((M,), expr)
 
 
@@ -83,84 +317,95 @@ def test_codegen_einsum():
     if not tf:
         skip("TensorFlow not installed")
 
-    session = tf.Session()
+    graph = tf.Graph()
+    with graph.as_default():
+        session = tf.compat.v1.Session(graph=graph)
 
-    M = MatrixSymbol("M", 2, 2)
-    N = MatrixSymbol("N", 2, 2)
+        M = MatrixSymbol("M", 2, 2)
+        N = MatrixSymbol("N", 2, 2)
 
-    cg = CodegenArrayContraction.from_MatMul(M*N)
-    f = lambdify((M, N), cg, 'tensorflow')
+        cg = CodegenArrayContraction.from_MatMul(M*N)
+        f = lambdify((M, N), cg, 'tensorflow')
 
-    ma = tf.constant([[1, 2], [3, 4]])
-    mb = tf.constant([[1,-2], [-1, 3]])
-    y = session.run(f(ma, mb))
-    c = session.run(tf.matmul(ma, mb))
-    assert (y == c).all()
+        ma = tf.constant([[1, 2], [3, 4]])
+        mb = tf.constant([[1,-2], [-1, 3]])
+        y = session.run(f(ma, mb))
+        c = session.run(tf.matmul(ma, mb))
+        assert (y == c).all()
 
 
 def test_codegen_extra():
     if not tf:
         skip("TensorFlow not installed")
 
-    session = tf.Session()
-
-    M = MatrixSymbol("M", 2, 2)
-    N = MatrixSymbol("N", 2, 2)
-    P = MatrixSymbol("P", 2, 2)
-    Q = MatrixSymbol("Q", 2, 2)
-    ma = tf.constant([[1, 2], [3, 4]])
-    mb = tf.constant([[1,-2], [-1, 3]])
-    mc = tf.constant([[2, 0], [1, 2]])
-    md = tf.constant([[1,-1], [4, 7]])
-
-    cg = CodegenArrayTensorProduct(M, N)
-    assert tensorflow_code(cg) == 'tensorflow.einsum("ab,cd", M, N)'
-    f = lambdify((M, N), cg, 'tensorflow')
-    y = session.run(f(ma, mb))
-    c = session.run(tf.einsum("ij,kl", ma, mb))
-    assert (y == c).all()
-
-    cg = CodegenArrayElementwiseAdd(M, N)
-    assert tensorflow_code(cg) == 'tensorflow.add(M, N)'
-    f = lambdify((M, N), cg, 'tensorflow')
-    y = session.run(f(ma, mb))
-    c = session.run(ma + mb)
-    assert (y == c).all()
-
-    cg = CodegenArrayElementwiseAdd(M, N, P)
-    assert tensorflow_code(cg) == 'tensorflow.add(tensorflow.add(M, N), P)'
-    f = lambdify((M, N, P), cg, 'tensorflow')
-    y = session.run(f(ma, mb, mc))
-    c = session.run(ma + mb + mc)
-    assert (y == c).all()
-
-    cg = CodegenArrayElementwiseAdd(M, N, P, Q)
-    assert tensorflow_code(cg) == 'tensorflow.add(tensorflow.add(tensorflow.add(M, N), P), Q)'
-    f = lambdify((M, N, P, Q), cg, 'tensorflow')
-    y = session.run(f(ma, mb, mc, md))
-    c = session.run(ma + mb + mc + md)
-    assert (y == c).all()
-
-    cg = CodegenArrayPermuteDims(M, [1, 0])
-    assert tensorflow_code(cg) == 'tensorflow.transpose(M, [1, 0])'
-    f = lambdify((M,), cg, 'tensorflow')
-    y = session.run(f(ma))
-    c = session.run(tf.transpose(ma))
-    assert (y == c).all()
-
-    cg = CodegenArrayPermuteDims(CodegenArrayTensorProduct(M, N), [1, 2, 3, 0])
-    assert tensorflow_code(cg) == 'tensorflow.transpose(tensorflow.einsum("ab,cd", M, N), [1, 2, 3, 0])'
-    f = lambdify((M, N), cg, 'tensorflow')
-    y = session.run(f(ma, mb))
-    c = session.run(tf.transpose(tf.einsum("ab,cd", ma, mb), [1, 2, 3, 0]))
-    assert (y == c).all()
-
-    cg = CodegenArrayDiagonal(CodegenArrayTensorProduct(M, N), (1, 2))
-    assert tensorflow_code(cg) == 'tensorflow.einsum("ab,bc->acb", M, N)'
-    f = lambdify((M, N), cg, 'tensorflow')
-    y = session.run(f(ma, mb))
-    c = session.run(tf.einsum("ab,bc->acb", ma, mb))
-    assert (y == c).all()
+    graph = tf.Graph()
+    with graph.as_default():
+        session = tf.compat.v1.Session()
+
+        M = MatrixSymbol("M", 2, 2)
+        N = MatrixSymbol("N", 2, 2)
+        P = MatrixSymbol("P", 2, 2)
+        Q = MatrixSymbol("Q", 2, 2)
+        ma = tf.constant([[1, 2], [3, 4]])
+        mb = tf.constant([[1,-2], [-1, 3]])
+        mc = tf.constant([[2, 0], [1, 2]])
+        md = tf.constant([[1,-1], [4, 7]])
+
+        cg = CodegenArrayTensorProduct(M, N)
+        assert tensorflow_code(cg) == \
+            'tensorflow.linalg.einsum("ab,cd", M, N)'
+        f = lambdify((M, N), cg, 'tensorflow')
+        y = session.run(f(ma, mb))
+        c = session.run(tf.einsum("ij,kl", ma, mb))
+        assert (y == c).all()
+
+        cg = CodegenArrayElementwiseAdd(M, N)
+        assert tensorflow_code(cg) == 'tensorflow.math.add(M, N)'
+        f = lambdify((M, N), cg, 'tensorflow')
+        y = session.run(f(ma, mb))
+        c = session.run(ma + mb)
+        assert (y == c).all()
+
+        cg = CodegenArrayElementwiseAdd(M, N, P)
+        assert tensorflow_code(cg) == \
+            'tensorflow.math.add(tensorflow.math.add(M, N), P)'
+        f = lambdify((M, N, P), cg, 'tensorflow')
+        y = session.run(f(ma, mb, mc))
+        c = session.run(ma + mb + mc)
+        assert (y == c).all()
+
+        cg = CodegenArrayElementwiseAdd(M, N, P, Q)
+        assert tensorflow_code(cg) == \
+            'tensorflow.math.add(' \
+                'tensorflow.math.add(tensorflow.math.add(M, N), P), Q)'
+        f = lambdify((M, N, P, Q), cg, 'tensorflow')
+        y = session.run(f(ma, mb, mc, md))
+        c = session.run(ma + mb + mc + md)
+        assert (y == c).all()
+
+        cg = CodegenArrayPermuteDims(M, [1, 0])
+        assert tensorflow_code(cg) == 'tensorflow.transpose(M, [1, 0])'
+        f = lambdify((M,), cg, 'tensorflow')
+        y = session.run(f(ma))
+        c = session.run(tf.transpose(ma))
+        assert (y == c).all()
+
+        cg = CodegenArrayPermuteDims(CodegenArrayTensorProduct(M, N), [1, 2, 3, 0])
+        assert tensorflow_code(cg) == \
+            'tensorflow.transpose(' \
+                'tensorflow.linalg.einsum("ab,cd", M, N), [1, 2, 3, 0])'
+        f = lambdify((M, N), cg, 'tensorflow')
+        y = session.run(f(ma, mb))
+        c = session.run(tf.transpose(tf.einsum("ab,cd", ma, mb), [1, 2, 3, 0]))
+        assert (y == c).all()
+
+        cg = CodegenArrayDiagonal(CodegenArrayTensorProduct(M, N), (1, 2))
+        assert tensorflow_code(cg) == \
+            'tensorflow.linalg.einsum("ab,bc->acb", M, N)'
+        f = lambdify((M, N), cg, 'tensorflow')
+        y = session.run(f(ma, mb))
+        c = session.run(tf.einsum("ab,bc->acb", ma, mb))
+        assert (y == c).all()
 
 
 def test_MatrixElement_printing():
@@ -172,11 +417,10 @@ def test_MatrixElement_printing():
     assert tensorflow_code(3 * A[0, 0]) == "3*A[0, 0]"
 
     F = C[0, 0].subs(C, A - B)
-    assert tensorflow_code(F) == "(tensorflow.add((-1)*B, A))[0, 0]"
+    assert tensorflow_code(F) == "(tensorflow.math.add((-1)*B, A))[0, 0]"
 
 
 def test_tensorflow_Derivative():
-    f = Function("f")
-
     expr = Derivative(sin(x), x)
-    assert tensorflow_code(expr) == "tensorflow.gradients(tensorflow.sin(x), x)[0]"
+    assert tensorflow_code(expr) == \
+        "tensorflow.gradients(tensorflow.math.sin(x), x)[0]"
diff --git a/sympy/utilities/lambdify.py b/sympy/utilities/lambdify.py
index 070181d..38d6310 100644
--- a/sympy/utilities/lambdify.py
+++ b/sympy/utilities/lambdify.py
@@ -4,6 +4,199 @@
 """
 
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-17103/sympy/utilities/lambdify.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 import inspect
 import keyword
@@ -11,6 +204,8 @@
 import textwrap
 import linecache
 
+from types import FunctionType
+
 from sympy.core.compatibility import (exec_, is_sequence, iterable,
     NotIterable, string_types, range, builtins, PY3)
 from sympy.utilities.misc import filldedent
@@ -82,15 +277,7 @@
 NUMPY_TRANSLATIONS = {}
 SCIPY_TRANSLATIONS = {}
 
-TENSORFLOW_TRANSLATIONS = {
-    "Abs": "abs",
-    "ceiling": "ceil",
-    "im": "imag",
-    "ln": "log",
-    "Mod": "mod",
-    "conjugate": "conj",
-    "re": "real",
-}
+TENSORFLOW_TRANSLATIONS = {}
 
 NUMEXPR_TRANSLATIONS = {}
 
@@ -100,7 +287,7 @@
     "mpmath": (MPMATH, MPMATH_DEFAULT, MPMATH_TRANSLATIONS, ("from mpmath import *",)),
     "numpy": (NUMPY, NUMPY_DEFAULT, NUMPY_TRANSLATIONS, ("import numpy; from numpy import *; from numpy.linalg import *",)),
     "scipy": (SCIPY, SCIPY_DEFAULT, SCIPY_TRANSLATIONS, ("import numpy; import scipy; from scipy import *; from scipy.special import *",)),
-    "tensorflow": (TENSORFLOW, TENSORFLOW_DEFAULT, TENSORFLOW_TRANSLATIONS, ("from tensorflow import *",)),
+    "tensorflow": (TENSORFLOW, TENSORFLOW_DEFAULT, TENSORFLOW_TRANSLATIONS, ("import tensorflow",)),
     "sympy": (SYMPY, SYMPY_DEFAULT, {}, (
         "from sympy.functions import *",
         "from sympy.matrices import *",
@@ -173,6 +360,7 @@ def _import(module, reload=False):
 # linecache.
 _lambdify_generated_counter = 1
 
+@inspect_code
 @doctest_depends_on(modules=('numpy', 'tensorflow', ), python_version=(3,))
 def lambdify(args, expr, modules=None, printer=None, use_imps=True,
              dummify=False):
@@ -588,21 +776,45 @@ def _lambdifygenerated(x):
     Usage with Tensorflow:
 
     >>> import tensorflow as tf
-    >>> from sympy import Max, sin
+    >>> from sympy import Max, sin, lambdify
+    >>> from sympy.abc import x
+
     >>> f = Max(x, sin(x))
     >>> func = lambdify(x, f, 'tensorflow')
+
+    After tensorflow v2, eager execution is enabled by default.
+    If you want to get the compatible result across tensorflow v1 and v2
+    as same as this tutorial, run this line.
+
+    >>> tf.compat.v1.enable_eager_execution()
+
+    If you have eager execution enabled, you can get the result out
+    immediately as you can use numpy.
+
+    If you pass tensorflow objects, you may get an ``EagerTensor``
+    object instead of value.
+
     >>> result = func(tf.constant(1.0))
-    >>> print(result) # a tf.Tensor representing the result of the calculation
-    Tensor("Maximum:0", shape=(), dtype=float32)
-    >>> sess = tf.Session()
-    >>> sess.run(result) # compute result
-    1.0
-    >>> var = tf.Variable(1.0)
-    >>> sess.run(tf.global_variables_initializer())
-    >>> sess.run(func(var)) # also works for tf.Variable and tf.Placeholder
+    >>> print(result)
+    tf.Tensor(1.0, shape=(), dtype=float32)
+    >>> print(result.__class__)
+    <class 'tensorflow.python.framework.ops.EagerTensor'>
+
+    You can use ``.numpy()`` to get the numpy value of the tensor.
+
+    >>> result.numpy()
     1.0
-    >>> tensor = tf.constant([[1.0, 2.0], [3.0, 4.0]]) # works with any shape tensor
-    >>> sess.run(func(tensor))
+
+    >>> var = tf.Variable(2.0)
+    >>> result = func(var) # also works for tf.Variable and tf.Placeholder
+    >>> result.numpy()
+    2.0
+
+    And it works with any shape array.
+
+    >>> tensor = tf.constant([[1.0, 2.0], [3.0, 4.0]])
+    >>> result = func(tensor)
+    >>> result.numpy()
     [[1. 2.]
      [3. 4.]]
 
@@ -763,9 +975,16 @@ def _lambdifygenerated(x):
     for mod, keys in (getattr(printer, 'module_imports', None) or {}).items():
         for k in keys:
             if k not in namespace:
-                imp_mod_lines.append("from %s import %s" % (mod, k))
-    for ln in imp_mod_lines:
-        exec_(ln, {}, namespace)
+                ln = "from %s import %s" % (mod, k)
+                try:
+                    exec_(ln, {}, namespace)
+                except ImportError:
+                    # Tensorflow 2.0 has issues with importing a specific
+                    # function from its submodule.
+                    # https://github.com/tensorflow/tensorflow/issues/33022
+                    ln = "%s = %s.%s" % (k, mod, k)
+                    exec_(ln, {}, namespace)
+                imp_mod_lines.append(ln)
 
     # Provide lambda expression with builtins, and compatible implementation of range
     namespace.update({'builtins':builtins, 'range':range})
diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py
index 3b4f1c0..db789f6 100644
--- a/sympy/utilities/tests/test_lambdify.py
+++ b/sympy/utilities/tests/test_lambdify.py
@@ -11,8 +11,11 @@
     true, false, And, Or, Not, ITE, Min, Max, floor, diff, IndexedBase, Sum,
     DotProduct, Eq, Dummy, sinc, erf, erfc, factorial, gamma, loggamma,
     digamma, RisingFactorial, besselj, bessely, besseli, besselk, S, beta,
-    MatrixSymbol, chebyshevt, chebyshevu, legendre, hermite, laguerre,
-    gegenbauer, assoc_legendre, assoc_laguerre, jacobi, fresnelc, fresnels)
+    MatrixSymbol, fresnelc, fresnels)
+from sympy.functions.elementary.complexes import re, im, Abs, arg
+from sympy.functions.special.polynomials import \
+    chebyshevt, chebyshevu, legendre, hermite, laguerre, gegenbauer, \
+    assoc_legendre, assoc_laguerre, jacobi
 from sympy.printing.lambdarepr import LambdaPrinter
 from sympy.printing.pycode import NumPyPrinter
 from sympy.utilities.lambdify import implemented_function, lambdastr
@@ -204,17 +207,6 @@ def test_scipy_transl():
         assert scip in scipy.__dict__ or scip in scipy.special.__dict__
 
 
-def test_tensorflow_transl():
-    if not tensorflow:
-        skip("tensorflow not installed")
-
-    from sympy.utilities.lambdify import TENSORFLOW_TRANSLATIONS
-    for sym, tens in TENSORFLOW_TRANSLATIONS.items():
-        assert sym in sympy.__dict__
-        # XXX __dict__ is not supported after tensorflow 1.14.0
-        assert tens in tensorflow.__all__
-
-
 def test_numpy_translation_abs():
     if not numpy:
         skip("numpy not installed.")
@@ -571,9 +563,10 @@ def test_tensorflow_basic_math():
         skip("tensorflow not installed.")
     expr = Max(sin(x), Abs(1/(x+2)))
     func = lambdify(x, expr, modules="tensorflow")
-    a = tensorflow.constant(0, dtype=tensorflow.float32)
-    s = tensorflow.Session()
-    assert func(a).eval(session=s) == 0.5
+
+    with tensorflow.compat.v1.Session() as s:
+        a = tensorflow.constant(0, dtype=tensorflow.float32)
+        assert func(a).eval(session=s) == 0.5
 
 
 def test_tensorflow_placeholders():
@@ -581,9 +574,10 @@ def test_tensorflow_placeholders():
         skip("tensorflow not installed.")
     expr = Max(sin(x), Abs(1/(x+2)))
     func = lambdify(x, expr, modules="tensorflow")
-    a = tensorflow.placeholder(dtype=tensorflow.float32)
-    s = tensorflow.Session()
-    assert func(a).eval(session=s, feed_dict={a: 0}) == 0.5
+
+    with tensorflow.compat.v1.Session() as s:
+        a = tensorflow.compat.v1.placeholder(dtype=tensorflow.float32)
+        assert func(a).eval(session=s, feed_dict={a: 0}) == 0.5
 
 
 def test_tensorflow_variables():
@@ -591,13 +585,11 @@ def test_tensorflow_variables():
         skip("tensorflow not installed.")
     expr = Max(sin(x), Abs(1/(x+2)))
     func = lambdify(x, expr, modules="tensorflow")
-    a = tensorflow.Variable(0, dtype=tensorflow.float32)
-    s = tensorflow.Session()
-    if V(tensorflow.__version__) < '1.0':
-        s.run(tensorflow.initialize_all_variables())
-    else:
-        s.run(tensorflow.global_variables_initializer())
-    assert func(a).eval(session=s) == 0.5
+
+    with tensorflow.compat.v1.Session() as s:
+        a = tensorflow.Variable(0, dtype=tensorflow.float32)
+        s.run(a.initializer)
+        assert func(a).eval(session=s, feed_dict={a: 0}) == 0.5
 
 
 def test_tensorflow_logical_operations():
@@ -605,10 +597,9 @@ def test_tensorflow_logical_operations():
         skip("tensorflow not installed.")
     expr = Not(And(Or(x, y), y))
     func = lambdify([x, y], expr, modules="tensorflow")
-    a = tensorflow.constant(False)
-    b = tensorflow.constant(True)
-    s = tensorflow.Session()
-    assert func(a, b).eval(session=s) == 0
+
+    with tensorflow.compat.v1.Session() as s:
+        assert func(False, True).eval(session=s) == False
 
 
 def test_tensorflow_piecewise():
@@ -616,11 +607,11 @@ def test_tensorflow_piecewise():
         skip("tensorflow not installed.")
     expr = Piecewise((0, Eq(x,0)), (-1, x < 0), (1, x > 0))
     func = lambdify(x, expr, modules="tensorflow")
-    a = tensorflow.placeholder(dtype=tensorflow.float32)
-    s = tensorflow.Session()
-    assert func(a).eval(session=s, feed_dict={a: -1}) == -1
-    assert func(a).eval(session=s, feed_dict={a: 0}) == 0
-    assert func(a).eval(session=s, feed_dict={a: 1}) == 1
+
+    with tensorflow.compat.v1.Session() as s:
+        assert func(-1).eval(session=s) == -1
+        assert func(0).eval(session=s) == 0
+        assert func(1).eval(session=s) == 1
 
 
 def test_tensorflow_multi_max():
@@ -628,9 +619,9 @@ def test_tensorflow_multi_max():
         skip("tensorflow not installed.")
     expr = Max(x, -x, x**2)
     func = lambdify(x, expr, modules="tensorflow")
-    a = tensorflow.placeholder(dtype=tensorflow.float32)
-    s = tensorflow.Session()
-    assert func(a).eval(session=s, feed_dict={a: -2}) == 4
+
+    with tensorflow.compat.v1.Session() as s:
+        assert func(-2).eval(session=s) == 4
 
 
 def test_tensorflow_multi_min():
@@ -638,9 +629,9 @@ def test_tensorflow_multi_min():
         skip("tensorflow not installed.")
     expr = Min(x, -x, x**2)
     func = lambdify(x, expr, modules="tensorflow")
-    a = tensorflow.placeholder(dtype=tensorflow.float32)
-    s = tensorflow.Session()
-    assert func(a).eval(session=s, feed_dict={a: -2}) == -2
+
+    with tensorflow.compat.v1.Session() as s:
+        assert func(-2).eval(session=s) == -2
 
 
 def test_tensorflow_relational():
@@ -648,9 +639,50 @@ def test_tensorflow_relational():
         skip("tensorflow not installed.")
     expr = x >= 0
     func = lambdify(x, expr, modules="tensorflow")
-    a = tensorflow.placeholder(dtype=tensorflow.float32)
-    s = tensorflow.Session()
-    assert func(a).eval(session=s, feed_dict={a: 1})
+
+    with tensorflow.compat.v1.Session() as s:
+        assert func(1).eval(session=s) == True
+
+
+def test_tensorflow_complexes():
+    if not tensorflow:
+        skip("tensorflow not installed")
+
+    func1 = lambdify(x, re(x), modules="tensorflow")
+    func2 = lambdify(x, im(x), modules="tensorflow")
+    func3 = lambdify(x, Abs(x), modules="tensorflow")
+    func4 = lambdify(x, arg(x), modules="tensorflow")
+
+    with tensorflow.compat.v1.Session() as s:
+        # For versions before
+        # https://github.com/tensorflow/tensorflow/issues/30029
+        # resolved, using python numeric types may not work
+        a = tensorflow.constant(1+2j)
+        assert func1(a).eval(session=s) == 1
+        assert func2(a).eval(session=s) == 2
+
+        tensorflow_result = func3(a).eval(session=s)
+        sympy_result = Abs(1 + 2j).evalf()
+        assert abs(tensorflow_result-sympy_result) < 10**-6
+
+        tensorflow_result = func4(a).eval(session=s)
+        sympy_result = arg(1 + 2j).evalf()
+        assert abs(tensorflow_result-sympy_result) < 10**-6
+
+
+def test_tensorflow_array_arg():
+    # Test for issue 14655 (tensorflow part)
+    if not tensorflow:
+        skip("tensorflow not installed.")
+
+    f = lambdify([[x, y]], x*x + y, 'tensorflow')
+
+    with tensorflow.compat.v1.Session() as s:
+        fcall = f(tensorflow.constant([2.0, 1.0]))
+        assert fcall.eval(session=s) == 5.0
+
+
+#================== Test symbolic ==================================
 
 
 def test_integral():
@@ -658,8 +690,6 @@ def test_integral():
     l = lambdify(x, Integral(f(x), (x, -oo, oo)), modules="sympy")
     assert l(x) == Integral(exp(-x**2), (x, -oo, oo))
 
-#================== Test symbolic ==================================
-
 
 def test_sym_single_arg():
     f = lambdify(x, x * y)
@@ -969,19 +999,6 @@ def test_numpy_array_arg():
     assert f(numpy.array([2.0, 1.0])) == 5
 
 
-def test_tensorflow_array_arg():
-    # Test for issue 14655 (tensorflow part)
-    if not tensorflow:
-        skip("tensorflow not installed.")
-
-    f = lambdify([[x, y]], x*x + y, 'tensorflow')
-
-    fcall = f(tensorflow.constant([2.0, 1.0]))
-
-    s = tensorflow.Session()
-    assert s.run(fcall) == 5
-
-
 def test_scipy_fns():
     if not scipy:
         skip("scipy not installed")
