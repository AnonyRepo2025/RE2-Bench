diff --git a/astropy/utils/masked/core.py b/astropy/utils/masked/core.py
index 8a634cb..5139e85 100644
--- a/astropy/utils/masked/core.py
+++ b/astropy/utils/masked/core.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-14590/astropy/utils/masked/core.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 """
 Built-in mask mixin class.
@@ -671,22 +864,38 @@ class MaskedNDArray(Masked, np.ndarray, base_cls=np.ndarray, data_cls=np.ndarray
         )
         return result.any(axis=-1)
 
-    def _combine_masks(self, masks, out=None):
+    def _combine_masks(self, masks, out=None, where=True, copy=True):
+        """Combine masks, possibly storing it in some output.
+
+        Parameters
+        ----------
+        masks : tuple of array of bool or None
+            Input masks.  Any that are `None` or `False` are ignored.
+            Should broadcast to each other.
+        out : output mask array, optional
+            Possible output array to hold the result.
+        where : array of bool, optional
+            Which elements of the output array to fill.
+        copy : bool optional
+            Whether to ensure a copy is made. Only relevant if a single
+            input mask is not `None`, and ``out`` is not given.
+        """
         masks = [m for m in masks if m is not None and m is not False]
         if not masks:
             return False
         if len(masks) == 1:
             if out is None:
-                return masks[0].copy()
+                return masks[0].copy() if copy else masks[0]
             else:
-                np.copyto(out, masks[0])
+                np.copyto(out, masks[0], where=where)
                 return out
 
-        out = np.logical_or(masks[0], masks[1], out=out)
+        out = np.logical_or(masks[0], masks[1], out=out, where=where)
         for mask in masks[2:]:
-            np.logical_or(out, mask, out=out)
+            np.logical_or(out, mask, out=out, where=where)
         return out
 
+    @inspect_code
     def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):
         out = kwargs.pop("out", None)
         out_unmasked = None
@@ -701,6 +910,15 @@ class MaskedNDArray(Masked, np.ndarray, base_cls=np.ndarray, data_cls=np.ndarray
                 elif out_mask is None:
                     out_mask = m
 
+        # TODO: where is only needed for __call__ and reduce;
+        # this is very fast, but still worth separating out?
+        where = kwargs.pop("where", True)
+        if where is True:
+            where_unmasked = True
+            where_mask = None
+        else:
+            where_unmasked, where_mask = self._get_data_and_mask(where)
+
         unmasked, masks = self._get_data_and_masks(*inputs)
 
         if ufunc.signature:
@@ -731,7 +949,7 @@ class MaskedNDArray(Masked, np.ndarray, base_cls=np.ndarray, data_cls=np.ndarray
                         else np.logical_or.reduce(mask1)
                     )
 
-                mask = self._combine_masks(masks, out=out_mask)
+                mask = self._combine_masks(masks, out=out_mask, copy=False)
 
             else:
                 # Parse signature with private numpy function. Note it
@@ -769,7 +987,11 @@ class MaskedNDArray(Masked, np.ndarray, base_cls=np.ndarray, data_cls=np.ndarray
 
         elif method == "__call__":
             # Regular ufunc call.
-            mask = self._combine_masks(masks, out=out_mask)
+            # Combine the masks from the input, possibly selecting elements.
+            mask = self._combine_masks(masks, out=out_mask, where=where_unmasked)
+            # If relevant, also mask output elements for which where was masked.
+            if where_mask is not None:
+                mask |= where_mask
 
         elif method == "outer":
             # Must have two arguments; adjust masks as will be done for data.
@@ -779,51 +1001,50 @@ class MaskedNDArray(Masked, np.ndarray, base_cls=np.ndarray, data_cls=np.ndarray
 
         elif method in {"reduce", "accumulate"}:
             # Reductions like np.add.reduce (sum).
-            if masks[0] is not None:
+            # Treat any masked where as if the input element was masked.
+            mask = self._combine_masks((masks[0], where_mask), copy=False)
+            if mask is not False:
                 # By default, we simply propagate masks, since for
                 # things like np.sum, it makes no sense to do otherwise.
                 # Individual methods need to override as needed.
-                # TODO: take care of 'out' too?
                 if method == "reduce":
                     axis = kwargs.get("axis", None)
                     keepdims = kwargs.get("keepdims", False)
-                    where = kwargs.get("where", True)
                     mask = np.logical_or.reduce(
-                        masks[0],
-                        where=where,
+                        mask,
+                        where=where_unmasked,
                         axis=axis,
                         keepdims=keepdims,
                         out=out_mask,
                     )
-                    if where is not True:
-                        # Mask also whole rows that were not selected by where,
-                        # so would have been left as unmasked above.
-                        mask |= np.logical_and.reduce(
-                            masks[0], where=where, axis=axis, keepdims=keepdims
+                    if where_unmasked is not True:
+                        # Mask also whole rows in which no elements were selected;
+                        # those will have been left as unmasked above.
+                        mask |= ~np.logical_or.reduce(
+                            where_unmasked, axis=axis, keepdims=keepdims
                         )
 
                 else:
                     # Accumulate
                     axis = kwargs.get("axis", 0)
-                    mask = np.logical_or.accumulate(masks[0], axis=axis, out=out_mask)
+                    mask = np.logical_or.accumulate(mask, axis=axis, out=out_mask)
 
-            elif out is not None:
-                mask = False
-
-            else:  # pragma: no cover
+            elif out is None:
                 # Can only get here if neither input nor output was masked, but
-                # perhaps axis or where was masked (in NUMPY_LT_1_21 this is
-                # possible).  We don't support this.
+                # perhaps where was masked (possible in "not NUMPY_LT_1_25" and
+                # in NUMPY_LT_1_21 (latter also allowed axis).
+                # We don't support this.
                 return NotImplemented
 
         elif method in {"reduceat", "at"}:  # pragma: no cover
-            # TODO: implement things like np.add.accumulate (used for cumsum).
             raise NotImplementedError(
                 "masked instances cannot yet deal with 'reduceat' or 'at'."
             )
 
         if out_unmasked is not None:
             kwargs["out"] = out_unmasked
+        if where_unmasked is not True:
+            kwargs["where"] = where_unmasked
         result = getattr(ufunc, method)(*unmasked, **kwargs)
 
         if result is None:  # pragma: no cover
diff --git a/astropy/utils/masked/tests/test_functions.py b/astropy/utils/masked/tests/test_functions.py
index 822990e..b6413ce 100644
--- a/astropy/utils/masked/tests/test_functions.py
+++ b/astropy/utils/masked/tests/test_functions.py
@@ -11,6 +11,7 @@ from numpy.testing import assert_array_equal
 
 from astropy import units as u
 from astropy.units import Quantity
+from astropy.utils.compat.numpycompat import NUMPY_LT_1_25
 from astropy.utils.masked.core import Masked
 
 from .test_masked import (
@@ -44,6 +45,57 @@ class MaskedUfuncTests(MaskedArraySetup):
         assert result is out
         assert_masked_equal(result, ma_mb)
 
+    @pytest.mark.parametrize("base_mask", [True, False])
+    def test_ufunc_inplace_where(self, base_mask):
+        # Construct base filled with -9 and base_mask (copying to get unit/class).
+        base = self.ma.copy()
+        base.unmasked.view(np.ndarray)[...] = -9.0
+        base._mask[...] = base_mask
+        out = base.copy()
+        where = np.array([[True, False, False], [False, True, False]])
+        result = np.add(self.ma, self.mb, out=out, where=where)
+        # Direct checks.
+        assert np.all(result.unmasked[~where] == base.unmasked[0, 0])
+        assert np.all(result.unmasked[where] == (self.a + self.b)[where])
+        # Full comparison.
+        expected = base.unmasked.copy()
+        np.add(self.a, self.b, out=expected, where=where)
+        expected_mask = base.mask.copy()
+        np.logical_or(self.mask_a, self.mask_b, out=expected_mask, where=where)
+        assert_array_equal(result.unmasked, expected)
+        assert_array_equal(result.mask, expected_mask)
+
+    @pytest.mark.parametrize("base_mask", [True, False])
+    def test_ufunc_inplace_masked_where(self, base_mask):
+        base = self.ma.copy()
+        base.unmasked.view(np.ndarray)[...] = -9.0
+        base._mask[...] = base_mask
+        out = base.copy()
+        where = Masked(
+            [[True, False, True], [False, False, True]],
+            mask=[[True, False, False], [True, False, True]],
+        )
+        result = np.add(self.ma, self.mb, out=out, where=where)
+        # Direct checks.
+        assert np.all(result.unmasked[~where.unmasked] == base.unmasked[0, 0])
+        assert np.all(
+            result.unmasked[where.unmasked] == (self.a + self.b)[where.unmasked]
+        )
+        assert np.all(result.mask[where.mask])
+        assert np.all(result.mask[~where.mask & ~where.unmasked] == base.mask[0, 0])
+        assert np.all(
+            result.mask[~where.mask & where.unmasked]
+            == (self.mask_a | self.mask_b)[~where.mask & where.unmasked]
+        )
+        # Full comparison.
+        expected = base.unmasked.copy()
+        np.add(self.a, self.b, out=expected, where=where.unmasked)
+        expected_mask = base.mask.copy()
+        np.logical_or(self.mask_a, self.mask_b, out=expected_mask, where=where.unmasked)
+        expected_mask |= where.mask
+        assert_array_equal(result.unmasked, expected)
+        assert_array_equal(result.mask, expected_mask)
+
     def test_ufunc_inplace_no_masked_input(self):
         a_b = np.add(self.a, self.b)
         out = Masked(np.zeros_like(a_b))
@@ -53,10 +105,19 @@ class MaskedUfuncTests(MaskedArraySetup):
         assert_array_equal(result.mask, np.zeros(a_b.shape, bool))
 
     def test_ufunc_inplace_error(self):
+        # Output is not masked.
         out = np.zeros(self.ma.shape)
         with pytest.raises(TypeError):
             np.add(self.ma, self.mb, out=out)
 
+    @pytest.mark.xfail(NUMPY_LT_1_25, reason="masked where not supported in numpy<1.25")
+    def test_ufunc_inplace_error_masked_where(self):
+        # Input and output are not masked, but where is.
+        # Note: prior to numpy 1.25, we cannot control this.
+        out = self.a.copy()
+        with pytest.raises(TypeError):
+            np.add(self.a, self.b, out=out, where=Masked(True, mask=True))
+
     @pytest.mark.parametrize("ufunc", (np.add.outer, np.minimum.outer))
     def test_2op_ufunc_outer(self, ufunc):
         ma_mb = ufunc(self.ma, self.mb)
