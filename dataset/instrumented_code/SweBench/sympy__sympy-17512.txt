diff --git a/sympy/sets/fancysets.py b/sympy/sets/fancysets.py
index e7c6e1b..4cb198d 100644
--- a/sympy/sets/fancysets.py
+++ b/sympy/sets/fancysets.py
@@ -1,14 +1,207 @@
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-17512/sympy/sets/fancysets.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 from sympy.core.basic import Basic
 from sympy.core.compatibility import as_int, with_metaclass, range, PY3
 from sympy.core.expr import Expr
 from sympy.core.function import Lambda
+from sympy.core.numbers import oo, Integer
 from sympy.core.logic import fuzzy_or
-from sympy.core.numbers import oo
 from sympy.core.relational import Eq
 from sympy.core.singleton import Singleton, S
-from sympy.core.symbol import Dummy, symbols
+from sympy.core.symbol import Dummy, symbols, Symbol
 from sympy.core.sympify import _sympify, sympify, converter
 from sympy.logic.boolalg import And
 from sympy.sets.sets import (Set, Interval, Union, FiniteSet,
@@ -509,15 +702,37 @@ class Range(Set):
         >>> Range(3).intersect(Range(4, oo))
         EmptySet()
 
+    Range will accept symbolic arguments but has very limited support
+    for doing anything other than displaying the Range:
+
+        >>> from sympy import Symbol, pprint
+        >>> from sympy.abc import i, j, k
+        >>> Range(i, j, k).start
+        i
+        >>> Range(i, j, k).inf
+        Traceback (most recent call last):
+        ...
+        ValueError: invalid method for symbolic range
+
+    Better success will be had when using integer symbols:
+
+        >>> n = Symbol('n', integer=True)
+        >>> r = Range(n, n + 20, 3)
+        >>> r.inf
+        n
+        >>> pprint(r)
+        {n, n + 3, ..., n + 17}
     """
 
     is_iterable = True
 
+    @inspect_code
     def __new__(cls, *args):
         from sympy.functions.elementary.integers import ceiling
         if len(args) == 1:
             if isinstance(args[0], range if PY3 else xrange):
-                args = args[0].__reduce__()[1]  # use pickle method
+                raise TypeError(
+                    'use sympify(%s) to convert range to Range' % args[0])
 
         # expand range
         slc = slice(*args)
@@ -527,42 +742,53 @@ def __new__(cls, *args):
 
         start, stop, step = slc.start or 0, slc.stop, slc.step or 1
         try:
-            start, stop, step = [
-                w if w in [S.NegativeInfinity, S.Infinity]
-                else sympify(as_int(w))
-                for w in (start, stop, step)]
+            ok = []
+            for w in (start, stop, step):
+                w = sympify(w)
+                if w in [S.NegativeInfinity, S.Infinity] or (
+                        w.has(Symbol) and w.is_integer != False):
+                    ok.append(w)
+                elif not w.is_Integer:
+                    raise ValueError
+                else:
+                    ok.append(w)
         except ValueError:
             raise ValueError(filldedent('''
     Finite arguments to Range must be integers; `imageset` can define
     other cases, e.g. use `imageset(i, i/10, Range(3))` to give
     [0, 1/10, 1/5].'''))
+        start, stop, step = ok
 
-        if not step.is_Integer:
-            raise ValueError(filldedent('''
-    Ranges must have a literal integer step.'''))
-
-        if all(i.is_infinite for i in  (start, stop)):
+        null = False
+        if any(i.has(Symbol) for i in (start, stop, step)):
             if start == stop:
-                # canonical null handled below
-                start = stop = S.One
+                null = True
             else:
+                end = stop
+        elif start.is_infinite:
+            span = step*(stop - start)
+            if span is S.NaN or span <= 0:
+                null = True
+            elif step.is_Integer and stop.is_infinite and abs(step) != 1:
                 raise ValueError(filldedent('''
-    Either the start or end value of the Range must be finite.'''))
-
-        if start.is_infinite:
-            if step*(stop - start) < 0:
-                start = stop = S.One
+                    Step size must be %s in this case.''' % (1 if step > 0 else -1)))
             else:
                 end = stop
-        if not start.is_infinite:
-            ref = start if start.is_finite else stop
-            n = ceiling((stop - ref)/step)
+        else:
+            oostep = step.is_infinite
+            if oostep:
+                step = S.One if step > 0 else S.NegativeOne
+            n = ceiling((stop - start)/step)
             if n <= 0:
-                # null Range
-                start = end = S.Zero
-                step = S.One
+                null = True
+            elif oostep:
+                end = start + 1
+                step = S.One  # make it a canonical single step
             else:
-                end = ref + n*step
+                end = start + n*step
+        if null:
+            start = end = S.Zero
+            step = S.One
         return Basic.__new__(cls, start, end, step)
 
     start = property(lambda self: self.args[0])
@@ -570,6 +796,7 @@ def __new__(cls, *args):
     step = property(lambda self: self.args[2])
 
     @property
+    @inspect_code
     def reversed(self):
         """Return an equivalent Range in the opposite order.
 
@@ -580,6 +807,8 @@ def reversed(self):
         >>> Range(10).reversed
         Range(9, -1, -1)
         """
+        if self.has(Symbol):
+            _ = self.size  # validate
         if not self:
             return self
         return self.func(
@@ -592,12 +821,19 @@ def _contains(self, other):
             return S.false
         if not other.is_integer:
             return other.is_integer
+        if self.has(Symbol):
+            try:
+                _ = self.size  # validate
+            except ValueError:
+                return
         ref = self.start if self.start.is_finite else self.stop
         if (ref - other) % self.step:  # off sequence
             return S.false
         return _sympify(other >= self.inf and other <= self.sup)
 
     def __iter__(self):
+        if self.has(Symbol):
+            _ = self.size  # validate
         if self.start in [S.NegativeInfinity, S.Infinity]:
             raise ValueError("Cannot iterate over Range with infinite start")
         elif self:
@@ -612,26 +848,30 @@ def __iter__(self):
                 i += step
 
     def __len__(self):
-        if not self:
-            return 0
-        dif = self.stop - self.start
-        if dif.is_infinite:
-            raise ValueError(
-                "Use .size to get the length of an infinite Range")
-        return abs(dif//self.step)
+        rv = self.size
+        if rv is S.Infinity:
+            raise ValueError('Use .size to get the length of an infinite Range')
+        return int(rv)
 
     @property
     def size(self):
-        try:
-            return _sympify(len(self))
-        except ValueError:
+        if not self:
+            return S.Zero
+        dif = self.stop - self.start
+        if self.has(Symbol):
+            if dif.has(Symbol) or self.step.has(Symbol) or (
+                    not self.start.is_integer and not self.stop.is_integer):
+                raise ValueError('invalid method for symbolic range')
+        if dif.is_infinite:
             return S.Infinity
+        return Integer(abs(dif//self.step))
 
     def __nonzero__(self):
         return self.start != self.stop
 
     __bool__ = __nonzero__
 
+    @inspect_code
     def __getitem__(self, i):
         from sympy.functions.elementary.integers import ceiling
         ooslice = "cannot slice from the end with an infinite value"
@@ -642,7 +882,7 @@ def __getitem__(self, i):
         ambiguous = "cannot unambiguously re-stride from the end " + \
             "with an infinite value"
         if isinstance(i, slice):
-            if self.size.is_finite:
+            if self.size.is_finite:  # validates, too
                 start, stop, step = i.indices(self.size)
                 n = ceiling((stop - start)/step)
                 if n <= 0:
@@ -740,9 +980,24 @@ def __getitem__(self, i):
             if not self:
                 raise IndexError('Range index out of range')
             if i == 0:
+                if self.start.is_infinite:
+                    raise ValueError(ooslice)
+                if self.has(Symbol):
+                    if (self.stop > self.start) == self.step.is_positive and self.step.is_positive is not None:
+                        pass
+                    else:
+                        _ = self.size  # validate
                 return self.start
-            if i == -1 or i is S.Infinity:
-                return self.stop - self.step
+            if i == -1:
+                if self.stop.is_infinite:
+                    raise ValueError(ooslice)
+                n = self.stop - self.step
+                if n.is_Integer or (
+                        n.is_integer and (
+                            (n - self.start).is_nonnegative ==
+                            self.step.is_positive)):
+                    return n
+            _ = self.size  # validate
             rv = (self.stop if i < 0 else self.start) + i*self.step
             if rv.is_infinite:
                 raise ValueError(ooslice)
@@ -751,18 +1006,32 @@ def __getitem__(self, i):
             return rv
 
     @property
+    @inspect_code
     def _inf(self):
         if not self:
             raise NotImplementedError
+        if self.has(Symbol):
+            if self.step.is_positive:
+                return self[0]
+            elif self.step.is_negative:
+                return self[-1]
+            _ = self.size  # validate
         if self.step > 0:
             return self.start
         else:
             return self.stop - self.step
 
     @property
+    @inspect_code
     def _sup(self):
         if not self:
             raise NotImplementedError
+        if self.has(Symbol):
+            if self.step.is_positive:
+                return self[-1]
+            elif self.step.is_negative:
+                return self[0]
+            _ = self.size  # validate
         if self.step > 0:
             return self.stop - self.step
         else:
@@ -775,17 +1044,17 @@ def _boundary(self):
     def as_relational(self, x):
         """Rewrite a Range in terms of equalities and logic operators. """
         from sympy.functions.elementary.integers import floor
-        i = (x - (self.inf if self.inf.is_finite else self.sup))/self.step
         return And(
-            Eq(i, floor(i)),
+            Eq(x, floor(x)),
             x >= self.inf if self.inf in self else x > self.inf,
             x <= self.sup if self.sup in self else x < self.sup)
 
 
 if PY3:
-    converter[range] = Range
+    converter[range] = lambda r: Range(r.start, r.stop, r.step)
 else:
-    converter[xrange] = Range
+    converter[xrange] = lambda r: Range(*r.__reduce__()[1])
+
 
 def normalize_theta_set(theta):
     """
diff --git a/sympy/sets/tests/test_fancysets.py b/sympy/sets/tests/test_fancysets.py
index 1da80f6..f049ce7 100644
--- a/sympy/sets/tests/test_fancysets.py
+++ b/sympy/sets/tests/test_fancysets.py
@@ -189,12 +189,14 @@ def test_Range_set():
     assert Range(-oo, 1, -1) == empty
     assert Range(1, oo, -1) == empty
     assert Range(1, -oo, 1) == empty
-    raises(ValueError, lambda: Range(1, 4, oo))
-    raises(ValueError, lambda: Range(-oo, oo))
-    raises(ValueError, lambda: Range(oo, -oo, -1))
+    assert Range(1, -4, oo) == empty
+    assert Range(1, -4, -oo) == Range(1, 2)
+    assert Range(1, 4, oo) == Range(1, 2)
+    assert Range(-oo, oo).size == oo
+    assert Range(oo, -oo, -1).size == oo
     raises(ValueError, lambda: Range(-oo, oo, 2))
-    raises(ValueError, lambda: Range(0, pi, 1))
-    raises(ValueError, lambda: Range(1, 10, 0))
+    raises(ValueError, lambda: Range(x, pi, y))
+    raises(ValueError, lambda: Range(x, y, 0))
 
     assert 5 in Range(0, oo, 5)
     assert -5 in Range(-oo, 0, 5)
@@ -204,13 +206,11 @@ def test_Range_set():
     u = symbols('u', integer=None)
     assert Range(oo).contains(u) is not False
     inf = symbols('inf', infinite=True)
-    assert inf not in Range(oo)
-    inf = symbols('inf', infinite=True)
-    assert inf not in Range(oo)
-    assert Range(0, oo, 2)[-1] == oo
+    assert inf not in Range(-oo, oo)
+    raises(ValueError, lambda: Range(0, oo, 2)[-1])
+    raises(ValueError, lambda: Range(0, -oo, -2)[-1])
     assert Range(-oo, 1, 1)[-1] is S.Zero
     assert Range(oo, 1, -1)[-1] == 2
-    assert Range(0, -oo, -2)[-1] == -oo
     assert Range(1, 10, 1)[-1] == 9
     assert all(i.is_Integer for i in Range(0, -1, 1))
 
@@ -222,7 +222,6 @@ def test_Range_set():
     assert Range(-1, 10, 1).intersect(S.Naturals) == Range(1, 10, 1)
     assert Range(-1, 10, 1).intersect(S.Naturals0) == Range(0, 10, 1)
 
-
     # test slicing
     assert Range(1, 10, 1)[5] == 6
     assert Range(1, 12, 2)[5] == 11
@@ -262,6 +261,7 @@ def test_Range_set():
     raises(ValueError, lambda: Range(oo, 0, -2)[:1:-1])
 
     # test empty Range
+    assert Range(x, x, y) == empty
     assert empty.reversed == empty
     assert 0 not in empty
     assert list(empty) == []
@@ -305,16 +305,67 @@ def test_Range_set():
     else:
         builtin_range = xrange
 
-    assert Range(builtin_range(10)) == Range(10)
-    assert Range(builtin_range(1, 10)) == Range(1, 10)
-    assert Range(builtin_range(1, 10, 2)) == Range(1, 10, 2)
+    raises(TypeError, lambda: Range(builtin_range(1)))
+    assert S(builtin_range(10)) == Range(10)
     if PY3:
-        assert Range(builtin_range(1000000000000)) == \
+        assert S(builtin_range(1000000000000)) == \
             Range(1000000000000)
 
     # test Range.as_relational
-    assert Range(1, 4).as_relational(x) == (x >= 1) & (x <= 3) & Eq(x - 1, floor(x) - 1)
-    assert Range(oo, 1, -2).as_relational(x) == (x >= 3) & (x < oo) & Eq((3 - x)/2, floor((3 - x)/2))
+    assert Range(1, 4).as_relational(x) == (x >= 1) & (x <= 3) & Eq(x, floor(x))
+    assert Range(oo, 1, -2).as_relational(x) == (x >= 3) & (x < oo) & Eq(x, floor(x))
+
+    # symbolic Range
+    sr = Range(x, y, t)
+    i = Symbol('i', integer=True)
+    ip = Symbol('i', integer=True, positive=True)
+    ir = Range(i, i + 20, 2)
+    # args
+    assert sr.args == (x, y, t)
+    assert ir.args == (i, i + 20, 2)
+    # reversed
+    raises(ValueError, lambda: sr.reversed)
+    assert ir.reversed == Range(i + 18, i - 2, -2)
+    # contains
+    assert inf not in sr
+    assert inf not in ir
+    assert .1 not in sr
+    assert .1 not in ir
+    assert i + 1 not in ir
+    assert i + 2 in ir
+    raises(TypeError, lambda: 1 in sr)  # XXX is this what contains is supposed to do?
+    # iter
+    raises(ValueError, lambda: next(iter(sr)))
+    assert next(iter(ir)) == i
+    assert sr.intersect(S.Integers) == sr
+    assert sr.intersect(FiniteSet(x)) == Intersection({x}, sr)
+    raises(ValueError, lambda: sr[:2])
+    raises(ValueError, lambda: sr[0])
+    raises(ValueError, lambda: sr.as_relational(x))
+    # len
+    assert len(ir) == ir.size == 10
+    raises(ValueError, lambda: len(sr))
+    raises(ValueError, lambda: sr.size)
+    # bool
+    assert bool(ir) == bool(sr) == True
+    # getitem
+    raises(ValueError, lambda: sr[0])
+    raises(ValueError, lambda: sr[-1])
+    raises(ValueError, lambda: sr[:2])
+    assert ir[:2] == Range(i, i + 4, 2)
+    assert ir[0] == i
+    assert ir[-2] == i + 16
+    assert ir[-1] == i + 18
+    raises(ValueError, lambda: Range(i)[-1])
+    assert Range(ip)[-1] == ip - 1
+    assert ir.inf == i
+    assert ir.sup == i + 18
+    assert Range(ip).inf == 0
+    assert Range(ip).sup == ip - 1
+    raises(ValueError, lambda: Range(i).inf)
+    raises(ValueError, lambda: sr.as_relational(x))
+    assert ir.as_relational(x) == (
+        x >= i) & Eq(x, floor(x)) & (x <= i + 18)
 
 
 def test_range_range_intersection():
