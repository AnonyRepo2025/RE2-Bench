diff --git a/sympy/core/numbers.py b/sympy/core/numbers.py
index 08fa959..7b414d8 100644
--- a/sympy/core/numbers.py
+++ b/sympy/core/numbers.py
@@ -1,4 +1,197 @@
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-16056/sympy/core/numbers.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 import decimal
 import fractions
@@ -3140,8 +3333,9 @@ class NaN(with_metaclass(Singleton, Number)):
     def __new__(cls):
         return AtomicExpr.__new__(cls)
 
+    @inspect_code
     def _latex(self, printer):
-        return r"\mathrm{NaN}"
+        return r"\text{NaN}"
 
     @_sympifyit('other', NotImplemented)
     def __add__(self, other):
@@ -3584,8 +3778,9 @@ class TribonacciConstant(with_metaclass(Singleton, NumberSymbol)):
 
     __slots__ = []
 
+    @inspect_code
     def _latex(self, printer):
-        return r"\mathrm{TribonacciConstant}"
+        return r"\text{TribonacciConstant}"
 
     def __int__(self):
         return 2
diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py
index 2d8e9f2..83fb44f 100644
--- a/sympy/core/tests/test_numbers.py
+++ b/sympy/core/tests/test_numbers.py
@@ -1644,12 +1644,12 @@ def test_latex():
     assert latex(pi) == r"\pi"
     assert latex(E) == r"e"
     assert latex(GoldenRatio) == r"\phi"
-    assert latex(TribonacciConstant) == r"\mathrm{TribonacciConstant}"
+    assert latex(TribonacciConstant) == r"\text{TribonacciConstant}"
     assert latex(EulerGamma) == r"\gamma"
     assert latex(oo) == r"\infty"
     assert latex(-oo) == r"-\infty"
     assert latex(zoo) == r"\tilde{\infty}"
-    assert latex(nan) == r"\mathrm{NaN}"
+    assert latex(nan) == r"\text{NaN}"
     assert latex(I) == r"i"
 
 
diff --git a/sympy/diffgeom/diffgeom.py b/sympy/diffgeom/diffgeom.py
index e756196..59f0606 100644
--- a/sympy/diffgeom/diffgeom.py
+++ b/sympy/diffgeom/diffgeom.py
@@ -1,4 +1,197 @@
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-16056/sympy/diffgeom/diffgeom.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 from itertools import permutations
 
@@ -38,8 +231,9 @@ def __new__(cls, name, dim):
         # other Patch instance on the same manifold.
         return obj
 
+    @inspect_code
     def _latex(self, printer, *args):
-        return r'\mathrm{%s}' % self.name
+        return r'\text{%s}' % self.name
 
 
 class Patch(Basic):
@@ -82,8 +276,9 @@ def __new__(cls, name, manifold):
     def dim(self):
         return self.manifold.dim
 
+    @inspect_code
     def _latex(self, printer, *args):
-        return r'\mathrm{%s}_{%s}' % (self.name, self.manifold._latex(printer, *args))
+        return r'\text{%s}_{%s}' % (self.name, self.manifold._latex(printer, *args))
 
 
 class CoordSystem(Basic):
@@ -340,8 +535,9 @@ def point_to_coords(self, point):
     # Printing.
     ##########################################################################
 
+    @inspect_code
     def _latex(self, printer, *args):
-        return r'\mathrm{%s}^{\mathrm{%s}}_{%s}' % (
+        return r'\text{%s}^{\text{%s}}_{%s}' % (
             self.name, self.patch.name, self.patch.manifold._latex(printer, *args))
 
 
diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py
index 0113d85..1857f25 100644
--- a/sympy/printing/latex.py
+++ b/sympy/printing/latex.py
@@ -3,6 +3,199 @@
 """
 
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-16056/sympy/printing/latex.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 import itertools
 
@@ -139,6 +332,7 @@ class LatexPrinter(Printer):
         "root_notation": True,
         "mat_symbol_style": "plain",
         "imaginary_unit": "i",
+        "gothic_re_im": False,
     }
 
     def __init__(self, settings=None):
@@ -197,10 +391,11 @@ def __init__(self, settings=None):
             self._settings['imaginary_unit_latex'] = \
                 self._settings['imaginary_unit']
 
+    @inspect_code
     def parenthesize(self, item, level, strict=False):
         prec_val = precedence_traditional(item)
         if (prec_val < level) or ((not strict) and prec_val <= level):
-            return r"\left(%s\right)" % self._print(item)
+            return r"\left({}\right)".format(self._print(item))
         else:
             return self._print(item)
 
@@ -314,13 +509,13 @@ def _print_Basic(self, expr):
             r"\left(%s\right)" % ", ".join(ls)
 
     def _print_bool(self, e):
-        return r"\mathrm{%s}" % e
+        return r"\text{%s}" % e
 
     _print_BooleanTrue = _print_bool
     _print_BooleanFalse = _print_bool
 
     def _print_NoneType(self, e):
-        return r"\mathrm{%s}" % e
+        return r"\text{%s}" % e
 
     def _print_Add(self, expr, order=None):
         if self.order == 'none':
@@ -898,12 +1093,18 @@ def _print_Abs(self, expr, exp=None):
     _print_Determinant = _print_Abs
 
     def _print_re(self, expr, exp=None):
-        tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
+        if self._settings['gothic_re_im']:
+            tex = r"\Re{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
+        else:
+            tex = r"\operatorname{{re}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
 
         return self._do_exponent(tex, exp)
 
     def _print_im(self, expr, exp=None):
-        tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Func'])
+        if self._settings['gothic_re_im']:
+            tex = r"\Im{%s}" % self.parenthesize(expr.args[0], PRECEDENCE['Atom'])
+        else:
+            tex = r"\operatorname{{im}}{{{}}}".format(self.parenthesize(expr.args[0], PRECEDENCE['Atom']))
 
         return self._do_exponent(tex, exp)
 
@@ -1503,9 +1704,10 @@ def _print_Transpose(self, expr):
         else:
             return "%s^T" % self._print(mat)
 
+    @inspect_code
     def _print_Trace(self, expr):
         mat = expr.arg
-        return r"\mathrm{tr}\left(%s \right)" % self._print(mat)
+        return r"\operatorname{tr}\left(%s \right)" % self._print(mat)
 
     def _print_Adjoint(self, expr):
         mat = expr.arg
@@ -1782,12 +1984,12 @@ def _print_ProductSet(self, p):
 
     def _print_RandomDomain(self, d):
         if hasattr(d, 'as_boolean'):
-            return 'Domain: ' + self._print(d.as_boolean())
+            return '\\text{Domain: }' + self._print(d.as_boolean())
         elif hasattr(d, 'set'):
-            return ('Domain: ' + self._print(d.symbols) + ' in ' +
+            return ('\\text{Domain: }' + self._print(d.symbols) + '\\text{ in }' +
                     self._print(d.set))
         elif hasattr(d, 'symbols'):
-            return 'Domain on ' + self._print(d.symbols)
+            return '\\text{Domain on }' + self._print(d.symbols)
         else:
             return self._print(None)
 
@@ -2073,55 +2275,38 @@ def _print_catalan(self, expr, exp=None):
             tex = r"%s^{%s}" % (tex, self._print(exp))
         return tex
 
+    def _print_UnifiedTransform(self, expr, s, inverse=False):
+        return r"\mathcal{{{}}}{}_{{{}}}\left[{}\right]\left({}\right)".format(s, '^{-1}' if inverse else '', self._print(expr.args[1]), self._print(expr.args[0]), self._print(expr.args[2]))
+
     def _print_MellinTransform(self, expr):
-        return r"\mathcal{M}_{%s}\left[%s\right]\left(%s\right)" % \
-            (self._print(expr.args[1]), self._print(expr.args[0]),
-             self._print(expr.args[2]))
+        return self._print_UnifiedTransform(expr, 'M')
 
     def _print_InverseMellinTransform(self, expr):
-        return r"\mathcal{M}^{-1}_{%s}\left[%s\right]\left(%s\right)" % \
-            (self._print(expr.args[1]), self._print(expr.args[0]),
-             self._print(expr.args[2]))
+        return self._print_UnifiedTransform(expr, 'M', True)
 
     def _print_LaplaceTransform(self, expr):
-        return r"\mathcal{L}_{%s}\left[%s\right]\left(%s\right)" % \
-            (self._print(expr.args[1]), self._print(expr.args[0]),
-             self._print(expr.args[2]))
+        return self._print_UnifiedTransform(expr, 'L')
 
     def _print_InverseLaplaceTransform(self, expr):
-        return r"\mathcal{L}^{-1}_{%s}\left[%s\right]\left(%s\right)" % \
-            (self._print(expr.args[1]), self._print(expr.args[0]),
-             self._print(expr.args[2]))
+        return self._print_UnifiedTransform(expr, 'L', True)
 
     def _print_FourierTransform(self, expr):
-        return r"\mathcal{F}_{%s}\left[%s\right]\left(%s\right)" % \
-            (self._print(expr.args[1]), self._print(expr.args[0]),
-             self._print(expr.args[2]))
+        return self._print_UnifiedTransform(expr, 'F')
 
     def _print_InverseFourierTransform(self, expr):
-        return r"\mathcal{F}^{-1}_{%s}\left[%s\right]\left(%s\right)" % \
-            (self._print(expr.args[1]), self._print(expr.args[0]),
-             self._print(expr.args[2]))
+        return self._print_UnifiedTransform(expr, 'F', True)
 
     def _print_SineTransform(self, expr):
-        return r"\mathcal{SIN}_{%s}\left[%s\right]\left(%s\right)" % \
-            (self._print(expr.args[1]), self._print(expr.args[0]),
-             self._print(expr.args[2]))
+        return self._print_UnifiedTransform(expr, 'SIN')
 
     def _print_InverseSineTransform(self, expr):
-        return r"\mathcal{SIN}^{-1}_{%s}\left[%s\right]\left(%s\right)" % \
-            (self._print(expr.args[1]), self._print(expr.args[0]),
-             self._print(expr.args[2]))
+        return self._print_UnifiedTransform(expr, 'SIN', True)
 
     def _print_CosineTransform(self, expr):
-        return r"\mathcal{COS}_{%s}\left[%s\right]\left(%s\right)" % \
-            (self._print(expr.args[1]), self._print(expr.args[0]),
-             self._print(expr.args[2]))
+        return self._print_UnifiedTransform(expr, 'COS')
 
     def _print_InverseCosineTransform(self, expr):
-        return r"\mathcal{COS}^{-1}_{%s}\left[%s\right]\left(%s\right)" % \
-            (self._print(expr.args[1]), self._print(expr.args[0]),
-             self._print(expr.args[2]))
+        return self._print_UnifiedTransform(expr, 'COS', True)
 
     def _print_DMP(self, p):
         try:
@@ -2164,8 +2349,9 @@ def _print_CompositeMorphism(self, morphism):
         pretty_morphism = self._print_Morphism(morphism)
         return component_names + pretty_morphism
 
+    @inspect_code
     def _print_Category(self, morphism):
-        return "\\mathbf{%s}" % self._print(Symbol(morphism.name))
+        return r"\mathbf{{{}}}".format(self._print(Symbol(morphism.name)))
 
     def _print_Diagram(self, diagram):
         if not diagram.premises:
@@ -2198,20 +2384,20 @@ def _print_DiagramGrid(self, grid):
         return latex_result
 
     def _print_FreeModule(self, M):
-        return '{%s}^{%s}' % (self._print(M.ring), self._print(M.rank))
+        return '{{{}}}^{{{}}}'.format(self._print(M.ring), self._print(M.rank))
 
     def _print_FreeModuleElement(self, m):
         # Print as row vector for convenience, for now.
-        return r"\left[ %s \right]" % ",".join(
-            '{' + self._print(x) + '}' for x in m)
+        return r"\left[ {} \right]".format(",".join(
+            '{' + self._print(x) + '}' for x in m))
 
     def _print_SubModule(self, m):
-        return r"\left\langle %s \right\rangle" % ",".join(
-            '{' + self._print(x) + '}' for x in m.gens)
+        return r"\left\langle {} \right\rangle".format(",".join(
+            '{' + self._print(x) + '}' for x in m.gens))
 
     def _print_ModuleImplementedIdeal(self, m):
-        return r"\left\langle %s \right\rangle" % ",".join(
-            '{' + self._print(x) + '}' for [x] in m._module.gens)
+        return r"\left\langle {} \right\rangle".format(",".join(
+            '{' + self._print(x) + '}' for [x] in m._module.gens))
 
     def _print_Quaternion(self, expr):
         # TODO: This expression is potentially confusing,
@@ -2223,49 +2409,47 @@ def _print_Quaternion(self, expr):
 
     def _print_QuotientRing(self, R):
         # TODO nicer fractions for few generators...
-        return r"\frac{%s}{%s}" % (self._print(R.ring),
-                                   self._print(R.base_ideal))
+        return r"\frac{{{}}}{{{}}}".format(self._print(R.ring),
+                 self._print(R.base_ideal))
 
     def _print_QuotientRingElement(self, x):
-        return r"{%s} + {%s}" % (self._print(x.data),
-                                 self._print(x.ring.base_ideal))
+        return r"{{{}}} + {{{}}}".format(self._print(x.data),
+                 self._print(x.ring.base_ideal))
 
     def _print_QuotientModuleElement(self, m):
-        return r"{%s} + {%s}" % (self._print(m.data),
-                                 self._print(m.module.killed_module))
+        return r"{{{}}} + {{{}}}".format(self._print(m.data),
+                 self._print(m.module.killed_module))
 
     def _print_QuotientModule(self, M):
         # TODO nicer fractions for few generators...
-        return r"\frac{%s}{%s}" % (self._print(M.base),
-                                   self._print(M.killed_module))
+        return r"\frac{{{}}}{{{}}}".format(self._print(M.base),
+                 self._print(M.killed_module))
 
     def _print_MatrixHomomorphism(self, h):
-        return r"{%s} : {%s} \to {%s}" % (self._print(h._sympy_matrix()),
-                                          self._print(h.domain),
-                                          self._print(h.codomain))
+        return r"{{{}}} : {{{}}} \to {{{}}}".format(self._print(h._sympy_matrix()),
+            self._print(h.domain), self._print(h.codomain))
 
     def _print_BaseScalarField(self, field):
         string = field._coord_sys._names[field._index]
-        return r'\boldsymbol{\mathrm{%s}}' % self._print(Symbol(string))
+        return r'\mathbf{{{}}}'.format(self._print(Symbol(string)))
 
     def _print_BaseVectorField(self, field):
         string = field._coord_sys._names[field._index]
-        return r'\partial_{%s}' % self._print(Symbol(string))
+        return r'\partial_{{{}}}'.format(self._print(Symbol(string)))
 
     def _print_Differential(self, diff):
         field = diff._form_field
         if hasattr(field, '_coord_sys'):
             string = field._coord_sys._names[field._index]
-            return r'\mathrm{d}%s' % self._print(Symbol(string))
+            return r'\operatorname{{d}}{}'.format(self._print(Symbol(string)))
         else:
-            return 'd(%s)' % self._print(field)
             string = self._print(field)
-            return r'\mathrm{d}\left(%s\right)' % string
+            return r'\operatorname{{d}}\left({}\right)'.format(string)
 
     def _print_Tr(self, p):
         # TODO: Handle indices
         contents = self._print(p.args[0])
-        return r'\mbox{Tr}\left(%s\right)' % (contents)
+        return r'\operatorname{{tr}}\left({}\right)'.format(contents)
 
     def _print_totient(self, expr, exp=None):
         if exp is not None:
@@ -2342,12 +2526,13 @@ def translate(s):
         return s
 
 
+@inspect_code
 def latex(expr, fold_frac_powers=False, fold_func_brackets=False,
           fold_short_frac=None, inv_trig_style="abbreviated",
           itex=False, ln_notation=False, long_frac_ratio=None,
           mat_delim="[", mat_str=None, mode="plain", mul_symbol=None,
           order=None, symbol_names=None, root_notation=True,
-          mat_symbol_style="plain", imaginary_unit="i"):
+          mat_symbol_style="plain", imaginary_unit="i", gothic_re_im=False):
     r"""Convert the given expression to LaTeX string representation.
 
     Parameters
@@ -2408,8 +2593,11 @@ def latex(expr, fold_frac_powers=False, fold_func_brackets=False,
         a MatrixSymbol A will be printed as ``\mathbf{A}``, otherwise as ``A``.
     imaginary_unit : string, optional
         String to use for the imaginary unit. Defined options are "i" (default)
-        and "j". Adding "b" or "t" in front gives ``\mathrm`` or ``\text``, so
-        "bi" leads to ``\mathrm{i}`` which gives `\mathrm{i}`.
+        and "j". Adding "r" or "t" in front gives ``\mathrm`` or ``\text``, so
+        "ri" leads to ``\mathrm{i}`` which gives `\mathrm{i}`.
+    gothic_re_im : boolean, optional
+        If set to ``True``, `\Re` and `\Im` is used for ``re`` and ``im``, respectively.
+        The default is ``False`` leading to `\operatorname{re}` and `\operatorname{im}`.
 
     Notes
     =====
@@ -2537,6 +2725,7 @@ def latex(expr, fold_frac_powers=False, fold_func_brackets=False,
         'root_notation': root_notation,
         'mat_symbol_style': mat_symbol_style,
         'imaginary_unit': imaginary_unit,
+        'gothic_re_im': gothic_re_im,
     }
 
     return LatexPrinter(settings).doprint(expr)
diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py
index f645863..c24c170 100644
--- a/sympy/printing/tests/test_latex.py
+++ b/sympy/printing/tests/test_latex.py
@@ -34,7 +34,7 @@
 from sympy.logic import Implies
 from sympy.logic.boolalg import And, Or, Xor
 from sympy.physics.quantum import Commutator, Operator
-from sympy.physics.units import degree, radian, kg, meter, R
+from sympy.physics.units import degree, radian, kg, meter
 from sympy.core.trace import Tr
 from sympy.core.compatibility import range
 from sympy.combinatorics.permutations import Cycle, Permutation
@@ -154,11 +154,11 @@ def test_latex_basic():
 
 
 def test_latex_builtins():
-    assert latex(True) == r"\mathrm{True}"
-    assert latex(False) == r"\mathrm{False}"
-    assert latex(None) == r"\mathrm{None}"
-    assert latex(true) == r"\mathrm{True}"
-    assert latex(false) == r'\mathrm{False}'
+    assert latex(True) == r"\text{True}"
+    assert latex(False) == r"\text{False}"
+    assert latex(None) == r"\text{None}"
+    assert latex(true) == r"\text{True}"
+    assert latex(false) == r'\text{False}'
 
 
 def test_latex_SingularityFunction():
@@ -373,9 +373,10 @@ def test_latex_functions():
     assert latex(Max(x, y)**2) == r"\max\left(x, y\right)^{2}"
     assert latex(Abs(x)) == r"\left|{x}\right|"
     assert latex(Abs(x)**2) == r"\left|{x}\right|^{2}"
-    assert latex(re(x)) == r"\Re{\left(x\right)}"
-    assert latex(re(x + y)) == r"\Re{\left(x\right)} + \Re{\left(y\right)}"
-    assert latex(im(x)) == r"\Im{x}"
+    assert latex(re(x)) == r"\operatorname{re}{\left(x\right)}"
+    assert latex(re(x + y)) == \
+        r"\operatorname{re}{\left(x\right)} + \operatorname{re}{\left(y\right)}"
+    assert latex(im(x)) == r"\operatorname{im}{\left(x\right)}"
     assert latex(conjugate(x)) == r"\overline{x}"
     assert latex(conjugate(x)**2) == r"\overline{x}^{2}"
     assert latex(conjugate(x**2)) == r"\overline{x}^{2}"
@@ -392,7 +393,8 @@ def test_latex_functions():
         r"O\left(x; \left( x, \  y\right)\rightarrow \left( 0, \  0\right)\right)"
     assert latex(Order(x, x, y)) == \
         r"O\left(x; \left( x, \  y\right)\rightarrow \left( 0, \  0\right)\right)"
-    assert latex(Order(x, (x, oo), (y, oo))) == r"O\left(x; \left( x, \  y\right)\rightarrow \left( \infty, \  \infty\right)\right)"
+    assert latex(Order(x, (x, oo), (y, oo))) == \
+        r"O\left(x; \left( x, \  y\right)\rightarrow \left( \infty, \  \infty\right)\right)"
     assert latex(lowergamma(x, y)) == r'\gamma\left(x, y\right)'
     assert latex(lowergamma(x, y)**2) == r'\gamma^{2}\left(x, y\right)'
     assert latex(uppergamma(x, y)) == r'\Gamma\left(x, y\right)'
@@ -400,8 +402,8 @@ def test_latex_functions():
 
     assert latex(cot(x)) == r'\cot{\left(x \right)}'
     assert latex(coth(x)) == r'\coth{\left(x \right)}'
-    assert latex(re(x)) == r'\Re{\left(x\right)}'
-    assert latex(im(x)) == r'\Im{x}'
+    assert latex(re(x)) == r'\operatorname{re}{\left(x\right)}'
+    assert latex(im(x)) == r'\operatorname{im}{\left(x\right)}'
     assert latex(root(x, y)) == r'x^{\frac{1}{y}}'
     assert latex(arg(x)) == r'\arg{\left(x \right)}'
     assert latex(zeta(x)) == r'\zeta\left(x\right)'
@@ -536,7 +538,8 @@ def test_hyper_printing():
 
     assert latex(meijerg(Tuple(pi, pi, x), Tuple(1),
                          (0, 1), Tuple(1, 2, 3/pi), z)) == \
-        r'{G_{4, 5}^{2, 3}\left(\begin{matrix} \pi, \pi, x & 1 \\0, 1 & 1, 2, \frac{3}{\pi} \end{matrix} \middle| {z} \right)}'
+        r'{G_{4, 5}^{2, 3}\left(\begin{matrix} \pi, \pi, x & 1 \\0, 1 & 1, 2, '\
+        r'\frac{3}{\pi} \end{matrix} \middle| {z} \right)}'
     assert latex(meijerg(Tuple(), Tuple(1), (0,), Tuple(), z)) == \
         r'{G_{1, 1}^{1, 0}\left(\begin{matrix}  & 1 \\0 &  \end{matrix} \middle| {z} \right)}'
     assert latex(hyper((x, 2), (3,), z)) == \
@@ -881,7 +884,8 @@ def test_latex_ComplexRegion():
     assert latex(ComplexRegion(Interval(3, 5)*Interval(4, 6))) == \
         r"\left\{x + y i\; |\; x, y \in \left[3, 5\right] \times \left[4, 6\right] \right\}"
     assert latex(ComplexRegion(Interval(0, 1)*Interval(0, 2*pi), polar=True)) == \
-        r"\left\{r \left(i \sin{\left(\theta \right)} + \cos{\left(\theta \right)}\right)\; |\; r, \theta \in \left[0, 1\right] \times \left[0, 2 \pi\right) \right\}"
+        r"\left\{r \left(i \sin{\left(\theta \right)} + \cos{\left(\theta "\
+        r"\right)}\right)\; |\; r, \theta \in \left[0, 1\right] \times \left[0, 2 \pi\right) \right\}"
 
 
 def test_latex_Contains():
@@ -1279,12 +1283,15 @@ def test_latex_Poly():
 
 def test_latex_Poly_order():
     assert latex(Poly([a, 1, b, 2, c, 3], x)) == \
-        '\\operatorname{Poly}{\\left( a x^{5} + x^{4} + b x^{3} + 2 x^{2} + c x + 3, x, domain=\\mathbb{Z}\\left[a, b, c\\right] \\right)}'
+        '\\operatorname{Poly}{\\left( a x^{5} + x^{4} + b x^{3} + 2 x^{2} + c'\
+        ' x + 3, x, domain=\\mathbb{Z}\\left[a, b, c\\right] \\right)}'
     assert latex(Poly([a, 1, b+c, 2, 3], x)) == \
-        '\\operatorname{Poly}{\\left( a x^{4} + x^{3} + \\left(b + c\\right) x^{2} + 2 x + 3, x, domain=\\mathbb{Z}\\left[a, b, c\\right] \\right)}'
+        '\\operatorname{Poly}{\\left( a x^{4} + x^{3} + \\left(b + c\\right) '\
+        'x^{2} + 2 x + 3, x, domain=\\mathbb{Z}\\left[a, b, c\\right] \\right)}'
     assert latex(Poly(a*x**3 + x**2*y - x*y - c*y**3 - b*x*y**2 + y - a*x + b,
                       (x, y))) == \
-        '\\operatorname{Poly}{\\left( a x^{3} + x^{2}y -  b xy^{2} - xy -  a x -  c y^{3} + y + b, x, y, domain=\\mathbb{Z}\\left[a, b, c\\right] \\right)}'
+        '\\operatorname{Poly}{\\left( a x^{3} + x^{2}y -  b xy^{2} - xy -  '\
+        'a x -  c y^{3} + y + b, x, y, domain=\\mathbb{Z}\\left[a, b, c\\right] \\right)}'
 
 
 def test_latex_ComplexRootOf():
@@ -1367,18 +1374,22 @@ def test_latex_MatrixSlice():
 
 def test_latex_RandomDomain():
     from sympy.stats import Normal, Die, Exponential, pspace, where
+    from sympy.stats.rv import RandomDomain
+
     X = Normal('x1', 0, 1)
-    assert latex(where(X > 0)) == r"Domain: 0 < x_{1} \wedge x_{1} < \infty"
+    assert latex(where(X > 0)) == r"\text{Domain: }0 < x_{1} \wedge x_{1} < \infty"
 
     D = Die('d1', 6)
-    assert latex(where(D > 4)) == r"Domain: d_{1} = 5 \vee d_{1} = 6"
+    assert latex(where(D > 4)) == r"\text{Domain: }d_{1} = 5 \vee d_{1} = 6"
 
     A = Exponential('a', 1)
     B = Exponential('b', 1)
     assert latex(
         pspace(Tuple(A, B)).domain) == \
-        r"Domain: 0 \leq a \wedge 0 \leq b \wedge a < \infty \wedge b < \infty"
+        r"\text{Domain: }0 \leq a \wedge 0 \leq b \wedge a < \infty \wedge b < \infty"
 
+    assert latex(RandomDomain(FiniteSet(x), FiniteSet(1, 2))) == \
+        r'\text{Domain: }\left\{x\right\}\text{ in }\left\{1, 2\right\}'
 
 def test_PrettyPoly():
     from sympy.polys.domains import QQ
@@ -1504,15 +1515,20 @@ def test_Modules():
 
     Q = F / M
     assert latex(Q) == \
-        r"\frac{{\mathbb{Q}\left[x, y\right]}^{2}}{\left\langle {\left[ {x},{y} \right]},{\left[ {1},{x^{2}} \right]} \right\rangle}"
+        r"\frac{{\mathbb{Q}\left[x, y\right]}^{2}}{\left\langle {\left[ {x},"\
+        r"{y} \right]},{\left[ {1},{x^{2}} \right]} \right\rangle}"
     assert latex(Q.submodule([1, x**3/2], [2, y])) == \
-        r"\left\langle {{\left[ {1},{\frac{x^{3}}{2}} \right]} + {\left\langle {\left[ {x},{y} \right]},{\left[ {1},{x^{2}} \right]} \right\rangle}},{{\left[ {2},{y} \right]} + {\left\langle {\left[ {x},{y} \right]},{\left[ {1},{x^{2}} \right]} \right\rangle}} \right\rangle"
+        r"\left\langle {{\left[ {1},{\frac{x^{3}}{2}} \right]} + {\left"\
+        r"\langle {\left[ {x},{y} \right]},{\left[ {1},{x^{2}} \right]} "\
+        r"\right\rangle}},{{\left[ {2},{y} \right]} + {\left\langle {\left[ "\
+        r"{x},{y} \right]},{\left[ {1},{x^{2}} \right]} \right\rangle}} \right\rangle"
 
     h = homomorphism(QQ.old_poly_ring(x).free_module(2),
                      QQ.old_poly_ring(x).free_module(2), [0, 0])
 
     assert latex(h) == \
-        r"{\left[\begin{matrix}0 & 0\\0 & 0\end{matrix}\right]} : {{\mathbb{Q}\left[x\right]}^{2}} \to {{\mathbb{Q}\left[x\right]}^{2}}"
+        r"{\left[\begin{matrix}0 & 0\\0 & 0\end{matrix}\right]} : "\
+        r"{{\mathbb{Q}\left[x\right]}^{2}} \to {{\mathbb{Q}\left[x\right]}^{2}}"
 
 
 def test_QuotientRing():
@@ -1528,7 +1544,7 @@ def test_Tr():
     #TODO: Handle indices
     A, B = symbols('A B', commutative=False)
     t = Tr(A*B)
-    assert latex(t) == r'\mbox{Tr}\left(A B\right)'
+    assert latex(t) == r'\operatorname{tr}\left(A B\right)'
 
 
 def test_Adjoint():
@@ -1931,7 +1947,7 @@ def test_WedgeProduct_printing():
     from sympy.diffgeom.rn import R2
     from sympy.diffgeom import WedgeProduct
     wp = WedgeProduct(R2.dx, R2.dy)
-    assert latex(wp) == r"\mathrm{d}x \wedge \mathrm{d}y"
+    assert latex(wp) == r"\operatorname{d}x \wedge \operatorname{d}y"
 
 
 def test_issue_14041():
@@ -2045,15 +2061,17 @@ def test_issue_15353():
     # Obtained from nonlinsolve([(sin(a*x)),cos(a*x)],[x,a])
     sol = ConditionSet(Tuple(x, a), FiniteSet(sin(a*x), cos(a*x)), S.Complexes)
     assert latex(sol) == \
-        r'\left\{\left( x, \  a\right) \mid \left( x, \  a\right) \in \mathbb{C} \wedge \left\{\sin{\left(a x \right)}, \cos{\left(a x \right)}\right\} \right\}'
+        r'\left\{\left( x, \  a\right) \mid \left( x, \  a\right) \in '\
+        r'\mathbb{C} \wedge \left\{\sin{\left(a x \right)}, \cos{\left(a x '\
+        r'\right)}\right\} \right\}'
 
 
 def test_trace():
     # Issue 15303
     from sympy import trace
     A = MatrixSymbol("A", 2, 2)
-    assert latex(trace(A)) == r"\mathrm{tr}\left(A \right)"
-    assert latex(trace(A**2)) == r"\mathrm{tr}\left(A^{2} \right)"
+    assert latex(trace(A)) == r"\operatorname{tr}\left(A \right)"
+    assert latex(trace(A**2)) == r"\operatorname{tr}\left(A^{2} \right)"
 
 
 def test_print_basic():
@@ -2088,9 +2106,9 @@ def test_MatrixSymbol_bold():
     from sympy import trace
     A = MatrixSymbol("A", 2, 2)
     assert latex(trace(A), mat_symbol_style='bold') == \
-        r"\mathrm{tr}\left(\mathbf{A} \right)"
+        r"\operatorname{tr}\left(\mathbf{A} \right)"
     assert latex(trace(A), mat_symbol_style='plain') == \
-        r"\mathrm{tr}\left(A \right)"
+        r"\operatorname{tr}\left(A \right)"
 
     A = MatrixSymbol("A", 3, 3)
     B = MatrixSymbol("B", 3, 3)
@@ -2113,3 +2131,28 @@ def test_imaginary_unit():
     assert latex(1 + I, imaginary_unit='foo') == '1 + foo'
     assert latex(I, imaginary_unit="ti") == '\\text{i}'
     assert latex(I, imaginary_unit="tj") == '\\text{j}'
+
+
+def test_text_re_im():
+    assert latex(im(x), gothic_re_im=True) ==  r'\Im{\left(x\right)}'
+    assert latex(im(x), gothic_re_im=False) ==  r'\operatorname{im}{\left(x\right)}'
+    assert latex(re(x), gothic_re_im=True) ==  r'\Re{\left(x\right)}'
+    assert latex(re(x), gothic_re_im=False) ==  r'\operatorname{re}{\left(x\right)}'
+
+
+def test_DiffGeomMethods():
+    from sympy.diffgeom import Manifold, Patch, CoordSystem, BaseScalarField, Differential
+    from sympy.diffgeom.rn import R2
+    m = Manifold('M', 2)
+    assert latex(m) == r'\text{M}'
+    p = Patch('P', m)
+    assert latex(p) == r'\text{P}_{\text{M}}'
+    rect = CoordSystem('rect', p)
+    assert latex(rect) == r'\text{rect}^{\text{P}}_{\text{M}}'
+    b = BaseScalarField(rect, 0)
+    assert latex(b) ==  r'\mathbf{rect_{0}}'
+
+    g = Function('g')
+    s_field = g(R2.x, R2.y)
+    assert latex(Differential(s_field)) == \
+        r'\operatorname{d}\left(g{\left(\mathbf{x},\mathbf{y} \right)}\right)'
