diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index 39ec6ea..626d095 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -1191,9 +1191,15 @@ class SQLInsertCompiler(SQLCompiler):
                     'can only be used to update, not to insert.' % (value, field)
                 )
             if value.contains_aggregate:
-                raise FieldError("Aggregate functions are not allowed in this query")
+                raise FieldError(
+                    'Aggregate functions are not allowed in this query '
+                    '(%s=%r).' % (field.name, value)
+                )
             if value.contains_over_clause:
-                raise FieldError('Window expressions are not allowed in this query.')
+                raise FieldError(
+                    'Window expressions are not allowed in this query (%s=%r).'
+                    % (field.name, value)
+                )
         else:
             value = field.get_db_prep_save(value, connection=self.connection)
         return value
@@ -1356,9 +1362,15 @@ class SQLUpdateCompiler(SQLCompiler):
             if hasattr(val, 'resolve_expression'):
                 val = val.resolve_expression(self.query, allow_joins=False, for_save=True)
                 if val.contains_aggregate:
-                    raise FieldError("Aggregate functions are not allowed in this query")
+                    raise FieldError(
+                        'Aggregate functions are not allowed in this query '
+                        '(%s=%r).' % (field.name, val)
+                    )
                 if val.contains_over_clause:
-                    raise FieldError('Window expressions are not allowed in this query.')
+                    raise FieldError(
+                        'Window expressions are not allowed in this query '
+                        '(%s=%r).' % (field.name, val)
+                    )
             elif hasattr(val, 'prepare_database_save'):
                 if field.remote_field:
                     val = field.get_db_prep_save(
diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py
index e66dcd6..cc03e83 100644
--- a/tests/expressions/tests.py
+++ b/tests/expressions/tests.py
@@ -264,7 +264,8 @@ class BasicExpressionsTests(TestCase):
 
     def test_object_create_with_aggregate(self):
         # Aggregates are not allowed when inserting new data
-        with self.assertRaisesMessage(FieldError, 'Aggregate functions are not allowed in this query'):
+        msg = 'Aggregate functions are not allowed in this query (num_employees=Max(Value(1))).'
+        with self.assertRaisesMessage(FieldError, msg):
             Company.objects.create(
                 name='Company', num_employees=Max(Value(1)), num_chairs=1,
                 ceo=Employee.objects.create(firstname="Just", lastname="Doit", salary=30),
diff --git a/tests/expressions_window/tests.py b/tests/expressions_window/tests.py
index d9a4a4f..129912b 100644
--- a/tests/expressions_window/tests.py
+++ b/tests/expressions_window/tests.py
@@ -670,7 +670,12 @@ class WindowFunctionTests(TestCase):
 
     def test_fail_update(self):
         """Window expressions can't be used in an UPDATE statement."""
-        msg = 'Window expressions are not allowed in this query'
+        msg = (
+            'Window expressions are not allowed in this query (salary=<Window: '
+            'Max(Col(expressions_window_employee, expressions_window.Employee.salary)) '
+            'OVER (PARTITION BY Col(expressions_window_employee, '
+            'expressions_window.Employee.department))>).'
+        )
         with self.assertRaisesMessage(FieldError, msg):
             Employee.objects.filter(department='Management').update(
                 salary=Window(expression=Max('salary'), partition_by='department'),
@@ -678,7 +683,10 @@ class WindowFunctionTests(TestCase):
 
     def test_fail_insert(self):
         """Window expressions can't be used in an INSERT statement."""
-        msg = 'Window expressions are not allowed in this query'
+        msg = (
+            'Window expressions are not allowed in this query (salary=<Window: '
+            'Sum(Value(10000), order_by=OrderBy(F(pk), descending=False)) OVER ()'
+        )
         with self.assertRaisesMessage(FieldError, msg):
             Employee.objects.create(
                 name='Jameson', department='Management', hire_date=datetime.date(2007, 7, 1),
diff --git a/tests/update/tests.py b/tests/update/tests.py
index 63e930b..8cb4d11 100644
--- a/tests/update/tests.py
+++ b/tests/update/tests.py
@@ -165,7 +165,11 @@ class AdvancedTests(TestCase):
         self.assertEqual(qs.update(another_value=F('alias')), 3)
         # Update where aggregation annotation is used in update parameters
         qs = DataPoint.objects.annotate(max=Max('value'))
-        with self.assertRaisesMessage(FieldError, 'Aggregate functions are not allowed in this query'):
+        msg = (
+            'Aggregate functions are not allowed in this query '
+            '(another_value=Max(Col(update_datapoint, update.DataPoint.value))).'
+        )
+        with self.assertRaisesMessage(FieldError, msg):
             qs.update(another_value=F('max'))
 
     def test_update_annotated_multi_table_queryset(self):
@@ -185,5 +189,9 @@ class AdvancedTests(TestCase):
         # self.assertEqual(updated, 1)
         # Update where aggregation annotation is used in update parameters
         qs = RelatedPoint.objects.annotate(max=Max('data__value'))
-        with self.assertRaisesMessage(FieldError, 'Aggregate functions are not allowed in this query'):
+        msg = (
+            'Aggregate functions are not allowed in this query '
+            '(name=Max(Col(update_datapoint, update.DataPoint.value))).'
+        )
+        with self.assertRaisesMessage(FieldError, msg):
             qs.update(name=F('max'))
