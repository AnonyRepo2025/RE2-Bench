diff --git a/sympy/core/expr.py b/sympy/core/expr.py
index 5532506..3196c1b 100644
--- a/sympy/core/expr.py
+++ b/sympy/core/expr.py
@@ -1,4 +1,197 @@
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-11232/sympy/core/expr.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 from .sympify import sympify, _sympify, SympifyError
 from .basic import Basic, Atom
@@ -1032,6 +1225,7 @@ def count_ops(self, visual=None):
         from .function import count_ops
         return count_ops(self, visual)
 
+    @inspect_code
     def args_cnc(self, cset=False, warn=True, split_1=True):
         """Return [commutative factors, non-commutative factors] of self.
 
@@ -1044,7 +1238,7 @@ def args_cnc(self, cset=False, warn=True, split_1=True):
         Note: -1 is always separated from a Number unless split_1 is False.
 
         >>> from sympy import symbols, oo
-        >>> A, B = symbols('A B', commutative=0)
+        >>> A, B = symbols('A B', commutative=False)
         >>> x, y = symbols('x y')
         >>> (-2*x*y).args_cnc()
         [[-1, 2, x, y], []]
diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py
index f2133a3..7123b78 100644
--- a/sympy/core/tests/test_subs.py
+++ b/sympy/core/tests/test_subs.py
@@ -595,9 +595,9 @@ def test_issue_6559():
     # though this involves cse it generated a failure in Mul._eval_subs
     x0, x1 = symbols('x0 x1')
     e = -log(-12*sqrt(2) + 17)/24 - log(-2*sqrt(2) + 3)/12 + sqrt(2)/3
-    # XXX modify cse so x1 is eliminated and x0 = -sqrt(2)?
     assert cse(e) == (
-        [(x0, sqrt(2))], [x0/3 - log(-12*x0 + 17)/24 - log(-2*x0 + 3)/12])
+        [(x0, sqrt(2))],
+        [x0/3 - log(-12*x0 + 17)/24 - log(-2*x0 + 3)/12])
 
 
 def test_issue_5261():
diff --git a/sympy/matrices/expressions/matmul.py b/sympy/matrices/expressions/matmul.py
index cf06ef7..d2e4ec8 100644
--- a/sympy/matrices/expressions/matmul.py
+++ b/sympy/matrices/expressions/matmul.py
@@ -1,4 +1,197 @@
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-11232/sympy/matrices/expressions/matmul.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 from sympy import Number
 from sympy.core import Mul, Basic, sympify, Add
@@ -118,11 +311,14 @@ def doit(self, **kwargs):
         return canonicalize(MatMul(*args))
 
     # Needed for partial compatibility with Mul
+    @inspect_code
     def args_cnc(self, **kwargs):
         coeff, matrices = self.as_coeff_matrices()
-        # I don't know how coeff could have noncommutative factors, but this
-        # handles it.
         coeff_c, coeff_nc = coeff.args_cnc(**kwargs)
+        if coeff_c == [1]:
+            coeff_c = []
+        elif coeff_c == set([1]):
+            coeff_c = set()
 
         return coeff_c, coeff_nc + matrices
 
diff --git a/sympy/matrices/expressions/tests/test_matmul.py b/sympy/matrices/expressions/tests/test_matmul.py
index cb41493..b3f9d5c 100644
--- a/sympy/matrices/expressions/tests/test_matmul.py
+++ b/sympy/matrices/expressions/tests/test_matmul.py
@@ -130,4 +130,4 @@ def test_matmul_no_matrices():
 def test_matmul_args_cnc():
     a, b = symbols('a b', commutative=False)
     assert MatMul(n, a, b, A, A.T).args_cnc() == ([n], [a, b, A, A.T])
-    assert MatMul(A, A.T).args_cnc() == ([1], [A, A.T])
+    assert MatMul(A, A.T).args_cnc() == ([], [A, A.T])
diff --git a/sympy/printing/llvmjitcode.py b/sympy/printing/llvmjitcode.py
index 51e0e65..db1f658 100644
--- a/sympy/printing/llvmjitcode.py
+++ b/sympy/printing/llvmjitcode.py
@@ -428,9 +428,9 @@ def llvm_callable(args, expr, callback_type=None):
     >>> from sympy.abc import x,y
     >>> e1 = x*x + y*y
     >>> e2 = 4*(x*x + y*y) + 8.0
-    >>> after_cse = cse([e1,e2])
+    >>> after_cse = cse([e1, e2])
     >>> after_cse
-    ([(x0, x**2), (x1, y**2)], [x0 + x1, 4*x0 + 4*x1 + 8.0])
+    ([(x0, x**2 + y**2)], [x0, 4*x0 + 8.0])
     >>> j1 = jit.llvm_callable([x,y], after_cse)
     >>> j1(1.0, 2.0)
     (5.0, 28.0)
diff --git a/sympy/simplify/cse_main.py b/sympy/simplify/cse_main.py
index e49ba26..d2ba479 100644
--- a/sympy/simplify/cse_main.py
+++ b/sympy/simplify/cse_main.py
@@ -1,14 +1,208 @@
 """ Tools for doing common subexpression elimination.
 """
 from __future__ import print_function, division
-
-from sympy.core import Basic, Mul, Add, Pow, sympify, Symbol, Tuple
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-11232/sympy/simplify/cse_main.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
+
+from sympy.core import Basic, Mul, Add, Pow, sympify, Symbol, Tuple, igcd
+from sympy.core.numbers import Integer
 from sympy.core.singleton import S
 from sympy.core.function import _coeff_isneg
 from sympy.core.exprtools import factor_terms
-from sympy.core.compatibility import iterable, range
+from sympy.core.compatibility import iterable, range, as_int
 from sympy.utilities.iterables import filter_symbols, \
-    numbered_symbols, sift, topological_sort, ordered
+    numbered_symbols, sift, topological_sort, ordered, subsets
 
 from . import cse_opts
 
@@ -136,7 +330,48 @@ def postprocess_for_cse(expr, optimizations):
     return expr
 
 
-def opt_cse(exprs, order='canonical'):
+@inspect_code
+def pairwise_most_common(sets):
+    """Return a list of `(s, L)` tuples where `s` is the largest subset
+    of elements that appear in pairs of sets given by `sets` and `L`
+    is a list of tuples giving the indices of the pairs of sets in
+    which those elements appeared. All `s` will be of the same length.
+
+    Examples
+    ========
+
+    >>> from sympy.simplify.cse_main import pairwise_most_common
+    >>> pairwise_most_common((
+    ...     set([1,2,3]),
+    ...     set([1,3,5]),
+    ...     set([1,2,3,4,5]),
+    ...     set([1,2,3,6])))
+    [(set([1, 3, 5]), [(1, 2)]), (set([1, 2, 3]), [(0, 2), (0, 3), (2, 3)])]
+    >>>
+    """
+    from sympy.utilities.iterables import subsets
+    from collections import defaultdict
+    most = -1
+    for i, j in subsets(list(range(len(sets))), 2):
+        com = sets[i] & sets[j]
+        if com and len(com) > most:
+            best = defaultdict(list)
+            best_keys = []
+            most = len(com)
+        if len(com) == most:
+            if com not in best_keys:
+                best_keys.append(com)
+            best[best_keys.index(com)].append((i,j))
+    if most == -1:
+        return []
+    for k in range(len(best)):
+        best_keys[k] = (best_keys[k], best[k])
+    best_keys.sort(key=lambda x: len(x[1]))
+    return best_keys
+
+
+@inspect_code
+def opt_cse(exprs, order='canonical', verbose=False):
     """Find optimization opportunities in Adds, Muls, Pows and negative
     coefficient Muls
 
@@ -147,6 +382,8 @@ def opt_cse(exprs, order='canonical'):
     order : string, 'none' or 'canonical'
         The order by which Mul and Add arguments are processed. For large
         expressions where speed is a concern, use the setting order='none'.
+    verbose : bool
+        Print debug information (default=False)
 
     Returns
     -------
@@ -218,55 +455,154 @@ def _match_common_args(Func, funcs):
         else:
             funcs = sorted(funcs, key=lambda x: len(x.args))
 
-        func_args = [set(e.args) for e in funcs]
-        for i in range(len(func_args)):
-            for j in range(i + 1, len(func_args)):
-                com_args = func_args[i].intersection(func_args[j])
-                if len(com_args) > 1:
-                    com_func = Func(*com_args)
-
-                    # for all sets, replace the common symbols by the function
-                    # over them, to allow recursive matches
-
-                    diff_i = func_args[i].difference(com_args)
-                    func_args[i] = diff_i | {com_func}
-                    if diff_i:
-                        opt_subs[funcs[i]] = Func(Func(*diff_i), com_func,
-                                                  evaluate=False)
-
-                    diff_j = func_args[j].difference(com_args)
-                    func_args[j] = diff_j | {com_func}
-                    opt_subs[funcs[j]] = Func(Func(*diff_j), com_func,
-                                              evaluate=False)
-
-                    for k in range(j + 1, len(func_args)):
-                        if not com_args.difference(func_args[k]):
-                            diff_k = func_args[k].difference(com_args)
-                            func_args[k] = diff_k | {com_func}
-                            opt_subs[funcs[k]] = Func(Func(*diff_k), com_func,
-                                                      evaluate=False)
+        if Func is Mul:
+            F = Pow
+            meth = 'as_powers_dict'
+            from sympy.core.add import _addsort as inplace_sorter
+        elif Func is Add:
+            F = Mul
+            meth = 'as_coefficients_dict'
+            from sympy.core.mul import _mulsort as inplace_sorter
+        else:
+            assert None  # expected Mul or Add
+
+        # ----------------- helpers ---------------------------
+        def ufunc(*args):
+            # return a well formed unevaluated function from the args
+            # SHARES Func, inplace_sorter
+            args = list(args)
+            inplace_sorter(args)
+            return Func(*args, evaluate=False)
+
+        def as_dict(e):
+            # creates a dictionary of the expression using either
+            # as_coefficients_dict or as_powers_dict, depending on Func
+            # SHARES meth
+            d = getattr(e, meth, lambda: {a: S.One for a in e.args})()
+            for k in list(d.keys()):
+                try:
+                    as_int(d[k])
+                except ValueError:
+                    d[F(k, d.pop(k))] = S.One
+            return d
+
+        def from_dict(d):
+            # build expression from dict from
+            # as_coefficients_dict or as_powers_dict
+            # SHARES F
+            return ufunc(*[F(k, v) for k, v in d.items()])
+
+        def update(k):
+            # updates all of the info associated with k using
+            # the com_dict: func_dicts, func_args, opt_subs
+            # returns True if all values were updated, else None
+            # SHARES com_dict, com_func, func_dicts, func_args,
+            #        opt_subs, funcs, verbose
+            for di in com_dict:
+                # don't allow a sign to change
+                if com_dict[di] > func_dicts[k][di]:
+                    return
+            # remove it
+            if Func is Add:
+                take = min(func_dicts[k][i] for i in com_dict)
+                com_func_take = Mul(take, from_dict(com_dict), evaluate=False)
+            else:
+                take = igcd(*[func_dicts[k][i] for i in com_dict])
+                com_func_take = Pow(from_dict(com_dict), take, evaluate=False)
+            for di in com_dict:
+                func_dicts[k][di] -= take*com_dict[di]
+            # compute the remaining expression
+            rem = from_dict(func_dicts[k])
+            # reject hollow change, e.g extracting x + 1 from x + 3
+            if Func is Add and rem and rem.is_Integer and 1 in com_dict:
+                return
+            if verbose:
+                print('\nfunc %s (%s) \ncontains %s \nas %s \nleaving %s' %
+                    (funcs[k], func_dicts[k], com_func, com_func_take, rem))
+            # recompute the dict since some keys may now
+            # have corresponding values of 0; one could
+            # keep track of which ones went to zero but
+            # this seems cleaner
+            func_dicts[k] = as_dict(rem)
+            # update associated info
+            func_dicts[k][com_func] = take
+            func_args[k] = set(func_dicts[k])
+            # keep the constant separate from the remaining
+            # part of the expression, e.g. 2*(a*b) rather than 2*a*b
+            opt_subs[funcs[k]] = ufunc(rem, com_func_take)
+            # everything was updated
+            return True
+
+        def get_copy(i):
+            return [func_dicts[i].copy(), func_args[i].copy(), funcs[i], i]
+
+        def restore(dafi):
+            i = dafi.pop()
+            func_dicts[i], func_args[i], funcs[i] = dafi
+
+        # ----------------- end helpers -----------------------
+
+        func_dicts = [as_dict(f) for f in funcs]
+        func_args = [set(d) for d in func_dicts]
+        while True:
+            hit = pairwise_most_common(func_args)
+            if not hit or len(hit[0][0]) <= 1:
+                break
+            changed = False
+            for com_args, ij in hit:
+                take = len(com_args)
+                ALL = list(ordered(com_args))
+                while take >= 2:
+                    for com_args in subsets(ALL, take):
+                        com_func = Func(*com_args)
+                        com_dict = as_dict(com_func)
+                        for i, j in ij:
+                            dafi = None
+                            if com_func != funcs[i]:
+                                dafi = get_copy(i)
+                                ch = update(i)
+                                if not ch:
+                                    restore(dafi)
+                                    continue
+                            if com_func != funcs[j]:
+                                dafj = get_copy(j)
+                                ch = update(j)
+                                if not ch:
+                                    if dafi is not None:
+                                        restore(dafi)
+                                    restore(dafj)
+                                    continue
+                            changed = True
+                        if changed:
+                            break
+                    else:
+                        take -= 1
+                        continue
+                    break
+                else:
+                    continue
+                break
+            if not changed:
+                break
 
     # split muls into commutative
-    comutative_muls = set()
+    commutative_muls = set()
     for m in muls:
         c, nc = m.args_cnc(cset=True)
         if c:
             c_mul = m.func(*c)
             if nc:
-                if c_mul == 1:
-                    new_obj = m.func(*nc)
-                else:
-                    new_obj = m.func(c_mul, m.func(*nc), evaluate=False)
-                opt_subs[m] = new_obj
+                opt_subs[m] = m.func(c_mul, m.func(*nc), evaluate=False)
             if len(c) > 1:
-                comutative_muls.add(c_mul)
+                commutative_muls.add(c_mul)
 
     _match_common_args(Add, adds)
-    _match_common_args(Mul, comutative_muls)
+    _match_common_args(Mul, commutative_muls)
 
     return opt_subs
 
 
+@inspect_code
 def tree_cse(exprs, symbols, opt_subs=None, order='canonical'):
     """Perform raw CSE on expression tree, taking opt_subs into account.
 
@@ -394,9 +730,34 @@ def _rebuild(expr):
             reduced_e = e
         reduced_exprs.append(reduced_e)
 
+    # don't allow hollow nesting
+    # e.g if p = [b + 2*d + e + f, b + 2*d + f + g, a + c + d + f + g]
+    # and R, C = cse(p) then
+    #     R = [(x0, d + f), (x1, b + d)]
+    #     C = [e + x0 + x1, g + x0 + x1, a + c + d + f + g]
+    # but the args of C[-1] should not be `(a + c, d + f + g)`
+    nested = [[i for i in f.args if isinstance(i, f.func)] for f in exprs]
+    for i in range(len(exprs)):
+        F = reduced_exprs[i].func
+        if not (F is Mul or F is Add):
+            continue
+        nested = [a for a in exprs[i].args if isinstance(a, F)]
+        args = []
+        for a in reduced_exprs[i].args:
+            if isinstance(a, F):
+                for ai in a.args:
+                    if isinstance(ai, F) and ai not in nested:
+                        args.extend(ai.args)
+                    else:
+                        args.append(ai)
+            else:
+                args.append(a)
+        reduced_exprs[i] = F(*args)
+
     return replacements, reduced_exprs
 
 
+@inspect_code
 def cse(exprs, symbols=None, optimizations=None, postprocess=None,
         order='canonical'):
     """ Perform common subexpression elimination on an expression.
@@ -444,7 +805,7 @@ def cse(exprs, symbols=None, optimizations=None, postprocess=None,
     >>> from sympy import cse, SparseMatrix
     >>> from sympy.abc import x, y, z, w
     >>> cse(((w + x + y + z)*(w + y + z))/(w + x)**3)
-    ([(x0, y + z), (x1, w + x)], [(w + x0)*(x0 + x1)/x1**3])
+    ([(x0, w + y + z)], [x0*(x + x0)/(w + x)**3])
 
     Note that currently, y + z will not get substituted if -y - z is used.
 
diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py
index c6e706c..a3664a3 100644
--- a/sympy/simplify/tests/test_cse.py
+++ b/sympy/simplify/tests/test_cse.py
@@ -2,10 +2,11 @@
 
 from sympy import (Add, Pow, Symbol, exp, sqrt, symbols, sympify, cse,
                    Matrix, S, cos, sin, Eq, Function, Tuple, CRootOf,
-                   IndexedBase, Idx, Piecewise, O)
+                   IndexedBase, Idx, Piecewise, O, Mul)
 from sympy.simplify.cse_opts import sub_pre, sub_post
 from sympy.functions.special.hyper import meijerg
 from sympy.simplify import cse_main, cse_opts
+from sympy.utilities.iterables import subsets
 from sympy.utilities.pytest import XFAIL, raises
 from sympy.matrices import (eye, SparseMatrix, MutableDenseMatrix,
     MutableSparseMatrix, ImmutableDenseMatrix, ImmutableSparseMatrix)
@@ -15,7 +16,7 @@
 
 
 w, x, y, z = symbols('w,x,y,z')
-x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12 = symbols('x:13')
+x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18 = symbols('x:19')
 
 
 def test_numbered_symbols():
@@ -174,9 +175,17 @@ def test_non_commutative_order():
     assert cse(l) == ([(x0, B+C)], [x0, A*x0])
 
 
-@XFAIL
-def test_powers():
-    assert cse(x*y**2 + x*y) == ([(x0, x*y)], [x0*y + x0])
+def test_issue_10228():
+    assert cse([x*y**2 + x*y]) == ([(x0, x*y)], [x0*y + x0])
+    assert cse([x + y, 2*x + y]) == ([(x0, x + y)], [x0, x + x0])
+    assert cse((w + 2*x + y + z, w + x + 1)) == (
+        [(x0, w + x)], [x0 + x + y + z, x0 + 1])
+    assert cse(((w + x + y + z)*(w - x))/(w + x)) == (
+        [(x0, w + x)], [(x0 + y + z)*(w - x)/x0])
+    a, b, c, d, f, g, j, m = symbols('a, b, c, d, f, g, j, m')
+    exprs = (d*g**2*j*m, 4*a*f*g*m, a*b*c*f**2)
+    assert cse(exprs) == (
+        [(x0, g*m), (x1, a*f)], [d*g*j*x0, 4*x0*x1, b*c*f*x1])
 
 
 def test_issue_4498():
@@ -264,12 +273,21 @@ def test_issue_4499():
         sqrt(z))*G(b)*G(2*a - b + 1), 1, 0, S(1)/2, z/2, -b + 1, -2*a + b,
         -2*a))
     c = cse(t)
+    # check rebuild
+    r = c[0]
+    tt = list(c[1][0])
+    for i in range(len(tt)):
+        for re in reversed(r):
+            tt[i] = tt[i].subs(*re)
+        assert tt[i] == t[i]
+    # check answer
     ans = (
-        [(x0, 2*a), (x1, -b), (x2, x1 + 1), (x3, x0 + x2), (x4, sqrt(z)), (x5,
-        B(x0 + x1, x4)), (x6, G(b)), (x7, G(x3)), (x8, -x0), (x9,
-        (x4/2)**(x8 + 1)), (x10, x6*x7*x9*B(b - 1, x4)), (x11, x6*x7*x9*B(b,
-        x4)), (x12, B(x3, x4))], [(a, a + S(1)/2, x0, b, x3, x10*x5,
-        x11*x4*x5, x10*x12*x4, x11*x12, 1, 0, S(1)/2, z/2, x2, b + x8, x8)])
+        [(x0, 2*a), (x1, -b), (x2, x0 + x1 + 1), (x3, sqrt(z)), (x4,
+        B(x0 + x1, x3)), (x5, G(b)), (x6, G(x2)), (x7, -x0), (x8,
+        (x3/2)**(x7 + 1)), (x9, x5*x6*x8*B(b - 1, x3)), (x10,
+        x5*x6*x8*B(b, x3)), (x11, B(x2, x3))], [(a, a + 1/2, x0, b,
+        x2, x4*x9, x10*x3*x4, x11*x3*x9, x10*x11, 1, 0, 1/2, z/2, x1 +
+        1, b + x7, x7)])
     assert ans == c
 
 
@@ -303,12 +321,13 @@ def test_cse_MatrixSymbol():
     B = MatrixSymbol("B", n, n)
     assert cse(B) == ([], [B])
 
+
 def test_cse_MatrixExpr():
     from sympy import MatrixSymbol
     A = MatrixSymbol('A', 3, 3)
     y = MatrixSymbol('y', 3, 1)
 
-    expr1 = (A.T*A).I * A * y
+    expr1 = 2*(A.T*A).I * A * y
     expr2 = (A.T*A) * A * y
     replacements, reduced_exprs = cse([expr1, expr2])
     assert len(replacements) > 0
@@ -319,6 +338,7 @@ def test_cse_MatrixExpr():
     replacements, reduced_exprs = cse([A**2, A + A**2])
     assert replacements
 
+
 def test_Piecewise():
     f = Piecewise((-z + x*y, Eq(y, 0)), (-z - x*y, True))
     ans = cse(f)
@@ -399,3 +419,61 @@ def test_issue_8891():
         ans = ([(x0, x + y)], [x0, cls([[x0, 0], [0, 0]])])
         assert res == ans
         assert isinstance(res[1][-1], cls)
+
+
+def test_issue_11230():
+    from random import choice
+    from sympy.core.function import expand_mul
+    s = symbols('a:m')
+    # 35 Mul tests, none of which should ever fail
+    ex = [Mul(*[choice(s) for i in range(5)]) for i in range(7)]
+    for p in subsets(ex, 3):
+        p = list(p)
+        R, C = cse(p)
+        assert not any(i.is_Mul for a in C for i in a.args)
+        for ri in reversed(R):
+            for i in range(len(C)):
+                C[i] = C[i].subs(*ri)
+        assert p == C
+    # 35 Add tests, none of which should ever fail
+    ex = [Add(*[choice(s[:7]) for i in range(5)]) for i in range(7)]
+    for p in subsets(ex, 3):
+        p = list(p)
+        was = R, C = cse(p)
+        assert not any(i.is_Add for a in C for i in a.args)
+        for ri in reversed(R):
+            for i in range(len(C)):
+                C[i] = C[i].subs(*ri)
+        # use expand_mul to handle cases like this:
+        # p = [a + 2*b + 2*e, 2*b + c + 2*e, b + 2*c + 2*g]
+        # x0 = 2*(b + e) is identified giving a rebuilt p that
+        # is now `[a + 2*(b + e), c + 2*(b + e), b + 2*c + 2*g]`
+        assert p == [expand_mul(i) for i in C]
+
+
+@XFAIL
+def test_issue_11577():
+    def check(eq):
+        from sympy.core.function import count_ops
+        r, c = cse(eq)
+        assert eq.count_ops() >= \
+            len(r) + sum([i[1].count_ops() for i in r]) + \
+            count_ops(c)
+
+    eq = x**5*y**2 + x**5*y + x**5
+    assert cse(eq) == (
+        [(x0, x**4), (x1, x*y)], [x**5 + x0*x1*y + x0*x1])
+        # ([(x0, x**5*y)], [x0*y + x0 + x**5]) or
+        # ([(x0, x**5)], [x0*y**2 + x0*y + x0])
+    check(eq)
+
+    eq = x**2/(y + 1)**2 + x/(y + 1)
+    assert cse(eq) == (
+        [(x0, y + 1)], [x**2/x0**2 + x/x0])
+        # ([(x0, x/(y + 1))], [x0**2 + x0])
+    check(eq)
+
+
+def test_hollow_rejection():
+    eq = [x + 3, x + 4]
+    assert cse(eq) == ([], eq)
diff --git a/sympy/solvers/ode.py b/sympy/solvers/ode.py
index 108d99c..8cfb5cd 100644
--- a/sympy/solvers/ode.py
+++ b/sympy/solvers/ode.py
@@ -4338,8 +4338,6 @@ def ode_linear_coefficients(eq, func, order, match):
     >>> f = Function('f')
     >>> df = f(x).diff(x)
     >>> eq = (x + f(x) + 1)*df + (f(x) - 6*x + 1)
-    >>> dsolve(eq, hint='linear_coefficients')
-    [Eq(f(x), -x - sqrt(C1 + 7*x**2) - 1), Eq(f(x), -x + sqrt(C1 + 7*x**2) - 1)]
     >>> pprint(dsolve(eq, hint='linear_coefficients'))
                       ___________                     ___________
                    /         2                     /         2
@@ -4403,8 +4401,6 @@ def ode_separable_reduced(eq, func, order, match):
     >>> f = Function('f')
     >>> d = f(x).diff(x)
     >>> eq = (x - x**2*f(x))*d - f(x)
-    >>> dsolve(eq, hint='separable_reduced')
-    [Eq(f(x), (-sqrt(C1*x**2 + 1) + 1)/x), Eq(f(x), (sqrt(C1*x**2 + 1) + 1)/x)]
     >>> pprint(dsolve(eq, hint='separable_reduced'))
                  ___________                ___________
                 /     2                    /     2
