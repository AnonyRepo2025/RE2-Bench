diff --git a/sympy/printing/latex.py b/sympy/printing/latex.py
index 8e526dc..8bd879b 100644
--- a/sympy/printing/latex.py
+++ b/sympy/printing/latex.py
@@ -3,6 +3,199 @@
 """
 
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-14564/sympy/printing/latex.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 import itertools
 
@@ -1796,9 +1989,15 @@ def _print_ImageSet(self, s):
             self._print(s.lamda.expr),
             ', '.join(varsets))
 
+    @inspect_code
     def _print_ConditionSet(self, s):
         vars_print = ', '.join([self._print(var) for var in Tuple(s.sym)])
-        return r"\left\{%s\; |\; %s \in %s \wedge %s \right\}" % (
+        if s.base_set is S.UniversalSet:
+            return r"\left\{%s \mid %s \right\}" % (
+            vars_print,
+            self._print(s.condition.as_expr()))
+
+        return r"\left\{%s \mid %s \in %s \wedge %s \right\}" % (
             vars_print,
             vars_print,
             self._print(s.base_set),
diff --git a/sympy/printing/pretty/pretty.py b/sympy/printing/pretty/pretty.py
index 09e2b00..990d385 100644
--- a/sympy/printing/pretty/pretty.py
+++ b/sympy/printing/pretty/pretty.py
@@ -1,4 +1,197 @@
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-14564/sympy/printing/pretty/pretty.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 import itertools
 
@@ -1759,6 +1952,7 @@ def _print_ImageSet(self, ts):
             pargs = tuple(j for var, setv in zip(variables, sets) for j in (var, inn, setv, ","))
             return self._print_seq((expr, bar) + pargs[:-1], "{", "}", ' ')
 
+    @inspect_code
     def _print_ConditionSet(self, ts):
         if self._use_unicode:
             inn = u"\N{SMALL ELEMENT OF}"
@@ -1778,8 +1972,11 @@ def _print_ConditionSet(self, ts):
                 cond = self._print_seq(cond, "(", ")")
 
         bar = self._print("|")
-        base = self._print(ts.base_set)
 
+        if ts.base_set is S.UniversalSet:
+            return self._print_seq((variables, bar, cond), "{", "}", ' ')
+
+        base = self._print(ts.base_set)
         return self._print_seq((variables, bar, variables, inn,
                                 base, _and, cond), "{", "}", ' ')
 
diff --git a/sympy/printing/str.py b/sympy/printing/str.py
index ecaed2a..d503686 100644
--- a/sympy/printing/str.py
+++ b/sympy/printing/str.py
@@ -3,6 +3,199 @@
 """
 
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-14564/sympy/printing/str.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 from sympy.core import S, Rational, Pow, Basic, Mul
 from sympy.core.mul import _keep_coeff
@@ -103,6 +296,14 @@ def _print_Catalan(self, expr):
     def _print_ComplexInfinity(self, expr):
         return 'zoo'
 
+    @inspect_code
+    def _print_ConditionSet(self, s):
+        args = tuple([self._print(i) for i in (s.sym, s.condition)])
+        if s.base_set is S.UniversalSet:
+            return 'ConditionSet(%s, %s)' % args
+        args += (self._print(s.base_set),)
+        return 'ConditionSet(%s, %s, %s)' % args
+
     def _print_Derivative(self, expr):
         dexpr = expr.expr
         dvars = [i[0] if i[1] == 1 else i for i in expr.variable_count]
diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py
index c8f0ae5..e44757c 100644
--- a/sympy/printing/tests/test_latex.py
+++ b/sympy/printing/tests/test_latex.py
@@ -781,7 +781,9 @@ def test_latex_ImageSet():
 def test_latex_ConditionSet():
     x = Symbol('x')
     assert latex(ConditionSet(x, Eq(x**2, 1), S.Reals)) == \
-        r"\left\{x\; |\; x \in \mathbb{R} \wedge x^{2} = 1 \right\}"
+        r"\left\{x \mid x \in \mathbb{R} \wedge x^{2} = 1 \right\}"
+    assert latex(ConditionSet(x, Eq(x**2, 1), S.UniversalSet)) == \
+        r"\left\{x \mid x^{2} = 1 \right\}"
 
 
 def test_latex_ComplexRegion():
diff --git a/sympy/sets/conditionset.py b/sympy/sets/conditionset.py
index bb0e21d..1f88f4a 100644
--- a/sympy/sets/conditionset.py
+++ b/sympy/sets/conditionset.py
@@ -1,8 +1,10 @@
 from __future__ import print_function, division
 
 from sympy import S
+from sympy.sets.contains import Contains
 from sympy.core.basic import Basic
 from sympy.core.containers import Tuple
+from sympy.core.expr import Expr
 from sympy.core.function import Lambda
 from sympy.core.logic import fuzzy_bool
 from sympy.core.symbol import Symbol, Dummy
@@ -10,6 +12,7 @@
 from sympy.sets.sets import (Set, Interval, Intersection, EmptySet, Union,
                              FiniteSet)
 from sympy.utilities.iterables import sift
+from sympy.utilities.misc import filldedent
 from sympy.multipledispatch import dispatch
 
 
@@ -23,7 +26,8 @@ class ConditionSet(Set):
     ========
 
     >>> from sympy import Symbol, S, ConditionSet, pi, Eq, sin, Interval
-    >>> x = Symbol('x')
+    >>> from sympy.abc import x, y, z
+
     >>> sin_sols = ConditionSet(x, Eq(sin(x), 0), Interval(0, 2*pi))
     >>> 2*pi in sin_sols
     True
@@ -33,65 +37,136 @@ class ConditionSet(Set):
     False
     >>> 5 in ConditionSet(x, x**2 > 4, S.Reals)
     True
+
+    If the value is not in the base set, the result is false:
+
+    >>> 5 in ConditionSet(x, x**2 > 4, Interval(2, 4))
+    False
+
+    Notes
+    =====
+
+    Symbols with assumptions should be avoided or else the
+    condition may evaluate without consideration of the set:
+
+    >>> n = Symbol('n', negative=True)
+    >>> cond = (n > 0); cond
+    False
+    >>> ConditionSet(n, cond, S.Integers)
+    EmptySet()
+
+    In addition, substitution of a dummy symbol can only be
+    done with a generic symbol with matching commutativity
+    or else a symbol that has identical assumptions. If the
+    base set contains the dummy symbol it is logically distinct
+    and will be the target of substitution.
+
+    >>> c = ConditionSet(x, x < 1, {x, z})
+    >>> c.subs(x, y)
+    ConditionSet(x, x < 1, {y, z})
+
+    A second substitution is needed to change the dummy symbol, too:
+
+    >>> _.subs(x, y)
+    ConditionSet(y, y < 1, {y, z})
+
+    And trying to replace the dummy symbol with anything but a symbol
+    is ignored: the only change possible will be in the base set:
+
+    >>> ConditionSet(y, y < 1, {y, z}).subs(y, 1)
+    ConditionSet(y, y < 1, {z})
+    >>> _.subs(y, 1)
+    ConditionSet(y, y < 1, {z})
+
+    Notes
+    =====
+
+    If no base set is specified, the universal set is implied:
+
+    >>> ConditionSet(x, x < 1).base_set
+    UniversalSet()
+
+    Although expressions other than symbols may be used, this
+    is discouraged and will raise an error if the expression
+    is not found in the condition:
+
+    >>> ConditionSet(x + 1, x + 1 < 1, S.Integers)
+    ConditionSet(x + 1, x + 1 < 1, S.Integers)
+
+    >>> ConditionSet(x + 1, x < 1, S.Integers)
+    Traceback (most recent call last):
+    ...
+    ValueError: non-symbol dummy not recognized in condition
+
+    Although the name is usually respected, it must be replaced if
+    the base set is another ConditionSet and the dummy symbol
+    and appears as a free symbol in the base set and the dummy symbol
+    of the base set appears as a free symbol in the condition:
+
+    >>> ConditionSet(x, x < y, ConditionSet(y, x + y < 2, S.Integers))
+    ConditionSet(lambda, (lambda < y) & (lambda + x < 2), S.Integers)
+
+    The best way to do anything with the dummy symbol is to access
+    it with the sym property.
+
+    >>> _.subs(_.sym, Symbol('_x'))
+    ConditionSet(_x, (_x < y) & (_x + x < 2), S.Integers)
     """
-    def __new__(cls, sym, condition, base_set):
+    def __new__(cls, sym, condition, base_set=S.UniversalSet):
         # nonlinsolve uses ConditionSet to return an unsolved system
         # of equations (see _return_conditionset in solveset) so until
         # that is changed we do minimal checking of the args
-        unsolved = isinstance(sym, (Tuple, tuple))
-        if unsolved:
+        if isinstance(sym, (Tuple, tuple)):  # unsolved eqns syntax
             sym = Tuple(*sym)
             condition = FiniteSet(*condition)
-        else:
-            condition = as_Boolean(condition)
+            return Basic.__new__(cls, sym, condition, base_set)
+        condition = as_Boolean(condition)
         if isinstance(base_set, set):
             base_set = FiniteSet(*base_set)
         elif not isinstance(base_set, Set):
             raise TypeError('expecting set for base_set')
-        if condition == S.false:
+        if condition is S.false:
             return S.EmptySet
-        if condition == S.true:
+        if condition is S.true:
             return base_set
         if isinstance(base_set, EmptySet):
             return base_set
-        if not unsolved:
-            if isinstance(base_set, FiniteSet):
-                sifted = sift(
-                    base_set, lambda _: fuzzy_bool(
-                        condition.subs(sym, _)))
-                if sifted[None]:
-                    return Union(FiniteSet(*sifted[True]),
-                        Basic.__new__(cls, sym, condition,
-                        FiniteSet(*sifted[None])))
-                else:
-                    return FiniteSet(*sifted[True])
-            if isinstance(base_set, cls):
-                s, c, base_set = base_set.args
-                if sym == s:
-                    condition = And(condition, c)
-                elif sym not in c.free_symbols:
-                    condition = And(condition, c.xreplace({s: sym}))
-                elif s not in condition.free_symbols:
-                    condition = And(condition.xreplace({sym: s}), c)
-                    sym = s
-                else:
-                    # user will have to use cls.sym to get symbol
-                    dum = Symbol('lambda')
-                    if dum in condition.free_symbols or \
-                            dum in c.free_symbols:
-                        dum = Dummy(str(dum))
-                    condition = And(
-                        condition.xreplace({sym: dum}),
-                        c.xreplace({s: dum}))
-                    sym = dum
-            if sym in base_set.free_symbols or \
-                    not isinstance(sym, Symbol):
-                s = Symbol('lambda')
-                if s in base_set.free_symbols:
-                    s = Dummy('lambda')
-                condition = condition.xreplace({sym: s})
+        know = None
+        if isinstance(base_set, FiniteSet):
+            sifted = sift(
+                base_set, lambda _: fuzzy_bool(
+                    condition.subs(sym, _)))
+            if sifted[None]:
+                know = FiniteSet(*sifted[True])
+                base_set = FiniteSet(*sifted[None])
+            else:
+                return FiniteSet(*sifted[True])
+        if isinstance(base_set, cls):
+            s, c, base_set = base_set.args
+            if sym == s:
+                condition = And(condition, c)
+            elif sym not in c.free_symbols:
+                condition = And(condition, c.xreplace({s: sym}))
+            elif s not in condition.free_symbols:
+                condition = And(condition.xreplace({sym: s}), c)
                 sym = s
-        return Basic.__new__(cls, sym, condition, base_set)
+            else:
+                # user will have to use cls.sym to get symbol
+                dum = Symbol('lambda')
+                if dum in condition.free_symbols or \
+                        dum in c.free_symbols:
+                    dum = Dummy(str(dum))
+                condition = And(
+                    condition.xreplace({sym: dum}),
+                    c.xreplace({s: dum}))
+                sym = dum
+        if not isinstance(sym, Symbol):
+            s = Dummy('lambda')
+            if s not in condition.xreplace({sym: s}).free_symbols:
+                raise ValueError(
+                    'non-symbol dummy not recognized in condition')
+        rv = Basic.__new__(cls, sym, condition, base_set)
+        return rv if know is None else Union(know, rv)
 
     sym = property(lambda self: self.args[0])
     condition = property(lambda self: self.args[1])
@@ -107,16 +182,45 @@ def contains(self, other):
             other), self.base_set.contains(other))
 
     def _eval_subs(self, old, new):
-        if not isinstance(self.sym, Symbol):
+        if not isinstance(self.sym, Expr):
             # Don't do anything with the equation set syntax;
             # that should go away, eventually.
             return self
-        if old == self.sym:
-            if new not in self.free_symbols:
-                if isinstance(new, Symbol):
-                    return self.func(*[i.subs(old, new) for i in self.args])
-            return self.func(self.sym, self.condition, self.base_set.subs(old, new))
-        return self.func(*([self.sym] + [i.subs(old, new) for i in self.args[1:]]))
+        sym, cond, base = self.args
+        if old == sym:
+            # we try to be as lenient as possible to allow
+            # the dummy symbol to be changed
+            base = base.subs(old, new)
+            if isinstance(new, Symbol):
+                # if the assumptions don't match, the cond
+                # might evaluate or change
+                if (new.assumptions0 == old.assumptions0 or
+                        len(new.assumptions0) == 1 and
+                        old.is_commutative == new.is_commutative):
+                    if base != self.base_set:
+                        # it will be aggravating to have the dummy
+                        # symbol change if you are trying to target
+                        # the base set so if the base set is changed
+                        # leave the dummy symbol alone -- a second
+                        # subs will be needed to change the dummy
+                        return self.func(sym, cond, base)
+                    else:
+                        return self.func(new, cond.subs(old, new), base)
+                raise ValueError(filldedent('''
+                    A dummy symbol can only be
+                    replaced with a symbol having the same
+                    assumptions or one having a single assumption
+                    having the same commutativity.
+                '''))
+            # don't target cond: it is there to tell how
+            # the base set should be filtered and if new is not in
+            # the base set then this substitution is ignored
+            return self.func(sym, cond, base)
+        cond = self.condition.subs(old, new)
+        base = self.base_set.subs(old, new)
+        if cond is S.true:
+            return ConditionSet(new, Contains(new, base), base)
+        return self.func(self.sym, cond, base)
 
     def dummy_eq(self, other, symbol=None):
         if not isinstance(other, self.func):
diff --git a/sympy/sets/tests/test_conditionset.py b/sympy/sets/tests/test_conditionset.py
index ae094cc..b5bdae1 100644
--- a/sympy/sets/tests/test_conditionset.py
+++ b/sympy/sets/tests/test_conditionset.py
@@ -1,7 +1,7 @@
 from sympy.sets import (ConditionSet, Intersection, FiniteSet,
     EmptySet, Union)
 from sympy import (Symbol, Eq, Lt, S, Abs, sin, pi, Lambda, Interval,
-    And, Mod)
+    And, Mod, oo, Function)
 from sympy.utilities.pytest import raises
 
 
@@ -10,6 +10,7 @@
 y = Symbol('y')
 z = Symbol('z')
 L = Symbol('lambda')
+f = Function('f')
 
 
 def test_CondSet():
@@ -20,6 +21,16 @@ def test_CondSet():
     assert 3*pi not in sin_sols_principal
     assert 5 in ConditionSet(x, x**2 > 4, S.Reals)
     assert 1 not in ConditionSet(x, x**2 > 4, S.Reals)
+    # in this case, 0 is not part of the base set so
+    # it can't be in any subset selected by the condition
+    assert 0 not in ConditionSet(x, y > 5, Interval(1, 7))
+    # since 'in' requires a true/false, the following raises
+    # an error because the given value provides no information
+    # for the condition to evaluate (since the condition does
+    # not depend on the dummy symbol): the result is `y > 5`.
+    # In this case, ConditionSet is just acting like
+    # Piecewise((Interval(1, 7), y > 5), (S.EmptySet, True)).
+    raises(TypeError, lambda: 6 in ConditionSet(x, y > 5, Interval(1, 7)))
 
     assert isinstance(ConditionSet(x, x < 1, {x, y}).base_set, FiniteSet)
     raises(TypeError, lambda: ConditionSet(x, x + 1, {x, y}))
@@ -41,9 +52,7 @@ def test_CondSet():
     assert c == C(c.sym, (L < y) & (x < 1), I)
     assert c.sym not in (x, y, L)
     c = C(y, x < 1, C(x, y < x, FiniteSet(L)))
-    assert c == C(
-        c.sym, c.condition.xreplace({L: c.sym}), FiniteSet(L))
-    assert c.sym not in (x, y, L)
+    assert c == C(L, And(x < 1, y < L), FiniteSet(L))
 
 
 def test_CondSet_intersect():
@@ -84,11 +93,44 @@ def test_subs_CondSet():
     # you can only replace sym with a symbol that is not in
     # the free symbols
     assert c.subs(x, 1) == c
-    assert c.subs(x, y) == c
+    assert c.subs(x, y) == ConditionSet(y, y < 2, s)
+
+    # double subs needed to change dummy if the base set
+    # also contains the dummy
+    orig = ConditionSet(y, y < 2, s)
+    base = orig.subs(y, w)
+    and_dummy = base.subs(y, w)
+    assert base == ConditionSet(y, y < 2, {w, z})
+    assert and_dummy == ConditionSet(w, w < 2, {w, z})
+
     assert c.subs(x, w) == ConditionSet(w, w < 2, s)
     assert ConditionSet(x, x < y, s
         ).subs(y, w) == ConditionSet(x, x < w, s.subs(y, w))
-
+    # if the user uses assumptions that cause the condition
+    # to evaluate, that can't be helped from SymPy's end
+    n = Symbol('n', negative=True)
+    assert ConditionSet(n, 0 < n, S.Integers) is S.EmptySet
+    p = Symbol('p', positive=True)
+    assert ConditionSet(n, n < y, S.Integers
+        ).subs(n, x) == ConditionSet(x, x < y, S.Integers)
+    nc = Symbol('nc', commutative=False)
+    raises(ValueError, lambda: ConditionSet(
+        x, x < p, S.Integers).subs(x, nc))
+    raises(ValueError, lambda: ConditionSet(
+        x, x < p, S.Integers).subs(x, n))
+    raises(ValueError, lambda: ConditionSet(
+        x + 1, x < 1, S.Integers))
+    raises(ValueError, lambda: ConditionSet(
+        x + 1, x < 1, s))
+    assert ConditionSet(
+        n, n < x, Interval(0, oo)).subs(x, p) == Interval(0, oo)
+    assert ConditionSet(
+        n, n < x, Interval(-oo, 0)).subs(x, p) == S.EmptySet
+    assert ConditionSet(f(x), f(x) < 1, {w, z}
+        ).subs(f(x), y) == ConditionSet(y, y < 1, {w, z})
+
+
+def test_subs_CondSet_tebr():
     # to eventually be removed
     c = ConditionSet((x, y), {x + 1, x + y}, S.Reals)
     assert c.subs(x, z) == c
@@ -111,3 +153,18 @@ def test_dummy_eq():
     assert c1.dummy_eq(c3) is False
     assert c.dummy_eq(c1) is False
     assert c1.dummy_eq(c) is False
+
+
+def test_contains():
+    assert 6 in ConditionSet(x, x > 5, Interval(1, 7))
+    assert (8 in ConditionSet(x, y > 5, Interval(1, 7))) is False
+    # `in` should give True or False; in this case there is not
+    # enough information for that result
+    raises(TypeError,
+        lambda: 6 in ConditionSet(x, y > 5, Interval(1, 7)))
+    assert ConditionSet(x, y > 5, Interval(1, 7)
+        ).contains(6) == (y > 5)
+    assert ConditionSet(x, y > 5, Interval(1, 7)
+        ).contains(8) is S.false
+    assert ConditionSet(x, y > 5, Interval(1, 7)
+        ).contains(w) == And(w >= 1, w <= 7, y > 5)
