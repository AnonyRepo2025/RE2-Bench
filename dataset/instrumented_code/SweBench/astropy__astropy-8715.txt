diff --git a/astropy/io/votable/__init__.py b/astropy/io/votable/__init__.py
index c6a8e4f..a473c92 100644
--- a/astropy/io/votable/__init__.py
+++ b/astropy/io/votable/__init__.py
@@ -24,10 +24,13 @@ class Conf(_config.ConfigNamespace):
     Configuration parameters for `astropy.io.votable`.
     """
 
-    pedantic = _config.ConfigItem(
-        False,
-        'When True, treat fixable violations of the VOTable spec as exceptions.',
-        aliases=['astropy.io.votable.table.pedantic'])
+    verify = _config.ConfigItem(
+        'ignore',
+        "Can be 'exception' (treat fixable violations of the VOTable spec as "
+        "exceptions), 'warn' (show warnings for VOTable spec violations), or "
+        "'ignore' (silently ignore VOTable spec violations)",
+        aliases=['astropy.io.votable.table.pedantic',
+                 'astropy.io.votable.pedantic'])
 
 
 conf = Conf()
diff --git a/astropy/io/votable/connect.py b/astropy/io/votable/connect.py
index a1ad77c..5bee8f7 100644
--- a/astropy/io/votable/connect.py
+++ b/astropy/io/votable/connect.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-8715/astropy/io/votable/connect.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 
 
@@ -44,7 +237,8 @@ def is_votable(origin, filepath, fileobj, *args, **kwargs):
         return False
 
 
-def read_table_votable(input, table_id=None, use_names_over_ids=False):
+@inspect_code
+def read_table_votable(input, table_id=None, use_names_over_ids=False, verify=None):
     """
     Read a Table object from an VO table file
 
@@ -68,9 +262,17 @@ def read_table_votable(input, table_id=None, use_names_over_ids=False):
         are not guaranteed to be unique, this may cause some columns
         to be renamed by appending numbers to the end.  Otherwise
         (default), use the ID attributes as the column names.
+
+    verify : {'ignore', 'warn', 'exception'}, optional
+        When ``'exception'``, raise an error when the file violates the spec,
+        otherwise either issue a warning (``'warn'``) or silently continue
+        (``'ignore'``). Warnings may be controlled using the standard Python
+        mechanisms.  See the `warnings` module in the Python standard library
+        for more information. When not provided, uses the configuration setting
+        ``astropy.io.votable.verify``, which defaults to ``'ignore'``.
     """
     if not isinstance(input, (VOTableFile, VOTable)):
-        input = parse(input, table_id=table_id)
+        input = parse(input, table_id=table_id, verify=verify)
 
     # Parse all table objects
     table_id_mapping = dict()
diff --git a/astropy/io/votable/converters.py b/astropy/io/votable/converters.py
index ea32d6f..1786cee 100644
--- a/astropy/io/votable/converters.py
+++ b/astropy/io/votable/converters.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-8715/astropy/io/votable/converters.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 """
 This module handles the conversion of various VOTABLE datatypes
@@ -292,6 +485,7 @@ class Char(Converter):
     """
     default = _empty_bytes
 
+    @inspect_code
     def __init__(self, field, config=None, pos=None):
         if config is None:
             config = {}
@@ -319,7 +513,7 @@ class Char(Converter):
             self.binoutput = self._binoutput_fixed
             self._struct_format = ">{:d}s".format(self.arraysize)
 
-        if config.get('pedantic'):
+        if config.get('verify', 'ignore') == 'exception':
             self.parse = self._ascii_parse
         else:
             self.parse = self._str_parse
@@ -439,7 +633,7 @@ class Array(Converter):
         if config is None:
             config = {}
         Converter.__init__(self, field, config, pos)
-        if config.get('pedantic'):
+        if config.get('verify', 'ignore') == 'exception':
             self._splitter = self._splitter_pedantic
         else:
             self._splitter = self._splitter_lax
@@ -578,7 +772,7 @@ class NumericArray(Array):
         parts = self._splitter(value, config, pos)
         if len(parts) != self._items:
             warn_or_raise(E02, E02, (self._items, len(parts)), config, pos)
-        if config.get('pedantic'):
+        if config.get('verify', 'ignore') == 'exception':
             return self.parse_parts(parts, config, pos)
         else:
             if len(parts) == self._items:
@@ -698,7 +892,7 @@ class FloatingPoint(Numeric):
             self._null_binoutput = self.binoutput(np.asarray(self.null), False)
             self.filter_array = self._filter_null
 
-        if config.get('pedantic'):
+        if config.get('verify', 'ignore') == 'exception':
             self.parse = self._parse_pedantic
         else:
             self.parse = self._parse_permissive
diff --git a/astropy/io/votable/exceptions.py b/astropy/io/votable/exceptions.py
index 8585fbb..a1002e9 100644
--- a/astropy/io/votable/exceptions.py
+++ b/astropy/io/votable/exceptions.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-8715/astropy/io/votable/exceptions.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 # -*- coding: utf-8 -*-
 """
@@ -24,9 +217,9 @@ Exceptions
 
 .. note::
 
-    This is a list of many of the fatal exceptions emitted by vo.table
+    This is a list of many of the fatal exceptions emitted by ``astropy.io.votable``
     when the file does not conform to spec.  Other exceptions may be
-    raised due to unforeseen cases or bugs in vo.table itself.
+    raised due to unforeseen cases or bugs in ``astropy.io.votable`` itself.
 
 {exceptions}
 """
@@ -77,15 +270,19 @@ def _suppressed_warning(warning, config, stacklevel=2):
 def warn_or_raise(warning_class, exception_class=None, args=(), config=None,
                   pos=None, stacklevel=1):
     """
-    Warn or raise an exception, depending on the pedantic setting.
+    Warn or raise an exception, depending on the verify setting.
     """
     if config is None:
         config = {}
-    if config.get('pedantic'):
+    # NOTE: the default here is deliberately warn rather than ignore, since
+    # one would expect that calling warn_or_raise without config should not
+    # silence the warnings.
+    config_value = config.get('verify', 'warn')
+    if config_value == 'exception':
         if exception_class is None:
             exception_class = warning_class
         vo_raise(exception_class, args, config, pos)
-    else:
+    elif config_value == 'warn':
         vo_warn(warning_class, args, config, pos, stacklevel=stacklevel+1)
 
 
@@ -116,14 +313,19 @@ def vo_reraise(exc, config=None, pos=None, additional=''):
     raise exc
 
 
+@inspect_code
 def vo_warn(warning_class, args=(), config=None, pos=None, stacklevel=1):
     """
     Warn, with proper position information if available.
     """
     if config is None:
         config = {}
-    warning = warning_class(args, config, pos)
-    _suppressed_warning(warning, config, stacklevel=stacklevel+1)
+    # NOTE: the default here is deliberately warn rather than ignore, since
+    # one would expect that calling warn_or_raise without config should not
+    # silence the warnings.
+    if config.get('verify', 'warn') != 'ignore':
+        warning = warning_class(args, config, pos)
+        _suppressed_warning(warning, config, stacklevel=stacklevel+1)
 
 
 def warn_unknown_attrs(element, attrs, config, pos, good_attr=[], stacklevel=1):
@@ -249,10 +451,10 @@ class W01(VOTableSpecWarning):
         encoded as multiple numbers separated by whitespace.
 
     Many VOTable files in the wild use commas as a separator instead,
-    and ``vo.table`` supports this convention when not in
+    and ``astropy.io.votable`` supports this convention when not in
     :ref:`pedantic-mode`.
 
-    ``vo.table`` always outputs files using only spaces, regardless of
+    ``astropy.io.votable`` always outputs files using only spaces, regardless of
     how they were input.
 
     **References**: `1.1
@@ -280,7 +482,7 @@ class W02(VOTableSpecWarning):
 
     However, this is in conflict with the XML standard, which says
     colons may not be used.  VOTable 1.1's own schema does not allow a
-    colon here.  Therefore, ``vo.table`` disallows the colon.
+    colon here.  Therefore, ``astropy.io.votable`` disallows the colon.
 
     VOTable 1.2 corrects this error in the specification.
 
@@ -323,7 +525,7 @@ class W03(VOTableChangeWarning):
         ``name`` attributes of ``FIELD``, ``PARAM`` and optional
         ``GROUP`` elements should be all different.
 
-    Since ``vo.table`` requires a unique identifier for each of its
+    Since ``astropy.io.votable`` requires a unique identifier for each of its
     columns, ``ID`` is used for the column name when present.
     However, when ``ID`` is not present, (since it is not required by
     the specification) ``name`` is used instead.  However, ``name``
@@ -415,7 +617,7 @@ class W07(VOTableSpecWarning):
 
 class W08(VOTableSpecWarning):
     """
-    To avoid local-dependent number parsing differences, ``vo.table``
+    To avoid local-dependent number parsing differences, ``astropy.io.votable``
     may require a string or unicode string where a numeric type may
     make more sense.
     """
@@ -430,8 +632,8 @@ class W09(VOTableSpecWarning):
     The VOTable specification uses the attribute name ``ID`` (with
     uppercase letters) to specify unique identifiers.  Some
     VOTable-producing tools use the more standard lowercase ``id``
-    instead.  ``vo.table`` accepts ``id`` and emits this warning when
-    not in ``pedantic`` mode.
+    instead. ``astropy.io.votable`` accepts ``id`` and emits this warning if
+    ``verify`` is ``'warn'``.
 
     **References**: `1.1
     <http://www.ivoa.net/Documents/VOTable/20040811/REC-VOTable-1.1-20040811.html#sec:name>`__,
@@ -449,7 +651,7 @@ class W10(VOTableSpecWarning):
     against the VOTable schema (with a tool such as `xmllint
     <http://xmlsoft.org/xmllint.html>`__.  If the file validates
     against the schema, and you still receive this warning, this may
-    indicate a bug in ``vo.table``.
+    indicate a bug in ``astropy.io.votable``.
 
     **References**: `1.1
     <http://www.ivoa.net/Documents/VOTable/20040811/REC-VOTable-1.1-20040811.html#ToC54>`__,
@@ -468,7 +670,7 @@ class W11(VOTableSpecWarning):
     <http://aladin.u-strasbg.fr/glu/>`__.  New files should
     specify a ``glu:`` protocol using the ``href`` attribute.
 
-    Since ``vo.table`` does not currently support GLU references, it
+    Since ``astropy.io.votable`` does not currently support GLU references, it
     likewise does not automatically convert the ``gref`` attribute to
     the new form.
 
@@ -487,8 +689,8 @@ class W12(VOTableChangeWarning):
     ``FIELD`` element must have either an ``ID`` or ``name`` attribute
     to derive a name from.  Strictly speaking, according to the
     VOTable schema, the ``name`` attribute is required.  However, if
-    ``name`` is not present by ``ID`` is, and *pedantic mode* is off,
-    ``vo.table`` will continue without a ``name`` defined.
+    ``name`` is not present by ``ID`` is, and ``verify`` is not ``'exception'``,
+    ``astropy.io.votable`` will continue without a ``name`` defined.
 
     **References**: `1.1
     <http://www.ivoa.net/Documents/VOTable/20040811/REC-VOTable-1.1-20040811.html#sec:name>`__,
@@ -536,8 +738,8 @@ class W15(VOTableSpecWarning):
     """
     The ``name`` attribute is required on every ``FIELD`` element.
     However, many VOTable files in the wild omit it and provide only
-    an ``ID`` instead.  In this case, when *pedantic mode* is off,
-    ``vo.table`` will copy the ``name`` attribute to a new ``ID``
+    an ``ID`` instead.  In this case, when ``verify`` is not ``'exception'``
+    ``astropy.io.votable`` will copy the ``name`` attribute to a new ``ID``
     attribute.
 
     **References**: `1.1
@@ -576,8 +778,8 @@ class W18(VOTableSpecWarning):
     The number of rows explicitly specified in the ``nrows`` attribute
     does not match the actual number of rows (``TR`` elements) present
     in the ``TABLE``.  This may indicate truncation of the file, or an
-    internal error in the tool that produced it.  If *pedantic mode*
-    is off, parsing will proceed, with the loss of some performance.
+    internal error in the tool that produced it.  If ``verify`` is not
+    ``'exception'``, parsing will proceed, with the loss of some performance.
 
     **References:** `1.1
     <http://www.ivoa.net/Documents/VOTable/20040811/REC-VOTable-1.1-20040811.html#ToC10>`__,
@@ -592,8 +794,8 @@ class W18(VOTableSpecWarning):
 class W19(VOTableSpecWarning):
     """
     The column fields as defined using ``FIELD`` elements do not match
-    those in the headers of the embedded FITS file.  If *pedantic
-    mode* is off, the embedded FITS file will take precedence.
+    those in the headers of the embedded FITS file.  If ``verify`` is not
+    ``'exception'``, the embedded FITS file will take precedence.
     """
 
     message_template = (
@@ -613,12 +815,12 @@ class W20(VOTableSpecWarning):
 
 class W21(UnimplementedWarning):
     """
-    Unknown issues may arise using ``vo.table`` with VOTable files
+    Unknown issues may arise using ``astropy.io.votable`` with VOTable files
     from a version other than 1.1, 1.2 or 1.3.
     """
 
     message_template = (
-        'vo.table is designed for VOTable version 1.1, 1.2 and 1.3, but ' +
+        'astropy.io.votable is designed for VOTable version 1.1, 1.2 and 1.3, but ' +
         'this file is {}')
     default_args = ('x',)
 
@@ -653,12 +855,12 @@ class W23(IOWarning):
 class W24(VOWarning, FutureWarning):
     """
     The VO catalog database retrieved from the www is designed for a
-    newer version of vo.table.  This may cause problems or limited
-    features performing service queries.  Consider upgrading vo.table
+    newer version of ``astropy.io.votable``.  This may cause problems or limited
+    features performing service queries.  Consider upgrading ``astropy.io.votable``
     to the latest version.
     """
 
-    message_template = "The VO catalog database is for a later version of vo.table"
+    message_template = "The VO catalog database is for a later version of astropy.io.votable"
 
 
 class W25(IOWarning):
@@ -726,9 +928,9 @@ class W29(VOTableSpecWarning):
 
 class W30(VOTableSpecWarning):
     """
-    Some VOTable files write missing floating-point values in non-standard
-    ways, such as "null" and "-".  In non-pedantic mode, any non-standard
-    floating-point literals are treated as missing values.
+    Some VOTable files write missing floating-point values in non-standard ways,
+    such as "null" and "-".  If ``verify`` is not ``'exception'``, any
+    non-standard floating-point literals are treated as missing values.
 
     **References**: `1.1
     <http://www.ivoa.net/Documents/VOTable/20040811/REC-VOTable-1.1-20040811.html#sec:datatypes>`__,
@@ -840,7 +1042,7 @@ class W36(VOTableSpecWarning):
 class W37(UnimplementedWarning):
     """
     The 3 datatypes defined in the VOTable specification and supported by
-    vo.table are ``TABLEDATA``, ``BINARY`` and ``FITS``.
+    ``astropy.io.votable`` are ``TABLEDATA``, ``BINARY`` and ``FITS``.
 
     **References:** `1.1
     <http://www.ivoa.net/Documents/VOTable/20040811/REC-VOTable-1.1-20040811.html#sec:data>`__,
diff --git a/astropy/io/votable/table.py b/astropy/io/votable/table.py
index a031bdc..0c14b42 100644
--- a/astropy/io/votable/table.py
+++ b/astropy/io/votable/table.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-8715/astropy/io/votable/table.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 
 """
@@ -17,13 +210,18 @@ from . import exceptions
 from . import tree
 from astropy.utils.xml import iterparser
 from astropy.utils import data
-
+from astropy.utils.decorators import deprecated_renamed_argument
+from astropy.utils.exceptions import AstropyDeprecationWarning
 
 __all__ = ['parse', 'parse_single_table', 'from_table', 'writeto', 'validate',
            'reset_vo_warnings']
 
+VERIFY_OPTIONS = ['ignore', 'warn', 'exception']
+
 
-def parse(source, columns=None, invalid='exception', pedantic=None,
+@inspect_code
+@deprecated_renamed_argument('pedantic', 'verify', pending=True, since='4.0')
+def parse(source, columns=None, invalid='exception', verify=None,
           chunk_size=tree.DEFAULT_CHUNK_SIZE, table_number=None,
           table_id=None, filename=None, unit_format=None,
           datatype_mapping=None, _debug_python_based_parser=False):
@@ -48,13 +246,17 @@ def parse(source, columns=None, invalid='exception', pedantic=None,
 
             - 'mask': mask out invalid values
 
-    pedantic : bool, optional
-        When `True`, raise an error when the file violates the spec,
-        otherwise issue a warning.  Warnings may be controlled using
-        the standard Python mechanisms.  See the `warnings`
-        module in the Python standard library for more information.
-        When not provided, uses the configuration setting
-        ``astropy.io.votable.pedantic``, which defaults to False.
+    verify : {'ignore', 'warn', 'exception'}, optional
+        When ``'exception'``, raise an error when the file violates the spec,
+        otherwise either issue a warning (``'warn'``) or silently continue
+        (``'ignore'``). Warnings may be controlled using the standard Python
+        mechanisms.  See the `warnings` module in the Python standard library
+        for more information. When not provided, uses the configuration setting
+        ``astropy.io.votable.verify``, which defaults to 'ignore'.
+
+        .. versionchanged:: 4.0
+           ``verify`` replaces the ``pedantic`` argument, which will be
+           deprecated in future.
 
     chunk_size : int, optional
         The number of rows to read before converting to an array.
@@ -110,8 +312,30 @@ def parse(source, columns=None, invalid='exception', pedantic=None,
         raise ValueError("accepted values of ``invalid`` are: "
                          "``'exception'`` or ``'mask'``.")
 
-    if pedantic is None:
-        pedantic = conf.pedantic
+    if verify is None:
+
+        # NOTE: since the pedantic argument isn't fully deprecated yet, we need
+        # to catch the deprecation warning that occurs when accessing the
+        # configuration item, but only if it is for the pedantic option in the
+        # [io.votable] section.
+        with warnings.catch_warnings():
+            warnings.filterwarnings("ignore",
+                                    r"Config parameter \'pedantic\' in section \[io.votable\]",
+                                    AstropyDeprecationWarning)
+            conf_verify_lowercase = conf.verify.lower()
+
+        # We need to allow verify to be booleans as strings since the
+        # configuration framework doesn't make it easy/possible to have mixed
+        # types.
+        if conf_verify_lowercase in ['false', 'true']:
+            verify = conf_verify_lowercase == 'true'
+        else:
+            verify = conf_verify_lowercase
+
+    if isinstance(verify, bool):
+        verify = 'exception' if verify else 'warn'
+    elif verify not in VERIFY_OPTIONS:
+        raise ValueError('verify should be one of {0}'.format('/'.join(VERIFY_OPTIONS)))
 
     if datatype_mapping is None:
         datatype_mapping = {}
@@ -119,7 +343,7 @@ def parse(source, columns=None, invalid='exception', pedantic=None,
     config = {
         'columns': columns,
         'invalid': invalid,
-        'pedantic': pedantic,
+        'verify': verify,
         'chunk_size': chunk_size,
         'table_number': table_number,
         'filename': filename,
@@ -186,6 +410,7 @@ def writeto(table, file, tabledata_format=None):
                  _debug_python_based_parser=True)
 
 
+@inspect_code
 def validate(source, output=None, xmllint=False, filename=None):
     """
     Prints a validation report for the given file.
@@ -250,7 +475,7 @@ def validate(source, output=None, xmllint=False, filename=None):
         warnings.resetwarnings()
         warnings.simplefilter("always", exceptions.VOWarning, append=True)
         try:
-            votable = parse(content_buffer, pedantic=False, filename=filename)
+            votable = parse(content_buffer, verify='warn', filename=filename)
         except ValueError as e:
             lines.append(str(e))
 
diff --git a/astropy/io/votable/tests/converter_test.py b/astropy/io/votable/tests/converter_test.py
index dd6e073..90eae1c 100644
--- a/astropy/io/votable/tests/converter_test.py
+++ b/astropy/io/votable/tests/converter_test.py
@@ -26,7 +26,7 @@ def test_invalid_arraysize():
 
 
 def test_oversize_char():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     with catch_warnings(exceptions.W47) as w:
         field = tree.Field(
             None, name='c', datatype='char',
@@ -40,7 +40,7 @@ def test_oversize_char():
 
 
 def test_char_mask():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(
         None, name='c', datatype='char',
         config=config)
@@ -49,7 +49,7 @@ def test_char_mask():
 
 
 def test_oversize_unicode():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     with catch_warnings(exceptions.W46) as w:
         field = tree.Field(
             None, name='c2', datatype='unicodeChar',
@@ -61,7 +61,7 @@ def test_oversize_unicode():
 
 
 def test_unicode_mask():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(
         None, name='c', datatype='unicodeChar',
         config=config)
@@ -71,7 +71,7 @@ def test_unicode_mask():
 
 @raises(exceptions.E02)
 def test_wrong_number_of_elements():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(
         None, name='c', datatype='int', arraysize='2x3*',
         config=config)
@@ -81,7 +81,7 @@ def test_wrong_number_of_elements():
 
 @raises(ValueError)
 def test_float_mask():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(
         None, name='c', datatype='float',
         config=config)
@@ -91,7 +91,7 @@ def test_float_mask():
 
 
 def test_float_mask_permissive():
-    config = {'pedantic': False}
+    config = {'verify': 'ignore'}
     field = tree.Field(
         None, name='c', datatype='float',
         config=config)
@@ -101,7 +101,7 @@ def test_float_mask_permissive():
 
 @raises(exceptions.E02)
 def test_complex_array_vararray():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(
         None, name='c', datatype='floatComplex', arraysize='2x3*',
         config=config)
@@ -110,7 +110,7 @@ def test_complex_array_vararray():
 
 
 def test_complex_array_vararray2():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(
         None, name='c', datatype='floatComplex', arraysize='2x3*',
         config=config)
@@ -120,7 +120,7 @@ def test_complex_array_vararray2():
 
 
 def test_complex_array_vararray3():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(
         None, name='c', datatype='doubleComplex', arraysize='2x3*',
         config=config)
@@ -131,7 +131,7 @@ def test_complex_array_vararray3():
 
 
 def test_complex_vararray():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(
         None, name='c', datatype='doubleComplex', arraysize='*',
         config=config)
@@ -143,7 +143,7 @@ def test_complex_vararray():
 
 @raises(exceptions.E03)
 def test_complex():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(
         None, name='c', datatype='doubleComplex',
         config=config)
@@ -153,7 +153,7 @@ def test_complex():
 
 @raises(exceptions.E04)
 def test_bit():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(
         None, name='c', datatype='bit',
         config=config)
@@ -162,7 +162,7 @@ def test_bit():
 
 
 def test_bit_mask():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     with catch_warnings(exceptions.W39) as w:
         field = tree.Field(
             None, name='c', datatype='bit',
@@ -174,7 +174,7 @@ def test_bit_mask():
 
 @raises(exceptions.E05)
 def test_boolean():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(
         None, name='c', datatype='boolean',
         config=config)
@@ -183,7 +183,7 @@ def test_boolean():
 
 
 def test_boolean_array():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(
         None, name='c', datatype='boolean', arraysize='*',
         config=config)
@@ -194,7 +194,7 @@ def test_boolean_array():
 
 @raises(exceptions.E06)
 def test_invalid_type():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(
         None, name='c', datatype='foobar',
         config=config)
@@ -202,7 +202,7 @@ def test_invalid_type():
 
 
 def test_precision():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
 
     field = tree.Field(
         None, name='c', datatype='float', precision="E4",
@@ -219,7 +219,7 @@ def test_precision():
 
 @raises(exceptions.W51)
 def test_integer_overflow():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
 
     field = tree.Field(
         None, name='c', datatype='int', config=config)
@@ -228,7 +228,7 @@ def test_integer_overflow():
 
 
 def test_float_default_precision():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
 
     field = tree.Field(
         None, name='c', datatype='float', arraysize="4",
diff --git a/astropy/io/votable/tests/exception_test.py b/astropy/io/votable/tests/exception_test.py
index 3f59e32..a4d4a54 100644
--- a/astropy/io/votable/tests/exception_test.py
+++ b/astropy/io/votable/tests/exception_test.py
@@ -24,7 +24,7 @@ def test_reraise():
 
 
 def test_parse_vowarning():
-    config = {'pedantic': True,
+    config = {'verify': 'exception',
               'filename': 'foo.xml'}
     pos = (42, 64)
     with catch_warnings(exceptions.W47) as w:
diff --git a/astropy/io/votable/tests/table_test.py b/astropy/io/votable/tests/table_test.py
index f91251a..2809789 100644
--- a/astropy/io/votable/tests/table_test.py
+++ b/astropy/io/votable/tests/table_test.py
@@ -6,18 +6,21 @@ import io
 import os
 
 import pathlib
+import pytest
 import numpy as np
 
+from astropy.config import set_temp_config, reload_config
 from astropy.utils.data import get_pkg_data_filename, get_pkg_data_fileobj
 from astropy.io.votable.table import parse, writeto
-from astropy.io.votable import tree
+from astropy.io.votable import tree, conf
+from astropy.io.votable.exceptions import VOWarning
+from astropy.tests.helper import catch_warnings
+from astropy.utils.exceptions import AstropyDeprecationWarning
 
 
 def test_table(tmpdir):
     # Read the VOTABLE
-    votable = parse(
-        get_pkg_data_filename('data/regression.xml'),
-        pedantic=False)
+    votable = parse(get_pkg_data_filename('data/regression.xml'))
     table = votable.get_first_table()
     astropy_table = table.to_table()
 
@@ -173,8 +176,93 @@ def test_write_with_format():
 
 
 def test_empty_table():
-    votable = parse(
-        get_pkg_data_filename('data/empty_table.xml'),
-        pedantic=False)
+    votable = parse(get_pkg_data_filename('data/empty_table.xml'))
     table = votable.get_first_table()
     astropy_table = table.to_table()  # noqa
+
+
+class TestVerifyOptions:
+
+    # Start off by checking the default (ignore)
+
+    def test_default(self):
+        with catch_warnings(VOWarning) as w:
+            parse(get_pkg_data_filename('data/gemini.xml'))
+        assert len(w) == 0
+
+    # Then try the various explicit options
+
+    def test_verify_ignore(self):
+        with catch_warnings(VOWarning) as w:
+            parse(get_pkg_data_filename('data/gemini.xml'), verify='ignore')
+        assert len(w) == 0
+
+    def test_verify_warn(self):
+        with catch_warnings(VOWarning) as w:
+            parse(get_pkg_data_filename('data/gemini.xml'), verify='warn')
+        assert len(w) == 25
+
+    def test_verify_exception(self):
+        with pytest.raises(VOWarning):
+            parse(get_pkg_data_filename('data/gemini.xml'), verify='exception')
+
+    # Make sure the pedantic option still works for now (pending deprecation)
+
+    def test_pedantic_false(self):
+        with catch_warnings(VOWarning, AstropyDeprecationWarning) as w:
+            parse(get_pkg_data_filename('data/gemini.xml'), pedantic=False)
+        assert len(w) == 25
+        # Make sure we don't yet emit a deprecation warning
+        assert not any(isinstance(x.category, AstropyDeprecationWarning) for x in w)
+
+    def test_pedantic_true(self):
+        with pytest.raises(VOWarning):
+            parse(get_pkg_data_filename('data/gemini.xml'), pedantic=True)
+
+    # Make sure that the default behavior can be set via configuration items
+
+    def test_conf_verify_ignore(self):
+        with conf.set_temp('verify', 'ignore'):
+            with catch_warnings(VOWarning) as w:
+                parse(get_pkg_data_filename('data/gemini.xml'))
+            assert len(w) == 0
+
+    def test_conf_verify_warn(self):
+        with conf.set_temp('verify', 'warn'):
+            with catch_warnings(VOWarning) as w:
+                parse(get_pkg_data_filename('data/gemini.xml'))
+            assert len(w) == 25
+
+    def test_conf_verify_exception(self):
+        with conf.set_temp('verify', 'exception'):
+            with pytest.raises(VOWarning):
+                parse(get_pkg_data_filename('data/gemini.xml'))
+
+    # And make sure the old configuration item will keep working
+
+    def test_conf_pedantic_false(self, tmpdir):
+
+        with set_temp_config(tmpdir.strpath):
+
+            with open(tmpdir.join('astropy').join('astropy.cfg').strpath, 'w') as f:
+                f.write('[io.votable]\npedantic = False')
+
+            reload_config('astropy.io.votable')
+
+            with catch_warnings(VOWarning, AstropyDeprecationWarning) as w:
+                parse(get_pkg_data_filename('data/gemini.xml'))
+            assert len(w) == 25
+            # Make sure we don't yet emit a deprecation warning
+            assert not any(isinstance(x.category, AstropyDeprecationWarning) for x in w)
+
+    def test_conf_pedantic_true(self, tmpdir):
+
+        with set_temp_config(tmpdir.strpath):
+
+            with open(tmpdir.join('astropy').join('astropy.cfg').strpath, 'w') as f:
+                f.write('[io.votable]\npedantic = True')
+
+            reload_config('astropy.io.votable')
+
+            with pytest.raises(VOWarning):
+                parse(get_pkg_data_filename('data/gemini.xml'))
diff --git a/astropy/io/votable/tests/tree_test.py b/astropy/io/votable/tests/tree_test.py
index 7b7dda6..449cd9f 100644
--- a/astropy/io/votable/tests/tree_test.py
+++ b/astropy/io/votable/tests/tree_test.py
@@ -7,14 +7,14 @@ from astropy.tests.helper import raises
 
 @raises(exceptions.W07)
 def test_check_astroyear_fail():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     field = tree.Field(None, name='astroyear')
     tree.check_astroyear('X2100', field, config)
 
 
 @raises(exceptions.W08)
 def test_string_fail():
-    config = {'pedantic': True}
+    config = {'verify': 'exception'}
     tree.check_string(42, 'foo', config)
 
 
diff --git a/astropy/io/votable/tests/vo_test.py b/astropy/io/votable/tests/vo_test.py
index 3ca281b..6399c68 100644
--- a/astropy/io/votable/tests/vo_test.py
+++ b/astropy/io/votable/tests/vo_test.py
@@ -48,18 +48,14 @@ def assert_validate_schema(filename, version):
 
 
 def test_parse_single_table():
-    table = parse_single_table(
-        get_pkg_data_filename('data/regression.xml'),
-        pedantic=False)
+    table = parse_single_table(get_pkg_data_filename('data/regression.xml'))
     assert isinstance(table, tree.Table)
     assert len(table.array) == 5
 
 
 def test_parse_single_table2():
-    table2 = parse_single_table(
-        get_pkg_data_filename('data/regression.xml'),
-        table_number=1,
-        pedantic=False)
+    table2 = parse_single_table(get_pkg_data_filename('data/regression.xml'),
+                                table_number=1)
     assert isinstance(table2, tree.Table)
     assert len(table2.array) == 1
     assert len(table2.array.dtype.names) == 28
@@ -67,17 +63,14 @@ def test_parse_single_table2():
 
 @raises(IndexError)
 def test_parse_single_table3():
-    parse_single_table(
-        get_pkg_data_filename('data/regression.xml'),
-        table_number=3, pedantic=False)
+    parse_single_table(get_pkg_data_filename('data/regression.xml'),
+                       table_number=3)
 
 
 def _test_regression(tmpdir, _python_based=False, binary_mode=1):
     # Read the VOTABLE
-    votable = parse(
-        get_pkg_data_filename('data/regression.xml'),
-        pedantic=False,
-        _debug_python_based_parser=_python_based)
+    votable = parse(get_pkg_data_filename('data/regression.xml'),
+                    _debug_python_based_parser=_python_based)
     table = votable.get_first_table()
 
     dtypes = [
@@ -139,8 +132,7 @@ def _test_regression(tmpdir, _python_based=False, binary_mode=1):
                            votable.version)
     # Also try passing a file handle
     with open(str(tmpdir.join("regression.binary.xml")), "rb") as fd:
-        votable2 = parse(fd, pedantic=False,
-                         _debug_python_based_parser=_python_based)
+        votable2 = parse(fd, _debug_python_based_parser=_python_based)
     votable2.get_first_table().format = 'tabledata'
     votable2.to_xml(str(tmpdir.join("regression.bin.tabledata.xml")),
                     _astropy_version="testing",
@@ -196,9 +188,7 @@ def test_regression_binary2(tmpdir):
 
 class TestFixups:
     def setup_class(self):
-        self.table = parse(
-            get_pkg_data_filename('data/regression.xml'),
-            pedantic=False).get_first_table()
+        self.table = parse(get_pkg_data_filename('data/regression.xml')).get_first_table()
         self.array = self.table.array
         self.mask = self.table.array.mask
 
@@ -209,9 +199,7 @@ class TestFixups:
 
 class TestReferences:
     def setup_class(self):
-        self.votable = parse(
-            get_pkg_data_filename('data/regression.xml'),
-            pedantic=False)
+        self.votable = parse(get_pkg_data_filename('data/regression.xml'))
         self.table = self.votable.get_first_table()
         self.array = self.table.array
         self.mask = self.table.array.mask
@@ -251,8 +239,7 @@ class TestReferences:
 def test_select_columns_by_index():
     columns = [0, 5, 13]
     table = parse(
-        get_pkg_data_filename('data/regression.xml'),
-        pedantic=False, columns=columns).get_first_table()
+        get_pkg_data_filename('data/regression.xml'), columns=columns).get_first_table()
     array = table.array
     mask = table.array.mask
     assert array['string_test'][0] == b"String & test"
@@ -265,8 +252,7 @@ def test_select_columns_by_index():
 def test_select_columns_by_name():
     columns = ['string_test', 'unsignedByte', 'bitarray']
     table = parse(
-        get_pkg_data_filename('data/regression.xml'),
-        pedantic=False, columns=columns).get_first_table()
+        get_pkg_data_filename('data/regression.xml'), columns=columns).get_first_table()
     array = table.array
     mask = table.array.mask
     assert array['string_test'][0] == b"String & test"
@@ -277,9 +263,7 @@ def test_select_columns_by_name():
 
 class TestParse:
     def setup_class(self):
-        self.votable = parse(
-            get_pkg_data_filename('data/regression.xml'),
-            pedantic=False)
+        self.votable = parse(get_pkg_data_filename('data/regression.xml'))
         self.table = self.votable.get_first_table()
         self.array = self.table.array
         self.mask = self.table.array.mask
@@ -609,14 +593,12 @@ class TestParse:
 
 class TestThroughTableData(TestParse):
     def setup_class(self):
-        votable = parse(
-            get_pkg_data_filename('data/regression.xml'),
-            pedantic=False)
+        votable = parse(get_pkg_data_filename('data/regression.xml'))
 
         self.xmlout = bio = io.BytesIO()
         votable.to_xml(bio)
         bio.seek(0)
-        self.votable = parse(bio, pedantic=False)
+        self.votable = parse(bio)
         self.table = self.votable.get_first_table()
         self.array = self.table.array
         self.mask = self.table.array.mask
@@ -642,15 +624,13 @@ class TestThroughTableData(TestParse):
 
 class TestThroughBinary(TestParse):
     def setup_class(self):
-        votable = parse(
-            get_pkg_data_filename('data/regression.xml'),
-            pedantic=False)
+        votable = parse(get_pkg_data_filename('data/regression.xml'))
         votable.get_first_table().format = 'binary'
 
         self.xmlout = bio = io.BytesIO()
         votable.to_xml(bio)
         bio.seek(0)
-        self.votable = parse(bio, pedantic=False)
+        self.votable = parse(bio)
 
         self.table = self.votable.get_first_table()
         self.array = self.table.array
@@ -671,9 +651,7 @@ class TestThroughBinary(TestParse):
 
 class TestThroughBinary2(TestParse):
     def setup_class(self):
-        votable = parse(
-            get_pkg_data_filename('data/regression.xml'),
-            pedantic=False)
+        votable = parse(get_pkg_data_filename('data/regression.xml'))
         votable.version = '1.3'
         votable.get_first_table()._config['version_1_3_or_later'] = True
         votable.get_first_table().format = 'binary2'
@@ -681,7 +659,7 @@ class TestThroughBinary2(TestParse):
         self.xmlout = bio = io.BytesIO()
         votable.to_xml(bio)
         bio.seek(0)
-        self.votable = parse(bio, pedantic=False)
+        self.votable = parse(bio)
 
         self.table = self.votable.get_first_table()
         self.array = self.table.array
@@ -729,14 +707,12 @@ def test_open_files():
     for filename in get_pkg_data_filenames('data', pattern='*.xml'):
         if filename.endswith('custom_datatype.xml'):
             continue
-        parse(filename, pedantic=False)
+        parse(filename)
 
 
 @raises(VOTableSpecError)
 def test_too_many_columns():
-    parse(
-        get_pkg_data_filename('data/too_many_columns.xml.gz'),
-        pedantic=False)
+    parse(get_pkg_data_filename('data/too_many_columns.xml.gz'))
 
 
 def test_build_from_scratch(tmpdir):
@@ -837,9 +813,7 @@ def test_validate_path_object():
 
 
 def test_gzip_filehandles(tmpdir):
-    votable = parse(
-        get_pkg_data_filename('data/regression.xml'),
-        pedantic=False)
+    votable = parse(get_pkg_data_filename('data/regression.xml'))
 
     with open(str(tmpdir.join("regression.compressed.xml")), 'wb') as fd:
         votable.to_xml(
@@ -848,9 +822,7 @@ def test_gzip_filehandles(tmpdir):
             _astropy_version="testing")
 
     with open(str(tmpdir.join("regression.compressed.xml")), 'rb') as fd:
-        votable = parse(
-            fd,
-            pedantic=False)
+        votable = parse(fd)
 
 
 def test_from_scratch_example():
@@ -908,17 +880,13 @@ def test_fileobj():
 def test_nonstandard_units():
     from astropy import units as u
 
-    votable = parse(
-        get_pkg_data_filename('data/nonstandard_units.xml'),
-        pedantic=False)
+    votable = parse(get_pkg_data_filename('data/nonstandard_units.xml'))
 
     assert isinstance(
         votable.get_first_table().fields[0].unit, u.UnrecognizedUnit)
 
-    votable = parse(
-        get_pkg_data_filename('data/nonstandard_units.xml'),
-        pedantic=False,
-        unit_format='generic')
+    votable = parse(get_pkg_data_filename('data/nonstandard_units.xml'),
+                    unit_format='generic')
 
     assert not isinstance(
         votable.get_first_table().fields[0].unit, u.UnrecognizedUnit)
@@ -1010,11 +978,8 @@ def test_instantiate_vowarning():
 
 
 def test_custom_datatype():
-    votable = parse(
-        get_pkg_data_filename('data/custom_datatype.xml'),
-        pedantic=False,
-        datatype_mapping={'bar': 'int'}
-    )
+    votable = parse(get_pkg_data_filename('data/custom_datatype.xml'),
+                    datatype_mapping={'bar': 'int'})
 
     table = votable.get_first_table()
     assert table.array.dtype['foo'] == np.int32
diff --git a/astropy/io/votable/tree.py b/astropy/io/votable/tree.py
index 304e06f..ae2248c 100644
--- a/astropy/io/votable/tree.py
+++ b/astropy/io/votable/tree.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-8715/astropy/io/votable/tree.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 # TODO: Test FITS parsing
 
@@ -268,11 +461,13 @@ def check_ucd(ucd, config=None, pos=None):
                 has_colon=config.get('version_1_2_or_later', False))
         except ValueError as e:
             # This weird construction is for Python 3 compatibility
-            if config.get('pedantic'):
+            if config.get('verify', 'ignore') == 'exception':
                 vo_raise(W06, (ucd, str(e)), config, pos)
-            else:
+            elif config.get('verify', 'ignore') == 'warn':
                 vo_warn(W06, (ucd, str(e)), config, pos)
                 return False
+            else:
+                return False
     return True
 
 
@@ -1144,6 +1339,7 @@ class Field(SimpleElement, _IDProperty, _NameProperty, _XtypeProperty,
     _attr_list_12 = _attr_list_11 + ['xtype']
     _element_name = 'FIELD'
 
+    @inspect_code
     def __init__(self, votable, ID=None, name=None, datatype=None,
                  arraysize=None, ucd=None, unit=None, width=None,
                  precision=None, utype=None, ref=None, type=None, id=None,
@@ -1170,7 +1366,7 @@ class Field(SimpleElement, _IDProperty, _NameProperty, _XtypeProperty,
         # actually contains character data.  We have to hack the field
         # to store character data, or we can't read it in.  A warning
         # will be raised when this happens.
-        if (not config.get('pedantic') and name == 'cprojection' and
+        if (config.get('verify', 'ignore') != 'exception' and name == 'cprojection' and
             ID == 'cprojection' and ucd == 'VOX:WCS_CoordProjection' and
             datatype == 'double'):
             datatype = 'char'
diff --git a/astropy/io/votable/validator/result.py b/astropy/io/votable/validator/result.py
index 6ea167b..b23e81a 100644
--- a/astropy/io/votable/validator/result.py
+++ b/astropy/io/votable/validator/result.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-8715/astropy/io/votable/validator/result.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 """
 Contains a class to handle a validation result for a single VOTable
@@ -143,6 +336,7 @@ class Result:
             content = fd.read()
         return content
 
+    @inspect_code
     def validate_vo(self):
         path = self.get_vo_xml_path()
         if not os.path.exists(path):
@@ -163,7 +357,7 @@ class Result:
         with open(path, 'rb') as input:
             with warnings.catch_warnings(record=True) as warning_lines:
                 try:
-                    t = table.parse(input, pedantic=False, filename=path)
+                    t = table.parse(input, verify='warn', filename=path)
                 except (ValueError, TypeError, ExpatError) as e:
                     lines.append(str(e))
                     nexceptions += 1
