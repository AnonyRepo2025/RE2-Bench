diff --git a/astropy/wcs/tests/test_wcs.py b/astropy/wcs/tests/test_wcs.py
index 7cae4f8..49b432a 100644
--- a/astropy/wcs/tests/test_wcs.py
+++ b/astropy/wcs/tests/test_wcs.py
@@ -785,11 +785,16 @@ def test_validate_faulty_wcs():
 def test_error_message():
     header = get_pkg_data_contents("data/invalid_header.hdr", encoding="binary")
 
+    # make WCS transformation invalid
+    hdr = fits.Header.fromstring(header)
+    del hdr["PV?_*"]
+    hdr["PV1_1"] = 110
+    hdr["PV1_2"] = 110
+    hdr["PV2_1"] = -110
+    hdr["PV2_2"] = -110
     with pytest.raises(wcs.InvalidTransformError):
-        # Both lines are in here, because 0.4 calls .set within WCS.__init__,
-        # whereas 0.3 and earlier did not.
         with pytest.warns(wcs.FITSFixedWarning):
-            w = wcs.WCS(header, _do_set=False)
+            w = wcs.WCS(hdr, _do_set=False)
             w.all_pix2world([[536.0, 894.0]], 0)
 
 
@@ -989,6 +994,106 @@ def test_sip_tpv_agreement():
         )
 
 
+def test_tpv_ctype_sip():
+    sip_header = fits.Header.fromstring(
+        get_pkg_data_contents(os.path.join("data", "siponly.hdr"), encoding="binary")
+    )
+    tpv_header = fits.Header.fromstring(
+        get_pkg_data_contents(os.path.join("data", "tpvonly.hdr"), encoding="binary")
+    )
+    sip_header.update(tpv_header)
+    sip_header["CTYPE1"] = "RA---TAN-SIP"
+    sip_header["CTYPE2"] = "DEC--TAN-SIP"
+
+    with pytest.warns(
+        wcs.FITSFixedWarning,
+        match="Removed redundant SCAMP distortion parameters "
+        "because SIP parameters are also present",
+    ):
+        w_sip = wcs.WCS(sip_header)
+
+    assert w_sip.sip is not None
+
+
+def test_tpv_ctype_tpv():
+    sip_header = fits.Header.fromstring(
+        get_pkg_data_contents(os.path.join("data", "siponly.hdr"), encoding="binary")
+    )
+    tpv_header = fits.Header.fromstring(
+        get_pkg_data_contents(os.path.join("data", "tpvonly.hdr"), encoding="binary")
+    )
+    sip_header.update(tpv_header)
+    sip_header["CTYPE1"] = "RA---TPV"
+    sip_header["CTYPE2"] = "DEC--TPV"
+
+    with pytest.warns(
+        wcs.FITSFixedWarning,
+        match="Removed redundant SIP distortion parameters "
+        "because CTYPE explicitly specifies TPV distortions",
+    ):
+        w_sip = wcs.WCS(sip_header)
+
+    assert w_sip.sip is None
+
+
+def test_tpv_ctype_tan():
+    sip_header = fits.Header.fromstring(
+        get_pkg_data_contents(os.path.join("data", "siponly.hdr"), encoding="binary")
+    )
+    tpv_header = fits.Header.fromstring(
+        get_pkg_data_contents(os.path.join("data", "tpvonly.hdr"), encoding="binary")
+    )
+    sip_header.update(tpv_header)
+    sip_header["CTYPE1"] = "RA---TAN"
+    sip_header["CTYPE2"] = "DEC--TAN"
+
+    with pytest.warns(
+        wcs.FITSFixedWarning,
+        match="Removed redundant SIP distortion parameters "
+        "because SCAMP' PV distortions are also present",
+    ):
+        w_sip = wcs.WCS(sip_header)
+
+    assert w_sip.sip is None
+
+
+def test_car_sip_with_pv():
+    # https://github.com/astropy/astropy/issues/14255
+    header_dict = {
+        "SIMPLE": True,
+        "BITPIX": -32,
+        "NAXIS": 2,
+        "NAXIS1": 1024,
+        "NAXIS2": 1024,
+        "CRPIX1": 512.0,
+        "CRPIX2": 512.0,
+        "CDELT1": 0.01,
+        "CDELT2": 0.01,
+        "CRVAL1": 120.0,
+        "CRVAL2": 29.0,
+        "CTYPE1": "RA---CAR-SIP",
+        "CTYPE2": "DEC--CAR-SIP",
+        "PV1_1": 120.0,
+        "PV1_2": 29.0,
+        "PV1_0": 1.0,
+        "A_ORDER": 2,
+        "A_2_0": 5.0e-4,
+        "B_ORDER": 2,
+        "B_2_0": 5.0e-4,
+    }
+
+    w = wcs.WCS(header_dict)
+
+    assert w.sip is not None
+
+    assert w.wcs.get_pv() == [(1, 1, 120.0), (1, 2, 29.0), (1, 0, 1.0)]
+
+    assert np.allclose(
+        w.all_pix2world(header_dict["CRPIX1"], header_dict["CRPIX2"], 1),
+        [header_dict["CRVAL1"], header_dict["CRVAL2"]],
+    )
+
+
 @pytest.mark.skipif(
     _wcs.__version__[0] < "5", reason="TPV only works with wcslib 5.x or later"
 )
diff --git a/astropy/wcs/wcs.py b/astropy/wcs/wcs.py
index ae7de02..940aa46 100644
--- a/astropy/wcs/wcs.py
+++ b/astropy/wcs/wcs.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-14295/astropy/wcs/wcs.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 
 # Under the hood, there are 3 separate classes that perform different
@@ -419,6 +612,7 @@ class WCS(FITSWCSAPIMixin, WCSBase):
 
     """
 
+    @inspect_code
     def __init__(
         self,
         header=None,
@@ -534,6 +728,8 @@ class WCS(FITSWCSAPIMixin, WCSBase):
 
             det2im = self._read_det2im_kw(header, fobj, err=minerr)
             cpdis = self._read_distortion_kw(header, fobj, dist="CPDIS", err=minerr)
+            self._fix_pre2012_scamp_tpv(header)
+
             sip = self._read_sip_kw(header, wcskey=key)
             self._remove_sip_kw(header)
 
@@ -714,12 +910,28 @@ reduce these to 2 dimensions using the naxis kwarg.
         SIP distortion parameters.
 
         See https://github.com/astropy/astropy/issues/299.
+
+        SCAMP uses TAN projection exclusively. The case of CTYPE ending
+        in -TAN should have been handled by ``_fix_pre2012_scamp_tpv()`` before
+        calling this function.
         """
-        # Nothing to be done if no WCS attached
         if self.wcs is None:
             return
 
-        # Nothing to be done if no PV parameters attached
+        # Delete SIP if CTYPE explicitly has '-TPV' code:
+        ctype = [ct.strip().upper() for ct in self.wcs.ctype]
+        if sum(ct.endswith("-TPV") for ct in ctype) == 2:
+            if self.sip is not None:
+                self.sip = None
+                warnings.warn(
+                    "Removed redundant SIP distortion parameters "
+                    + "because CTYPE explicitly specifies TPV distortions",
+                    FITSFixedWarning,
+                )
+            return
+
+        # Nothing to be done if no PV parameters attached since SCAMP
+        # encodes distortion coefficients using PV keywords
         pv = self.wcs.get_pv()
         if not pv:
             return
@@ -728,28 +940,28 @@ reduce these to 2 dimensions using the naxis kwarg.
         if self.sip is None:
             return
 
-        # Nothing to be done if any radial terms are present...
-        # Loop over list to find any radial terms.
-        # Certain values of the `j' index are used for storing
-        # radial terms; refer to Equation (1) in
-        # <http://web.ipac.caltech.edu/staff/shupe/reprints/SIP_to_PV_SPIE2012.pdf>.
-        pv = np.asarray(pv)
         # Loop over distinct values of `i' index
-        for i in set(pv[:, 0]):
+        has_scamp = False
+        for i in {v[0] for v in pv}:
             # Get all values of `j' index for this value of `i' index
-            js = set(pv[:, 1][pv[:, 0] == i])
-            # Find max value of `j' index
-            max_j = max(js)
-            for j in (3, 11, 23, 39):
-                if j < max_j and j in js:
-                    return
-
-        self.wcs.set_pv([])
-        warnings.warn(
-            "Removed redundant SCAMP distortion parameters "
-            + "because SIP parameters are also present",
-            FITSFixedWarning,
-        )
+            js = tuple(v[1] for v in pv if v[0] == i)
+            if "-TAN" in self.wcs.ctype[i - 1].upper() and js and max(js) >= 5:
+                # TAN projection *may* use PVi_j with j up to 4 - see
+                # Sections 2.5, 2.6, and Table 13
+                # in https://doi.org/10.1051/0004-6361:20021327
+                has_scamp = True
+                break
+
+        if has_scamp and all(ct.endswith("-SIP") for ct in ctype):
+            # Prefer SIP - see recommendations in Section 7 in
+            # http://web.ipac.caltech.edu/staff/shupe/reprints/SIP_to_PV_SPIE2012.pdf
+            self.wcs.set_pv([])
+            warnings.warn(
+                "Removed redundant SCAMP distortion parameters "
+                + "because SIP parameters are also present",
+                FITSFixedWarning,
+            )
+            return
 
     def fix(self, translate_units="", naxis=None):
         """
@@ -1175,7 +1387,66 @@ reduce these to 2 dimensions using the naxis kwarg.
         write_dist(1, self.cpdis1)
         write_dist(2, self.cpdis2)
 
-    def _remove_sip_kw(self, header):
+    @inspect_code
+    def _fix_pre2012_scamp_tpv(self, header, wcskey=""):
+        """
+        Replace -TAN with TPV (for pre-2012 SCAMP headers that use -TAN
+        in CTYPE). Ignore SIP if present. This follows recommendations in
+        Section 7 in
+        http://web.ipac.caltech.edu/staff/shupe/reprints/SIP_to_PV_SPIE2012.pdf.
+
+        This is to deal with pre-2012 headers that may contain TPV with a
+        CTYPE that ends in '-TAN' (post-2012 they should end in '-TPV' when
+        SCAMP has adopted the new TPV convention).
+        """
+        if isinstance(header, (str, bytes)):
+            return
+
+        wcskey = wcskey.strip().upper()
+        cntype = [
+            (nax, header.get(f"CTYPE{nax}{wcskey}", "").strip())
+            for nax in range(1, self.naxis + 1)
+        ]
+
+        tan_axes = [ct[0] for ct in cntype if ct[1].endswith("-TAN")]
+
+        if len(tan_axes) == 2:
+            # check if PVi_j with j >= 5 is present and if so, do not load SIP
+            tan_to_tpv = False
+            for nax in tan_axes:
+                js = []
+                for p in header[f"PV{nax}_*{wcskey}"].keys():
+                    prefix = f"PV{nax}_"
+                    if p.startswith(prefix):
+                        p = p[len(prefix) :]
+                        p = p.rstrip(wcskey)
+                        try:
+                            p = int(p)
+                        except ValueError:
+                            continue
+                        js.append(p)
+
+                if js and max(js) >= 5:
+                    tan_to_tpv = True
+                    break
+
+            if tan_to_tpv:
+                warnings.warn(
+                    "Removed redundant SIP distortion parameters "
+                    + "because SCAMP' PV distortions are also present",
+                    FITSFixedWarning,
+                )
+                self._remove_sip_kw(header, del_order=True)
+                for i in tan_axes:
+                    kwd = f"CTYPE{i:d}{wcskey}"
+                    if kwd in header:
+                        header[kwd] = (
+                            header[kwd].strip().upper().replace("-TAN", "-TPV")
+                        )
+
+    @staticmethod
+    @inspect_code
+    def _remove_sip_kw(header, del_order=False):
         """
         Remove SIP information from a header.
         """
@@ -1186,6 +1457,11 @@ reduce these to 2 dimensions using the naxis kwarg.
         }:
             del header[key]
 
+        if del_order:
+            for kwd in ["A_ORDER", "B_ORDER", "AP_ORDER", "BP_ORDER"]:
+                if kwd in header:
+                    del header[kwd]
+
     def _read_sip_kw(self, header, wcskey=""):
         """
         Reads `SIP`_ header keywords and returns a `~astropy.wcs.Sip`
