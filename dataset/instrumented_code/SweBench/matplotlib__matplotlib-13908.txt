diff --git a/lib/matplotlib/axis.py b/lib/matplotlib/axis.py
index 3569187..95e84ae 100644
--- a/lib/matplotlib/axis.py
+++ b/lib/matplotlib/axis.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/matplotlib__matplotlib-13908/lib/matplotlib/axis.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 """
 Classes for the ticks and x and y axis.
 """
@@ -712,6 +905,7 @@ class Axis(martist.Artist):
         return self.__class__.__name__ \
             + "(%f,%f)" % tuple(self.axes.transAxes.transform_point((0, 0)))
 
+    @inspect_code
     def __init__(self, axes, pickradius=15):
         """
         Parameters
@@ -723,6 +917,8 @@ class Axis(martist.Artist):
             `.Axis.contains`.
         """
         martist.Artist.__init__(self)
+        self._remove_overlapping_locs = True
+
         self.set_figure(axes.figure)
 
         self.isDefault_label = True
@@ -754,6 +950,18 @@ class Axis(martist.Artist):
     majorTicks = _LazyTickList(major=True)
     minorTicks = _LazyTickList(major=False)
 
+    @inspect_code
+    def get_remove_overlapping_locs(self):
+        return self._remove_overlapping_locs
+
+    def set_remove_overlapping_locs(self, val):
+        self._remove_overlapping_locs = bool(val)
+
+    remove_overlapping_locs = property(
+        get_remove_overlapping_locs, set_remove_overlapping_locs,
+        doc=('If minor ticker locations that overlap with major '
+             'ticker locations should be trimmed.'))
+
     def set_label_coords(self, x, y, transform=None):
         """
         Set the coordinates of the label.
@@ -1064,23 +1272,29 @@ class Axis(martist.Artist):
         Update ticks (position and labels) using the current data interval of
         the axes.  Return the list of ticks that will be drawn.
         """
-
-        major_locs = self.major.locator()
-        major_ticks = self.get_major_ticks(len(major_locs))
+        major_locs = self.get_majorticklocs()
         major_labels = self.major.formatter.format_ticks(major_locs)
+        major_ticks = self.get_major_ticks(len(major_locs))
+        self.major.formatter.set_locs(major_locs)
         for tick, loc, label in zip(major_ticks, major_locs, major_labels):
             tick.update_position(loc)
             tick.set_label1(label)
             tick.set_label2(label)
-        minor_locs = self.minor.locator()
-        minor_ticks = self.get_minor_ticks(len(minor_locs))
+        minor_locs = self.get_minorticklocs()
         minor_labels = self.minor.formatter.format_ticks(minor_locs)
+        minor_ticks = self.get_minor_ticks(len(minor_locs))
+        self.minor.formatter.set_locs(minor_locs)
         for tick, loc, label in zip(minor_ticks, minor_locs, minor_labels):
             tick.update_position(loc)
             tick.set_label1(label)
             tick.set_label2(label)
         ticks = [*major_ticks, *minor_ticks]
 
+        # mark the ticks that we will not be using as not visible
+        for t in (self.minorTicks[len(minor_locs):] +
+                  self.majorTicks[len(major_locs):]):
+            t.set_visible(False)
+
         view_low, view_high = self.get_view_interval()
         if view_low > view_high:
             view_low, view_high = view_high, view_low
@@ -1310,6 +1524,7 @@ class Axis(martist.Artist):
         """Get the array of major tick locations in data coordinates."""
         return self.major.locator()
 
+    @inspect_code
     def get_minorticklocs(self):
         """Get the array of minor tick locations in data coordinates."""
         # Remove minor ticks duplicating major ticks.
@@ -1322,9 +1537,10 @@ class Axis(martist.Artist):
         # Use the transformed view limits as scale.  1e-5 is the default rtol
         # for np.isclose.
         tol = (hi - lo) * 1e-5
-        minor_locs = [
-            loc for loc, tr_loc in zip(minor_locs, tr_minor_locs)
-            if not np.isclose(tr_loc, tr_major_locs, atol=tol, rtol=0).any()]
+        if self.remove_overlapping_locs:
+            minor_locs = [
+                loc for loc, tr_loc in zip(minor_locs, tr_minor_locs)
+                if ~np.isclose(tr_loc, tr_major_locs, atol=tol, rtol=0).any()]
         return minor_locs
 
     def get_ticklocs(self, minor=False):
@@ -1387,10 +1603,11 @@ class Axis(martist.Artist):
         'Get the formatter of the minor ticker'
         return self.minor.formatter
 
+    @inspect_code
     def get_major_ticks(self, numticks=None):
         'Get the tick instances; grow as necessary.'
         if numticks is None:
-            numticks = len(self.get_major_locator()())
+            numticks = len(self.get_majorticklocs())
 
         while len(self.majorTicks) < numticks:
             # Update the new tick label properties from the old.
@@ -1401,10 +1618,11 @@ class Axis(martist.Artist):
 
         return self.majorTicks[:numticks]
 
+    @inspect_code
     def get_minor_ticks(self, numticks=None):
         'Get the minor tick instances; grow as necessary.'
         if numticks is None:
-            numticks = len(self.get_minor_locator()())
+            numticks = len(self.get_minorticklocs())
 
         while len(self.minorTicks) < numticks:
             # Update the new tick label properties from the old.
diff --git a/lib/matplotlib/tests/test_ticker.py b/lib/matplotlib/tests/test_ticker.py
index b35a7fd..8c52fc9 100644
--- a/lib/matplotlib/tests/test_ticker.py
+++ b/lib/matplotlib/tests/test_ticker.py
@@ -923,3 +923,49 @@ def test_minorticks_rc():
     minorticksubplot(True, False, 2)
     minorticksubplot(False, True, 3)
     minorticksubplot(True, True, 4)
+
+
+@pytest.mark.parametrize('remove_overlapping_locs, expected_num',
+                         ((True, 6),
+                          (None, 6),  # this tests the default
+                          (False, 9)))
+def test_remove_overlap(remove_overlapping_locs, expected_num):
+    import numpy as np
+    import matplotlib.dates as mdates
+
+    t = np.arange("2018-11-03", "2018-11-06", dtype="datetime64")
+    x = np.ones(len(t))
+
+    fig, ax = plt.subplots()
+    ax.plot(t, x)
+
+    ax.xaxis.set_major_locator(mdates.DayLocator())
+    ax.xaxis.set_major_formatter(mdates.DateFormatter('\n%a'))
+
+    ax.xaxis.set_minor_locator(mdates.HourLocator((0, 6, 12, 18)))
+    ax.xaxis.set_minor_formatter(mdates.DateFormatter('%H:%M'))
+    # force there to be extra ticks
+    ax.xaxis.get_minor_ticks(15)
+    if remove_overlapping_locs is not None:
+        ax.xaxis.remove_overlapping_locs = remove_overlapping_locs
+
+    # check that getter/setter exists
+    current = ax.xaxis.remove_overlapping_locs
+    assert (current == ax.xaxis.get_remove_overlapping_locs())
+    plt.setp(ax.xaxis, remove_overlapping_locs=current)
+    new = ax.xaxis.remove_overlapping_locs
+    assert (new == ax.xaxis.remove_overlapping_locs)
+
+    # check that the accessors filter correctly
+    # this is the method that does the actual filtering
+    assert len(ax.xaxis.get_minorticklocs()) == expected_num
+    # these three are derivative
+    assert len(ax.xaxis.get_minor_ticks()) == expected_num
+    assert len(ax.xaxis.get_minorticklabels()) == expected_num
+    assert len(ax.xaxis.get_minorticklines()) == expected_num*2
+
+    # force a draw to call _update_ticks under the hood
+    fig.canvas.draw()
+    # check that the correct number of ticks report them selves as
+    # visible
+    assert sum(t.get_visible() for t in ax.xaxis.minorTicks) == expected_num
