diff --git a/django/utils/timesince.py b/django/utils/timesince.py
index 3a0d4af..adabee5 100644
--- a/django/utils/timesince.py
+++ b/django/utils/timesince.py
@@ -1,4 +1,196 @@
-import calendar
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/django__django-16027/django/utils/timesince.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 import datetime
 
 from django.utils.html import avoid_wrapping
@@ -14,16 +206,19 @@ TIME_STRINGS = {
     "minute": ngettext_lazy("%(num)d minute", "%(num)d minutes", "num"),
 }
 
-TIMESINCE_CHUNKS = (
-    (60 * 60 * 24 * 365, "year"),
-    (60 * 60 * 24 * 30, "month"),
-    (60 * 60 * 24 * 7, "week"),
-    (60 * 60 * 24, "day"),
-    (60 * 60, "hour"),
-    (60, "minute"),
-)
+TIME_STRINGS_KEYS = list(TIME_STRINGS.keys())
+
+TIME_CHUNKS = [
+    60 * 60 * 24 * 7,  # week
+    60 * 60 * 24,  # day
+    60 * 60,  # hour
+    60,  # minute
+]
 
+MONTHS_DAYS = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)
 
+
+@inspect_code
 def timesince(d, now=None, reversed=False, time_strings=None, depth=2):
     """
     Take two datetime objects and return the time between d and now as a nicely
@@ -31,9 +226,16 @@ def timesince(d, now=None, reversed=False, time_strings=None, depth=2):
     "0 minutes".
 
     Units used are years, months, weeks, days, hours, and minutes.
-    Seconds and microseconds are ignored. Up to `depth` adjacent units will be
-    displayed.  For example, "2 weeks, 3 days" and "1 year, 3 months" are
-    possible outputs, but "2 weeks, 3 hours" and "1 year, 5 days" are not.
+    Seconds and microseconds are ignored.
+
+    The algorithm takes into account the varying duration of years and months.
+    There is exactly "1 year, 1 month" between 2013/02/10 and 2014/03/10,
+    but also between 2007/08/10 and 2008/09/10 despite the delta being 393 days
+    in the former case and 397 in the latter.
+
+    Up to `depth` adjacent units will be displayed.  For example,
+    "2 weeks, 3 days" and "1 year, 3 months" are possible outputs, but
+    "2 weeks, 3 hours" and "1 year, 5 days" are not.
 
     `time_strings` is an optional dict of strings to replace the default
     TIME_STRINGS dict.
@@ -41,8 +243,9 @@ def timesince(d, now=None, reversed=False, time_strings=None, depth=2):
     `depth` is an optional integer to control the number of adjacent time
     units returned.
 
-    Adapted from
+    Originally adapted from
     https://web.archive.org/web/20060617175230/http://blog.natbat.co.uk/archive/2003/Jun/14/time_since
+    Modified to improve results for years and months.
     """
     if time_strings is None:
         time_strings = TIME_STRINGS
@@ -60,37 +263,64 @@ def timesince(d, now=None, reversed=False, time_strings=None, depth=2):
         d, now = now, d
     delta = now - d
 
-    # Deal with leapyears by subtracing the number of leapdays
-    leapdays = calendar.leapdays(d.year, now.year)
-    if leapdays != 0:
-        if calendar.isleap(d.year):
-            leapdays -= 1
-        elif calendar.isleap(now.year):
-            leapdays += 1
-    delta -= datetime.timedelta(leapdays)
-
-    # ignore microseconds
+    # Ignore microseconds.
     since = delta.days * 24 * 60 * 60 + delta.seconds
     if since <= 0:
         # d is in the future compared to now, stop processing.
         return avoid_wrapping(time_strings["minute"] % {"num": 0})
-    for i, (seconds, name) in enumerate(TIMESINCE_CHUNKS):
-        count = since // seconds
-        if count != 0:
+
+    # Get years and months.
+    total_months = (now.year - d.year) * 12 + (now.month - d.month)
+    if d.day > now.day or (d.day == now.day and d.time() > now.time()):
+        total_months -= 1
+    years, months = divmod(total_months, 12)
+
+    # Calculate the remaining time.
+    # Create a "pivot" datetime shifted from d by years and months, then use
+    # that to determine the other parts.
+    if years or months:
+        pivot_year = d.year + years
+        pivot_month = d.month + months
+        if pivot_month > 12:
+            pivot_month -= 12
+            pivot_year += 1
+        pivot = datetime.datetime(
+            pivot_year,
+            pivot_month,
+            min(MONTHS_DAYS[pivot_month - 1], d.day),
+            d.hour,
+            d.minute,
+            d.second,
+        )
+    else:
+        pivot = d
+    remaining_time = (now - pivot).total_seconds()
+    partials = [years, months]
+    for chunk in TIME_CHUNKS:
+        count = remaining_time // chunk
+        partials.append(count)
+        remaining_time -= chunk * count
+
+    # Find the first non-zero part (if any) and then build the result, until
+    # depth.
+    i = 0
+    for i, value in enumerate(partials):
+        if value != 0:
             break
     else:
         return avoid_wrapping(time_strings["minute"] % {"num": 0})
+
     result = []
     current_depth = 0
-    while i < len(TIMESINCE_CHUNKS) and current_depth < depth:
-        seconds, name = TIMESINCE_CHUNKS[i]
-        count = since // seconds
-        if count == 0:
+    while i < len(TIME_STRINGS_KEYS) and current_depth < depth:
+        value = partials[i]
+        if value == 0:
             break
-        result.append(avoid_wrapping(time_strings[name] % {"num": count}))
-        since -= seconds * count
+        name = TIME_STRINGS_KEYS[i]
+        result.append(avoid_wrapping(time_strings[name] % {"num": value}))
         current_depth += 1
         i += 1
+
     return gettext(", ").join(result)
 
 
diff --git a/tests/humanize_tests/tests.py b/tests/humanize_tests/tests.py
index 432314f..cf29f58 100644
--- a/tests/humanize_tests/tests.py
+++ b/tests/humanize_tests/tests.py
@@ -506,8 +506,8 @@ class HumanizeTests(SimpleTestCase):
             # "%(delta)s from now" translations
             now + datetime.timedelta(days=1),
             now + datetime.timedelta(days=2),
-            now + datetime.timedelta(days=30),
-            now + datetime.timedelta(days=60),
+            now + datetime.timedelta(days=31),
+            now + datetime.timedelta(days=61),
             now + datetime.timedelta(days=500),
             now + datetime.timedelta(days=865),
         ]
diff --git a/tests/template_tests/filter_tests/test_timesince.py b/tests/template_tests/filter_tests/test_timesince.py
index 10e4e51..d623449 100644
--- a/tests/template_tests/filter_tests/test_timesince.py
+++ b/tests/template_tests/filter_tests/test_timesince.py
@@ -147,6 +147,23 @@ class TimesinceTests(TimezoneTestCase):
         )
         self.assertEqual(output, "1\xa0day")
 
+    # Tests for #33879 (wrong results for 11 months + several weeks).
+    @setup({"timesince19": "{{ earlier|timesince }}"})
+    def test_timesince19(self):
+        output = self.engine.render_to_string(
+            "timesince19", {"earlier": self.today - timedelta(days=358)}
+        )
+        self.assertEqual(output, "11\xa0months, 3\xa0weeks")
+
+    @setup({"timesince20": "{{ a|timesince:b }}"})
+    def test_timesince20(self):
+        now = datetime(2018, 5, 9)
+        output = self.engine.render_to_string(
+            "timesince20",
+            {"a": now, "b": now + timedelta(days=365) + timedelta(days=364)},
+        )
+        self.assertEqual(output, "1\xa0year, 11\xa0months")
+
 
 class FunctionTests(SimpleTestCase):
     def test_since_now(self):
diff --git a/tests/utils_tests/test_timesince.py b/tests/utils_tests/test_timesince.py
index 4ab8e49..bf05f32 100644
--- a/tests/utils_tests/test_timesince.py
+++ b/tests/utils_tests/test_timesince.py
@@ -16,8 +16,8 @@ class TimesinceTests(TestCase):
         self.onehour = datetime.timedelta(hours=1)
         self.oneday = datetime.timedelta(days=1)
         self.oneweek = datetime.timedelta(days=7)
-        self.onemonth = datetime.timedelta(days=30)
-        self.oneyear = datetime.timedelta(days=365)
+        self.onemonth = datetime.timedelta(days=31)
+        self.oneyear = datetime.timedelta(days=366)
 
     def test_equal_datetimes(self):
         """equal datetimes."""
@@ -205,6 +205,37 @@ class TimesinceTests(TestCase):
                 self.assertEqual(timesince(self.t, value, depth=depth), expected)
                 self.assertEqual(timeuntil(value, self.t, depth=depth), expected)
 
+    def test_months_edge(self):
+        t = datetime.datetime(2022, 1, 1)
+        tests = [
+            (datetime.datetime(2022, 1, 31), "4\xa0weeks, 2\xa0days"),
+            (datetime.datetime(2022, 2, 1), "1\xa0month"),
+            (datetime.datetime(2022, 2, 28), "1\xa0month, 3\xa0weeks"),
+            (datetime.datetime(2022, 3, 1), "2\xa0months"),
+            (datetime.datetime(2022, 3, 31), "2\xa0months, 4\xa0weeks"),
+            (datetime.datetime(2022, 4, 1), "3\xa0months"),
+            (datetime.datetime(2022, 4, 30), "3\xa0months, 4\xa0weeks"),
+            (datetime.datetime(2022, 5, 1), "4\xa0months"),
+            (datetime.datetime(2022, 5, 31), "4\xa0months, 4\xa0weeks"),
+            (datetime.datetime(2022, 6, 1), "5\xa0months"),
+            (datetime.datetime(2022, 6, 30), "5\xa0months, 4\xa0weeks"),
+            (datetime.datetime(2022, 7, 1), "6\xa0months"),
+            (datetime.datetime(2022, 7, 31), "6\xa0months, 4\xa0weeks"),
+            (datetime.datetime(2022, 8, 1), "7\xa0months"),
+            (datetime.datetime(2022, 8, 31), "7\xa0months, 4\xa0weeks"),
+            (datetime.datetime(2022, 9, 1), "8\xa0months"),
+            (datetime.datetime(2022, 9, 30), "8\xa0months, 4\xa0weeks"),
+            (datetime.datetime(2022, 10, 1), "9\xa0months"),
+            (datetime.datetime(2022, 10, 31), "9\xa0months, 4\xa0weeks"),
+            (datetime.datetime(2022, 11, 1), "10\xa0months"),
+            (datetime.datetime(2022, 11, 30), "10\xa0months, 4\xa0weeks"),
+            (datetime.datetime(2022, 12, 1), "11\xa0months"),
+            (datetime.datetime(2022, 12, 31), "11\xa0months, 4\xa0weeks"),
+        ]
+        for value, expected in tests:
+            with self.subTest():
+                self.assertEqual(timesince(t, value), expected)
+
     def test_depth_invalid(self):
         msg = "depth must be greater than 0."
         with self.assertRaisesMessage(ValueError, msg):
