diff --git a/django/middleware/csrf.py b/django/middleware/csrf.py
index d103900..6a5bec1 100644
--- a/django/middleware/csrf.py
+++ b/django/middleware/csrf.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/django__django-14681/django/middleware/csrf.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 """
 Cross Site Request Forgery Middleware.
 
@@ -11,6 +204,7 @@ from urllib.parse import urlparse
 
 from django.conf import settings
 from django.core.exceptions import DisallowedHost, ImproperlyConfigured
+from django.http import UnreadablePostError
 from django.http.request import HttpHeaders
 from django.urls import get_callable
 from django.utils.cache import patch_vary_headers
@@ -322,6 +516,7 @@ class CsrfViewMiddleware(MiddlewareMixin):
             token_source = f'the {header_name!r} HTTP header'
         return f'CSRF token from {token_source} {reason}.'
 
+    @inspect_code
     def _check_token(self, request):
         # Access csrf_token via self._get_token() as rotate_token() may have
         # been called by an authentication middleware during the
@@ -342,7 +537,7 @@ class CsrfViewMiddleware(MiddlewareMixin):
         if request.method == 'POST':
             try:
                 request_csrf_token = request.POST.get('csrfmiddlewaretoken', '')
-            except OSError:
+            except UnreadablePostError:
                 # Handle a broken connection before we've completed reading the
                 # POST data. process_view shouldn't raise any exceptions, so
                 # we'll ignore and serve the user a 403 (assuming they're still
diff --git a/tests/csrf_tests/tests.py b/tests/csrf_tests/tests.py
index 2166250..6ec0c63 100644
--- a/tests/csrf_tests/tests.py
+++ b/tests/csrf_tests/tests.py
@@ -3,7 +3,7 @@ import re
 from django.conf import settings
 from django.contrib.sessions.backends.cache import SessionStore
 from django.core.exceptions import ImproperlyConfigured
-from django.http import HttpRequest, HttpResponse
+from django.http import HttpRequest, HttpResponse, UnreadablePostError
 from django.middleware.csrf import (
     CSRF_ALLOWED_CHARS, CSRF_SESSION_KEY, CSRF_TOKEN_LENGTH, REASON_BAD_ORIGIN,
     REASON_CSRF_TOKEN_MISSING, REASON_NO_CSRF_COOKIE, CsrfViewMiddleware,
@@ -99,6 +99,23 @@ class TestingHttpRequest(HttpRequest):
         return getattr(self, '_is_secure_override', False)
 
 
+class PostErrorRequest(TestingHttpRequest):
+    """
+    TestingHttpRequest that can raise errors when accessing POST data.
+    """
+    post_error = None
+
+    def _get_post(self):
+        if self.post_error is not None:
+            raise self.post_error
+        return self._post
+
+    def _set_post(self, post):
+        self._post = post
+
+    POST = property(_get_post, _set_post)
+
+
 class CsrfViewMiddlewareTestMixin:
     """
     Shared methods and tests for session-based and cookie-based tokens.
@@ -131,10 +148,12 @@ class CsrfViewMiddlewareTestMixin:
         secrets_set = [_unmask_cipher_token(cookie) for cookie in cookies_set]
         self.assertEqual(secrets_set, expected_secrets)
 
-    def _get_request(self, method=None, cookie=None):
+    def _get_request(self, method=None, cookie=None, request_class=None):
         if method is None:
             method = 'GET'
-        req = TestingHttpRequest()
+        if request_class is None:
+            request_class = TestingHttpRequest
+        req = request_class()
         req.method = method
         if cookie is not None:
             self._set_csrf_cookie(req, cookie)
@@ -142,7 +161,7 @@ class CsrfViewMiddlewareTestMixin:
 
     def _get_csrf_cookie_request(
         self, method=None, cookie=None, post_token=None, meta_token=None,
-        token_header=None,
+        token_header=None, request_class=None,
     ):
         """
         The method argument defaults to "GET". The cookie argument defaults to
@@ -156,7 +175,11 @@ class CsrfViewMiddlewareTestMixin:
             cookie = self._csrf_id_cookie
         if token_header is None:
             token_header = 'HTTP_X_CSRFTOKEN'
-        req = self._get_request(method=method, cookie=cookie)
+        req = self._get_request(
+            method=method,
+            cookie=cookie,
+            request_class=request_class,
+        )
         if post_token is not None:
             req.POST['csrfmiddlewaretoken'] = post_token
         if meta_token is not None:
@@ -165,15 +188,21 @@ class CsrfViewMiddlewareTestMixin:
 
     def _get_POST_csrf_cookie_request(
         self, cookie=None, post_token=None, meta_token=None, token_header=None,
+        request_class=None,
     ):
         return self._get_csrf_cookie_request(
             method='POST', cookie=cookie, post_token=post_token,
             meta_token=meta_token, token_header=token_header,
+            request_class=request_class,
         )
 
-    def _get_POST_request_with_token(self, cookie=None):
+    def _get_POST_request_with_token(self, cookie=None, request_class=None):
         """The cookie argument defaults to this class's default test cookie."""
-        return self._get_POST_csrf_cookie_request(cookie=cookie, post_token=self._csrf_id_token)
+        return self._get_POST_csrf_cookie_request(
+            cookie=cookie,
+            post_token=self._csrf_id_token,
+            request_class=request_class,
+        )
 
     def _check_token_present(self, response, csrf_id=None):
         text = str(response.content, response.charset)
@@ -699,52 +728,19 @@ class CsrfViewMiddlewareTestMixin:
             req = self._get_request()
             ensure_csrf_cookie_view(req)
 
-    def test_post_data_read_failure(self):
+    def test_reading_post_data_raises_unreadable_post_error(self):
         """
-        OSErrors during POST data reading are caught and treated as if the
-        POST data wasn't there (#20128).
+        An UnreadablePostError raised while reading the POST data should be
+        handled by the middleware.
         """
-        class CsrfPostRequest(HttpRequest):
-            """
-            HttpRequest that can raise an OSError when accessing POST data
-            """
-            def __init__(self, token, raise_error):
-                super().__init__()
-                self.method = 'POST'
-
-                self.raise_error = False
-                self.COOKIES[settings.CSRF_COOKIE_NAME] = token
-
-                # Handle both cases here to prevent duplicate code in the
-                # session tests.
-                self.session = {}
-                self.session[CSRF_SESSION_KEY] = token
-
-                self.POST['csrfmiddlewaretoken'] = token
-                self.raise_error = raise_error
-
-            def _load_post_and_files(self):
-                raise OSError('error reading input data')
-
-            def _get_post(self):
-                if self.raise_error:
-                    self._load_post_and_files()
-                return self._post
-
-            def _set_post(self, post):
-                self._post = post
-
-            POST = property(_get_post, _set_post)
-
-        token = ('ABC' + self._csrf_id_token)[:CSRF_TOKEN_LENGTH]
-
-        req = CsrfPostRequest(token, raise_error=False)
+        req = self._get_POST_request_with_token()
         mw = CsrfViewMiddleware(post_form_view)
         mw.process_request(req)
         resp = mw.process_view(req, post_form_view, (), {})
         self.assertIsNone(resp)
 
-        req = CsrfPostRequest(token, raise_error=True)
+        req = self._get_POST_request_with_token(request_class=PostErrorRequest)
+        req.post_error = UnreadablePostError('Error reading input data.')
         mw.process_request(req)
         with self.assertLogs('django.security.csrf', 'WARNING') as cm:
             resp = mw.process_view(req, post_form_view, (), {})
@@ -754,6 +750,18 @@ class CsrfViewMiddlewareTestMixin:
             'Forbidden (%s): ' % REASON_CSRF_TOKEN_MISSING,
         )
 
+    def test_reading_post_data_raises_os_error(self):
+        """
+        An OSError raised while reading the POST data should not be handled by
+        the middleware.
+        """
+        mw = CsrfViewMiddleware(post_form_view)
+        req = self._get_POST_request_with_token(request_class=PostErrorRequest)
+        req.post_error = OSError('Deleted directories/Missing permissions.')
+        mw.process_request(req)
+        with self.assertRaises(OSError):
+            mw.process_view(req, post_form_view, (), {})
+
     @override_settings(ALLOWED_HOSTS=['www.example.com'])
     def test_bad_origin_bad_domain(self):
         """A request with a bad origin is rejected."""
