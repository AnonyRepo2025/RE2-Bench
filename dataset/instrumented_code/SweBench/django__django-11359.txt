diff --git a/django/contrib/gis/db/models/functions.py b/django/contrib/gis/db/models/functions.py
index 8ab5de6..b864b55 100644
--- a/django/contrib/gis/db/models/functions.py
+++ b/django/contrib/gis/db/models/functions.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/django__django-11359/django/contrib/gis/db/models/functions.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 from decimal import Decimal
 
 from django.contrib.gis.db.models.fields import BaseSpatialField, GeometryField
@@ -100,11 +293,15 @@ class SQLiteDecimalToFloatMixin:
     By default, Decimal values are converted to str by the SQLite backend, which
     is not acceptable by the GIS functions expecting numeric values.
     """
+    @inspect_code
     def as_sqlite(self, compiler, connection, **extra_context):
-        for expr in self.get_source_expressions():
-            if hasattr(expr, 'value') and isinstance(expr.value, Decimal):
-                expr.value = float(expr.value)
-        return super().as_sql(compiler, connection, **extra_context)
+        copy = self.copy()
+        copy.set_source_expressions([
+            Value(float(expr.value)) if hasattr(expr, 'value') and isinstance(expr.value, Decimal)
+            else expr
+            for expr in copy.get_source_expressions()
+        ])
+        return copy.as_sql(compiler, connection, **extra_context)
 
 
 class OracleToleranceMixin:
diff --git a/django/contrib/postgres/fields/ranges.py b/django/contrib/postgres/fields/ranges.py
index c2f24eb..8b176a4 100644
--- a/django/contrib/postgres/fields/ranges.py
+++ b/django/contrib/postgres/fields/ranges.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/django__django-11359/django/contrib/postgres/fields/ranges.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 import datetime
 import json
 
@@ -170,11 +363,11 @@ class DateTimeRangeContains(PostgresOperatorLookup):
     lookup_name = 'contains'
     postgres_operator = RangeOperators.CONTAINS
 
+    @inspect_code
     def process_rhs(self, compiler, connection):
         # Transform rhs value for db lookup.
         if isinstance(self.rhs, datetime.date):
-            output_field = models.DateTimeField() if isinstance(self.rhs, datetime.datetime) else models.DateField()
-            value = models.Value(self.rhs, output_field=output_field)
+            value = models.Value(self.rhs)
             self.rhs = value.resolve_expression(compiler.query)
         return super().process_rhs(compiler, connection)
 
diff --git a/django/db/models/expressions.py b/django/db/models/expressions.py
index 8cceb7d..1930a09 100644
--- a/django/db/models/expressions.py
+++ b/django/db/models/expressions.py
@@ -1,7 +1,202 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/django__django-11359/django/db/models/expressions.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 import copy
 import datetime
+import functools
 import inspect
 from decimal import Decimal
+from uuid import UUID
 
 from django.core.exceptions import EmptyResultSet, FieldError
 from django.db import NotSupportedError, connection
@@ -53,15 +248,11 @@ class Combinable:
     BITRIGHTSHIFT = '>>'
     BITXOR = '#'
 
+    @inspect_code
     def _combine(self, other, connector, reversed):
         if not hasattr(other, 'resolve_expression'):
             # everything must be resolvable to an expression
-            output_field = (
-                fields.DurationField()
-                if isinstance(other, datetime.timedelta) else
-                None
-            )
-            other = Value(other, output_field=output_field)
+            other = Value(other)
 
         if reversed:
             return CombinedExpression(other, connector, self)
@@ -422,6 +613,25 @@ class Expression(BaseExpression, Combinable):
     pass
 
 
+_connector_combinators = {
+    connector: [
+        (fields.IntegerField, fields.DecimalField, fields.DecimalField),
+        (fields.DecimalField, fields.IntegerField, fields.DecimalField),
+        (fields.IntegerField, fields.FloatField, fields.FloatField),
+        (fields.FloatField, fields.IntegerField, fields.FloatField),
+    ]
+    for connector in (Combinable.ADD, Combinable.SUB, Combinable.MUL, Combinable.DIV)
+}
+
+
+@functools.lru_cache(maxsize=128)
+def _resolve_combined_type(connector, lhs_type, rhs_type):
+    combinators = _connector_combinators.get(connector, ())
+    for combinator_lhs_type, combinator_rhs_type, combined_type in combinators:
+        if issubclass(lhs_type, combinator_lhs_type) and issubclass(rhs_type, combinator_rhs_type):
+            return combined_type
+
+
 class CombinedExpression(SQLiteNumericMixin, Expression):
 
     def __init__(self, lhs, connector, rhs, output_field=None):
@@ -442,6 +652,20 @@ class CombinedExpression(SQLiteNumericMixin, Expression):
     def set_source_expressions(self, exprs):
         self.lhs, self.rhs = exprs
 
+    @inspect_code
+    def _resolve_output_field(self):
+        try:
+            return super()._resolve_output_field()
+        except FieldError:
+            combined_type = _resolve_combined_type(
+                self.connector,
+                type(self.lhs.output_field),
+                type(self.rhs.output_field),
+            )
+            if combined_type is None:
+                raise
+            return combined_type()
+
     def as_sql(self, compiler, connection):
         expressions = []
         expression_params = []
@@ -721,6 +945,31 @@ class Value(Expression):
     def get_group_by_cols(self, alias=None):
         return []
 
+    @inspect_code
+    def _resolve_output_field(self):
+        if isinstance(self.value, str):
+            return fields.CharField()
+        if isinstance(self.value, bool):
+            return fields.BooleanField()
+        if isinstance(self.value, int):
+            return fields.IntegerField()
+        if isinstance(self.value, float):
+            return fields.FloatField()
+        if isinstance(self.value, datetime.datetime):
+            return fields.DateTimeField()
+        if isinstance(self.value, datetime.date):
+            return fields.DateField()
+        if isinstance(self.value, datetime.time):
+            return fields.TimeField()
+        if isinstance(self.value, datetime.timedelta):
+            return fields.DurationField()
+        if isinstance(self.value, Decimal):
+            return fields.DecimalField()
+        if isinstance(self.value, bytes):
+            return fields.BinaryField()
+        if isinstance(self.value, UUID):
+            return fields.UUIDField()
+
 
 class RawSQL(Expression):
     def __init__(self, sql, params, output_field=None):
@@ -1177,7 +1426,6 @@ class OrderBy(BaseExpression):
             copy.expression = Case(
                 When(self.expression, then=True),
                 default=False,
-                output_field=fields.BooleanField(),
             )
             return copy.as_sql(compiler, connection)
         return self.as_sql(compiler, connection)
diff --git a/django/db/models/lookups.py b/django/db/models/lookups.py
index 79313dd..cfb274b 100644
--- a/django/db/models/lookups.py
+++ b/django/db/models/lookups.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/django__django-11359/django/db/models/lookups.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 import itertools
 import math
 import warnings
@@ -6,7 +199,7 @@ from copy import copy
 from django.core.exceptions import EmptyResultSet
 from django.db.models.expressions import Case, Exists, Func, Value, When
 from django.db.models.fields import (
-    BooleanField, CharField, DateTimeField, Field, IntegerField, UUIDField,
+    CharField, DateTimeField, Field, IntegerField, UUIDField,
 )
 from django.db.models.query_utils import RegisterLookupMixin
 from django.utils.datastructures import OrderedSet
@@ -116,6 +309,7 @@ class Lookup:
     def as_sql(self, compiler, connection):
         raise NotImplementedError
 
+    @inspect_code
     def as_oracle(self, compiler, connection):
         # Oracle doesn't allow EXISTS() to be compared to another expression
         # unless it's wrapped in a CASE WHEN.
@@ -123,7 +317,7 @@ class Lookup:
         exprs = []
         for expr in (self.lhs, self.rhs):
             if isinstance(expr, Exists):
-                expr = Case(When(expr, then=True), default=False, output_field=BooleanField())
+                expr = Case(When(expr, then=True), default=False)
                 wrapped = True
             exprs.append(expr)
         lookup = type(self)(*exprs) if wrapped else self
diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py
index a8377c9..c738cbb 100644
--- a/tests/aggregation/tests.py
+++ b/tests/aggregation/tests.py
@@ -841,17 +841,13 @@ class AggregateTestCase(TestCase):
             Book.objects.aggregate(fail=F('price'))
 
     def test_nonfield_annotation(self):
-        book = Book.objects.annotate(val=Max(Value(2, output_field=IntegerField()))).first()
+        book = Book.objects.annotate(val=Max(Value(2))).first()
         self.assertEqual(book.val, 2)
         book = Book.objects.annotate(val=Max(Value(2), output_field=IntegerField())).first()
         self.assertEqual(book.val, 2)
         book = Book.objects.annotate(val=Max(2, output_field=IntegerField())).first()
         self.assertEqual(book.val, 2)
 
-    def test_missing_output_field_raises_error(self):
-        with self.assertRaisesMessage(FieldError, 'Cannot resolve expression type, unknown output_field'):
-            Book.objects.annotate(val=Max(2)).first()
-
     def test_annotation_expressions(self):
         authors = Author.objects.annotate(combined_ages=Sum(F('age') + F('friends__age'))).order_by('name')
         authors2 = Author.objects.annotate(combined_ages=Sum('age') + Sum('friends__age')).order_by('name')
@@ -893,7 +889,7 @@ class AggregateTestCase(TestCase):
 
     def test_combine_different_types(self):
         msg = (
-            'Expression contains mixed types: FloatField, IntegerField. '
+            'Expression contains mixed types: FloatField, DecimalField. '
             'You must set output_field.'
         )
         qs = Book.objects.annotate(sums=Sum('rating') + Sum('pages') + Sum('price'))
diff --git a/tests/aggregation_regress/tests.py b/tests/aggregation_regress/tests.py
index bdfcb1d..7604335 100644
--- a/tests/aggregation_regress/tests.py
+++ b/tests/aggregation_regress/tests.py
@@ -374,7 +374,7 @@ class AggregationTests(TestCase):
         # Conditional aggregation of a grouped queryset.
         self.assertEqual(
             Book.objects.annotate(c=Count('authors')).values('pk').aggregate(test=Sum(
-                Case(When(c__gt=1, then=1), output_field=IntegerField())
+                Case(When(c__gt=1, then=1))
             ))['test'],
             3
         )
@@ -382,13 +382,13 @@ class AggregationTests(TestCase):
     def test_sliced_conditional_aggregate(self):
         self.assertEqual(
             Author.objects.all()[:5].aggregate(test=Sum(Case(
-                When(age__lte=35, then=1), output_field=IntegerField()
+                When(age__lte=35, then=1)
             )))['test'],
             3
         )
 
     def test_annotated_conditional_aggregate(self):
-        annotated_qs = Book.objects.annotate(discount_price=F('price') * 0.75)
+        annotated_qs = Book.objects.annotate(discount_price=F('price') * Decimal('0.75'))
         self.assertAlmostEqual(
             annotated_qs.aggregate(test=Avg(Case(
                 When(pages__lt=400, then='discount_price'),
diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py
index aa3682b..5401cd9 100644
--- a/tests/annotations/tests.py
+++ b/tests/annotations/tests.py
@@ -5,9 +5,9 @@ from unittest import skipIf
 from django.core.exceptions import FieldDoesNotExist, FieldError
 from django.db import connection
 from django.db.models import (
-    BooleanField, Case, CharField, Count, DateTimeField, Exists,
-    ExpressionWrapper, F, FloatField, Func, IntegerField, Max,
-    NullBooleanField, OuterRef, Q, Subquery, Sum, Value, When,
+    BooleanField, Case, Count, DateTimeField, Exists, ExpressionWrapper, F,
+    FloatField, Func, IntegerField, Max, NullBooleanField, OuterRef, Q,
+    Subquery, Sum, Value, When,
 )
 from django.db.models.expressions import RawSQL
 from django.db.models.functions import Length, Lower
@@ -115,8 +115,7 @@ class NonAggregateAnnotationTestCase(TestCase):
         s3.books.add(cls.b3, cls.b4, cls.b6)
 
     def test_basic_annotation(self):
-        books = Book.objects.annotate(
-            is_book=Value(1, output_field=IntegerField()))
+        books = Book.objects.annotate(is_book=Value(1))
         for book in books:
             self.assertEqual(book.is_book, 1)
 
@@ -163,9 +162,7 @@ class NonAggregateAnnotationTestCase(TestCase):
         self.assertTrue(all(not book.selected for book in books))
 
     def test_annotate_with_aggregation(self):
-        books = Book.objects.annotate(
-            is_book=Value(1, output_field=IntegerField()),
-            rating_count=Count('rating'))
+        books = Book.objects.annotate(is_book=Value(1), rating_count=Count('rating'))
         for book in books:
             self.assertEqual(book.is_book, 1)
             self.assertEqual(book.rating_count, 1)
@@ -231,9 +228,7 @@ class NonAggregateAnnotationTestCase(TestCase):
         self.assertCountEqual(lengths, [3, 7, 8])
 
     def test_filter_annotation(self):
-        books = Book.objects.annotate(
-            is_book=Value(1, output_field=IntegerField())
-        ).filter(is_book=1)
+        books = Book.objects.annotate(is_book=Value(1)).filter(is_book=1)
         for book in books:
             self.assertEqual(book.is_book, 1)
 
@@ -469,7 +464,7 @@ class NonAggregateAnnotationTestCase(TestCase):
         qs = Employee.objects.extra(
             select={'random_value': '42'}
         ).select_related('store').annotate(
-            annotated_value=Value(17, output_field=IntegerField())
+            annotated_value=Value(17),
         )
 
         rows = [
@@ -493,7 +488,7 @@ class NonAggregateAnnotationTestCase(TestCase):
         qs = Employee.objects.extra(
             select={'random_value': '42'}
         ).select_related('store').annotate(
-            annotated_value=Value(17, output_field=IntegerField())
+            annotated_value=Value(17),
         )
 
         rows = [
@@ -554,7 +549,7 @@ class NonAggregateAnnotationTestCase(TestCase):
                 function='COALESCE',
             )
         ).annotate(
-            tagline_lower=Lower(F('tagline'), output_field=CharField())
+            tagline_lower=Lower(F('tagline')),
         ).order_by('name')
 
         # LOWER function supported by:
@@ -661,7 +656,6 @@ class NonAggregateAnnotationTestCase(TestCase):
             max_pages=Case(
                 When(book_contact_set__isnull=True, then=Value(0)),
                 default=Max(F('book__pages')),
-                output_field=IntegerField(),
             ),
         ).values('name', 'max_pages')
         self.assertCountEqual(qs, [
diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py
index 42b8c8f..2f392a5 100644
--- a/tests/expressions/tests.py
+++ b/tests/expressions/tests.py
@@ -3,15 +3,17 @@ import pickle
 import unittest
 import uuid
 from copy import deepcopy
+from decimal import Decimal
 from unittest import mock
 
 from django.core.exceptions import FieldError
 from django.db import DatabaseError, NotSupportedError, connection
 from django.db.models import (
-    Avg, BooleanField, Case, CharField, Count, DateField, DateTimeField,
-    DurationField, Exists, Expression, ExpressionList, ExpressionWrapper, F,
-    Func, IntegerField, Max, Min, Model, OrderBy, OuterRef, Q, StdDev,
-    Subquery, Sum, TimeField, UUIDField, Value, Variance, When,
+    Avg, BinaryField, BooleanField, Case, CharField, Count, DateField,
+    DateTimeField, DecimalField, DurationField, Exists, Expression,
+    ExpressionList, ExpressionWrapper, F, FloatField, Func, IntegerField, Max,
+    Min, Model, OrderBy, OuterRef, Q, StdDev, Subquery, Sum, TimeField,
+    UUIDField, Value, Variance, When,
 )
 from django.db.models.expressions import Col, Combinable, Random, RawSQL, Ref
 from django.db.models.functions import (
@@ -727,7 +729,7 @@ class BasicExpressionsTests(TestCase):
         self.assertEqual(qs.get().ceo_company, 'Test GmbH')
 
     def test_pickle_expression(self):
-        expr = Value(1, output_field=IntegerField())
+        expr = Value(1)
         expr.convert_value  # populate cached property
         self.assertEqual(pickle.loads(pickle.dumps(expr)), expr)
 
@@ -1543,7 +1545,7 @@ class FTimeDeltaTests(TestCase):
     def test_time_subtraction(self):
         Time.objects.create(time=datetime.time(12, 30, 15, 2345))
         queryset = Time.objects.annotate(
-            difference=F('time') - Value(datetime.time(11, 15, 0), output_field=TimeField()),
+            difference=F('time') - Value(datetime.time(11, 15, 0)),
         )
         self.assertEqual(
             queryset.get().difference,
@@ -1629,7 +1631,7 @@ class FTimeDeltaTests(TestCase):
 
     def test_date_minus_duration(self):
         more_than_4_days = Experiment.objects.filter(
-            assigned__lt=F('completed') - Value(datetime.timedelta(days=4), output_field=DurationField())
+            assigned__lt=F('completed') - Value(datetime.timedelta(days=4))
         )
         self.assertQuerysetEqual(more_than_4_days, ['e3', 'e4', 'e5'], lambda e: e.name)
 
@@ -1711,6 +1713,30 @@ class ValueTests(TestCase):
         value = Value('foo', output_field=CharField())
         self.assertEqual(value.as_sql(compiler, connection), ('%s', ['foo']))
 
+    def test_resolve_output_field(self):
+        value_types = [
+            ('str', CharField),
+            (True, BooleanField),
+            (42, IntegerField),
+            (3.14, FloatField),
+            (datetime.date(2019, 5, 15), DateField),
+            (datetime.datetime(2019, 5, 15), DateTimeField),
+            (datetime.time(3, 16), TimeField),
+            (datetime.timedelta(1), DurationField),
+            (Decimal('3.14'), DecimalField),
+            (b'', BinaryField),
+            (uuid.uuid4(), UUIDField),
+        ]
+        for value, ouput_field_type in value_types:
+            with self.subTest(type=type(value)):
+                expr = Value(value)
+                self.assertIsInstance(expr.output_field, ouput_field_type)
+
+    def test_resolve_output_field_failure(self):
+        msg = 'Cannot resolve expression type, unknown output_field'
+        with self.assertRaisesMessage(FieldError, msg):
+            Value(object()).output_field
+
 
 class FieldTransformTests(TestCase):
 
@@ -1848,7 +1874,9 @@ class ExpressionWrapperTests(SimpleTestCase):
         self.assertEqual(expr.get_group_by_cols(alias=None), [])
 
     def test_non_empty_group_by(self):
-        expr = ExpressionWrapper(Lower(Value('f')), output_field=IntegerField())
+        value = Value('f')
+        value.output_field = None
+        expr = ExpressionWrapper(Lower(value), output_field=IntegerField())
         group_by_cols = expr.get_group_by_cols(alias=None)
         self.assertEqual(group_by_cols, [expr.expression])
         self.assertEqual(group_by_cols[0].output_field, expr.output_field)
diff --git a/tests/expressions_case/tests.py b/tests/expressions_case/tests.py
index 3778e32..2a101ee 100644
--- a/tests/expressions_case/tests.py
+++ b/tests/expressions_case/tests.py
@@ -6,9 +6,9 @@ from uuid import UUID
 
 from django.core.exceptions import FieldError
 from django.db.models import (
-    BinaryField, BooleanField, Case, CharField, Count, DecimalField,
-    DurationField, F, GenericIPAddressField, IntegerField, Max, Min, Q, Sum,
-    TextField, TimeField, UUIDField, Value, When,
+    BinaryField, BooleanField, Case, Count, DecimalField, F,
+    GenericIPAddressField, IntegerField, Max, Min, Q, Sum, TextField, Value,
+    When,
 )
 from django.test import SimpleTestCase, TestCase
 
@@ -68,7 +68,6 @@ class CaseExpressionTests(TestCase):
                 When(integer=1, then=Value('one')),
                 When(integer=2, then=Value('two')),
                 default=Value('other'),
-                output_field=CharField(),
             )).order_by('pk'),
             [(1, 'one'), (2, 'two'), (3, 'other'), (2, 'two'), (3, 'other'), (3, 'other'), (4, 'other')],
             transform=attrgetter('integer', 'test')
@@ -79,7 +78,6 @@ class CaseExpressionTests(TestCase):
             CaseTestModel.objects.annotate(test=Case(
                 When(integer=1, then=1),
                 When(integer=2, then=2),
-                output_field=IntegerField(),
             )).order_by('pk'),
             [(1, 1), (2, 2), (3, None), (2, 2), (3, None), (3, None), (4, None)],
             transform=attrgetter('integer', 'test')
@@ -101,7 +99,6 @@ class CaseExpressionTests(TestCase):
             CaseTestModel.objects.annotate(f_test=Case(
                 When(integer2=F('integer'), then=Value('equal')),
                 When(integer2=F('integer') + 1, then=Value('+1')),
-                output_field=CharField(),
             )).order_by('pk'),
             [(1, 'equal'), (2, '+1'), (3, '+1'), (2, 'equal'), (3, '+1'), (3, 'equal'), (4, '+1')],
             transform=attrgetter('integer', 'f_test')
@@ -135,7 +132,6 @@ class CaseExpressionTests(TestCase):
                 When(integer2=F('o2o_rel__integer'), then=Value('equal')),
                 When(integer2=F('o2o_rel__integer') + 1, then=Value('+1')),
                 default=Value('other'),
-                output_field=CharField(),
             )).order_by('pk'),
             [(1, 'equal'), (2, '+1'), (3, '+1'), (2, 'equal'), (3, '+1'), (3, 'equal'), (4, 'other')],
             transform=attrgetter('integer', 'join_test')
@@ -148,7 +144,6 @@ class CaseExpressionTests(TestCase):
                 When(o2o_rel__integer=2, then=Value('two')),
                 When(o2o_rel__integer=3, then=Value('three')),
                 default=Value('other'),
-                output_field=CharField(),
             )).order_by('pk'),
             [(1, 'one'), (2, 'two'), (3, 'three'), (2, 'two'), (3, 'three'), (3, 'three'), (4, 'one')],
             transform=attrgetter('integer', 'join_test')
@@ -178,7 +173,6 @@ class CaseExpressionTests(TestCase):
                 f_test=Case(
                     When(integer2=F('integer'), then=Value('equal')),
                     When(integer2=F('f_plus_1'), then=Value('+1')),
-                    output_field=CharField(),
                 ),
             ).order_by('pk'),
             [(1, 'equal'), (2, '+1'), (3, '+1'), (2, 'equal'), (3, '+1'), (3, 'equal'), (4, '+1')],
@@ -195,7 +189,6 @@ class CaseExpressionTests(TestCase):
                     When(f_minus_2=0, then=Value('zero')),
                     When(f_minus_2=1, then=Value('one')),
                     default=Value('other'),
-                    output_field=CharField(),
                 ),
             ).order_by('pk'),
             [(1, 'negative one'), (2, 'zero'), (3, 'one'), (2, 'zero'), (3, 'one'), (3, 'one'), (4, 'other')],
@@ -226,7 +219,6 @@ class CaseExpressionTests(TestCase):
                 test=Case(
                     When(integer2=F('min'), then=Value('min')),
                     When(integer2=F('max'), then=Value('max')),
-                    output_field=CharField(),
                 ),
             ).order_by('pk'),
             [(1, 1, 'min'), (2, 3, 'max'), (3, 4, 'max'), (2, 2, 'min'), (3, 4, 'max'), (3, 3, 'min'), (4, 5, 'min')],
@@ -242,7 +234,6 @@ class CaseExpressionTests(TestCase):
                     When(max=3, then=Value('max = 3')),
                     When(max=4, then=Value('max = 4')),
                     default=Value(''),
-                    output_field=CharField(),
                 ),
             ).order_by('pk'),
             [(1, 1, ''), (2, 3, 'max = 3'), (3, 4, 'max = 4'), (2, 3, 'max = 3'),
@@ -256,7 +247,6 @@ class CaseExpressionTests(TestCase):
                 When(integer=1, then=Value('one')),
                 When(integer=2, then=Value('two')),
                 default=Value('other'),
-                output_field=CharField(),
             )).exclude(test='other').order_by('pk'),
             [(1, 'one'), (2, 'two'), (2, 'two')],
             transform=attrgetter('integer', 'test')
@@ -269,7 +259,6 @@ class CaseExpressionTests(TestCase):
                 When(integer=2, then=Value('two')),
                 When(integer=3, then=Value('three')),
                 default=Value('other'),
-                output_field=CharField(),
             )).order_by('test').values_list('integer', flat=True)),
             [1, 4, 3, 3, 3, 2, 2]
         )
@@ -278,7 +267,7 @@ class CaseExpressionTests(TestCase):
         objects = CaseTestModel.objects.annotate(
             selected=Case(
                 When(pk__in=[], then=Value('selected')),
-                default=Value('not selected'), output_field=CharField()
+                default=Value('not selected'),
             )
         )
         self.assertEqual(len(objects), CaseTestModel.objects.count())
@@ -291,7 +280,6 @@ class CaseExpressionTests(TestCase):
                     When(integer=1, then=2),
                     When(integer=2, then=1),
                     default=3,
-                    output_field=IntegerField(),
                 ) + 1,
             ).order_by('pk'),
             [(1, 3), (2, 2), (3, 4), (2, 2), (3, 4), (3, 4), (4, 4)],
@@ -305,7 +293,6 @@ class CaseExpressionTests(TestCase):
                     test=Case(
                         When(integer=F('integer2'), then='pk'),
                         When(integer=4, then='pk'),
-                        output_field=IntegerField(),
                     ),
                 ).values('test')).order_by('pk'),
             [(1, 1), (2, 2), (3, 3), (4, 5)],
@@ -327,7 +314,6 @@ class CaseExpressionTests(TestCase):
         SOME_CASE = Case(
             When(pk=0, then=Value('0')),
             default=Value('1'),
-            output_field=CharField(),
         )
         self.assertQuerysetEqual(
             CaseTestModel.objects.annotate(somecase=SOME_CASE).order_by('pk'),
@@ -340,19 +326,15 @@ class CaseExpressionTests(TestCase):
             CaseTestModel.objects.aggregate(
                 one=Sum(Case(
                     When(integer=1, then=1),
-                    output_field=IntegerField(),
                 )),
                 two=Sum(Case(
                     When(integer=2, then=1),
-                    output_field=IntegerField(),
                 )),
                 three=Sum(Case(
                     When(integer=3, then=1),
-                    output_field=IntegerField(),
                 )),
                 four=Sum(Case(
                     When(integer=4, then=1),
-                    output_field=IntegerField(),
                 )),
             ),
             {'one': 1, 'two': 2, 'three': 3, 'four': 1}
@@ -373,11 +355,9 @@ class CaseExpressionTests(TestCase):
             CaseTestModel.objects.aggregate(
                 equal=Sum(Case(
                     When(integer2=F('integer'), then=1),
-                    output_field=IntegerField(),
                 )),
                 plus_one=Sum(Case(
                     When(integer2=F('integer') + 1, then=1),
-                    output_field=IntegerField(),
                 )),
             ),
             {'equal': 3, 'plus_one': 4}
@@ -389,7 +369,6 @@ class CaseExpressionTests(TestCase):
                 When(integer=2, then=3),
                 When(integer=3, then=4),
                 default=1,
-                output_field=IntegerField(),
             )).order_by('pk'),
             [(1, 1), (2, 3), (3, 4), (3, 4)],
             transform=attrgetter('integer', 'integer2')
@@ -400,7 +379,6 @@ class CaseExpressionTests(TestCase):
             CaseTestModel.objects.filter(integer2=Case(
                 When(integer=2, then=3),
                 When(integer=3, then=4),
-                output_field=IntegerField(),
             )).order_by('pk'),
             [(2, 3), (3, 4), (3, 4)],
             transform=attrgetter('integer', 'integer2')
@@ -422,7 +400,6 @@ class CaseExpressionTests(TestCase):
             CaseTestModel.objects.filter(string=Case(
                 When(integer2=F('integer'), then=Value('2')),
                 When(integer2=F('integer') + 1, then=Value('3')),
-                output_field=CharField(),
             )).order_by('pk'),
             [(3, 4, '3'), (2, 2, '2'), (3, 4, '3')],
             transform=attrgetter('integer', 'integer2', 'string')
@@ -444,7 +421,6 @@ class CaseExpressionTests(TestCase):
             CaseTestModel.objects.filter(integer=Case(
                 When(integer2=F('o2o_rel__integer') + 1, then=2),
                 When(integer2=F('o2o_rel__integer'), then=3),
-                output_field=IntegerField(),
             )).order_by('pk'),
             [(2, 3), (3, 3)],
             transform=attrgetter('integer', 'integer2')
@@ -456,7 +432,6 @@ class CaseExpressionTests(TestCase):
                 When(o2o_rel__integer=1, then=1),
                 When(o2o_rel__integer=2, then=3),
                 When(o2o_rel__integer=3, then=4),
-                output_field=IntegerField(),
             )).order_by('pk'),
             [(1, 1), (2, 3), (3, 4), (3, 4)],
             transform=attrgetter('integer', 'integer2')
@@ -485,7 +460,6 @@ class CaseExpressionTests(TestCase):
                 integer=Case(
                     When(integer2=F('integer'), then=2),
                     When(integer2=F('f_plus_1'), then=3),
-                    output_field=IntegerField(),
                 ),
             ).order_by('pk'),
             [(3, 4), (2, 2), (3, 4)],
@@ -501,7 +475,6 @@ class CaseExpressionTests(TestCase):
                     When(f_plus_1=3, then=3),
                     When(f_plus_1=4, then=4),
                     default=1,
-                    output_field=IntegerField(),
                 ),
             ).order_by('pk'),
             [(1, 1), (2, 3), (3, 4), (3, 4)],
@@ -612,7 +585,6 @@ class CaseExpressionTests(TestCase):
                 integer=Case(
                     When(integer2=F('o2o_rel__integer') + 1, then=2),
                     When(integer2=F('o2o_rel__integer'), then=3),
-                    output_field=IntegerField(),
                 ),
             )
 
@@ -624,7 +596,6 @@ class CaseExpressionTests(TestCase):
                     When(o2o_rel__integer=2, then=Value('two')),
                     When(o2o_rel__integer=3, then=Value('three')),
                     default=Value('other'),
-                    output_field=CharField(),
                 ),
             )
 
@@ -644,9 +615,9 @@ class CaseExpressionTests(TestCase):
     def test_update_binary(self):
         CaseTestModel.objects.update(
             binary=Case(
-                When(integer=1, then=Value(b'one', output_field=BinaryField())),
-                When(integer=2, then=Value(b'two', output_field=BinaryField())),
-                default=Value(b'', output_field=BinaryField()),
+                When(integer=1, then=b'one'),
+                When(integer=2, then=b'two'),
+                default=b'',
             ),
         )
         self.assertQuerysetEqual(
@@ -725,10 +696,8 @@ class CaseExpressionTests(TestCase):
     def test_update_duration(self):
         CaseTestModel.objects.update(
             duration=Case(
-                # fails on sqlite if output_field is not set explicitly on all
-                # Values containing timedeltas
-                When(integer=1, then=Value(timedelta(1), output_field=DurationField())),
-                When(integer=2, then=Value(timedelta(2), output_field=DurationField())),
+                When(integer=1, then=timedelta(1)),
+                When(integer=2, then=timedelta(2)),
             ),
         )
         self.assertQuerysetEqual(
@@ -808,7 +777,6 @@ class CaseExpressionTests(TestCase):
     def test_update_generic_ip_address(self):
         CaseTestModel.objects.update(
             generic_ip_address=Case(
-                # fails on postgresql if output_field is not set explicitly
                 When(integer=1, then=Value('1.1.1.1')),
                 When(integer=2, then=Value('2.2.2.2')),
                 output_field=GenericIPAddressField(),
@@ -915,8 +883,8 @@ class CaseExpressionTests(TestCase):
     def test_update_string(self):
         CaseTestModel.objects.filter(string__in=['1', '2']).update(
             string=Case(
-                When(integer=1, then=Value('1', output_field=CharField())),
-                When(integer=2, then=Value('2', output_field=CharField())),
+                When(integer=1, then=Value('1')),
+                When(integer=2, then=Value('2')),
             ),
         )
         self.assertQuerysetEqual(
@@ -942,10 +910,8 @@ class CaseExpressionTests(TestCase):
     def test_update_time(self):
         CaseTestModel.objects.update(
             time=Case(
-                # fails on sqlite if output_field is not set explicitly on all
-                # Values containing times
-                When(integer=1, then=Value(time(1), output_field=TimeField())),
-                When(integer=2, then=Value(time(2), output_field=TimeField())),
+                When(integer=1, then=time(1)),
+                When(integer=2, then=time(2)),
             ),
         )
         self.assertQuerysetEqual(
@@ -974,16 +940,8 @@ class CaseExpressionTests(TestCase):
     def test_update_uuid(self):
         CaseTestModel.objects.update(
             uuid=Case(
-                # fails on sqlite if output_field is not set explicitly on all
-                # Values containing UUIDs
-                When(integer=1, then=Value(
-                    UUID('11111111111111111111111111111111'),
-                    output_field=UUIDField(),
-                )),
-                When(integer=2, then=Value(
-                    UUID('22222222222222222222222222222222'),
-                    output_field=UUIDField(),
-                )),
+                When(integer=1, then=UUID('11111111111111111111111111111111')),
+                When(integer=2, then=UUID('22222222222222222222222222222222')),
             ),
         )
         self.assertQuerysetEqual(
@@ -1022,7 +980,6 @@ class CaseExpressionTests(TestCase):
                     When(integer__lt=2, then=Value('less than 2')),
                     When(integer__gt=2, then=Value('greater than 2')),
                     default=Value('equal to 2'),
-                    output_field=CharField(),
                 ),
             ).order_by('pk'),
             [
@@ -1038,7 +995,6 @@ class CaseExpressionTests(TestCase):
                 test=Case(
                     When(integer=2, integer2=3, then=Value('when')),
                     default=Value('default'),
-                    output_field=CharField(),
                 ),
             ).order_by('pk'),
             [
@@ -1054,7 +1010,6 @@ class CaseExpressionTests(TestCase):
                 test=Case(
                     When(Q(integer=2) | Q(integer2=3), then=Value('when')),
                     default=Value('default'),
-                    output_field=CharField(),
                 ),
             ).order_by('pk'),
             [
@@ -1070,7 +1025,6 @@ class CaseExpressionTests(TestCase):
                 When(integer=1, then=2),
                 When(integer=2, then=1),
                 default=3,
-                output_field=IntegerField(),
             )).order_by('test', 'pk'),
             [(2, 1), (2, 1), (1, 2)],
             transform=attrgetter('integer', 'test')
@@ -1082,7 +1036,6 @@ class CaseExpressionTests(TestCase):
                 When(integer=1, then=2),
                 When(integer=2, then=1),
                 default=3,
-                output_field=IntegerField(),
             )).order_by(F('test').asc(), 'pk'),
             [(2, 1), (2, 1), (1, 2)],
             transform=attrgetter('integer', 'test')
@@ -1101,7 +1054,6 @@ class CaseExpressionTests(TestCase):
                 foo=Case(
                     When(fk_rel__pk=1, then=2),
                     default=3,
-                    output_field=IntegerField()
                 ),
             ),
             [(o, 3)],
@@ -1113,7 +1065,6 @@ class CaseExpressionTests(TestCase):
                 foo=Case(
                     When(fk_rel__isnull=True, then=2),
                     default=3,
-                    output_field=IntegerField()
                 ),
             ),
             [(o, 2)],
@@ -1133,12 +1084,10 @@ class CaseExpressionTests(TestCase):
                 foo=Case(
                     When(fk_rel__pk=1, then=2),
                     default=3,
-                    output_field=IntegerField()
                 ),
                 bar=Case(
                     When(fk_rel__pk=1, then=4),
                     default=5,
-                    output_field=IntegerField()
                 ),
             ),
             [(o, 3, 5)],
@@ -1150,12 +1099,10 @@ class CaseExpressionTests(TestCase):
                 foo=Case(
                     When(fk_rel__isnull=True, then=2),
                     default=3,
-                    output_field=IntegerField()
                 ),
                 bar=Case(
                     When(fk_rel__isnull=True, then=4),
                     default=5,
-                    output_field=IntegerField()
                 ),
             ),
             [(o, 2, 4)],
@@ -1167,7 +1114,6 @@ class CaseExpressionTests(TestCase):
         qs = CaseTestModel.objects.values_list('id', 'integer').annotate(
             cnt=Sum(
                 Case(When(~Q(fk_rel__integer=1), then=1), default=2),
-                output_field=IntegerField()
             ),
         ).order_by('integer')
         # The first o has 2 as its fk_rel__integer=1, thus it hits the
@@ -1189,12 +1135,10 @@ class CaseExpressionTests(TestCase):
         qs = CaseTestModel.objects.values_list('id', 'integer').annotate(
             cnt=Sum(
                 Case(When(~Q(fk_rel__integer=1), then=1), default=2),
-                output_field=IntegerField()
             ),
         ).annotate(
             cnt2=Sum(
                 Case(When(~Q(fk_rel__integer=1), then=1), default=2),
-                output_field=IntegerField()
             ),
         ).order_by('integer')
         self.assertEqual(str(qs.query).count(' JOIN '), 1)
@@ -1231,7 +1175,6 @@ class CaseDocumentationExamples(TestCase):
                     When(account_type=Client.GOLD, then=Value('5%')),
                     When(account_type=Client.PLATINUM, then=Value('10%')),
                     default=Value('0%'),
-                    output_field=CharField(),
                 ),
             ).order_by('pk'),
             [('Jane Doe', '0%'), ('James Smith', '5%'), ('Jack Black', '10%')],
@@ -1247,7 +1190,6 @@ class CaseDocumentationExamples(TestCase):
                     When(registered_on__lte=a_year_ago, then=Value('10%')),
                     When(registered_on__lte=a_month_ago, then=Value('5%')),
                     default=Value('0%'),
-                    output_field=CharField(),
                 ),
             ).order_by('pk'),
             [('Jane Doe', '5%'), ('James Smith', '0%'), ('Jack Black', '10%')],
@@ -1299,15 +1241,12 @@ class CaseDocumentationExamples(TestCase):
             Client.objects.aggregate(
                 regular=Sum(Case(
                     When(account_type=Client.REGULAR, then=1),
-                    output_field=IntegerField(),
                 )),
                 gold=Sum(Case(
                     When(account_type=Client.GOLD, then=1),
-                    output_field=IntegerField(),
                 )),
                 platinum=Sum(Case(
                     When(account_type=Client.PLATINUM, then=1),
-                    output_field=IntegerField(),
                 )),
             ),
             {'regular': 2, 'gold': 1, 'platinum': 3}
@@ -1360,9 +1299,9 @@ class CaseWhenTests(SimpleTestCase):
         with self.assertRaisesMessage(TypeError, msg):
             When(condition=object())
         with self.assertRaisesMessage(TypeError, msg):
-            When(condition=Value(1, output_field=IntegerField()))
+            When(condition=Value(1))
         with self.assertRaisesMessage(TypeError, msg):
-            When(Value(1, output_field=IntegerField()), string='1')
+            When(Value(1), string='1')
         with self.assertRaisesMessage(TypeError, msg):
             When()
 
diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py
index 61ec3a8..fe319b3 100644
--- a/tests/ordering/tests.py
+++ b/tests/ordering/tests.py
@@ -1,7 +1,6 @@
 from datetime import datetime
 from operator import attrgetter
 
-from django.core.exceptions import FieldError
 from django.db.models import (
     CharField, DateTimeField, F, Max, OuterRef, Subquery, Value,
 )
@@ -439,17 +438,6 @@ class OrderingTests(TestCase):
         qs = Article.objects.order_by(Value('1', output_field=CharField()), '-headline')
         self.assertSequenceEqual(qs, [self.a4, self.a3, self.a2, self.a1])
 
-    def test_order_by_constant_value_without_output_field(self):
-        msg = 'Cannot resolve expression type, unknown output_field'
-        qs = Article.objects.annotate(constant=Value('1')).order_by('constant')
-        for ordered_qs in (
-            qs,
-            qs.values('headline'),
-            Article.objects.order_by(Value('1')),
-        ):
-            with self.subTest(ordered_qs=ordered_qs), self.assertRaisesMessage(FieldError, msg):
-                ordered_qs.first()
-
     def test_related_ordering_duplicate_table_reference(self):
         """
         An ordering referencing a model with an ordering referencing a model
diff --git a/tests/postgres_tests/test_ranges.py b/tests/postgres_tests/test_ranges.py
index 7257d66..14dc75c 100644
--- a/tests/postgres_tests/test_ranges.py
+++ b/tests/postgres_tests/test_ranges.py
@@ -170,7 +170,7 @@ class TestRangeContainsLookup(PostgreSQLTestCase):
             self.aware_timestamps[1],
             (self.timestamps[1], self.timestamps[2]),
             (self.aware_timestamps[1], self.aware_timestamps[2]),
-            Value(self.dates[0], output_field=DateTimeField()),
+            Value(self.dates[0]),
             Func(F('dates'), function='lower', output_field=DateTimeField()),
             F('timestamps_inner'),
         )
