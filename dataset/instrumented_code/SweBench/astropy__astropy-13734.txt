diff --git a/astropy/io/ascii/fixedwidth.py b/astropy/io/ascii/fixedwidth.py
index 9a2d322..1b45ebe 100644
--- a/astropy/io/ascii/fixedwidth.py
+++ b/astropy/io/ascii/fixedwidth.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-13734/astropy/io/ascii/fixedwidth.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 """An extensible ASCII table reader and writer.
 
@@ -78,6 +271,7 @@ class FixedWidthHeader(basic.BasicHeader):
             raise InconsistentTableError('No header line found in table')
         return line
 
+    @inspect_code
     def get_cols(self, lines):
         """
         Initialize the header Column objects from the table ``lines``.
@@ -91,6 +285,7 @@ class FixedWidthHeader(basic.BasicHeader):
             List of table lines
 
         """
+        header_rows = getattr(self, "header_rows", ["name"])
 
         # See "else" clause below for explanation of start_line and position_line
         start_line = core._get_line_index(self.start_line, self.process_lines(lines))
@@ -148,14 +343,20 @@ class FixedWidthHeader(basic.BasicHeader):
                 vals, self.col_starts, col_ends = self.get_fixedwidth_params(line)
                 self.col_ends = [x - 1 if x is not None else None for x in col_ends]
 
-            # Get the header column names and column positions
-            line = self.get_line(lines, start_line)
-            vals, starts, ends = self.get_fixedwidth_params(line)
-
-            self.names = vals
+            # Get the column names from the header line
+            line = self.get_line(lines, start_line + header_rows.index("name"))
+            self.names, starts, ends = self.get_fixedwidth_params(line)
 
         self._set_cols_from_names()
 
+        for ii, attr in enumerate(header_rows):
+            if attr != "name":
+                line = self.get_line(lines, start_line + ii)
+                vals = self.get_fixedwidth_params(line)[0]
+                for col, val in zip(self.cols, vals):
+                    if val:
+                        setattr(col, attr, val)
+
         # Set column start and end positions.
         for i, col in enumerate(self.cols):
             col.start = starts[i]
@@ -236,29 +437,44 @@ class FixedWidthData(basic.BasicData):
     """
     splitter_class = FixedWidthSplitter
     """ Splitter class for splitting data lines into columns """
+    start_line = None
 
     def write(self, lines):
+        default_header_rows = [] if self.header.start_line is None else ['name']
+        header_rows = getattr(self, "header_rows", default_header_rows)
+        # First part is getting the widths of each column.
+        # List (rows) of list (column values) for data lines
         vals_list = []
         col_str_iters = self.str_vals()
         for vals in zip(*col_str_iters):
             vals_list.append(vals)
 
-        for i, col in enumerate(self.cols):
-            col.width = max(len(vals[i]) for vals in vals_list)
-            if self.header.start_line is not None:
-                col.width = max(col.width, len(col.info.name))
-
-        widths = [col.width for col in self.cols]
-
-        if self.header.start_line is not None:
-            lines.append(self.splitter.join([col.info.name for col in self.cols],
-                                            widths))
+        # List (rows) of list (columns values) for header lines.
+        hdrs_list = []
+        for col_attr in header_rows:
+            vals = [
+                "" if (val := getattr(col.info, col_attr)) is None else str(val)
+                for col in self.cols
+            ]
+            hdrs_list.append(vals)
+
+        # Widths for data columns
+        widths = [max(len(vals[i_col]) for vals in vals_list)
+                  for i_col in range(len(self.cols))]
+        # Incorporate widths for header columns (if there are any)
+        if hdrs_list:
+            for i_col in range(len(self.cols)):
+                widths[i_col] = max(
+                    widths[i_col],
+                    max(len(vals[i_col]) for vals in hdrs_list)
+                )
+
+        # Now collect formatted header and data lines into the output lines
+        for vals in hdrs_list:
+            lines.append(self.splitter.join(vals, widths))
 
         if self.header.position_line is not None:
-            char = self.header.position_char
-            if len(char) != 1:
-                raise ValueError(f'Position_char="{char}" must be a single character')
-            vals = [char * col.width for col in self.cols]
+            vals = [self.header.position_char * width for width in widths]
             lines.append(self.splitter.join(vals, widths))
 
         for vals in vals_list:
@@ -299,12 +515,25 @@ class FixedWidth(basic.Basic):
     header_class = FixedWidthHeader
     data_class = FixedWidthData
 
-    def __init__(self, col_starts=None, col_ends=None, delimiter_pad=' ', bookend=True):
+    def __init__(
+        self,
+        col_starts=None,
+        col_ends=None,
+        delimiter_pad=' ',
+        bookend=True,
+        header_rows=None
+    ):
+        if header_rows is None:
+            header_rows = ["name"]
         super().__init__()
         self.data.splitter.delimiter_pad = delimiter_pad
         self.data.splitter.bookend = bookend
         self.header.col_starts = col_starts
         self.header.col_ends = col_ends
+        self.header.header_rows = header_rows
+        self.data.header_rows = header_rows
+        if self.data.start_line is None:
+            self.data.start_line = len(header_rows)
 
 
 class FixedWidthNoHeaderHeader(FixedWidthHeader):
@@ -349,9 +578,10 @@ class FixedWidthNoHeader(FixedWidth):
     header_class = FixedWidthNoHeaderHeader
     data_class = FixedWidthNoHeaderData
 
+    @inspect_code
     def __init__(self, col_starts=None, col_ends=None, delimiter_pad=' ', bookend=True):
         super().__init__(col_starts, col_ends, delimiter_pad=delimiter_pad,
-                         bookend=bookend)
+                         bookend=bookend, header_rows=[])
 
 
 class FixedWidthTwoLineHeader(FixedWidthHeader):
@@ -406,8 +636,23 @@ class FixedWidthTwoLine(FixedWidth):
     data_class = FixedWidthTwoLineData
     header_class = FixedWidthTwoLineHeader
 
-    def __init__(self, position_line=1, position_char='-', delimiter_pad=None, bookend=False):
-        super().__init__(delimiter_pad=delimiter_pad, bookend=bookend)
+    @inspect_code
+    def __init__(
+        self,
+        position_line=None,
+        position_char='-',
+        delimiter_pad=None,
+        bookend=False,
+        header_rows=None
+    ):
+        if len(position_char) != 1:
+            raise ValueError(
+                f'Position_char="{position_char}" must be a ''single character'
+            )
+        super().__init__(delimiter_pad=delimiter_pad, bookend=bookend,
+                         header_rows=header_rows)
+        if position_line is None:
+            position_line = len(self.header.header_rows)
         self.header.position_line = position_line
         self.header.position_char = position_char
         self.data.start_line = position_line + 1
diff --git a/astropy/io/ascii/tests/test_fixedwidth.py b/astropy/io/ascii/tests/test_fixedwidth.py
index 5b5e75b..ecc682c 100644
--- a/astropy/io/ascii/tests/test_fixedwidth.py
+++ b/astropy/io/ascii/tests/test_fixedwidth.py
@@ -499,3 +499,46 @@ AAA y z
     assert np.all(dat['a'] == [1, 4])
     assert np.all(dat['b'] == [2, 5])
     assert np.all(dat['c'] == [3, 6])
+
+
+def test_fixed_width_header_rows():
+    tbl = [
+        '| int16 | float32 |      <U3 | int64 |',
+        '|     a |       b |        c |     d |',
+        '|     m |         |          | m / s |',
+        '|       |     .2f |          |       |',
+        '|       |         | C column |       |',
+        '|     1 |    1.00 |        c |     4 |',
+        '|     2 |    2.00 |        d |     5 |',
+        '|     3 |    3.00 |        e |     6 |'
+    ]
+    header_rows = ["dtype", "name", "unit", "format", "description"]
+    dat = ascii.read(tbl, format='fixed_width', delimiter='|', header_rows=header_rows)
+    out = StringIO()
+    ascii.write(dat, out, format='fixed_width', delimiter='|', header_rows=header_rows)
+    assert out.getvalue().splitlines() == tbl
+
+
+def test_fixed_width_two_line_header_rows():
+    tbl = [
+        'int32 float32      <U2 int64',
+        '    m                  m / s',
+        '          .2f               ',
+        '              C column      ',
+        '    a       b        c     d',
+        '----- ------- -------- -----',
+        '    1    1.00        c     4',
+        '    2    2.00        d     5',
+        '    3    3.00        e     6'
+    ]
+    header_rows = ["dtype", "unit", "format", "description", "name"]
+    dat = ascii.read(tbl, format='fixed_width_two_line', header_rows=header_rows)
+    out = StringIO()
+    ascii.write(dat, out, format='fixed_width_two_line', header_rows=header_rows)
+    assert out.getvalue().splitlines() == tbl
+
+
+def test_fixed_width_no_header_header_rows():
+    tbl = ['    1    1.00        c     4']
+    with pytest.raises(TypeError, match=r"unexpected keyword argument 'header_rows'"):
+        ascii.read(tbl, format='fixed_width_no_header', header_rows=["unit"])
