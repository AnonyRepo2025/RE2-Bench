diff --git a/astropy/io/fits/column.py b/astropy/io/fits/column.py
index 785ae12..bcc2886 100644
--- a/astropy/io/fits/column.py
+++ b/astropy/io/fits/column.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-13417/astropy/io/fits/column.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see PYFITS.rst
 
 import copy
@@ -1008,6 +1201,7 @@ class Column(NotifierMixin):
         return format, recformat
 
     @classmethod
+    @inspect_code
     def _verify_keywords(
         cls,
         name=None,
@@ -1212,7 +1406,11 @@ class Column(NotifierMixin):
                 )
 
             if dims_tuple:
-                if reduce(operator.mul, dims_tuple) > format.repeat:
+                if isinstance(recformat, _FormatP):
+                    # TDIMs have different meaning for VLA format,
+                    # no warning should be thrown
+                    msg = None
+                elif reduce(operator.mul, dims_tuple) > format.repeat:
                     msg = (
                         "The repeat count of the column format {!r} for column {!r} "
                         "is fewer than the number of elements per the TDIM "
@@ -1379,6 +1577,7 @@ class Column(NotifierMixin):
 
         return format, recformat
 
+    @inspect_code
     def _convert_to_valid_data_type(self, array):
         # Convert the format to a type we understand
         if isinstance(array, Delayed):
@@ -1388,8 +1587,7 @@ class Column(NotifierMixin):
         else:
             format = self.format
             dims = self._dims
-
-            if dims:
+            if dims and format.format not in "PQ":
                 shape = dims[:-1] if "A" in format else dims
                 shape = (len(array),) + shape
                 array = array.reshape(shape)
@@ -1699,6 +1897,7 @@ class ColDefs(NotifierMixin):
             return attr
         raise AttributeError(name)
 
+    @inspect_code
     @lazyproperty
     def dtype(self):
         # Note: This previously returned a dtype that just used the raw field
@@ -1720,7 +1919,9 @@ class ColDefs(NotifierMixin):
                 # filled with undefined values.
                 offsets.append(offsets[-1] + dt.itemsize)
 
-            if dim:
+            if dim and format_.format not in "PQ":
+                # Note: VLA array descriptors should not be reshaped
+                # as they are always of shape (2,)
                 if format_.format == "A":
                     dt = np.dtype((dt.char + str(dim[-1]), dim[:-1]))
                 else:
@@ -2108,6 +2309,7 @@ class _VLF(np.ndarray):
         self.max = obj.max
         self.element_dtype = obj.element_dtype
 
+    @inspect_code
     def __setitem__(self, key, value):
         """
         To make sure the new item has consistent data type to avoid
@@ -2123,7 +2325,9 @@ class _VLF(np.ndarray):
         else:
             value = np.array(value, dtype=self.element_dtype)
         np.ndarray.__setitem__(self, key, value)
-        self.max = max(self.max, len(value))
+        nelem = value.shape
+        len_value = np.prod(nelem)
+        self.max = max(self.max, len_value)
 
     def tolist(self):
         return [list(item) for item in super().tolist()]
@@ -2285,9 +2489,10 @@ def _makep(array, descr_output, format, nrows=None):
         else:
             data_output[idx] = np.array(rowval, dtype=format.dtype)
 
-        descr_output[idx, 0] = len(data_output[idx])
+        nelem = data_output[idx].shape
+        descr_output[idx, 0] = np.prod(nelem)
         descr_output[idx, 1] = _offset
-        _offset += len(data_output[idx]) * _nbytes
+        _offset += descr_output[idx, 0] * _nbytes
 
     return data_output
 
diff --git a/astropy/io/fits/fitsrec.py b/astropy/io/fits/fitsrec.py
index c4aed40..3f021cd 100644
--- a/astropy/io/fits/fitsrec.py
+++ b/astropy/io/fits/fitsrec.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-13417/astropy/io/fits/fitsrec.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see PYFITS.rst
 
 import copy
@@ -809,11 +1002,14 @@ class FITS_rec(np.recarray):
         _unwrapx(field, dummy, recformat.repeat)
         return dummy
 
+    @inspect_code
     def _convert_p(self, column, field, recformat):
         """Convert a raw table column of FITS P or Q format descriptors
         to a VLA column with the array data returned from the heap.
         """
 
+        if column.dim:
+            vla_shape = tuple(map(int, column.dim.strip("()").split(",")))
         dummy = _VLF([None] * len(self), dtype=recformat.dtype)
         raw_data = self._get_raw_data()
 
@@ -837,6 +1033,11 @@ class FITS_rec(np.recarray):
                 dt = np.dtype(recformat.dtype)
                 arr_len = count * dt.itemsize
                 dummy[idx] = raw_data[offset : offset + arr_len].view(dt)
+                if column.dim and len(vla_shape) > 1:
+                    # The VLA is reshaped consistently with TDIM instructions
+                    vla_dim = vla_shape[:-1]
+                    vla_dimlast = int(len(dummy[idx]) / np.prod(vla_dim))
+                    dummy[idx] = dummy[idx].reshape(vla_dim + (vla_dimlast,))
                 dummy[idx].dtype = dummy[idx].dtype.newbyteorder(">")
                 # Each array in the field may now require additional
                 # scaling depending on the other scaling parameters
@@ -892,6 +1093,7 @@ class FITS_rec(np.recarray):
 
         return dummy
 
+    @inspect_code
     def _convert_other(self, column, field, recformat):
         """Perform conversions on any other fixed-width column data types.
 
@@ -952,7 +1154,7 @@ class FITS_rec(np.recarray):
                     actual_nitems = 1
                 else:
                     actual_nitems = field.shape[1]
-                if nitems > actual_nitems:
+                if nitems > actual_nitems and not isinstance(recformat, _FormatP):
                     warnings.warn(
                         "TDIM{} value {:d} does not fit with the size of "
                         "the array items ({:d}).  TDIM{:d} will be ignored.".format(
@@ -1021,7 +1223,7 @@ class FITS_rec(np.recarray):
                 with suppress(UnicodeDecodeError):
                     field = decode_ascii(field)
 
-        if dim:
+        if dim and not isinstance(recformat, _FormatP):
             # Apply the new field item dimensions
             nitems = reduce(operator.mul, dim)
             if field.ndim > 1:
@@ -1107,6 +1309,7 @@ class FITS_rec(np.recarray):
 
         return (_str, _bool, _number, _scale, _zero, bscale, bzero, dim)
 
+    @inspect_code
     def _scale_back(self, update_heap_pointers=True):
         """
         Update the parent array, using the (latest) scaled array.
@@ -1140,7 +1343,7 @@ class FITS_rec(np.recarray):
                     # The VLA has potentially been updated, so we need to
                     # update the array descriptors
                     raw_field[:] = 0  # reset
-                    npts = [len(arr) for arr in self._converted[name]]
+                    npts = [np.prod(arr.shape) for arr in self._converted[name]]
 
                     raw_field[: len(npts), 0] = npts
                     raw_field[1:, 1] = (
diff --git a/astropy/io/fits/tests/test_table.py b/astropy/io/fits/tests/test_table.py
index 0916285..71af4fa 100644
--- a/astropy/io/fits/tests/test_table.py
+++ b/astropy/io/fits/tests/test_table.py
@@ -3270,6 +3270,72 @@ class TestVLATables(FitsTestCase):
                 [np.array([], dtype=np.int32), np.array([], dtype=np.int32)],
             )
 
+    def test_multidim_VLA_tables(self):
+        """
+        Check if multidimensional VLF are correctly write and read.
+        See https://github.com/astropy/astropy/issues/12860
+        and https://github.com/astropy/astropy/issues/7810
+        """
+        a = np.arange(5).reshape((5, 1))
+        b = np.arange(7).reshape((7, 1))
+        array = np.array([a, b], dtype=object)
+        col = fits.Column(name="test", format="PD(7)", dim="(1,7)", array=array)
+        fits.BinTableHDU.from_columns([col]).writeto(self.temp("test.fits"))
+
+        with fits.open(self.temp("test.fits")) as hdus:
+            assert hdus[1].columns.formats == ["PD(7)"]
+            np.array_equal(
+                hdus[1].data["test"],
+                [
+                    np.array([[0.0, 1.0, 2.0, 3.0, 4.0]]),
+                    np.array([[0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0]]),
+                ],
+            )
+
+        a = np.arange(10).reshape((5, 2))
+        b = np.arange(14).reshape((7, 2))
+        array = np.array([a, b], dtype=object)
+        col = fits.Column(name="test", format="PD(14)", dim="(2,7)", array=array)
+        fits.BinTableHDU.from_columns([col]).writeto(self.temp("test2.fits"))
+
+        with fits.open(self.temp("test2.fits")) as hdus:
+            assert hdus[1].columns.formats == ["PD(14)"]
+            np.array_equal(
+                hdus[1].data["test"],
+                [
+                    np.array(
+                        [[0.0, 1.0], [2.0, 3.0], [4.0, 5.0], [6.0, 7.0], [8.0, 9.0]]
+                    ),
+                    np.array(
+                        [
+                            [0.0, 1.0],
+                            [2.0, 3.0],
+                            [4.0, 5.0],
+                            [6.0, 7.0],
+                            [8.0, 9.0],
+                            [10.0, 11.0],
+                            [12.0, 13.0],
+                        ]
+                    ),
+                ],
+            )
+
+        a = np.arange(3).reshape((1, 3))
+        b = np.arange(6).reshape((2, 3))
+        array = np.array([a, b], dtype=object)
+        col = fits.Column(name="test", format="PD(6)", dim="(3,2)", array=array)
+        fits.BinTableHDU.from_columns([col]).writeto(self.temp("test3.fits"))
+
+        with fits.open(self.temp("test3.fits")) as hdus:
+            assert hdus[1].columns.formats == ["PD(6)"]
+            np.array_equal(
+                hdus[1].data["test"],
+                [
+                    np.array([[0.0, 1.0, 2.0]]),
+                    np.array([[0.0, 1.0, 2.0], [3.0, 4.0, 5.0]]),
+                ],
+            )
+
 
 # These are tests that solely test the Column and ColDefs interfaces and
 # related functionality without directly involving full tables; currently there
