diff --git a/astropy/table/table.py b/astropy/table/table.py
index ed36e89..a713a77 100644
--- a/astropy/table/table.py
+++ b/astropy/table/table.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-13842/astropy/table/table.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 import itertools
 import sys
@@ -1180,6 +1373,7 @@ class Table:
 
         self._init_from_cols(cols)
 
+    @inspect_code
     def _convert_data_to_col(self, data, copy=True, default_name=None, dtype=None, name=None):
         """
         Convert any allowed sequence data ``col`` to a column object that can be used
@@ -1264,8 +1458,10 @@ class Table:
 
         elif data_is_mixin:
             # Copy the mixin column attributes if they exist since the copy below
-            # may not get this attribute.
-            col = col_copy(data, copy_indices=self._init_indices) if copy else data
+            # may not get this attribute. If not copying, take a slice
+            # to ensure we get a new instance and we do not share metadata
+            # like info.
+            col = col_copy(data, copy_indices=self._init_indices) if copy else data[:]
             col.info.name = name
             return col
 
diff --git a/astropy/table/table_helpers.py b/astropy/table/table_helpers.py
index 4f39fb1..d7c482a 100644
--- a/astropy/table/table_helpers.py
+++ b/astropy/table/table_helpers.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-13842/astropy/table/table_helpers.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 
 """
@@ -168,16 +361,18 @@ class ArrayWrapper:
     """
     info = ArrayWrapperInfo()
 
-    def __init__(self, data):
-        self.data = np.array(data)
+    @inspect_code
+    def __init__(self, data, copy=True):
+        self.data = np.array(data, copy=copy)
         if 'info' in getattr(data, '__dict__', ()):
             self.info = data.info
 
+    @inspect_code
     def __getitem__(self, item):
         if isinstance(item, (int, np.integer)):
             out = self.data[item]
         else:
-            out = self.__class__(self.data[item])
+            out = self.__class__(self.data[item], copy=False)
             if 'info' in self.__dict__:
                 out.info = self.info
         return out
diff --git a/astropy/table/tests/test_mixin.py b/astropy/table/tests/test_mixin.py
index 2109788..7103478 100644
--- a/astropy/table/tests/test_mixin.py
+++ b/astropy/table/tests/test_mixin.py
@@ -438,38 +438,76 @@ def test_info_preserved_pickle_copy_init(mixin_cols):
                 assert getattr(m2.info, attr) == original
 
 
-def test_add_column(mixin_cols):
+def check_share_memory(col1, col2, copy):
+    """Check whether data attributes in col1 and col2 share memory.
+
+    If copy=True, this should not be the case for any, while
+    if copy=False, all should share memory.
+    """
+    if isinstance(col1, SkyCoord):
+        # For SkyCoord, .info does not access actual data by default,
+        # but rather attributes like .ra, which are copies.
+        map1 = col1.data.info._represent_as_dict()
+        map2 = col2.data.info._represent_as_dict()
+    else:
+        map1 = col1.info._represent_as_dict()
+        map2 = col2.info._represent_as_dict()
+
+    # Check array attributes only (in principle, could iterate on, e.g.,
+    # differentials in representations, but this is enough for table).
+    shared = [np.may_share_memory(v1, v2)
+              for (v1, v2) in zip(map1.values(), map2.values())
+              if isinstance(v1, np.ndarray) and v1.shape]
+    if copy:
+        assert not any(shared)
+    else:
+        assert all(shared)
+
+
+@pytest.mark.parametrize('copy', [True, False])
+def test_add_column(mixin_cols, copy):
     """
-    Test that adding a column preserves values and attributes
+    Test that adding a column preserves values and attributes.
+    For copy=True, the data should be independent;
+    for copy=False, the data should be shared, but the instance independent.
     """
     attrs = ('name', 'unit', 'dtype', 'format', 'description', 'meta')
     m = mixin_cols['m']
     assert m.info.name is None
 
-    # Make sure adding column in various ways doesn't touch
-    t = QTable([m], names=['a'])
+    # Make sure adding column in various ways doesn't touch info.
+    t = QTable([m], names=['a'], copy=copy)
     assert m.info.name is None
+    check_share_memory(m, t['a'], copy=copy)
 
     t['new'] = m
     assert m.info.name is None
+    check_share_memory(m, t['new'], copy=True)
 
     m.info.name = 'm'
     m.info.format = '{0}'
     m.info.description = 'd'
     m.info.meta = {'a': 1}
-    t = QTable([m])
+    t = QTable([m], copy=copy)
+    assert t.colnames == ['m']
+    check_share_memory(m, t['m'], copy=copy)
+
+    t = QTable([m], names=['m1'], copy=copy)
+    assert m.info.name == 'm'
+    assert t.colnames == ['m1']
+    check_share_memory(m, t['m1'], copy=copy)
 
     # Add columns m2, m3, m4 by two different methods and test expected equality
     t['m2'] = m
+    check_share_memory(m, t['m2'], copy=True)
     m.info.name = 'm3'
-    t.add_columns([m], copy=True)
-    m.info.name = 'm4'
-    t.add_columns([m], copy=False)
-    for name in ('m2', 'm3', 'm4'):
+    t.add_columns([m], copy=copy)
+    check_share_memory(m, t['m3'], copy=copy)
+    for name in ('m2', 'm3'):
         assert_table_name_col_equal(t, name, m)
         for attr in attrs:
             if attr != 'name':
-                assert getattr(t['m'].info, attr) == getattr(t[name].info, attr)
+                assert getattr(t['m1'].info, attr) == getattr(t[name].info, attr)
     # Also check that one can set using a scalar.
     s = m[0]
     if type(s) is type(m) and 'info' in s.__dict__:
@@ -477,18 +515,20 @@ def test_add_column(mixin_cols):
         # are a different class than the real array, or where info is not copied.
         t['s'] = m[0]
         assert_table_name_col_equal(t, 's', m[0])
+        check_share_memory(m, t['s'], copy=True)
         for attr in attrs:
             if attr != 'name':
-                assert getattr(t['m'].info, attr) == getattr(t['s'].info, attr)
+                assert getattr(t['m1'].info, attr) == getattr(t['s'].info, attr)
 
     # While we're add it, also check a length-1 table.
-    t = QTable([m[1:2]], names=['m'])
+    t = QTable([m[1:2]], names=['m'], copy=copy)
+    check_share_memory(m, t['m'], copy=copy)
     if type(s) is type(m) and 'info' in s.__dict__:
         t['s'] = m[0]
         assert_table_name_col_equal(t, 's', m[0])
         for attr in attrs:
             if attr != 'name':
-                assert getattr(t['m'].info, attr) == getattr(t['s'].info, attr)
+                assert getattr(t['m1'].info, attr) == getattr(t['s'].info, attr)
 
 
 def test_vstack():
@@ -852,8 +892,9 @@ def test_skycoord_with_velocity():
     assert skycoord_equal(t2['col0'], sc)
 
 
+@pytest.mark.parametrize('copy', [True, False])
 @pytest.mark.parametrize('table_cls', [Table, QTable])
-def test_ensure_input_info_is_unchanged(table_cls):
+def test_ensure_input_info_is_unchanged(table_cls, copy):
     """If a mixin input to a table has no info, it should stay that way.
 
     This since having 'info' slows down slicing, etc.
@@ -861,11 +902,11 @@ def test_ensure_input_info_is_unchanged(table_cls):
     """
     q = [1, 2] * u.m
     assert 'info' not in q.__dict__
-    t = table_cls([q], names=['q'])
+    t = table_cls([q], names=['q'], copy=copy)
     assert 'info' not in q.__dict__
-    t = table_cls([q])
+    t = table_cls([q], copy=copy)
     assert 'info' not in q.__dict__
-    t = table_cls({'q': q})
+    t = table_cls({'q': q}, copy=copy)
     assert 'info' not in q.__dict__
     t['q2'] = q
     assert 'info' not in q.__dict__
