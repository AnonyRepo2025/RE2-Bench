diff --git a/sympy/functions/special/polynomials.py b/sympy/functions/special/polynomials.py
index 361ba77..d9c3924 100644
--- a/sympy/functions/special/polynomials.py
+++ b/sympy/functions/special/polynomials.py
@@ -7,6 +7,199 @@
 """
 
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-17010/sympy/functions/special/polynomials.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 from sympy.core import Rational
 from sympy.core.function import Function, ArgumentIndexError
@@ -590,6 +783,7 @@ class chebyshevu(OrthogonalPolynomial):
     _ortho_poly = staticmethod(chebyshevu_poly)
 
     @classmethod
+    @inspect_code
     def eval(cls, n, x):
         if not n.is_Number:
             # Symbolic result U_n(x)
@@ -601,7 +795,7 @@ def eval(cls, n, x):
                 if n == S.NegativeOne:
                     # n can not be -1 here
                     return S.Zero
-                else:
+                elif not (-n - 2).could_extract_minus_sign():
                     return -chebyshevu(-n - 2, x)
             # We can evaluate for some special values of x
             if x == S.Zero:
@@ -776,6 +970,7 @@ class legendre(OrthogonalPolynomial):
     _ortho_poly = staticmethod(legendre_poly)
 
     @classmethod
+    @inspect_code
     def eval(cls, n, x):
         if not n.is_Number:
             # Symbolic result L_n(x)
@@ -783,7 +978,7 @@ def eval(cls, n, x):
             if x.could_extract_minus_sign():
                 return S.NegativeOne**n * legendre(n, -x)
             # L_{-n}(x)  --->  L_{n-1}(x)
-            if n.could_extract_minus_sign():
+            if n.could_extract_minus_sign() and not(-n - 1).could_extract_minus_sign():
                 return legendre(-n - S.One, x)
             # We can evaluate for some special values of x
             if x == S.Zero:
@@ -1087,13 +1282,16 @@ class laguerre(OrthogonalPolynomial):
     _ortho_poly = staticmethod(laguerre_poly)
 
     @classmethod
+    @inspect_code
     def eval(cls, n, x):
+        if n.is_integer is False:
+            raise ValueError("Error: n should be an integer.")
         if not n.is_Number:
             # Symbolic result L_n(x)
             # L_{n}(-x)  --->  exp(-x) * L_{-n-1}(x)
             # L_{-n}(x)  --->  exp(x) * L_{n-1}(-x)
-            if n.could_extract_minus_sign():
-                return exp(x) * laguerre(n - 1, -x)
+            if n.could_extract_minus_sign() and not(-n - 1).could_extract_minus_sign():
+                return exp(x)*laguerre(-n - 1, -x)
             # We can evaluate for some special values of x
             if x == S.Zero:
                 return S.One
@@ -1102,10 +1300,8 @@ def eval(cls, n, x):
             elif x == S.Infinity:
                 return S.NegativeOne**n * S.Infinity
         else:
-            # n is a given fixed integer, evaluate into polynomial
             if n.is_negative:
-                raise ValueError(
-                    "The index n must be nonnegative integer (got %r)" % n)
+                return exp(x)*laguerre(-n - 1, -x)
             else:
                 return cls._eval_at_order(n, x)
 
@@ -1120,11 +1316,14 @@ def fdiff(self, argindex=2):
         else:
             raise ArgumentIndexError(self, argindex)
 
+    @inspect_code
     def _eval_rewrite_as_polynomial(self, n, x, **kwargs):
         from sympy import Sum
         # Make sure n \in N_0
-        if n.is_negative or n.is_integer is False:
-            raise ValueError("Error: n should be a non-negative integer.")
+        if n.is_negative:
+            return exp(x) * self._eval_rewrite_as_polynomial(-n - 1, -x, **kwargs)
+        if n.is_integer is False:
+            raise ValueError("Error: n should be an integer.")
         k = Dummy("k")
         kern = RisingFactorial(-n, k) / factorial(k)**2 * x**k
         return Sum(kern, (k, 0, n))
@@ -1193,7 +1392,7 @@ class assoc_laguerre(OrthogonalPolynomial):
     References
     ==========
 
-    .. [1] https://en.wikipedia.org/wiki/Laguerre_polynomial#Assoc_laguerre_polynomials
+    .. [1] https://en.wikipedia.org/wiki/Laguerre_polynomial#Generalized_Laguerre_polynomials
     .. [2] http://mathworld.wolfram.com/AssociatedLaguerrePolynomial.html
     .. [3] http://functions.wolfram.com/Polynomials/LaguerreL/
     .. [4] http://functions.wolfram.com/Polynomials/LaguerreL3/
diff --git a/sympy/functions/special/tests/test_spec_polynomials.py b/sympy/functions/special/tests/test_spec_polynomials.py
index b6c235c..dd42547 100644
--- a/sympy/functions/special/tests/test_spec_polynomials.py
+++ b/sympy/functions/special/tests/test_spec_polynomials.py
@@ -8,7 +8,8 @@
 from sympy.core.compatibility import range
 from sympy.core.expr import unchanged
 from sympy.core.function import ArgumentIndexError
-from sympy.utilities.pytest import raises, skip
+from sympy.utilities.pytest import raises
+
 
 x = Symbol('x')
 
@@ -154,12 +155,14 @@ def test_legendre():
 
     X = legendre(n, x)
     assert isinstance(X, legendre)
+    assert unchanged(legendre, n, x)
 
     assert legendre(n, 0) == sqrt(pi)/(gamma(S(1)/2 - n/2)*gamma(n/2 + 1))
     assert legendre(n, 1) == 1
     assert legendre(n, oo) == oo
     assert legendre(-n, x) == legendre(n - 1, x)
     assert legendre(n, -x) == (-1)**n*legendre(n, x)
+    assert unchanged(legendre, -n + k, x)
 
     assert conjugate(legendre(n, x)) == legendre(n, conjugate(x))
 
@@ -244,6 +247,7 @@ def test_chebyshev():
     n = Symbol("n")
     X = chebyshevt(n, x)
     assert isinstance(X, chebyshevt)
+    assert unchanged(chebyshevt, n, x)
     assert chebyshevt(n, -x) == (-1)**n*chebyshevt(n, x)
     assert chebyshevt(-n, x) == chebyshevt(n, x)
 
@@ -258,8 +262,10 @@ def test_chebyshev():
     X = chebyshevu(n, x)
     assert isinstance(X, chebyshevu)
 
+    y = Symbol('y')
     assert chebyshevu(n, -x) == (-1)**n*chebyshevu(n, x)
     assert chebyshevu(-n, x) == -chebyshevu(n - 2, x)
+    assert unchanged(chebyshevu, -n + y, x)
 
     assert chebyshevu(n, 0) == cos(pi*n/2)
     assert chebyshevu(n, 1) == n + 1
@@ -312,15 +318,14 @@ def test_hermite():
 
 def test_laguerre():
     n = Symbol("n")
+    m = Symbol("m", negative=True)
 
     # Laguerre polynomials:
     assert laguerre(0, x) == 1
     assert laguerre(1, x) == -x + 1
     assert laguerre(2, x) == x**2/2 - 2*x + 1
     assert laguerre(3, x) == -x**3/6 + 3*x**2/2 - 3*x + 1
-
-    X = laguerre(Rational(5,2), x)
-    assert isinstance(X, laguerre)
+    assert laguerre(-2, x) == (x + 1)*exp(x)
 
     X = laguerre(n, x)
     assert isinstance(X, laguerre)
@@ -335,21 +340,23 @@ def test_laguerre():
 
     assert laguerre(n, x).rewrite("polynomial").dummy_eq(
         Sum(x**_k*RisingFactorial(-n, _k)/factorial(_k)**2, (_k, 0, n)))
+    assert laguerre(m, x).rewrite("polynomial").dummy_eq(
+        exp(x)*Sum((-x)**_k*RisingFactorial(m + 1, _k)/factorial(_k)**2,
+            (_k, 0, -m - 1)))
 
     assert diff(laguerre(n, x), x) == -assoc_laguerre(n - 1, 1, x)
 
+    k = Symbol('k')
+    assert laguerre(-n, x) == exp(x)*laguerre(n - 1, -x)
+    assert laguerre(-3, x) == exp(x)*laguerre(2, -x)
+    assert unchanged(laguerre, -n + k, x)
+
     raises(ValueError, lambda: laguerre(-2.1, x))
+    raises(ValueError, lambda: laguerre(Rational(5, 2), x))
     raises(ArgumentIndexError, lambda: laguerre(n, x).fdiff(1))
     raises(ArgumentIndexError, lambda: laguerre(n, x).fdiff(3))
 
 
-def test_legendre_fail():
-    skip("Infinite recursion kills Travis")
-    n = Symbol("n")
-    assert laguerre(-n, x) == exp(x)*laguerre(n-1, -x)
-    assert laguerre(-3, x) == exp(x)*laguerre(2, -x)
-
-
 def test_assoc_laguerre():
     n = Symbol("n")
     m = Symbol("m")
