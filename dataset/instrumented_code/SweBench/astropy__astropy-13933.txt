diff --git a/astropy/coordinates/angles.py b/astropy/coordinates/angles.py
index 8216843..4069e6b 100644
--- a/astropy/coordinates/angles.py
+++ b/astropy/coordinates/angles.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-13933/astropy/coordinates/angles.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 
 """
@@ -5,6 +198,7 @@ This module contains the fundamental classes used for representing
 coordinates in astropy.
 """
 
+import functools
 from collections import namedtuple
 
 import numpy as np
@@ -156,8 +350,9 @@ class Angle(u.SpecificTypeQuantity):
             raise u.UnitsError(f"Can not parse '{angle}' as unit '{unit}'")
 
     @staticmethod
+    @inspect_code
     def _convert_unit_to_angle_unit(unit):
-        return u.hourangle if unit is u.hour else unit
+        return u.hourangle if unit == u.hour else unit
 
     def _set_unit(self, unit):
         super()._set_unit(self._convert_unit_to_angle_unit(unit))
@@ -198,6 +393,7 @@ class Angle(u.SpecificTypeQuantity):
         return signed_dms_tuple(np.sign(self.degree),
                                 *form.degrees_to_dms(np.abs(self.degree)))
 
+    @inspect_code
     def to_string(self, unit=None, decimal=False, sep='fromunit',
                   precision=None, alwayssign=False, pad=False,
                   fields=3, format=None):
@@ -211,8 +407,10 @@ class Angle(u.SpecificTypeQuantity):
             used.
 
         decimal : bool, optional
-            If `True`, a decimal representation will be used, otherwise
-            the returned string will be in sexagesimal form.
+            If `False`, the returned string will be in sexagesimal form
+            if possible (for units of degrees or hourangle).  If `True`,
+            a decimal representation will be used. In that case, no unit
+            will be appended if ``format`` is not explicitly given.
 
         sep : str, optional
             The separator between numbers in a sexagesimal
@@ -274,7 +472,7 @@ class Angle(u.SpecificTypeQuantity):
             unit = self._convert_unit_to_angle_unit(u.Unit(unit))
 
         separators = {
-            None: {
+            'generic': {
                 u.degree: 'dms',
                 u.hourangle: 'hms'},
             'latex': {
@@ -287,75 +485,31 @@ class Angle(u.SpecificTypeQuantity):
         # 'latex_inline' provides no functionality beyond what 'latex' offers,
         # but it should be implemented to avoid ValueErrors in user code.
         separators['latex_inline'] = separators['latex']
-
-        if sep == 'fromunit':
-            if format not in separators:
-                raise ValueError(f"Unknown format '{format}'")
-            seps = separators[format]
-            if unit in seps:
-                sep = seps[unit]
+        # Default separators are as for generic.
+        separators[None] = separators['generic']
 
         # Create an iterator so we can format each element of what
         # might be an array.
-        if unit is u.degree:
-            if decimal:
-                values = self.degree
-                if precision is not None:
-                    func = ("{0:0." + str(precision) + "f}").format
-                else:
-                    func = '{:g}'.format
-            else:
-                if sep == 'fromunit':
-                    sep = 'dms'
-                values = self.degree
-                func = lambda x: form.degrees_to_string(
-                    x, precision=precision, sep=sep, pad=pad,
-                    fields=fields)
-
-        elif unit is u.hourangle:
-            if decimal:
-                values = self.hour
-                if precision is not None:
-                    func = ("{0:0." + str(precision) + "f}").format
-                else:
-                    func = '{:g}'.format
-            else:
-                if sep == 'fromunit':
-                    sep = 'hms'
-                values = self.hour
-                func = lambda x: form.hours_to_string(
-                    x, precision=precision, sep=sep, pad=pad,
-                    fields=fields)
-
-        elif unit.is_equivalent(u.radian):
-            if decimal:
-                values = self.to_value(unit)
-                if precision is not None:
-                    func = ("{0:1." + str(precision) + "f}").format
-                else:
-                    func = "{:g}".format
-            elif sep == 'fromunit':
-                values = self.to_value(unit)
+        if not decimal and (unit_is_deg := unit == u.degree
+                            or unit == u.hourangle):
+            # Sexagesimal.
+            if sep == 'fromunit':
+                if format not in separators:
+                    raise ValueError(f"Unknown format '{format}'")
+                sep = separators[format][unit]
+            func = functools.partial(
+                form.degrees_to_string if unit_is_deg else form.hours_to_string,
+                precision=precision, sep=sep, pad=pad, fields=fields)
+        else:
+            if sep != 'fromunit':
+                raise ValueError(f"'{unit}' can not be represented in sexagesimal notation")
+            func = ("{:g}" if precision is None else f"{{0:0.{precision}f}}").format
+            if not (decimal and format is None):  # Don't add unit by default for decimal.
                 unit_string = unit.to_string(format=format)
                 if format == 'latex' or format == 'latex_inline':
                     unit_string = unit_string[1:-1]
-
-                if precision is not None:
-                    def plain_unit_format(val):
-                        return ("{0:0." + str(precision) + "f}{1}").format(
-                            val, unit_string)
-                    func = plain_unit_format
-                else:
-                    def plain_unit_format(val):
-                        return f"{val:g}{unit_string}"
-                    func = plain_unit_format
-            else:
-                raise ValueError(
-                    f"'{unit.name}' can not be represented in sexagesimal notation")
-
-        else:
-            raise u.UnitsError(
-                "The unit value provided is not an angular unit.")
+                format_func = func
+                func = lambda x: format_func(x) + unit_string
 
         def do_format(val):
             # Check if value is not nan to avoid ValueErrors when turning it into
@@ -370,6 +524,7 @@ class Angle(u.SpecificTypeQuantity):
             s = f"{val}"
             return s
 
+        values = self.to_value(unit)
         format_ufunc = np.vectorize(do_format, otypes=['U'])
         result = format_ufunc(values)
 
@@ -570,6 +725,7 @@ class Latitude(Angle):
         self._validate_angles()
         return self
 
+    @inspect_code
     def _validate_angles(self, angles=None):
         """Check that angles are between -90 and 90 degrees.
         If not given, the check is done on the object itself"""
@@ -581,6 +737,8 @@ class Latitude(Angle):
         if angles is None:
             angles = self
 
+        # For speed, compare using "is", which is not strictly guaranteed to hold,
+        # but if it doesn't we'll just convert correctly in the 'else' clause.
         if angles.unit is u.deg:
             limit = 90
         elif angles.unit is u.rad:
diff --git a/astropy/coordinates/tests/test_angles.py b/astropy/coordinates/tests/test_angles.py
index fb40cc4..c189918 100644
--- a/astropy/coordinates/tests/test_angles.py
+++ b/astropy/coordinates/tests/test_angles.py
@@ -1,6 +1,7 @@
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 """Test initialization and other aspects of Angle and subclasses"""
 
+import pickle
 import threading
 
 import numpy as np
@@ -77,6 +78,7 @@ def test_create_angles():
     a22 = Angle("3.6h", unit=u.hour)
     a23 = Angle("- 3h", unit=u.hour)
     a24 = Angle("+ 3h", unit=u.hour)
+    a25 = Angle(3., unit=u.hour**1)
 
     # ensure the above angles that should match do
     assert a1 == a2 == a3 == a4 == a5 == a6 == a8 == a18 == a19 == a20
@@ -90,6 +92,7 @@ def test_create_angles():
     assert a11 == a12 == a13 == a14
     assert a21 == a22
     assert a23 == -a24
+    assert a24 == a25
 
     # check for illegal ranges / values
     with pytest.raises(IllegalSecondError):
@@ -353,6 +356,9 @@ def test_angle_formatting():
     assert angle2.to_string(unit=u.hour, pad=True) == '-01h14m04.444404s'
     assert angle.to_string(unit=u.radian, decimal=True) == '-0.0215473'
 
+    # We should recognize units that are equal but not identical
+    assert angle.to_string(unit=u.hour**1) == '-0h04m56.2962936s'
+
 
 def test_to_string_vector():
     # Regression test for the fact that vectorize doesn't work with Numpy 1.6
@@ -1142,3 +1148,16 @@ def test_latitude_out_of_limits(value, dtype):
     """
     with pytest.raises(ValueError, match=r"Latitude angle\(s\) must be within.*"):
         Latitude(value, u.rad, dtype=dtype)
+
+
+def test_angle_pickle_to_string():
+    """
+    Ensure that after pickling we can still do to_string on hourangle.
+
+    Regression test for gh-13923.
+    """
+    angle = Angle(0.25 * u.hourangle)
+    expected = angle.to_string()
+    via_pickle = pickle.loads(pickle.dumps(angle))
+    via_pickle_string = via_pickle.to_string()  # This used to fail.
+    assert via_pickle_string == expected
diff --git a/astropy/coordinates/tests/test_formatting.py b/astropy/coordinates/tests/test_formatting.py
index 235a169..df87019 100644
--- a/astropy/coordinates/tests/test_formatting.py
+++ b/astropy/coordinates/tests/test_formatting.py
@@ -2,7 +2,7 @@
 Tests the Angle string formatting capabilities.  SkyCoord formatting is in
 test_sky_coord
 """
-
+import pytest
 
 from astropy import units as u
 from astropy.coordinates.angles import Angle
@@ -56,6 +56,9 @@ def test_to_string_decimal():
     assert angle3.to_string(decimal=True, precision=1) == '4.0'
     assert angle3.to_string(decimal=True, precision=0) == '4'
 
+    with pytest.raises(ValueError, match='sexagesimal notation'):
+        angle3.to_string(decimal=True, sep='abc')
+
 
 def test_to_string_formats():
     a = Angle(1.113355, unit=u.deg)
@@ -76,6 +79,28 @@ def test_to_string_formats():
     assert a.to_string(format='unicode') == '1.11336rad'
 
 
+def test_to_string_decimal_formats():
+    angle1 = Angle(2., unit=u.degree)
+
+    assert angle1.to_string(decimal=True, format='generic') == '2deg'
+    assert angle1.to_string(decimal=True, format='latex') == '$2\\mathrm{{}^{\\circ}}$'
+    assert angle1.to_string(decimal=True, format='unicode') == '2°'
+
+    angle2 = Angle(3., unit=u.hourangle)
+    assert angle2.to_string(decimal=True, format='generic') == '3hourangle'
+    assert angle2.to_string(decimal=True, format='latex') == '$3\\mathrm{{}^{h}}$'
+    assert angle2.to_string(decimal=True, format='unicode') == '3ʰ'
+
+    angle3 = Angle(4., unit=u.radian)
+
+    assert angle3.to_string(decimal=True, format='generic') == '4rad'
+    assert angle3.to_string(decimal=True, format='latex') == '$4\\mathrm{rad}$'
+    assert angle3.to_string(decimal=True, format='unicode') == '4rad'
+
+    with pytest.raises(ValueError, match='Unknown format'):
+        angle3.to_string(decimal=True, format='myformat')
+
+
 def test_to_string_fields():
     a = Angle(1.113355, unit=u.deg)
     assert a.to_string(fields=1) == r'1d'
diff --git a/astropy/visualization/wcsaxes/formatter_locator.py b/astropy/visualization/wcsaxes/formatter_locator.py
index 9a37f53..042c43a 100644
--- a/astropy/visualization/wcsaxes/formatter_locator.py
+++ b/astropy/visualization/wcsaxes/formatter_locator.py
@@ -394,14 +394,7 @@ class AngleFormatterLocator(BaseFormatterLocator):
             is_latex = format == 'latex' or (format == 'auto' and rcParams['text.usetex'])
 
             if decimal:
-                # At the moment, the Angle class doesn't have a consistent way
-                # to always convert angles to strings in decimal form with
-                # symbols for units (instead of e.g 3arcsec). So as a workaround
-                # we take advantage of the fact that Angle.to_string converts
-                # the unit to a string manually when decimal=False and the unit
-                # is not strictly u.degree or u.hourangle
                 if self.show_decimal_unit:
-                    decimal = False
                     sep = 'fromunit'
                     if is_latex:
                         fmt = 'latex'
@@ -409,10 +402,10 @@ class AngleFormatterLocator(BaseFormatterLocator):
                         if unit is u.hourangle:
                             fmt = 'unicode'
                         else:
-                            fmt = None
+                            fmt = 'generic'
                     unit = CUSTOM_UNITS.get(unit, unit)
                 else:
-                    sep = None
+                    sep = 'fromunit'
                     fmt = None
             elif self.sep is not None:
                 sep = self.sep
