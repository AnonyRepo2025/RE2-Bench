diff --git a/sympy/diffgeom/diffgeom.py b/sympy/diffgeom/diffgeom.py
index de372f3..c6af32f 100644
--- a/sympy/diffgeom/diffgeom.py
+++ b/sympy/diffgeom/diffgeom.py
@@ -1,4 +1,197 @@
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-12812/sympy/diffgeom/diffgeom.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 from itertools import permutations
 
@@ -12,6 +205,7 @@
 from sympy.core.compatibility import reduce
 from sympy.combinatorics import Permutation
 
+
 # TODO you are a bit excessive in the use of Dummies
 # TODO dummy point, literal field
 # TODO too often one needs to call doit or simplify on the output, check the
@@ -563,6 +757,7 @@ def __new__(cls, coord_sys, index):
         obj._index = index
         return obj
 
+    @inspect_code
     def __call__(self, scalar_field):
         """Apply on a scalar field.
 
@@ -574,6 +769,9 @@ def __call__(self, scalar_field):
         if covariant_order(scalar_field) or contravariant_order(scalar_field):
             raise ValueError('Only scalar fields can be supplied as arguments to vector fields.')
 
+        if scalar_field is None:
+            return self
+
         base_scalars = list(scalar_field.atoms(BaseScalarField))
 
         # First step: e_x(x+r**2) -> e_x(x) + 2*r*e_x(r)
@@ -789,10 +987,10 @@ class TensorProduct(Expr):
     """Tensor product of forms.
 
     The tensor product permits the creation of multilinear functionals (i.e.
-    higher order tensors) out of lower order forms (e.g. 1-forms). However, the
-    higher tensors thus created lack the interesting features provided by the
-    other type of product, the wedge product, namely they are not antisymmetric
-    and hence are not form fields.
+    higher order tensors) out of lower order fields (e.g. 1-forms and vector
+    fields). However, the higher tensors thus created lack the interesting
+    features provided by the other type of product, the wedge product, namely
+    they are not antisymmetric and hence are not form fields.
 
     Examples
     ========
@@ -810,6 +1008,11 @@ class TensorProduct(Expr):
     0
     >>> TensorProduct(R2.dx, R2.x*R2.dy)(R2.x*R2.e_x, R2.e_y)
     x**2
+    >>> TensorProduct(R2.e_x, R2.e_y)(R2.x**2, R2.y**2)
+    4*x*y
+    >>> TensorProduct(R2.e_y, R2.dx)(R2.y)
+    dx
+
 
     You can nest tensor products.
 
@@ -832,15 +1035,14 @@ class TensorProduct(Expr):
     3*dy
 
     """
+    @inspect_code
     def __new__(cls, *args):
-        if any(contravariant_order(a) for a in args):
-            raise ValueError('A vector field was supplied as an argument to TensorProduct.')
-        scalar = Mul(*[m for m in args if covariant_order(m) == 0])
-        forms = [m for m in args if covariant_order(m)]
-        if forms:
-            if len(forms) == 1:
-                return scalar*forms[0]
-            return scalar*super(TensorProduct, cls).__new__(cls, *forms)
+        scalar = Mul(*[m for m in args if covariant_order(m) + contravariant_order(m) == 0])
+        multifields = [m for m in args if covariant_order(m) + contravariant_order(m)]
+        if multifields:
+            if len(multifields) == 1:
+                return scalar*multifields[0]
+            return scalar*super(TensorProduct, cls).__new__(cls, *multifields)
         else:
             return scalar
 
@@ -848,25 +1050,25 @@ def __init__(self, *args):
         super(TensorProduct, self).__init__()
         self._args = args
 
-    def __call__(self, *v_fields):
-        """Apply on a list of vector_fields.
+    def __call__(self, *fields):
+        """Apply on a list of fields.
 
-        If the number of vector fields supplied is not equal to the order of
-        the form field the list of arguments is padded with ``None``'s.
+        If the number of input fields supplied is not equal to the order of
+        the tensor product field, the list of arguments is padded with ``None``'s.
 
         The list of arguments is divided in sublists depending on the order of
         the forms inside the tensor product. The sublists are provided as
         arguments to these forms and the resulting expressions are given to the
         constructor of ``TensorProduct``.
         """
-        tot_order = covariant_order(self)
-        tot_args = len(v_fields)
+        tot_order = covariant_order(self) + contravariant_order(self)
+        tot_args = len(fields)
         if tot_args != tot_order:
-            v_fields = list(v_fields) + [None]*(tot_order - tot_args)
-        orders = [covariant_order(f) for f in self._args]
+            fields = list(fields) + [None]*(tot_order - tot_args)
+        orders = [covariant_order(f) + contravariant_order(f) for f in self._args]
         indices = [sum(orders[:i + 1]) for i in range(len(orders) - 1)]
-        v_fields = [v_fields[i:j] for i, j in zip([0] + indices, indices + [None])]
-        multipliers = [t[0].rcall(*t[1]) for t in zip(self._args, v_fields)]
+        fields = [fields[i:j] for i, j in zip([0] + indices, indices + [None])]
+        multipliers = [t[0].rcall(*t[1]) for t in zip(self._args, fields)]
         return TensorProduct(*multipliers)
 
     def _latex(self, printer, *args):
@@ -896,6 +1098,8 @@ class WedgeProduct(TensorProduct):
     -1
     >>> WedgeProduct(R2.dx, R2.x*R2.dy)(R2.x*R2.e_x, R2.e_y)
     x**2
+    >>> WedgeProduct(R2.e_x,R2.e_y)(R2.y,None)
+    -e_x
 
     You can nest wedge products.
 
@@ -906,15 +1110,15 @@ class WedgeProduct(TensorProduct):
     """
     # TODO the calculation of signatures is slow
     # TODO you do not need all these permutations (neither the prefactor)
-    def __call__(self, *vector_fields):
+    def __call__(self, *fields):
         """Apply on a list of vector_fields.
 
         The expression is rewritten internally in terms of tensor products and evaluated."""
-        orders = (covariant_order(e) for e in self.args)
+        orders = (covariant_order(e) + contravariant_order(e) for e in self.args)
         mul = 1/Mul(*(factorial(o) for o in orders))
-        perms = permutations(vector_fields)
+        perms = permutations(fields)
         perms_par = (Permutation(
-            p).signature() for p in permutations(list(range(len(vector_fields)))))
+            p).signature() for p in permutations(list(range(len(fields)))))
         tensor_prod = TensorProduct(*self.args)
         return mul*Add(*[tensor_prod(*p[0])*p[1] for p in zip(perms, perms_par)])
 
@@ -1303,6 +1507,7 @@ def dummyfy(args, exprs):
 ###############################################################################
 # Helpers
 ###############################################################################
+@inspect_code
 def contravariant_order(expr, _strict=False):
     """Return the contravariant order of an expression.
 
@@ -1340,6 +1545,8 @@ def contravariant_order(expr, _strict=False):
         return 0
     elif isinstance(expr, BaseVectorField):
         return 1
+    elif isinstance(expr, TensorProduct):
+        return sum(contravariant_order(a) for a in expr.args)
     elif not _strict or expr.atoms(BaseScalarField):
         return 0
     else:  # If it does not contain anything related to the diffgeom module and it is _strict
diff --git a/sympy/diffgeom/tests/test_diffgeom.py b/sympy/diffgeom/tests/test_diffgeom.py
index 486f2f6..e5bc603 100644
--- a/sympy/diffgeom/tests/test_diffgeom.py
+++ b/sympy/diffgeom/tests/test_diffgeom.py
@@ -73,11 +73,31 @@ def test_differential():
 def test_products():
     assert TensorProduct(
         R2.dx, R2.dy)(R2.e_x, R2.e_y) == R2.dx(R2.e_x)*R2.dy(R2.e_y) == 1
-    assert WedgeProduct(R2.dx, R2.dy)(R2.e_x, R2.e_y) == 1
     assert TensorProduct(R2.dx, R2.dy)(None, R2.e_y) == R2.dx
     assert TensorProduct(R2.dx, R2.dy)(R2.e_x, None) == R2.dy
     assert TensorProduct(R2.dx, R2.dy)(R2.e_x) == R2.dy
     assert TensorProduct(R2.x, R2.dx) == R2.x*R2.dx
+    assert TensorProduct(
+        R2.e_x, R2.e_y)(R2.x, R2.y) == R2.e_x(R2.x) * R2.e_y(R2.y) == 1
+    assert TensorProduct(R2.e_x, R2.e_y)(None, R2.y) == R2.e_x
+    assert TensorProduct(R2.e_x, R2.e_y)(R2.x, None) == R2.e_y
+    assert TensorProduct(R2.e_x, R2.e_y)(R2.x) == R2.e_y
+    assert TensorProduct(R2.x, R2.e_x) == R2.x * R2.e_x
+    assert TensorProduct(
+        R2.dx, R2.e_y)(R2.e_x, R2.y) == R2.dx(R2.e_x) * R2.e_y(R2.y) == 1
+    assert TensorProduct(R2.dx, R2.e_y)(None, R2.y) == R2.dx
+    assert TensorProduct(R2.dx, R2.e_y)(R2.e_x, None) == R2.e_y
+    assert TensorProduct(R2.dx, R2.e_y)(R2.e_x) == R2.e_y
+    assert TensorProduct(R2.x, R2.e_x) == R2.x * R2.e_x
+    assert TensorProduct(
+        R2.e_x, R2.dy)(R2.x, R2.e_y) == R2.e_x(R2.x) * R2.dy(R2.e_y) == 1
+    assert TensorProduct(R2.e_x, R2.dy)(None, R2.e_y) == R2.e_x
+    assert TensorProduct(R2.e_x, R2.dy)(R2.x, None) == R2.dy
+    assert TensorProduct(R2.e_x, R2.dy)(R2.x) == R2.dy
+    assert TensorProduct(R2.e_y,R2.e_x)(R2.x**2 + R2.y**2,R2.x**2 + R2.y**2) == 4*R2.x*R2.y
+
+    assert WedgeProduct(R2.dx, R2.dy)(R2.e_x, R2.e_y) == 1
+    assert WedgeProduct(R2.e_x, R2.e_y)(R2.x, R2.y) == 1
 
 
 def test_lie_derivative():
@@ -126,6 +146,11 @@ def test_helpers_and_coordinate_dependent():
     twoform_not_sym = TensorProduct(R2.dx, R2.dx) + TensorProduct(R2.dx, R2.dy)
     twoform_not_TP = WedgeProduct(R2.dx, R2.dy)
 
+    one_vector = R2.e_x + R2.e_y
+    two_vector = TensorProduct(R2.e_x, R2.e_y)
+    three_vector = TensorProduct(R2.e_x, R2.e_y, R2.e_x)
+    two_wp = WedgeProduct(R2.e_x,R2.e_y)
+
     assert covariant_order(one_form) == 1
     assert covariant_order(two_form) == 2
     assert covariant_order(three_form) == 3
@@ -134,6 +159,11 @@ def test_helpers_and_coordinate_dependent():
     assert covariant_order(two_form + twoform_not_sym) == 2
     assert covariant_order(two_form + twoform_not_TP) == 2
 
+    assert contravariant_order(one_vector) == 1
+    assert contravariant_order(two_vector) == 2
+    assert contravariant_order(three_vector) == 3
+    assert contravariant_order(two_vector + two_wp) == 2
+
     raises(ValueError, lambda: covariant_order(misform_a))
     raises(ValueError, lambda: covariant_order(misform_b))
     raises(ValueError, lambda: covariant_order(misform_c))
@@ -163,8 +193,6 @@ def test_correct_arguments():
 
     raises(ValueError, lambda: R2.dx(R2.x))
 
-    raises(ValueError, lambda: TensorProduct(R2.e_x, R2.dx))
-
     raises(ValueError, lambda: LieDerivative(R2.dx, R2.dx))
     raises(ValueError, lambda: LieDerivative(R2.x, R2.dx))
 
