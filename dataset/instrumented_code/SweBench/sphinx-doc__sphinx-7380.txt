diff --git a/sphinx/domains/cpp.py b/sphinx/domains/cpp.py
index 51bd417..24e58e8 100644
--- a/sphinx/domains/cpp.py
+++ b/sphinx/domains/cpp.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sphinx-doc__sphinx-7380/sphinx/domains/cpp.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 """
     sphinx.domains.cpp
     ~~~~~~~~~~~~~~~~~~
@@ -1505,8 +1698,38 @@ class ASTBinOpExpr(ASTExpression):
             self.exprs[i].describe_signature(signode, mode, env, symbol)
 
 
+class ASTBracedInitList(ASTBase):
+    def __init__(self, exprs: List[Union[ASTExpression, "ASTBracedInitList"]],
+                 trailingComma: bool) -> None:
+        self.exprs = exprs
+        self.trailingComma = trailingComma
+
+    def get_id(self, version: int) -> str:
+        return "il%sE" % ''.join(e.get_id(version) for e in self.exprs)
+
+    def _stringify(self, transform: StringifyTransform) -> str:
+        exprs = [transform(e) for e in self.exprs]
+        trailingComma = ',' if self.trailingComma else ''
+        return '{%s%s}' % (', '.join(exprs), trailingComma)
+
+    def describe_signature(self, signode: TextElement, mode: str,
+                           env: "BuildEnvironment", symbol: "Symbol") -> None:
+        verify_description_mode(mode)
+        signode.append(nodes.Text('{'))
+        first = True
+        for e in self.exprs:
+            if not first:
+                signode.append(nodes.Text(', '))
+            else:
+                first = False
+            e.describe_signature(signode, mode, env, symbol)
+        if self.trailingComma:
+            signode.append(nodes.Text(','))
+        signode.append(nodes.Text('}'))
+
+
 class ASTAssignmentExpr(ASTExpression):
-    def __init__(self, exprs: List[ASTExpression], ops: List[str]):
+    def __init__(self, exprs: List[Union[ASTExpression, ASTBracedInitList]], ops: List[str]):
         assert len(exprs) > 0
         assert len(exprs) == len(ops) + 1
         self.exprs = exprs
@@ -1540,6 +1763,31 @@ class ASTAssignmentExpr(ASTExpression):
             self.exprs[i].describe_signature(signode, mode, env, symbol)
 
 
+class ASTCommaExpr(ASTExpression):
+    def __init__(self, exprs: List[ASTExpression]):
+        assert len(exprs) > 0
+        self.exprs = exprs
+
+    def _stringify(self, transform: StringifyTransform) -> str:
+        return ', '.join(transform(e) for e in self.exprs)
+
+    def get_id(self, version: int) -> str:
+        id_ = _id_operator_v2[',']
+        res = []
+        for i in range(len(self.exprs) - 1):
+            res.append(id_)
+            res.append(self.exprs[i].get_id(version))
+        res.append(self.exprs[-1].get_id(version))
+        return ''.join(res)
+
+    def describe_signature(self, signode: TextElement, mode: str,
+                           env: "BuildEnvironment", symbol: "Symbol") -> None:
+        self.exprs[0].describe_signature(signode, mode, env, symbol)
+        for i in range(1, len(self.exprs)):
+            signode.append(nodes.Text(', '))
+            self.exprs[i].describe_signature(signode, mode, env, symbol)
+
+
 class ASTFallbackExpr(ASTExpression):
     def __init__(self, expr: str):
         self.expr = expr
@@ -1658,9 +1906,11 @@ class ASTTemplateArgConstant(ASTBase):
 
 
 class ASTTemplateArgs(ASTBase):
-    def __init__(self, args: List[Union["ASTType", ASTTemplateArgConstant]]) -> None:
+    def __init__(self, args: List[Union["ASTType", ASTTemplateArgConstant]],
+                 packExpansion: bool) -> None:
         assert args is not None
         self.args = args
+        self.packExpansion = packExpansion
 
     def get_id(self, version: int) -> str:
         if version == 1:
@@ -1672,15 +1922,24 @@ class ASTTemplateArgs(ASTBase):
 
         res = []
         res.append('I')
-        for a in self.args:
-            res.append(a.get_id(version))
+        if len(self.args) > 0:
+            for a in self.args[:-1]:
+                res.append(a.get_id(version))
+            if self.packExpansion:
+                res.append('J')
+            res.append(self.args[-1].get_id(version))
+            if self.packExpansion:
+                res.append('E')
         res.append('E')
         return ''.join(res)
 
     def _stringify(self, transform: StringifyTransform) -> str:
         res = ', '.join(transform(a) for a in self.args)
+        if self.packExpansion:
+            res += '...'
         return '<' + res + '>'
 
+    @inspect_code
     def describe_signature(self, signode: TextElement, mode: str,
                            env: "BuildEnvironment", symbol: "Symbol") -> None:
         verify_description_mode(mode)
@@ -1691,6 +1950,8 @@ class ASTTemplateArgs(ASTBase):
                 signode += nodes.Text(', ')
             first = False
             a.describe_signature(signode, 'markType', env, symbol=symbol)
+        if self.packExpansion:
+            signode += nodes.Text('...')
         signode += nodes.Text('>')
 
 
@@ -2641,7 +2902,8 @@ class ASTDeclaratorParen(ASTDeclarator):
 ##############################################################################################
 
 class ASTPackExpansionExpr(ASTExpression):
-    def __init__(self, expr: ASTExpression):
+    @inspect_code
+    def __init__(self, expr: Union[ASTExpression, ASTBracedInitList]):
         self.expr = expr
 
     def _stringify(self, transform: StringifyTransform) -> str:
@@ -2658,7 +2920,8 @@ class ASTPackExpansionExpr(ASTExpression):
 
 
 class ASTParenExprList(ASTBase):
-    def __init__(self, exprs: List[ASTExpression]) -> None:
+    @inspect_code
+    def __init__(self, exprs: List[Union[ASTExpression, ASTBracedInitList]]) -> None:
         self.exprs = exprs
 
     def get_id(self, version: int) -> str:
@@ -2682,35 +2945,6 @@ class ASTParenExprList(ASTBase):
         signode.append(nodes.Text(')'))
 
 
-class ASTBracedInitList(ASTBase):
-    def __init__(self, exprs: List[ASTExpression], trailingComma: bool) -> None:
-        self.exprs = exprs
-        self.trailingComma = trailingComma
-
-    def get_id(self, version: int) -> str:
-        return "il%sE" % ''.join(e.get_id(version) for e in self.exprs)
-
-    def _stringify(self, transform: StringifyTransform) -> str:
-        exprs = [transform(e) for e in self.exprs]
-        trailingComma = ',' if self.trailingComma else ''
-        return '{%s%s}' % (', '.join(exprs), trailingComma)
-
-    def describe_signature(self, signode: TextElement, mode: str,
-                           env: "BuildEnvironment", symbol: "Symbol") -> None:
-        verify_description_mode(mode)
-        signode.append(nodes.Text('{'))
-        first = True
-        for e in self.exprs:
-            if not first:
-                signode.append(nodes.Text(', '))
-            else:
-                first = False
-            e.describe_signature(signode, mode, env, symbol)
-        if self.trailingComma:
-            signode.append(nodes.Text(','))
-        signode.append(nodes.Text('}'))
-
-
 class ASTInitializer(ASTBase):
     def __init__(self, value: Union[ASTExpression, ASTBracedInitList],
                  hasAssign: bool = True) -> None:
@@ -4720,6 +4954,7 @@ class DefinitionParser(BaseParser):
         # TODO: user-defined lit
         return None
 
+    @inspect_code
     def _parse_fold_or_paren_expression(self) -> ASTExpression:
         # "(" expression ")"
         # fold-expression
@@ -4755,7 +4990,7 @@ class DefinitionParser(BaseParser):
             self.pos = pos
             # fall back to a paren expression
             try:
-                res = self._parse_expression(inTemplate=False)
+                res = self._parse_expression()
                 self.skip_ws()
                 if not self.skip_string(')'):
                     self.fail("Expected ')' in end of parenthesized expression.")
@@ -4802,8 +5037,11 @@ class DefinitionParser(BaseParser):
             return ASTIdExpression(nn)
         return None
 
+    @inspect_code
     def _parse_initializer_list(self, name: str, open: str, close: str
-                                ) -> Tuple[List[ASTExpression], bool]:
+                                ) -> Tuple[List[Union[ASTExpression,
+                                                      ASTBracedInitList]],
+                                           bool]:
         # Parse open and close with the actual initializer-list inbetween
         # -> initializer-clause '...'[opt]
         #  | initializer-list ',' initializer-clause '...'[opt]
@@ -4813,11 +5051,11 @@ class DefinitionParser(BaseParser):
         if self.skip_string(close):
             return [], False
 
-        exprs = []  # type: List[ASTExpression]
+        exprs = []  # type: List[Union[ASTExpression, ASTBracedInitList]]
         trailingComma = False
         while True:
             self.skip_ws()
-            expr = self._parse_expression(inTemplate=False)
+            expr = self._parse_initializer_clause()
             self.skip_ws()
             if self.skip_string('...'):
                 exprs.append(ASTPackExpansionExpr(expr))
@@ -4847,6 +5085,13 @@ class DefinitionParser(BaseParser):
             return None
         return ASTParenExprList(exprs)
 
+    @inspect_code
+    def _parse_initializer_clause(self) -> Union[ASTExpression, ASTBracedInitList]:
+        bracedInitList = self._parse_braced_init_list()
+        if bracedInitList is not None:
+            return bracedInitList
+        return self._parse_assignment_expression(inTemplate=False)
+
     def _parse_braced_init_list(self) -> ASTBracedInitList:
         # -> '{' initializer-list ','[opt] '}'
         #  | '{' '}'
@@ -4863,6 +5108,7 @@ class DefinitionParser(BaseParser):
             return paren
         return self._parse_braced_init_list()
 
+    @inspect_code
     def _parse_postfix_expression(self) -> ASTPostfixExpr:
         # -> primary
         #  | postfix "[" expression "]"
@@ -4905,8 +5151,9 @@ class DefinitionParser(BaseParser):
             if not self.skip_string("("):
                 self.fail("Expected '(' in '%s'." % cast)
 
+            @inspect_code
             def parser():
-                return self._parse_expression(inTemplate=False)
+                return self._parse_expression()
             expr = self._parse_expression_fallback([')'], parser)
             self.skip_ws()
             if not self.skip_string(")"):
@@ -4927,7 +5174,7 @@ class DefinitionParser(BaseParser):
                 try:
 
                     def parser():
-                        return self._parse_expression(inTemplate=False)
+                        return self._parse_expression()
                     expr = self._parse_expression_fallback([')'], parser)
                     prefix = ASTTypeId(expr, isType=False)
                     if not self.skip_string(')'):
@@ -4974,7 +5221,7 @@ class DefinitionParser(BaseParser):
             self.skip_ws()
             if prefixType in ['expr', 'cast', 'typeid']:
                 if self.skip_string_and_ws('['):
-                    expr = self._parse_expression(inTemplate=False)
+                    expr = self._parse_expression()
                     self.skip_ws()
                     if not self.skip_string(']'):
                         self.fail("Expected ']' in end of postfix expression.")
@@ -5065,7 +5312,7 @@ class DefinitionParser(BaseParser):
         if self.skip_word_and_ws('noexcept'):
             if not self.skip_string_and_ws('('):
                 self.fail("Expecting '(' after 'noexcept'.")
-            expr = self._parse_expression(inTemplate=False)
+            expr = self._parse_expression()
             self.skip_ws()
             if not self.skip_string(')'):
                 self.fail("Expecting ')' to end 'noexcept'.")
@@ -5198,7 +5445,7 @@ class DefinitionParser(BaseParser):
         #     logical-or-expression
         #   | logical-or-expression "?" expression ":" assignment-expression
         #   | logical-or-expression assignment-operator initializer-clause
-        exprs = []
+        exprs = []  # type: List[Union[ASTExpression, ASTBracedInitList]]
         ops = []
         orExpr = self._parse_logical_or_expression(inTemplate=inTemplate)
         exprs.append(orExpr)
@@ -5213,7 +5460,7 @@ class DefinitionParser(BaseParser):
                 else:
                     if not self.skip_string(op):
                         continue
-                expr = self._parse_logical_or_expression(False)
+                expr = self._parse_initializer_clause()
                 exprs.append(expr)
                 ops.append(op)
                 oneMore = True
@@ -5230,11 +5477,19 @@ class DefinitionParser(BaseParser):
         # TODO: use _parse_conditional_expression_tail
         return orExpr
 
-    def _parse_expression(self, inTemplate: bool) -> ASTExpression:
+    def _parse_expression(self) -> ASTExpression:
         # -> assignment-expression
         #  | expression "," assignment-expresion
-        # TODO: actually parse the second production
-        return self._parse_assignment_expression(inTemplate=inTemplate)
+        exprs = [self._parse_assignment_expression(inTemplate=False)]
+        while True:
+            self.skip_ws()
+            if not self.skip_string(','):
+                break
+            exprs.append(self._parse_assignment_expression(inTemplate=False))
+        if len(exprs) == 1:
+            return exprs[0]
+        else:
+            return ASTCommaExpr(exprs)
 
     def _parse_expression_fallback(self, end: List[str],
                                    parser: Callable[[], ASTExpression],
@@ -5312,14 +5567,23 @@ class DefinitionParser(BaseParser):
         type = self._parse_type(named=False, outer="operatorCast")
         return ASTOperatorType(type)
 
+    @inspect_code
     def _parse_template_argument_list(self) -> ASTTemplateArgs:
+        # template-argument-list: (but we include the < and > here
+        #    template-argument ...[opt]
+        #    template-argument-list, template-argument ...[opt]
+        # template-argument:
+        #    constant-expression
+        #    type-id
+        #    id-expression
         self.skip_ws()
         if not self.skip_string_and_ws('<'):
             return None
         if self.skip_string('>'):
-            return ASTTemplateArgs([])
+            return ASTTemplateArgs([], False)
         prevErrors = []
         templateArgs = []  # type: List[Union[ASTType, ASTTemplateArgConstant]]
+        packExpansion = False
         while 1:
             pos = self.pos
             parsedComma = False
@@ -5327,31 +5591,35 @@ class DefinitionParser(BaseParser):
             try:
                 type = self._parse_type(named=False)
                 self.skip_ws()
-                if self.skip_string('>'):
+                if self.skip_string_and_ws('...'):
+                    packExpansion = True
+                    parsedEnd = True
+                    if not self.skip_string('>'):
+                        self.fail('Expected ">" after "..." in template argument list.')
+                elif self.skip_string('>'):
                     parsedEnd = True
                 elif self.skip_string(','):
                     parsedComma = True
                 else:
-                    self.fail('Expected ">" or "," in template argument list.')
+                    self.fail('Expected "...>", ">" or "," in template argument list.')
                 templateArgs.append(type)
             except DefinitionError as e:
                 prevErrors.append((e, "If type argument"))
                 self.pos = pos
                 try:
-                    # actually here we shouldn't use the fallback parser (hence allow=False),
-                    # because if actually took the < in an expression, then we _will_ fail,
-                    # which is handled elsewhere. E.g., :cpp:expr:`A <= 0`.
-                    def parser():
-                        return self._parse_constant_expression(inTemplate=True)
-                    value = self._parse_expression_fallback(
-                        [',', '>'], parser, allow=False)
+                    value = self._parse_constant_expression(inTemplate=True)
                     self.skip_ws()
-                    if self.skip_string('>'):
+                    if self.skip_string_and_ws('...'):
+                        packExpansion = True
+                        parsedEnd = True
+                        if not self.skip_string('>'):
+                            self.fail('Expected ">" after "..." in template argument list.')
+                    elif self.skip_string('>'):
                         parsedEnd = True
                     elif self.skip_string(','):
                         parsedComma = True
                     else:
-                        self.fail('Expected ">" or "," in template argument list.')
+                        self.fail('Expected "...>", ">" or "," in template argument list.')
                     templateArgs.append(ASTTemplateArgConstant(value))
                 except DefinitionError as e:
                     self.pos = pos
@@ -5361,7 +5629,9 @@ class DefinitionParser(BaseParser):
             if parsedEnd:
                 assert not parsedComma
                 break
-        return ASTTemplateArgs(templateArgs)
+            else:
+                assert not packExpansion
+        return ASTTemplateArgs(templateArgs, packExpansion)
 
     def _parse_nested_name(self, memberPointer: bool = False) -> ASTNestedName:
         names = []  # type: List[ASTNestedNameElement]
@@ -5451,7 +5721,7 @@ class DefinitionParser(BaseParser):
                 if not self.skip_string(')'):
                     self.fail("Expected ')' after 'decltype(auto'.")
                 return ASTTrailingTypeSpecDecltypeAuto()
-            expr = self._parse_expression(inTemplate=False)
+            expr = self._parse_expression()
             self.skip_ws()
             if not self.skip_string(')'):
                 self.fail("Expected ')' after 'decltype(<expr>'.")
@@ -5464,7 +5734,6 @@ class DefinitionParser(BaseParser):
             if self.skip_word_and_ws(k):
                 prefix = k
                 break
-
         nestedName = self._parse_nested_name()
         return ASTTrailingTypeSpecName(prefix, nestedName)
 
@@ -5696,7 +5965,7 @@ class DefinitionParser(BaseParser):
                     continue
 
                 def parser():
-                    return self._parse_expression(inTemplate=False)
+                    return self._parse_expression()
                 value = self._parse_expression_fallback([']'], parser)
                 if not self.skip_string(']'):
                     self.fail("Expected ']' in end of array operator.")
@@ -5758,32 +6027,6 @@ class DefinitionParser(BaseParser):
         if typed and self.skip_string("..."):
             next = self._parse_declarator(named, paramMode, False)
             return ASTDeclaratorParamPack(next=next)
-        if typed:  # pointer to member
-            pos = self.pos
-            try:
-                name = self._parse_nested_name(memberPointer=True)
-                self.skip_ws()
-                if not self.skip_string('*'):
-                    self.fail("Expected '*' in pointer to member declarator.")
-                self.skip_ws()
-            except DefinitionError as e:
-                self.pos = pos
-                prevErrors.append((e, "If pointer to member declarator"))
-            else:
-                volatile = False
-                const = False
-                while 1:
-                    if not volatile:
-                        volatile = self.skip_word_and_ws('volatile')
-                        if volatile:
-                            continue
-                    if not const:
-                        const = self.skip_word_and_ws('const')
-                        if const:
-                            continue
-                    break
-                next = self._parse_declarator(named, paramMode, typed)
-                return ASTDeclaratorMemPtr(name, const, volatile, next=next)
         if typed and self.current_char == '(':  # note: peeking, not skipping
             if paramMode == "operatorCast":
                 # TODO: we should be able to parse cast operators which return
@@ -5820,9 +6063,40 @@ class DefinitionParser(BaseParser):
                     prevErrors.append((exNoPtrParen, "If parenthesis in noptr-declarator"))
                     header = "Error in declarator"
                     raise self._make_multi_error(prevErrors, header)
+        if typed:  # pointer to member
+            pos = self.pos
+            try:
+                name = self._parse_nested_name(memberPointer=True)
+                self.skip_ws()
+                if not self.skip_string('*'):
+                    self.fail("Expected '*' in pointer to member declarator.")
+                self.skip_ws()
+            except DefinitionError as e:
+                self.pos = pos
+                prevErrors.append((e, "If pointer to member declarator"))
+            else:
+                volatile = False
+                const = False
+                while 1:
+                    if not volatile:
+                        volatile = self.skip_word_and_ws('volatile')
+                        if volatile:
+                            continue
+                    if not const:
+                        const = self.skip_word_and_ws('const')
+                        if const:
+                            continue
+                    break
+                next = self._parse_declarator(named, paramMode, typed)
+                return ASTDeclaratorMemPtr(name, const, volatile, next=next)
         pos = self.pos
         try:
-            return self._parse_declarator_name_suffix(named, paramMode, typed)
+            res = self._parse_declarator_name_suffix(named, paramMode, typed)
+            # this is a heuristic for error messages, for when there is a < after a
+            # nested name, but it was not a successful template argument list
+            if self.current_char == '<':
+                self.otherErrors.append(self._make_multi_error(prevErrors, ""))
+            return res
         except DefinitionError as e:
             self.pos = pos
             prevErrors.append((e, "If declarator-id"))
@@ -5891,7 +6165,6 @@ class DefinitionParser(BaseParser):
                 raise Exception('Internal error, unknown outer "%s".' % outer)
             if outer != 'operatorCast':
                 assert named
-
         if outer in ('type', 'function'):
             # We allow type objects to just be a name.
             # Some functions don't have normal return types: constructors,
@@ -6085,8 +6358,8 @@ class DefinitionParser(BaseParser):
         self.skip_ws()
         if not self.skip_string("<"):
             self.fail("Expected '<' after 'template'")
+        prevErrors = []
         while 1:
-            prevErrors = []
             self.skip_ws()
             if self.skip_word('template'):
                 # declare a tenplate template parameter
@@ -6139,6 +6412,7 @@ class DefinitionParser(BaseParser):
             if self.skip_string('>'):
                 return ASTTemplateParams(templateParams)
             elif self.skip_string(','):
+                prevErrors = []
                 continue
             else:
                 header = "Error in template parameter list."
@@ -6358,7 +6632,7 @@ class DefinitionParser(BaseParser):
     def parse_expression(self) -> Union[ASTExpression, ASTType]:
         pos = self.pos
         try:
-            expr = self._parse_expression(False)
+            expr = self._parse_expression()
             self.skip_ws()
             self.assert_end()
             return expr
diff --git a/tests/test_domain_cpp.py b/tests/test_domain_cpp.py
index c6d0df8..2faa3d4 100644
--- a/tests/test_domain_cpp.py
+++ b/tests/test_domain_cpp.py
@@ -274,6 +274,9 @@ def test_expressions():
     exprCheck('a xor_eq 5', 'eO1aL5E')
     exprCheck('a |= 5', 'oR1aL5E')
     exprCheck('a or_eq 5', 'oR1aL5E')
+    exprCheck('a = {1, 2, 3}', 'aS1ailL1EL2EL3EE')
+    # comma operator
+    exprCheck('a, 5', 'cm1aL5E')
 
     # Additional tests
     # a < expression that starts with something that could be a template
@@ -626,6 +629,12 @@ def test_class_definitions():
           {2: 'I0E7has_varI1TNSt6void_tIDTadN1T3varEEEEE'})
 
 
+    check('class', 'template<typename ...Ts> T<int (*)(Ts)...>',
+          {2: 'IDpE1TIJPFi2TsEEE'})
+    check('class', 'template<int... Is> T<(Is)...>',
+          {2: 'I_DpiE1TIJX(Is)EEE', 3: 'I_DpiE1TIJX2IsEEE'})
+
+
 def test_union_definitions():
     check('union', 'A', {2: "1A"})
 
