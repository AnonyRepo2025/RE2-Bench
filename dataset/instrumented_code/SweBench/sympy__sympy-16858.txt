diff --git a/sympy/stats/crv_types.py b/sympy/stats/crv_types.py
index cb28935..ff737e6 100644
--- a/sympy/stats/crv_types.py
+++ b/sympy/stats/crv_types.py
@@ -45,6 +45,199 @@
 """
 
 from __future__ import print_function, division
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-16858/sympy/stats/crv_types.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 
 from sympy import (log, sqrt, pi, S, Dummy, Interval, sympify, gamma,
                    Piecewise, And, Eq, binomial, factorial, Sum, floor, Abs,
@@ -163,6 +356,10 @@ def rv(symbol, cls, args):
 class ArcsinDistribution(SingleContinuousDistribution):
     _argnames = ('a', 'b')
 
+    @inspect_code
+    def set(self):
+        return Interval(self.a, self.b)
+
     def pdf(self, x):
         return 1/(pi*sqrt((x - self.a)*(self.b - x)))
 
@@ -871,6 +1068,8 @@ def ChiSquared(name, k):
 class DagumDistribution(SingleContinuousDistribution):
     _argnames = ('p', 'a', 'b')
 
+    set = Interval(0, oo)
+
     @staticmethod
     def check(p, a, b):
         _value_check(p > 0, "Shape parameter p must be positive.")
@@ -1205,6 +1404,13 @@ def FDistribution(name, d1, d2):
 class FisherZDistribution(SingleContinuousDistribution):
     _argnames = ('d1', 'd2')
 
+    set = Interval(-oo, oo)
+
+    @staticmethod
+    def check(d1, d2):
+        _value_check(d1 > 0, "Degree of freedom d1 must be positive.")
+        _value_check(d2 > 0, "Degree of freedom d2 must be positive.")
+
     def pdf(self, x):
         d1, d2 = self.d1, self.d2
         return (2*d1**(d1/2)*d2**(d2/2) / beta_fn(d1/2, d2/2) *
@@ -1276,6 +1482,11 @@ class FrechetDistribution(SingleContinuousDistribution):
 
     set = Interval(0, oo)
 
+    @staticmethod
+    def check(a, s, m):
+        _value_check(a > 0, "Shape parameter alpha must be positive.")
+        _value_check(s > 0, "Scale parameter s must be positive.")
+
     def __new__(cls, a, s=1, m=0):
         a, s, m = list(map(sympify, (a, s, m)))
         return Basic.__new__(cls, a, s, m)
@@ -1551,6 +1762,10 @@ class GumbelDistribution(SingleContinuousDistribution):
 
     set = Interval(-oo, oo)
 
+    @staticmethod
+    def check(beta, mu):
+        _value_check(beta > 0, "Scale parameter beta must be positive.")
+
     def pdf(self, x):
         beta, mu = self.beta, self.mu
         z = (x - mu)/beta
@@ -1563,8 +1778,9 @@ def _cdf(self, x):
     def _characteristic_function(self, t):
         return gamma(1 - I*self.beta*t) * exp(I*self.mu*t)
 
+    @inspect_code
     def _moment_generating_function(self, t):
-        return gamma(1 - self.beta*t) * exp(I*self.mu*t)
+        return gamma(1 - self.beta*t) * exp(self.mu*t)
 
 def Gumbel(name, beta, mu):
     r"""
@@ -1765,6 +1981,13 @@ def Kumaraswamy(name, a, b):
 class LaplaceDistribution(SingleContinuousDistribution):
     _argnames = ('mu', 'b')
 
+    set = Interval(-oo, oo)
+
+    @staticmethod
+    def check(mu, b):
+        _value_check(b > 0, "Scale parameter b must be positive.")
+        _value_check(mu.is_real, "Location parameter mu should be real")
+
     def pdf(self, x):
         mu, b = self.mu, self.b
         return 1/(2*b)*exp(-Abs(x - mu)/b)
@@ -1852,6 +2075,12 @@ def Laplace(name, mu, b):
 class LogisticDistribution(SingleContinuousDistribution):
     _argnames = ('mu', 's')
 
+    set = Interval(-oo, oo)
+
+    @staticmethod
+    def check(mu, s):
+        _value_check(s > 0, "Scale parameter s must be positive.")
+
     def pdf(self, x):
         mu, s = self.mu, self.s
         return exp(-(x - mu)/s)/(s*(1 + exp(-(x - mu)/s))**2)
@@ -1863,8 +2092,9 @@ def _cdf(self, x):
     def _characteristic_function(self, t):
         return Piecewise((exp(I*t*self.mu) * pi*self.s*t / sinh(pi*self.s*t), Ne(t, 0)), (S.One, True))
 
+    @inspect_code
     def _moment_generating_function(self, t):
-        return exp(self.mu*t) * Beta(1 - self.s*t, 1 + self.s*t)
+        return exp(self.mu*t) * beta_fn(1 - self.s*t, 1 + self.s*t)
 
     def _quantile(self, p):
         return self.mu - self.s*log(-S.One + S.One/p)
@@ -2015,6 +2245,10 @@ class MaxwellDistribution(SingleContinuousDistribution):
 
     set = Interval(0, oo)
 
+    @staticmethod
+    def check(a):
+        _value_check(a > 0, "Parameter a must be positive.")
+
     def pdf(self, x):
         a = self.a
         return sqrt(2/pi)*x**2*exp(-x**2/(2*a**2))/a**3
@@ -2085,6 +2319,11 @@ class NakagamiDistribution(SingleContinuousDistribution):
 
     set = Interval(0, oo)
 
+    @staticmethod
+    def check(mu, omega):
+        _value_check(mu >= S.Half, "Shape parameter mu must be greater than equal to 1/2.")
+        _value_check(omega > 0, "Spread parameter omega must be positive.")
+
     def pdf(self, x):
         mu, omega = self.mu, self.omega
         return 2*mu**mu/(gamma(mu)*omega**mu)*x**(2*mu - 1)*exp(-mu/omega*x**2)
@@ -2385,6 +2624,10 @@ class QuadraticUDistribution(SingleContinuousDistribution):
     def set(self):
         return Interval(self.a, self.b)
 
+    @staticmethod
+    def check(a, b):
+        _value_check(b > a, "Parameter b must be in range (%s, oo)."%(a))
+
     def pdf(self, x):
         a, b = self.a, self.b
         alpha = 12 / (b-a)**3
@@ -2553,6 +2796,10 @@ class RayleighDistribution(SingleContinuousDistribution):
 
     set = Interval(0, oo)
 
+    @staticmethod
+    def check(sigma):
+        _value_check(sigma > 0, "Scale parameter sigma must be positive.")
+
     def pdf(self, x):
         sigma = self.sigma
         return x/sigma**2*exp(-x**2/(2*sigma**2))
@@ -2690,6 +2937,12 @@ def ShiftedGompertz(name, b, eta):
 class StudentTDistribution(SingleContinuousDistribution):
     _argnames = ('nu',)
 
+    set = Interval(-oo, oo)
+
+    @staticmethod
+    def check(nu):
+        _value_check(nu > 0, "Degrees of freedom nu must be positive.")
+
     def pdf(self, x):
         nu = self.nu
         return 1/(sqrt(nu)*beta_fn(S(1)/2, nu/2))*(1 + x**2/nu)**(-(nu + 1)/2)
@@ -2770,6 +3023,19 @@ def StudentT(name, nu):
 class TrapezoidalDistribution(SingleContinuousDistribution):
     _argnames = ('a', 'b', 'c', 'd')
 
+    @property
+    def set(self):
+        return Interval(self.a, self.d)
+
+    @staticmethod
+    def check(a, b, c, d):
+        _value_check(a < d, "Lower bound parameter a < %s. a = %s"%(d, a))
+        _value_check((a <= b, b < c),
+        "Level start parameter b must be in range [%s, %s). b = %s"%(a, c, b))
+        _value_check((b < c, c <= d),
+        "Level end parameter c must be in range (%s, %s]. c = %s"%(b, d, c))
+        _value_check(d >= c, "Upper bound parameter d > %s. d = %s"%(c, d))
+
     def pdf(self, x):
         a, b, c, d = self.a, self.b, self.c, self.d
         return Piecewise(
@@ -2850,6 +3116,16 @@ def Trapezoidal(name, a, b, c, d):
 class TriangularDistribution(SingleContinuousDistribution):
     _argnames = ('a', 'b', 'c')
 
+    @property
+    def set(self):
+        return Interval(self.a, self.b)
+
+    @staticmethod
+    def check(a, b, c):
+        _value_check(b > a, "Parameter b > %s. b = %s"%(a, b))
+        _value_check((a <= c, c <= b),
+        "Parameter c must be in range [%s, %s]. c = %s"%(a, b, c))
+
     def pdf(self, x):
         a, b, c = self.a, self.b, self.c
         return Piecewise(
@@ -2862,9 +3138,10 @@ def _characteristic_function(self, t):
         a, b, c = self.a, self.b, self.c
         return -2 *((b-c) * exp(I*a*t) - (b-a) * exp(I*c*t) + (c-a) * exp(I*b*t)) / ((b-a)*(c-a)*(b-c)*t**2)
 
+    @inspect_code
     def _moment_generating_function(self, t):
         a, b, c = self.a, self.b, self.c
-        return 2 * ((b - c) * exp(a * t) - (b - a) * exp(c * t) + (c + a) * exp(b * t)) / (
+        return 2 * ((b - c) * exp(a * t) - (b - a) * exp(c * t) + (c - a) * exp(b * t)) / (
         (b - a) * (c - a) * (b - c) * t ** 2)
 
 
@@ -2940,6 +3217,14 @@ def Triangular(name, a, b, c):
 class UniformDistribution(SingleContinuousDistribution):
     _argnames = ('left', 'right')
 
+    @property
+    def set(self):
+        return Interval(self.left, self.right)
+
+    @staticmethod
+    def check(left, right):
+        _value_check(left < right, "Lower limit should be less than Upper limit.")
+
     def pdf(self, x):
         left, right = self.left, self.right
         return Piecewise(
@@ -3047,6 +3332,11 @@ class UniformSumDistribution(SingleContinuousDistribution):
     def set(self):
         return Interval(0, self.n)
 
+    @staticmethod
+    def check(n):
+        _value_check((n > 0, n.is_integer),
+        "Parameter n must be positive integer.")
+
     def pdf(self, x):
         n = self.n
         k = Dummy("k")
@@ -3292,6 +3582,10 @@ class WignerSemicircleDistribution(SingleContinuousDistribution):
     def set(self):
         return Interval(-self.R, self.R)
 
+    @staticmethod
+    def check(R):
+        _value_check(R > 0, "Radius R must be positive.")
+
     def pdf(self, x):
         R = self.R
         return 2/(pi*R**2)*sqrt(R**2 - x**2)
diff --git a/sympy/stats/joint_rv_types.py b/sympy/stats/joint_rv_types.py
index 224e3f0..3421e9a 100644
--- a/sympy/stats/joint_rv_types.py
+++ b/sympy/stats/joint_rv_types.py
@@ -76,7 +76,8 @@ def set(self):
         k = len(self.mu)
         return S.Reals**k
 
-    def check(self, mu, sigma):
+    @staticmethod
+    def check(mu, sigma):
         _value_check(len(mu) == len(sigma.col(0)),
             "Size of the mean vector and covariance matrix are incorrect.")
         #check if covariance matrix is positive definite or not.
@@ -117,7 +118,8 @@ def set(self):
         k = len(self.mu)
         return S.Reals**k
 
-    def check(self, mu, sigma):
+    @staticmethod
+    def check(mu, sigma):
         _value_check(len(mu) == len(sigma.col(0)),
             "Size of the mean vector and covariance matrix are incorrect.")
         #check if covariance matrix is positive definite or not.
@@ -151,7 +153,8 @@ def set(self):
         k = len(self.mu)
         return S.Reals**k
 
-    def check(self, mu, sigma, v):
+    @staticmethod
+    def check(mu, sigma, v):
         _value_check(len(mu) == len(sigma.col(0)),
             "Size of the location vector and shape matrix are incorrect.")
         #check if covariance matrix is positive definite or not.
@@ -196,7 +199,8 @@ class NormalGammaDistribution(JointDistribution):
     _argnames = ['mu', 'lamda', 'alpha', 'beta']
     is_Continuous=True
 
-    def check(self, mu, lamda, alpha, beta):
+    @staticmethod
+    def check(mu, lamda, alpha, beta):
         _value_check(mu.is_real, "Location must be real.")
         _value_check(lamda > 0, "Lambda must be positive")
         _value_check(alpha > 0, "alpha must be positive")
@@ -258,7 +262,8 @@ class MultivariateBetaDistribution(JointDistribution):
     _argnames = ['alpha']
     is_Continuous = True
 
-    def check(self, alpha):
+    @staticmethod
+    def check(alpha):
         _value_check(len(alpha) >= 2, "At least two categories should be passed.")
         for a_k in alpha:
             _value_check((a_k > 0) != False, "Each concentration parameter"
@@ -331,7 +336,8 @@ class MultivariateEwensDistribution(JointDistribution):
     is_Discrete = True
     is_Continuous = False
 
-    def check(self, n, theta):
+    @staticmethod
+    def check(n, theta):
         _value_check(isinstance(n, Integer) and (n > 0) == True,
                         "sample size should be positive integer.")
         _value_check(theta.is_positive, "mutation rate should be positive.")
@@ -403,7 +409,8 @@ class MultinomialDistribution(JointDistribution):
     is_Continuous=False
     is_Discrete = True
 
-    def check(self, n, p):
+    @staticmethod
+    def check(n, p):
         _value_check(n > 0,
                         "number of trials must be a positve integer")
         for p_k in p:
@@ -471,7 +478,8 @@ class NegativeMultinomialDistribution(JointDistribution):
     is_Continuous=False
     is_Discrete = True
 
-    def check(self, k0, p):
+    @staticmethod
+    def check(k0, p):
         _value_check(k0 > 0,
                         "number of failures must be a positve integer")
         for p_k in p:
diff --git a/sympy/stats/tests/test_continuous_rv.py b/sympy/stats/tests/test_continuous_rv.py
index ee529df..333360c 100644
--- a/sympy/stats/tests/test_continuous_rv.py
+++ b/sympy/stats/tests/test_continuous_rv.py
@@ -1,13 +1,16 @@
-from sympy import (Symbol, Abs, exp, S, N, pi, simplify, Interval, erf, erfc, Ne,
-                   Eq, log, lowergamma, uppergamma, Sum, symbols, sqrt, And, gamma, beta,
-                   Piecewise, Integral, sin, cos, tan, atan, besseli, factorial, binomial,
-                   floor, expand_func, Rational, I, re, im, lambdify, hyper, diff, Or, Mul)
+from sympy import (Symbol, Abs, exp, expint, S, N, pi, simplify, Interval, erf, erfc, Ne,
+                   EulerGamma, Eq, log, lowergamma, uppergamma, Sum, symbols, sqrt, And,
+                   gamma, beta, Piecewise, Integral, sin, cos, tan, atan, sinh, cosh,
+                   besseli, factorial, binomial, floor, expand_func, Rational, I, re,
+                   im, lambdify, hyper, diff, Or, Mul)
 from sympy.core.compatibility import range
 from sympy.external import import_module
 from sympy.functions.special.error_functions import erfinv
+from sympy.functions.special.hyper import meijerg
 from sympy.sets.sets import Intersection, FiniteSet
 from sympy.stats import (P, E, where, density, variance, covariance, skewness,
-                         given, pspace, cdf, characteristic_function, ContinuousRV, sample,
+                         given, pspace, cdf, characteristic_function,
+                         moment_generating_function, ContinuousRV, sample,
                          Arcsin, Benini, Beta, BetaNoncentral, BetaPrime, Cauchy,
                          Chi, ChiSquared,
                          ChiNoncentral, Dagum, Erlang, Exponential,
@@ -22,6 +25,7 @@
 from sympy.stats.joint_rv import JointPSpace
 from sympy.utilities.pytest import raises, XFAIL, slow, skip
 from sympy.utilities.randtest import verify_numerically as tn
+from sympy import E as e
 
 oo = S.Infinity
 
@@ -34,8 +38,8 @@ def test_single_normal():
     X = Normal('x', 0, 1)
     Y = X*sigma + mu
 
-    assert simplify(E(Y)) == mu
-    assert simplify(variance(Y)) == sigma**2
+    assert E(Y) == mu
+    assert variance(Y) == sigma**2
     pdf = density(Y)
     x = Symbol('x')
     assert (pdf(x) ==
@@ -46,12 +50,12 @@ def test_single_normal():
     assert E(X, Eq(X, mu)) == mu
 
 
-@XFAIL
 def test_conditional_1d():
     X = Normal('x', 0, 1)
     Y = given(X, X >= 0)
+    z = Symbol('z')
 
-    assert density(Y) == 2 * density(X)
+    assert density(Y)(z) == 2 * density(X)(z)
 
     assert Y.pspace.domain.set == Interval(0, oo)
     assert E(Y) == sqrt(2) / sqrt(pi)
@@ -108,7 +112,7 @@ def test_symbolic():
     assert E(X + Y) == mu1 + mu2
     assert E(a*X + b) == a*E(X) + b
     assert variance(X) == s1**2
-    assert simplify(variance(X + a*Y + b)) == variance(X) + a**2*variance(Y)
+    assert variance(X + a*Y + b) == variance(X) + a**2*variance(Y)
 
     assert E(Z) == 1/rate
     assert E(a*Z + b) == a*E(Z) + b
@@ -147,12 +151,144 @@ def test_characteristic_function():
     Y = Normal('y', 1, 1)
     cf = characteristic_function(Y)
     assert cf(0) == 1
-    assert simplify(cf(1)) == exp(I - S(1)/2)
+    assert cf(1) == exp(I - S(1)/2)
 
     Z = Exponential('z', 5)
     cf = characteristic_function(Z)
     assert cf(0) == 1
-    assert simplify(cf(1)) == S(25)/26 + 5*I/26
+    assert cf(1).expand() == S(25)/26 + 5*I/26
+
+def test_moment_generating_function():
+    t = symbols('t', positive=True)
+
+    # Symbolic tests
+    a, b, c = symbols('a b c')
+
+    mgf = moment_generating_function(Beta('x', a, b))(t)
+    assert mgf == hyper((a,), (a + b,), t)
+
+    mgf = moment_generating_function(Chi('x', a))(t)
+    assert mgf == sqrt(2)*t*gamma(a/2 + S(1)/2)*\
+        hyper((a/2 + S(1)/2,), (S(3)/2,), t**2/2)/gamma(a/2) +\
+        hyper((a/2,), (S(1)/2,), t**2/2)
+
+    mgf = moment_generating_function(ChiSquared('x', a))(t)
+    assert mgf == (1 - 2*t)**(-a/2)
+
+    mgf = moment_generating_function(Erlang('x', a, b))(t)
+    assert mgf == (1 - t/b)**(-a)
+
+    mgf = moment_generating_function(Exponential('x', a))(t)
+    assert mgf == a/(a - t)
+
+    mgf = moment_generating_function(Gamma('x', a, b))(t)
+    assert mgf == (-b*t + 1)**(-a)
+
+    mgf = moment_generating_function(Gumbel('x', a, b))(t)
+    assert mgf == exp(b*t)*gamma(-a*t + 1)
+
+    mgf = moment_generating_function(Gompertz('x', a, b))(t)
+    assert mgf == b*exp(b)*expint(t/a, b)
+
+    mgf = moment_generating_function(Laplace('x', a, b))(t)
+    assert mgf == exp(a*t)/(-b**2*t**2 + 1)
+
+    mgf = moment_generating_function(Logistic('x', a, b))(t)
+    assert mgf == exp(a*t)*beta(-b*t + 1, b*t + 1)
+
+    mgf = moment_generating_function(Normal('x', a, b))(t)
+    assert mgf == exp(a*t + b**2*t**2/2)
+
+    mgf = moment_generating_function(Pareto('x', a, b))(t)
+    assert mgf == b*(-a*t)**b*uppergamma(-b, -a*t)
+
+    mgf = moment_generating_function(QuadraticU('x', a, b))(t)
+    assert str(mgf) == ("(3*(t*(-4*b + (a + b)**2) + 4)*exp(b*t) - "
+    "3*(t*(a**2 + 2*a*(b - 2) + b**2) + 4)*exp(a*t))/(t**2*(a - b)**3)")
+
+    mgf = moment_generating_function(RaisedCosine('x', a, b))(t)
+    assert mgf == pi**2*exp(a*t)*sinh(b*t)/(b*t*(b**2*t**2 + pi**2))
+
+    mgf = moment_generating_function(Rayleigh('x', a))(t)
+    assert mgf == sqrt(2)*sqrt(pi)*a*t*(erf(sqrt(2)*a*t/2) + 1)\
+        *exp(a**2*t**2/2)/2 + 1
+
+    mgf = moment_generating_function(Triangular('x', a, b, c))(t)
+    assert str(mgf) == ("(-2*(-a + b)*exp(c*t) + 2*(-a + c)*exp(b*t) + "
+    "2*(b - c)*exp(a*t))/(t**2*(-a + b)*(-a + c)*(b - c))")
+
+    mgf = moment_generating_function(Uniform('x', a, b))(t)
+    assert mgf == (-exp(a*t) + exp(b*t))/(t*(-a + b))
+
+    mgf = moment_generating_function(UniformSum('x', a))(t)
+    assert mgf == ((exp(t) - 1)/t)**a
+
+    mgf = moment_generating_function(WignerSemicircle('x', a))(t)
+    assert mgf == 2*besseli(1, a*t)/(a*t)
+
+    # Numeric tests
+
+    mgf = moment_generating_function(Beta('x', 1, 1))(t)
+    assert mgf.diff(t).subs(t, 1) == hyper((2,), (3,), 1)/2
+
+    mgf = moment_generating_function(Chi('x', 1))(t)
+    assert mgf.diff(t).subs(t, 1) == sqrt(2)*hyper((1,), (S(3)/2,), S(1)/2
+    )/sqrt(pi) + hyper((S(3)/2,), (S(3)/2,), S(1)/2) + 2*sqrt(2)*hyper((2,),
+    (S(5)/2,), S(1)/2)/(3*sqrt(pi))
+
+    mgf = moment_generating_function(ChiSquared('x', 1))(t)
+    assert mgf.diff(t).subs(t, 1) == I
+
+    mgf = moment_generating_function(Erlang('x', 1, 1))(t)
+    assert mgf.diff(t).subs(t, 0) == 1
+
+    mgf = moment_generating_function(Exponential('x', 1))(t)
+    assert mgf.diff(t).subs(t, 0) == 1
+
+    mgf = moment_generating_function(Gamma('x', 1, 1))(t)
+    assert mgf.diff(t).subs(t, 0) == 1
+
+    mgf = moment_generating_function(Gumbel('x', 1, 1))(t)
+    assert mgf.diff(t).subs(t, 0) == EulerGamma + 1
+
+    mgf = moment_generating_function(Gompertz('x', 1, 1))(t)
+    assert mgf.diff(t).subs(t, 1) == -e*meijerg(((), (1, 1)),
+    ((0, 0, 0), ()), 1)
+
+    mgf = moment_generating_function(Laplace('x', 1, 1))(t)
+    assert mgf.diff(t).subs(t, 0) == 1
+
+    mgf = moment_generating_function(Logistic('x', 1, 1))(t)
+    assert mgf.diff(t).subs(t, 0) == beta(1, 1)
+
+    mgf = moment_generating_function(Normal('x', 0, 1))(t)
+    assert mgf.diff(t).subs(t, 1) == exp(S(1)/2)
+
+    mgf = moment_generating_function(Pareto('x', 1, 1))(t)
+    assert mgf.diff(t).subs(t, 0) == expint(1, 0)
+
+    mgf = moment_generating_function(QuadraticU('x', 1, 2))(t)
+    assert mgf.diff(t).subs(t, 1) == -12*e - 3*exp(2)
+
+    mgf = moment_generating_function(RaisedCosine('x', 1, 1))(t)
+    assert mgf.diff(t).subs(t, 1) == -2*e*pi**2*sinh(1)/\
+    (1 + pi**2)**2 + e*pi**2*cosh(1)/(1 + pi**2)
+
+    mgf = moment_generating_function(Rayleigh('x', 1))(t)
+    assert mgf.diff(t).subs(t, 0) == sqrt(2)*sqrt(pi)/2
+
+    mgf = moment_generating_function(Triangular('x', 1, 3, 2))(t)
+    assert mgf.diff(t).subs(t, 1) == -e + exp(3)
+
+    mgf = moment_generating_function(Uniform('x', 0, 1))(t)
+    assert mgf.diff(t).subs(t, 1) == 1
+
+    mgf = moment_generating_function(UniformSum('x', 1))(t)
+    assert mgf.diff(t).subs(t, 1) == 1
+
+    mgf = moment_generating_function(WignerSemicircle('x', 1))(t)
+    assert mgf.diff(t).subs(t, 1) == -2*besseli(1, 1) + besseli(2, 1) +\
+        besseli(0, 1)
 
 
 def test_sample_continuous():
@@ -451,7 +587,7 @@ def test_gamma():
     X = Gamma('x', k, theta)
     assert E(X) == k*theta
     assert variance(X) == k*theta**2
-    assert simplify(skewness(X)) == 2/sqrt(k)
+    assert skewness(X).expand() == 2/sqrt(k)
 
 
 def test_gamma_inverse():
@@ -554,7 +690,7 @@ def test_maxwell():
     assert density(X)(x) == (sqrt(2)*x**2*exp(-x**2/(2*a**2))/
         (sqrt(pi)*a**3))
     assert E(X) == 2*sqrt(2)*a/sqrt(pi)
-    assert simplify(variance(X)) == a**2*(-8 + 3*pi)/pi
+    assert variance(X) == -8*a**2/pi + 3*a**2
     assert cdf(X)(x) == erf(sqrt(2)*x/(2*a)) - sqrt(2)*x*exp(-x**2/(2*a**2))/(sqrt(pi)*a)
     assert diff(cdf(X)(x), x) == density(X)(x)
 
@@ -653,18 +789,14 @@ def test_trapezoidal():
     assert variance(X) == S(5)/12
     assert P(X < 2) == S(3)/4
 
-@XFAIL
 def test_triangular():
     a = Symbol("a")
     b = Symbol("b")
     c = Symbol("c")
 
     X = Triangular('x', a, b, c)
-    assert density(X)(x) == Piecewise(
-                 ((2*x - 2*a)/((-a + b)*(-a + c)), And(a <= x, x < c)),
-                 (2/(-a + b), x == c),
-                 ((-2*x + 2*b)/((-a + b)*(b - c)), And(x <= b, c < x)),
-                 (0, True))
+    assert str(density(X)(x)) == ("Piecewise(((-2*a + 2*x)/((-a + b)*(-a + c)), (a <= x) & (c > x)), "
+    "(2/(-a + b), Eq(c, x)), ((2*b - 2*x)/((-a + b)*(b - c)), (b >= x) & (c < x)), (0, True))")
 
 
 def test_quadratic_u():
@@ -681,8 +813,8 @@ def test_uniform():
     w = Symbol('w', positive=True, finite=True)
     X = Uniform('x', l, l + w)
 
-    assert simplify(E(X)) == l + w/2
-    assert simplify(variance(X)) == w**2/12
+    assert E(X) == l + w/2
+    assert variance(X).expand() == w**2/12
 
     # With numbers all is well
     X = Uniform('x', 3, 5)
@@ -700,7 +832,7 @@ def test_uniform():
     assert c(S(7)/2) == S(1)/4
     assert c(5) == 1 and c(6) == 1
 
-
+@XFAIL
 def test_uniform_P():
     """ This stopped working because SingleContinuousPSpace.compute_density no
     longer calls integrate on a DiracDelta but rather just solves directly.
@@ -738,8 +870,8 @@ def test_weibull():
     a, b = symbols('a b', positive=True)
     X = Weibull('x', a, b)
 
-    assert simplify(E(X)) == simplify(a * gamma(1 + 1/b))
-    assert simplify(variance(X)) == simplify(a**2 * gamma(1 + 2/b) - E(X)**2)
+    assert E(X).expand() == a * gamma(1 + 1/b)
+    assert variance(X).expand() == (a**2 * gamma(1 + 2/b) - E(X)**2).expand()
     assert simplify(skewness(X)) == (2*gamma(1 + 1/b)**3 - 3*gamma(1 + 1/b)*gamma(1 + 2/b) + gamma(1 + 3/b))/(-gamma(1 + 1/b)**2 + gamma(1 + 2/b))**(S(3)/2)
 
 def test_weibull_numeric():
@@ -795,22 +927,18 @@ def test_input_value_assertions():
         fn('x', p, q)  # No error raised
 
 
-@XFAIL
 def test_unevaluated():
     X = Normal('x', 0, 1)
-    assert E(X, evaluate=False) == (
-        Integral(sqrt(2)*x*exp(-x**2/2)/(2*sqrt(pi)), (x, -oo, oo)))
+    assert str(E(X, evaluate=False)) == ("Integral(sqrt(2)*x*exp(-x**2/2)/"
+    "(2*sqrt(pi)), (x, -oo, oo))")
 
-    assert E(X + 1, evaluate=False) == (
-        Integral(sqrt(2)*x*exp(-x**2/2)/(2*sqrt(pi)), (x, -oo, oo)) + 1)
+    assert str(E(X + 1, evaluate=False)) == ("Integral(sqrt(2)*x*exp(-x**2/2)/"
+    "(2*sqrt(pi)), (x, -oo, oo)) + 1")
 
-    assert P(X > 0, evaluate=False) == (
-        Integral(sqrt(2)*exp(-x**2/2)/(2*sqrt(pi)), (x, 0, oo)))
+    assert str(P(X > 0, evaluate=False)) == ("Integral(sqrt(2)*exp(-_z**2/2)/"
+    "(2*sqrt(pi)), (_z, 0, oo))")
 
-    assert P(X > 0, X**2 < 1, evaluate=False) == (
-        Integral(sqrt(2)*exp(-x**2/2)/(2*sqrt(pi)*
-            Integral(sqrt(2)*exp(-x**2/2)/(2*sqrt(pi)),
-                (x, -1, 1))), (x, 0, 1)))
+    assert P(X > 0, X**2 < 1, evaluate=False) == S(1)/2
 
 
 def test_probability_unevaluated():
