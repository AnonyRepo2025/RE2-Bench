diff --git a/sympy/diffgeom/diffgeom.py b/sympy/diffgeom/diffgeom.py
index ba82bee..d657914 100644
--- a/sympy/diffgeom/diffgeom.py
+++ b/sympy/diffgeom/diffgeom.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/sympy__sympy-21476/sympy/diffgeom/diffgeom.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 from typing import Any, Set
 
 from functools import reduce
@@ -193,8 +386,9 @@ class CoordSystem(Basic):
 
     relations : dict, optional
         Key is a tuple of two strings, who are the names of the systems where
-        the coordinates transform from and transform to. Value is a tuple of
-        transformed coordinates.
+        the coordinates transform from and transform to.
+        Value is a tuple of the symbols before transformation and a tuple of
+        the expressions after transformation.
 
     Examples
     ========
@@ -209,8 +403,8 @@ class CoordSystem(Basic):
     >>> x, y = symbols('x y', real=True)
     >>> r, theta = symbols('r theta', nonnegative=True)
     >>> relation_dict = {
-    ... ('Car2D', 'Pol'): (sqrt(x**2 + y**2), atan2(y, x)),
-    ... ('Pol', 'Car2D'): (r*cos(theta), r*sin(theta))
+    ... ('Car2D', 'Pol'): [(x, y), (sqrt(x**2 + y**2), atan2(y, x))],
+    ... ('Pol', 'Car2D'): [(r, theta), (r*cos(theta), r*sin(theta))]
     ... }
     >>> Car2D = CoordSystem('Car2D', p, (x, y), relation_dict)
     >>> Pol = CoordSystem('Pol', p, (r, theta), relation_dict)
@@ -314,8 +508,12 @@ def __new__(cls, name, patch, symbols=None, relations={}, **kwargs):
             if not isinstance(s2, Str):
                 s2 = Str(s2)
             key = Tuple(s1, s2)
+
+            # Old version used Lambda as a value.
             if isinstance(v, Lambda):
-                v = tuple(v(*symbols))
+                v = (tuple(v.signature), tuple(v.expr))
+            else:
+                v = (tuple(v[0]), tuple(v[1]))
             rel_temp[key] = v
         relations = Dict(rel_temp)
 
@@ -366,6 +564,7 @@ def dim(self):
     # Finding transformation relation
     ##########################################################################
 
+    @inspect_code
     def transformation(self, sys):
         """
         Return coordinate transformation function from *self* to *sys*.
@@ -396,7 +595,7 @@ def transformation(self, sys):
         if self == sys:
             expr = Matrix(self.symbols)
         elif key in self.relations:
-            expr = Matrix(self.relations[key])
+            expr = Matrix(self.relations[key][1])
         elif key[::-1] in self.relations:
             expr = Matrix(self._inverse_transformation(sys, self))
         else:
@@ -404,44 +603,59 @@ def transformation(self, sys):
         return Lambda(signature, expr)
 
     @staticmethod
-    def _inverse_transformation(sys1, sys2):
-        # Find the transformation relation from sys2 to sys1
-        forward_transform_expressions = sys1.transform(sys2)
-
-        inv_results = solve(
-            [t[0] - t[1] for t in zip(sys2.symbols, forward_transform_expressions)],
-            list(sys1.symbols), dict=True)
-        if len(inv_results) == 0:
-            raise NotImplementedError(
-                "Cannot solve inverse of transformation from {} to {}".format(sys1, sys2))
-        elif len(inv_results) > 1:
-            raise ValueError(
-                "Obtained multiple results for inverse of transformation from {} to {}".format(sys1, sys2)
-            )
+    def _solve_inverse(sym1, sym2, exprs, sys1_name, sys2_name):
+        ret = solve(
+            [t[0] - t[1] for t in zip(sym2, exprs)],
+            list(sym1), dict=True)
+
+        if len(ret) == 0:
+            temp = "Cannot solve inverse relation from {} to {}."
+            raise NotImplementedError(temp.format(sys1_name, sys2_name))
+        elif len(ret) > 1:
+            temp = "Obtained multiple inverse relation from {} to {}."
+            raise ValueError(temp.format(sys1_name, sys2_name))
+
+        return ret[0]
 
-        inv_results = inv_results[0]
+    @classmethod
+    def _inverse_transformation(cls, sys1, sys2):
+        # Find the transformation relation from sys2 to sys1
+        forward = sys1.transform(sys2)
+        inv_results = cls._solve_inverse(sys1.symbols, sys2.symbols, forward,
+                                         sys1.name, sys2.name)
         signature = tuple(sys1.symbols)
         return [inv_results[s] for s in signature]
 
     @classmethod
     @cacheit
     def _indirect_transformation(cls, sys1, sys2):
-        # Find the transformation relation between two indirectly connected coordinate systems
+        # Find the transformation relation between two indirectly connected
+        # coordinate systems
+        rel = sys1.relations
         path = cls._dijkstra(sys1, sys2)
-        Lambdas = []
-        for i in range(len(path) - 1):
-            s1, s2 = path[i], path[i + 1]
-            Lambdas.append(s1.transformation(s2))
-        syms = Lambdas[-1].signature
-        expr = syms
-        for l in reversed(Lambdas):
-            expr = l(*expr)
-        return Lambda(syms, expr)
+
+        transforms = []
+        for s1, s2 in zip(path, path[1:]):
+            if (s1, s2) in rel:
+                transforms.append(rel[(s1, s2)])
+            else:
+                sym2, inv_exprs = rel[(s2, s1)]
+                sym1 = tuple(Dummy() for i in sym2)
+                ret = cls._solve_inverse(sym2, sym1, inv_exprs, s2, s1)
+                ret = tuple(ret[s] for s in sym2)
+                transforms.append((sym1, ret))
+        syms = sys1.args[2]
+        exprs = syms
+        for newsyms, newexprs in transforms:
+            exprs = tuple(e.subs(zip(newsyms, exprs)) for e in newexprs)
+        return exprs
 
     @staticmethod
+    @inspect_code
     def _dijkstra(sys1, sys2):
         # Use Dijkstra algorithm to find the shortest path between two indirectly-connected
         # coordinate systems
+        # return value is the list of the names of the systems.
         relations = sys1.relations
         graph = {}
         for s1, s2 in relations.keys():
@@ -465,7 +679,7 @@ def visit(sys):
                     path_dict[newsys][1] = [i for i in path_dict[sys][1]]
                     path_dict[newsys][1].append(sys)
 
-        visit(sys1)
+        visit(sys1.name)
 
         while True:
             min_distance = max(path_dict.values(), key=lambda x:x[0])[0]
@@ -478,10 +692,10 @@ def visit(sys):
                 break
             visit(newsys)
 
-        result = path_dict[sys2][1]
-        result.append(sys2)
+        result = path_dict[sys2.name][1]
+        result.append(sys2.name)
 
-        if result == [sys2]:
+        if result == [sys2.name]:
             raise KeyError("Two coordinate systems are not connected.")
         return result
 
diff --git a/sympy/diffgeom/rn.py b/sympy/diffgeom/rn.py
index 635e85f..c625473 100644
--- a/sympy/diffgeom/rn.py
+++ b/sympy/diffgeom/rn.py
@@ -30,8 +30,8 @@
 r, theta = symbols('rho theta', nonnegative=True)
 
 relations_2d = {
-    ('rectangular', 'polar'): (sqrt(x**2 + y**2), atan2(y, x)),
-    ('polar', 'rectangular'): (r*cos(theta), r*sin(theta)),
+    ('rectangular', 'polar'): [(x, y), (sqrt(x**2 + y**2), atan2(y, x))],
+    ('polar', 'rectangular'): [(r, theta), (r*cos(theta), r*sin(theta))],
 }
 
 R2_r = CoordSystem('rectangular', R2_origin, (x, y), relations_2d)  # type: Any
@@ -74,18 +74,24 @@
 rho, psi, r, theta, phi = symbols('rho psi r theta phi', nonnegative=True)
 
 relations_3d = {
-    ('rectangular', 'cylindrical'): (sqrt(x**2 + y**2), atan2(y, x), z),
-    ('cylindrical', 'rectangular'): (rho*cos(psi), rho*sin(psi), z),
-    ('rectangular', 'spherical'): (sqrt(x**2 + y**2 + z**2),
-                                   acos(z/sqrt(x**2 + y**2 + z**2)),
-                                   atan2(y, x)),
-    ('spherical', 'rectangular'): (r*sin(theta)*cos(phi),
-                                   r*sin(theta)*sin(phi),
-                                   r*cos(theta)),
-    ('cylindrical', 'spherical'): (sqrt(rho**2 + z**2),
-                                   acos(z/sqrt(rho**2 + z**2)),
-                                   psi),
-    ('spherical', 'cylindrical'): (r*sin(theta), phi, r*cos(theta)),
+    ('rectangular', 'cylindrical'): [(x, y, z),
+                                     (sqrt(x**2 + y**2), atan2(y, x), z)],
+    ('cylindrical', 'rectangular'): [(rho, psi, z),
+                                     (rho*cos(psi), rho*sin(psi), z)],
+    ('rectangular', 'spherical'): [(x, y, z),
+                                   (sqrt(x**2 + y**2 + z**2),
+                                    acos(z/sqrt(x**2 + y**2 + z**2)),
+                                    atan2(y, x))],
+    ('spherical', 'rectangular'): [(r, theta, phi),
+                                   (r*sin(theta)*cos(phi),
+                                    r*sin(theta)*sin(phi),
+                                    r*cos(theta))],
+    ('cylindrical', 'spherical'): [(rho, psi, z),
+                                   (sqrt(rho**2 + z**2),
+                                    acos(z/sqrt(rho**2 + z**2)),
+                                    psi)],
+    ('spherical', 'cylindrical'): [(r, theta, phi),
+                                   (r*sin(theta), phi, r*cos(theta))],
 }
 
 R3_r = CoordSystem('rectangular', R3_origin, (x, y, z), relations_3d)  # type: Any
diff --git a/sympy/diffgeom/tests/test_diffgeom.py b/sympy/diffgeom/tests/test_diffgeom.py
index f5c1209..dc36547 100644
--- a/sympy/diffgeom/tests/test_diffgeom.py
+++ b/sympy/diffgeom/tests/test_diffgeom.py
@@ -1,10 +1,10 @@
+from sympy.core import Lambda, Symbol, symbols
 from sympy.diffgeom.rn import R2, R2_p, R2_r, R3_r, R3_c, R3_s, R2_origin
 from sympy.diffgeom import (CoordSystem, Commutator, Differential, TensorProduct,
         WedgeProduct, BaseCovarDerivativeOp, CovarDerivativeOp, LieDerivative,
         covariant_order, contravariant_order, twoform_to_matrix, metric_to_Christoffel_1st,
         metric_to_Christoffel_2nd, metric_to_Riemann_components,
         metric_to_Ricci_components, intcurve_diffequ, intcurve_series)
-from sympy.core import Symbol, symbols
 from sympy.simplify import trigsimp, simplify
 from sympy.functions import sqrt, atan2, sin
 from sympy.matrices import Matrix
@@ -14,6 +14,78 @@
 TP = TensorProduct
 
 
+def test_coordsys_transform():
+    # test inverse transforms
+    p, q, r, s = symbols('p q r s')
+    rel = {('first', 'second'): [(p, q), (q, -p)]}
+    R2_pq = CoordSystem('first', R2_origin, [p, q], rel)
+    R2_rs = CoordSystem('second', R2_origin, [r, s], rel)
+    r, s = R2_rs.symbols
+    assert R2_rs.transform(R2_pq) == Matrix([[-s], [r]])
+
+    # inverse transform impossible case
+    a, b = symbols('a b', positive=True)
+    rel = {('first', 'second'): [(a,), (-a,)]}
+    R2_a = CoordSystem('first', R2_origin, [a], rel)
+    R2_b = CoordSystem('second', R2_origin, [b], rel)
+    # This transformation is uninvertible because there is no positive a, b satisfying a = -b
+    with raises(NotImplementedError):
+        R2_b.transform(R2_a)
+
+    # inverse transform ambiguous case
+    c, d = symbols('c d')
+    rel = {('first', 'second'): [(c,), (c**2,)]}
+    R2_c = CoordSystem('first', R2_origin, [c], rel)
+    R2_d = CoordSystem('second', R2_origin, [d], rel)
+    # The transform method should throw if it finds multiple inverses for a coordinate transformation.
+    with raises(ValueError):
+        R2_d.transform(R2_c)
+
+    # test indirect transformation
+    a, b, c, d, e, f = symbols('a, b, c, d, e, f')
+    rel = {('C1', 'C2'): [(a, b), (2*a, 3*b)],
+        ('C2', 'C3'): [(c, d), (3*c, 2*d)]}
+    C1 = CoordSystem('C1', R2_origin, (a, b), rel)
+    C2 = CoordSystem('C2', R2_origin, (c, d), rel)
+    C3 = CoordSystem('C3', R2_origin, (e, f), rel)
+    a, b = C1.symbols
+    c, d = C2.symbols
+    e, f = C3.symbols
+    assert C2.transform(C1) == Matrix([c/2, d/3])
+    assert C1.transform(C3) == Matrix([6*a, 6*b])
+    assert C3.transform(C1) == Matrix([e/6, f/6])
+    assert C3.transform(C2) == Matrix([e/3, f/2])
+
+    a, b, c, d, e, f = symbols('a, b, c, d, e, f')
+    rel = {('C1', 'C2'): [(a, b), (2*a, 3*b + 1)],
+        ('C3', 'C2'): [(e, f), (-e - 2, 2*f)]}
+    C1 = CoordSystem('C1', R2_origin, (a, b), rel)
+    C2 = CoordSystem('C2', R2_origin, (c, d), rel)
+    C3 = CoordSystem('C3', R2_origin, (e, f), rel)
+    a, b = C1.symbols
+    c, d = C2.symbols
+    e, f = C3.symbols
+    assert C2.transform(C1) == Matrix([c/2, (d - 1)/3])
+    assert C1.transform(C3) == Matrix([-2*a - 2, (3*b + 1)/2])
+    assert C3.transform(C1) == Matrix([-e/2 - 1, (2*f - 1)/3])
+    assert C3.transform(C2) == Matrix([-e - 2, 2*f])
+
+    # old signature uses Lambda
+    a, b, c, d, e, f = symbols('a, b, c, d, e, f')
+    rel = {('C1', 'C2'): Lambda((a, b), (2*a, 3*b + 1)),
+        ('C3', 'C2'): Lambda((e, f), (-e - 2, 2*f))}
+    C1 = CoordSystem('C1', R2_origin, (a, b), rel)
+    C2 = CoordSystem('C2', R2_origin, (c, d), rel)
+    C3 = CoordSystem('C3', R2_origin, (e, f), rel)
+    a, b = C1.symbols
+    c, d = C2.symbols
+    e, f = C3.symbols
+    assert C2.transform(C1) == Matrix([c/2, (d - 1)/3])
+    assert C1.transform(C3) == Matrix([-2*a - 2, (3*b + 1)/2])
+    assert C3.transform(C1) == Matrix([-e/2 - 1, (2*f - 1)/3])
+    assert C3.transform(C2) == Matrix([-e - 2, 2*f])
+
+
 def test_R2():
     x0, y0, r0, theta0 = symbols('x0, y0, r0, theta0', real=True)
     point_r = R2_r.point([x0, y0])
@@ -37,45 +109,6 @@ def test_R2():
             R2_r, R2_r.coord_tuple_transform_to(R2_p, m)).applyfunc(simplify)
 
 
-def test_inverse_transformations():
-    p, q, r, s = symbols('p q r s')
-
-    relations_quarter_rotation = {
-        ('first', 'second'): (q, -p)
-    }
-
-    R2_pq = CoordSystem('first', R2_origin, [p, q], relations_quarter_rotation)
-    R2_rs = CoordSystem('second', R2_origin, [r, s], relations_quarter_rotation)
-
-    # The transform method should derive the inverse transformation if not given explicitly
-    assert R2_rs.transform(R2_pq) == Matrix([[-R2_rs.symbols[1]], [R2_rs.symbols[0]]])
-
-    a, b = symbols('a b', positive=True)
-    relations_uninvertible_transformation = {
-        ('first', 'second'): (-a,)
-    }
-
-    R2_a = CoordSystem('first', R2_origin, [a], relations_uninvertible_transformation)
-    R2_b = CoordSystem('second', R2_origin, [b], relations_uninvertible_transformation)
-
-    # The transform method should throw if it cannot invert the coordinate transformation.
-    # This transformation is uninvertible because there is no positive a, b satisfying a = -b
-    with raises(NotImplementedError):
-        R2_b.transform(R2_a)
-
-    c, d = symbols('c d')
-    relations_ambiguous_inverse = {
-        ('first', 'second'): (c**2,)
-    }
-
-    R2_c = CoordSystem('first', R2_origin, [c], relations_ambiguous_inverse)
-    R2_d = CoordSystem('second', R2_origin, [d], relations_ambiguous_inverse)
-
-    # The transform method should throw if it finds multiple inverses for a coordinate transformation.
-    with raises(ValueError):
-        R2_d.transform(R2_c)
-
-
 def test_R3():
     a, b, c = symbols('a b c', positive=True)
     m = Matrix([[a], [b], [c]])
