diff --git a/astropy/table/column.py b/astropy/table/column.py
index 2072975..e12eb71 100644
--- a/astropy/table/column.py
+++ b/astropy/table/column.py
@@ -340,7 +340,9 @@ class ColumnInfo(BaseColumnInfo):
     This is required when the object is used as a mixin column within a table,
     but can be used as a general way to store meta information.
     """
-    attrs_from_parent = BaseColumnInfo.attr_names
+    attr_names = BaseColumnInfo.attr_names | {'groups'}
+    _attrs_no_copy = BaseColumnInfo._attrs_no_copy | {'groups'}
+    attrs_from_parent = attr_names
     _supports_indexing = True
 
     def new_like(self, cols, length, metadata_conflicts='warn', name=None):
diff --git a/astropy/table/groups.py b/astropy/table/groups.py
index 5d0afaf..9e3491b 100644
--- a/astropy/table/groups.py
+++ b/astropy/table/groups.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/astropy__astropy-12825/astropy/table/groups.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 # Licensed under a 3-clause BSD style license - see LICENSE.rst
 
 import platform
@@ -212,9 +405,10 @@ class BaseGroups:
 
 
 class ColumnGroups(BaseGroups):
+    @inspect_code
     def __init__(self, parent_column, indices=None, keys=None):
         self.parent_column = parent_column  # parent Column
-        self.parent_table = parent_column.parent_table
+        self.parent_table = parent_column.info.parent_table
         self._indices = indices
         self._keys = keys
 
@@ -237,8 +431,10 @@ class ColumnGroups(BaseGroups):
         else:
             return self._keys
 
+    @inspect_code
     def aggregate(self, func):
-        from .column import MaskedColumn
+        from .column import MaskedColumn, Column
+        from astropy.utils.compat import NUMPY_LT_1_20
 
         i0s, i1s = self.indices[:-1], self.indices[1:]
         par_col = self.parent_column
@@ -248,6 +444,15 @@ class ColumnGroups(BaseGroups):
         mean_case = func is np.mean
         try:
             if not masked and (reduceat or sum_case or mean_case):
+                # For numpy < 1.20 there is a bug where reduceat will fail to
+                # raise an exception for mixin columns that do not support the
+                # operation. For details see:
+                # https://github.com/astropy/astropy/pull/12825#issuecomment-1082412447
+                # Instead we try the function directly with a 2-element version
+                # of the column
+                if NUMPY_LT_1_20 and not isinstance(par_col, Column) and len(par_col) > 0:
+                    func(par_col[[0, 0]])
+
                 if mean_case:
                     vals = np.add.reduceat(par_col, i0s) / np.diff(self.indices)
                 else:
@@ -256,17 +461,18 @@ class ColumnGroups(BaseGroups):
                     vals = func.reduceat(par_col, i0s)
             else:
                 vals = np.array([func(par_col[i0: i1]) for i0, i1 in zip(i0s, i1s)])
+            out = par_col.__class__(vals)
         except Exception as err:
-            raise TypeError("Cannot aggregate column '{}' with type '{}'"
-                            .format(par_col.info.name,
-                                    par_col.info.dtype)) from err
-
-        out = par_col.__class__(data=vals,
-                                name=par_col.info.name,
-                                description=par_col.info.description,
-                                unit=par_col.info.unit,
-                                format=par_col.info.format,
-                                meta=par_col.info.meta)
+            raise TypeError("Cannot aggregate column '{}' with type '{}': {}"
+                            .format(par_col.info.name, par_col.info.dtype, err)) from err
+
+        out_info = out.info
+        for attr in ('name', 'unit', 'format', 'description', 'meta'):
+            try:
+                setattr(out_info, attr, getattr(par_col.info, attr))
+            except AttributeError:
+                pass
+
         return out
 
     def filter(self, func):
@@ -328,6 +534,7 @@ class TableGroups(BaseGroups):
         else:
             return self._indices
 
+    @inspect_code
     def aggregate(self, func):
         """
         Aggregate each group in the Table into a single row by applying the reduction
@@ -354,7 +561,7 @@ class TableGroups(BaseGroups):
                 new_col = col.take(i0s)
             else:
                 try:
-                    new_col = col.groups.aggregate(func)
+                    new_col = col.info.groups.aggregate(func)
                 except TypeError as err:
                     warnings.warn(str(err), AstropyUserWarning)
                     continue
diff --git a/astropy/table/tests/conftest.py b/astropy/table/tests/conftest.py
index 9a453e6..0417699 100644
--- a/astropy/table/tests/conftest.py
+++ b/astropy/table/tests/conftest.py
@@ -178,16 +178,17 @@ def mixin_cols(request):
 
 @pytest.fixture(params=[False, True])
 def T1(request):
-    T = Table.read([' a b c d',
-                    ' 2 c 7.0 0',
-                    ' 2 b 5.0 1',
-                    ' 2 b 6.0 2',
-                    ' 2 a 4.0 3',
-                    ' 0 a 0.0 4',
-                    ' 1 b 3.0 5',
-                    ' 1 a 2.0 6',
-                    ' 1 a 1.0 7',
-                    ], format='ascii')
+    T = QTable.read([' a b c d',
+                     ' 2 c 7.0 0',
+                     ' 2 b 5.0 1',
+                     ' 2 b 6.0 2',
+                     ' 2 a 4.0 3',
+                     ' 0 a 0.0 4',
+                     ' 1 b 3.0 5',
+                     ' 1 a 2.0 6',
+                     ' 1 a 1.0 7',
+                     ], format='ascii')
+    T['q'] = np.arange(len(T)) * u.m
     T.meta.update({'ta': 1})
     T['c'].meta.update({'a': 1})
     T['c'].description = 'column c'
diff --git a/astropy/table/tests/test_groups.py b/astropy/table/tests/test_groups.py
index b95b0cc..a5e1392 100644
--- a/astropy/table/tests/test_groups.py
+++ b/astropy/table/tests/test_groups.py
@@ -17,7 +17,7 @@ def sort_eq(list1, list2):
 
 def test_column_group_by(T1):
     for masked in (False, True):
-        t1 = Table(T1, masked=masked)
+        t1 = QTable(T1, masked=masked)
         t1a = t1['a'].copy()
 
         # Group by a Column (i.e. numpy array)
@@ -39,7 +39,7 @@ def test_table_group_by(T1):
     masked/unmasked tables.
     """
     for masked in (False, True):
-        t1 = Table(T1, masked=masked)
+        t1 = QTable(T1, masked=masked)
         # Group by a single column key specified by name
         tg = t1.group_by('a')
         assert np.all(tg.groups.indices == np.array([0, 1, 4, 8]))
@@ -47,16 +47,17 @@ def test_table_group_by(T1):
         assert str(tg['a'].groups) == "<ColumnGroups indices=[0 1 4 8]>"
 
         # Sorted by 'a' and in original order for rest
-        assert tg.pformat() == [' a   b   c   d ',
-                                '--- --- --- ---',
-                                '  0   a 0.0   4',
-                                '  1   b 3.0   5',
-                                '  1   a 2.0   6',
-                                '  1   a 1.0   7',
-                                '  2   c 7.0   0',
-                                '  2   b 5.0   1',
-                                '  2   b 6.0   2',
-                                '  2   a 4.0   3']
+        assert tg.pformat() == [' a   b   c   d   q ',
+                                '                 m ',
+                                '--- --- --- --- ---',
+                                '  0   a 0.0   4 4.0',
+                                '  1   b 3.0   5 5.0',
+                                '  1   a 2.0   6 6.0',
+                                '  1   a 1.0   7 7.0',
+                                '  2   c 7.0   0 0.0',
+                                '  2   b 5.0   1 1.0',
+                                '  2   b 6.0   2 2.0',
+                                '  2   a 4.0   3 3.0']
         assert tg.meta['ta'] == 1
         assert tg['c'].meta['a'] == 1
         assert tg['c'].description == 'column c'
@@ -70,16 +71,17 @@ def test_table_group_by(T1):
             tg = t1.group_by(keys)
             assert np.all(tg.groups.indices == np.array([0, 1, 3, 4, 5, 7, 8]))
             # Sorted by 'a', 'b' and in original order for rest
-            assert tg.pformat() == [' a   b   c   d ',
-                                    '--- --- --- ---',
-                                    '  0   a 0.0   4',
-                                    '  1   a 2.0   6',
-                                    '  1   a 1.0   7',
-                                    '  1   b 3.0   5',
-                                    '  2   a 4.0   3',
-                                    '  2   b 5.0   1',
-                                    '  2   b 6.0   2',
-                                    '  2   c 7.0   0']
+            assert tg.pformat() == [' a   b   c   d   q ',
+                                    '                 m ',
+                                    '--- --- --- --- ---',
+                                    '  0   a 0.0   4 4.0',
+                                    '  1   a 2.0   6 6.0',
+                                    '  1   a 1.0   7 7.0',
+                                    '  1   b 3.0   5 5.0',
+                                    '  2   a 4.0   3 3.0',
+                                    '  2   b 5.0   1 1.0',
+                                    '  2   b 6.0   2 2.0',
+                                    '  2   c 7.0   0 0.0']
 
         # Group by a Table
         tg2 = t1.group_by(t1['a', 'b'])
@@ -92,16 +94,17 @@ def test_table_group_by(T1):
         # Group by a simple ndarray
         tg = t1.group_by(np.array([0, 1, 0, 1, 2, 1, 0, 0]))
         assert np.all(tg.groups.indices == np.array([0, 4, 7, 8]))
-        assert tg.pformat() == [' a   b   c   d ',
-                                '--- --- --- ---',
-                                '  2   c 7.0   0',
-                                '  2   b 6.0   2',
-                                '  1   a 2.0   6',
-                                '  1   a 1.0   7',
-                                '  2   b 5.0   1',
-                                '  2   a 4.0   3',
-                                '  1   b 3.0   5',
-                                '  0   a 0.0   4']
+        assert tg.pformat() == [' a   b   c   d   q ',
+                                '                 m ',
+                                '--- --- --- --- ---',
+                                '  2   c 7.0   0 0.0',
+                                '  2   b 6.0   2 2.0',
+                                '  1   a 2.0   6 6.0',
+                                '  1   a 1.0   7 7.0',
+                                '  2   b 5.0   1 1.0',
+                                '  2   a 4.0   3 3.0',
+                                '  1   b 3.0   5 5.0',
+                                '  0   a 0.0   4 4.0']
 
 
 def test_groups_keys(T1):
@@ -134,7 +137,7 @@ def test_grouped_copy(T1):
     Test that copying a table or column copies the groups properly
     """
     for masked in (False, True):
-        t1 = Table(T1, masked=masked)
+        t1 = QTable(T1, masked=masked)
         tg = t1.group_by('a')
         tgc = tg.copy()
         assert np.all(tgc.groups.indices == tg.groups.indices)
@@ -155,7 +158,7 @@ def test_grouped_slicing(T1):
     """
 
     for masked in (False, True):
-        t1 = Table(T1, masked=masked)
+        t1 = QTable(T1, masked=masked)
 
         # Regular slice of a table
         tg = t1.group_by('a')
@@ -266,11 +269,11 @@ def test_mutable_operations(T1):
     but adding or removing or renaming a column should retain grouping.
     """
     for masked in (False, True):
-        t1 = Table(T1, masked=masked)
+        t1 = QTable(T1, masked=masked)
 
         # add row
         tg = t1.group_by('a')
-        tg.add_row((0, 'a', 3.0, 4))
+        tg.add_row((0, 'a', 3.0, 4, 4 * u.m))
         assert np.all(tg.groups.indices == np.array([0, len(tg)]))
         assert tg.groups.keys is None
 
@@ -312,19 +315,20 @@ def test_mutable_operations(T1):
 
 
 def test_group_by_masked(T1):
-    t1m = Table(T1, masked=True)
+    t1m = QTable(T1, masked=True)
     t1m['c'].mask[4] = True
     t1m['d'].mask[5] = True
-    assert t1m.group_by('a').pformat() == [' a   b   c   d ',
-                                           '--- --- --- ---',
-                                           '  0   a  --   4',
-                                           '  1   b 3.0  --',
-                                           '  1   a 2.0   6',
-                                           '  1   a 1.0   7',
-                                           '  2   c 7.0   0',
-                                           '  2   b 5.0   1',
-                                           '  2   b 6.0   2',
-                                           '  2   a 4.0   3']
+    assert t1m.group_by('a').pformat() == [' a   b   c   d   q ',
+                                           '                 m ',
+                                           '--- --- --- --- ---',
+                                           '  0   a  --   4 4.0',
+                                           '  1   b 3.0  -- 5.0',
+                                           '  1   a 2.0   6 6.0',
+                                           '  1   a 1.0   7 7.0',
+                                           '  2   c 7.0   0 0.0',
+                                           '  2   b 5.0   1 1.0',
+                                           '  2   b 6.0   2 2.0',
+                                           '  2   a 4.0   3 3.0']
 
 
 def test_group_by_errors(T1):
@@ -348,7 +352,7 @@ def test_group_by_errors(T1):
         T1.group_by(None)
 
     # Masked key column
-    t1 = Table(T1, masked=True)
+    t1 = QTable(T1, masked=True)
     t1['a'].mask[4] = True
     with pytest.raises(ValueError):
         t1.group_by('a')
@@ -408,23 +412,24 @@ def test_table_aggregate(T1):
     # Aggregate with np.sum with masked elements.  This results
     # in one group with no elements, hence a nan result and conversion
     # to float for the 'd' column.
-    t1m = Table(t1, masked=True)
+    t1m = QTable(T1, masked=True)
     t1m['c'].mask[4:6] = True
     t1m['d'].mask[4:6] = True
     tg = t1m.group_by('a')
     with pytest.warns(UserWarning, match="converting a masked element to nan"):
         tga = tg.groups.aggregate(np.sum)
 
-    assert tga.pformat() == [' a   c    d  ',
-                             '--- ---- ----',
-                             '  0  nan  nan',
-                             '  1  3.0 13.0',
-                             '  2 22.0  6.0']
+    assert tga.pformat() == [' a   c    d    q  ',
+                             '               m  ',
+                             '--- ---- ---- ----',
+                             '  0  nan  nan  4.0',
+                             '  1  3.0 13.0 18.0',
+                             '  2 22.0  6.0  6.0']
 
     # Aggregrate with np.sum with masked elements, but where every
     # group has at least one remaining (unmasked) element.  Then
     # the int column stays as an int.
-    t1m = Table(t1, masked=True)
+    t1m = QTable(t1, masked=True)
     t1m['c'].mask[5] = True
     t1m['d'].mask[5] = True
     tg = t1m.group_by('a')
@@ -440,11 +445,12 @@ def test_table_aggregate(T1):
     tg = T1.group_by('a')
     with pytest.warns(AstropyUserWarning, match="Cannot aggregate column"):
         tga = tg.groups.aggregate(np.sum)
-    assert tga.pformat() == [' a   c    d ',
-                             '--- ---- ---',
-                             '  0  0.0   4',
-                             '  1  6.0  18',
-                             '  2 22.0   6']
+    assert tga.pformat() == [' a   c    d   q  ',
+                             '              m  ',
+                             '--- ---- --- ----',
+                             '  0  0.0   4  4.0',
+                             '  1  6.0  18 18.0',
+                             '  2 22.0   6  6.0']
 
 
 def test_table_aggregate_reduceat(T1):
@@ -504,7 +510,7 @@ def test_column_aggregate(T1):
     Aggregate a single table column
     """
     for masked in (False, True):
-        tg = Table(T1, masked=masked).group_by('a')
+        tg = QTable(T1, masked=masked).group_by('a')
         tga = tg['c'].groups.aggregate(np.sum)
         assert tga.pformat() == [' c  ',
                                  '----',
@@ -635,3 +641,16 @@ def test_group_mixins():
     # Column group_by() with mixins
     idxg = qt['idx'].group_by(qt[mixin_keys])
     assert np.all(idxg == [1, 3, 2, 0])
+
+
+@pytest.mark.parametrize(
+    'col', [time.TimeDelta([1, 2], format='sec'),
+            time.Time([1, 2], format='cxcsec'),
+            coordinates.SkyCoord([1, 2], [3, 4], unit='deg,deg')])
+def test_group_mixins_unsupported(col):
+    """Test that aggregating unsupported mixins produces a warning only"""
+
+    t = Table([[1, 1], [3, 4], col], names=['a', 'b', 'mix'])
+    tg = t.group_by('a')
+    with pytest.warns(AstropyUserWarning, match="Cannot aggregate column 'mix'"):
+        tg.groups.aggregate(np.sum)
diff --git a/astropy/utils/data_info.py b/astropy/utils/data_info.py
index f1cf3ec..216bfdf 100644
--- a/astropy/utils/data_info.py
+++ b/astropy/utils/data_info.py
@@ -511,7 +511,7 @@ class BaseColumnInfo(DataInfo):
     Note that this class is defined here so that mixins can use it
     without importing the table package.
     """
-    attr_names = DataInfo.attr_names.union(['parent_table', 'indices'])
+    attr_names = DataInfo.attr_names | {'parent_table', 'indices'}
     _attrs_no_copy = set(['parent_table', 'indices'])
 
     # Context for serialization.  This can be set temporarily via
@@ -752,6 +752,15 @@ class MixinInfo(BaseColumnInfo):
 
         self._attrs['name'] = name
 
+    @property
+    def groups(self):
+        # This implementation for mixin columns essentially matches the Column
+        # property definition.  `groups` is a read-only property here and
+        # depends on the parent table of the column having `groups`. This will
+        # allow aggregating mixins as long as they support those operations.
+        from astropy.table import groups
+        return self._attrs.setdefault('groups', groups.ColumnGroups(self._parent))
+
 
 class ParentDtypeInfo(MixinInfo):
     """Mixin that gets info.dtype from parent"""
