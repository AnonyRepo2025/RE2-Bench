diff --git a/lib/matplotlib/axes/_axes.py b/lib/matplotlib/axes/_axes.py
index 4d06707..66d2d9f 100644
--- a/lib/matplotlib/axes/_axes.py
+++ b/lib/matplotlib/axes/_axes.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/matplotlib__matplotlib-25027/lib/matplotlib/axes/_axes.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 import functools
 import itertools
 import logging
@@ -5738,6 +5931,7 @@ default: :rc:`scatter.edgecolors`
         self.add_image(im)
         return im
 
+    @inspect_code
     def _pcolorargs(self, funcname, *args, shading='auto', **kwargs):
         # - create X and Y if not present;
         # - reshape X and Y as needed if they are 1-D;
@@ -5778,13 +5972,7 @@ default: :rc:`scatter.edgecolors`
                     raise ValueError(
                         'x and y arguments to pcolormesh cannot have '
                         'non-finite values or be of type '
-                        'numpy.ma.core.MaskedArray with masked values')
-                # safe_masked_invalid() returns an ndarray for dtypes other
-                # than floating point.
-                if isinstance(X, np.ma.core.MaskedArray):
-                    X = X.data  # strip mask as downstream doesn't like it...
-                if isinstance(Y, np.ma.core.MaskedArray):
-                    Y = Y.data
+                        'numpy.ma.MaskedArray with masked values')
             nrows, ncols = C.shape[:2]
         else:
             raise _api.nargs_error(funcname, takes="1 or 3", given=len(args))
@@ -5822,6 +6010,7 @@ default: :rc:`scatter.edgecolors`
                 # grid is specified at the center, so define corners
                 # at the midpoints between the grid centers and then use the
                 # flat algorithm.
+                @inspect_code
                 def _interp_grid(X):
                     # helper for below
                     if np.shape(X)[1] > 1:
@@ -5834,9 +6023,11 @@ default: :rc:`scatter.edgecolors`
                                 "This may lead to incorrectly calculated cell "
                                 "edges, in which case, please supply "
                                 f"explicit cell edges to {funcname}.")
-                        X = np.hstack((X[:, [0]] - dX[:, [0]],
-                                       X[:, :-1] + dX,
-                                       X[:, [-1]] + dX[:, [-1]]))
+
+                        hstack = np.ma.hstack if np.ma.isMA(X) else np.hstack
+                        X = hstack((X[:, [0]] - dX[:, [0]],
+                                    X[:, :-1] + dX,
+                                    X[:, [-1]] + dX[:, [-1]]))
                     else:
                         # This is just degenerate, but we can't reliably guess
                         # a dX if there is just one value.
@@ -5854,6 +6045,7 @@ default: :rc:`scatter.edgecolors`
         C = cbook.safe_masked_invalid(C)
         return X, Y, C, shading
 
+    @inspect_code
     @_preprocess_data()
     @_docstring.dedent_interpd
     def pcolor(self, *args, shading=None, alpha=None, norm=None, cmap=None,
@@ -5954,7 +6146,7 @@ default: :rc:`scatter.edgecolors`
 
         Returns
         -------
-        `matplotlib.collections.Collection`
+        `matplotlib.collections.PolyQuadMesh`
 
         Other Parameters
         ----------------
@@ -5972,7 +6164,7 @@ default: :rc:`scatter.edgecolors`
 
         **kwargs
             Additionally, the following arguments are allowed. They are passed
-            along to the `~matplotlib.collections.PolyCollection` constructor:
+            along to the `~matplotlib.collections.PolyQuadMesh` constructor:
 
         %(PolyCollection:kwdoc)s
 
@@ -6006,35 +6198,6 @@ default: :rc:`scatter.edgecolors`
         shading = shading.lower()
         X, Y, C, shading = self._pcolorargs('pcolor', *args, shading=shading,
                                             kwargs=kwargs)
-        Ny, Nx = X.shape
-
-        # convert to MA, if necessary.
-        C = ma.asarray(C)
-        X = ma.asarray(X)
-        Y = ma.asarray(Y)
-
-        mask = ma.getmaskarray(X) + ma.getmaskarray(Y)
-        xymask = (mask[0:-1, 0:-1] + mask[1:, 1:] +
-                  mask[0:-1, 1:] + mask[1:, 0:-1])
-        # don't plot if C or any of the surrounding vertices are masked.
-        mask = ma.getmaskarray(C) + xymask
-
-        unmask = ~mask
-        X1 = ma.filled(X[:-1, :-1])[unmask]
-        Y1 = ma.filled(Y[:-1, :-1])[unmask]
-        X2 = ma.filled(X[1:, :-1])[unmask]
-        Y2 = ma.filled(Y[1:, :-1])[unmask]
-        X3 = ma.filled(X[1:, 1:])[unmask]
-        Y3 = ma.filled(Y[1:, 1:])[unmask]
-        X4 = ma.filled(X[:-1, 1:])[unmask]
-        Y4 = ma.filled(Y[:-1, 1:])[unmask]
-        npoly = len(X1)
-
-        xy = np.stack([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X1, Y1], axis=-1)
-        verts = xy.reshape((npoly, 5, 2))
-
-        C = ma.filled(C[:Ny - 1, :Nx - 1])[unmask]
-
         linewidths = (0.25,)
         if 'linewidth' in kwargs:
             kwargs['linewidths'] = kwargs.pop('linewidth')
@@ -6048,19 +6211,29 @@ default: :rc:`scatter.edgecolors`
         # unless the boundary is not stroked, in which case the
         # default will be False; with unstroked boundaries, aa
         # makes artifacts that are often disturbing.
-        if 'antialiased' in kwargs:
-            kwargs['antialiaseds'] = kwargs.pop('antialiased')
-        if 'antialiaseds' not in kwargs and cbook._str_lower_equal(ec, "none"):
-            kwargs['antialiaseds'] = False
+        if 'antialiaseds' in kwargs:
+            kwargs['antialiased'] = kwargs.pop('antialiaseds')
+        if 'antialiased' not in kwargs and cbook._str_lower_equal(ec, "none"):
+            kwargs['antialiased'] = False
 
         kwargs.setdefault('snap', False)
 
-        collection = mcoll.PolyCollection(
-            verts, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
-        collection._scale_norm(norm, vmin, vmax)
+        if np.ma.isMaskedArray(X) or np.ma.isMaskedArray(Y):
+            stack = np.ma.stack
+            X = np.ma.asarray(X)
+            Y = np.ma.asarray(Y)
+            # For bounds collections later
+            x = X.compressed()
+            y = Y.compressed()
+        else:
+            stack = np.stack
+            x = X
+            y = Y
+        coords = stack([X, Y], axis=-1)
 
-        x = X.compressed()
-        y = Y.compressed()
+        collection = mcoll.PolyQuadMesh(
+            coords, array=C, cmap=cmap, norm=norm, alpha=alpha, **kwargs)
+        collection._scale_norm(norm, vmin, vmax)
 
         # Transform from native to data coordinates?
         t = collection._transform
@@ -6088,6 +6261,7 @@ default: :rc:`scatter.edgecolors`
         self._request_autoscale_view()
         return collection
 
+    @inspect_code
     @_preprocess_data()
     @_docstring.dedent_interpd
     def pcolormesh(self, *args, alpha=None, norm=None, cmap=None, vmin=None,
@@ -6253,7 +6427,7 @@ default: :rc:`scatter.edgecolors`
 
         The main difference lies in the created object and internal data
         handling:
-        While `~.Axes.pcolor` returns a `.PolyCollection`, `~.Axes.pcolormesh`
+        While `~.Axes.pcolor` returns a `.PolyQuadMesh`, `~.Axes.pcolormesh`
         returns a `.QuadMesh`. The latter is more specialized for the given
         purpose and thus is faster. It should almost always be preferred.
 
@@ -6262,12 +6436,13 @@ default: :rc:`scatter.edgecolors`
         for *C*. However, only `~.Axes.pcolor` supports masked arrays for *X*
         and *Y*. The reason lies in the internal handling of the masked values.
         `~.Axes.pcolor` leaves out the respective polygons from the
-        PolyCollection. `~.Axes.pcolormesh` sets the facecolor of the masked
+        PolyQuadMesh. `~.Axes.pcolormesh` sets the facecolor of the masked
         elements to transparent. You can see the difference when using
         edgecolors. While all edges are drawn irrespective of masking in a
         QuadMesh, the edge between two adjacent masked quadrilaterals in
         `~.Axes.pcolor` is not drawn as the corresponding polygons do not
-        exist in the PolyCollection.
+        exist in the PolyQuadMesh. Because PolyQuadMesh draws each individual
+        polygon, it also supports applying hatches and linestyles to the collection.
 
         Another difference is the support of Gouraud shading in
         `~.Axes.pcolormesh`, which is not available with `~.Axes.pcolor`.
diff --git a/lib/matplotlib/collections.py b/lib/matplotlib/collections.py
index e61c377..23d6569 100644
--- a/lib/matplotlib/collections.py
+++ b/lib/matplotlib/collections.py
@@ -1,3 +1,196 @@
+import inspect
+def recursive_object_seralizer(obj, visited):
+    seralized_dict = {}
+    keys = list(obj.__dict__)
+    for k in keys:
+        if id(obj.__dict__[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(obj.__dict__[k])
+            continue
+        if isinstance(obj.__dict__[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = obj.__dict__[k]
+        elif isinstance(obj.__dict__[k], tuple):
+            ## handle tuple
+            seralized_dict[k] = recursive_tuple_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], set):
+            ## handle set
+            seralized_dict[k] = recursive_set_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], list):
+            ## handle list
+            seralized_dict[k] = recursive_list_seralizer(obj.__dict__[k], visited)
+        elif hasattr(obj.__dict__[k], '__dict__'):
+            ## handle object
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_object_seralizer(obj.__dict__[k], visited)
+        elif isinstance(obj.__dict__[k], dict):
+            visited.append(id(obj.__dict__[k]))
+            seralized_dict[k] = recursive_dict_seralizer(obj.__dict__[k], visited)
+        elif callable(obj.__dict__[k]):
+            ## handle function
+            if hasattr(obj.__dict__[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(obj.__dict__[k].__name__)
+        else:
+            seralized_dict[k] = str(obj.__dict__[k])
+    return seralized_dict
+
+def recursive_dict_seralizer(dictionary, visited):
+    seralized_dict = {}
+    keys = list(dictionary)
+    for k in keys:
+        if id(dictionary[k]) in visited:
+            seralized_dict[k] = "<RECURSIVE {}>".format(dictionary[k])
+            continue
+        # if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+        #     pass
+        # else:
+        #     visited.append(id(dictionary[k]))
+        if isinstance(dictionary[k], (float, int, str, bool, type(None))):
+            seralized_dict[k] = dictionary[k]
+        elif isinstance(dictionary[k], list):
+            seralized_dict[k] = recursive_list_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], tuple):
+            seralized_dict[k] = recursive_tuple_seralizer(dictionary[k], visited)
+        elif isinstance(dictionary[k], set):
+            seralized_dict[k] = recursive_set_seralizer(dictionary[k], visited)        
+        elif hasattr(dictionary[k], '__dict__'):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_object_seralizer(dictionary[k], visited)
+        elif callable(dictionary[k]):
+            if hasattr(dictionary[k], '__name__'):
+                seralized_dict[k] = "<function {}>".format(dictionary[k].__name__)
+        elif isinstance(dictionary[k], dict):
+            visited.append(id(dictionary[k]))
+            seralized_dict[k] = recursive_dict_seralizer(dictionary[k], visited)
+        else:
+            seralized_dict[k] =str(dictionary[k])
+    return seralized_dict   
+
+def recursive_set_seralizer(set_data, visited):
+    new_set = set()
+    for s in set_data:
+        if id(s) in visited:
+            continue 
+        if isinstance(s, (float, int, str, bool, type(None))):
+            new_set.add(s)
+        elif isinstance(s, tuple):
+            new_set.add(recursive_tuple_seralizer(s, visited))
+        elif isinstance(s, list):
+            new_set.add(recursive_list_seralizer(s, visited))
+        elif isinstance(s, set):
+            new_set.add(recursive_set_seralizer(s,visited))
+        elif isinstance(s, dict):
+            visited.append(id(s))
+            new_set.add(recursive_dict_seralizer(s, visited))
+        elif hasattr(s, '__dict__'):
+            visited.append(id(s))
+            new_set.add(str(recursive_object_seralizer(s, visited)))
+        elif callable(s):
+            if hasattr(s, '__name__'):
+                new_set.add("<function {}>".format(s.__name__))
+        else:
+            new_set.add(str(s))
+    return new_set
+    
+
+def recursive_tuple_seralizer(tup, visited):
+    new_tup = ()
+    for t in tup:
+        if id(t) in visited:
+           continue
+        if isinstance(t, (float, int, str, bool, type(None))):
+            new_tup = (*new_tup, t)
+        elif isinstance(t, tuple):
+            new_tup = (*new_tup, recursive_tuple_seralizer(t, visited))
+        elif isinstance(t, list):
+            new_tup = (*new_tup, recursive_list_seralizer(t, visited))
+        elif isinstance(t, set):
+            new_tup = (*new_tup, recursive_set_seralizer(t, visited))
+        elif isinstance(t, dict):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_dict_seralizer(t, visited))
+        elif hasattr(t, '__dict__'):
+            visited.append(id(t))
+            new_tup = (*new_tup, recursive_object_seralizer(t, visited))
+        elif callable(t):
+            if hasattr(t, '__name__'):
+                new_tup = (*new_tup, "<function {}>".format(t.__name__))
+        else:
+            new_tup = (*new_tup, str(t))
+    return new_tup
+
+def recursive_list_seralizer(li, visited):
+    new_list = []
+    for l in li:
+        if id(l) in visited:
+            continue
+        if isinstance(l, (float, int, str, bool, type(None))):
+            new_list.append(l)
+        elif isinstance(l, tuple):
+            new_list.append(recursive_tuple_seralizer(l, visited))
+        elif isinstance(l, list):
+            new_list.append(recursive_list_seralizer(l, visited))
+        elif isinstance(l, set):
+            new_list.append(recursive_set_seralizer(l, visited))
+        elif hasattr(l, '__dict__'):
+            visited.append(id(l))
+            new_list.append(recursive_object_seralizer(l, visited))
+        elif isinstance(l, dict):
+            visited.append(id(l))
+            new_list.append(recursive_dict_seralizer(l, visited))
+        elif callable(l):
+            if hasattr(l, '__name__'):
+                new_list.append("<function {}>".format(l.__name__))
+        else:
+            new_list.append(str(l))       
+
+def inspect_code(func):
+    def wrapper(*args, **kwargs):
+        visited = []
+        filename = "/home/changshu/CODEMIND/scripts/swebench/swebench_playground/obj/matplotlib__matplotlib-25027/lib/matplotlib/collections.py"
+        para_dict = {"name": func.__name__}
+        args_names = inspect.getfullargspec(func).args
+        if len(args) > 0 and hasattr(args[0], '__dict__') and args_names[0] == 'self':
+            ## 'self'
+            self_args = args[0]
+            para_dict['self'] = recursive_object_seralizer(self_args, [id(self_args)])
+        else:
+            para_dict['self'] = {}
+        if len(args) > 0 :
+            if args_names[0] == 'self':
+                other_args = {}
+                for m,n in zip(args_names[1:], args[1:]):
+                    other_args[m] = n
+            else:
+                other_args = {}
+                for m,n in zip(args_names, args):
+                    other_args[m] = n
+            para_dict['args'] = recursive_dict_seralizer(other_args, [id(other_args)])
+        else:
+            para_dict['args'] = {}
+        if kwargs:
+            para_dict['kwargs'] = recursive_dict_seralizer(kwargs, [id(kwargs)])
+        else:
+            para_dict['kwargs'] = {}
+            
+        result = func(*args, **kwargs)
+        ## seralize the return value
+        if isinstance(result, tuple):
+            ret = recursive_tuple_seralizer(result, [])
+        elif isinstance(result, (float, int, str)):
+            ret = result
+        elif isinstance(result, list):
+            ret = recursive_list_seralizer(result, [])
+        elif isinstance(result, dict):
+            ret = recursive_dict_seralizer(result, [])
+        elif hasattr(result, '__dict__'):
+            ret = recursive_object_seralizer(result, [])
+        elif callable(result):
+            ret = "<function {}>".format(result.__name__)
+        else:
+            ret = str(result)
+        para_dict["return"] = ret
+        print("@[DATA]@", filename,"[SEP]", para_dict, "[/SEP]")
+        return result
+    return wrapper
 """
 Classes for the efficient drawing of large collections of objects that
 share most properties, e.g., a large number of line segments or
@@ -863,6 +1056,7 @@ class Collection(artist.Artist, cm.ScalarMappable):
                    or self._face_is_mapped != face0)
         return mapped or changed
 
+    @inspect_code
     def update_scalarmappable(self):
         """
         Update colors from the scalar mappable array, if any.
@@ -875,7 +1069,7 @@ class Collection(artist.Artist, cm.ScalarMappable):
         # Allow possibility to call 'self.set_array(None)'.
         if self._A is not None:
             # QuadMesh can map 2d arrays (but pcolormesh supplies 1d array)
-            if self._A.ndim > 1 and not isinstance(self, QuadMesh):
+            if self._A.ndim > 1 and not isinstance(self, _MeshData):
                 raise ValueError('Collections can only map rank 1 arrays')
             if np.iterable(self._alpha):
                 if self._alpha.size != self._A.size:
@@ -1944,9 +2138,11 @@ class TriMesh(Collection):
         renderer.close_group(self.__class__.__name__)
 
 
-class QuadMesh(Collection):
+class _MeshData:
     r"""
-    Class for the efficient drawing of a quadrilateral mesh.
+    Class for managing the two dimensional coordinates of Quadrilateral meshes
+    and the associated data with them. This class is a mixin and is intended to
+    be used with another collection that will implement the draw separately.
 
     A quadrilateral mesh is a grid of M by N adjacent quadrilaterals that are
     defined via a (M+1, N+1) grid of vertices. The quadrilateral (m, n) is
@@ -1966,42 +2162,13 @@ class QuadMesh(Collection):
         The vertices. ``coordinates[m, n]`` specifies the (x, y) coordinates
         of vertex (m, n).
 
-    antialiased : bool, default: True
-
     shading : {'flat', 'gouraud'}, default: 'flat'
-
-    Notes
-    -----
-    Unlike other `.Collection`\s, the default *pickradius* of `.QuadMesh` is 0,
-    i.e. `~.Artist.contains` checks whether the test point is within any of the
-    mesh quadrilaterals.
-
     """
-
-    def __init__(self, coordinates, *, antialiased=True, shading='flat',
-                 **kwargs):
-        kwargs.setdefault("pickradius", 0)
-        # end of signature deprecation code
-
+    @inspect_code
+    def __init__(self, coordinates, *, shading='flat'):
         _api.check_shape((None, None, 2), coordinates=coordinates)
         self._coordinates = coordinates
-        self._antialiased = antialiased
         self._shading = shading
-        self._bbox = transforms.Bbox.unit()
-        self._bbox.update_from_data_xy(self._coordinates.reshape(-1, 2))
-        # super init delayed after own init because array kwarg requires
-        # self._coordinates and self._shading
-        super().__init__(**kwargs)
-        self.set_mouseover(False)
-
-    def get_paths(self):
-        if self._paths is None:
-            self.set_paths()
-        return self._paths
-
-    def set_paths(self):
-        self._paths = self._convert_mesh_to_paths(self._coordinates)
-        self.stale = True
 
     def set_array(self, A):
         """
@@ -2040,9 +2207,6 @@ class QuadMesh(Collection):
                     f"{' or '.join(map(str, ok_shapes))}, not {A.shape}")
         return super().set_array(A)
 
-    def get_datalim(self, transData):
-        return (self.get_transform() - transData).transform_bbox(self._bbox)
-
     def get_coordinates(self):
         """
         Return the vertices of the mesh as an (M+1, N+1, 2) array.
@@ -2053,6 +2217,19 @@ class QuadMesh(Collection):
         """
         return self._coordinates
 
+    @inspect_code
+    def get_edgecolor(self):
+        # docstring inherited
+        # Note that we want to return an array of shape (N*M, 4)
+        # a flattened RGBA collection
+        return super().get_edgecolor().reshape(-1, 4)
+
+    def get_facecolor(self):
+        # docstring inherited
+        # Note that we want to return an array of shape (N*M, 4)
+        # a flattened RGBA collection
+        return super().get_facecolor().reshape(-1, 4)
+
     @staticmethod
     def _convert_mesh_to_paths(coordinates):
         """
@@ -2116,6 +2293,64 @@ class QuadMesh(Collection):
         tmask = np.isnan(colors[..., 2, 3])
         return triangles[~tmask], colors[~tmask]
 
+
+class QuadMesh(_MeshData, Collection):
+    r"""
+    Class for the efficient drawing of a quadrilateral mesh.
+
+    A quadrilateral mesh is a grid of M by N adjacent quadrilaterals that are
+    defined via a (M+1, N+1) grid of vertices. The quadrilateral (m, n) is
+    defined by the vertices ::
+
+               (m+1, n) ----------- (m+1, n+1)
+                  /                   /
+                 /                 /
+                /               /
+            (m, n) -------- (m, n+1)
+
+    The mesh need not be regular and the polygons need not be convex.
+
+    Parameters
+    ----------
+    coordinates : (M+1, N+1, 2) array-like
+        The vertices. ``coordinates[m, n]`` specifies the (x, y) coordinates
+        of vertex (m, n).
+
+    antialiased : bool, default: True
+
+    shading : {'flat', 'gouraud'}, default: 'flat'
+
+    Notes
+    -----
+    Unlike other `.Collection`\s, the default *pickradius* of `.QuadMesh` is 0,
+    i.e. `~.Artist.contains` checks whether the test point is within any of the
+    mesh quadrilaterals.
+
+    """
+
+    def __init__(self, coordinates, *, antialiased=True, shading='flat',
+                 **kwargs):
+        kwargs.setdefault("pickradius", 0)
+        super().__init__(coordinates=coordinates, shading=shading)
+        Collection.__init__(self, **kwargs)
+
+        self._antialiased = antialiased
+        self._bbox = transforms.Bbox.unit()
+        self._bbox.update_from_data_xy(self._coordinates.reshape(-1, 2))
+        self.set_mouseover(False)
+
+    def get_paths(self):
+        if self._paths is None:
+            self.set_paths()
+        return self._paths
+
+    def set_paths(self):
+        self._paths = self._convert_mesh_to_paths(self._coordinates)
+        self.stale = True
+
+    def get_datalim(self, transData):
+        return (self.get_transform() - transData).transform_bbox(self._bbox)
+
     @artist.allow_rasterization
     def draw(self, renderer):
         if not self.get_visible():
@@ -2170,3 +2405,161 @@ class QuadMesh(Collection):
         if contained and self.get_array() is not None:
             return self.get_array().ravel()[info["ind"]]
         return None
+
+
+class PolyQuadMesh(_MeshData, PolyCollection):
+    """
+    Class for drawing a quadrilateral mesh as individual Polygons.
+
+    A quadrilateral mesh is a grid of M by N adjacent quadrilaterals that are
+    defined via a (M+1, N+1) grid of vertices. The quadrilateral (m, n) is
+    defined by the vertices ::
+
+               (m+1, n) ----------- (m+1, n+1)
+                  /                   /
+                 /                 /
+                /               /
+            (m, n) -------- (m, n+1)
+
+    The mesh need not be regular and the polygons need not be convex.
+
+    Parameters
+    ----------
+    coordinates : (M+1, N+1, 2) array-like
+        The vertices. ``coordinates[m, n]`` specifies the (x, y) coordinates
+        of vertex (m, n).
+
+    Notes
+    -----
+    Unlike `.QuadMesh`, this class will draw each cell as an individual Polygon.
+    This is significantly slower, but allows for more flexibility when wanting
+    to add additional properties to the cells, such as hatching.
+
+    Another difference from `.QuadMesh` is that if any of the vertices or data
+    of a cell are masked, that Polygon will **not** be drawn and it won't be in
+    the list of paths returned.
+    """
+
+    def __init__(self, coordinates, **kwargs):
+        # We need to keep track of whether we are using deprecated compression
+        # Update it after the initializers
+        self._deprecated_compression = False
+        super().__init__(coordinates=coordinates)
+        PolyCollection.__init__(self, verts=[], **kwargs)
+        # Store this during the compression deprecation period
+        self._original_mask = ~self._get_unmasked_polys()
+        self._deprecated_compression = np.any(self._original_mask)
+        # Setting the verts updates the paths of the PolyCollection
+        # This is called after the initializers to make sure the kwargs
+        # have all been processed and available for the masking calculations
+        self._set_unmasked_verts()
+
+    def _get_unmasked_polys(self):
+        """Get the unmasked regions using the coordinates and array"""
+        # mask(X) | mask(Y)
+        mask = np.any(np.ma.getmaskarray(self._coordinates), axis=-1)
+
+        # We want the shape of the polygon, which is the corner of each X/Y array
+        mask = (mask[0:-1, 0:-1] | mask[1:, 1:] | mask[0:-1, 1:] | mask[1:, 0:-1])
+
+        if (getattr(self, "_deprecated_compression", False) and
+                np.any(self._original_mask)):
+            return ~(mask | self._original_mask)
+        # Take account of the array data too, temporarily avoiding
+        # the compression warning and resetting the variable after the call
+        with cbook._setattr_cm(self, _deprecated_compression=False):
+            arr = self.get_array()
+        if arr is not None:
+            arr = np.ma.getmaskarray(arr)
+            if arr.ndim == 3:
+                # RGB(A) case
+                mask |= np.any(arr, axis=-1)
+            elif arr.ndim == 2:
+                mask |= arr
+            else:
+                mask |= arr.reshape(self._coordinates[:-1, :-1, :].shape[:2])
+        return ~mask
+
+    def _set_unmasked_verts(self):
+        X = self._coordinates[..., 0]
+        Y = self._coordinates[..., 1]
+
+        unmask = self._get_unmasked_polys()
+        X1 = np.ma.filled(X[:-1, :-1])[unmask]
+        Y1 = np.ma.filled(Y[:-1, :-1])[unmask]
+        X2 = np.ma.filled(X[1:, :-1])[unmask]
+        Y2 = np.ma.filled(Y[1:, :-1])[unmask]
+        X3 = np.ma.filled(X[1:, 1:])[unmask]
+        Y3 = np.ma.filled(Y[1:, 1:])[unmask]
+        X4 = np.ma.filled(X[:-1, 1:])[unmask]
+        Y4 = np.ma.filled(Y[:-1, 1:])[unmask]
+        npoly = len(X1)
+
+        xy = np.ma.stack([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X1, Y1], axis=-1)
+        verts = xy.reshape((npoly, 5, 2))
+        self.set_verts(verts)
+
+    def get_edgecolor(self):
+        # docstring inherited
+        # We only want to return the facecolors of the polygons
+        # that were drawn.
+        ec = super().get_edgecolor()
+        unmasked_polys = self._get_unmasked_polys().ravel()
+        if len(ec) != len(unmasked_polys):
+            # Mapping is off
+            return ec
+        return ec[unmasked_polys, :]
+
+    def get_facecolor(self):
+        # docstring inherited
+        # We only want to return the facecolors of the polygons
+        # that were drawn.
+        fc = super().get_facecolor()
+        unmasked_polys = self._get_unmasked_polys().ravel()
+        if len(fc) != len(unmasked_polys):
+            # Mapping is off
+            return fc
+        return fc[unmasked_polys, :]
+
+    def set_array(self, A):
+        # docstring inherited
+        prev_unmask = self._get_unmasked_polys()
+        # MPL <3.8 compressed the mask, so we need to handle flattened 1d input
+        # until the deprecation expires, also only warning when there are masked
+        # elements and thus compression occurring.
+        if self._deprecated_compression and np.ndim(A) == 1:
+            _api.warn_deprecated("3.8", message="Setting a PolyQuadMesh array using "
+                                 "the compressed values is deprecated. "
+                                 "Pass the full 2D shape of the original array "
+                                 f"{prev_unmask.shape} including the masked elements.")
+            Afull = np.empty(self._original_mask.shape)
+            Afull[~self._original_mask] = A
+            # We also want to update the mask with any potential
+            # new masked elements that came in. But, we don't want
+            # to update any of the compression from the original
+            mask = self._original_mask.copy()
+            mask[~self._original_mask] |= np.ma.getmask(A)
+            A = np.ma.array(Afull, mask=mask)
+            return super().set_array(A)
+        self._deprecated_compression = False
+        super().set_array(A)
+        # If the mask has changed at all we need to update
+        # the set of Polys that we are drawing
+        if not np.array_equal(prev_unmask, self._get_unmasked_polys()):
+            self._set_unmasked_verts()
+
+    def get_array(self):
+        # docstring inherited
+        # Can remove this entire function once the deprecation period ends
+        A = super().get_array()
+        if A is None:
+            return
+        if self._deprecated_compression and np.any(np.ma.getmask(A)):
+            _api.warn_deprecated("3.8", message=(
+                "Getting the array from a PolyQuadMesh will return the full "
+                "array in the future (uncompressed). To get this behavior now "
+                "set the PolyQuadMesh with a 2D array .set_array(data2d)."))
+            # Setting an array of a polycollection required
+            # compressing the array
+            return np.ma.compressed(A)
+        return A
diff --git a/lib/matplotlib/tests/test_collections.py b/lib/matplotlib/tests/test_collections.py
index 56a9c68..2a1002b 100644
--- a/lib/matplotlib/tests/test_collections.py
+++ b/lib/matplotlib/tests/test_collections.py
@@ -19,6 +19,11 @@ from matplotlib.collections import (Collection, LineCollection,
 from matplotlib.testing.decorators import check_figures_equal, image_comparison
 
 
+@pytest.fixture(params=["pcolormesh", "pcolor"])
+def pcfunc(request):
+    return request.param
+
+
 def generate_EventCollection_plot():
     """Generate the initial collection and plot it."""
     positions = np.array([0., 1., 2., 3., 5., 8., 13., 21.])
@@ -818,12 +823,12 @@ def test_autolim_with_zeros(transform, expected):
     np.testing.assert_allclose(ax.get_xlim(), expected)
 
 
-def test_quadmesh_set_array_validation():
+def test_quadmesh_set_array_validation(pcfunc):
     x = np.arange(11)
     y = np.arange(8)
     z = np.random.random((7, 10))
     fig, ax = plt.subplots()
-    coll = ax.pcolormesh(x, y, z)
+    coll = getattr(ax, pcfunc)(x, y, z)
 
     with pytest.raises(ValueError, match=re.escape(
             "For X (11) and Y (8) with flat shading, A should have shape "
@@ -866,12 +871,65 @@ def test_quadmesh_set_array_validation():
     coll = ax.pcolormesh(x, y, z, shading='gouraud')
 
 
-def test_quadmesh_get_coordinates():
+def test_polyquadmesh_masked_vertices_array():
+    xx, yy = np.meshgrid([0, 1, 2], [0, 1, 2, 3])
+    # 2 x 3 mesh data
+    zz = (xx*yy)[:-1, :-1]
+    quadmesh = plt.pcolormesh(xx, yy, zz)
+    quadmesh.update_scalarmappable()
+    quadmesh_fc = quadmesh.get_facecolor()[1:, :]
+    # Mask the origin vertex in x
+    xx = np.ma.masked_where((xx == 0) & (yy == 0), xx)
+    polymesh = plt.pcolor(xx, yy, zz)
+    polymesh.update_scalarmappable()
+    # One cell should be left out
+    assert len(polymesh.get_paths()) == 5
+    # Poly version should have the same facecolors as the end of the quadmesh
+    assert_array_equal(quadmesh_fc, polymesh.get_facecolor())
+
+    # Mask the origin vertex in y
+    yy = np.ma.masked_where((xx == 0) & (yy == 0), yy)
+    polymesh = plt.pcolor(xx, yy, zz)
+    polymesh.update_scalarmappable()
+    # One cell should be left out
+    assert len(polymesh.get_paths()) == 5
+    # Poly version should have the same facecolors as the end of the quadmesh
+    assert_array_equal(quadmesh_fc, polymesh.get_facecolor())
+
+    # Mask the origin cell data
+    zz = np.ma.masked_where((xx[:-1, :-1] == 0) & (yy[:-1, :-1] == 0), zz)
+    polymesh = plt.pcolor(zz)
+    polymesh.update_scalarmappable()
+    # One cell should be left out
+    assert len(polymesh.get_paths()) == 5
+    # Poly version should have the same facecolors as the end of the quadmesh
+    assert_array_equal(quadmesh_fc, polymesh.get_facecolor())
+
+    # Setting array with 1D compressed values is deprecated
+    with pytest.warns(mpl.MatplotlibDeprecationWarning,
+                      match="Setting a PolyQuadMesh"):
+        polymesh.set_array(np.ones(5))
+
+    # We should also be able to call set_array with a new mask and get
+    # updated polys
+    # Remove mask, should add all polys back
+    zz = np.arange(6).reshape((3, 2))
+    polymesh.set_array(zz)
+    polymesh.update_scalarmappable()
+    assert len(polymesh.get_paths()) == 6
+    # Add mask should remove polys
+    zz = np.ma.masked_less(zz, 2)
+    polymesh.set_array(zz)
+    polymesh.update_scalarmappable()
+    assert len(polymesh.get_paths()) == 4
+
+
+def test_quadmesh_get_coordinates(pcfunc):
     x = [0, 1, 2]
     y = [2, 4, 6]
     z = np.ones(shape=(2, 2))
     xx, yy = np.meshgrid(x, y)
-    coll = plt.pcolormesh(xx, yy, z)
+    coll = getattr(plt, pcfunc)(xx, yy, z)
 
     # shape (3, 3, 2)
     coords = np.stack([xx.T, yy.T]).T
@@ -908,23 +966,23 @@ def test_quadmesh_set_array():
     assert np.array_equal(coll.get_array(), np.ones(16))
 
 
-def test_quadmesh_vmin_vmax():
+def test_quadmesh_vmin_vmax(pcfunc):
     # test when vmin/vmax on the norm changes, the quadmesh gets updated
     fig, ax = plt.subplots()
     cmap = mpl.colormaps['plasma']
     norm = mpl.colors.Normalize(vmin=0, vmax=1)
-    coll = ax.pcolormesh([[1]], cmap=cmap, norm=norm)
+    coll = getattr(ax, pcfunc)([[1]], cmap=cmap, norm=norm)
     fig.canvas.draw()
-    assert np.array_equal(coll.get_facecolors()[0, 0, :], cmap(norm(1)))
+    assert np.array_equal(coll.get_facecolors()[0, :], cmap(norm(1)))
 
     # Change the vmin/vmax of the norm so that the color is from
     # the bottom of the colormap now
     norm.vmin, norm.vmax = 1, 2
     fig.canvas.draw()
-    assert np.array_equal(coll.get_facecolors()[0, 0, :], cmap(norm(1)))
+    assert np.array_equal(coll.get_facecolors()[0, :], cmap(norm(1)))
 
 
-def test_quadmesh_alpha_array():
+def test_quadmesh_alpha_array(pcfunc):
     x = np.arange(4)
     y = np.arange(4)
     z = np.arange(9).reshape((3, 3))
@@ -932,26 +990,26 @@ def test_quadmesh_alpha_array():
     alpha_flat = alpha.ravel()
     # Provide 2-D alpha:
     fig, (ax0, ax1) = plt.subplots(2)
-    coll1 = ax0.pcolormesh(x, y, z, alpha=alpha)
-    coll2 = ax1.pcolormesh(x, y, z)
+    coll1 = getattr(ax0, pcfunc)(x, y, z, alpha=alpha)
+    coll2 = getattr(ax0, pcfunc)(x, y, z)
     coll2.set_alpha(alpha)
     plt.draw()
-    assert_array_equal(coll1.get_facecolors()[..., -1], alpha)
-    assert_array_equal(coll2.get_facecolors()[..., -1], alpha)
+    assert_array_equal(coll1.get_facecolors()[:, -1], alpha_flat)
+    assert_array_equal(coll2.get_facecolors()[:, -1], alpha_flat)
     # Or provide 1-D alpha:
     fig, (ax0, ax1) = plt.subplots(2)
-    coll1 = ax0.pcolormesh(x, y, z, alpha=alpha)
-    coll2 = ax1.pcolormesh(x, y, z)
+    coll1 = getattr(ax0, pcfunc)(x, y, z, alpha=alpha)
+    coll2 = getattr(ax1, pcfunc)(x, y, z)
     coll2.set_alpha(alpha)
     plt.draw()
-    assert_array_equal(coll1.get_facecolors()[..., -1], alpha)
-    assert_array_equal(coll2.get_facecolors()[..., -1], alpha)
+    assert_array_equal(coll1.get_facecolors()[:, -1], alpha_flat)
+    assert_array_equal(coll2.get_facecolors()[:, -1], alpha_flat)
 
 
-def test_alpha_validation():
+def test_alpha_validation(pcfunc):
     # Most of the relevant testing is in test_artist and test_colors.
     fig, ax = plt.subplots()
-    pc = ax.pcolormesh(np.arange(12).reshape((3, 4)))
+    pc = getattr(ax, pcfunc)(np.arange(12).reshape((3, 4)))
     with pytest.raises(ValueError, match="^Data array shape"):
         pc.set_alpha([0.5, 0.6])
         pc.update_scalarmappable()
@@ -985,15 +1043,15 @@ def test_legend_inverse_size_label_relationship():
 
 
 @mpl.style.context('default')
-@pytest.mark.parametrize('pcfunc', [plt.pcolor, plt.pcolormesh])
 def test_color_logic(pcfunc):
+    pcfunc = getattr(plt, pcfunc)
     z = np.arange(12).reshape(3, 4)
     # Explicitly set an edgecolor.
     pc = pcfunc(z, edgecolors='red', facecolors='none')
     pc.update_scalarmappable()  # This is called in draw().
     # Define 2 reference "colors" here for multiple use.
     face_default = mcolors.to_rgba_array(pc._get_default_facecolor())
-    mapped = pc.get_cmap()(pc.norm(z.ravel() if pcfunc == plt.pcolor else z))
+    mapped = pc.get_cmap()(pc.norm(z.ravel()))
     # GitHub issue #1302:
     assert mcolors.same_color(pc.get_edgecolor(), 'red')
     # Check setting attributes after initialization:
@@ -1023,7 +1081,7 @@ def test_color_logic(pcfunc):
     assert mcolors.same_color(pc.get_edgecolor(), 'none')
     assert mcolors.same_color(pc.get_facecolor(), face_default)  # not mapped
     # Turn it back on by restoring the array (must be 1D!):
-    pc.set_array(z.ravel() if pcfunc == plt.pcolor else z)
+    pc.set_array(z)
     pc.update_scalarmappable()
     assert np.array_equal(pc.get_facecolor(), mapped)
     assert mcolors.same_color(pc.get_edgecolor(), 'none')
@@ -1068,18 +1126,20 @@ def test_LineCollection_args():
     assert mcolors.same_color(lc.get_facecolor(), 'none')
 
 
-def test_array_wrong_dimensions():
+def test_array_dimensions(pcfunc):
+    # Make sure we can set the 1D, 2D, and 3D array shapes
     z = np.arange(12).reshape(3, 4)
-    pc = plt.pcolor(z)
-    with pytest.raises(ValueError, match="^Collections can only map"):
-        pc.set_array(z)
-        pc.update_scalarmappable()
-    pc = plt.pcolormesh(z)
-    pc.set_array(z)  # 2D is OK for Quadmesh
+    pc = getattr(plt, pcfunc)(z)
+    # 1D
+    pc.set_array(z.ravel())
+    pc.update_scalarmappable()
+    # 2D
+    pc.set_array(z)
     pc.update_scalarmappable()
     # 3D RGB is OK as well
-    z = np.arange(36).reshape(3, 4, 3)
+    z = np.arange(36, dtype=np.uint8).reshape(3, 4, 3)
     pc.set_array(z)
+    pc.update_scalarmappable()
 
 
 def test_get_segments():
