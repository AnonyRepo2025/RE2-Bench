{
    ".sympy.integrals.intpoly.py@@integration_reduction": "def integration_reduction(facets, index, a, b, expr, dims, degree):\n    expr = _sympify(expr)\n    if expr.is_zero:\n        return expr\n    value = S.Zero\n    x0 = facets[index].points[0]\n    m = len(facets)\n    gens = (x, y)\n    inner_product = diff(expr, gens[0]) * x0[0] + diff(expr, gens[1]) * x0[1]\n    if inner_product != 0:\n        value += integration_reduction(facets, index, a, b, inner_product, dims, degree - 1)\n    value += left_integral2D(m, index, facets, x0, expr, gens)\n    return value / (len(dims) + degree - 1)",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    cls = getattr(a, '__class__', None)\n    for superclass in getmro(cls):\n        conv = _external_converter.get(superclass)\n        if conv is None:\n            conv = _sympy_converter.get(superclass)\n        if conv is not None:\n            return conv(a)\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from sympy.tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(), locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        else:\n            for coerce in (float, int):\n                try:\n                    return sympify(coerce(a))\n                except (TypeError, ValueError, AttributeError, SympifyError):\n                    continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational, evaluate=evaluate) for x in a])\n        except TypeError:\n            pass\n    if not isinstance(a, str):\n        try:\n            a = str(a)\n        except Exception as exc:\n            raise SympifyError(a, exc)\n        sympy_deprecation_warning(f'\\nThe string fallback in sympify() is deprecated.\\n\\nTo explicitly convert the string form of an object, use\\nsympify(str(obj)). To add define sympify behavior on custom\\nobjects, use sympy.core.sympify.converter or define obj._sympy_\\n(see the sympify() docstring).\\n\\nsympify() performed the string fallback resulting in the following string:\\n\\n{a!r}\\n            ', deprecated_since_version='1.6', active_deprecations_target='deprecated-sympify-string-fallback')\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.assumptions.py@@StdFactKB.copy": "def copy(self):\n    return self.__class__(self)",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    super().__init__(_assume_rules)\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.__init__": "def __init__(self, rules):\n    self.rules = rules",
    ".sympy.core.assumptions.py@@_ask": "def _ask(fact, obj):\n    assumptions = obj._assumptions\n    handler_map = obj._prop_handler\n    try:\n        assumptions._tell(fact, None)\n    except InconsistentAssumptions:\n        return assumptions[fact]\n    try:\n        evaluate = handler_map[fact]\n    except KeyError:\n        pass\n    else:\n        a = evaluate(obj)\n        if a is not None:\n            assumptions.deduce_all_facts(((fact, a),))\n            return a\n    prereq = list(_assume_rules.prereq[fact])\n    shuffle(prereq)\n    for pk in prereq:\n        if pk in assumptions:\n            continue\n        if pk in handler_map:\n            _ask(pk, obj)\n            ret_val = assumptions.get(fact)\n            if ret_val is not None:\n                return ret_val\n    return None",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.mul.py@@Mul._eval_is_zero": "def _eval_is_zero(self):\n    zero = infinite = False\n    for a in self.args:\n        z = a.is_zero\n        if z:\n            if infinite:\n                return\n            zero = True\n        else:\n            if not a.is_finite:\n                if zero:\n                    return\n                infinite = True\n            if zero is False and z is None:\n                zero = None\n    return zero",
    ".sympy.core.basic.py@@Basic.args": "def args(self) -> 'Tuple[Basic, ...]':\n    return self._args",
    ".sympy.core.mul.py@@Mul._eval_is_rational": "def _eval_is_rational(self):\n    r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        return self.is_zero",
    ".sympy.core.logic.py@@_fuzzy_group": "def _fuzzy_group(args, quick_exit=False):\n    saw_other = False\n    for a in args:\n        if a is True:\n            continue\n        if a is None:\n            return\n        if quick_exit and saw_other:\n            return\n        saw_other = True\n    return not saw_other",
    ".sympy.core.mul.py@@Mul._eval_is_extended_real": "def _eval_is_extended_real(self):\n    return self._eval_real_imag(True)",
    ".sympy.core.mul.py@@Mul._eval_real_imag": "def _eval_real_imag(self, real):\n    zero = False\n    t_not_re_im = None\n    for t in self.args:\n        if (t.is_complex or t.is_infinite) is False and t.is_extended_real is False:\n            return False\n        elif t.is_imaginary:\n            real = not real\n        elif t.is_extended_real:\n            if not zero:\n                z = t.is_zero\n                if not z and zero is False:\n                    zero = z\n                elif z:\n                    if all((a.is_finite for a in self.args)):\n                        return True\n                    return\n        elif t.is_extended_real is False:\n            if t_not_re_im:\n                return\n            t_not_re_im = t\n        elif t.is_imaginary is False:\n            if t_not_re_im:\n                return\n            t_not_re_im = t\n        else:\n            return\n    if t_not_re_im:\n        if t_not_re_im.is_extended_real is False:\n            if real:\n                return zero\n        if t_not_re_im.is_imaginary is False:\n            if not real:\n                return zero\n    elif zero is False:\n        return real\n    elif real:\n        return real",
    ".sympy.core.mul.py@@Mul._eval_is_imaginary": "def _eval_is_imaginary(self):\n    z = self.is_zero\n    if z:\n        return False\n    if self.is_finite is False:\n        return False\n    elif z is False and self.is_finite is True:\n        return self._eval_real_imag(False)",
    ".sympy.core.mul.py@@Mul._eval_is_finite": "def _eval_is_finite(self):\n    if all((a.is_finite for a in self.args)):\n        return True\n    if any((a.is_infinite for a in self.args)):\n        if all((a.is_zero is False for a in self.args)):\n            return False",
    ".sympy.core.mul.py@@Mul._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all(((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others)):\n                return True\n            return\n        if a is None:\n            return\n    if all((x.is_real for x in self.args)):\n        return False",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.mul.py@@Mul._eval_is_odd": "def _eval_is_odd(self):\n    is_integer = self.is_integer\n    if is_integer:\n        if self.is_zero:\n            return False\n        from sympy.simplify.radsimp import fraction\n        n, d = fraction(self)\n        if d.is_Integer and d.is_even:\n            from sympy.ntheory.factor_ import trailing\n            if (Add(*[i.as_base_exp()[1] for i in Mul.make_args(n) if i.is_even]) - trailing(d.p)).is_positive:\n                return False\n            return\n        r, acc = (True, 1)\n        for t in self.args:\n            if abs(t) is S.One:\n                continue\n            assert t.is_integer\n            if t.is_even:\n                return False\n            if r is False:\n                pass\n            elif acc != 1 and (acc + t).is_odd:\n                r = False\n            elif t.is_even is None:\n                r = None\n            acc = t\n        return r\n    return is_integer",
    ".sympy.core.mul.py@@Mul._eval_is_integer": "def _eval_is_integer(self):\n    from sympy.ntheory.factor_ import trailing\n    is_rational = self._eval_is_rational()\n    if is_rational is False:\n        return False\n    numerators = []\n    denominators = []\n    unknown = False\n    for a in self.args:\n        hit = False\n        if a.is_integer:\n            if abs(a) is not S.One:\n                numerators.append(a)\n        elif a.is_Rational:\n            n, d = a.as_numer_denom()\n            if abs(n) is not S.One:\n                numerators.append(n)\n            if d is not S.One:\n                denominators.append(d)\n        elif a.is_Pow:\n            b, e = a.as_base_exp()\n            if not b.is_integer or not e.is_integer:\n                hit = unknown = True\n            if e.is_negative:\n                denominators.append(2 if a is S.Half else Pow(a, S.NegativeOne))\n            elif not hit:\n                assert not e.is_positive\n                assert not e.is_zero\n                return\n        else:\n            return\n    if not denominators and (not unknown):\n        return True\n    allodd = lambda x: all((i.is_odd for i in x))\n    alleven = lambda x: all((i.is_even for i in x))\n    anyeven = lambda x: any((i.is_even for i in x))\n    from .relational import is_gt\n    if not numerators and denominators and all((is_gt(_, S.One) for _ in denominators)):\n        return False\n    elif unknown:\n        return\n    elif allodd(numerators) and anyeven(denominators):\n        return False\n    elif anyeven(numerators) and denominators == [2]:\n        return True\n    elif alleven(numerators) and allodd(denominators) and (Mul(*denominators, evaluate=False) - 1).is_positive:\n        return False\n    if len(denominators) == 1:\n        d = denominators[0]\n        if d.is_Integer and d.is_even:\n            if (Add(*[i.as_base_exp()[1] for i in numerators if i.is_even]) - trailing(d.p)).is_nonnegative:\n                return True\n    if len(numerators) == 1:\n        n = numerators[0]\n        if n.is_Integer and n.is_even:\n            if (Add(*[i.as_base_exp()[1] for i in denominators if i.is_even]) - trailing(n.p)).is_positive:\n                return False",
    ".sympy.core.mul.py@@Mul._eval_is_algebraic": "def _eval_is_algebraic(self):\n    r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        return self.is_zero",
    ".sympy.core.mul.py@@Mul._eval_is_complex": "def _eval_is_complex(self):\n    comp = _fuzzy_group((a.is_complex for a in self.args))\n    if comp is False:\n        if any((a.is_infinite for a in self.args)):\n            if any((a.is_zero is not False for a in self.args)):\n                return None\n            return False\n    return comp",
    ".sympy.core.mul.py@@Mul._eval_is_composite": "def _eval_is_composite(self):\n    number_of_args = 0\n    for arg in self.args:\n        if not (arg.is_integer and arg.is_positive):\n            return None\n        if (arg - 1).is_positive:\n            number_of_args += 1\n    if number_of_args > 1:\n        return True",
    ".sympy.core.mul.py@@Mul._eval_is_infinite": "def _eval_is_infinite(self):\n    if any((a.is_infinite for a in self.args)):\n        if any((a.is_zero for a in self.args)):\n            return S.NaN.is_infinite\n        if any((a.is_zero is None for a in self.args)):\n            return None\n        return True",
    ".sympy.core.expr.py@@Expr._eval_is_negative": "def _eval_is_negative(self):\n    finite = self.is_finite\n    if finite is False:\n        return False\n    extended_negative = self.is_extended_negative\n    if finite is True:\n        return extended_negative\n    if extended_negative is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    return self._eval_pos_neg(-1)",
    ".sympy.core.mul.py@@Mul._eval_pos_neg": "def _eval_pos_neg(self, sign):\n    saw_NON = saw_NOT = False\n    for t in self.args:\n        if t.is_extended_positive:\n            continue\n        elif t.is_extended_negative:\n            sign = -sign\n        elif t.is_zero:\n            if all((a.is_finite for a in self.args)):\n                return False\n            return\n        elif t.is_extended_nonpositive:\n            sign = -sign\n            saw_NON = True\n        elif t.is_extended_nonnegative:\n            saw_NON = True\n        elif t.is_positive is False:\n            sign = -sign\n            if saw_NOT:\n                return\n            saw_NOT = True\n        elif t.is_negative is False:\n            if saw_NOT:\n                return\n            saw_NOT = True\n        else:\n            return\n    if sign == 1 and saw_NON is False and (saw_NOT is False):\n        return True\n    if sign < 0:\n        return False",
    ".sympy.core.expr.py@@Expr._eval_is_positive": "def _eval_is_positive(self):\n    finite = self.is_finite\n    if finite is False:\n        return False\n    extended_positive = self.is_extended_positive\n    if finite is True:\n        return extended_positive\n    if extended_positive is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    return self._eval_pos_neg(1)",
    ".sympy.core.mul.py@@Mul._eval_is_hermitian": "def _eval_is_hermitian(self):\n    return self._eval_herm_antiherm(True)",
    ".sympy.core.mul.py@@Mul._eval_herm_antiherm": "def _eval_herm_antiherm(self, real):\n    one_nc = zero = one_neither = False\n    for t in self.args:\n        if not t.is_commutative:\n            if one_nc:\n                return\n            one_nc = True\n        if t.is_antihermitian:\n            real = not real\n        elif t.is_hermitian:\n            if not zero:\n                z = t.is_zero\n                if not z and zero is False:\n                    zero = z\n                elif z:\n                    if all((a.is_finite for a in self.args)):\n                        return True\n                    return\n        elif t.is_hermitian is False:\n            if one_neither:\n                return\n            one_neither = True\n        else:\n            return\n    if one_neither:\n        if real:\n            return zero\n    elif zero is False or real:\n        return real",
    ".sympy.core.mul.py@@Mul._eval_is_even": "def _eval_is_even(self):\n    is_integer = self.is_integer\n    if is_integer:\n        return fuzzy_not(self.is_odd)\n    from sympy.simplify.radsimp import fraction\n    n, d = fraction(self)\n    if n.is_Integer and n.is_even:\n        from sympy.ntheory.factor_ import trailing\n        if (Add(*[i.as_base_exp()[1] for i in Mul.make_args(d) if i.is_even]) - trailing(n.p)).is_nonnegative:\n            return False\n    return is_integer",
    ".sympy.simplify.radsimp.py@@fraction": "def fraction(expr, exact=False):\n    expr = sympify(expr)\n    numer, denom = ([], [])\n    for term in Mul.make_args(expr):\n        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):\n            b, ex = term.as_base_exp()\n            if ex.is_negative:\n                if ex is S.NegativeOne:\n                    denom.append(b)\n                elif exact:\n                    if ex.is_constant():\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n            elif ex.is_positive:\n                numer.append(term)\n            elif not exact and ex.is_Mul:\n                n, d = term.as_numer_denom()\n                if n != 1:\n                    numer.append(n)\n                denom.append(d)\n            else:\n                numer.append(term)\n        elif term.is_Rational and (not term.is_Integer):\n            if term.p != 1:\n                numer.append(term.p)\n            denom.append(term.q)\n        else:\n            numer.append(term)\n    return (Mul(*numer, evaluate=not exact), Mul(*denom, evaluate=not exact))",
    ".sympy.core.operations.py@@AssocOp.make_args": "def make_args(cls, expr):\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    ".sympy.functions.elementary.exponential.py@@ExpMeta.__instancecheck__": "def __instancecheck__(cls, instance):\n    if exp in instance.__class__.__mro__:\n        return True\n    return isinstance(instance, Pow) and instance.base is S.Exp1",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, evaluate=None, _sympify=True):\n    if _sympify:\n        args = list(map(_sympify_, args))\n    typ = cls._args_type\n    if typ is not None:\n        from .relational import Relational\n        if any((isinstance(arg, Relational) for arg in args)):\n            raise TypeError('Relational cannot be used in %s' % cls.__name__)\n        for arg in args:\n            if not isinstance(arg, typ):\n                sympy_deprecation_warning(f'\\n\\nUsing non-Expr arguments in {cls.__name__} is deprecated (in this case, one of\\nthe arguments has type {type(arg).__name__!r}).\\n\\nIf you really did intend to use a multiplication or addition operation with\\nthis object, use the * or + operator instead.\\n\\n                        ', deprecated_since_version='1.7', active_deprecations_target='non-expr-args-deprecated', stacklevel=4)\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if not evaluate:\n        obj = cls._from_args(args)\n        obj = cls._exec_constructor_postprocessors(obj)\n        return obj\n    args = [a for a in args if a is not cls.identity]\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if order_symbols is not None:\n        from sympy.series.order import Order\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.core.mul.py@@Mul.flatten": "def flatten(cls, seq):\n    from sympy.calculus.accumulationbounds import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n            seq = [a, b]\n        assert a is not S.One\n        if not a.is_zero and a.is_Rational:\n            r, b = b.as_coeff_Mul()\n            if b.is_Add:\n                if r is not S.One:\n                    ar = a * r\n                    if ar is S.One:\n                        arb = b\n                    else:\n                        arb = cls(a * r, b, evaluate=False)\n                    rv = ([arb], [], None)\n                elif global_parameters.distribute and b.is_commutative:\n                    newb = Add(*[_keep_coeff(a, bi) for bi in b.args])\n                    rv = ([newb], [], None)\n        if rv:\n            return rv\n    c_part = []\n    nc_part = []\n    nc_seq = []\n    coeff = S.One\n    c_powers = []\n    num_exp = []\n    neg1e = S.Zero\n    pnum_rat = {}\n    order_symbols = None\n    for o in seq:\n        if o.is_Order:\n            o, order_symbols = o.as_expr_variables(order_symbols)\n        if o.is_Mul:\n            if o.is_commutative:\n                seq.extend(o.args)\n            else:\n                for q in o.args:\n                    if q.is_commutative:\n                        seq.append(q)\n                    else:\n                        nc_seq.append(q)\n                seq.append(NC_Marker)\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_zero):\n                return ([S.NaN], [], None)\n            elif coeff.is_Number or isinstance(coeff, AccumBounds):\n                coeff *= o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__mul__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if not coeff:\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o is S.ImaginaryUnit:\n            neg1e += S.Half\n            continue\n        elif o.is_commutative:\n            b, e = o.as_base_exp()\n            if o.is_Pow:\n                if b.is_Number:\n                    if e.is_Rational:\n                        if e.is_Integer:\n                            coeff *= Pow(b, e)\n                            continue\n                        elif e.is_negative:\n                            seq.append(Pow(b, e))\n                            continue\n                        elif b.is_negative:\n                            neg1e += e\n                            b = -b\n                        if b is not S.One:\n                            pnum_rat.setdefault(b, []).append(e)\n                        continue\n                    elif b.is_positive or e.is_integer:\n                        num_exp.append((b, e))\n                        continue\n            c_powers.append((b, e))\n        else:\n            if o is not NC_Marker:\n                nc_seq.append(o)\n            while nc_seq:\n                o = nc_seq.pop(0)\n                if not nc_part:\n                    nc_part.append(o)\n                    continue\n                o1 = nc_part.pop()\n                b1, e1 = o1.as_base_exp()\n                b2, e2 = o.as_base_exp()\n                new_exp = e1 + e2\n                if b1 == b2 and (not new_exp.is_Add):\n                    o12 = b1 ** new_exp\n                    if o12.is_commutative:\n                        seq.append(o12)\n                        continue\n                    else:\n                        nc_seq.insert(0, o12)\n                else:\n                    nc_part.append(o1)\n                    nc_part.append(o)\n\n    def _gather(c_powers):\n        common_b = {}\n        for b, e in c_powers:\n            co = e.as_coeff_Mul()\n            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n        for b, d in common_b.items():\n            for di, li in d.items():\n                d[di] = Add(*li)\n        new_c_powers = []\n        for b, e in common_b.items():\n            new_c_powers.extend([(b, c * t) for t, c in e.items()])\n        return new_c_powers\n    c_powers = _gather(c_powers)\n    num_exp = _gather(num_exp)\n    for i in range(2):\n        new_c_powers = []\n        changed = False\n        for b, e in c_powers:\n            if e.is_zero:\n                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):\n                    return ([S.NaN], [], None)\n                continue\n            if e is S.One:\n                if b.is_Number:\n                    coeff *= b\n                    continue\n                p = b\n            if e is not S.One:\n                p = Pow(b, e)\n                if p.is_Pow and (not b.is_Pow):\n                    bi = b\n                    b, e = p.as_base_exp()\n                    if b != bi:\n                        changed = True\n            c_part.append(p)\n            new_c_powers.append((b, e))\n        if changed and len({b for b, e in new_c_powers}) != len(new_c_powers):\n            c_part = []\n            c_powers = _gather(new_c_powers)\n        else:\n            break\n    inv_exp_dict = {}\n    for b, e in num_exp:\n        inv_exp_dict.setdefault(e, []).append(b)\n    for e, b in inv_exp_dict.items():\n        inv_exp_dict[e] = cls(*b)\n    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n    comb_e = {}\n    for b, e in pnum_rat.items():\n        comb_e.setdefault(Add(*e), []).append(b)\n    del pnum_rat\n    num_rat = []\n    for e, b in comb_e.items():\n        b = cls(*b)\n        if e.q == 1:\n            coeff *= Pow(b, e)\n            continue\n        if e.p > e.q:\n            e_i, ep = divmod(e.p, e.q)\n            coeff *= Pow(b, e_i)\n            e = Rational(ep, e.q)\n        num_rat.append((b, e))\n    del comb_e\n    pnew = defaultdict(list)\n    i = 0\n    while i < len(num_rat):\n        bi, ei = num_rat[i]\n        grow = []\n        for j in range(i + 1, len(num_rat)):\n            bj, ej = num_rat[j]\n            g = bi.gcd(bj)\n            if g is not S.One:\n                e = ei + ej\n                if e.q == 1:\n                    coeff *= Pow(g, e)\n                else:\n                    if e.p > e.q:\n                        e_i, ep = divmod(e.p, e.q)\n                        coeff *= Pow(g, e_i)\n                        e = Rational(ep, e.q)\n                    grow.append((g, e))\n                num_rat[j] = (bj / g, ej)\n                bi = bi / g\n                if bi is S.One:\n                    break\n        if bi is not S.One:\n            obj = Pow(bi, ei)\n            if obj.is_Number:\n                coeff *= obj\n            else:\n                for obj in Mul.make_args(obj):\n                    if obj.is_Number:\n                        coeff *= obj\n                    else:\n                        assert obj.is_Pow\n                        bi, ei = obj.args\n                        pnew[ei].append(bi)\n        num_rat.extend(grow)\n        i += 1\n    for e, b in pnew.items():\n        pnew[e] = cls(*b)\n    if neg1e:\n        p, q = neg1e.as_numer_denom()\n        n, p = divmod(p, q)\n        if n % 2:\n            coeff = -coeff\n        if q == 2:\n            c_part.append(S.ImaginaryUnit)\n        elif p:\n            neg1e = Rational(p, q)\n            for e, b in pnew.items():\n                if e == neg1e and b.is_positive:\n                    pnew[e] = -b\n                    break\n            else:\n                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n    c_part.extend([Pow(b, e) for e, b in pnew.items()])\n    if coeff in (S.Infinity, S.NegativeInfinity):\n\n        def _handle_for_oo(c_part, coeff_sign):\n            new_c_part = []\n            for t in c_part:\n                if t.is_extended_positive:\n                    continue\n                if t.is_extended_negative:\n                    coeff_sign *= -1\n                    continue\n                new_c_part.append(t)\n            return (new_c_part, coeff_sign)\n        c_part, coeff_sign = _handle_for_oo(c_part, 1)\n        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n        coeff *= coeff_sign\n    if coeff is S.ComplexInfinity:\n        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]\n        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]\n    elif coeff.is_zero:\n        if any((isinstance(c, MatrixExpr) for c in nc_part)):\n            return ([coeff], nc_part, order_symbols)\n        if any((c.is_finite == False for c in c_part)):\n            return ([S.NaN], [], order_symbols)\n        return ([coeff], [], order_symbols)\n    _new = []\n    for i in c_part:\n        if i.is_Number:\n            coeff *= i\n        else:\n            _new.append(i)\n    c_part = _new\n    _mulsort(c_part)\n    if coeff is not S.One:\n        c_part.insert(0, coeff)\n    if global_parameters.distribute and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add:\n        coeff = c_part[0]\n        c_part = [Add(*[coeff * f for f in c_part[1].args])]\n    return (c_part, nc_part, order_symbols)",
    ".sympy.core.expr.py@@Expr.as_base_exp": "def as_base_exp(self) -> tTuple['Expr', 'Expr']:\n    return (self, S.One)",
    ".sympy.core.mul.py@@Mul._gather": "def _gather(c_powers):\n    common_b = {}\n    for b, e in c_powers:\n        co = e.as_coeff_Mul()\n        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n    for b, d in common_b.items():\n        for di, li in d.items():\n            d[di] = Add(*li)\n    new_c_powers = []\n    for b, e in common_b.items():\n        new_c_powers.extend([(b, c * t) for t, c in e.items()])\n    return new_c_powers",
    ".sympy.core.numbers.py@@Rational.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (self, S.One)",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self) -> int:\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.numbers.py@@Integer.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p * other)\n        elif isinstance(other, Integer):\n            return Integer(self.p * other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, str):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    if ival == 1:\n        return S.One\n    if ival == -1:\n        return S.NegativeOne\n    if ival == 0:\n        return S.Zero\n    obj = Expr.__new__(cls)\n    obj.p = ival\n    return obj",
    ".sympy.core.numbers.py@@Zero.__bool__": "def __bool__(self):\n    return False",
    ".sympy.core.numbers.py@@Infinity.__eq__": "def __eq__(self, other):\n    return other is S.Infinity or other == float('inf')",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if not isinstance(other, Number):\n        return False\n    if not self:\n        return not other\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Rational:\n        return self.p == other.p and self.q == other.q\n    if other.is_Float:\n        if self.q & self.q - 1:\n            return False\n        s, m, t = other._mpf_[:3]\n        if s:\n            m = -m\n        if not t:\n            if not self.is_Integer or self.is_even:\n                return False\n            return m == self.p\n        from .power import integer_log\n        if t > 0:\n            if not self.is_Integer:\n                return False\n            return self.p and (not self.p % m) and (integer_log(self.p // m, 2) == (t, True))\n        if self.is_Integer:\n            return False\n        return m == self.p and integer_log(self.q, 2) == (-t, True)\n    return False",
    ".sympy.core.numbers.py@@Float.__new__": "def __new__(cls, num, dps=None, precision=None):\n    if dps is not None and precision is not None:\n        raise ValueError('Both decimal and binary precision supplied. Supply only one. ')\n    if isinstance(num, str):\n        num = num.replace(' ', '').lower()\n        if num.startswith('.') and len(num) > 1:\n            num = '0' + num\n        elif num.startswith('-.') and len(num) > 2:\n            num = '-0.' + num[2:]\n        elif num in ('inf', '+inf'):\n            return S.Infinity\n        elif num == '-inf':\n            return S.NegativeInfinity\n    elif isinstance(num, float) and num == 0:\n        num = '0'\n    elif isinstance(num, float) and num == float('inf'):\n        return S.Infinity\n    elif isinstance(num, float) and num == float('-inf'):\n        return S.NegativeInfinity\n    elif isinstance(num, float) and math.isnan(num):\n        return S.NaN\n    elif isinstance(num, (SYMPY_INTS, Integer)):\n        num = str(num)\n    elif num is S.Infinity:\n        return num\n    elif num is S.NegativeInfinity:\n        return num\n    elif num is S.NaN:\n        return num\n    elif _is_numpy_instance(num):\n        num = _convert_numpy_types(num)\n    elif isinstance(num, mpmath.mpf):\n        if precision is None:\n            if dps is None:\n                precision = num.context.prec\n        num = num._mpf_\n    if dps is None and precision is None:\n        dps = 15\n        if isinstance(num, Float):\n            return num\n        if isinstance(num, str) and _literal_float(num):\n            try:\n                Num = decimal.Decimal(num)\n            except decimal.InvalidOperation:\n                pass\n            else:\n                isint = '.' not in num\n                num, dps = _decimal_to_Rational_prec(Num)\n                if num.is_Integer and isint:\n                    dps = max(dps, len(str(num).lstrip('-')))\n                dps = max(15, dps)\n                precision = dps_to_prec(dps)\n    elif precision == '' and dps is None or (precision is None and dps == ''):\n        if not isinstance(num, str):\n            raise ValueError('The null string can only be used when the number to Float is passed as a string or an integer.')\n        ok = None\n        if _literal_float(num):\n            try:\n                Num = decimal.Decimal(num)\n            except decimal.InvalidOperation:\n                pass\n            else:\n                isint = '.' not in num\n                num, dps = _decimal_to_Rational_prec(Num)\n                if num.is_Integer and isint:\n                    dps = max(dps, len(str(num).lstrip('-')))\n                    precision = dps_to_prec(dps)\n                ok = True\n        if ok is None:\n            raise ValueError('string-float not recognized: %s' % num)\n    if precision is None or precision == '':\n        precision = dps_to_prec(dps)\n    precision = int(precision)\n    if isinstance(num, float):\n        _mpf_ = mlib.from_float(num, precision, rnd)\n    elif isinstance(num, str):\n        _mpf_ = mlib.from_str(num, precision, rnd)\n    elif isinstance(num, decimal.Decimal):\n        if num.is_finite():\n            _mpf_ = mlib.from_str(str(num), precision, rnd)\n        elif num.is_nan():\n            return S.NaN\n        elif num.is_infinite():\n            if num > 0:\n                return S.Infinity\n            return S.NegativeInfinity\n        else:\n            raise ValueError('unexpected decimal value %s' % str(num))\n    elif isinstance(num, tuple) and len(num) in (3, 4):\n        if isinstance(num[1], str):\n            num = list(num)\n            if num[1].endswith('L'):\n                num[1] = num[1][:-1]\n            if num[1].startswith('0x'):\n                num[1] = num[1][2:]\n            num[1] = MPZ(num[1], 16)\n            _mpf_ = tuple(num)\n        elif len(num) == 4:\n            return Float._new(num, precision)\n        else:\n            if not all((num[0] in (0, 1), num[1] >= 0, all((type(i) in (int, int) for i in num)))):\n                raise ValueError('malformed mpf: %s' % (num,))\n            return Float._new((num[0], num[1], num[2], bitcount(num[1])), precision)\n    else:\n        try:\n            _mpf_ = num._as_mpf_val(precision)\n        except (NotImplementedError, AttributeError):\n            _mpf_ = mpmath.mpf(num, prec=precision)._mpf_\n    return cls._new(_mpf_, precision, zero=False)",
    ".sympy.core.numbers.py@@NegativeInfinity.__eq__": "def __eq__(self, other):\n    return other is S.NegativeInfinity or other == float('-inf')",
    ".sympy.core.mul.py@@_mulsort": "def _mulsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.basic.py@@Basic.compare": "def compare(self, other):\n    if self is other:\n        return 0\n    n1 = self.__class__\n    n2 = other.__class__\n    c = (n1 > n2) - (n1 < n2)\n    if c:\n        return c\n    st = self._hashable_content()\n    ot = other._hashable_content()\n    c = (len(st) > len(ot)) - (len(st) < len(ot))\n    if c:\n        return c\n    for l, r in zip(st, ot):\n        l = Basic(*l) if isinstance(l, frozenset) else l\n        r = Basic(*r) if isinstance(r, frozenset) else r\n        if isinstance(l, Basic):\n            c = l.compare(r)\n        else:\n            c = (l > r) - (l < r)\n        if c:\n            return c\n    return 0",
    ".sympy.core.core.py@@BasicMeta.__gt__": "def __gt__(cls, other):\n    if cls.__cmp__(other) == 1:\n        return True\n    return False",
    ".sympy.core.core.py@@BasicMeta.__cmp__": "def __cmp__(cls, other):\n    if not isinstance(other, BasicMeta):\n        return -1\n    n1 = cls.__name__\n    n2 = other.__name__\n    if n1 == n2:\n        return 0\n    UNKNOWN = len(ordering_of_classes) + 1\n    try:\n        i1 = ordering_of_classes.index(n1)\n    except ValueError:\n        i1 = UNKNOWN\n    try:\n        i2 = ordering_of_classes.index(n2)\n    except ValueError:\n        i2 = UNKNOWN\n    if i1 == UNKNOWN and i2 == UNKNOWN:\n        return (n1 > n2) - (n1 < n2)\n    return (i1 > i2) - (i1 < i2)",
    ".sympy.core.core.py@@BasicMeta.__lt__": "def __lt__(cls, other):\n    if cls.__cmp__(other) == -1:\n        return True\n    return False",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return {key: value for key, value in self._assumptions.items() if value is not None}",
    ".sympy.core.operations.py@@AssocOp._from_args": "def _from_args(cls, args, is_commutative=None):\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n    obj = super().__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and((a.is_commutative for a in args))\n    obj.is_commutative = is_commutative\n    return obj",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.basic.py@@Basic._exec_constructor_postprocessors": "def _exec_constructor_postprocessors(cls, obj):\n    clsname = obj.__class__.__name__\n    postprocessors = defaultdict(list)\n    for i in obj.args:\n        try:\n            postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)\n            for k, v in chain.from_iterable(postprocessor_mappings):\n                postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n        except TypeError:\n            pass\n    for f in postprocessors.get(clsname, []):\n        obj = f(obj)\n    return obj",
    ".sympy.core.mul.py@@Mul._eval_is_antihermitian": "def _eval_is_antihermitian(self):\n    z = self.is_zero\n    if z:\n        return False\n    elif z is False:\n        return self._eval_herm_antiherm(False)",
    ".sympy.geometry.line.py@@LinearEntity.points": "def points(self):\n    return (self.p1, self.p2)",
    ".sympy.geometry.line.py@@LinearEntity.p1": "def p1(self):\n    return self.args[0]",
    ".sympy.geometry.line.py@@LinearEntity.p2": "def p2(self):\n    return self.args[1]",
    ".sympy.core.function.py@@diff": "def diff(f, *symbols, **kwargs):\n    if hasattr(f, 'diff'):\n        return f.diff(*symbols, **kwargs)\n    kwargs.setdefault('evaluate', True)\n    return _derivative_dispatch(f, *symbols, **kwargs)",
    ".sympy.core.expr.py@@Expr.diff": "def diff(self, *symbols, **assumptions):\n    assumptions.setdefault('evaluate', True)\n    return _derivative_dispatch(self, *symbols, **assumptions)",
    ".sympy.core.function.py@@_derivative_dispatch": "def _derivative_dispatch(expr, *variables, **kwargs):\n    from sympy.matrices.common import MatrixCommon\n    from sympy.matrices.expressions.matexpr import MatrixExpr\n    from sympy.tensor.array import NDimArray\n    array_types = (MatrixCommon, MatrixExpr, NDimArray, list, tuple, Tuple)\n    if isinstance(expr, array_types) or any((isinstance(i[0], array_types) if isinstance(i, (tuple, list, Tuple)) else isinstance(i, array_types) for i in variables)):\n        from sympy.tensor.array.array_derivatives import ArrayDerivative\n        return ArrayDerivative(expr, *variables, **kwargs)\n    return Derivative(expr, *variables, **kwargs)",
    ".sympy.core.function.py@@Derivative.__new__": "def __new__(cls, expr, *variables, **kwargs):\n    expr = sympify(expr)\n    symbols_or_none = getattr(expr, 'free_symbols', None)\n    has_symbol_set = isinstance(symbols_or_none, set)\n    if not has_symbol_set:\n        raise ValueError(filldedent('\\n            Since there are no variables in the expression %s,\\n            it cannot be differentiated.' % expr))\n    if not variables:\n        variables = expr.free_symbols\n        if len(variables) != 1:\n            if expr.is_number:\n                return S.Zero\n            if len(variables) == 0:\n                raise ValueError(filldedent('\\n                    Since there are no variables in the expression,\\n                    the variable(s) of differentiation must be supplied\\n                    to differentiate %s' % expr))\n            else:\n                raise ValueError(filldedent('\\n                    Since there is more than one variable in the\\n                    expression, the variable(s) of differentiation\\n                    must be supplied to differentiate %s' % expr))\n    variable_count = []\n    array_likes = (tuple, list, Tuple)\n    from sympy.tensor.array import Array, NDimArray\n    for i, v in enumerate(variables):\n        if isinstance(v, UndefinedFunction):\n            raise TypeError('cannot differentiate wrt UndefinedFunction: %s' % v)\n        if isinstance(v, array_likes):\n            if len(v) == 0:\n                continue\n            if isinstance(v[0], array_likes):\n                if len(v) == 1:\n                    v = Array(v[0])\n                    count = 1\n                else:\n                    v, count = v\n                    v = Array(v)\n            else:\n                v, count = v\n            if count == 0:\n                continue\n            variable_count.append(Tuple(v, count))\n            continue\n        v = _sympify(v)\n        if isinstance(v, Integer):\n            if i == 0:\n                raise ValueError('First variable cannot be a number: %i' % v)\n            count = v\n            prev, prevcount = variable_count[-1]\n            if prevcount != 1:\n                raise TypeError('tuple {} followed by number {}'.format((prev, prevcount), v))\n            if count == 0:\n                variable_count.pop()\n            else:\n                variable_count[-1] = Tuple(prev, count)\n        else:\n            count = 1\n            variable_count.append(Tuple(v, count))\n    merged = []\n    for t in variable_count:\n        v, c = t\n        if c.is_negative:\n            raise ValueError('order of differentiation must be nonnegative')\n        if merged and merged[-1][0] == v:\n            c += merged[-1][1]\n            if not c:\n                merged.pop()\n            else:\n                merged[-1] = Tuple(v, c)\n        else:\n            merged.append(t)\n    variable_count = merged\n    for v, c in variable_count:\n        if not v._diff_wrt:\n            __ = ''\n            raise ValueError(filldedent(\"\\n                Can't calculate derivative wrt %s.%s\" % (v, __)))\n    if len(variable_count) == 0:\n        return expr\n    evaluate = kwargs.get('evaluate', False)\n    if evaluate:\n        if isinstance(expr, Derivative):\n            expr = expr.canonical\n        variable_count = [(v.canonical if isinstance(v, Derivative) else v, c) for v, c in variable_count]\n        zero = False\n        free = expr.free_symbols\n        from sympy.matrices.expressions.matexpr import MatrixExpr\n        for v, c in variable_count:\n            vfree = v.free_symbols\n            if c.is_positive and vfree:\n                if isinstance(v, AppliedUndef):\n                    D = Dummy()\n                    if not expr.xreplace({v: D}).has(D):\n                        zero = True\n                        break\n                elif isinstance(v, MatrixExpr):\n                    zero = False\n                    break\n                elif isinstance(v, Symbol) and v not in free:\n                    zero = True\n                    break\n                elif not free & vfree:\n                    zero = True\n                    break\n        if zero:\n            return cls._get_zero_with_shape_like(expr)\n        variable_count = cls._sort_variable_count(variable_count)\n    if isinstance(expr, Derivative):\n        variable_count = list(expr.variable_count) + variable_count\n        expr = expr.expr\n        return _derivative_dispatch(expr, *variable_count, **kwargs)\n    if not evaluate or not hasattr(expr, '_eval_derivative'):\n        if evaluate and variable_count == [(expr, 1)] and expr.is_scalar:\n            return S.One\n        return Expr.__new__(cls, expr, *variable_count)\n    nderivs = 0\n    unhandled = []\n    from sympy.matrices.common import MatrixCommon\n    for i, (v, count) in enumerate(variable_count):\n        old_expr = expr\n        old_v = None\n        is_symbol = v.is_symbol or isinstance(v, (Iterable, Tuple, MatrixCommon, NDimArray))\n        if not is_symbol:\n            old_v = v\n            v = Dummy('xi')\n            expr = expr.xreplace({old_v: v})\n            clashing = not (isinstance(old_v, Derivative) or isinstance(old_v, AppliedUndef))\n            if v not in expr.free_symbols and (not clashing):\n                return expr.diff(v)\n            if not old_v.is_scalar and (not hasattr(old_v, '_eval_derivative')):\n                expr *= old_v.diff(old_v)\n        obj = cls._dispatch_eval_derivative_n_times(expr, v, count)\n        if obj is not None and obj.is_zero:\n            return obj\n        nderivs += count\n        if old_v is not None:\n            if obj is not None:\n                obj = obj.subs(v, old_v)\n            expr = old_expr\n        if obj is None:\n            unhandled = variable_count[i:]\n            break\n        expr = obj\n    expr = expr.replace(lambda x: isinstance(x, Derivative), lambda x: x.canonical)\n    if unhandled:\n        if isinstance(expr, Derivative):\n            unhandled = list(expr.variable_count) + unhandled\n            expr = expr.expr\n        expr = Expr.__new__(cls, expr, *unhandled)\n    if (nderivs > 1) == True and kwargs.get('simplify', True):\n        from .exprtools import factor_terms\n        from sympy.simplify.simplify import signsimp\n        expr = factor_terms(signsimp(expr))\n    return expr",
    ".sympy.core.basic.py@@Basic.free_symbols": "def free_symbols(self) -> 'Set[Basic]':\n    empty: 'Set[Basic]' = set()\n    return empty.union(*(a.free_symbols for a in self.args))",
    ".sympy.core.symbol.py@@Symbol.free_symbols": "def free_symbols(self):\n    return {self}",
    ".sympy.core.containers.py@@Tuple.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.symbol.py@@Symbol._diff_wrt": "def _diff_wrt(self):\n    return True",
    ".sympy.core.function.py@@Derivative._sort_variable_count": "def _sort_variable_count(cls, vc):\n    if not vc:\n        return []\n    vc = list(vc)\n    if len(vc) == 1:\n        return [Tuple(*vc[0])]\n    V = list(range(len(vc)))\n    E = []\n    v = lambda i: vc[i][0]\n    D = Dummy()\n\n    def _block(d, v, wrt=False):\n        if d == v:\n            return wrt\n        if d.is_Symbol:\n            return False\n        if isinstance(d, Derivative):\n            if any((_block(k, v, wrt=True) for k in d._wrt_variables)):\n                return True\n            return False\n        if not wrt and isinstance(d, AppliedUndef):\n            return False\n        if v.is_Symbol:\n            return v in d.free_symbols\n        if isinstance(v, AppliedUndef):\n            return _block(d.xreplace({v: D}), D)\n        return d.free_symbols & v.free_symbols\n    for i in range(len(vc)):\n        for j in range(i):\n            if _block(v(j), v(i)):\n                E.append((j, i))\n    O = dict(zip(ordered(uniq([i for i, c in vc])), range(len(vc))))\n    ix = topological_sort((V, E), key=lambda i: O[v(i)])\n    merged = []\n    for v, c in [vc[i] for i in ix]:\n        if merged and merged[-1][0] == v:\n            merged[-1][1] += c\n        else:\n            merged.append([v, c])\n    return [Tuple(*i) for i in merged]",
    ".sympy.core.function.py@@Derivative._dispatch_eval_derivative_n_times": "def _dispatch_eval_derivative_n_times(cls, expr, v, count):\n    return expr._eval_derivative_n_times(v, count)",
    ".sympy.core.mul.py@@Mul._eval_derivative_n_times": "def _eval_derivative_n_times(self, s, n):\n    from .function import AppliedUndef\n    from .symbol import Symbol, symbols, Dummy\n    if not isinstance(s, (AppliedUndef, Symbol)):\n        return super()._eval_derivative_n_times(s, n)\n    from .numbers import Integer\n    args = self.args\n    m = len(args)\n    if isinstance(n, (int, Integer)):\n        terms = []\n        from sympy.ntheory.multinomial import multinomial_coefficients_iterator\n        for kvals, c in multinomial_coefficients_iterator(m, n):\n            p = prod([arg.diff((s, k)) for k, arg in zip(kvals, args)])\n            terms.append(c * p)\n        return Add(*terms)\n    from sympy.concrete.summations import Sum\n    from sympy.functions.combinatorial.factorials import factorial\n    from sympy.functions.elementary.miscellaneous import Max\n    kvals = symbols('k1:%i' % m, cls=Dummy)\n    klast = n - sum(kvals)\n    nfact = factorial(n)\n    e, l = (nfact / prod(map(factorial, kvals)) / factorial(klast) * prod([args[t].diff((s, kvals[t])) for t in range(m - 1)]) * args[-1].diff((s, Max(0, klast))), [(k, 0, n) for k in kvals])\n    return Sum(e, *l)",
    ".sympy.ntheory.multinomial.py@@multinomial_coefficients_iterator": "def multinomial_coefficients_iterator(m, n, _tuple=tuple):\n    m = as_int(m)\n    n = as_int(n)\n    if m < 2 * n or n == 1:\n        mc = multinomial_coefficients(m, n)\n        yield from mc.items()\n    else:\n        mc = multinomial_coefficients(n, n)\n        mc1 = {}\n        for k, v in mc.items():\n            mc1[_tuple(filter(None, k))] = v\n        mc = mc1\n        t = [n] + [0] * (m - 1)\n        t1 = _tuple(t)\n        b = _tuple(filter(None, t1))\n        yield (t1, mc[b])\n        if n:\n            j = 0\n        else:\n            j = m\n        while j < m - 1:\n            tj = t[j]\n            if j:\n                t[j] = 0\n                t[0] = tj\n            if tj > 1:\n                t[j + 1] += 1\n                j = 0\n            else:\n                j += 1\n                t[j] += 1\n            t[0] -= 1\n            t1 = _tuple(t)\n            b = _tuple(filter(None, t1))\n            yield (t1, mc[b])",
    ".sympy.utilities.misc.py@@as_int": "def as_int(n, strict=True):\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n != result:\n            raise ValueError('%s is not an integer' % (n,))\n        return result",
    ".sympy.core.numbers.py@@Integer.__index__": "def __index__(self):\n    return self.p",
    ".sympy.ntheory.multinomial.py@@multinomial_coefficients": "def multinomial_coefficients(m, n):\n    m = as_int(m)\n    n = as_int(n)\n    if not m:\n        if n:\n            return {}\n        return {(): 1}\n    if m == 2:\n        return binomial_coefficients(n)\n    if m >= 2 * n and n > 1:\n        return dict(multinomial_coefficients_iterator(m, n))\n    t = [n] + [0] * (m - 1)\n    r = {tuple(t): 1}\n    if n:\n        j = 0\n    else:\n        j = m\n    while j < m - 1:\n        tj = t[j]\n        if j:\n            t[j] = 0\n            t[0] = tj\n        if tj > 1:\n            t[j + 1] += 1\n            j = 0\n            start = 1\n            v = 0\n        else:\n            j += 1\n            start = j + 1\n            v = r[tuple(t)]\n            t[j] += 1\n        for k in range(start, m):\n            if t[k]:\n                t[k] -= 1\n                v += r[tuple(t)]\n                t[k] += 1\n        t[0] -= 1\n        r[tuple(t)] = v * tj // (n - t[0])\n    return r",
    ".sympy.ntheory.multinomial.py@@binomial_coefficients": "def binomial_coefficients(n):\n    n = as_int(n)\n    d = {(0, n): 1, (n, 0): 1}\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k, n - k] = d[n - k, k] = a\n    return d",
    ".sympy.core.function.py@@Derivative._get_zero_with_shape_like": "def _get_zero_with_shape_like(cls, expr):\n    return S.Zero",
    ".sympy.core.mul.py@@prod": "def prod(a, start=1):\n    return reduce(operator.mul, a, start)",
    ".sympy.core.decorators.py@@_SympifyWrapper._func": "def _func(self, other):\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    ".sympy.core.decorators.py@@binary_op_wrapper": "def binary_op_wrapper(self, other):\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:\n            f = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    ".sympy.core.expr.py@@Expr.__rmul__": "def __rmul__(self, other):\n    return Mul(other, self)",
    ".sympy.core.expr.py@@Expr.__mul__": "def __mul__(self, other):\n    return Mul(self, other)",
    ".sympy.core.numbers.py@@Integer.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other * self.p)\n        elif isinstance(other, Rational):\n            return Rational(other.p * self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    ".sympy.core.expr.py@@AtomicExpr._eval_derivative_n_times": "def _eval_derivative_n_times(self, s, n):\n    from .containers import Tuple\n    from sympy.matrices.expressions.matexpr import MatrixExpr\n    from sympy.matrices.common import MatrixCommon\n    if isinstance(s, (MatrixCommon, Tuple, Iterable, MatrixExpr)):\n        return super()._eval_derivative_n_times(s, n)\n    from .relational import Eq\n    from sympy.functions.elementary.piecewise import Piecewise\n    if self == s:\n        return Piecewise((self, Eq(n, 0)), (1, Eq(n, 1)), (0, True))\n    else:\n        return Piecewise((self, Eq(n, 0)), (0, True))",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n    if not (self.is_Number and other.is_Number) and type(self) != type(other):\n        return False\n    a, b = (self._hashable_content(), other._hashable_content())\n    if a != b:\n        return False\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    ".sympy.core.relational.py@@Equality.__new__": "def __new__(cls, lhs, rhs=None, **options):\n    if rhs is None:\n        sympy_deprecation_warning('\\n            Eq(expr) with a single argument with the right-hand side\\n            defaulting to 0 is deprecated. Use Eq(expr, 0) instead.\\n            ', deprecated_since_version='1.5', active_deprecations_target='deprecated-eq-expr')\n        rhs = 0\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    if evaluate:\n        val = is_eq(lhs, rhs)\n        if val is None:\n            return cls(lhs, rhs, evaluate=False)\n        else:\n            return _sympify(val)\n    return Relational.__new__(cls, lhs, rhs)",
    ".sympy.core.relational.py@@is_eq": "def is_eq(lhs, rhs, assumptions=None):\n    for side1, side2 in ((lhs, rhs), (rhs, lhs)):\n        eval_func = getattr(side1, '_eval_Eq', None)\n        if eval_func is not None:\n            retval = eval_func(side2)\n            if retval is not None:\n                return retval\n    retval = _eval_is_eq(lhs, rhs)\n    if retval is not None:\n        return retval\n    if dispatch(type(lhs), type(rhs)) != dispatch(type(rhs), type(lhs)):\n        retval = _eval_is_eq(rhs, lhs)\n        if retval is not None:\n            return retval\n    if lhs == rhs:\n        return True\n    elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):\n        return False\n    elif not (lhs.is_Symbol or rhs.is_Symbol) and isinstance(lhs, Boolean) != isinstance(rhs, Boolean):\n        return False\n    from sympy.assumptions.wrapper import AssumptionsWrapper, is_infinite, is_extended_real\n    from .add import Add\n    _lhs = AssumptionsWrapper(lhs, assumptions)\n    _rhs = AssumptionsWrapper(rhs, assumptions)\n    if _lhs.is_infinite or _rhs.is_infinite:\n        if fuzzy_xor([_lhs.is_infinite, _rhs.is_infinite]):\n            return False\n        if fuzzy_xor([_lhs.is_extended_real, _rhs.is_extended_real]):\n            return False\n        if fuzzy_and([_lhs.is_extended_real, _rhs.is_extended_real]):\n            return fuzzy_xor([_lhs.is_extended_positive, fuzzy_not(_rhs.is_extended_positive)])\n        I = S.ImaginaryUnit\n\n        def split_real_imag(expr):\n            real_imag = lambda t: 'real' if is_extended_real(t, assumptions) else 'imag' if is_extended_real(I * t, assumptions) else None\n            return sift(Add.make_args(expr), real_imag)\n        lhs_ri = split_real_imag(lhs)\n        if not lhs_ri[None]:\n            rhs_ri = split_real_imag(rhs)\n            if not rhs_ri[None]:\n                eq_real = is_eq(Add(*lhs_ri['real']), Add(*rhs_ri['real']), assumptions)\n                eq_imag = is_eq(I * Add(*lhs_ri['imag']), I * Add(*rhs_ri['imag']), assumptions)\n                return fuzzy_and(map(fuzzy_bool, [eq_real, eq_imag]))\n        from sympy.functions.elementary.complexes import arg\n        arglhs = arg(lhs)\n        argrhs = arg(rhs)\n        if not (arglhs == S.NaN and argrhs == S.NaN):\n            return fuzzy_bool(is_eq(arglhs, argrhs, assumptions))\n    if all((isinstance(i, Expr) for i in (lhs, rhs))):\n        dif = lhs - rhs\n        _dif = AssumptionsWrapper(dif, assumptions)\n        z = _dif.is_zero\n        if z is not None:\n            if z is False and _dif.is_commutative:\n                return False\n            if z:\n                return True\n        n2 = _n2(lhs, rhs)\n        if n2 is not None:\n            return _sympify(n2 == 0)\n        n, d = dif.as_numer_denom()\n        rv = None\n        _n = AssumptionsWrapper(n, assumptions)\n        _d = AssumptionsWrapper(d, assumptions)\n        if _n.is_zero:\n            rv = _d.is_nonzero\n        elif _n.is_finite:\n            if _d.is_infinite:\n                rv = True\n            elif _n.is_zero is False:\n                rv = _d.is_infinite\n                if rv is None:\n                    from sympy.simplify.simplify import clear_coefficients\n                    l, r = clear_coefficients(d, S.Infinity)\n                    args = [_.subs(l, r) for _ in (lhs, rhs)]\n                    if args != [lhs, rhs]:\n                        rv = fuzzy_bool(is_eq(*args, assumptions))\n                        if rv is True:\n                            rv = None\n        elif any((is_infinite(a, assumptions) for a in Add.make_args(n))):\n            rv = False\n        if rv is not None:\n            return rv",
    ".sympy.multipledispatch.dispatcher.py@@Dispatcher.__call__": "def __call__(self, *args, **kwargs):\n    types = tuple([type(arg) for arg in args])\n    try:\n        func = self._cache[types]\n    except KeyError:\n        func = self.dispatch(*types)\n        if not func:\n            raise NotImplementedError('Could not find signature for %s: <%s>' % (self.name, str_signature(types)))\n        self._cache[types] = func\n    try:\n        return func(*args, **kwargs)\n    except MDNotImplementedError:\n        funcs = self.dispatch_iter(*types)\n        next(funcs)\n        for func in funcs:\n            try:\n                return func(*args, **kwargs)\n            except MDNotImplementedError:\n                pass\n        raise NotImplementedError('Matching functions for %s: <%s> found, but none completed successfully' % (self.name, str_signature(types)))",
    ".sympy.multipledispatch.dispatcher.py@@Dispatcher.dispatch": "def dispatch(self, *types):\n    if types in self.funcs:\n        return self.funcs[types]\n    try:\n        return next(self.dispatch_iter(*types))\n    except StopIteration:\n        return None",
    ".sympy.multipledispatch.dispatcher.py@@Dispatcher.dispatch_iter": "def dispatch_iter(self, *types):\n    n = len(types)\n    for signature in self.ordering:\n        if len(signature) == n and all(map(issubclass, types, signature)):\n            result = self.funcs[signature]\n            yield result",
    ".sympy.core.relational.py@@_eval_is_eq": "def _eval_is_eq(lhs, rhs):\n    return None",
    ".sympy.multipledispatch.core.py@@dispatch": "def dispatch(*types, namespace=global_namespace, on_ambiguity=ambiguity_warn):\n    types = tuple(types)\n\n    def _(func):\n        name = func.__name__\n        if ismethod(func):\n            dispatcher = inspect.currentframe().f_back.f_locals.get(name, MethodDispatcher(name))\n        else:\n            if name not in namespace:\n                namespace[name] = Dispatcher(name)\n            dispatcher = namespace[name]\n        dispatcher.add(types, func, on_ambiguity=on_ambiguity)\n        return dispatcher\n    return _",
    ".sympy.assumptions.wrapper.py@@AssumptionsWrapper.__new__": "def __new__(cls, expr, assumptions=None):\n    if assumptions is None:\n        return expr\n    obj = super().__new__(cls, expr, _sympify(assumptions))\n    obj.expr = expr\n    obj.assumptions = assumptions\n    return obj",
    ".sympy.core.numbers.py@@Integer.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    ".sympy.functions.elementary.piecewise.py@@Piecewise.__new__": "def __new__(cls, *args, **options):\n    if len(args) == 0:\n        raise TypeError('At least one (expr, cond) pair expected.')\n    newargs = []\n    for ec in args:\n        pair = ExprCondPair(*getattr(ec, 'args', ec))\n        cond = pair.cond\n        if cond is false:\n            continue\n        newargs.append(pair)\n        if cond is true:\n            break\n    eval = options.pop('evaluate', global_parameters.evaluate)\n    if eval:\n        r = cls.eval(*newargs)\n        if r is not None:\n            return r\n    elif len(newargs) == 1 and newargs[0].cond == True:\n        return newargs[0].expr\n    return Basic.__new__(cls, *newargs, **options)",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.__new__": "def __new__(cls, expr, cond):\n    expr = as_Basic(expr)\n    if cond == True:\n        return Tuple.__new__(cls, expr, true)\n    elif cond == False:\n        return Tuple.__new__(cls, expr, false)\n    elif isinstance(cond, Basic) and cond.has(Piecewise):\n        cond = piecewise_fold(cond)\n        if isinstance(cond, Piecewise):\n            cond = cond.rewrite(ITE)\n    if not isinstance(cond, Boolean):\n        raise TypeError(filldedent('\\n            Second argument must be a Boolean,\\n            not `%s`' % func_name(cond)))\n    return Tuple.__new__(cls, expr, cond)",
    ".sympy.core.basic.py@@as_Basic": "def as_Basic(expr):\n    try:\n        return _sympify(expr)\n    except SympifyError:\n        raise TypeError('Argument must be a Basic object, not `%s`' % func_name(expr))",
    ".sympy.logic.boolalg.py@@BooleanFalse.__eq__": "def __eq__(self, other):\n    if other is True:\n        return False\n    if other is False:\n        return True\n    return super().__eq__(other)",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.cond": "def cond(self):\n    return self.args[1]",
    ".sympy.logic.boolalg.py@@BooleanTrue.__eq__": "def __eq__(self, other):\n    if other is True:\n        return True\n    if other is False:\n        return False\n    return super().__eq__(other)",
    ".sympy.functions.elementary.piecewise.py@@Piecewise.eval": "def eval(cls, *_args):\n    if not _args:\n        return Undefined\n    if len(_args) == 1 and _args[0][-1] == True:\n        return _args[0][0]\n    newargs = []\n    current_cond = set()\n    for expr, cond in _args:\n        cond = cond.replace(lambda _: _.is_Relational, _canonical_coeff)\n        if isinstance(expr, Piecewise):\n            unmatching = []\n            for i, (e, c) in enumerate(expr.args):\n                if c in current_cond:\n                    continue\n                if c == cond:\n                    if c != True:\n                        if unmatching:\n                            expr = Piecewise(*unmatching + [(e, c)])\n                        else:\n                            expr = e\n                    break\n                else:\n                    unmatching.append((e, c))\n        got = False\n        for i in [cond] + (list(cond.args) if isinstance(cond, And) else []):\n            if i in current_cond:\n                got = True\n                break\n        if got:\n            continue\n        if isinstance(cond, And):\n            nonredundant = []\n            for c in cond.args:\n                if isinstance(c, Relational):\n                    if c.negated.canonical in current_cond:\n                        continue\n                    if isinstance(c, (Lt, Gt)) and c.weak in current_cond:\n                        cond = False\n                        break\n                nonredundant.append(c)\n            else:\n                cond = cond.func(*nonredundant)\n        elif isinstance(cond, Relational):\n            if cond.negated.canonical in current_cond:\n                cond = S.true\n        current_cond.add(cond)\n        if newargs:\n            if newargs[-1].expr == expr:\n                orcond = Or(cond, newargs[-1].cond)\n                if isinstance(orcond, (And, Or)):\n                    orcond = distribute_and_over_or(orcond)\n                newargs[-1] = ExprCondPair(expr, orcond)\n                continue\n            elif newargs[-1].cond == cond:\n                newargs[-1] = ExprCondPair(expr, cond)\n                continue\n        newargs.append(ExprCondPair(expr, cond))\n    missing = len(newargs) != len(_args)\n    same = all((a == b for a, b in zip(newargs, _args)))\n    if not newargs:\n        raise ValueError(filldedent('\\n            There are no conditions (or none that\\n            are not trivially false) to define an\\n            expression.'))\n    if missing or not same:\n        return cls(*newargs)",
    ".sympy.core.containers.py@@Tuple.__getitem__": "def __getitem__(self, i):\n    if isinstance(i, slice):\n        indices = i.indices(len(self))\n        return Tuple(*(self.args[j] for j in range(*indices)))\n    return self.args[i]",
    ".sympy.core.numbers.py@@Integer.__radd__": "def __radd__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other + self.p)\n        elif isinstance(other, Rational):\n            return Rational(other.p + self.p * other.q, other.q, 1)\n        return Rational.__radd__(self, other)\n    return Rational.__radd__(self, other)",
    ".sympy.core.basic.py@@Basic.replace": "def replace(self, query, value, map=False, simultaneous=True, exact=None):\n    try:\n        query = _sympify(query)\n    except SympifyError:\n        pass\n    try:\n        value = _sympify(value)\n    except SympifyError:\n        pass\n    if isinstance(query, type):\n        _query = lambda expr: isinstance(expr, query)\n        if isinstance(value, type):\n            _value = lambda expr, result: value(*expr.args)\n        elif callable(value):\n            _value = lambda expr, result: value(*expr.args)\n        else:\n            raise TypeError('given a type, replace() expects another type or a callable')\n    elif isinstance(query, Basic):\n        _query = lambda expr: expr.match(query)\n        if exact is None:\n            from .symbol import Wild\n            exact = len(query.atoms(Wild)) > 1\n        if isinstance(value, Basic):\n            if exact:\n                _value = lambda expr, result: value.subs(result) if all(result.values()) else expr\n            else:\n                _value = lambda expr, result: value.subs(result)\n        elif callable(value):\n            if exact:\n                _value = lambda expr, result: value(**{str(k)[:-1]: v for k, v in result.items()}) if all((val for val in result.values())) else expr\n            else:\n                _value = lambda expr, result: value(**{str(k)[:-1]: v for k, v in result.items()})\n        else:\n            raise TypeError('given an expression, replace() expects another expression or a callable')\n    elif callable(query):\n        _query = query\n        if callable(value):\n            _value = lambda expr, result: value(expr)\n        else:\n            raise TypeError('given a callable, replace() expects another callable')\n    else:\n        raise TypeError('first argument to replace() must be a type, an expression or a callable')\n\n    def walk(rv, F):\n        args = getattr(rv, 'args', None)\n        if args is not None:\n            if args:\n                newargs = tuple([walk(a, F) for a in args])\n                if args != newargs:\n                    rv = rv.func(*newargs)\n                    if simultaneous:\n                        for i, e in enumerate(args):\n                            if rv == e and e != newargs[i]:\n                                return rv\n            rv = F(rv)\n        return rv\n    mapping = {}\n\n    def rec_replace(expr):\n        result = _query(expr)\n        if result or result == {}:\n            v = _value(expr, result)\n            if v is not None and v != expr:\n                if map:\n                    mapping[expr] = v\n                expr = v\n        return expr\n    rv = walk(self, rec_replace)\n    return (rv, mapping) if map else rv",
    ".sympy.core.sympify.py@@_is_numpy_instance": "def _is_numpy_instance(a):\n    return any((type_.__module__ == 'numpy' for type_ in type(a).__mro__))",
    ".sympy.core.sympify.py@@SympifyError.__init__": "def __init__(self, expr, base_exc=None):\n    self.expr = expr\n    self.base_exc = base_exc",
    ".sympy.core.basic.py@@Basic.walk": "def walk(rv, F):\n    args = getattr(rv, 'args', None)\n    if args is not None:\n        if args:\n            newargs = tuple([walk(a, F) for a in args])\n            if args != newargs:\n                rv = rv.func(*newargs)\n                if simultaneous:\n                    for i, e in enumerate(args):\n                        if rv == e and e != newargs[i]:\n                            return rv\n        rv = F(rv)\n    return rv",
    ".sympy.core.basic.py@@Basic.rec_replace": "def rec_replace(expr):\n    result = _query(expr)\n    if result or result == {}:\n        v = _value(expr, result)\n        if v is not None and v != expr:\n            if map:\n                mapping[expr] = v\n            expr = v\n    return expr",
    ".sympy.core.numbers.py@@Integer.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    ".sympy.core.decorators.py@@__sympifyit_wrapper": "def __sympifyit_wrapper(a, b):\n    try:\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    ".sympy.core.numbers.py@@Rational.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))\n        elif isinstance(other, Float):\n            return other * self\n        else:\n            return Number.__mul__(self, other)\n    return Number.__mul__(self, other)",
    ".sympy.core.numbers.py@@Number.__mul__": "def __mul__(self, other):\n    if isinstance(other, Number) and global_parameters.evaluate:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.Infinity\n            else:\n                return S.NegativeInfinity\n        elif other is S.NegativeInfinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.NegativeInfinity\n            else:\n                return S.Infinity\n    elif isinstance(other, Tuple):\n        return NotImplemented\n    return AtomicExpr.__mul__(self, other)",
    ".sympy.geometry.point.py@@Point.__getitem__": "def __getitem__(self, key):\n    return self.args[key]",
    ".sympy.core.numbers.py@@Integer.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    ".sympy.core.numbers.py@@Integer.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.integrals.intpoly.py@@left_integral2D": "def left_integral2D(m, index, facets, x0, expr, gens):\n    value = S.Zero\n    for j in range(0, m):\n        intersect = ()\n        if j in ((index - 1) % m, (index + 1) % m):\n            intersect = intersection(facets[index], facets[j], 'segment2D')\n        if intersect:\n            distance_origin = norm(tuple(map(lambda x, y: x - y, intersect, x0)))\n            if is_vertex(intersect):\n                if isinstance(expr, Expr):\n                    if len(gens) == 3:\n                        expr_dict = {gens[0]: intersect[0], gens[1]: intersect[1], gens[2]: intersect[2]}\n                    else:\n                        expr_dict = {gens[0]: intersect[0], gens[1]: intersect[1]}\n                    value += distance_origin * expr.subs(expr_dict)\n                else:\n                    value += distance_origin * expr\n    return value",
    ".sympy.integrals.intpoly.py@@intersection": "def intersection(geom_1, geom_2, intersection_type):\n    if intersection_type[:-2] == 'segment':\n        if intersection_type == 'segment2D':\n            x1, y1 = geom_1.points[0]\n            x2, y2 = geom_1.points[1]\n            x3, y3 = geom_2.points[0]\n            x4, y4 = geom_2.points[1]\n        elif intersection_type == 'segment3D':\n            x1, y1, z1 = geom_1.points[0]\n            x2, y2, z2 = geom_1.points[1]\n            x3, y3, z3 = geom_2.points[0]\n            x4, y4, z4 = geom_2.points[1]\n        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if denom:\n            t1 = x1 * y2 - y1 * x2\n            t2 = x3 * y4 - x4 * y3\n            return (S(t1 * (x3 - x4) - t2 * (x1 - x2)) / denom, S(t1 * (y3 - y4) - t2 * (y1 - y2)) / denom)\n    if intersection_type[:-2] == 'plane':\n        if intersection_type == 'plane2D':\n            a1x, a1y = geom_1[0]\n            a2x, a2y = geom_2[0]\n            b1, b2 = (geom_1[1], geom_2[1])\n            denom = a1x * a2y - a2x * a1y\n            if denom:\n                return (S(b1 * a2y - b2 * a1y) / denom, S(b2 * a1x - b1 * a2x) / denom)",
    ".sympy.geometry.point.py@@Point.__iter__": "def __iter__(self):\n    return self.args.__iter__()",
    ".sympy.core.numbers.py@@Rational.__truediv__": "def __truediv__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            if self.p and other.p == S.Zero:\n                return S.ComplexInfinity\n            else:\n                return Rational(self.p, self.q * other.p, igcd(self.p, other.p))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q, self.q * other.p, igcd(self.p, other.p) * igcd(self.q, other.q))\n        elif isinstance(other, Float):\n            return self * (1 / other)\n        else:\n            return Number.__truediv__(self, other)\n    return Number.__truediv__(self, other)",
    ".sympy.core.numbers.py@@Rational.__new__": "def __new__(cls, p, q=None, gcd=None):\n    if q is None:\n        if isinstance(p, Rational):\n            return p\n        if isinstance(p, SYMPY_INTS):\n            pass\n        else:\n            if isinstance(p, (float, Float)):\n                return Rational(*_as_integer_ratio(p))\n            if not isinstance(p, str):\n                try:\n                    p = sympify(p)\n                except (SympifyError, SyntaxError):\n                    pass\n            else:\n                if p.count('/') > 1:\n                    raise TypeError('invalid input: %s' % p)\n                p = p.replace(' ', '')\n                pq = p.rsplit('/', 1)\n                if len(pq) == 2:\n                    p, q = pq\n                    fp = fractions.Fraction(p)\n                    fq = fractions.Fraction(q)\n                    p = fp / fq\n                try:\n                    p = fractions.Fraction(p)\n                except ValueError:\n                    pass\n                else:\n                    return Rational(p.numerator, p.denominator, 1)\n            if not isinstance(p, Rational):\n                raise TypeError('invalid input: %s' % p)\n        q = 1\n        gcd = 1\n    if not isinstance(p, SYMPY_INTS):\n        p = Rational(p)\n        q *= p.q\n        p = p.p\n    else:\n        p = int(p)\n    if not isinstance(q, SYMPY_INTS):\n        q = Rational(q)\n        p *= q.q\n        q = q.p\n    else:\n        q = int(q)\n    if q == 0:\n        if p == 0:\n            if _errdict['divide']:\n                raise ValueError('Indeterminate 0/0')\n            else:\n                return S.NaN\n        return S.ComplexInfinity\n    if q < 0:\n        q = -q\n        p = -p\n    if not gcd:\n        gcd = igcd(abs(p), q)\n    if gcd > 1:\n        p //= gcd\n        q //= gcd\n    if q == 1:\n        return Integer(p)\n    if p == 1 and q == 2:\n        return S.Half\n    obj = Expr.__new__(cls)\n    obj.p = p\n    obj.q = q\n    return obj",
    ".sympy.integrals.intpoly.py@@norm": "def norm(point):\n    half = S.Half\n    if isinstance(point, (list, tuple)):\n        return sum([coord ** 2 for coord in point]) ** half\n    elif isinstance(point, Point):\n        if isinstance(point, Point2D):\n            return (point.x ** 2 + point.y ** 2) ** half\n        else:\n            return (point.x ** 2 + point.y ** 2 + point.z) ** half\n    elif isinstance(point, dict):\n        return sum((i ** 2 for i in point.values())) ** half",
    ".sympy.core.expr.py@@Expr.__pow__": "def __pow__(self, other, mod=None):\n    if mod is None:\n        return self._pow(other)\n    try:\n        _self, other, mod = (as_int(self), as_int(other), as_int(mod))\n        if other >= 0:\n            return pow(_self, other, mod)\n        else:\n            from .numbers import mod_inverse\n            return mod_inverse(pow(_self, -other, mod), mod)\n    except ValueError:\n        power = self._pow(other)\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    ".sympy.core.expr.py@@Expr._pow": "def _pow(self, other):\n    return Pow(self, other)",
    ".sympy.core.power.py@@Pow.__new__": "def __new__(cls, b, e, evaluate=None):\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    b = _sympify(b)\n    e = _sympify(e)\n    from .relational import Relational\n    if isinstance(b, Relational) or isinstance(e, Relational):\n        raise TypeError('Relational cannot be used in Pow')\n    for arg in [b, e]:\n        if not isinstance(arg, Expr):\n            sympy_deprecation_warning(f'\\nUsing non-Expr arguments in Pow is deprecated (in this case, one of the\\narguments is of type {type(arg).__name__!r}).\\n\\nIf you really did intend to construct a power with this base, use the **\\noperator instead.', deprecated_since_version='1.7', active_deprecations_target='non-expr-args-deprecated', stacklevel=4)\n    if evaluate:\n        if e is S.ComplexInfinity:\n            return S.NaN\n        if e is S.Infinity:\n            if is_gt(b, S.One):\n                return S.Infinity\n            if is_gt(b, S.NegativeOne) and is_lt(b, S.One):\n                return S.Zero\n            if is_lt(b, S.NegativeOne):\n                if b.is_finite:\n                    return S.ComplexInfinity\n                if b.is_finite is False:\n                    return S.NaN\n        if e is S.Zero:\n            return S.One\n        elif e is S.One:\n            return b\n        elif e == -1 and (not b):\n            return S.ComplexInfinity\n        elif e.__class__.__name__ == 'AccumulationBounds':\n            if b == S.Exp1:\n                from sympy.calculus.accumulationbounds import AccumBounds\n                return AccumBounds(Pow(b, e.min), Pow(b, e.max))\n        elif (e.is_Symbol and e.is_integer or e.is_Integer) and (b.is_number and b.is_Mul or b.is_Number) and b.could_extract_minus_sign():\n            if e.is_even:\n                b = -b\n            elif e.is_odd:\n                return -Pow(-b, e)\n        if S.NaN in (b, e):\n            return S.NaN\n        elif b is S.One:\n            if abs(e).is_infinite:\n                return S.NaN\n            return S.One\n        else:\n            from sympy.functions.elementary.exponential import exp_polar\n            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):\n                from .exprtools import factor_terms\n                from sympy.functions.elementary.exponential import log\n                from sympy.simplify.radsimp import fraction\n                c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n                num, den = fraction(ex)\n                if isinstance(den, log) and den.args[0] == b:\n                    return S.Exp1 ** (c * num)\n                elif den.is_Add:\n                    from sympy.functions.elementary.complexes import sign, im\n                    s = sign(im(b))\n                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):\n                        return S.Exp1 ** (c * num)\n            obj = b._eval_power(e)\n            if obj is not None:\n                return obj\n    obj = Expr.__new__(cls, b, e)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if not isinstance(obj, Pow):\n        return obj\n    obj.is_commutative = b.is_commutative and e.is_commutative\n    return obj",
    ".sympy.core.numbers.py@@Number.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    return bool(self.is_extended_negative)",
    ".sympy.core.numbers.py@@Integer.__abs__": "def __abs__(self):\n    if self.p >= 0:\n        return self\n    else:\n        return Integer(-self.p)",
    ".sympy.core.numbers.py@@Zero._eval_power": "def _eval_power(self, expt):\n    if expt.is_extended_positive:\n        return self\n    if expt.is_extended_negative:\n        return S.ComplexInfinity\n    if expt.is_extended_real is False:\n        return S.NaN\n    coeff, terms = expt.as_coeff_Mul()\n    if coeff.is_negative:\n        return S.ComplexInfinity ** terms\n    if coeff is not S.One:\n        return self ** terms",
    ".sympy.core.assumptions.py@@StdFactKB.generator": "def generator(self):\n    return self._generator.copy()",
    ".sympy.core.expr.py@@Expr._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    return self._eval_is_extended_positive_negative(positive=True)",
    ".sympy.core.expr.py@@Expr._eval_is_extended_positive_negative": "def _eval_is_extended_positive_negative(self, positive):\n    from sympy.polys.numberfields import minimal_polynomial\n    from sympy.polys.polyerrors import NotAlgebraic\n    if self.is_number:\n        if self.is_extended_real is False:\n            return False\n        try:\n            n2 = self._eval_evalf(2)\n        except ValueError:\n            return None\n        if n2 is None:\n            return None\n        if getattr(n2, '_prec', 1) == 1:\n            return None\n        if n2 is S.NaN:\n            return None\n        f = self.evalf(2)\n        if f.is_Float:\n            match = (f, S.Zero)\n        else:\n            match = pure_complex(f)\n        if match is None:\n            return False\n        r, i = match\n        if not (i.is_Number and r.is_Number):\n            return False\n        if r._prec != 1 and i._prec != 1:\n            return bool(not i and (r > 0 if positive else r < 0))\n        elif r._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):\n            try:\n                if minimal_polynomial(self).is_Symbol:\n                    return False\n            except (NotAlgebraic, NotImplementedError):\n                pass",
    ".sympy.core.numbers.py@@Number._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Integer._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_int(self.p, prec, rnd)",
    ".sympy.core.numbers.py@@Float._new": "def _new(cls, _mpf_, _prec, zero=True):\n    if zero and _mpf_ == fzero:\n        return S.Zero\n    elif _mpf_ == _mpf_nan:\n        return S.NaN\n    elif _mpf_ == _mpf_inf:\n        return S.Infinity\n    elif _mpf_ == _mpf_ninf:\n        return S.NegativeInfinity\n    obj = Expr.__new__(cls)\n    obj._mpf_ = mpf_norm(_mpf_, _prec)\n    obj._prec = _prec\n    return obj",
    ".sympy.core.numbers.py@@mpf_norm": "def mpf_norm(mpf, prec):\n    sign, man, expt, bc = mpf\n    if not man:\n        if not bc:\n            return fzero\n        else:\n            return mpf\n    from mpmath.libmp.backend import MPZ\n    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n    return rv",
    ".sympy.core.evalf.py@@EvalfMixin.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    from .numbers import Float, Number\n    n = n if n is not None else 15\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n    if n == 1 and isinstance(self, Number):\n        from .expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        if hasattr(self, 'subs') and subs is not None:\n            v = self.subs(subs)._eval_evalf(prec)\n        else:\n            v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        elif not v.is_number:\n            return v\n        try:\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            return v\n    if result is S.ComplexInfinity:\n        return result\n    re, im, re_acc, im_acc = result\n    if re is S.NaN or im is S.NaN:\n        return S.NaN\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im * S.ImaginaryUnit\n    else:\n        return re",
    ".sympy.core.evalf.py@@evalf": "def evalf(x: 'Expr', prec: int, options: OPT_DICT) -> TMP_RES:\n    from sympy.functions.elementary.complexes import re as re_, im as im_\n    try:\n        rf = evalf_table[type(x)]\n        r = rf(x, prec, options)\n    except KeyError:\n        if 'subs' in options:\n            x = x.subs(evalf_subs(prec, options['subs']))\n        xe = x._eval_evalf(prec)\n        if xe is None:\n            raise NotImplementedError\n        as_real_imag = getattr(xe, 'as_real_imag', None)\n        if as_real_imag is None:\n            raise NotImplementedError\n        re, im = as_real_imag()\n        if re.has(re_) or im.has(im_):\n            raise NotImplementedError\n        if re == 0:\n            re = None\n            reprec = None\n        elif re.is_number:\n            re = re._to_mpmath(prec, allow_ints=False)._mpf_\n            reprec = prec\n        else:\n            raise NotImplementedError\n        if im == 0:\n            im = None\n            imprec = None\n        elif im.is_number:\n            im = im._to_mpmath(prec, allow_ints=False)._mpf_\n            imprec = prec\n        else:\n            raise NotImplementedError\n        r = (re, im, reprec, imprec)\n    if options.get('verbose'):\n        print('### input', x)\n        print('### output', to_str(r[0] or fzero, 50) if isinstance(r, tuple) else r)\n        print('### raw', r)\n        print()\n    chop = options.get('chop', False)\n    if chop:\n        if chop is True:\n            chop_prec = prec\n        else:\n            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))\n            if chop_prec == 3:\n                chop_prec -= 1\n        r = chop_parts(r, chop_prec)\n    if options.get('strict'):\n        check_target(x, r, prec)\n    return r",
    ".sympy.core.evalf.py@@evalf_integer": "def evalf_integer(expr: 'Integer', prec: int, options: OPT_DICT) -> TMP_RES:\n    return (from_int(expr.p, prec), None, prec, None)",
    ".sympy.core.numbers.py@@Float.__gt__": "def __gt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__lt__(self)\n    rv = self._Frel(other, mlib.mpf_gt)\n    if rv is None:\n        return Expr.__gt__(self, other)\n    return rv",
    ".sympy.core.numbers.py@@Float._Frel": "def _Frel(self, other, op):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Rational:\n        '\\n        >>> f = Float(.1,2)\\n        >>> i = 1234567890\\n        >>> (f*i)._mpf_\\n        (0, 471, 18, 9)\\n        >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))\\n        (0, 505555550955, -12, 39)\\n        '\n        smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))\n        ompf = mlib.from_int(other.p)\n        return _sympify(bool(op(smpf, ompf)))\n    elif other.is_Float:\n        return _sympify(bool(op(self._mpf_, other._mpf_)))\n    elif other.is_comparable and other not in (S.Infinity, S.NegativeInfinity):\n        other = other.evalf(prec_to_dps(self._prec))\n        if other._prec > 1:\n            if other.is_Number:\n                return _sympify(bool(op(self._mpf_, other._as_mpf_val(self._prec))))",
    ".sympy.logic.boolalg.py@@BooleanTrue.__bool__": "def __bool__(self):\n    return True",
    ".sympy.core.numbers.py@@Half.__abs__": "def __abs__():\n    return S.Half",
    ".sympy.integrals.intpoly.py@@is_vertex": "def is_vertex(ent):\n    if isinstance(ent, tuple):\n        if len(ent) in [2, 3]:\n            return True\n    elif isinstance(ent, Point):\n        return True\n    return False",
    ".sympy.core.basic.py@@Basic.subs": "def subs(self, *args, **kwargs):\n    from .containers import Dict\n    from .symbol import Dummy, Symbol\n    from .numbers import _illegal\n    unordered = False\n    if len(args) == 1:\n        sequence = args[0]\n        if isinstance(sequence, set):\n            unordered = True\n        elif isinstance(sequence, (Dict, Mapping)):\n            unordered = True\n            sequence = sequence.items()\n        elif not iterable(sequence):\n            raise ValueError(filldedent('\\n               When a single argument is passed to subs\\n               it should be a dictionary of old: new pairs or an iterable\\n               of (old, new) tuples.'))\n    elif len(args) == 2:\n        sequence = [args]\n    else:\n        raise ValueError('subs accepts either 1 or 2 arguments')\n    sequence = list(sequence)\n    for i, s in enumerate(sequence):\n        if isinstance(s[0], str):\n            s = (Symbol(s[0]), s[1])\n        try:\n            s = [sympify(_, strict=not isinstance(_, (str, type))) for _ in s]\n        except SympifyError:\n            sequence[i] = None\n            continue\n        sequence[i] = None if _aresame(*s) else tuple(s)\n    sequence = list(filter(None, sequence))\n    simultaneous = kwargs.pop('simultaneous', False)\n    if unordered:\n        from .sorting import _nodes, default_sort_key\n        sequence = dict(sequence)\n        k = list(ordered(sequence, default=False, keys=(lambda x: -_nodes(x), default_sort_key)))\n        sequence = [(k, sequence[k]) for k in k]\n        if not simultaneous:\n            redo = []\n            for i in range(len(sequence)):\n                if sequence[i][1] in _illegal:\n                    redo.append(i)\n            for i in reversed(redo):\n                sequence.insert(0, sequence.pop(i))\n    if simultaneous:\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy('subs_m')\n        for old, new in sequence:\n            com = new.is_commutative\n            if com is None:\n                com = True\n            d = Dummy('subs_d', commutative=com)\n            rv = rv._subs(old, d * m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    ".sympy.core.basic.py@@_aresame": "def _aresame(a, b):\n    from .numbers import Number\n    from .function import AppliedUndef, UndefinedFunction as UndefFunc\n    if isinstance(a, Number) and isinstance(b, Number):\n        return a == b and a.__class__ == b.__class__\n    for i, j in zip_longest(_preorder_traversal(a), _preorder_traversal(b)):\n        if i != j or type(i) != type(j):\n            if isinstance(i, UndefFunc) and isinstance(j, UndefFunc) or (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef)):\n                if i.class_key() != j.class_key():\n                    return False\n            else:\n                return False\n    return True",
    ".sympy.core.traversal.py@@preorder_traversal.__init__": "def __init__(self, node, keys=None):\n    self._skip_flag = False\n    self._pt = self._preorder_traversal(node, keys)",
    ".sympy.core.traversal.py@@preorder_traversal.__iter__": "def __iter__(self):\n    return self",
    ".sympy.core.traversal.py@@preorder_traversal.__next__": "def __next__(self):\n    return next(self._pt)",
    ".sympy.core.traversal.py@@preorder_traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.sorting.py@@ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    d = defaultdict(list)\n    if keys:\n        if not isinstance(keys, (list, tuple)):\n            keys = [keys]\n        keys = list(keys)\n        f = keys.pop(0)\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n    for k in sorted(d.keys()):\n        if len(d[k]) > 1:\n            if keys:\n                d[k] = ordered(d[k], keys, default, warn)\n            elif default:\n                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)\n            elif warn:\n                u = list(uniq(d[k]))\n                if len(u) > 1:\n                    raise ValueError('not enough keys to break ties: %s' % u)\n        yield from d[k]\n        d.pop(k)",
    ".sympy.core.sorting.py@@_nodes": "def _nodes(e):\n    from .basic import Basic\n    from .function import Derivative\n    if isinstance(e, Basic):\n        if isinstance(e, Derivative):\n            return _nodes(e.expr) + sum((i[1] if i[1].is_Number else _nodes(i[1]) for i in e.variable_count))\n        return _node_count(e)\n    elif iterable(e):\n        return 1 + sum((_nodes(ei) for ei in e))\n    elif isinstance(e, dict):\n        return 1 + sum((_nodes(k) + _nodes(v) for k, v in e.items()))\n    else:\n        return 1",
    ".sympy.core.sorting.py@@_node_count": "def _node_count(e):\n    if e.is_Float:\n        return 0.5\n    return 1 + sum(map(_node_count, e.args))",
    ".sympy.core.sorting.py@@default_sort_key": "def default_sort_key(item, order=None):\n    from .basic import Basic\n    from .singleton import S\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n    if iterable(item, exclude=str):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            args = list(item)\n            unordered = False\n        args = [default_sort_key(arg, order=order) for arg in args]\n        if unordered:\n            args = sorted(args)\n        cls_index, args = (10, (len(args), tuple(args)))\n    else:\n        if not isinstance(item, str):\n            try:\n                item = sympify(item, strict=True)\n            except SympifyError:\n                pass\n            else:\n                if isinstance(item, Basic):\n                    return default_sort_key(item)\n        cls_index, args = (0, (1, (str(item),)))\n    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)",
    ".sympy.core.symbol.py@@Symbol.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (1, (self.name,)), S.One.sort_key(), S.One)",
    ".sympy.core.basic.py@@Atom.class_key": "def class_key(cls):\n    return (2, 0, cls.__name__)",
    ".sympy.core.numbers.py@@Number.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (0, ()), (), self)",
    ".sympy.core.numbers.py@@Number.class_key": "def class_key(cls):\n    return (1, 0, 'Number')",
    ".sympy.core.numbers.py@@NaN.__eq__": "def __eq__(self, other):\n    return other is S.NaN",
    ".sympy.core.basic.py@@Basic._subs": "def _subs(self, old, new, **hints):\n\n    def fallback(self, old, new):\n        hit = False\n        args = list(self.args)\n        for i, arg in enumerate(args):\n            if not hasattr(arg, '_eval_subs'):\n                continue\n            arg = arg._subs(old, new, **hints)\n            if not _aresame(arg, args[i]):\n                hit = True\n                args[i] = arg\n        if hit:\n            rv = self.func(*args)\n            hack2 = hints.get('hack2', False)\n            if hack2 and self.is_Mul and (not rv.is_Mul):\n                coeff = S.One\n                nonnumber = []\n                for i in args:\n                    if i.is_Number:\n                        coeff *= i\n                    else:\n                        nonnumber.append(i)\n                nonnumber = self.func(*nonnumber)\n                if coeff is S.One:\n                    return nonnumber\n                else:\n                    return self.func(coeff, nonnumber, evaluate=False)\n            return rv\n        return self\n    if _aresame(self, old):\n        return new\n    rv = self._eval_subs(old, new)\n    if rv is None:\n        rv = fallback(self, old, new)\n    return rv",
    ".sympy.core.mul.py@@Mul._eval_subs": "def _eval_subs(self, old, new):\n    from sympy.functions.elementary.complexes import sign\n    from sympy.ntheory.factor_ import multiplicity\n    from sympy.simplify.powsimp import powdenest\n    from sympy.simplify.radsimp import fraction\n    if not old.is_Mul:\n        return None\n    if old.args[0].is_Number and old.args[0] < 0:\n        if self.args[0].is_Number:\n            if self.args[0] < 0:\n                return self._subs(-old, -new)\n            return None\n\n    def base_exp(a):\n        from sympy.functions.elementary.exponential import exp\n        if a.is_Pow or isinstance(a, exp):\n            return a.as_base_exp()\n        return (a, S.One)\n\n    def breakup(eq):\n        c, nc = (defaultdict(int), list())\n        for a in Mul.make_args(eq):\n            a = powdenest(a)\n            b, e = base_exp(a)\n            if e is not S.One:\n                co, _ = e.as_coeff_mul()\n                b = Pow(b, e / co)\n                e = co\n            if a.is_commutative:\n                c[b] += e\n            else:\n                nc.append([b, e])\n        return (c, nc)\n\n    def rejoin(b, co):\n        b, e = base_exp(b)\n        return Pow(b, e * co)\n\n    def ndiv(a, b):\n        if not b.q % a.q or not a.q % b.q:\n            return int(a / b)\n        return 0\n    rv = None\n    n, d = fraction(self)\n    self2 = self\n    if d is not S.One:\n        self2 = n._subs(old, new) / d._subs(old, new)\n        if not self2.is_Mul:\n            return self2._subs(old, new)\n        if self2 != self:\n            rv = self2\n    co_self = self2.args[0]\n    co_old = old.args[0]\n    co_xmul = None\n    if co_old.is_Rational and co_self.is_Rational:\n        if co_old != co_self:\n            co_xmul = co_self.extract_multiplicatively(co_old)\n    elif co_old.is_Rational:\n        return rv\n    c, nc = breakup(self2)\n    old_c, old_nc = breakup(old)\n    if co_xmul and co_xmul.is_Rational and (abs(co_old) != 1):\n        mult = S(multiplicity(abs(co_old), co_self))\n        c.pop(co_self)\n        if co_old in c:\n            c[co_old] += mult\n        else:\n            c[co_old] = mult\n        co_residual = co_self / co_old ** mult\n    else:\n        co_residual = 1\n    ok = True\n    if len(old_nc) > len(nc):\n        ok = False\n    elif len(old_c) > len(c):\n        ok = False\n    elif {i[0] for i in old_nc}.difference({i[0] for i in nc}):\n        ok = False\n    elif set(old_c).difference(set(c)):\n        ok = False\n    elif any((sign(c[b]) != sign(old_c[b]) for b in old_c)):\n        ok = False\n    if not ok:\n        return rv\n    if not old_c:\n        cdid = None\n    else:\n        rat = []\n        for b, old_e in old_c.items():\n            c_e = c[b]\n            rat.append(ndiv(c_e, old_e))\n            if not rat[-1]:\n                return rv\n        cdid = min(rat)\n    if not old_nc:\n        ncdid = None\n        for i in range(len(nc)):\n            nc[i] = rejoin(*nc[i])\n    else:\n        ncdid = 0\n        take = len(old_nc)\n        limit = cdid or S.Infinity\n        failed = []\n        i = 0\n        while limit and i + take <= len(nc):\n            hit = False\n            rat = []\n            for j in range(take):\n                if nc[i + j][0] != old_nc[j][0]:\n                    break\n                elif j == 0:\n                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n                elif j == take - 1:\n                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n                elif nc[i + j][1] != old_nc[j][1]:\n                    break\n                else:\n                    rat.append(1)\n                j += 1\n            else:\n                ndo = min(rat)\n                if ndo:\n                    if take == 1:\n                        if cdid:\n                            ndo = min(cdid, ndo)\n                        nc[i] = Pow(new, ndo) * rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])\n                    else:\n                        ndo = 1\n                        l = rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])\n                        mid = new\n                        ir = i + take - 1\n                        r = (nc[ir][0], nc[ir][1] - ndo * old_nc[-1][1])\n                        if r[1]:\n                            if i + take < len(nc):\n                                nc[i:i + take] = [l * mid, r]\n                            else:\n                                r = rejoin(*r)\n                                nc[i:i + take] = [l * mid * r]\n                        else:\n                            nc[i:i + take] = [l * mid]\n                    limit -= ndo\n                    ncdid += ndo\n                    hit = True\n            if not hit:\n                failed.append(i)\n            i += 1\n        else:\n            if not ncdid:\n                return rv\n            failed.extend(range(i, len(nc)))\n            for i in failed:\n                nc[i] = rejoin(*nc[i]).subs(old, new)\n    if cdid is None:\n        do = ncdid\n    elif ncdid is None:\n        do = cdid\n    else:\n        do = min(ncdid, cdid)\n    margs = []\n    for b in c:\n        if b in old_c:\n            e = c[b] - old_c[b] * do\n            margs.append(rejoin(b, e))\n        else:\n            margs.append(rejoin(b.subs(old, new), c[b]))\n    if cdid and (not ncdid):\n        margs = [Pow(new, cdid)] + margs\n    return co_residual * self2.func(*margs) * self2.func(*nc)",
    ".sympy.core.basic.py@@Basic.fallback": "def fallback(self, old, new):\n    hit = False\n    args = list(self.args)\n    for i, arg in enumerate(args):\n        if not hasattr(arg, '_eval_subs'):\n            continue\n        arg = arg._subs(old, new, **hints)\n        if not _aresame(arg, args[i]):\n            hit = True\n            args[i] = arg\n    if hit:\n        rv = self.func(*args)\n        hack2 = hints.get('hack2', False)\n        if hack2 and self.is_Mul and (not rv.is_Mul):\n            coeff = S.One\n            nonnumber = []\n            for i in args:\n                if i.is_Number:\n                    coeff *= i\n                else:\n                    nonnumber.append(i)\n            nonnumber = self.func(*nonnumber)\n            if coeff is S.One:\n                return nonnumber\n            else:\n                return self.func(coeff, nonnumber, evaluate=False)\n        return rv\n    return self",
    ".sympy.core.symbol.py@@Symbol._eval_subs": "def _eval_subs(self, old, new):\n    if old.is_Pow:\n        from sympy.core.power import Pow\n        return Pow(self, S.One, evaluate=False)._eval_subs(old, new)",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.core.numbers.py@@igcd": "def igcd(*args):\n    if len(args) < 2:\n        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))\n    args_temp = [abs(as_int(i)) for i in args]\n    if 1 in args_temp:\n        return 1\n    a = args_temp.pop()\n    if HAS_GMPY:\n        for b in args_temp:\n            a = gmpy.gcd(a, b) if b else a\n        return as_int(a)\n    for b in args_temp:\n        a = math.gcd(a, b)\n    return a",
    ".sympy.core.numbers.py@@Rational._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_rational(self.p, self.q, prec, rnd)",
    ".sympy.core.numbers.py@@Number._eval_subs": "def _eval_subs(self, old, new):\n    if old == -self:\n        return -new\n    return self",
    ".sympy.core.numbers.py@@Zero.__neg__": "def __neg__():\n    return S.Zero",
    ".sympy.core.expr.py@@Expr.__add__": "def __add__(self, other):\n    return Add(self, other)",
    ".sympy.core.basic.py@@Basic._do_eq_sympify": "def _do_eq_sympify(self, other):\n    for superclass in type(other).__mro__:\n        conv = _external_converter.get(superclass)\n        if conv is not None:\n            return self == conv(other)\n    if hasattr(other, '_sympy_'):\n        return self == other._sympy_()\n    return NotImplemented",
    ".sympy.core.numbers.py@@Rational.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(self.p + self.q * other.p, self.q, 1)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + self.q * other.p, self.q * other.q)\n        elif isinstance(other, Float):\n            return other + self\n        else:\n            return Number.__add__(self, other)\n    return Number.__add__(self, other)",
    ".sympy.core.numbers.py@@Integer._eval_is_odd": "def _eval_is_odd(self):\n    return bool(self.p % 2)",
    ".sympy.core.numbers.py@@NegativeOne.__neg__": "def __neg__():\n    return S.One",
    ".sympy.core.add.py@@Add.flatten": "def flatten(cls, seq):\n    from sympy.calculus.accumulationbounds import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    from sympy.tensor.tensor import TensExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        if a.is_Rational:\n            if b.is_Mul:\n                rv = ([a, b], [], None)\n        if rv:\n            if all((s.is_commutative for s in rv[0])):\n                return rv\n            return ([], rv[0], None)\n    terms = {}\n    coeff = S.Zero\n    order_factors = []\n    extra = []\n    for o in seq:\n        if o.is_Order:\n            if o.expr.is_zero:\n                continue\n            for o1 in order_factors:\n                if o1.contains(o):\n                    o = None\n                    break\n            if o is None:\n                continue\n            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]\n            continue\n        elif o.is_Number:\n            if (o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False)) and (not extra):\n                return ([S.NaN], [], None)\n            if coeff.is_Number or isinstance(coeff, AccumBounds):\n                coeff += o\n                if coeff is S.NaN and (not extra):\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__add__(coeff)\n            continue\n        elif isinstance(o, MatrixExpr):\n            extra.append(o)\n            continue\n        elif isinstance(o, TensExpr):\n            coeff = o.__add__(coeff) if coeff else o\n            continue\n        elif o is S.ComplexInfinity:\n            if coeff.is_finite is False and (not extra):\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o.is_Add:\n            seq.extend(o.args)\n            continue\n        elif o.is_Mul:\n            c, s = o.as_coeff_Mul()\n        elif o.is_Pow:\n            b, e = o.as_base_exp()\n            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):\n                seq.append(b ** e)\n                continue\n            c, s = (S.One, o)\n        else:\n            c = S.One\n            s = o\n        if s in terms:\n            terms[s] += c\n            if terms[s] is S.NaN and (not extra):\n                return ([S.NaN], [], None)\n        else:\n            terms[s] = c\n    newseq = []\n    noncommutative = False\n    for s, c in terms.items():\n        if c.is_zero:\n            continue\n        elif c is S.One:\n            newseq.append(s)\n        elif s.is_Mul:\n            cs = s._new_rawargs(*(c,) + s.args)\n            newseq.append(cs)\n        elif s.is_Add:\n            newseq.append(Mul(c, s, evaluate=False))\n        else:\n            newseq.append(Mul(c, s))\n        noncommutative = noncommutative or not s.is_commutative\n    if coeff is S.Infinity:\n        newseq = [f for f in newseq if not (f.is_extended_nonnegative or f.is_real)]\n    elif coeff is S.NegativeInfinity:\n        newseq = [f for f in newseq if not (f.is_extended_nonpositive or f.is_real)]\n    if coeff is S.ComplexInfinity:\n        newseq = [c for c in newseq if not (c.is_finite and c.is_extended_real is not None)]\n    if order_factors:\n        newseq2 = []\n        for t in newseq:\n            for o in order_factors:\n                if o.contains(t):\n                    t = None\n                    break\n            if t is not None:\n                newseq2.append(t)\n        newseq = newseq2 + order_factors\n        for o in order_factors:\n            if o.contains(coeff):\n                coeff = S.Zero\n                break\n    _addsort(newseq)\n    if coeff is not S.Zero:\n        newseq.insert(0, coeff)\n    if extra:\n        newseq += extra\n        noncommutative = True\n    if noncommutative:\n        return ([], newseq, None)\n    else:\n        return (newseq, [], None)",
    ".sympy.core.add.py@@_addsort": "def _addsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.add.py@@Add._eval_is_zero": "def _eval_is_zero(self):\n    if self.is_commutative is False:\n        return\n    nz = []\n    z = 0\n    im_or_z = False\n    im = 0\n    for a in self.args:\n        if a.is_extended_real:\n            if a.is_zero:\n                z += 1\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im += 1\n        elif (S.ImaginaryUnit * a).is_extended_real:\n            im_or_z = True\n        else:\n            return\n    if z == len(self.args):\n        return True\n    if len(nz) in [0, len(self.args)]:\n        return None\n    b = self.func(*nz)\n    if b.is_zero:\n        if not im_or_z:\n            if im == 0:\n                return True\n            elif im == 1:\n                return False\n    if b.is_zero is False:\n        return False",
    ".sympy.core.numbers.py@@Rational.as_numer_denom": "def as_numer_denom(self):\n    return (Integer(self.p), Integer(self.q))",
    ".sympy.core.numbers.py@@Integer.__divmod__": "def __divmod__(self, other):\n    if isinstance(other, Integer) and global_parameters.evaluate:\n        return Tuple(*divmod(self.p, other.p))\n    else:\n        return Number.__divmod__(self, other)",
    ".sympy.core.numbers.py@@Integer.__mod__": "def __mod__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p % other)\n        elif isinstance(other, Integer):\n            return Integer(self.p % other.p)\n        return Rational.__mod__(self, other)\n    return Rational.__mod__(self, other)",
    ".sympy.core.add.py@@Add._eval_is_infinite": "def _eval_is_infinite(self):\n    sawinf = False\n    for a in self.args:\n        ainf = a.is_infinite\n        if ainf is None:\n            return None\n        elif ainf is True:\n            if sawinf is True:\n                return None\n            sawinf = True\n    return sawinf",
    ".sympy.core.add.py@@Add._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all((x.is_rational is True for x in others)):\n                return True\n            return None\n        if a is None:\n            return\n    return False",
    ".sympy.core.add.py@@Add._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    if self.is_number:\n        return super()._eval_is_extended_positive()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        from .exprtools import _monotonic_sign\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s != self and s.is_extended_positive and a.is_extended_nonnegative:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v != self and v.is_extended_positive:\n                    return True\n    pos = nonneg = nonpos = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        ispos = a.is_extended_positive\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((ispos, a.is_extended_nonnegative)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if ispos:\n            pos = True\n            continue\n        elif a.is_extended_nonnegative:\n            nonneg = True\n            continue\n        elif a.is_extended_nonpositive:\n            nonpos = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonpos and (not nonneg) and pos:\n        return True\n    elif not nonpos and pos:\n        return True\n    elif not pos and (not nonneg):\n        return False",
    ".sympy.core.expr.py@@Expr.is_number": "def is_number(self):\n    return all((obj.is_number for obj in self.args))",
    ".sympy.core.add.py@@Add.as_coeff_Add": "def as_coeff_Add(self, rational=False, deps=None):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number and (not rational) or coeff.is_Rational:\n        return (coeff, self._new_rawargs(*args))\n    return (S.Zero, self)",
    ".sympy.core.add.py@@Add._eval_is_imaginary": "def _eval_is_imaginary(self):\n    nz = []\n    im_I = []\n    for a in self.args:\n        if a.is_extended_real:\n            if a.is_zero:\n                pass\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im_I.append(a * S.ImaginaryUnit)\n        elif (S.ImaginaryUnit * a).is_extended_real:\n            im_I.append(a * S.ImaginaryUnit)\n        else:\n            return\n    b = self.func(*nz)\n    if b.is_zero:\n        return fuzzy_not(self.func(*im_I).is_zero)\n    elif b.is_zero is False:\n        return False",
    ".sympy.core.add.py@@Add._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    if self.is_number:\n        return super()._eval_is_extended_negative()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        from .exprtools import _monotonic_sign\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s != self and s.is_extended_negative and a.is_extended_nonpositive:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v != self and v.is_extended_negative:\n                    return True\n    neg = nonpos = nonneg = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        isneg = a.is_extended_negative\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((isneg, a.is_extended_nonpositive)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if isneg:\n            neg = True\n            continue\n        elif a.is_extended_nonpositive:\n            nonpos = True\n            continue\n        elif a.is_extended_nonnegative:\n            nonneg = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonneg and (not nonpos) and neg:\n        return True\n    elif not nonneg and neg:\n        return True\n    elif not neg and (not nonpos):\n        return False",
    ".sympy.core.add.py@@Add._eval_is_odd": "def _eval_is_odd(self):\n    l = [f for f in self.args if not f.is_even is True]\n    if not l:\n        return False\n    if l[0].is_odd:\n        return self._new_rawargs(*l[1:]).is_even",
    ".sympy.core.add.py@@Add._eval_is_extended_nonpositive": "def _eval_is_extended_nonpositive(self):\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_extended_nonpositive:\n            from .exprtools import _monotonic_sign\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s != self and s.is_extended_nonpositive:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v != self and v.is_extended_nonpositive:\n                        return True",
    ".sympy.core.add.py@@Add._eval_is_extended_nonnegative": "def _eval_is_extended_nonnegative(self):\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_extended_nonnegative:\n            from .exprtools import _monotonic_sign\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s != self and s.is_extended_nonnegative:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v != self and v.is_extended_nonnegative:\n                        return True",
    ".sympy.core.basic.py@@Basic._eval_derivative_n_times": "def _eval_derivative_n_times(self, s, n):\n    from .numbers import Integer\n    if isinstance(n, (int, Integer)):\n        obj = self\n        for i in range(n):\n            obj2 = obj._eval_derivative(s)\n            if obj == obj2 or obj2 is None:\n                break\n            obj = obj2\n        return obj2\n    else:\n        return None",
    ".sympy.core.add.py@@Add._eval_derivative": "def _eval_derivative(self, s):\n    return self.func(*[a.diff(s) for a in self.args])",
    ".sympy.core.numbers.py@@Rational._eval_is_zero": "def _eval_is_zero(self):\n    return self.p == 0",
    ".sympy.core.numbers.py@@Integer._eval_power": "def _eval_power(self, expt):\n    from sympy.ntheory.factor_ import perfect_power\n    if expt is S.Infinity:\n        if self.p > S.One:\n            return S.Infinity\n        return S.Infinity + S.ImaginaryUnit * S.Infinity\n    if expt is S.NegativeInfinity:\n        return Rational(1, self, 1) ** S.Infinity\n    if not isinstance(expt, Number):\n        if self.is_negative and expt.is_even:\n            return (-self) ** expt\n    if isinstance(expt, Float):\n        return super()._eval_power(expt)\n    if not isinstance(expt, Rational):\n        return\n    if expt is S.Half and self.is_negative:\n        return S.ImaginaryUnit * Pow(-self, expt)\n    if expt.is_negative:\n        ne = -expt\n        if self.is_negative:\n            return S.NegativeOne ** expt * Rational(1, -self, 1) ** ne\n        else:\n            return Rational(1, self.p, 1) ** ne\n    x, xexact = integer_nthroot(abs(self.p), expt.q)\n    if xexact:\n        result = Integer(x ** abs(expt.p))\n        if self.is_negative:\n            result *= S.NegativeOne ** expt\n        return result\n    b_pos = int(abs(self.p))\n    p = perfect_power(b_pos)\n    if p is not False:\n        dict = {p[0]: p[1]}\n    else:\n        dict = Integer(b_pos).factors(limit=2 ** 15)\n    out_int = 1\n    out_rad = 1\n    sqr_int = 1\n    sqr_gcd = 0\n    sqr_dict = {}\n    for prime, exponent in dict.items():\n        exponent *= expt.p\n        div_e, div_m = divmod(exponent, expt.q)\n        if div_e > 0:\n            out_int *= prime ** div_e\n        if div_m > 0:\n            g = igcd(div_m, expt.q)\n            if g != 1:\n                out_rad *= Pow(prime, Rational(div_m // g, expt.q // g, 1))\n            else:\n                sqr_dict[prime] = div_m\n    for p, ex in sqr_dict.items():\n        if sqr_gcd == 0:\n            sqr_gcd = ex\n        else:\n            sqr_gcd = igcd(sqr_gcd, ex)\n            if sqr_gcd == 1:\n                break\n    for k, v in sqr_dict.items():\n        sqr_int *= k ** (v // sqr_gcd)\n    if sqr_int == b_pos and out_int == 1 and (out_rad == 1):\n        result = None\n    else:\n        result = out_int * out_rad * Pow(sqr_int, Rational(sqr_gcd, expt.q))\n        if self.is_negative:\n            result *= Pow(S.NegativeOne, expt)\n    return result",
    ".sympy.core.expr.py@@Expr._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    return self._eval_is_extended_positive_negative(positive=False)",
    ".sympy.core.numbers.py@@Float.__lt__": "def __lt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__gt__(self)\n    rv = self._Frel(other, mlib.mpf_lt)\n    if rv is None:\n        return Expr.__lt__(self, other)\n    return rv",
    ".sympy.logic.boolalg.py@@BooleanFalse.__bool__": "def __bool__(self):\n    return False",
    ".sympy.core.power.py@@integer_nthroot": "def integer_nthroot(y, n):\n    y, n = (as_int(y), as_int(n))\n    if y < 0:\n        raise ValueError('y must be nonnegative')\n    if n < 1:\n        raise ValueError('n must be positive')\n    if HAS_GMPY and n < 2 ** 63:\n        if HAS_GMPY >= 2:\n            x, t = gmpy.iroot(y, n)\n        else:\n            x, t = gmpy.root(y, n)\n        return (as_int(x), bool(t))\n    return _integer_nthroot_python(y, n)",
    ".sympy.core.power.py@@_integer_nthroot_python": "def _integer_nthroot_python(y, n):\n    if y in (0, 1):\n        return (y, True)\n    if n == 1:\n        return (y, True)\n    if n == 2:\n        x, rem = mpmath_sqrtrem(y)\n        return (int(x), not rem)\n    if n > y:\n        return (1, False)\n    try:\n        guess = int(y ** (1.0 / n) + 0.5)\n    except OverflowError:\n        exp = _log(y, 2) / n\n        if exp > 53:\n            shift = int(exp - 53)\n            guess = int(2.0 ** (exp - shift) + 1) << shift\n        else:\n            guess = int(2.0 ** exp)\n    if guess > 2 ** 50:\n        xprev, x = (-1, guess)\n        while 1:\n            t = x ** (n - 1)\n            xprev, x = (x, ((n - 1) * x + y // t) // n)\n            if abs(x - xprev) < 2:\n                break\n    else:\n        x = guess\n    t = x ** n\n    while t < y:\n        x += 1\n        t = x ** n\n    while t > y:\n        x -= 1\n        t = x ** n\n    return (int(x), t == y)",
    ".sympy.ntheory.factor_.py@@perfect_power": "def perfect_power(n, candidates=None, big=True, factor=True):\n    if isinstance(n, Rational) and (not n.is_Integer):\n        p, q = n.as_numer_denom()\n        if p is S.One:\n            pp = perfect_power(q)\n            if pp:\n                pp = (n.func(1, pp[0]), pp[1])\n        else:\n            pp = perfect_power(p)\n            if pp:\n                num, e = pp\n                pq = perfect_power(q, [e])\n                if pq:\n                    den, _ = pq\n                    pp = (n.func(num, den), e)\n        return pp\n    n = as_int(n)\n    if n < 0:\n        pp = perfect_power(-n)\n        if pp:\n            b, e = pp\n            if e % 2:\n                return (-b, e)\n        return False\n    if n <= 3:\n        return False\n    logn = math.log(n, 2)\n    max_possible = int(logn) + 2\n    not_square = n % 10 in [2, 3, 7, 8]\n    min_possible = 2 + not_square\n    if not candidates:\n        candidates = primerange(min_possible, max_possible)\n    else:\n        candidates = sorted([i for i in candidates if min_possible <= i < max_possible])\n        if n % 2 == 0:\n            e = trailing(n)\n            candidates = [i for i in candidates if e % i == 0]\n        if big:\n            candidates = reversed(candidates)\n        for e in candidates:\n            r, ok = integer_nthroot(n, e)\n            if ok:\n                return (r, e)\n        return False\n\n    def _factors():\n        rv = 2 + n % 2\n        while True:\n            yield rv\n            rv = nextprime(rv)\n    for fac, e in zip(_factors(), candidates):\n        if factor and n % fac == 0:\n            if fac == 2:\n                e = trailing(n)\n            else:\n                e = multiplicity(fac, n)\n            if e == 1:\n                return False\n            r, exact = integer_nthroot(n, e)\n            if not exact:\n                m = n // fac ** e\n                rE = perfect_power(m, candidates=divisors(e, generator=True))\n                if not rE:\n                    return False\n                else:\n                    r, E = rE\n                    r, e = (fac ** (e // E) * r, E)\n            if not big:\n                e0 = primefactors(e)\n                if e0[0] != e:\n                    r, e = (r ** (e // e0[0]), e0[0])\n            return (r, e)\n        if logn / e < 40:\n            b = 2.0 ** (logn / e)\n            if abs(int(b + 0.5) - b) > 0.01:\n                continue\n        r, exact = integer_nthroot(n, e)\n        if exact:\n            if big:\n                m = perfect_power(r, big=big, factor=factor)\n                if m:\n                    r, e = (m[0], e * m[1])\n            return (int(r), e)\n    return False",
    ".sympy.core.numbers.py@@Rational.factors": "def factors(self, limit=None, use_trial=True, use_rho=False, use_pm1=False, verbose=False, visual=False):\n    from sympy.ntheory.factor_ import factorrat\n    return factorrat(self, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()",
    ".sympy.ntheory.factor_.py@@factorrat": "def factorrat(rat, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False):\n    if multiple:\n        fac = factorrat(rat, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)\n        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S.One / p] * -fac[p] for p, _ in sorted(fac.items(), key=lambda elem: elem[0] if elem[1] > 0 else 1 / elem[0])), [])\n        return factorlist\n    f = factorint(rat.p, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()\n    f = defaultdict(int, f)\n    for p, e in factorint(rat.q, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).items():\n        f[p] += -e\n    if len(f) > 1 and 1 in f:\n        del f[1]\n    if not visual:\n        return dict(f)\n    else:\n        if -1 in f:\n            f.pop(-1)\n            args = [S.NegativeOne]\n        else:\n            args = []\n        args.extend([Pow(*i, evaluate=False) for i in sorted(f.items())])\n        return Mul(*args, evaluate=False)",
    ".sympy.ntheory.factor_.py@@factorint": "def factorint(n, limit=None, use_trial=True, use_rho=True, use_pm1=True, use_ecm=True, verbose=False, visual=None, multiple=False):\n    if isinstance(n, Dict):\n        n = dict(n)\n    if multiple:\n        fac = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)\n        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S.One / p] * -fac[p] for p in sorted(fac)), [])\n        return factorlist\n    factordict = {}\n    if visual and (not isinstance(n, (Mul, dict))):\n        factordict = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n    elif isinstance(n, Mul):\n        factordict = {int(k): int(v) for k, v in n.as_powers_dict().items()}\n    elif isinstance(n, dict):\n        factordict = n\n    if factordict and isinstance(n, (Mul, dict)):\n        for key in list(factordict.keys()):\n            if isprime(key):\n                continue\n            e = factordict.pop(key)\n            d = factorint(key, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n            for k, v in d.items():\n                if k in factordict:\n                    factordict[k] += v * e\n                else:\n                    factordict[k] = v * e\n    if visual or (type(n) is dict and visual is not True and (visual is not False)):\n        if factordict == {}:\n            return S.One\n        if -1 in factordict:\n            factordict.pop(-1)\n            args = [S.NegativeOne]\n        else:\n            args = []\n        args.extend([Pow(*i, evaluate=False) for i in sorted(factordict.items())])\n        return Mul(*args, evaluate=False)\n    elif isinstance(n, (dict, Mul)):\n        return factordict\n    assert use_trial or use_rho or use_pm1 or use_ecm\n    from sympy.functions.combinatorial.factorials import factorial\n    if isinstance(n, factorial):\n        x = as_int(n.args[0])\n        if x >= 20:\n            factors = {}\n            m = 2\n            for p in sieve.primerange(2, x + 1):\n                if m > 1:\n                    m, q = (0, x // p)\n                    while q != 0:\n                        m += q\n                        q //= p\n                factors[p] = m\n            if factors and verbose:\n                for k in sorted(factors):\n                    print(factor_msg % (k, factors[k]))\n            if verbose:\n                print(complete_msg)\n            return factors\n        else:\n            n = n.func(x)\n    n = as_int(n)\n    if limit:\n        limit = int(limit)\n        use_ecm = False\n    if n < 0:\n        factors = factorint(-n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n        factors[-1] = 1\n        return factors\n    if limit and limit < 2:\n        if n == 1:\n            return {}\n        return {n: 1}\n    elif n < 10:\n        return [{0: 1}, {}, {2: 1}, {3: 1}, {2: 2}, {5: 1}, {2: 1, 3: 1}, {7: 1}, {2: 3}, {3: 2}][n]\n    factors = {}\n    if verbose:\n        sn = str(n)\n        if len(sn) > 50:\n            print('Factoring %s' % sn[:5] + '..(%i other digits)..' % (len(sn) - 10) + sn[-5:])\n        else:\n            print('Factoring', n)\n    if use_trial:\n        small = 2 ** 15\n        fail_max = 600\n        small = min(small, limit or small)\n        if verbose:\n            print(trial_int_msg % (2, small, fail_max))\n        n, next_p = _factorint_small(factors, n, small, fail_max)\n    else:\n        next_p = 2\n    if factors and verbose:\n        for k in sorted(factors):\n            print(factor_msg % (k, factors[k]))\n    if next_p == 0:\n        if n > 1:\n            factors[int(n)] = 1\n        if verbose:\n            print(complete_msg)\n        return factors\n    try:\n        if limit and next_p > limit:\n            if verbose:\n                print('Exceeded limit:', limit)\n            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n            if n > 1:\n                factors[int(n)] = 1\n            return factors\n        else:\n            sqrt_n = integer_nthroot(n, 2)[0]\n            a = sqrt_n + 1\n            a2 = a ** 2\n            b2 = a2 - n\n            for i in range(3):\n                b, fermat = integer_nthroot(b2, 2)\n                if fermat:\n                    break\n                b2 += 2 * a + 1\n                a += 1\n            if fermat:\n                if verbose:\n                    print(fermat_msg)\n                if limit:\n                    limit -= 1\n                for r in [a - b, a + b]:\n                    facs = factorint(r, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)\n                    for k, v in facs.items():\n                        factors[k] = factors.get(k, 0) + v\n                raise StopIteration\n            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n    except StopIteration:\n        if verbose:\n            print(complete_msg)\n        return factors\n    low, high = (next_p, 2 * next_p)\n    limit = limit or sqrt_n\n    limit += 1\n    iteration = 0\n    while 1:\n        try:\n            high_ = high\n            if limit < high_:\n                high_ = limit\n            if use_trial:\n                if verbose:\n                    print(trial_msg % (low, high_))\n                ps = sieve.primerange(low, high_)\n                n, found_trial = _trial(factors, n, ps, verbose)\n                if found_trial:\n                    _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n            else:\n                found_trial = False\n            if high > limit:\n                if verbose:\n                    print('Exceeded limit:', limit)\n                if n > 1:\n                    factors[int(n)] = 1\n                raise StopIteration\n            if not found_trial:\n                if use_pm1 or use_rho:\n                    high_root = max(int(math.log(high_ ** 0.7)), low, 3)\n                    if use_pm1:\n                        if verbose:\n                            print(pm1_msg % (high_root, high_))\n                        c = pollard_pm1(n, B=high_root, seed=high_)\n                        if c:\n                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, use_ecm=use_ecm, verbose=verbose)\n                            n, _ = _trial(factors, n, ps, verbose=False)\n                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n                    if use_rho:\n                        max_steps = high_root\n                        if verbose:\n                            print(rho_msg % (1, max_steps, high_))\n                        c = pollard_rho(n, retries=1, max_steps=max_steps, seed=high_)\n                        if c:\n                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, use_ecm=use_ecm, verbose=verbose)\n                            n, _ = _trial(factors, n, ps, verbose=False)\n                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n        except StopIteration:\n            if verbose:\n                print(complete_msg)\n            return factors\n        iteration += 1\n        if use_ecm and iteration >= 3 and (len(str(n)) >= 25):\n            break\n        low, high = (high, high * 2)\n    B1 = 10000\n    B2 = 100 * B1\n    num_curves = 50\n    while 1:\n        if verbose:\n            print(ecm_msg % (B1, B2, num_curves))\n        while 1:\n            try:\n                factor = _ecm_one_factor(n, B1, B2, num_curves)\n                ps = factorint(factor, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, use_ecm=use_ecm, verbose=verbose)\n                n, _ = _trial(factors, n, ps, verbose=False)\n                _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n            except ValueError:\n                break\n            except StopIteration:\n                if verbose:\n                    print(complete_msg)\n                return factors\n        B1 *= 5\n        B2 = 100 * B1\n        num_curves *= 4",
    ".sympy.core.numbers.py@@Integer.__neg__": "def __neg__(self):\n    return Integer(-self.p)",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational: bool=False) -> tTuple['Number', 'Expr']:\n    return (S.One, self)",
    ".sympy.core.power.py@@Pow.as_base_exp": "def as_base_exp(self):\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and (b.q != 1):\n        return (Integer(b.q), -e)\n    return (b, e)",
    ".sympy.core.numbers.py@@Rational.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.numbers.py@@Rational._hashable_content": "def _hashable_content(self):\n    return (self.p, self.q)",
    ".sympy.core.numbers.py@@Number.__add__": "def __add__(self, other):\n    if isinstance(other, Number) and global_parameters.evaluate:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            return S.Infinity\n        elif other is S.NegativeInfinity:\n            return S.NegativeInfinity\n    return AtomicExpr.__add__(self, other)",
    ".sympy.core.expr.py@@Expr.__truediv__": "def __truediv__(self, other):\n    denom = Pow(other, S.NegativeOne)\n    if self is S.One:\n        return denom\n    else:\n        return Mul(self, denom)",
    ".sympy.core.numbers.py@@NegativeOne.__abs__": "def __abs__():\n    return S.One",
    ".sympy.core.add.py@@Add._eval_subs": "def _eval_subs(self, old, new):\n    if not old.is_Add:\n        if old is S.Infinity and -old in self.args:\n            return self.xreplace({-old: -new})\n        return None\n    coeff_self, terms_self = self.as_coeff_Add()\n    coeff_old, terms_old = old.as_coeff_Add()\n    if coeff_self.is_Rational and coeff_old.is_Rational:\n        if terms_self == terms_old:\n            return self.func(new, coeff_self, -coeff_old)\n        if terms_self == -terms_old:\n            return self.func(-new, coeff_self, coeff_old)\n    if coeff_self.is_Rational and coeff_old.is_Rational or coeff_self == coeff_old:\n        args_old, args_self = (self.func.make_args(terms_old), self.func.make_args(terms_self))\n        if len(args_old) < len(args_self):\n            self_set = set(args_self)\n            old_set = set(args_old)\n            if old_set < self_set:\n                ret_set = self_set - old_set\n                return self.func(new, coeff_self, -coeff_old, *[s._subs(old, new) for s in ret_set])\n            args_old = self.func.make_args(-terms_old)\n            old_set = set(args_old)\n            if old_set < self_set:\n                ret_set = self_set - old_set\n                return self.func(-new, coeff_self, coeff_old, *[s._subs(old, new) for s in ret_set])",
    ".sympy.core.power.py@@Pow._eval_is_finite": "def _eval_is_finite(self):\n    if self.exp.is_negative:\n        if self.base.is_zero:\n            return False\n        if self.base.is_infinite or self.base.is_nonzero:\n            return True\n    c1 = self.base.is_finite\n    if c1 is None:\n        return\n    c2 = self.exp.is_finite\n    if c2 is None:\n        return\n    if c1 and c2:\n        if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):\n            return True",
    ".sympy.core.power.py@@Pow.exp": "def exp(self):\n    return self._args[1]",
    ".sympy.core.power.py@@Pow.base": "def base(self):\n    return self._args[0]",
    ".sympy.core.numbers.py@@One.__neg__": "def __neg__():\n    return S.NegativeOne",
    ".sympy.core.mul.py@@Mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return (coeff, args[0])\n            else:\n                return (coeff, self._new_rawargs(*args))\n        elif coeff.is_extended_negative:\n            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))\n    return (S.One, self)",
    ".sympy.core.numbers.py@@Number.__truediv__": "def __truediv__(self, other):\n    if isinstance(other, Number) and global_parameters.evaluate:\n        if other is S.NaN:\n            return S.NaN\n        elif other in (S.Infinity, S.NegativeInfinity):\n            return S.Zero\n    return AtomicExpr.__truediv__(self, other)",
    ".sympy.core.power.py@@Pow._eval_power": "def _eval_power(self, other):\n    b, e = self.as_base_exp()\n    if b is S.NaN:\n        return (b ** e) ** other\n    s = None\n    if other.is_integer:\n        s = 1\n    elif b.is_polar:\n        s = 1\n    elif e.is_extended_real is not None:\n        from sympy.functions.elementary.complexes import arg, im, re, sign\n        from sympy.functions.elementary.exponential import exp, log\n        from sympy.functions.elementary.integers import floor\n\n        def _half(e):\n            if getattr(e, 'q', None) == 2:\n                return True\n            n, d = e.as_numer_denom()\n            if n.is_integer and d == 2:\n                return True\n\n        def _n2(e):\n            try:\n                rv = e.evalf(2, strict=True)\n                if rv.is_Number:\n                    return rv\n            except PrecisionExhausted:\n                pass\n        if e.is_extended_real:\n            if e == -1:\n                if _half(other):\n                    if b.is_negative is True:\n                        return S.NegativeOne ** other * Pow(-b, e * other)\n                    elif b.is_negative is False:\n                        return Pow(b, -other)\n            elif e.is_even:\n                if b.is_extended_real:\n                    b = abs(b)\n                if b.is_imaginary:\n                    b = abs(im(b)) * S.ImaginaryUnit\n            if (abs(e) < 1) == True or e == 1:\n                s = 1\n            elif b.is_extended_nonnegative:\n                s = 1\n            elif re(b).is_extended_nonnegative and (abs(e) < 2) == True:\n                s = 1\n            elif fuzzy_not(im(b).is_zero) and abs(e) == 2:\n                s = 1\n            elif _half(other):\n                s = exp(2 * S.Pi * S.ImaginaryUnit * other * floor(S.Half - e * arg(b) / (2 * S.Pi)))\n                if s.is_extended_real and _n2(sign(s) - s) == 0:\n                    s = sign(s)\n                else:\n                    s = None\n        else:\n            try:\n                s = exp(2 * S.ImaginaryUnit * S.Pi * other * floor(S.Half - im(e * log(b)) / 2 / S.Pi))\n                if s.is_extended_real and _n2(sign(s) - s) == 0:\n                    s = sign(s)\n                else:\n                    s = None\n            except PrecisionExhausted:\n                s = None\n    if s is not None:\n        return s * Pow(b, e * other)",
    ".sympy.core.evalf.py@@evalf_rational": "def evalf_rational(expr: 'Rational', prec: int, options: OPT_DICT) -> TMP_RES:\n    return (from_rational(expr.p, expr.q, prec), None, prec, None)",
    ".sympy.core.numbers.py@@Rational.__neg__": "def __neg__(self):\n    return Rational(-self.p, self.q)",
    ".sympy.core.numbers.py@@Rational._eval_power": "def _eval_power(self, expt):\n    if isinstance(expt, Number):\n        if isinstance(expt, Float):\n            return self._eval_evalf(expt._prec) ** expt\n        if expt.is_extended_negative:\n            ne = -expt\n            if ne is S.One:\n                return Rational(self.q, self.p)\n            if self.is_negative:\n                return S.NegativeOne ** expt * Rational(self.q, -self.p) ** ne\n            else:\n                return Rational(self.q, self.p) ** ne\n        if expt is S.Infinity:\n            if self.p > self.q:\n                return S.Infinity\n            if self.p < -self.q:\n                return S.Infinity + S.Infinity * S.ImaginaryUnit\n            return S.Zero\n        if isinstance(expt, Integer):\n            return Rational(self.p ** expt.p, self.q ** expt.p, 1)\n        if isinstance(expt, Rational):\n            intpart = expt.p // expt.q\n            if intpart:\n                intpart += 1\n                remfracpart = intpart * expt.q - expt.p\n                ratfracpart = Rational(remfracpart, expt.q)\n                if self.p != 1:\n                    return Integer(self.p) ** expt * Integer(self.q) ** ratfracpart * Rational(1, self.q ** intpart, 1)\n                return Integer(self.q) ** ratfracpart * Rational(1, self.q ** intpart, 1)\n            else:\n                remfracpart = expt.q - expt.p\n                ratfracpart = Rational(remfracpart, expt.q)\n                if self.p != 1:\n                    return Integer(self.p) ** expt * Integer(self.q) ** ratfracpart * Rational(1, self.q, 1)\n                return Integer(self.q) ** ratfracpart * Rational(1, self.q, 1)\n    if self.is_extended_negative and expt.is_even:\n        return (-self) ** expt\n    return",
    ".sympy.core.power.py@@Pow._eval_is_extended_real": "def _eval_is_extended_real(self):\n    if self.base is S.Exp1:\n        if self.exp.is_extended_real:\n            return True\n        elif self.exp.is_imaginary:\n            return (2 * S.ImaginaryUnit * self.exp / S.Pi).is_even\n    from sympy.functions.elementary.exponential import log, exp\n    real_b = self.base.is_extended_real\n    if real_b is None:\n        if self.base.func == exp and self.base.exp.is_imaginary:\n            return self.exp.is_imaginary\n        if self.base.func == Pow and self.base.base is S.Exp1 and self.base.exp.is_imaginary:\n            return self.exp.is_imaginary\n        return\n    real_e = self.exp.is_extended_real\n    if real_e is None:\n        return\n    if real_b and real_e:\n        if self.base.is_extended_positive:\n            return True\n        elif self.base.is_extended_nonnegative and self.exp.is_extended_nonnegative:\n            return True\n        elif self.exp.is_integer and self.base.is_extended_nonzero:\n            return True\n        elif self.exp.is_integer and self.exp.is_nonnegative:\n            return True\n        elif self.base.is_extended_negative:\n            if self.exp.is_Rational:\n                return False\n    if real_e and self.exp.is_extended_negative and (self.base.is_zero is False):\n        return Pow(self.base, -self.exp).is_extended_real\n    im_b = self.base.is_imaginary\n    im_e = self.exp.is_imaginary\n    if im_b:\n        if self.exp.is_integer:\n            if self.exp.is_even:\n                return True\n            elif self.exp.is_odd:\n                return False\n        elif im_e and log(self.base).is_imaginary:\n            return True\n        elif self.exp.is_Add:\n            c, a = self.exp.as_coeff_Add()\n            if c and c.is_Integer:\n                return Mul(self.base ** c, self.base ** a, evaluate=False).is_extended_real\n        elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):\n            if (self.exp / 2).is_integer is False:\n                return False\n    if real_b and im_e:\n        if self.base is S.NegativeOne:\n            return True\n        c = self.exp.coeff(S.ImaginaryUnit)\n        if c:\n            if self.base.is_rational and c.is_rational:\n                if self.base.is_nonzero and (self.base - 1).is_nonzero and c.is_nonzero:\n                    return False\n            ok = (c * log(self.base) / S.Pi).is_integer\n            if ok is not None:\n                return ok\n    if real_b is False:\n        from sympy.functions.elementary.complexes import arg\n        i = arg(self.base) * self.exp / S.Pi\n        if i.is_complex:\n            return i.is_integer",
    ".sympy.core.power.py@@Pow._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    if self.base == self.exp:\n        if self.base.is_extended_nonnegative:\n            return True\n    elif self.base.is_positive:\n        if self.exp.is_real:\n            return True\n    elif self.base.is_extended_negative:\n        if self.exp.is_even:\n            return True\n        if self.exp.is_odd:\n            return False\n    elif self.base.is_zero:\n        if self.exp.is_extended_real:\n            return self.exp.is_zero\n    elif self.base.is_extended_nonpositive:\n        if self.exp.is_odd:\n            return False\n    elif self.base.is_imaginary:\n        if self.exp.is_integer:\n            m = self.exp % 4\n            if m.is_zero:\n                return True\n            if m.is_integer and m.is_zero is False:\n                return False\n        if self.exp.is_imaginary:\n            from sympy.functions.elementary.exponential import log\n            return log(self.base).is_imaginary",
    ".sympy.core.power.py@@Pow._eval_is_composite": "def _eval_is_composite(self):\n    if self.base.is_integer and self.exp.is_integer and ((self.base - 1).is_positive and (self.exp - 1).is_positive or ((self.base + 1).is_negative and self.exp.is_positive and self.exp.is_even)):\n        return True",
    ".sympy.core.power.py@@Pow._eval_is_positive": "def _eval_is_positive(self):\n    ext_pos = Pow._eval_is_extended_positive(self)\n    if ext_pos is True:\n        return self.is_finite\n    return ext_pos",
    ".sympy.core.power.py@@Pow._eval_is_negative": "def _eval_is_negative(self):\n    ext_neg = Pow._eval_is_extended_negative(self)\n    if ext_neg is True:\n        return self.is_finite\n    return ext_neg",
    ".sympy.core.power.py@@Pow._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    if self.exp is S.Half:\n        if self.base.is_complex or self.base.is_extended_real:\n            return False\n    if self.base.is_extended_negative:\n        if self.exp.is_odd and self.base.is_finite:\n            return True\n        if self.exp.is_even:\n            return False\n    elif self.base.is_extended_positive:\n        if self.exp.is_extended_real:\n            return False\n    elif self.base.is_zero:\n        if self.exp.is_extended_real:\n            return False\n    elif self.base.is_extended_nonnegative:\n        if self.exp.is_extended_nonnegative:\n            return False\n    elif self.base.is_extended_nonpositive:\n        if self.exp.is_even:\n            return False\n    elif self.base.is_extended_real:\n        if self.exp.is_even:\n            return False",
    ".sympy.core.power.py@@Pow._eval_is_imaginary": "def _eval_is_imaginary(self):\n    if self.base.is_imaginary:\n        if self.exp.is_integer:\n            odd = self.exp.is_odd\n            if odd is not None:\n                return odd\n            return\n    if self.base == S.Exp1:\n        f = 2 * self.exp / (S.Pi * S.ImaginaryUnit)\n        if f.is_even:\n            return False\n        if f.is_odd:\n            return True\n        return None\n    if self.exp.is_imaginary:\n        from sympy.functions.elementary.exponential import log\n        imlog = log(self.base).is_imaginary\n        if imlog is not None:\n            return False\n    if self.base.is_extended_real and self.exp.is_extended_real:\n        if self.base.is_positive:\n            return False\n        else:\n            rat = self.exp.is_rational\n            if not rat:\n                return rat\n            if self.exp.is_integer:\n                return False\n            else:\n                half = (2 * self.exp).is_integer\n                if half:\n                    return self.base.is_negative\n                return half\n    if self.base.is_extended_real is False:\n        from sympy.functions.elementary.complexes import arg\n        i = arg(self.base) * self.exp / S.Pi\n        isodd = (2 * i).is_odd\n        if isodd is not None:\n            return isodd",
    ".sympy.core.power.py@@Pow._eval_is_integer": "def _eval_is_integer(self):\n    b, e = self.args\n    if b.is_rational:\n        if b.is_integer is False and e.is_positive:\n            return False\n    if b.is_integer and e.is_integer:\n        if b is S.NegativeOne:\n            return True\n        if e.is_nonnegative or e.is_positive:\n            return True\n    if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):\n        if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):\n            return False\n    if b.is_Number and e.is_Number:\n        check = self.func(*self.args)\n        return check.is_Integer\n    if e.is_negative and b.is_positive and (b - 1).is_positive:\n        return False\n    if e.is_negative and b.is_negative and (b + 1).is_negative:\n        return False",
    ".sympy.core.power.py@@Pow._eval_is_zero": "def _eval_is_zero(self):\n    if self.base.is_zero:\n        if self.exp.is_extended_positive:\n            return True\n        elif self.exp.is_extended_nonpositive:\n            return False\n    elif self.base == S.Exp1:\n        return self.exp is S.NegativeInfinity\n    elif self.base.is_zero is False:\n        if self.base.is_finite and self.exp.is_finite:\n            return False\n        elif self.exp.is_negative:\n            return self.base.is_infinite\n        elif self.exp.is_nonnegative:\n            return False\n        elif self.exp.is_infinite and self.exp.is_extended_real:\n            if (1 - abs(self.base)).is_extended_positive:\n                return self.exp.is_extended_positive\n            elif (1 - abs(self.base)).is_extended_negative:\n                return self.exp.is_extended_negative\n    elif self.base.is_finite and self.exp.is_negative:\n        return False",
    ".sympy.core.power.py@@Pow._eval_is_prime": "def _eval_is_prime(self):\n    if self.base.is_integer and self.exp.is_integer and (self.exp - 1).is_positive:\n        return False",
    ".sympy.core.power.py@@Pow._eval_is_rational": "def _eval_is_rational(self):\n    if self.exp.is_integer and self.base.is_rational and fuzzy_not(fuzzy_and([self.exp.is_negative, self.base.is_zero])):\n        return True\n    p = self.func(*self.as_base_exp())\n    if not p.is_Pow:\n        return p.is_rational\n    b, e = p.as_base_exp()\n    if e.is_Rational and b.is_Rational:\n        return False\n    if e.is_integer:\n        if b.is_rational:\n            if fuzzy_not(b.is_zero) or e.is_nonnegative:\n                return True\n            if b == e:\n                return True\n        elif b.is_irrational:\n            return e.is_zero\n    if b is S.Exp1:\n        if e.is_rational and e.is_nonzero:\n            return False",
    ".sympy.core.expr.py@@Expr._eval_power": "def _eval_power(self, other):\n    return None",
    ".sympy.core.power.py@@Pow._eval_is_complex": "def _eval_is_complex(self):\n    if self.base == S.Exp1:\n        return fuzzy_or([self.exp.is_complex, self.exp.is_extended_negative])\n    if all((a.is_complex for a in self.args)) and self._eval_is_finite():\n        return True",
    ".sympy.core.power.py@@Pow._eval_is_odd": "def _eval_is_odd(self):\n    if self.exp.is_integer:\n        if self.exp.is_positive:\n            return self.base.is_odd\n        elif self.exp.is_nonnegative and self.base.is_odd:\n            return True\n        elif self.base is S.NegativeOne:\n            return True",
    ".sympy.core.power.py@@Pow._eval_is_algebraic": "def _eval_is_algebraic(self):\n\n    def _is_one(expr):\n        try:\n            return (expr - 1).is_zero\n        except ValueError:\n            return False\n    if self.base.is_zero or _is_one(self.base):\n        return True\n    elif self.base is S.Exp1:\n        s = self.func(*self.args)\n        if s.func == self.func:\n            if self.exp.is_nonzero:\n                if self.exp.is_algebraic:\n                    return False\n                elif (self.exp / S.Pi).is_rational:\n                    return False\n                elif (self.exp / (S.ImaginaryUnit * S.Pi)).is_rational:\n                    return True\n        else:\n            return s.is_algebraic\n    elif self.exp.is_rational:\n        if self.base.is_algebraic is False:\n            return self.exp.is_zero\n        if self.base.is_zero is False:\n            if self.exp.is_nonzero:\n                return self.base.is_algebraic\n            elif self.base.is_algebraic:\n                return True\n        if self.exp.is_positive:\n            return self.base.is_algebraic\n    elif self.base.is_algebraic and self.exp.is_algebraic:\n        if fuzzy_not(self.base.is_zero) and fuzzy_not(_is_one(self.base)) or self.base.is_integer is False or self.base.is_irrational:\n            return self.exp.is_rational",
    ".sympy.core.power.py@@Pow._is_one": "def _is_one(expr):\n    try:\n        return (expr - 1).is_zero\n    except ValueError:\n        return False",
    ".sympy.core.expr.py@@Expr.__sub__": "def __sub__(self, other):\n    return Add(self, -other)",
    ".sympy.core.operations.py@@AssocOp._new_rawargs": "def _new_rawargs(self, *args, reeval=True, **kwargs):\n    if reeval and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)",
    ".sympy.core.exprtools.py@@_monotonic_sign": "def _monotonic_sign(self):\n    if not self.is_extended_real:\n        return\n    if (-self).is_Symbol:\n        rv = _monotonic_sign(-self)\n        return rv if rv is None else -rv\n    if not self.is_Add and self.as_numer_denom()[1].is_number:\n        s = self\n        if s.is_prime:\n            if s.is_odd:\n                return Integer(3)\n            else:\n                return Integer(2)\n        elif s.is_composite:\n            if s.is_odd:\n                return Integer(9)\n            else:\n                return Integer(4)\n        elif s.is_positive:\n            if s.is_even:\n                if s.is_prime is False:\n                    return Integer(4)\n                else:\n                    return Integer(2)\n            elif s.is_integer:\n                return S.One\n            else:\n                return _eps\n        elif s.is_extended_negative:\n            if s.is_even:\n                return Integer(-2)\n            elif s.is_integer:\n                return S.NegativeOne\n            else:\n                return -_eps\n        if s.is_zero or s.is_extended_nonpositive or s.is_extended_nonnegative:\n            return S.Zero\n        return None\n    free = self.free_symbols\n    if len(free) == 1:\n        if self.is_polynomial():\n            from sympy.polys.polytools import real_roots\n            from sympy.polys.polyroots import roots\n            from sympy.polys.polyerrors import PolynomialError\n            x = free.pop()\n            x0 = _monotonic_sign(x)\n            if x0 in (_eps, -_eps):\n                x0 = S.Zero\n            if x0 is not None:\n                d = self.diff(x)\n                if d.is_number:\n                    currentroots = []\n                else:\n                    try:\n                        currentroots = real_roots(d)\n                    except (PolynomialError, NotImplementedError):\n                        currentroots = [r for r in roots(d, x) if r.is_extended_real]\n                y = self.subs(x, x0)\n                if x.is_nonnegative and all(((r - x0).is_nonpositive for r in currentroots)):\n                    if y.is_nonnegative and d.is_positive:\n                        if y:\n                            return y if y.is_positive else Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_negative:\n                        if y:\n                            return y if y.is_negative else Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n                elif x.is_nonpositive and all(((r - x0).is_nonnegative for r in currentroots)):\n                    if y.is_nonnegative and d.is_negative:\n                        if y:\n                            return Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_positive:\n                        if y:\n                            return Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n        else:\n            n, d = self.as_numer_denom()\n            den = None\n            if n.is_number:\n                den = _monotonic_sign(d)\n            elif not d.is_number:\n                if _monotonic_sign(n) is not None:\n                    den = _monotonic_sign(d)\n            if den is not None and (den.is_positive or den.is_negative):\n                v = n * den\n                if v.is_positive:\n                    return Dummy('pos', positive=True)\n                elif v.is_nonnegative:\n                    return Dummy('nneg', nonnegative=True)\n                elif v.is_negative:\n                    return Dummy('neg', negative=True)\n                elif v.is_nonpositive:\n                    return Dummy('npos', nonpositive=True)\n        return None\n    c, a = self.as_coeff_Add()\n    v = None\n    if not a.is_polynomial():\n        n, d = a.as_numer_denom()\n        if not (n.is_number or d.is_number):\n            return\n        if (a.is_Mul or a.is_Pow) and a.is_rational and all((p.exp.is_Integer for p in a.atoms(Pow) if p.is_Pow)) and (a.is_positive or a.is_negative):\n            v = S.One\n            for ai in Mul.make_args(a):\n                if ai.is_number:\n                    v *= ai\n                    continue\n                reps = {}\n                for x in ai.free_symbols:\n                    reps[x] = _monotonic_sign(x)\n                    if reps[x] is None:\n                        return\n                v *= ai.subs(reps)\n    elif c:\n        if not any((p for p in a.atoms(Pow) if not p.is_number)) and (a.is_nonpositive or a.is_nonnegative):\n            free = list(a.free_symbols)\n            p = {}\n            for i in free:\n                v = _monotonic_sign(i)\n                if v is None:\n                    return\n                p[i] = v or (_eps if i.is_nonnegative else -_eps)\n            v = a.xreplace(p)\n    if v is not None:\n        rv = v + c\n        if v.is_nonnegative and rv.is_positive:\n            return rv.subs(_eps, 0)\n        if v.is_nonpositive and rv.is_negative:\n            return rv.subs(_eps, 0)",
    ".sympy.core.power.py@@Pow._eval_is_even": "def _eval_is_even(self):\n    if self.exp.is_integer and self.exp.is_positive:\n        return self.base.is_even",
    ".sympy.core.numbers.py@@Rational._eval_is_positive": "def _eval_is_positive(self):\n    return self.p > 0",
    ".sympy.core.power.py@@Pow._eval_derivative": "def _eval_derivative(self, s):\n    from sympy.functions.elementary.exponential import log\n    dbase = self.base.diff(s)\n    dexp = self.exp.diff(s)\n    return self * (dexp * log(self.base) + dbase * self.exp / self.base)",
    ".sympy.core.function.py@@Function.__new__": "def __new__(cls, *args, **options):\n    if cls is Function:\n        return UndefinedFunction(*args, **options)\n    n = len(args)\n    if n not in cls.nargs:\n        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'\n        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})\n    evaluate = options.get('evaluate', global_parameters.evaluate)\n    result = super().__new__(cls, *args, **options)\n    if evaluate and isinstance(result, cls) and result.args:\n        pr2 = min((cls._should_evalf(a) for a in result.args))\n        if pr2 > 0:\n            pr = max((cls._should_evalf(a) for a in result.args))\n            result = result.evalf(prec_to_dps(pr))\n    return result",
    ".sympy.core.function.py@@FunctionClass.nargs": "def nargs(self):\n    from sympy.sets.sets import FiniteSet\n    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0",
    ".sympy.sets.sets.py@@FiniteSet.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n    if evaluate:\n        args = list(map(sympify, args))\n        if len(args) == 0:\n            return S.EmptySet\n    else:\n        args = list(map(sympify, args))\n    dargs = {}\n    for i in reversed(list(ordered(args))):\n        if i.is_Symbol:\n            dargs[i] = i\n        else:\n            try:\n                dargs[i.as_dummy()] = i\n            except TypeError:\n                dargs[i] = i\n    _args_set = set(dargs.values())\n    args = list(ordered(_args_set, Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._args_set = _args_set\n    return obj",
    ".sympy.core.basic.py@@Basic.as_dummy": "def as_dummy(self):\n    from .symbol import Dummy, Symbol\n\n    def can(x):\n        free = x.free_symbols\n        bound = set(x.bound_symbols)\n        d = {i: Dummy() for i in bound & free}\n        x = x.subs(d)\n        x = x.xreplace(x.canonical_variables)\n        return x.xreplace({v: k for k, v in d.items()})\n    if not self.has(Symbol):\n        return self\n    return self.replace(lambda x: hasattr(x, 'bound_symbols'), can, simultaneous=False)",
    ".sympy.core.basic.py@@Basic.has": "def has(self, *patterns):\n    return self._has(iterargs, *patterns)",
    ".sympy.core.basic.py@@Basic._has": "def _has(self, iterargs, *patterns):\n    type_set = set()\n    p_set = set()\n    for p in patterns:\n        if isinstance(p, BasicMeta):\n            type_set.add(p)\n            continue\n        if not isinstance(p, Basic):\n            try:\n                p = _sympify(p)\n            except SympifyError:\n                continue\n        p_set.add(p)\n    types = tuple(type_set)\n    for i in iterargs(self):\n        if i in p_set:\n            return True\n        if isinstance(i, types):\n            return True\n    for i in p_set - type_set:\n        if not hasattr(i, '_has_matcher'):\n            continue\n        match = i._has_matcher()\n        if any((match(arg) for arg in iterargs(self))):\n            return True\n    return False",
    ".sympy.core.traversal.py@@iterargs": "def iterargs(expr):\n    args = [expr]\n    for i in args:\n        yield i\n        try:\n            args.extend(i.args)\n        except TypeError:\n            pass",
    ".sympy.sets.sets.py@@Set._infimum_key": "def _infimum_key(expr):\n    try:\n        infimum = expr.inf\n        assert infimum.is_comparable\n        infimum = infimum.evalf()\n    except (NotImplementedError, AttributeError, AssertionError, ValueError):\n        infimum = S.Infinity\n    return infimum",
    ".sympy.core.numbers.py@@Infinity.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.sets.sets.py@@Set.__contains__": "def __contains__(self, other):\n    other = _sympify(other)\n    c = self._contains(other)\n    b = tfn[c]\n    if b is None:\n        raise TypeError('did not evaluate to a bool: %r' % c)\n    return b",
    ".sympy.sets.sets.py@@FiniteSet._contains": "def _contains(self, other):\n    if other in self._args_set:\n        return True\n    else:\n        return fuzzy_or((fuzzy_bool(Eq(e, other, evaluate=True)) for e in self.args))",
    ".sympy.core.function.py@@Application.__new__": "def __new__(cls, *args, **options):\n    from sympy.sets.fancysets import Naturals0\n    from sympy.sets.sets import FiniteSet\n    args = list(map(sympify, args))\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    options.pop('nargs', None)\n    if options:\n        raise ValueError('Unknown options: %s' % options)\n    if evaluate:\n        evaluated = cls.eval(*args)\n        if evaluated is not None:\n            return evaluated\n    obj = super().__new__(cls, *args, **options)\n    sentinel = object()\n    objnargs = getattr(obj, 'nargs', sentinel)\n    if objnargs is not sentinel:\n        if is_sequence(objnargs):\n            nargs = tuple(ordered(set(objnargs)))\n        elif objnargs is not None:\n            nargs = (as_int(objnargs),)\n        else:\n            nargs = None\n    else:\n        nargs = obj._nargs\n    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()\n    return obj",
    ".sympy.functions.elementary.exponential.py@@log.eval": "def eval(cls, arg, base=None):\n    from sympy.calculus import AccumBounds\n    from sympy.sets.setexpr import SetExpr\n    arg = sympify(arg)\n    if base is not None:\n        base = sympify(base)\n        if base == 1:\n            if arg == 1:\n                return S.NaN\n            else:\n                return S.ComplexInfinity\n        try:\n            n = multiplicity(base, arg)\n            if n:\n                return n + log(arg / base ** n) / log(base)\n            else:\n                return log(arg) / log(base)\n        except ValueError:\n            pass\n        if base is not S.Exp1:\n            return cls(arg) / cls(base)\n        else:\n            return cls(arg)\n    if arg.is_Number:\n        if arg.is_zero:\n            return S.ComplexInfinity\n        elif arg is S.One:\n            return S.Zero\n        elif arg is S.Infinity:\n            return S.Infinity\n        elif arg is S.NegativeInfinity:\n            return S.Infinity\n        elif arg is S.NaN:\n            return S.NaN\n        elif arg.is_Rational and arg.p == 1:\n            return -cls(arg.q)\n    if arg.is_Pow and arg.base is S.Exp1 and arg.exp.is_extended_real:\n        return arg.exp\n    I = S.ImaginaryUnit\n    if isinstance(arg, exp) and arg.exp.is_extended_real:\n        return arg.exp\n    elif isinstance(arg, exp) and arg.exp.is_number:\n        r_, i_ = match_real_imag(arg.exp)\n        if i_ and i_.is_comparable:\n            i_ %= 2 * S.Pi\n            if i_ > S.Pi:\n                i_ -= 2 * S.Pi\n            return r_ + expand_mul(i_ * I, deep=False)\n    elif isinstance(arg, exp_polar):\n        return unpolarify(arg.exp)\n    elif isinstance(arg, AccumBounds):\n        if arg.min.is_positive:\n            return AccumBounds(log(arg.min), log(arg.max))\n        elif arg.min.is_zero:\n            return AccumBounds(S.NegativeInfinity, log(arg.max))\n        else:\n            return S.NaN\n    elif isinstance(arg, SetExpr):\n        return arg._eval_func(cls)\n    if arg.is_number:\n        if arg.is_negative:\n            return S.Pi * I + cls(-arg)\n        elif arg is S.ComplexInfinity:\n            return S.ComplexInfinity\n        elif arg is S.Exp1:\n            return S.One\n    if arg.is_zero:\n        return S.ComplexInfinity\n    if not arg.is_Add:\n        coeff = arg.as_coefficient(I)\n        if coeff is not None:\n            if coeff is S.Infinity:\n                return S.Infinity\n            elif coeff is S.NegativeInfinity:\n                return S.Infinity\n            elif coeff.is_Rational:\n                if coeff.is_nonnegative:\n                    return S.Pi * I * S.Half + cls(coeff)\n                else:\n                    return -S.Pi * I * S.Half + cls(-coeff)\n    if arg.is_number and arg.is_algebraic:\n        coeff, arg_ = arg.as_independent(I, as_Add=False)\n        if coeff.is_negative:\n            coeff *= -1\n            arg_ *= -1\n        arg_ = expand_mul(arg_, deep=False)\n        r_, i_ = arg_.as_independent(I, as_Add=True)\n        i_ = i_.as_coefficient(I)\n        if coeff.is_real and i_ and i_.is_real and r_.is_real:\n            if r_.is_zero:\n                if i_.is_positive:\n                    return S.Pi * I * S.Half + cls(coeff * i_)\n                elif i_.is_negative:\n                    return -S.Pi * I * S.Half + cls(coeff * -i_)\n            else:\n                from sympy.simplify import ratsimp\n                t = (i_ / r_).cancel()\n                t1 = (-t).cancel()\n                atan_table = {sqrt(3): S.Pi / 3, 1: S.Pi / 4, sqrt(5 - 2 * sqrt(5)): S.Pi / 5, sqrt(2) * sqrt(5 - sqrt(5)) / (1 + sqrt(5)): S.Pi / 5, sqrt(5 + 2 * sqrt(5)): S.Pi * Rational(2, 5), sqrt(2) * sqrt(sqrt(5) + 5) / (-1 + sqrt(5)): S.Pi * Rational(2, 5), sqrt(3) / 3: S.Pi / 6, sqrt(2) - 1: S.Pi / 8, sqrt(2 - sqrt(2)) / sqrt(sqrt(2) + 2): S.Pi / 8, sqrt(2) + 1: S.Pi * Rational(3, 8), sqrt(sqrt(2) + 2) / sqrt(2 - sqrt(2)): S.Pi * Rational(3, 8), sqrt(1 - 2 * sqrt(5) / 5): S.Pi / 10, (-sqrt(2) + sqrt(10)) / (2 * sqrt(sqrt(5) + 5)): S.Pi / 10, sqrt(1 + 2 * sqrt(5) / 5): S.Pi * Rational(3, 10), (sqrt(2) + sqrt(10)) / (2 * sqrt(5 - sqrt(5))): S.Pi * Rational(3, 10), 2 - sqrt(3): S.Pi / 12, (-1 + sqrt(3)) / (1 + sqrt(3)): S.Pi / 12, 2 + sqrt(3): S.Pi * Rational(5, 12), (1 + sqrt(3)) / (-1 + sqrt(3)): S.Pi * Rational(5, 12)}\n                if t in atan_table:\n                    modulus = ratsimp(coeff * Abs(arg_))\n                    if r_.is_positive:\n                        return cls(modulus) + I * atan_table[t]\n                    else:\n                        return cls(modulus) + I * (atan_table[t] - S.Pi)\n                elif t1 in atan_table:\n                    modulus = ratsimp(coeff * Abs(arg_))\n                    if r_.is_positive:\n                        return cls(modulus) + I * -atan_table[t1]\n                    else:\n                        return cls(modulus) + I * (S.Pi - atan_table[t1])",
    ".sympy.core.decorators.py@@_sympifyit": "def _sympifyit(arg, retval=None):\n\n    def deco(func):\n        return __sympifyit(func, arg, retval)\n    return deco",
    ".sympy.core.decorators.py@@call_highest_priority": "def call_highest_priority(method_name):\n\n    def priority_decorator(func):\n\n        @wraps(func)\n        def binary_op_wrapper(self, other):\n            if hasattr(other, '_op_priority'):\n                if other._op_priority > self._op_priority:\n                    f = getattr(other, method_name, None)\n                    if f is not None:\n                        return f(self)\n            return func(self, other)\n        return binary_op_wrapper\n    return priority_decorator",
    ".sympy.core.decorators.py@@priority_decorator": "def priority_decorator(func):\n\n    @wraps(func)\n    def binary_op_wrapper(self, other):\n        if hasattr(other, '_op_priority'):\n            if other._op_priority > self._op_priority:\n                f = getattr(other, method_name, None)\n                if f is not None:\n                    return f(self)\n        return func(self, other)\n    return binary_op_wrapper",
    ".sympy.core.decorators.py@@deco": "def deco(func):\n    return __sympifyit(func, arg, retval)",
    ".sympy.core.decorators.py@@__sympifyit": "def __sympifyit(func, arg, retval=None):\n    if not func.__code__.co_argcount:\n        raise LookupError('func not found')\n    assert func.__code__.co_varnames[1] == arg\n    if retval is None:\n\n        @wraps(func)\n        def __sympifyit_wrapper(a, b):\n            return func(a, sympify(b, strict=True))\n    else:\n\n        @wraps(func)\n        def __sympifyit_wrapper(a, b):\n            try:\n                if not hasattr(b, '_op_priority'):\n                    b = sympify(b, strict=True)\n                return func(a, b)\n            except SympifyError:\n                return retval\n    return __sympifyit_wrapper",
    ".sympy.core.assumptions.py@@ManagedProperties.__init__": "def __init__(cls, *args, **kws):\n    BasicMeta.__init__(cls, *args, **kws)\n    local_defs = {}\n    for k in _assume_defined:\n        attrname = as_property(k)\n        v = cls.__dict__.get(attrname, '')\n        if isinstance(v, (bool, int, type(None))):\n            if v is not None:\n                v = bool(v)\n            local_defs[k] = v\n    defs = {}\n    for base in reversed(cls.__bases__):\n        assumptions = getattr(base, '_explicit_class_assumptions', None)\n        if assumptions is not None:\n            defs.update(assumptions)\n    defs.update(local_defs)\n    cls._explicit_class_assumptions = defs\n    cls.default_assumptions = StdFactKB(defs)\n    cls._prop_handler = {}\n    for k in _assume_defined:\n        eval_is_meth = getattr(cls, '_eval_is_%s' % k, None)\n        if eval_is_meth is not None:\n            cls._prop_handler[k] = eval_is_meth\n    for k, v in cls.default_assumptions.items():\n        setattr(cls, as_property(k), v)\n    derived_from_bases = set()\n    for base in cls.__bases__:\n        default_assumptions = getattr(base, 'default_assumptions', None)\n        if default_assumptions is not None:\n            derived_from_bases.update(default_assumptions)\n    for fact in derived_from_bases - set(cls.default_assumptions):\n        pname = as_property(fact)\n        if pname not in cls.__dict__:\n            setattr(cls, pname, make_property(fact))\n    for fact in _assume_defined:\n        pname = as_property(fact)\n        if not hasattr(cls, pname):\n            setattr(cls, pname, make_property(fact))",
    ".sympy.core.core.py@@BasicMeta.__init__": "def __init__(cls, *args, **kws):\n    all_classes.add(cls)\n    cls.__sympy__ = property(lambda self: True)",
    ".sympy.core.assumptions.py@@as_property": "def as_property(fact):\n    return 'is_%s' % fact",
    ".sympy.core.expr.py@@Expr.as_coefficient": "def as_coefficient(self, expr):\n    r = self.extract_multiplicatively(expr)\n    if r and (not r.has(expr)):\n        return r",
    ".sympy.core.expr.py@@Expr.extract_multiplicatively": "def extract_multiplicatively(self, c):\n    from sympy.functions.elementary.exponential import exp\n    from .add import _unevaluated_Add\n    c = sympify(c)\n    if self is S.NaN:\n        return None\n    if c is S.One:\n        return self\n    elif c == self:\n        return S.One\n    if c.is_Add:\n        cc, pc = c.primitive()\n        if cc is not S.One:\n            c = Mul(cc, pc, evaluate=False)\n    if c.is_Mul:\n        a, b = c.as_two_terms()\n        x = self.extract_multiplicatively(a)\n        if x is not None:\n            return x.extract_multiplicatively(b)\n        else:\n            return x\n    quotient = self / c\n    if self.is_Number:\n        if self is S.Infinity:\n            if c.is_positive:\n                return S.Infinity\n        elif self is S.NegativeInfinity:\n            if c.is_negative:\n                return S.Infinity\n            elif c.is_positive:\n                return S.NegativeInfinity\n        elif self is S.ComplexInfinity:\n            if not c.is_zero:\n                return S.ComplexInfinity\n        elif self.is_Integer:\n            if not quotient.is_Integer:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n        elif self.is_Rational:\n            if not quotient.is_Rational:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n        elif self.is_Float:\n            if not quotient.is_Float:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n    elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:\n        if quotient.is_Mul and len(quotient.args) == 2:\n            if quotient.args[0].is_Integer and quotient.args[0].is_positive and (quotient.args[1] == self):\n                return quotient\n        elif quotient.is_Integer and c.is_Number:\n            return quotient\n    elif self.is_Add:\n        cs, ps = self.primitive()\n        if c.is_Number and c is not S.NegativeOne:\n            if cs is not S.One:\n                if c.is_negative:\n                    xc = -cs.extract_multiplicatively(-c)\n                else:\n                    xc = cs.extract_multiplicatively(c)\n                if xc is not None:\n                    return xc * ps\n            return\n        if c == ps:\n            return cs\n        newargs = []\n        for arg in ps.args:\n            newarg = arg.extract_multiplicatively(c)\n            if newarg is None:\n                return\n            newargs.append(newarg)\n        if cs is not S.One:\n            args = [cs * t for t in newargs]\n            return _unevaluated_Add(*args)\n        else:\n            return Add._from_args(newargs)\n    elif self.is_Mul:\n        args = list(self.args)\n        for i, arg in enumerate(args):\n            newarg = arg.extract_multiplicatively(c)\n            if newarg is not None:\n                args[i] = newarg\n                return Mul(*args)\n    elif self.is_Pow or isinstance(self, exp):\n        sb, se = self.as_base_exp()\n        cb, ce = c.as_base_exp()\n        if cb == sb:\n            new_exp = se.extract_additively(ce)\n            if new_exp is not None:\n                return Pow(sb, new_exp)\n        elif c == sb:\n            new_exp = self.exp.extract_additively(1)\n            if new_exp is not None:\n                return Pow(sb, new_exp)",
    ".sympy.core.numbers.py@@ImaginaryUnit._eval_power": "def _eval_power(self, expt):\n    if isinstance(expt, Integer):\n        expt = expt % 4\n        if expt == 0:\n            return S.One\n        elif expt == 1:\n            return S.ImaginaryUnit\n        elif expt == 2:\n            return S.NegativeOne\n        elif expt == 3:\n            return -S.ImaginaryUnit\n    if isinstance(expt, Rational):\n        i, r = divmod(expt, 2)\n        rv = Pow(S.ImaginaryUnit, r, evaluate=False)\n        if i % 2:\n            return Mul(S.NegativeOne, rv, evaluate=False)\n        return rv",
    ".sympy.core.expr.py@@Expr.__neg__": "def __neg__(self):\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    ".sympy.core.function.py@@Function._should_evalf": "def _should_evalf(cls, arg):\n    if arg.is_Float:\n        return arg._prec\n    if not arg.is_Add:\n        return -1\n    from .evalf import pure_complex\n    m = pure_complex(arg)\n    if m is None or not (m[0].is_Float or m[1].is_Float):\n        return -1\n    l = [i._prec for i in m if i.is_Float]\n    l.append(-1)\n    return max(l)",
    ".sympy.core.function.py@@Function._eval_is_commutative": "def _eval_is_commutative(self):\n    return fuzzy_and((a.is_commutative for a in self.args))",
    ".sympy.core.logic.py@@fuzzy_and": "def fuzzy_and(args):\n    rv = True\n    for ai in args:\n        ai = fuzzy_bool(ai)\n        if ai is False:\n            return False\n        if rv:\n            rv = ai\n    return rv",
    ".sympy.core.logic.py@@fuzzy_bool": "def fuzzy_bool(x):\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    ".sympy.functions.elementary.exponential.py@@log.as_base_exp": "def as_base_exp(self):\n    return (self, S.One)",
    ".sympy.core.expr.py@@Expr._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_finite": "def _eval_is_finite(self):\n    arg = self.args[0]\n    if arg.is_zero:\n        return False\n    return arg.is_finite",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_algebraic": "def _eval_is_algebraic(self):\n    s = self.func(*self.args)\n    if s.func == self.func:\n        if (self.args[0] - 1).is_zero:\n            return True\n        elif fuzzy_not((self.args[0] - 1).is_zero):\n            if self.args[0].is_algebraic:\n                return False\n    else:\n        return s.is_algebraic",
    ".sympy.core.function.py@@Application.func": "def func(self):\n    return self.__class__",
    ".sympy.core.logic.py@@fuzzy_not": "def fuzzy_not(v):\n    if v is None:\n        return v\n    else:\n        return not v",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_rational": "def _eval_is_rational(self):\n    s = self.func(*self.args)\n    if s.func == self.func:\n        if (self.args[0] - 1).is_zero:\n            return True\n        if s.args[0].is_rational and fuzzy_not((self.args[0] - 1).is_zero):\n            return False\n    else:\n        return s.is_rational",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_zero": "def _eval_is_zero(self):\n    return (self.args[0] - 1).is_zero",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    return (self.args[0] - 1).is_extended_positive",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_extended_nonnegative": "def _eval_is_extended_nonnegative(self):\n    return (self.args[0] - 1).is_extended_nonnegative",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_complex": "def _eval_is_complex(self):\n    z = self.args[0]\n    return fuzzy_and([z.is_complex, fuzzy_not(z.is_zero)])",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_extended_real": "def _eval_is_extended_real(self):\n    return self.args[0].is_extended_positive",
    ".sympy.core.mul.py@@_keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = (coeff, factors)\n        else:\n            return coeff * factors\n    if factors is S.One:\n        return coeff\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and (not sign):\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and (coeff.q != 1):\n            args = [i.as_coeff_Mul() for i in factors.args]\n            args = [(_keep_coeff(c, coeff), m) for c, m in args]\n            if any((c.is_Integer for c, _ in args)):\n                return Add._from_args([Mul._from_args(i[1:] if i[0] == 1 else i) for i in args])\n        return Mul(coeff, factors, evaluate=False)\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        m = coeff * factors\n        if m.is_Number and (not factors.is_Number):\n            m = Mul._from_args((coeff, factors))\n        return m",
    ".sympy.core.numbers.py@@Rational.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.numbers.py@@Rational.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(self.p - self.q * other.p, self.q, 1)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - self.q * other.p, self.q * other.q)\n        elif isinstance(other, Float):\n            return -other + self\n        else:\n            return Number.__sub__(self, other)\n    return Number.__sub__(self, other)",
    ".sympy.ntheory.factor_.py@@_factors": "def _factors():\n    rv = 2 + n % 2\n    while True:\n        yield rv\n        rv = nextprime(rv)",
    ".sympy.ntheory.generate.py@@primerange": "def primerange(a, b=None):\n    if b is None:\n        a, b = (2, a)\n    if a >= b:\n        return\n    if b <= sieve._list[-1]:\n        yield from sieve.primerange(a, b)\n        return\n    a = _as_int_ceiling(a) - 1\n    b = _as_int_ceiling(b)\n    while 1:\n        a = nextprime(a)\n        if a < b:\n            yield a\n        else:\n            return",
    ".sympy.ntheory.generate.py@@_as_int_ceiling": "def _as_int_ceiling(a):\n    from sympy.functions.elementary.integers import ceiling\n    return as_int(ceiling(a))",
    ".sympy.functions.elementary.integers.py@@RoundFunction.eval": "def eval(cls, arg):\n    v = cls._eval_number(arg)\n    if v is not None:\n        return v\n    if arg.is_integer or arg.is_finite is False:\n        return arg\n    if arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        i = im(arg)\n        if not i.has(S.ImaginaryUnit):\n            return cls(i) * S.ImaginaryUnit\n        return cls(arg, evaluate=False)\n    ipart = npart = spart = S.Zero\n    terms = Add.make_args(arg)\n    for t in terms:\n        if t.is_integer or (t.is_imaginary and im(t).is_integer):\n            ipart += t\n        elif t.has(Symbol):\n            spart += t\n        else:\n            npart += t\n    if not (npart or spart):\n        return ipart\n    if npart and (not spart or (npart.is_real and (spart.is_imaginary or (S.ImaginaryUnit * spart).is_real)) or (npart.is_imaginary and spart.is_real)):\n        try:\n            r, i = get_integer_part(npart, cls._dir, {}, return_ints=True)\n            ipart += Integer(r) + Integer(i) * S.ImaginaryUnit\n            npart = S.Zero\n        except (PrecisionExhausted, NotImplementedError):\n            pass\n    spart += npart\n    if not spart:\n        return ipart\n    elif spart.is_imaginary or (S.ImaginaryUnit * spart).is_real:\n        return ipart + cls(im(spart), evaluate=False) * S.ImaginaryUnit\n    elif isinstance(spart, (floor, ceiling)):\n        return ipart + spart\n    else:\n        return ipart + cls(spart, evaluate=False)",
    ".sympy.functions.elementary.integers.py@@ceiling._eval_number": "def _eval_number(cls, arg):\n    if arg.is_Number:\n        return arg.ceiling()\n    elif any((isinstance(i, j) for i in (arg, -arg) for j in (floor, ceiling))):\n        return arg\n    if arg.is_NumberSymbol:\n        return arg.approximation_interval(Integer)[1]",
    ".sympy.core.numbers.py@@Integer.ceiling": "def ceiling(self):\n    return Integer(self.p)",
    ".sympy.ntheory.generate.py@@nextprime": "def nextprime(n, ith=1):\n    n = int(n)\n    i = as_int(ith)\n    if i > 1:\n        pr = n\n        j = 1\n        while 1:\n            pr = nextprime(pr)\n            j += 1\n            if j > i:\n                break\n        return pr\n    if n < 2:\n        return 2\n    if n < 7:\n        return {2: 3, 3: 5, 4: 5, 5: 7, 6: 7}[n]\n    if n <= sieve._list[-2]:\n        l, u = sieve.search(n)\n        if l == u:\n            return sieve[u + 1]\n        else:\n            return sieve[u]\n    nn = 6 * (n // 6)\n    if nn == n:\n        n += 1\n        if isprime(n):\n            return n\n        n += 4\n    elif n - nn == 5:\n        n += 2\n        if isprime(n):\n            return n\n        n += 4\n    else:\n        n = nn + 5\n    while 1:\n        if isprime(n):\n            return n\n        n += 2\n        if isprime(n):\n            return n\n        n += 4",
    ".sympy.ntheory.generate.py@@Sieve.search": "def search(self, n):\n    test = _as_int_ceiling(n)\n    n = as_int(n)\n    if n < 2:\n        raise ValueError('n should be >= 2 but got: %s' % n)\n    if n > self._list[-1]:\n        self.extend(n)\n    b = bisect(self._list, n)\n    if self._list[b - 1] == test:\n        return (b, b)\n    else:\n        return (b, b + 1)",
    ".sympy.ntheory.generate.py@@Sieve.__getitem__": "def __getitem__(self, n):\n    if isinstance(n, slice):\n        self.extend_to_no(n.stop)\n        start = n.start if n.start is not None else 0\n        if start < 1:\n            raise IndexError('Sieve indices start at 1.')\n        return self._list[start - 1:n.stop - 1:n.step]\n    else:\n        if n < 1:\n            raise IndexError('Sieve indices start at 1.')\n        n = as_int(n)\n        self.extend_to_no(n)\n        return self._list[n - 1]",
    ".sympy.ntheory.generate.py@@Sieve.extend_to_no": "def extend_to_no(self, i):\n    i = as_int(i)\n    while len(self._list) < i:\n        self.extend(int(self._list[-1] * 1.5))",
    ".sympy.ntheory.primetest.py@@isprime": "def isprime(n):\n    try:\n        n = as_int(n)\n    except ValueError:\n        return False\n    if n in [2, 3, 5]:\n        return True\n    if n < 2 or n % 2 == 0 or n % 3 == 0 or (n % 5 == 0):\n        return False\n    if n < 49:\n        return True\n    if n % 7 == 0 or n % 11 == 0 or n % 13 == 0 or (n % 17 == 0) or (n % 19 == 0) or (n % 23 == 0) or (n % 29 == 0) or (n % 31 == 0) or (n % 37 == 0) or (n % 41 == 0) or (n % 43 == 0) or (n % 47 == 0):\n        return False\n    if n < 2809:\n        return True\n    if n <= 23001:\n        return pow(2, n, n) == 2 and n not in [7957, 8321, 13747, 18721, 19951]\n    from sympy.ntheory.generate import sieve as s\n    if n <= s._list[-1]:\n        l, u = s.search(n)\n        return l == u\n    if HAS_GMPY == 2:\n        from gmpy2 import is_strong_prp, is_strong_selfridge_prp\n        return is_strong_prp(n, 2) and is_strong_selfridge_prp(n)\n    if n < 341531:\n        return mr(n, [9345883071009581737])\n    if n < 885594169:\n        return mr(n, [725270293939359937, 3569819667048198375])\n    if n < 350269456337:\n        return mr(n, [4230279247111683200, 14694767155120705706, 16641139526367750375])\n    if n < 55245642489451:\n        return mr(n, [2, 141889084524735, 1199124725622454117, 11096072698276303650])\n    if n < 7999252175582851:\n        return mr(n, [2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805])\n    if n < 585226005592931977:\n        return mr(n, [2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375])\n    if n < 18446744073709551616:\n        return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n    return mr(n, [2]) and is_strong_lucas_prp(n)",
    ".sympy.ntheory.factor_.py@@_factorint_small": "def _factorint_small(factors, n, limit, fail_max):\n\n    def done(n, d):\n        if d * d <= n:\n            return (n, d)\n        return (n, 0)\n    d = 2\n    m = trailing(n)\n    if m:\n        factors[d] = m\n        n >>= m\n    d = 3\n    if limit < d:\n        if n > 1:\n            factors[n] = 1\n        return done(n, d)\n    m = 0\n    while n % d == 0:\n        n //= d\n        m += 1\n        if m == 20:\n            mm = multiplicity(d, n)\n            m += mm\n            n //= d ** mm\n            break\n    if m:\n        factors[d] = m\n    if limit * limit > n:\n        maxx = 0\n    else:\n        maxx = limit * limit\n    dd = maxx or n\n    d = 5\n    fails = 0\n    while fails < fail_max:\n        if d * d > dd:\n            break\n        m = 0\n        while n % d == 0:\n            n //= d\n            m += 1\n            if m == 20:\n                mm = multiplicity(d, n)\n                m += mm\n                n //= d ** mm\n                break\n        if m:\n            factors[d] = m\n            dd = maxx or n\n            fails = 0\n        else:\n            fails += 1\n        d += 2\n        if d * d > dd:\n            break\n        m = 0\n        while n % d == 0:\n            n //= d\n            m += 1\n            if m == 20:\n                mm = multiplicity(d, n)\n                m += mm\n                n //= d ** mm\n                break\n        if m:\n            factors[d] = m\n            dd = maxx or n\n            fails = 0\n        else:\n            fails += 1\n        d += 4\n    return done(n, d)",
    ".sympy.ntheory.factor_.py@@trailing": "def trailing(n):\n    n = abs(int(n))\n    if not n:\n        return 0\n    low_byte = n & 255\n    if low_byte:\n        return small_trailing[low_byte]\n    z = bitcount(n) - 1\n    if isinstance(z, SYMPY_INTS):\n        if n == 1 << z:\n            return z\n    if z < 300:\n        t = 8\n        n >>= 8\n        while not n & 255:\n            n >>= 8\n            t += 8\n        return t + small_trailing[n & 255]\n    t = 0\n    p = 8\n    while not n & 1:\n        while not n & (1 << p) - 1:\n            n >>= p\n            t += p\n            p *= 2\n        p //= 2\n    return t",
    ".sympy.ntheory.factor_.py@@done": "def done(n, d):\n    if d * d <= n:\n        return (n, d)\n    return (n, 0)",
    ".sympy.core.power.py@@Pow._eval_subs": "def _eval_subs(self, old, new):\n    from sympy.calculus.accumulationbounds import AccumBounds\n    if isinstance(self.exp, AccumBounds):\n        b = self.base.subs(old, new)\n        e = self.exp.subs(old, new)\n        if isinstance(e, AccumBounds):\n            return e.__rpow__(b)\n        return self.func(b, e)\n    from sympy.functions.elementary.exponential import exp, log\n\n    def _check(ct1, ct2, old):\n        coeff1, terms1 = ct1\n        coeff2, terms2 = ct2\n        if terms1 == terms2:\n            if old.is_commutative:\n                pow = coeff1 / coeff2\n                try:\n                    as_int(pow, strict=False)\n                    combines = True\n                except ValueError:\n                    b, e = old.as_base_exp()\n                    combines = b.is_positive and e.is_real or (b.is_nonnegative and e.is_nonnegative)\n                return (combines, pow, None)\n            else:\n                if not isinstance(terms1, tuple):\n                    terms1 = (terms1,)\n                if not all((term.is_integer for term in terms1)):\n                    return (False, None, None)\n                try:\n                    pow, remainder = divmod(as_int(coeff1), as_int(coeff2))\n                    if pow < 0 and remainder != 0:\n                        pow += 1\n                        remainder -= as_int(coeff2)\n                    if remainder == 0:\n                        remainder_pow = None\n                    else:\n                        remainder_pow = Mul(remainder, *terms1)\n                    return (True, pow, remainder_pow)\n                except ValueError:\n                    pass\n        return (False, None, None)\n    if old == self.base or (old == exp and self.base == S.Exp1):\n        if new.is_Function and isinstance(new, Callable):\n            return new(self.exp._subs(old, new))\n        else:\n            return new ** self.exp._subs(old, new)\n    if isinstance(old, self.func) and self.exp == old.exp:\n        l = log(self.base, old.base)\n        if l.is_Number:\n            return Pow(new, l)\n    if isinstance(old, self.func) and self.base == old.base:\n        if self.exp.is_Add is False:\n            ct1 = self.exp.as_independent(Symbol, as_Add=False)\n            ct2 = old.exp.as_independent(Symbol, as_Add=False)\n            ok, pow, remainder_pow = _check(ct1, ct2, old)\n            if ok:\n                result = self.func(new, pow)\n                if remainder_pow is not None:\n                    result = Mul(result, Pow(old.base, remainder_pow))\n                return result\n        else:\n            oarg = old.exp\n            new_l = []\n            o_al = []\n            ct2 = oarg.as_coeff_mul()\n            for a in self.exp.args:\n                newa = a._subs(old, new)\n                ct1 = newa.as_coeff_mul()\n                ok, pow, remainder_pow = _check(ct1, ct2, old)\n                if ok:\n                    new_l.append(new ** pow)\n                    if remainder_pow is not None:\n                        o_al.append(remainder_pow)\n                    continue\n                elif not old.is_commutative and (not newa.is_integer):\n                    return\n                o_al.append(newa)\n            if new_l:\n                expo = Add(*o_al)\n                new_l.append(Pow(self.base, expo, evaluate=False) if expo != 1 else self.base)\n                return Mul(*new_l)\n    if (isinstance(old, exp) or (old.is_Pow and old.base is S.Exp1)) and self.exp.is_extended_real and self.base.is_positive:\n        ct1 = old.exp.as_independent(Symbol, as_Add=False)\n        ct2 = (self.exp * log(self.base)).as_independent(Symbol, as_Add=False)\n        ok, pow, remainder_pow = _check(ct1, ct2, old)\n        if ok:\n            result = self.func(new, pow)\n            if remainder_pow is not None:\n                result = Mul(result, Pow(old.base, remainder_pow))\n            return result",
    ".sympy.ntheory.factor_.py@@multiplicity": "def multiplicity(p, n):\n    try:\n        p, n = (as_int(p), as_int(n))\n    except ValueError:\n        from sympy.functions.combinatorial.factorials import factorial\n        if all((isinstance(i, (SYMPY_INTS, Rational)) for i in (p, n))):\n            p = Rational(p)\n            n = Rational(n)\n            if p.q == 1:\n                if n.p == 1:\n                    return -multiplicity(p.p, n.q)\n                return multiplicity(p.p, n.p) - multiplicity(p.p, n.q)\n            elif p.p == 1:\n                return multiplicity(p.q, n.q)\n            else:\n                like = min(multiplicity(p.p, n.p), multiplicity(p.q, n.q))\n                cross = min(multiplicity(p.q, n.p), multiplicity(p.p, n.q))\n                return like - cross\n        elif isinstance(p, (SYMPY_INTS, Integer)) and isinstance(n, factorial) and isinstance(n.args[0], Integer) and (n.args[0] >= 0):\n            return multiplicity_in_factorial(p, n.args[0])\n        raise ValueError('expecting ints or fractions, got %s and %s' % (p, n))\n    if n == 0:\n        raise ValueError('no such integer exists: multiplicity of %s is not-defined' % n)\n    if p == 2:\n        return trailing(n)\n    if p < 2:\n        raise ValueError('p must be an integer, 2 or larger, but got %s' % p)\n    if p == n:\n        return 1\n    m = 0\n    n, rem = divmod(n, p)\n    while not rem:\n        m += 1\n        if m > 5:\n            e = 2\n            while 1:\n                ppow = p ** e\n                if ppow < n:\n                    nnew, rem = divmod(n, ppow)\n                    if not rem:\n                        m += e\n                        e *= 2\n                        n = nnew\n                        continue\n                return m + multiplicity(p, n)\n        n, rem = divmod(n, p)\n    return m",
    ".sympy.ntheory.factor_.py@@divisors": "def divisors(n, generator=False, proper=False):\n    n = as_int(abs(n))\n    if isprime(n):\n        if proper:\n            return [1]\n        return [1, n]\n    if n == 1:\n        if proper:\n            return []\n        return [1]\n    if n == 0:\n        return []\n    rv = _divisors(n, proper)\n    if not generator:\n        return sorted(rv)\n    return rv",
    ".sympy.ntheory.factor_.py@@_divisors": "def _divisors(n, proper=False):\n    factordict = factorint(n)\n    ps = sorted(factordict.keys())\n\n    def rec_gen(n=0):\n        if n == len(ps):\n            yield 1\n        else:\n            pows = [1]\n            for j in range(factordict[ps[n]]):\n                pows.append(pows[-1] * ps[n])\n            for q in rec_gen(n + 1):\n                for p in pows:\n                    yield (p * q)\n    if proper:\n        for p in rec_gen():\n            if p != n:\n                yield p\n    else:\n        yield from rec_gen()",
    ".sympy.ntheory.factor_.py@@rec_gen": "def rec_gen(n=0):\n    if n == len(ps):\n        yield 1\n    else:\n        pows = [1]\n        for j in range(factordict[ps[n]]):\n            pows.append(pows[-1] * ps[n])\n        for q in rec_gen(n + 1):\n            for p in pows:\n                yield (p * q)",
    ".sympy.core.mul.py@@Mul.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    if self == -self:\n        return False\n    c = self.args[0]\n    return c.is_Number and c.is_extended_negative",
    ".sympy.core.mul.py@@Mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    ".sympy.core.mul.py@@Mul.as_coeff_mul": "def as_coeff_mul(self, *deps, rational=True, **kwargs):\n    if deps:\n        l1, l2 = sift(self.args, lambda x: x.has(*deps), binary=True)\n        return (self._new_rawargs(*l2), tuple(l1))\n    args = self.args\n    if args[0].is_Number:\n        if not rational or args[0].is_Rational:\n            return (args[0], args[1:])\n        elif args[0].is_extended_negative:\n            return (S.NegativeOne, (-args[0],) + args[1:])\n    return (S.One, args)",
    ".sympy.core.mul.py@@Mul._eval_power": "def _eval_power(self, e):\n    cargs, nc = self.args_cnc(split_1=False)\n    if e.is_Integer:\n        return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * Pow(Mul._from_args(nc), e, evaluate=False)\n    if e.is_Rational and e.q == 2:\n        if self.is_imaginary:\n            a = self.as_real_imag()[1]\n            if a.is_Rational:\n                from .power import integer_nthroot\n                n, d = abs(a / 2).as_numer_denom()\n                n, t = integer_nthroot(n, 2)\n                if t:\n                    d, t = integer_nthroot(d, 2)\n                    if t:\n                        from sympy.functions.elementary.complexes import sign\n                        r = sympify(n) / d\n                        return _unevaluated_Mul(r ** e.p, (1 + sign(a) * S.ImaginaryUnit) ** e.p)\n    p = Pow(self, e, evaluate=False)\n    if e.is_Rational or e.is_Float:\n        return p._eval_expand_power_base()\n    return p",
    ".sympy.core.expr.py@@Expr.args_cnc": "def args_cnc(self, cset=False, warn=True, split_1=True):\n    if self.is_Mul:\n        args = list(self.args)\n    else:\n        args = [self]\n    for i, mi in enumerate(args):\n        if not mi.is_commutative:\n            c = args[:i]\n            nc = args[i:]\n            break\n    else:\n        c = args\n        nc = []\n    if c and split_1 and (c[0].is_Number and c[0].is_extended_negative and (c[0] is not S.NegativeOne)):\n        c[:1] = [S.NegativeOne, -c[0]]\n    if cset:\n        clen = len(c)\n        c = set(c)\n        if clen and warn and (len(c) != clen):\n            raise ValueError('repeated commutative arguments: %s' % [ci for ci in c if list(self.args).count(ci) > 1])\n    return [c, nc]",
    ".sympy.ntheory.generate.py@@Sieve.primerange": "def primerange(self, a, b=None):\n    if b is None:\n        b = _as_int_ceiling(a)\n        a = 2\n    else:\n        a = max(2, _as_int_ceiling(a))\n        b = _as_int_ceiling(b)\n    if a >= b:\n        return\n    self.extend(b)\n    i = self.search(a)[1]\n    maxi = len(self._list) + 1\n    while i < maxi:\n        p = self._list[i - 1]\n        if p < b:\n            yield p\n            i += 1\n        else:\n            return",
    ".sympy.ntheory.generate.py@@Sieve.extend": "def extend(self, n):\n    n = int(n)\n    if n <= self._list[-1]:\n        return\n    maxbase = int(n ** 0.5) + 1\n    self.extend(maxbase)\n    begin = self._list[-1] + 1\n    newsieve = _arange(begin, n + 1)\n    for p in self.primerange(maxbase):\n        startindex = -begin % p\n        for i in range(startindex, len(newsieve), p):\n            newsieve[i] = 0\n    self._list += _array('l', [x for x in newsieve if x])",
    ".sympy.ntheory.factor_.py@@_check_termination": "def _check_termination(factors, n, limitp1, use_trial, use_rho, use_pm1, verbose):\n    if verbose:\n        print('Check for termination')\n    p = perfect_power(n, factor=False)\n    if p is not False:\n        base, exp = p\n        if limitp1:\n            limit = limitp1 - 1\n        else:\n            limit = limitp1\n        facs = factorint(base, limit, use_trial, use_rho, use_pm1, verbose=False)\n        for b, e in facs.items():\n            if verbose:\n                print(factor_msg % (b, e))\n            factors[b] = exp * e\n        raise StopIteration\n    if isprime(n):\n        factors[int(n)] = 1\n        raise StopIteration\n    if n == 1:\n        raise StopIteration",
    ".sympy.ntheory.primetest.py@@mr": "def mr(n, bases):\n    from sympy.ntheory.factor_ import trailing\n    from sympy.polys.domains import ZZ\n    n = as_int(n)\n    if n < 2:\n        return False\n    s = trailing(n - 1)\n    t = n >> s\n    for base in bases:\n        if base >= n:\n            base %= n\n        if base >= 2:\n            base = ZZ(base)\n            if not _test(n, base, s, t):\n                return False\n    return True",
    ".sympy.polys.domains.domain.py@@Domain.__call__": "def __call__(self, *args):\n    return self.new(*args)",
    ".sympy.polys.domains.domain.py@@Domain.new": "def new(self, *args):\n    return self.dtype(*args)",
    ".sympy.ntheory.primetest.py@@_test": "def _test(n, base, s, t):\n    b = pow(base, t, n)\n    if b == 1 or b == n - 1:\n        return True\n    else:\n        for j in range(1, s):\n            b = pow(b, 2, n)\n            if b == n - 1:\n                return True\n            if b == 1:\n                return False\n    return False",
    ".sympy.ntheory.factor_.py@@_trial": "def _trial(factors, n, candidates, verbose=False):\n    if verbose:\n        factors0 = list(factors.keys())\n    nfactors = len(factors)\n    for d in candidates:\n        if n % d == 0:\n            m = multiplicity(d, n)\n            n //= d ** m\n            factors[d] = m\n    if verbose:\n        for k in sorted(set(factors).difference(set(factors0))):\n            print(factor_msg % (k, factors[k]))\n    return (int(n), len(factors) != nfactors)",
    ".sympy.ntheory.generate.py@@_arange": "def _arange(a, b):\n    return _array('l', range(a, b))"
}