{
    ".django.views.debug.py@@SafeExceptionReporterFilter.get_traceback_frame_variables": "def get_traceback_frame_variables(self, request, tb_frame):\n    current_frame = tb_frame.f_back\n    sensitive_variables = None\n    while current_frame is not None:\n        if current_frame.f_code.co_name == 'sensitive_variables_wrapper' and 'sensitive_variables_wrapper' in current_frame.f_locals:\n            wrapper = current_frame.f_locals['sensitive_variables_wrapper']\n            sensitive_variables = getattr(wrapper, 'sensitive_variables', None)\n            break\n        current_frame = current_frame.f_back\n    cleansed = {}\n    if self.is_active(request) and sensitive_variables:\n        if sensitive_variables == '__ALL__':\n            for name in tb_frame.f_locals:\n                cleansed[name] = self.cleansed_substitute\n        else:\n            for name, value in tb_frame.f_locals.items():\n                if name in sensitive_variables:\n                    value = self.cleansed_substitute\n                else:\n                    value = self.cleanse_special_types(request, value)\n                cleansed[name] = value\n    else:\n        for name, value in tb_frame.f_locals.items():\n            cleansed[name] = self.cleanse_special_types(request, value)\n    if tb_frame.f_code.co_name == 'sensitive_variables_wrapper' and 'sensitive_variables_wrapper' in tb_frame.f_locals:\n        cleansed['func_args'] = self.cleansed_substitute\n        cleansed['func_kwargs'] = self.cleansed_substitute\n    return cleansed.items()",
    ".django.views.debug.py@@SafeExceptionReporterFilter.is_active": "def is_active(self, request):\n    return settings.DEBUG is False",
    ".django.utils.functional.py@@LazyObject.__getattribute__": "def __getattribute__(self, name):\n    if name == '_wrapped':\n        return super().__getattribute__(name)\n    value = super().__getattribute__(name)\n    if not getattr(value, '_mask_wrapped', True):\n        raise AttributeError\n    return value",
    ".django.views.debug.py@@SafeExceptionReporterFilter.cleanse_special_types": "def cleanse_special_types(self, request, value):\n    try:\n        is_multivalue_dict = isinstance(value, MultiValueDict)\n    except Exception as e:\n        return '{!r} while evaluating {!r}'.format(e, value)\n    if is_multivalue_dict:\n        value = self.get_cleansed_multivaluedict(request, value)\n    return value",
    ".django.template.defaultfilters.py@@pprint": "def pprint(value):\n    try:\n        return pformat(value)\n    except Exception as e:\n        return 'Error in formatting: %s: %s' % (e.__class__.__name__, e)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.__repr__": "def __repr__(self):\n    return f'<{self.__class__.__qualname__} vendor={self.vendor!r} alias={self.alias!r}>'",
    ".django.views.debug.py@@SafeExceptionReporterFilter.get_safe_request_meta": "def get_safe_request_meta(self, request):\n    if not hasattr(request, 'META'):\n        return {}\n    return {k: self.cleanse_setting(k, v) for k, v in request.META.items()}",
    ".django.views.debug.py@@SafeExceptionReporterFilter.cleanse_setting": "def cleanse_setting(self, key, value):\n    if key == settings.SESSION_COOKIE_NAME:\n        is_sensitive = True\n    else:\n        try:\n            is_sensitive = self.hidden_settings.search(key)\n        except TypeError:\n            is_sensitive = False\n    if is_sensitive:\n        cleansed = self.cleansed_substitute\n    elif isinstance(value, dict):\n        cleansed = {k: self.cleanse_setting(k, v) for k, v in value.items()}\n    elif isinstance(value, list):\n        cleansed = [self.cleanse_setting('', v) for v in value]\n    elif isinstance(value, tuple):\n        cleansed = tuple([self.cleanse_setting('', v) for v in value])\n    else:\n        cleansed = value\n    if callable(cleansed):\n        cleansed = CallableSettingWrapper(cleansed)\n    return cleansed",
    ".django.conf.__init__.py@@LazySettings.__getattr__": "def __getattr__(self, name):\n    if (_wrapped := self._wrapped) is empty:\n        self._setup(name)\n        _wrapped = self._wrapped\n    val = getattr(_wrapped, name)\n    if name in {'MEDIA_URL', 'STATIC_URL'} and val is not None:\n        val = self._add_script_prefix(val)\n    elif name == 'SECRET_KEY' and (not val):\n        raise ImproperlyConfigured('The SECRET_KEY setting must not be empty.')\n    self.__dict__[name] = val\n    return val",
    ".django.utils.functional.py@@inner": "def inner(self, *args):\n    if (_wrapped := self._wrapped) is empty:\n        self._setup()\n        _wrapped = self._wrapped\n    return func(_wrapped, *args)",
    ".django.utils.functional.py@@SimpleLazyObject._setup": "def _setup(self):\n    self._wrapped = self._setupfunc()",
    ".django.utils.regex_helper.py@@_compile": "def _compile():\n    if isinstance(regex, (str, bytes)):\n        return re.compile(regex, flags)\n    else:\n        assert not flags, 'flags must be empty if regex is passed pre-compiled'\n        return regex",
    ".django.utils.functional.py@@LazyObject.__setattr__": "def __setattr__(self, name, value):\n    if name == '_wrapped':\n        self.__dict__['_wrapped'] = value\n    else:\n        if self._wrapped is empty:\n            self._setup()\n        setattr(self._wrapped, name, value)",
    ".django.views.debug.py@@SafeExceptionReporterFilter.get_safe_cookies": "def get_safe_cookies(self, request):\n    if not hasattr(request, 'COOKIES'):\n        return {}\n    return {k: self.cleanse_setting(k, v) for k, v in request.COOKIES.items()}",
    ".django.utils.functional.py@@cached_property.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    res = instance.__dict__[self.name] = self.func(instance)\n    return res",
    ".django.core.handlers.wsgi.py@@WSGIRequest.COOKIES": "def COOKIES(self):\n    raw_cookie = get_str_from_wsgi(self.environ, 'HTTP_COOKIE', '')\n    return parse_cookie(raw_cookie)",
    ".django.core.handlers.wsgi.py@@get_str_from_wsgi": "def get_str_from_wsgi(environ, key, default):\n    value = get_bytes_from_wsgi(environ, key, default)\n    return value.decode(errors='replace')",
    ".django.core.handlers.wsgi.py@@get_bytes_from_wsgi": "def get_bytes_from_wsgi(environ, key, default):\n    value = environ.get(key, default)\n    return value.encode('iso-8859-1')",
    ".django.http.cookie.py@@parse_cookie": "def parse_cookie(cookie):\n    cookiedict = {}\n    for chunk in cookie.split(';'):\n        if '=' in chunk:\n            key, val = chunk.split('=', 1)\n        else:\n            key, val = ('', chunk)\n        key, val = (key.strip(), val.strip())\n        if key or val:\n            cookiedict[key] = cookies._unquote(val)\n    return cookiedict",
    ".django.views.debug.py@@SafeExceptionReporterFilter.get_post_parameters": "def get_post_parameters(self, request):\n    if request is None:\n        return {}\n    else:\n        sensitive_post_parameters = getattr(request, 'sensitive_post_parameters', [])\n        if self.is_active(request) and sensitive_post_parameters:\n            cleansed = request.POST.copy()\n            if sensitive_post_parameters == '__ALL__':\n                for k in cleansed:\n                    cleansed[k] = self.cleansed_substitute\n                return cleansed\n            else:\n                for param in sensitive_post_parameters:\n                    if param in cleansed:\n                        cleansed[param] = self.cleansed_substitute\n                return cleansed\n        else:\n            return request.POST",
    ".django.core.handlers.wsgi.py@@WSGIRequest._get_post": "def _get_post(self):\n    if not hasattr(self, '_post'):\n        self._load_post_and_files()\n    return self._post",
    ".django.http.request.py@@HttpRequest._load_post_and_files": "def _load_post_and_files(self):\n    if self.method != 'POST':\n        self._post, self._files = (QueryDict(encoding=self._encoding), MultiValueDict())\n        return\n    if self._read_started and (not hasattr(self, '_body')):\n        self._mark_post_parse_error()\n        return\n    if self.content_type == 'multipart/form-data':\n        if hasattr(self, '_body'):\n            data = BytesIO(self._body)\n        else:\n            data = self\n        try:\n            self._post, self._files = self.parse_file_upload(self.META, data)\n        except MultiPartParserError:\n            self._mark_post_parse_error()\n            raise\n    elif self.content_type == 'application/x-www-form-urlencoded':\n        self._post, self._files = (QueryDict(self.body, encoding=self._encoding), MultiValueDict())\n    else:\n        self._post, self._files = (QueryDict(encoding=self._encoding), MultiValueDict())",
    ".django.http.request.py@@QueryDict.__init__": "def __init__(self, query_string=None, mutable=False, encoding=None):\n    super().__init__()\n    self.encoding = encoding or settings.DEFAULT_CHARSET\n    query_string = query_string or ''\n    parse_qsl_kwargs = {'keep_blank_values': True, 'encoding': self.encoding, 'max_num_fields': settings.DATA_UPLOAD_MAX_NUMBER_FIELDS}\n    if isinstance(query_string, bytes):\n        try:\n            query_string = query_string.decode(self.encoding)\n        except UnicodeDecodeError:\n            query_string = query_string.decode('iso-8859-1')\n    try:\n        for key, value in parse_qsl(query_string, **parse_qsl_kwargs):\n            self.appendlist(key, value)\n    except ValueError as e:\n        raise TooManyFieldsSent('The number of GET/POST parameters exceeded settings.DATA_UPLOAD_MAX_NUMBER_FIELDS.') from e\n    self._mutable = mutable",
    ".django.utils.datastructures.py@@MultiValueDict.__init__": "def __init__(self, key_to_list_mapping=()):\n    super().__init__(key_to_list_mapping)",
    ".django.http.request.py@@QueryDict.encoding": "def encoding(self):\n    if self._encoding is None:\n        self._encoding = settings.DEFAULT_CHARSET\n    return self._encoding",
    ".django.utils.datastructures.py@@MultiValueDict.items": "def items(self):\n    for key in self:\n        yield (key, self[key])",
    ".django.views.debug.py@@SafeExceptionReporterFilter.get_safe_settings": "def get_safe_settings(self):\n    settings_dict = {}\n    for k in dir(settings):\n        if k.isupper():\n            settings_dict[k] = self.cleanse_setting(k, getattr(settings, k))\n    return settings_dict",
    ".django.conf.__init__.py@@LazySettings._add_script_prefix": "def _add_script_prefix(value):\n    if value.startswith(('http://', 'https://', '/')):\n        return value\n    from django.urls import get_script_prefix\n    return '%s%s' % (get_script_prefix(), value)",
    ".django.urls.base.py@@get_script_prefix": "def get_script_prefix():\n    return getattr(_prefixes, 'value', '/')",
    ".django.conf.__init__.py@@LazySettings.USE_L10N": "def USE_L10N(self):\n    stack = traceback.extract_stack()\n    filename, _, _, _ = stack[-3]\n    if not filename.startswith(os.path.dirname(django.__file__)):\n        warnings.warn(USE_L10N_DEPRECATED_MSG, RemovedInDjango50Warning, stacklevel=2)\n    return self.__getattr__('USE_L10N')",
    ".django.utils.timezone.py@@now": "def now():\n    return datetime.now(tz=timezone.utc if settings.USE_TZ else None)",
    ".django.utils.version.py@@get_version": "def get_version(version=None):\n    version = get_complete_version(version)\n    main = get_main_version(version)\n    sub = ''\n    if version[3] == 'alpha' and version[4] == 0:\n        git_changeset = get_git_changeset()\n        if git_changeset:\n            sub = '.dev%s' % git_changeset\n    elif version[3] != 'final':\n        mapping = {'alpha': 'a', 'beta': 'b', 'rc': 'rc'}\n        sub = mapping[version[3]] + str(version[4])\n    return main + sub",
    ".django.utils.version.py@@get_complete_version": "def get_complete_version(version=None):\n    if version is None:\n        from django import VERSION as version\n    else:\n        assert len(version) == 5\n        assert version[3] in ('alpha', 'beta', 'rc', 'final')\n    return version",
    ".django.utils.version.py@@get_main_version": "def get_main_version(version=None):\n    version = get_complete_version(version)\n    parts = 2 if version[2] == 0 else 3\n    return '.'.join((str(x) for x in version[:parts]))",
    ".django.core.handlers.wsgi.py@@WSGIRequest.GET": "def GET(self):\n    raw_query_string = get_bytes_from_wsgi(self.environ, 'QUERY_STRING', '')\n    return QueryDict(raw_query_string, encoding=self._encoding)",
    ".django.core.handlers.wsgi.py@@WSGIRequest.FILES": "def FILES(self):\n    if not hasattr(self, '_files'):\n        self._load_post_and_files()\n    return self._files",
    ".django.http.request.py@@HttpRequest.scheme": "def scheme(self):\n    if settings.SECURE_PROXY_SSL_HEADER:\n        try:\n            header, secure_value = settings.SECURE_PROXY_SSL_HEADER\n        except ValueError:\n            raise ImproperlyConfigured('The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.')\n        header_value = self.META.get(header)\n        if header_value is not None:\n            header_value, *_ = header_value.split(',', 1)\n            return 'https' if header_value.strip() == secure_value else 'http'\n    return self._get_scheme()",
    ".django.core.handlers.wsgi.py@@WSGIRequest._get_scheme": "def _get_scheme(self):\n    return self.environ.get('wsgi.url_scheme')",
    ".django.http.request.py@@HttpRequest._get_raw_host": "def _get_raw_host(self):\n    if settings.USE_X_FORWARDED_HOST and 'HTTP_X_FORWARDED_HOST' in self.META:\n        host = self.META['HTTP_X_FORWARDED_HOST']\n    elif 'HTTP_HOST' in self.META:\n        host = self.META['HTTP_HOST']\n    else:\n        host = self.META['SERVER_NAME']\n        server_port = self.get_port()\n        if server_port != ('443' if self.is_secure() else '80'):\n            host = '%s:%s' % (host, server_port)\n    return host",
    ".django.http.request.py@@HttpRequest.get_port": "def get_port(self):\n    if settings.USE_X_FORWARDED_PORT and 'HTTP_X_FORWARDED_PORT' in self.META:\n        port = self.META['HTTP_X_FORWARDED_PORT']\n    else:\n        port = self.META['SERVER_PORT']\n    return str(port)",
    ".django.http.request.py@@HttpRequest.is_secure": "def is_secure(self):\n    return self.scheme == 'https'",
    ".django.http.request.py@@HttpRequest.get_full_path": "def get_full_path(self, force_append_slash=False):\n    return self._get_full_path(self.path, force_append_slash)",
    ".django.http.request.py@@HttpRequest._get_full_path": "def _get_full_path(self, path, force_append_slash):\n    return '%s%s%s' % (escape_uri_path(path), '/' if force_append_slash and (not path.endswith('/')) else '', '?' + iri_to_uri(self.META.get('QUERY_STRING', '')) if self.META.get('QUERY_STRING', '') else '')",
    ".django.utils.encoding.py@@escape_uri_path": "def escape_uri_path(path):\n    return quote(path, safe=\"/:@&+$,-_.!~*'()\")",
    ".django.views.debug.py@@get_caller": "def get_caller(request):\n    resolver_match = request.resolver_match\n    if resolver_match is None:\n        try:\n            resolver_match = resolve(request.path)\n        except Http404:\n            pass\n    return '' if resolver_match is None else resolver_match._func_path",
    ".django.urls.base.py@@resolve": "def resolve(path, urlconf=None):\n    if urlconf is None:\n        urlconf = get_urlconf()\n    return get_resolver(urlconf).resolve(path)",
    ".django.urls.base.py@@get_urlconf": "def get_urlconf(default=None):\n    return getattr(_urlconfs, 'value', default)",
    ".django.urls.resolvers.py@@get_resolver": "def get_resolver(urlconf=None):\n    if urlconf is None:\n        urlconf = settings.ROOT_URLCONF\n    return _get_cached_resolver(urlconf)",
    ".django.urls.resolvers.py@@_get_cached_resolver": "def _get_cached_resolver(urlconf=None):\n    return URLResolver(RegexPattern('^/'), urlconf)",
    ".django.urls.resolvers.py@@RegexPattern.__init__": "def __init__(self, regex, name=None, is_endpoint=False):\n    self._regex = regex\n    self._regex_dict = {}\n    self._is_endpoint = is_endpoint\n    self.name = name\n    self.converters = {}",
    ".django.urls.resolvers.py@@URLResolver.__init__": "def __init__(self, pattern, urlconf_name, default_kwargs=None, app_name=None, namespace=None):\n    self.pattern = pattern\n    self.urlconf_name = urlconf_name\n    self.callback = None\n    self.default_kwargs = default_kwargs or {}\n    self.namespace = namespace\n    self.app_name = app_name\n    self._reverse_dict = {}\n    self._namespace_dict = {}\n    self._app_dict = {}\n    self._callback_strs = set()\n    self._populated = False\n    self._local = Local()",
    ".django.urls.resolvers.py@@URLResolver.resolve": "def resolve(self, path):\n    path = str(path)\n    tried = []\n    match = self.pattern.match(path)\n    if match:\n        new_path, args, kwargs = match\n        for pattern in self.url_patterns:\n            try:\n                sub_match = pattern.resolve(new_path)\n            except Resolver404 as e:\n                self._extend_tried(tried, pattern, e.args[0].get('tried'))\n            else:\n                if sub_match:\n                    sub_match_dict = {**kwargs, **self.default_kwargs}\n                    sub_match_dict.update(sub_match.kwargs)\n                    sub_match_args = sub_match.args\n                    if not sub_match_dict:\n                        sub_match_args = args + sub_match.args\n                    current_route = '' if isinstance(pattern, URLPattern) else str(pattern.pattern)\n                    self._extend_tried(tried, pattern, sub_match.tried)\n                    return ResolverMatch(sub_match.func, sub_match_args, sub_match_dict, sub_match.url_name, [self.app_name] + sub_match.app_names, [self.namespace] + sub_match.namespaces, self._join_route(current_route, sub_match.route), tried, captured_kwargs=sub_match.captured_kwargs, extra_kwargs={**self.default_kwargs, **sub_match.extra_kwargs})\n                tried.append([pattern])\n        raise Resolver404({'tried': tried, 'path': new_path})\n    raise Resolver404({'path': path})",
    ".django.urls.resolvers.py@@RegexPattern.match": "def match(self, path):\n    match = self.regex.fullmatch(path) if self._is_endpoint and self.regex.pattern.endswith('$') else self.regex.search(path)\n    if match:\n        kwargs = match.groupdict()\n        args = () if kwargs else match.groups()\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        return (path[match.end():], args, kwargs)\n    return None",
    ".django.urls.resolvers.py@@LocaleRegexDescriptor.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    pattern = getattr(instance, self.attr)\n    if isinstance(pattern, str):\n        instance.__dict__['regex'] = instance._compile(pattern)\n        return instance.__dict__['regex']\n    language_code = get_language()\n    if language_code not in instance._regex_dict:\n        instance._regex_dict[language_code] = instance._compile(str(pattern))\n    return instance._regex_dict[language_code]",
    ".django.urls.resolvers.py@@RegexPattern._compile": "def _compile(self, regex):\n    try:\n        return re.compile(regex)\n    except re.error as e:\n        raise ImproperlyConfigured('\"%s\" is not a valid regular expression: %s' % (regex, e)) from e",
    ".django.urls.resolvers.py@@URLResolver.url_patterns": "def url_patterns(self):\n    patterns = getattr(self.urlconf_module, 'urlpatterns', self.urlconf_module)\n    try:\n        iter(patterns)\n    except TypeError as e:\n        msg = \"The included URLconf '{name}' does not appear to have any patterns in it. If you see the 'urlpatterns' variable with valid patterns in the file then the issue is probably caused by a circular import.\"\n        raise ImproperlyConfigured(msg.format(name=self.urlconf_name)) from e\n    return patterns",
    ".django.urls.resolvers.py@@URLResolver.urlconf_module": "def urlconf_module(self):\n    if isinstance(self.urlconf_name, str):\n        return import_module(self.urlconf_name)\n    else:\n        return self.urlconf_name",
    ".django.http.request.py@@HttpRequest.__repr__": "def __repr__(self):\n    if self.method is None or not self.get_full_path():\n        return '<%s>' % self.__class__.__name__\n    return '<%s: %s %r>' % (self.__class__.__name__, self.method, self.get_full_path())",
    ".django.utils.deprecation.py@@MiddlewareMixin.__repr__": "def __repr__(self):\n    return '<%s get_response=%s>' % (self.__class__.__qualname__, getattr(self.get_response, '__qualname__', self.get_response.__class__.__name__))",
    ".django.contrib.auth.middleware.py@@get_user": "def get_user(request):\n    if not hasattr(request, '_cached_user'):\n        request._cached_user = auth.get_user(request)\n    return request._cached_user",
    ".django.contrib.auth.__init__.py@@get_user": "def get_user(request):\n    from .models import AnonymousUser\n    user = None\n    try:\n        user_id = _get_user_session_key(request)\n        backend_path = request.session[BACKEND_SESSION_KEY]\n    except KeyError:\n        pass\n    else:\n        if backend_path in settings.AUTHENTICATION_BACKENDS:\n            backend = load_backend(backend_path)\n            user = backend.get_user(user_id)\n            if hasattr(user, 'get_session_auth_hash'):\n                session_hash = request.session.get(HASH_SESSION_KEY)\n                session_hash_verified = session_hash and constant_time_compare(session_hash, user.get_session_auth_hash())\n                if not session_hash_verified:\n                    request.session.flush()\n                    user = None\n    return user or AnonymousUser()",
    ".django.contrib.auth.__init__.py@@_get_user_session_key": "def _get_user_session_key(request):\n    return get_user_model()._meta.pk.to_python(request.session[SESSION_KEY])",
    ".django.contrib.auth.__init__.py@@get_user_model": "def get_user_model():\n    try:\n        return django_apps.get_model(settings.AUTH_USER_MODEL, require_ready=False)\n    except ValueError:\n        raise ImproperlyConfigured(\"AUTH_USER_MODEL must be of the form 'app_label.model_name'\")\n    except LookupError:\n        raise ImproperlyConfigured(\"AUTH_USER_MODEL refers to model '%s' that has not been installed\" % settings.AUTH_USER_MODEL)",
    ".django.conf.__init__.py@@UserSettingsHolder.__getattr__": "def __getattr__(self, name):\n    if not name.isupper() or name in self._deleted:\n        raise AttributeError\n    return getattr(self.default_settings, name)",
    ".django.apps.registry.py@@Apps.get_model": "def get_model(self, app_label, model_name=None, require_ready=True):\n    if require_ready:\n        self.check_models_ready()\n    else:\n        self.check_apps_ready()\n    if model_name is None:\n        app_label, model_name = app_label.split('.')\n    app_config = self.get_app_config(app_label)\n    if not require_ready and app_config.models is None:\n        app_config.import_models()\n    return app_config.get_model(model_name, require_ready=require_ready)",
    ".django.apps.registry.py@@Apps.check_apps_ready": "def check_apps_ready(self):\n    if not self.apps_ready:\n        from django.conf import settings\n        settings.INSTALLED_APPS\n        raise AppRegistryNotReady(\"Apps aren't loaded yet.\")",
    ".django.apps.registry.py@@Apps.get_app_config": "def get_app_config(self, app_label):\n    self.check_apps_ready()\n    try:\n        return self.app_configs[app_label]\n    except KeyError:\n        message = \"No installed app with label '%s'.\" % app_label\n        for app_config in self.get_app_configs():\n            if app_config.name == app_label:\n                message += \" Did you mean '%s'?\" % app_config.label\n                break\n        raise LookupError(message)",
    ".django.apps.config.py@@AppConfig.get_model": "def get_model(self, model_name, require_ready=True):\n    if require_ready:\n        self.apps.check_models_ready()\n    else:\n        self.apps.check_apps_ready()\n    try:\n        return self.models[model_name.lower()]\n    except KeyError:\n        raise LookupError(\"App '%s' doesn't have a '%s' model.\" % (self.label, model_name))",
    ".django.contrib.sessions.backends.base.py@@SessionBase.__getitem__": "def __getitem__(self, key):\n    return self._session[key]",
    ".django.contrib.sessions.backends.base.py@@SessionBase._get_session": "def _get_session(self, no_load=False):\n    self.accessed = True\n    try:\n        return self._session_cache\n    except AttributeError:\n        if self.session_key is None or no_load:\n            self._session_cache = {}\n        else:\n            self._session_cache = self.load()\n    return self._session_cache",
    ".django.contrib.sessions.backends.base.py@@SessionBase._get_session_key": "def _get_session_key(self):\n    return self.__session_key",
    ".django.contrib.auth.models.py@@AnonymousUser.__str__": "def __str__(self):\n    return 'AnonymousUser'",
    ".django.conf.__init__.py@@UserSettingsHolder.__dir__": "def __dir__(self):\n    return sorted((s for s in [*self.__dict__, *dir(self.default_settings)] if s not in self._deleted))",
    ".django.http.request.py@@HttpRequest.parse_file_upload": "def parse_file_upload(self, META, post_data):\n    self.upload_handlers = ImmutableList(self.upload_handlers, warning='You cannot alter upload handlers after the upload has been processed.')\n    parser = MultiPartParser(META, post_data, self.upload_handlers, self.encoding)\n    return parser.parse()",
    ".django.http.request.py@@HttpRequest.upload_handlers": "def upload_handlers(self):\n    if not self._upload_handlers:\n        self._initialize_handlers()\n    return self._upload_handlers",
    ".django.http.request.py@@HttpRequest._initialize_handlers": "def _initialize_handlers(self):\n    self._upload_handlers = [uploadhandler.load_handler(handler, self) for handler in settings.FILE_UPLOAD_HANDLERS]",
    ".django.core.files.uploadhandler.py@@load_handler": "def load_handler(path, *args, **kwargs):\n    return import_string(path)(*args, **kwargs)",
    ".django.utils.module_loading.py@@import_string": "def import_string(dotted_path):\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n    except ValueError as err:\n        raise ImportError(\"%s doesn't look like a module path\" % dotted_path) from err\n    try:\n        return cached_import(module_path, class_name)\n    except AttributeError as err:\n        raise ImportError('Module \"%s\" does not define a \"%s\" attribute/class' % (module_path, class_name)) from err",
    ".django.utils.module_loading.py@@cached_import": "def cached_import(module_path, class_name):\n    if not ((module := sys.modules.get(module_path)) and (spec := getattr(module, '__spec__', None)) and (getattr(spec, '_initializing', False) is False)):\n        module = import_module(module_path)\n    return getattr(module, class_name)",
    ".django.core.files.uploadhandler.py@@FileUploadHandler.__init__": "def __init__(self, request=None):\n    self.file_name = None\n    self.content_type = None\n    self.content_length = None\n    self.charset = None\n    self.content_type_extra = None\n    self.request = request",
    ".django.utils.datastructures.py@@ImmutableList.__new__": "def __new__(cls, *args, warning='ImmutableList object is immutable.', **kwargs):\n    self = tuple.__new__(cls, *args, **kwargs)\n    self.warning = warning\n    return self",
    ".django.http.request.py@@HttpRequest.encoding": "def encoding(self):\n    return self._encoding",
    ".django.http.multipartparser.py@@MultiPartParser.__init__": "def __init__(self, META, input_data, upload_handlers, encoding=None):\n    content_type = META.get('CONTENT_TYPE', '')\n    if not content_type.startswith('multipart/'):\n        raise MultiPartParserError('Invalid Content-Type: %s' % content_type)\n    try:\n        content_type.encode('ascii')\n    except UnicodeEncodeError:\n        raise MultiPartParserError('Invalid non-ASCII Content-Type in multipart: %s' % force_str(content_type))\n    _, opts = parse_header_parameters(content_type)\n    boundary = opts.get('boundary')\n    if not boundary or not self.boundary_re.fullmatch(boundary):\n        raise MultiPartParserError('Invalid boundary in multipart: %s' % force_str(boundary))\n    try:\n        content_length = int(META.get('CONTENT_LENGTH', 0))\n    except (ValueError, TypeError):\n        content_length = 0\n    if content_length < 0:\n        raise MultiPartParserError('Invalid content length: %r' % content_length)\n    self._boundary = boundary.encode('ascii')\n    self._input_data = input_data\n    possible_sizes = [x.chunk_size for x in upload_handlers if x.chunk_size]\n    self._chunk_size = min([2 ** 31 - 4] + possible_sizes)\n    self._meta = META\n    self._encoding = encoding or settings.DEFAULT_CHARSET\n    self._content_length = content_length\n    self._upload_handlers = upload_handlers",
    ".django.utils.http.py@@parse_header_parameters": "def parse_header_parameters(line):\n    parts = _parseparam(';' + line)\n    key = parts.__next__().lower()\n    pdict = {}\n    for p in parts:\n        i = p.find('=')\n        if i >= 0:\n            has_encoding = False\n            name = p[:i].strip().lower()\n            if name.endswith('*'):\n                name = name[:-1]\n                if p.count(\"'\") == 2:\n                    has_encoding = True\n            value = p[i + 1:].strip()\n            if len(value) >= 2 and value[0] == value[-1] == '\"':\n                value = value[1:-1]\n                value = value.replace('\\\\\\\\', '\\\\').replace('\\\\\"', '\"')\n            if has_encoding:\n                encoding, lang, value = value.split(\"'\")\n                value = unquote(value, encoding=encoding)\n            pdict[name] = value\n    return (key, pdict)",
    ".django.utils.http.py@@_parseparam": "def _parseparam(s):\n    while s[:1] == ';':\n        s = s[1:]\n        end = s.find(';')\n        while end > 0 and (s.count('\"', 0, end) - s.count('\\\\\"', 0, end)) % 2:\n            end = s.find(';', end + 1)\n        if end < 0:\n            end = len(s)\n        f = s[:end]\n        yield f.strip()\n        s = s[end:]",
    ".django.http.multipartparser.py@@MultiPartParser.parse": "def parse(self):\n    from django.http import QueryDict\n    encoding = self._encoding\n    handlers = self._upload_handlers\n    if self._content_length == 0:\n        return (QueryDict(encoding=self._encoding), MultiValueDict())\n    for handler in handlers:\n        result = handler.handle_raw_input(self._input_data, self._meta, self._content_length, self._boundary, encoding)\n        if result is not None:\n            return (result[0], result[1])\n    self._post = QueryDict(mutable=True)\n    self._files = MultiValueDict()\n    stream = LazyStream(ChunkIter(self._input_data, self._chunk_size))\n    old_field_name = None\n    counters = [0] * len(handlers)\n    num_bytes_read = 0\n    num_post_keys = 0\n    read_size = None\n    uploaded_file = True\n    try:\n        for item_type, meta_data, field_stream in Parser(stream, self._boundary):\n            if old_field_name:\n                self.handle_file_complete(old_field_name, counters)\n                old_field_name = None\n                uploaded_file = True\n            try:\n                disposition = meta_data['content-disposition'][1]\n                field_name = disposition['name'].strip()\n            except (KeyError, IndexError, AttributeError):\n                continue\n            transfer_encoding = meta_data.get('content-transfer-encoding')\n            if transfer_encoding is not None:\n                transfer_encoding = transfer_encoding[0].strip()\n            field_name = force_str(field_name, encoding, errors='replace')\n            if item_type == FIELD:\n                num_post_keys += 1\n                if settings.DATA_UPLOAD_MAX_NUMBER_FIELDS is not None and settings.DATA_UPLOAD_MAX_NUMBER_FIELDS < num_post_keys:\n                    raise TooManyFieldsSent('The number of GET/POST parameters exceeded settings.DATA_UPLOAD_MAX_NUMBER_FIELDS.')\n                if settings.DATA_UPLOAD_MAX_MEMORY_SIZE is not None:\n                    read_size = settings.DATA_UPLOAD_MAX_MEMORY_SIZE - num_bytes_read\n                if transfer_encoding == 'base64':\n                    raw_data = field_stream.read(size=read_size)\n                    num_bytes_read += len(raw_data)\n                    try:\n                        data = base64.b64decode(raw_data)\n                    except binascii.Error:\n                        data = raw_data\n                else:\n                    data = field_stream.read(size=read_size)\n                    num_bytes_read += len(data)\n                num_bytes_read += len(field_name) + 2\n                if settings.DATA_UPLOAD_MAX_MEMORY_SIZE is not None and num_bytes_read > settings.DATA_UPLOAD_MAX_MEMORY_SIZE:\n                    raise RequestDataTooBig('Request body exceeded settings.DATA_UPLOAD_MAX_MEMORY_SIZE.')\n                self._post.appendlist(field_name, force_str(data, encoding, errors='replace'))\n            elif item_type == FILE:\n                file_name = disposition.get('filename')\n                if file_name:\n                    file_name = force_str(file_name, encoding, errors='replace')\n                    file_name = self.sanitize_file_name(file_name)\n                if not file_name:\n                    continue\n                content_type, content_type_extra = meta_data.get('content-type', ('', {}))\n                content_type = content_type.strip()\n                charset = content_type_extra.get('charset')\n                try:\n                    content_length = int(meta_data.get('content-length')[0])\n                except (IndexError, TypeError, ValueError):\n                    content_length = None\n                counters = [0] * len(handlers)\n                uploaded_file = False\n                try:\n                    for handler in handlers:\n                        try:\n                            handler.new_file(field_name, file_name, content_type, content_length, charset, content_type_extra)\n                        except StopFutureHandlers:\n                            break\n                    for chunk in field_stream:\n                        if transfer_encoding == 'base64':\n                            stripped_chunk = b''.join(chunk.split())\n                            remaining = len(stripped_chunk) % 4\n                            while remaining != 0:\n                                over_chunk = field_stream.read(4 - remaining)\n                                if not over_chunk:\n                                    break\n                                stripped_chunk += b''.join(over_chunk.split())\n                                remaining = len(stripped_chunk) % 4\n                            try:\n                                chunk = base64.b64decode(stripped_chunk)\n                            except Exception as exc:\n                                raise MultiPartParserError('Could not decode base64 data.') from exc\n                        for i, handler in enumerate(handlers):\n                            chunk_length = len(chunk)\n                            chunk = handler.receive_data_chunk(chunk, counters[i])\n                            counters[i] += chunk_length\n                            if chunk is None:\n                                break\n                except SkipFile:\n                    self._close_files()\n                    exhaust(field_stream)\n                else:\n                    old_field_name = field_name\n            else:\n                exhaust(stream)\n    except StopUpload as e:\n        self._close_files()\n        if not e.connection_reset:\n            exhaust(self._input_data)\n    else:\n        if not uploaded_file:\n            for handler in handlers:\n                handler.upload_interrupted()\n        exhaust(self._input_data)\n    any((handler.upload_complete() for handler in handlers))\n    self._post._mutable = False\n    return (self._post, self._files)",
    ".django.core.files.uploadhandler.py@@MemoryFileUploadHandler.handle_raw_input": "def handle_raw_input(self, input_data, META, content_length, boundary, encoding=None):\n    self.activated = content_length <= settings.FILE_UPLOAD_MAX_MEMORY_SIZE",
    ".django.core.files.uploadhandler.py@@FileUploadHandler.handle_raw_input": "def handle_raw_input(self, input_data, META, content_length, boundary, encoding=None):\n    pass",
    ".django.http.multipartparser.py@@ChunkIter.__init__": "def __init__(self, flo, chunk_size=64 * 1024):\n    self.flo = flo\n    self.chunk_size = chunk_size",
    ".django.http.multipartparser.py@@LazyStream.__init__": "def __init__(self, producer, length=None):\n    self._producer = producer\n    self._empty = False\n    self._leftover = b''\n    self.length = length\n    self.position = 0\n    self._remaining = length\n    self._unget_history = []",
    ".django.http.multipartparser.py@@Parser.__init__": "def __init__(self, stream, boundary):\n    self._stream = stream\n    self._separator = b'--' + boundary",
    ".django.http.multipartparser.py@@Parser.__iter__": "def __iter__(self):\n    boundarystream = InterBoundaryIter(self._stream, self._separator)\n    for sub_stream in boundarystream:\n        yield parse_boundary_stream(sub_stream, 1024)",
    ".django.http.multipartparser.py@@InterBoundaryIter.__init__": "def __init__(self, stream, boundary):\n    self._stream = stream\n    self._boundary = boundary",
    ".django.http.multipartparser.py@@InterBoundaryIter.__iter__": "def __iter__(self):\n    return self",
    ".django.http.multipartparser.py@@InterBoundaryIter.__next__": "def __next__(self):\n    try:\n        return LazyStream(BoundaryIter(self._stream, self._boundary))\n    except InputStreamExhausted:\n        raise StopIteration()",
    ".django.http.multipartparser.py@@BoundaryIter.__init__": "def __init__(self, stream, boundary):\n    self._stream = stream\n    self._boundary = boundary\n    self._done = False\n    self._rollback = len(boundary) + 6\n    unused_char = self._stream.read(1)\n    if not unused_char:\n        raise InputStreamExhausted()\n    self._stream.unget(unused_char)",
    ".django.http.multipartparser.py@@LazyStream.read": "def read(self, size=None):\n\n    def parts():\n        remaining = self._remaining if size is None else size\n        if remaining is None:\n            yield b''.join(self)\n            return\n        while remaining != 0:\n            assert remaining > 0, 'remaining bytes to read should never go negative'\n            try:\n                chunk = next(self)\n            except StopIteration:\n                return\n            else:\n                emitting = chunk[:remaining]\n                self.unget(chunk[remaining:])\n                remaining -= len(emitting)\n                yield emitting\n    return b''.join(parts())",
    ".django.http.multipartparser.py@@LazyStream.parts": "def parts():\n    remaining = self._remaining if size is None else size\n    if remaining is None:\n        yield b''.join(self)\n        return\n    while remaining != 0:\n        assert remaining > 0, 'remaining bytes to read should never go negative'\n        try:\n            chunk = next(self)\n        except StopIteration:\n            return\n        else:\n            emitting = chunk[:remaining]\n            self.unget(chunk[remaining:])\n            remaining -= len(emitting)\n            yield emitting",
    ".django.http.multipartparser.py@@LazyStream.__next__": "def __next__(self):\n    if self._leftover:\n        output = self._leftover\n        self._leftover = b''\n    else:\n        output = next(self._producer)\n        self._unget_history = []\n    self.position += len(output)\n    return output",
    ".django.http.multipartparser.py@@ChunkIter.__next__": "def __next__(self):\n    try:\n        data = self.flo.read(self.chunk_size)\n    except InputStreamExhausted:\n        raise StopIteration()\n    if data:\n        return data\n    else:\n        raise StopIteration()",
    ".django.http.request.py@@HttpRequest.read": "def read(self, *args, **kwargs):\n    self._read_started = True\n    try:\n        return self._stream.read(*args, **kwargs)\n    except OSError as e:\n        raise UnreadablePostError(*e.args) from e",
    ".django.core.handlers.wsgi.py@@LimitedStream.read": "def read(self, size=None):\n    if size is None:\n        result = self.buffer + self._read_limited()\n        self.buffer = b''\n    elif size < len(self.buffer):\n        result = self.buffer[:size]\n        self.buffer = self.buffer[size:]\n    else:\n        result = self.buffer + self._read_limited(size - len(self.buffer))\n        self.buffer = b''\n    return result",
    ".django.core.handlers.wsgi.py@@LimitedStream._read_limited": "def _read_limited(self, size=None):\n    if size is None or size > self.remaining:\n        size = self.remaining\n    if size == 0:\n        return b''\n    result = self.stream.read(size)\n    self.remaining -= len(result)\n    return result",
    ".django.test.client.py@@FakePayload.read": "def read(self, num_bytes=None):\n    if not self.read_started:\n        self.__content.seek(0)\n        self.read_started = True\n    if num_bytes is None:\n        num_bytes = self.__len or 0\n    assert self.__len >= num_bytes, 'Cannot read more than the available bytes from the HTTP incoming data.'\n    content = self.__content.read(num_bytes)\n    self.__len -= num_bytes\n    return content",
    ".django.http.multipartparser.py@@LazyStream.unget": "def unget(self, bytes):\n    if not bytes:\n        return\n    self._update_unget_history(len(bytes))\n    self.position -= len(bytes)\n    self._leftover = bytes + self._leftover",
    ".django.http.multipartparser.py@@LazyStream._update_unget_history": "def _update_unget_history(self, num_bytes):\n    self._unget_history = [num_bytes] + self._unget_history[:49]\n    number_equal = len([current_number for current_number in self._unget_history if current_number == num_bytes])\n    if number_equal > 40:\n        raise SuspiciousMultipartForm(\"The multipart parser got stuck, which shouldn't happen with normal uploaded files. Check for malicious upload activity; if there is none, report this to the Django developers.\")",
    ".django.http.multipartparser.py@@parse_boundary_stream": "def parse_boundary_stream(stream, max_header_size):\n    chunk = stream.read(max_header_size)\n    header_end = chunk.find(b'\\r\\n\\r\\n')\n    if header_end == -1:\n        stream.unget(chunk)\n        return (RAW, {}, stream)\n    header = chunk[:header_end]\n    stream.unget(chunk[header_end + 4:])\n    TYPE = RAW\n    outdict = {}\n    for line in header.split(b'\\r\\n'):\n        try:\n            main_value_pair, params = parse_header_parameters(line.decode())\n            name, value = main_value_pair.split(':', 1)\n            params = {k: v.encode() for k, v in params.items()}\n        except ValueError:\n            continue\n        if name == 'content-disposition':\n            TYPE = FIELD\n            if params.get('filename'):\n                TYPE = FILE\n        outdict[name] = (value, params)\n    if TYPE == RAW:\n        stream.unget(chunk)\n    return (TYPE, outdict, stream)",
    ".django.http.multipartparser.py@@BoundaryIter.__next__": "def __next__(self):\n    if self._done:\n        raise StopIteration()\n    stream = self._stream\n    rollback = self._rollback\n    bytes_read = 0\n    chunks = []\n    for bytes in stream:\n        bytes_read += len(bytes)\n        chunks.append(bytes)\n        if bytes_read > rollback:\n            break\n        if not bytes:\n            break\n    else:\n        self._done = True\n    if not chunks:\n        raise StopIteration()\n    chunk = b''.join(chunks)\n    boundary = self._find_boundary(chunk)\n    if boundary:\n        end, next = boundary\n        stream.unget(chunk[next:])\n        self._done = True\n        return chunk[:end]\n    elif not chunk[:-rollback]:\n        self._done = True\n        return chunk\n    else:\n        stream.unget(chunk[-rollback:])\n        return chunk[:-rollback]",
    ".django.http.multipartparser.py@@LazyStream.__iter__": "def __iter__(self):\n    return self",
    ".django.http.multipartparser.py@@BoundaryIter._find_boundary": "def _find_boundary(self, data):\n    index = data.find(self._boundary)\n    if index < 0:\n        return None\n    else:\n        end = index\n        next = index + len(self._boundary)\n        last = max(0, end - 1)\n        if data[last:last + 1] == b'\\n':\n            end -= 1\n        last = max(0, end - 1)\n        if data[last:last + 1] == b'\\r':\n            end -= 1\n        return (end, next)",
    ".django.utils.encoding.py@@force_str": "def force_str(s, encoding='utf-8', strings_only=False, errors='strict'):\n    if issubclass(type(s), str):\n        return s\n    if strings_only and is_protected_type(s):\n        return s\n    try:\n        if isinstance(s, bytes):\n            s = str(s, encoding, errors)\n        else:\n            s = str(s)\n    except UnicodeDecodeError as e:\n        raise DjangoUnicodeDecodeError(s, *e.args)\n    return s",
    ".django.http.multipartparser.py@@MultiPartParser.sanitize_file_name": "def sanitize_file_name(self, file_name):\n    file_name = html.unescape(file_name)\n    file_name = file_name.rsplit('/')[-1]\n    file_name = file_name.rsplit('\\\\')[-1]\n    file_name = ''.join([char for char in file_name if char.isprintable()])\n    if file_name in {'', '.', '..'}:\n        return None\n    return file_name",
    ".django.core.files.uploadhandler.py@@MemoryFileUploadHandler.new_file": "def new_file(self, *args, **kwargs):\n    super().new_file(*args, **kwargs)\n    if self.activated:\n        self.file = BytesIO()\n        raise StopFutureHandlers()",
    ".django.core.files.uploadhandler.py@@FileUploadHandler.new_file": "def new_file(self, field_name, file_name, content_type, content_length, charset=None, content_type_extra=None):\n    self.field_name = field_name\n    self.file_name = file_name\n    self.content_type = content_type\n    self.content_length = content_length\n    self.charset = charset\n    self.content_type_extra = content_type_extra",
    ".django.core.files.uploadhandler.py@@MemoryFileUploadHandler.receive_data_chunk": "def receive_data_chunk(self, raw_data, start):\n    if self.activated:\n        self.file.write(raw_data)\n    else:\n        return raw_data",
    ".django.http.multipartparser.py@@MultiPartParser.handle_file_complete": "def handle_file_complete(self, old_field_name, counters):\n    for i, handler in enumerate(self._upload_handlers):\n        file_obj = handler.file_complete(counters[i])\n        if file_obj:\n            self._files.appendlist(force_str(old_field_name, self._encoding, errors='replace'), file_obj)\n            break",
    ".django.core.files.uploadhandler.py@@MemoryFileUploadHandler.file_complete": "def file_complete(self, file_size):\n    if not self.activated:\n        return\n    self.file.seek(0)\n    return InMemoryUploadedFile(file=self.file, field_name=self.field_name, name=self.file_name, content_type=self.content_type, size=file_size, charset=self.charset, content_type_extra=self.content_type_extra)",
    ".django.core.files.uploadedfile.py@@InMemoryUploadedFile.__init__": "def __init__(self, file, field_name, name, content_type, size, charset, content_type_extra=None):\n    super().__init__(file, name, content_type, size, charset, content_type_extra)\n    self.field_name = field_name",
    ".django.core.files.uploadedfile.py@@UploadedFile.__init__": "def __init__(self, file=None, name=None, content_type=None, size=None, charset=None, content_type_extra=None):\n    super().__init__(file, name)\n    self.size = size\n    self.content_type = content_type\n    self.charset = charset\n    self.content_type_extra = content_type_extra",
    ".django.core.files.base.py@@File.__init__": "def __init__(self, file, name=None):\n    self.file = file\n    if name is None:\n        name = getattr(file, 'name', None)\n    self.name = name\n    if hasattr(file, 'mode'):\n        self.mode = file.mode",
    ".django.core.files.uploadedfile.py@@UploadedFile._set_name": "def _set_name(self, name):\n    if name is not None:\n        name = os.path.basename(name)\n        if len(name) > 255:\n            name, ext = os.path.splitext(name)\n            ext = ext[:255]\n            name = name[:255 - len(ext)] + ext\n        name = validate_file_name(name)\n    self._name = name",
    ".django.core.files.utils.py@@validate_file_name": "def validate_file_name(name, allow_relative_path=False):\n    if os.path.basename(name) in {'', '.', '..'}:\n        raise SuspiciousFileOperation(\"Could not derive file name from '%s'\" % name)\n    if allow_relative_path:\n        path = pathlib.PurePosixPath(name)\n        if path.is_absolute() or '..' in path.parts:\n            raise SuspiciousFileOperation(\"Detected path traversal attempt in '%s'\" % name)\n    elif name != os.path.basename(name):\n        raise SuspiciousFileOperation(\"File name '%s' includes path elements\" % name)\n    return name",
    ".django.core.files.base.py@@File.__bool__": "def __bool__(self):\n    return bool(self.name)",
    ".django.core.files.uploadedfile.py@@UploadedFile._get_name": "def _get_name(self):\n    return self._name",
    ".django.utils.datastructures.py@@MultiValueDict.appendlist": "def appendlist(self, key, value):\n    self.setlistdefault(key).append(value)",
    ".django.utils.datastructures.py@@MultiValueDict.setlistdefault": "def setlistdefault(self, key, default_list=None):\n    if key not in self:\n        if default_list is None:\n            default_list = []\n        self.setlist(key, default_list)\n    return self._getlist(key)",
    ".django.utils.datastructures.py@@MultiValueDict.setlist": "def setlist(self, key, list_):\n    super().__setitem__(key, list_)",
    ".django.utils.datastructures.py@@MultiValueDict._getlist": "def _getlist(self, key, default=None, force_list=False):\n    try:\n        values = super().__getitem__(key)\n    except KeyError:\n        if default is None:\n            return []\n        return default\n    else:\n        if force_list:\n            values = list(values) if values is not None else None\n        return values",
    ".django.http.multipartparser.py@@exhaust": "def exhaust(stream_or_iterable):\n    try:\n        iterator = iter(stream_or_iterable)\n    except TypeError:\n        iterator = ChunkIter(stream_or_iterable, 16384)\n    collections.deque(iterator, maxlen=0)",
    ".django.http.request.py@@HttpRequest.__iter__": "def __iter__(self):\n    return iter(self.readline, b'')",
    ".django.http.request.py@@HttpRequest.readline": "def readline(self, *args, **kwargs):\n    self._read_started = True\n    try:\n        return self._stream.readline(*args, **kwargs)\n    except OSError as e:\n        raise UnreadablePostError(*e.args) from e",
    ".django.core.handlers.wsgi.py@@LimitedStream.readline": "def readline(self, size=None):\n    while b'\\n' not in self.buffer and (size is None or len(self.buffer) < size):\n        if size:\n            chunk = self._read_limited(size - len(self.buffer))\n        else:\n            chunk = self._read_limited()\n        if not chunk:\n            break\n        self.buffer += chunk\n    sio = BytesIO(self.buffer)\n    if size:\n        line = sio.readline(size)\n    else:\n        line = sio.readline()\n    self.buffer = sio.read()\n    return line",
    ".django.core.files.uploadhandler.py@@FileUploadHandler.upload_complete": "def upload_complete(self):\n    pass",
    ".django.template.base.py@@Template.__repr__": "def __repr__(self):\n    return '<%s template_string=\"%s...\">' % (self.__class__.__qualname__, self.source[:20].replace('\\n', ''))",
    ".django.template.context.py@@BaseContext.__repr__": "def __repr__(self):\n    return repr(self.dicts)",
    ".django.template.loader_tags.py@@ExtendsNode.__repr__": "def __repr__(self):\n    return '<%s: extends %s>' % (self.__class__.__name__, self.parent_name.token)",
    ".django.template.base.py@@Origin.__repr__": "def __repr__(self):\n    return '<%s name=%r>' % (self.__class__.__qualname__, self.name)",
    ".django.template.engine.py@@Engine.__repr__": "def __repr__(self):\n    return '<%s:%s app_dirs=%s%s debug=%s loaders=%s string_if_invalid=%s file_charset=%s%s%s autoescape=%s>' % (self.__class__.__qualname__, '' if not self.dirs else ' dirs=%s' % repr(self.dirs), self.app_dirs, '' if not self.context_processors else ' context_processors=%s' % repr(self.context_processors), self.debug, repr(self.loaders), repr(self.string_if_invalid), repr(self.file_charset), '' if not self.libraries else ' libraries=%s' % repr(self.libraries), '' if not self.builtins else ' builtins=%s' % repr(self.builtins), repr(self.autoescape))",
    ".django.utils.safestring.py@@SafeString.__str__": "def __str__(self):\n    return self",
    ".django.template.base.py@@TextNode.__repr__": "def __repr__(self):\n    return '<%s: %r>' % (self.__class__.__name__, self.s[:25])",
    ".django.views.debug.py@@CallableSettingWrapper.__init__": "def __init__(self, callable_setting):\n    self._wrapped = callable_setting",
    ".django.contrib.sessions.backends.db.py@@SessionStore.load": "def load(self):\n    s = self._get_session_from_db()\n    return self.decode(s.session_data) if s else {}",
    ".django.contrib.sessions.backends.db.py@@SessionStore._get_session_from_db": "def _get_session_from_db(self):\n    try:\n        return self.model.objects.get(session_key=self.session_key, expire_date__gt=timezone.now())\n    except (self.model.DoesNotExist, SuspiciousOperation) as e:\n        if isinstance(e, SuspiciousOperation):\n            logger = logging.getLogger('django.security.%s' % e.__class__.__name__)\n            logger.warning(str(e))\n        self._session_key = None",
    ".django.contrib.sessions.backends.db.py@@SessionStore.model": "def model(self):\n    return self.get_model_class()",
    ".django.contrib.sessions.backends.db.py@@SessionStore.get_model_class": "def get_model_class(cls):\n    from django.contrib.sessions.models import Session\n    return Session",
    ".django.db.models.manager.py@@ManagerDescriptor.__get__": "def __get__(self, instance, cls=None):\n    if instance is not None:\n        raise AttributeError(\"Manager isn't accessible via %s instances\" % cls.__name__)\n    if cls._meta.abstract:\n        raise AttributeError(\"Manager isn't available; %s is abstract\" % (cls._meta.object_name,))\n    if cls._meta.swapped:\n        raise AttributeError(\"Manager isn't available; '%s' has been swapped for '%s'\" % (cls._meta.label, cls._meta.swapped))\n    return cls._meta.managers_map[self.manager.name]",
    ".django.db.models.options.py@@Options.swapped": "def swapped(self):\n    if self.swappable:\n        swapped_for = getattr(settings, self.swappable, None)\n        if swapped_for:\n            try:\n                swapped_label, swapped_object = swapped_for.split('.')\n            except ValueError:\n                return swapped_for\n            if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:\n                return swapped_for\n    return None",
    ".django.db.models.options.py@@Options.managers_map": "def managers_map(self):\n    return {manager.name: manager for manager in self.managers}",
    ".django.db.models.manager.py@@BaseManager.manager_method": "def manager_method(self, *args, **kwargs):\n    return getattr(self.get_queryset(), name)(*args, **kwargs)",
    ".django.db.models.manager.py@@BaseManager.get_queryset": "def get_queryset(self):\n    return self._queryset_class(model=self.model, using=self._db, hints=self._hints)",
    ".django.db.models.query.py@@QuerySet.__init__": "def __init__(self, model=None, query=None, using=None, hints=None):\n    self.model = model\n    self._db = using\n    self._hints = hints or {}\n    self._query = query or sql.Query(self.model)\n    self._result_cache = None\n    self._sticky_filter = False\n    self._for_write = False\n    self._prefetch_related_lookups = ()\n    self._prefetch_done = False\n    self._known_related_objects = {}\n    self._iterable_class = ModelIterable\n    self._fields = None\n    self._defer_next_filter = False\n    self._deferred_filter = None",
    ".django.db.models.sql.query.py@@Query.__init__": "def __init__(self, model, alias_cols=True):\n    self.model = model\n    self.alias_refcount = {}\n    self.alias_map = {}\n    self.alias_cols = alias_cols\n    self.external_aliases = {}\n    self.table_map = {}\n    self.used_aliases = set()\n    self.where = WhereNode()\n    self.annotations = {}\n    self.extra = {}\n    self._filtered_relations = {}",
    ".django.utils.tree.py@@Node.__init__": "def __init__(self, children=None, connector=None, negated=False):\n    self.children = children[:] if children else []\n    self.connector = connector or self.default\n    self.negated = negated",
    ".django.db.models.query.py@@QuerySet.get": "def get(self, *args, **kwargs):\n    if self.query.combinator and (args or kwargs):\n        raise NotSupportedError('Calling QuerySet.get(...) with filters after %s() is not supported.' % self.query.combinator)\n    clone = self._chain() if self.query.combinator else self.filter(*args, **kwargs)\n    if self.query.can_filter() and (not self.query.distinct_fields):\n        clone = clone.order_by()\n    limit = None\n    if not clone.query.select_for_update or connections[clone.db].features.supports_select_for_update_with_limit:\n        limit = MAX_GET_RESULTS\n        clone.query.set_limits(high=limit)\n    num = len(clone)\n    if num == 1:\n        return clone._result_cache[0]\n    if not num:\n        raise self.model.DoesNotExist('%s matching query does not exist.' % self.model._meta.object_name)\n    raise self.model.MultipleObjectsReturned('get() returned more than one %s -- it returned %s!' % (self.model._meta.object_name, num if not limit or num < limit else 'more than %s' % (limit - 1)))",
    ".django.db.models.query.py@@QuerySet.query": "def query(self):\n    if self._deferred_filter:\n        negate, args, kwargs = self._deferred_filter\n        self._filter_or_exclude_inplace(negate, args, kwargs)\n        self._deferred_filter = None\n    return self._query",
    ".django.db.models.query.py@@QuerySet.filter": "def filter(self, *args, **kwargs):\n    self._not_support_combined_queries('filter')\n    return self._filter_or_exclude(False, args, kwargs)",
    ".django.db.models.query.py@@QuerySet._not_support_combined_queries": "def _not_support_combined_queries(self, operation_name):\n    if self.query.combinator:\n        raise NotSupportedError('Calling QuerySet.%s() after %s() is not supported.' % (operation_name, self.query.combinator))",
    ".django.db.models.query.py@@QuerySet._filter_or_exclude": "def _filter_or_exclude(self, negate, args, kwargs):\n    if (args or kwargs) and self.query.is_sliced:\n        raise TypeError('Cannot filter a query once a slice has been taken.')\n    clone = self._chain()\n    if self._defer_next_filter:\n        self._defer_next_filter = False\n        clone._deferred_filter = (negate, args, kwargs)\n    else:\n        clone._filter_or_exclude_inplace(negate, args, kwargs)\n    return clone",
    ".django.db.models.sql.query.py@@Query.is_sliced": "def is_sliced(self):\n    return self.low_mark != 0 or self.high_mark is not None",
    ".django.db.models.query.py@@QuerySet._chain": "def _chain(self):\n    obj = self._clone()\n    if obj._sticky_filter:\n        obj.query.filter_is_sticky = True\n        obj._sticky_filter = False\n    return obj",
    ".django.db.models.query.py@@QuerySet._clone": "def _clone(self):\n    c = self.__class__(model=self.model, query=self.query.chain(), using=self._db, hints=self._hints)\n    c._sticky_filter = self._sticky_filter\n    c._for_write = self._for_write\n    c._prefetch_related_lookups = self._prefetch_related_lookups[:]\n    c._known_related_objects = self._known_related_objects\n    c._iterable_class = self._iterable_class\n    c._fields = self._fields\n    return c",
    ".django.db.models.sql.query.py@@Query.chain": "def chain(self, klass=None):\n    obj = self.clone()\n    if klass and obj.__class__ != klass:\n        obj.__class__ = klass\n    if not obj.filter_is_sticky:\n        obj.used_aliases = set()\n    obj.filter_is_sticky = False\n    if hasattr(obj, '_setup_query'):\n        obj._setup_query()\n    return obj",
    ".django.db.models.sql.query.py@@Query.clone": "def clone(self):\n    obj = Empty()\n    obj.__class__ = self.__class__\n    obj.__dict__ = self.__dict__.copy()\n    obj.alias_refcount = self.alias_refcount.copy()\n    obj.alias_map = self.alias_map.copy()\n    obj.external_aliases = self.external_aliases.copy()\n    obj.table_map = self.table_map.copy()\n    obj.where = self.where.clone()\n    obj.annotations = self.annotations.copy()\n    if self.annotation_select_mask is not None:\n        obj.annotation_select_mask = self.annotation_select_mask.copy()\n    if self.combined_queries:\n        obj.combined_queries = tuple([query.clone() for query in self.combined_queries])\n    obj._annotation_select_cache = None\n    obj.extra = self.extra.copy()\n    if self.extra_select_mask is not None:\n        obj.extra_select_mask = self.extra_select_mask.copy()\n    if self._extra_select_cache is not None:\n        obj._extra_select_cache = self._extra_select_cache.copy()\n    if self.select_related is not False:\n        obj.select_related = copy.deepcopy(obj.select_related)\n    if 'subq_aliases' in self.__dict__:\n        obj.subq_aliases = self.subq_aliases.copy()\n    obj.used_aliases = self.used_aliases.copy()\n    obj._filtered_relations = self._filtered_relations.copy()\n    obj.__dict__.pop('base_table', None)\n    return obj",
    ".django.db.models.sql.where.py@@WhereNode.clone": "def clone(self):\n    clone = self.create(connector=self.connector, negated=self.negated)\n    for child in self.children:\n        if hasattr(child, 'clone'):\n            child = child.clone()\n        clone.children.append(child)\n    return clone",
    ".django.utils.tree.py@@Node.create": "def create(cls, children=None, connector=None, negated=False):\n    obj = Node(children, connector or cls.default, negated)\n    obj.__class__ = cls\n    return obj",
    ".django.db.models.query.py@@QuerySet._filter_or_exclude_inplace": "def _filter_or_exclude_inplace(self, negate, args, kwargs):\n    if negate:\n        self._query.add_q(~Q(*args, **kwargs))\n    else:\n        self._query.add_q(Q(*args, **kwargs))",
    ".django.db.models.query_utils.py@@Q.__init__": "def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n    super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)",
    ".django.db.models.sql.query.py@@Query.add_q": "def add_q(self, q_object):\n    existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}\n    clause, _ = self._add_q(q_object, self.used_aliases)\n    if clause:\n        self.where.add(clause, AND)\n    self.demote_joins(existing_inner)",
    ".django.db.models.sql.query.py@@Query._add_q": "def _add_q(self, q_object, used_aliases, branch_negated=False, current_negated=False, allow_joins=True, split_subq=True, check_filterable=True):\n    connector = q_object.connector\n    current_negated = current_negated ^ q_object.negated\n    branch_negated = branch_negated or q_object.negated\n    target_clause = WhereNode(connector=connector, negated=q_object.negated)\n    joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)\n    for child in q_object.children:\n        child_clause, needed_inner = self.build_filter(child, can_reuse=used_aliases, branch_negated=branch_negated, current_negated=current_negated, allow_joins=allow_joins, split_subq=split_subq, check_filterable=check_filterable)\n        joinpromoter.add_votes(needed_inner)\n        if child_clause:\n            target_clause.add(child_clause, connector)\n    needed_inner = joinpromoter.update_join_types(self)\n    return (target_clause, needed_inner)",
    ".django.db.models.sql.query.py@@JoinPromoter.__init__": "def __init__(self, connector, num_children, negated):\n    self.connector = connector\n    self.negated = negated\n    if self.negated:\n        if connector == AND:\n            self.effective_connector = OR\n        else:\n            self.effective_connector = AND\n    else:\n        self.effective_connector = self.connector\n    self.num_children = num_children\n    self.votes = Counter()",
    ".django.db.models.sql.query.py@@Query.build_filter": "def build_filter(self, filter_expr, branch_negated=False, current_negated=False, can_reuse=None, allow_joins=True, split_subq=True, reuse_with_filtered_relation=False, check_filterable=True):\n    if isinstance(filter_expr, dict):\n        raise FieldError('Cannot parse keyword query as dict')\n    if isinstance(filter_expr, Q):\n        return self._add_q(filter_expr, branch_negated=branch_negated, current_negated=current_negated, used_aliases=can_reuse, allow_joins=allow_joins, split_subq=split_subq, check_filterable=check_filterable)\n    if hasattr(filter_expr, 'resolve_expression'):\n        if not getattr(filter_expr, 'conditional', False):\n            raise TypeError('Cannot filter against a non-conditional expression.')\n        condition = filter_expr.resolve_expression(self, allow_joins=allow_joins)\n        if not isinstance(condition, Lookup):\n            condition = self.build_lookup(['exact'], condition, True)\n        return (WhereNode([condition], connector=AND), [])\n    arg, value = filter_expr\n    if not arg:\n        raise FieldError('Cannot parse keyword query %r' % arg)\n    lookups, parts, reffed_expression = self.solve_lookup_type(arg)\n    if check_filterable:\n        self.check_filterable(reffed_expression)\n    if not allow_joins and len(parts) > 1:\n        raise FieldError('Joined field references are not permitted in this query')\n    pre_joins = self.alias_refcount.copy()\n    value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n    used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n    if check_filterable:\n        self.check_filterable(value)\n    if reffed_expression:\n        condition = self.build_lookup(lookups, reffed_expression, value)\n        return (WhereNode([condition], connector=AND), [])\n    opts = self.get_meta()\n    alias = self.get_initial_alias()\n    allow_many = not branch_negated or not split_subq\n    try:\n        join_info = self.setup_joins(parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many, reuse_with_filtered_relation=reuse_with_filtered_relation)\n        if isinstance(value, Iterator):\n            value = list(value)\n        self.check_related_objects(join_info.final_field, value, join_info.opts)\n        self._lookup_joins = join_info.joins\n    except MultiJoin as e:\n        return self.split_exclude(filter_expr, can_reuse, e.names_with_path)\n    used_joins.update(join_info.joins)\n    targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)\n    if can_reuse is not None:\n        can_reuse.update(join_list)\n    if join_info.final_field.is_relation:\n        if len(targets) == 1:\n            col = self._get_col(targets[0], join_info.final_field, alias)\n        else:\n            col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)\n    else:\n        col = self._get_col(targets[0], join_info.final_field, alias)\n    condition = self.build_lookup(lookups, col, value)\n    lookup_type = condition.lookup_name\n    clause = WhereNode([condition], connector=AND)\n    require_outer = lookup_type == 'isnull' and condition.rhs is True and (not current_negated)\n    if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and (condition.rhs is not None):\n        require_outer = True\n        if lookup_type != 'isnull':\n            if self.is_nullable(targets[0]) or self.alias_map[join_list[-1]].join_type == LOUTER:\n                lookup_class = targets[0].get_lookup('isnull')\n                col = self._get_col(targets[0], join_info.targets[0], alias)\n                clause.add(lookup_class(col, False), AND)\n            if isinstance(value, Col) and self.is_nullable(value.target):\n                lookup_class = value.target.get_lookup('isnull')\n                clause.add(lookup_class(value, False), AND)\n    return (clause, used_joins if not require_outer else ())",
    ".django.db.models.sql.query.py@@Query.solve_lookup_type": "def solve_lookup_type(self, lookup):\n    lookup_splitted = lookup.split(LOOKUP_SEP)\n    if self.annotations:\n        expression, expression_lookups = refs_expression(lookup_splitted, self.annotations)\n        if expression:\n            return (expression_lookups, (), expression)\n    _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())\n    field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]\n    if len(lookup_parts) > 1 and (not field_parts):\n        raise FieldError('Invalid lookup \"%s\" for model %s\".' % (lookup, self.get_meta().model.__name__))\n    return (lookup_parts, field_parts, False)",
    ".django.db.models.sql.query.py@@Query.get_meta": "def get_meta(self):\n    if self.model:\n        return self.model._meta",
    ".django.db.models.sql.query.py@@Query.names_to_path": "def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n    path, names_with_path = ([], [])\n    for pos, name in enumerate(names):\n        cur_names_with_path = (name, [])\n        if name == 'pk':\n            name = opts.pk.name\n        field = None\n        filtered_relation = None\n        try:\n            if opts is None:\n                raise FieldDoesNotExist\n            field = opts.get_field(name)\n        except FieldDoesNotExist:\n            if name in self.annotation_select:\n                field = self.annotation_select[name].output_field\n            elif name in self._filtered_relations and pos == 0:\n                filtered_relation = self._filtered_relations[name]\n                if LOOKUP_SEP in filtered_relation.relation_name:\n                    parts = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    filtered_relation_path, field, _, _ = self.names_to_path(parts, opts, allow_many, fail_on_missing)\n                    path.extend(filtered_relation_path[:-1])\n                else:\n                    field = opts.get_field(filtered_relation.relation_name)\n        if field is not None:\n            if field.is_relation and (not field.related_model):\n                raise FieldError('Field %r does not generate an automatic reverse relation and therefore cannot be used for reverse querying. If it is a GenericForeignKey, consider adding a GenericRelation.' % name)\n            try:\n                model = field.model._meta.concrete_model\n            except AttributeError:\n                model = None\n        else:\n            pos -= 1\n            if pos == -1 or fail_on_missing:\n                available = sorted([*get_field_names_from_opts(opts), *self.annotation_select, *self._filtered_relations])\n                raise FieldError(\"Cannot resolve keyword '%s' into field. Choices are: %s\" % (name, ', '.join(available)))\n            break\n        if opts is not None and model is not opts.model:\n            path_to_parent = opts.get_path_to_parent(model)\n            if path_to_parent:\n                path.extend(path_to_parent)\n                cur_names_with_path[1].extend(path_to_parent)\n                opts = path_to_parent[-1].to_opts\n        if hasattr(field, 'path_infos'):\n            if filtered_relation:\n                pathinfos = field.get_path_info(filtered_relation)\n            else:\n                pathinfos = field.path_infos\n            if not allow_many:\n                for inner_pos, p in enumerate(pathinfos):\n                    if p.m2m:\n                        cur_names_with_path[1].extend(pathinfos[0:inner_pos + 1])\n                        names_with_path.append(cur_names_with_path)\n                        raise MultiJoin(pos + 1, names_with_path)\n            last = pathinfos[-1]\n            path.extend(pathinfos)\n            final_field = last.join_field\n            opts = last.to_opts\n            targets = last.target_fields\n            cur_names_with_path[1].extend(pathinfos)\n            names_with_path.append(cur_names_with_path)\n        else:\n            final_field = field\n            targets = (field,)\n            if fail_on_missing and pos + 1 != len(names):\n                raise FieldError(\"Cannot resolve keyword %r into field. Join on '%s' not permitted.\" % (names[pos + 1], name))\n            break\n    return (path, final_field, targets, names[pos + 1:])",
    ".django.db.models.options.py@@Options.get_field": "def get_field(self, field_name):\n    try:\n        return self._forward_fields_map[field_name]\n    except KeyError:\n        if not self.apps.models_ready:\n            raise FieldDoesNotExist(\"%s has no field named '%s'. The app cache isn't ready yet, so if this is an auto-created related field, it won't be available yet.\" % (self.object_name, field_name))\n    try:\n        return self.fields_map[field_name]\n    except KeyError:\n        raise FieldDoesNotExist(\"%s has no field named '%s'\" % (self.object_name, field_name))",
    ".django.db.models.options.py@@Options._forward_fields_map": "def _forward_fields_map(self):\n    res = {}\n    fields = self._get_fields(reverse=False)\n    for field in fields:\n        res[field.name] = field\n        try:\n            res[field.attname] = field\n        except AttributeError:\n            pass\n    return res",
    ".django.db.models.options.py@@Options._get_fields": "def _get_fields(self, forward=True, reverse=True, include_parents=True, include_hidden=False, seen_models=None):\n    if include_parents not in (True, False, PROXY_PARENTS):\n        raise TypeError('Invalid argument for include_parents: %s' % (include_parents,))\n    topmost_call = seen_models is None\n    if topmost_call:\n        seen_models = set()\n    seen_models.add(self.model)\n    cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)\n    try:\n        return self._get_fields_cache[cache_key]\n    except KeyError:\n        pass\n    fields = []\n    if include_parents is not False:\n        for parent in self.parents:\n            if parent in seen_models:\n                continue\n            if parent._meta.concrete_model != self.concrete_model and include_parents == PROXY_PARENTS:\n                continue\n            for obj in parent._meta._get_fields(forward=forward, reverse=reverse, include_parents=include_parents, include_hidden=include_hidden, seen_models=seen_models):\n                if not getattr(obj, 'parent_link', False) or obj.model == self.concrete_model:\n                    fields.append(obj)\n    if reverse and (not self.proxy):\n        all_fields = self._relation_tree\n        for field in all_fields:\n            if include_hidden or not field.remote_field.hidden:\n                fields.append(field.remote_field)\n    if forward:\n        fields += self.local_fields\n        fields += self.local_many_to_many\n        if topmost_call:\n            fields += self.private_fields\n    fields = make_immutable_fields_list('get_fields()', fields)\n    self._get_fields_cache[cache_key] = fields\n    return fields",
    ".django.db.models.sql.query.py@@Query.check_filterable": "def check_filterable(self, expression):\n    if hasattr(expression, 'resolve_expression') and (not getattr(expression, 'filterable', True)):\n        raise NotSupportedError(expression.__class__.__name__ + ' is disallowed in the filter clause.')\n    if hasattr(expression, 'get_source_expressions'):\n        for expr in expression.get_source_expressions():\n            self.check_filterable(expr)",
    ".django.db.models.sql.query.py@@Query.resolve_lookup_value": "def resolve_lookup_value(self, value, can_reuse, allow_joins):\n    if hasattr(value, 'resolve_expression'):\n        value = value.resolve_expression(self, reuse=can_reuse, allow_joins=allow_joins)\n    elif isinstance(value, (list, tuple)):\n        values = (self.resolve_lookup_value(sub_value, can_reuse, allow_joins) for sub_value in value)\n        type_ = type(value)\n        if hasattr(type_, '_make'):\n            return type_(*values)\n        return type_(values)\n    return value",
    ".django.db.models.sql.query.py@@Query.get_initial_alias": "def get_initial_alias(self):\n    if self.alias_map:\n        alias = self.base_table\n        self.ref_alias(alias)\n    elif self.model:\n        alias = self.join(self.base_table_class(self.get_meta().db_table, None))\n    else:\n        alias = None\n    return alias",
    ".django.db.models.sql.datastructures.py@@BaseTable.__init__": "def __init__(self, table_name, alias):\n    self.table_name = table_name\n    self.table_alias = alias",
    ".django.db.models.sql.query.py@@Query.join": "def join(self, join, reuse=None, reuse_with_filtered_relation=False):\n    if reuse_with_filtered_relation and reuse:\n        reuse_aliases = [a for a, j in self.alias_map.items() if a in reuse and j.equals(join)]\n    else:\n        reuse_aliases = [a for a, j in self.alias_map.items() if (reuse is None or a in reuse) and j == join]\n    if reuse_aliases:\n        if join.table_alias in reuse_aliases:\n            reuse_alias = join.table_alias\n        else:\n            reuse_alias = reuse_aliases[-1]\n        self.ref_alias(reuse_alias)\n        return reuse_alias\n    alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)\n    if join.join_type:\n        if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n            join_type = LOUTER\n        else:\n            join_type = INNER\n        join.join_type = join_type\n    join.table_alias = alias\n    self.alias_map[alias] = join\n    return alias",
    ".django.db.models.sql.query.py@@Query.table_alias": "def table_alias(self, table_name, create=False, filtered_relation=None):\n    alias_list = self.table_map.get(table_name)\n    if not create and alias_list:\n        alias = alias_list[0]\n        self.alias_refcount[alias] += 1\n        return (alias, False)\n    if alias_list:\n        alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)\n        alias_list.append(alias)\n    else:\n        alias = filtered_relation.alias if filtered_relation is not None else table_name\n        self.table_map[table_name] = [alias]\n    self.alias_refcount[alias] = 1\n    return (alias, True)",
    ".django.db.models.sql.query.py@@Query.setup_joins": "def setup_joins(self, names, opts, alias, can_reuse=None, allow_many=True, reuse_with_filtered_relation=False):\n    joins = [alias]\n\n    def final_transformer(field, alias):\n        if not self.alias_cols:\n            alias = None\n        return field.get_col(alias)\n    last_field_exception = None\n    for pivot in range(len(names), 0, -1):\n        try:\n            path, final_field, targets, rest = self.names_to_path(names[:pivot], opts, allow_many, fail_on_missing=True)\n        except FieldError as exc:\n            if pivot == 1:\n                raise\n            else:\n                last_field_exception = exc\n        else:\n            transforms = names[pivot:]\n            break\n    for name in transforms:\n\n        def transform(field, alias, *, name, previous):\n            try:\n                wrapped = previous(field, alias)\n                return self.try_transform(wrapped, name)\n            except FieldError:\n                if isinstance(final_field, Field) and last_field_exception:\n                    raise last_field_exception\n                else:\n                    raise\n        final_transformer = functools.partial(transform, name=name, previous=final_transformer)\n        final_transformer.has_transforms = True\n    for join in path:\n        if join.filtered_relation:\n            filtered_relation = join.filtered_relation.clone()\n            table_alias = filtered_relation.alias\n        else:\n            filtered_relation = None\n            table_alias = None\n        opts = join.to_opts\n        if join.direct:\n            nullable = self.is_nullable(join.join_field)\n        else:\n            nullable = True\n        connection = self.join_class(opts.db_table, alias, table_alias, INNER, join.join_field, nullable, filtered_relation=filtered_relation)\n        reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None\n        alias = self.join(connection, reuse=reuse, reuse_with_filtered_relation=reuse_with_filtered_relation)\n        joins.append(alias)\n        if filtered_relation:\n            filtered_relation.path = joins[:]\n    return JoinInfo(final_field, targets, opts, joins, path, final_transformer)",
    ".django.db.models.sql.query.py@@Query.check_related_objects": "def check_related_objects(self, field, value, opts):\n    if field.is_relation:\n        if isinstance(value, Query) and (not value.has_select_fields) and (not check_rel_lookup_compatibility(value.model, opts, field)):\n            raise ValueError('Cannot use QuerySet for \"%s\": Use a QuerySet for \"%s\".' % (value.model._meta.object_name, opts.object_name))\n        elif hasattr(value, '_meta'):\n            self.check_query_object_type(value, opts, field)\n        elif hasattr(value, '__iter__'):\n            for v in value:\n                self.check_query_object_type(v, opts, field)",
    ".django.db.models.sql.query.py@@Query.trim_joins": "def trim_joins(self, targets, joins, path):\n    joins = joins[:]\n    for pos, info in enumerate(reversed(path)):\n        if len(joins) == 1 or not info.direct:\n            break\n        if info.filtered_relation:\n            break\n        join_targets = {t.column for t in info.join_field.foreign_related_fields}\n        cur_targets = {t.column for t in targets}\n        if not cur_targets.issubset(join_targets):\n            break\n        targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}\n        targets = tuple((targets_dict[t.column] for t in targets))\n        self.unref_alias(joins.pop())\n    return (targets, joins[-1], joins)",
    ".django.db.models.sql.query.py@@Query._get_col": "def _get_col(self, target, field, alias):\n    if not self.alias_cols:\n        alias = None\n    return target.get_col(alias, field)",
    ".django.db.models.fields.__init__.py@@Field.get_col": "def get_col(self, alias, output_field=None):\n    if alias == self.model._meta.db_table and (output_field is None or output_field == self):\n        return self.cached_col\n    from django.db.models.expressions import Col\n    return Col(alias, self, output_field)",
    ".django.db.models.fields.__init__.py@@Field.__eq__": "def __eq__(self, other):\n    if isinstance(other, Field):\n        return self.creation_counter == other.creation_counter and getattr(self, 'model', None) == getattr(other, 'model', None)\n    return NotImplemented",
    ".django.db.models.fields.__init__.py@@Field.cached_col": "def cached_col(self):\n    from django.db.models.expressions import Col\n    return Col(self.model._meta.db_table, self)",
    ".django.utils.deconstruct.py@@__new__": "def __new__(cls, *args, **kwargs):\n    obj = super(klass, cls).__new__(cls)\n    obj._constructor_args = (args, kwargs)\n    return obj",
    ".django.db.models.expressions.py@@Col.__init__": "def __init__(self, alias, target, output_field=None):\n    if output_field is None:\n        output_field = target\n    super().__init__(output_field=output_field)\n    self.alias, self.target = (alias, target)",
    ".django.db.models.expressions.py@@BaseExpression.__init__": "def __init__(self, output_field=None):\n    if output_field is not None:\n        self.output_field = output_field",
    ".django.db.models.sql.query.py@@Query.build_lookup": "def build_lookup(self, lookups, lhs, rhs):\n    *transforms, lookup_name = lookups or ['exact']\n    for name in transforms:\n        lhs = self.try_transform(lhs, name)\n    lookup_class = lhs.get_lookup(lookup_name)\n    if not lookup_class:\n        lhs = self.try_transform(lhs, lookup_name)\n        lookup_name = 'exact'\n        lookup_class = lhs.get_lookup(lookup_name)\n        if not lookup_class:\n            return\n    lookup = lookup_class(lhs, rhs)\n    if lookup.rhs is None and (not lookup.can_use_none_as_rhs):\n        if lookup_name not in ('exact', 'iexact'):\n            raise ValueError('Cannot use None as a query value')\n        return lhs.get_lookup('isnull')(lhs, True)\n    if lookup_name == 'exact' and lookup.rhs == '' and connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls:\n        return lhs.get_lookup('isnull')(lhs, True)\n    return lookup",
    ".django.db.models.expressions.py@@BaseExpression.get_lookup": "def get_lookup(self, lookup):\n    return self.output_field.get_lookup(lookup)",
    ".django.db.models.query_utils.py@@RegisterLookupMixin.get_lookup": "def get_lookup(self, lookup_name):\n    from django.db.models.lookups import Lookup\n    found = self._get_lookup(lookup_name)\n    if found is None and hasattr(self, 'output_field'):\n        return self.output_field.get_lookup(lookup_name)\n    if found is not None and (not issubclass(found, Lookup)):\n        return None\n    return found",
    ".django.db.models.query_utils.py@@RegisterLookupMixin._get_lookup": "def _get_lookup(self, lookup_name):\n    return self.get_lookups().get(lookup_name, None)",
    ".django.db.models.query_utils.py@@class_or_instance_method.__get__": "def __get__(self, instance, owner):\n    if instance is None:\n        return functools.partial(self.class_method, owner)\n    return functools.partial(self.instance_method, instance)",
    ".django.db.models.query_utils.py@@RegisterLookupMixin.get_instance_lookups": "def get_instance_lookups(self):\n    class_lookups = self.get_class_lookups()\n    if (instance_lookups := getattr(self, 'instance_lookups', None)):\n        return {**class_lookups, **instance_lookups}\n    return class_lookups",
    ".django.db.models.query_utils.py@@RegisterLookupMixin.get_class_lookups": "def get_class_lookups(cls):\n    class_lookups = [parent.__dict__.get('class_lookups', {}) for parent in inspect.getmro(cls)]\n    return cls.merge_dicts(class_lookups)",
    ".django.db.models.query_utils.py@@RegisterLookupMixin.merge_dicts": "def merge_dicts(dicts):\n    merged = {}\n    for d in reversed(dicts):\n        merged.update(d)\n    return merged",
    ".django.db.models.lookups.py@@Lookup.__init__": "def __init__(self, lhs, rhs):\n    self.lhs, self.rhs = (lhs, rhs)\n    self.rhs = self.get_prep_lookup()\n    self.lhs = self.get_prep_lhs()\n    if hasattr(self.lhs, 'get_bilateral_transforms'):\n        bilateral_transforms = self.lhs.get_bilateral_transforms()\n    else:\n        bilateral_transforms = []\n    if bilateral_transforms:\n        from django.db.models.sql.query import Query\n        if isinstance(rhs, Query):\n            raise NotImplementedError('Bilateral transformations on nested querysets are not implemented.')\n    self.bilateral_transforms = bilateral_transforms",
    ".django.db.models.lookups.py@@Lookup.get_prep_lookup": "def get_prep_lookup(self):\n    if not self.prepare_rhs or hasattr(self.rhs, 'resolve_expression'):\n        return self.rhs\n    if hasattr(self.lhs, 'output_field'):\n        if hasattr(self.lhs.output_field, 'get_prep_value'):\n            return self.lhs.output_field.get_prep_value(self.rhs)\n    elif self.rhs_is_direct_value():\n        return Value(self.rhs)\n    return self.rhs",
    ".django.db.models.fields.__init__.py@@DateTimeField.get_prep_value": "def get_prep_value(self, value):\n    value = super().get_prep_value(value)\n    value = self.to_python(value)\n    if value is not None and settings.USE_TZ and timezone.is_naive(value):\n        try:\n            name = '%s.%s' % (self.model.__name__, self.name)\n        except AttributeError:\n            name = '(unbound)'\n        warnings.warn('DateTimeField %s received a naive datetime (%s) while time zone support is active.' % (name, value), RuntimeWarning)\n        default_timezone = timezone.get_default_timezone()\n        value = timezone.make_aware(value, default_timezone)\n    return value",
    ".django.db.models.fields.__init__.py@@DateField.get_prep_value": "def get_prep_value(self, value):\n    value = super().get_prep_value(value)\n    return self.to_python(value)",
    ".django.db.models.fields.__init__.py@@Field.get_prep_value": "def get_prep_value(self, value):\n    if isinstance(value, Promise):\n        value = value._proxy____cast()\n    return value",
    ".django.db.models.fields.__init__.py@@DateTimeField.to_python": "def to_python(self, value):\n    if value is None:\n        return value\n    if isinstance(value, datetime.datetime):\n        return value\n    if isinstance(value, datetime.date):\n        value = datetime.datetime(value.year, value.month, value.day)\n        if settings.USE_TZ:\n            warnings.warn('DateTimeField %s.%s received a naive datetime (%s) while time zone support is active.' % (self.model.__name__, self.name, value), RuntimeWarning)\n            default_timezone = timezone.get_default_timezone()\n            value = timezone.make_aware(value, default_timezone)\n        return value\n    try:\n        parsed = parse_datetime(value)\n        if parsed is not None:\n            return parsed\n    except ValueError:\n        raise exceptions.ValidationError(self.error_messages['invalid_datetime'], code='invalid_datetime', params={'value': value})\n    try:\n        parsed = parse_date(value)\n        if parsed is not None:\n            return datetime.datetime(parsed.year, parsed.month, parsed.day)\n    except ValueError:\n        raise exceptions.ValidationError(self.error_messages['invalid_date'], code='invalid_date', params={'value': value})\n    raise exceptions.ValidationError(self.error_messages['invalid'], code='invalid', params={'value': value})",
    ".django.db.models.lookups.py@@Lookup.get_prep_lhs": "def get_prep_lhs(self):\n    if hasattr(self.lhs, 'resolve_expression'):\n        return self.lhs\n    return Value(self.lhs)",
    ".django.db.models.sql.query.py@@JoinPromoter.add_votes": "def add_votes(self, votes):\n    self.votes.update(votes)",
    ".django.utils.tree.py@@Node.__bool__": "def __bool__(self):\n    return bool(self.children)",
    ".django.utils.tree.py@@Node.add": "def add(self, data, conn_type):\n    if self.connector != conn_type:\n        obj = self.copy()\n        self.connector = conn_type\n        self.children = [obj, data]\n        return data\n    elif isinstance(data, Node) and (not data.negated) and (data.connector == conn_type or len(data) == 1):\n        self.children.extend(data.children)\n        return self\n    else:\n        self.children.append(data)\n        return data",
    ".django.db.models.sql.query.py@@Query.base_table": "def base_table(self):\n    for alias in self.alias_map:\n        return alias",
    ".django.db.models.sql.query.py@@Query.ref_alias": "def ref_alias(self, alias):\n    self.alias_refcount[alias] += 1",
    ".django.db.models.lookups.py@@Exact.get_prep_lookup": "def get_prep_lookup(self):\n    from django.db.models.sql.query import Query\n    if isinstance(self.rhs, Query):\n        if self.rhs.has_limit_one():\n            if not self.rhs.has_select_fields:\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n        else:\n            raise ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.')\n    return super().get_prep_lookup()",
    ".django.db.models.fields.__init__.py@@CharField.get_prep_value": "def get_prep_value(self, value):\n    value = super().get_prep_value(value)\n    return self.to_python(value)",
    ".django.db.models.fields.__init__.py@@CharField.to_python": "def to_python(self, value):\n    if isinstance(value, str) or value is None:\n        return value\n    return str(value)",
    ".django.db.models.sql.query.py@@JoinPromoter.update_join_types": "def update_join_types(self, query):\n    to_promote = set()\n    to_demote = set()\n    for table, votes in self.votes.items():\n        if self.effective_connector == OR and votes < self.num_children:\n            to_promote.add(table)\n        if self.effective_connector == AND or (self.effective_connector == OR and votes == self.num_children):\n            to_demote.add(table)\n    query.promote_joins(to_promote)\n    query.demote_joins(to_demote)\n    return to_demote",
    ".django.db.models.sql.query.py@@Query.promote_joins": "def promote_joins(self, aliases):\n    aliases = list(aliases)\n    while aliases:\n        alias = aliases.pop(0)\n        if self.alias_map[alias].join_type is None:\n            continue\n        assert self.alias_map[alias].join_type is not None\n        parent_alias = self.alias_map[alias].parent_alias\n        parent_louter = parent_alias and self.alias_map[parent_alias].join_type == LOUTER\n        already_louter = self.alias_map[alias].join_type == LOUTER\n        if (self.alias_map[alias].nullable or parent_louter) and (not already_louter):\n            self.alias_map[alias] = self.alias_map[alias].promote()\n            aliases.extend((join for join in self.alias_map if self.alias_map[join].parent_alias == alias and join not in aliases))",
    ".django.db.models.sql.query.py@@Query.demote_joins": "def demote_joins(self, aliases):\n    aliases = list(aliases)\n    while aliases:\n        alias = aliases.pop(0)\n        if self.alias_map[alias].join_type == LOUTER:\n            self.alias_map[alias] = self.alias_map[alias].demote()\n            parent_alias = self.alias_map[alias].parent_alias\n            if self.alias_map[parent_alias].join_type == INNER:\n                aliases.append(parent_alias)",
    ".django.db.models.sql.query.py@@Query.can_filter": "def can_filter(self):\n    return not self.is_sliced",
    ".django.db.models.query.py@@QuerySet.order_by": "def order_by(self, *field_names):\n    if self.query.is_sliced:\n        raise TypeError('Cannot reorder a query once a slice has been taken.')\n    obj = self._chain()\n    obj.query.clear_ordering(force=True, clear_default=False)\n    obj.query.add_ordering(*field_names)\n    return obj",
    ".django.db.models.sql.query.py@@Query.clear_ordering": "def clear_ordering(self, force=False, clear_default=True):\n    if not force and (self.is_sliced or self.distinct_fields or self.select_for_update):\n        return\n    self.order_by = ()\n    self.extra_order_by = ()\n    if clear_default:\n        self.default_ordering = False",
    ".django.db.models.sql.query.py@@Query.add_ordering": "def add_ordering(self, *ordering):\n    errors = []\n    for item in ordering:\n        if isinstance(item, str):\n            if item == '?':\n                continue\n            if item.startswith('-'):\n                item = item[1:]\n            if item in self.annotations:\n                continue\n            if self.extra and item in self.extra:\n                continue\n            self.names_to_path(item.split(LOOKUP_SEP), self.model._meta)\n        elif not hasattr(item, 'resolve_expression'):\n            errors.append(item)\n        if getattr(item, 'contains_aggregate', False):\n            raise FieldError('Using an aggregate in order_by() without also including it in annotate() is not allowed: %s' % item)\n    if errors:\n        raise FieldError('Invalid order_by arguments: %s' % errors)\n    if ordering:\n        self.order_by += ordering\n    else:\n        self.default_ordering = False",
    ".django.db.models.sql.query.py@@Query.set_limits": "def set_limits(self, low=None, high=None):\n    if high is not None:\n        if self.high_mark is not None:\n            self.high_mark = min(self.high_mark, self.low_mark + high)\n        else:\n            self.high_mark = self.low_mark + high\n    if low is not None:\n        if self.high_mark is not None:\n            self.low_mark = min(self.high_mark, self.low_mark + low)\n        else:\n            self.low_mark = self.low_mark + low\n    if self.low_mark == self.high_mark:\n        self.set_empty()",
    ".django.db.models.query.py@@QuerySet.__len__": "def __len__(self):\n    self._fetch_all()\n    return len(self._result_cache)",
    ".django.db.models.query.py@@QuerySet._fetch_all": "def _fetch_all(self):\n    if self._result_cache is None:\n        self._result_cache = list(self._iterable_class(self))\n    if self._prefetch_related_lookups and (not self._prefetch_done):\n        self._prefetch_related_objects()",
    ".django.db.models.query.py@@BaseIterable.__init__": "def __init__(self, queryset, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n    self.queryset = queryset\n    self.chunked_fetch = chunked_fetch\n    self.chunk_size = chunk_size",
    ".django.db.models.query.py@@ModelIterable.__iter__": "def __iter__(self):\n    queryset = self.queryset\n    db = queryset.db\n    compiler = queryset.query.get_compiler(using=db)\n    results = compiler.execute_sql(chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size)\n    select, klass_info, annotation_col_map = (compiler.select, compiler.klass_info, compiler.annotation_col_map)\n    model_cls = klass_info['model']\n    select_fields = klass_info['select_fields']\n    model_fields_start, model_fields_end = (select_fields[0], select_fields[-1] + 1)\n    init_list = [f[0].target.attname for f in select[model_fields_start:model_fields_end]]\n    related_populators = get_related_populators(klass_info, select, db)\n    known_related_objects = [(field, related_objs, operator.attrgetter(*[field.attname if from_field == 'self' else queryset.model._meta.get_field(from_field).attname for from_field in field.from_fields])) for field, related_objs in queryset._known_related_objects.items()]\n    for row in compiler.results_iter(results):\n        obj = model_cls.from_db(db, init_list, row[model_fields_start:model_fields_end])\n        for rel_populator in related_populators:\n            rel_populator.populate(row, obj)\n        if annotation_col_map:\n            for attr_name, col_pos in annotation_col_map.items():\n                setattr(obj, attr_name, row[col_pos])\n        for field, rel_objs, rel_getter in known_related_objects:\n            if field.is_cached(obj):\n                continue\n            rel_obj_id = rel_getter(obj)\n            try:\n                rel_obj = rel_objs[rel_obj_id]\n            except KeyError:\n                pass\n            else:\n                setattr(obj, field.name, rel_obj)\n        yield obj",
    ".django.db.models.query.py@@QuerySet.db": "def db(self):\n    if self._for_write:\n        return self._db or router.db_for_write(self.model, **self._hints)\n    return self._db or router.db_for_read(self.model, **self._hints)",
    ".django.db.utils.py@@ConnectionRouter._route_db": "def _route_db(self, model, **hints):\n    chosen_db = None\n    for router in self.routers:\n        try:\n            method = getattr(router, action)\n        except AttributeError:\n            pass\n        else:\n            chosen_db = method(model, **hints)\n            if chosen_db:\n                return chosen_db\n    instance = hints.get('instance')\n    if instance is not None and instance._state.db:\n        return instance._state.db\n    return DEFAULT_DB_ALIAS",
    ".django.db.models.sql.query.py@@Query.get_compiler": "def get_compiler(self, using=None, connection=None, elide_empty=True):\n    if using is None and connection is None:\n        raise ValueError('Need either using or connection')\n    if using:\n        connection = connections[using]\n    return connection.ops.compiler(self.compiler)(self, connection, using, elide_empty)",
    ".django.utils.connection.py@@BaseConnectionHandler.__getitem__": "def __getitem__(self, alias):\n    try:\n        return getattr(self._connections, alias)\n    except AttributeError:\n        if alias not in self.settings:\n            raise self.exception_class(f\"The connection '{alias}' doesn't exist.\")\n    conn = self.create_connection(alias)\n    setattr(self._connections, alias, conn)\n    return conn",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.compiler": "def compiler(self, compiler_name):\n    if self._cache is None:\n        self._cache = import_module(self.compiler_module)\n    return getattr(self._cache, compiler_name)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.__init__": "def __init__(self, query, connection, using, elide_empty=True):\n    self.query = query\n    self.connection = connection\n    self.using = using\n    self.elide_empty = elide_empty\n    self.quote_cache = {'*': '*'}\n    self.select = None\n    self.annotation_col_map = None\n    self.klass_info = None\n    self._meta_ordering = None",
    ".django.db.models.sql.compiler.py@@SQLCompiler.execute_sql": "def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n    result_type = result_type or NO_RESULTS\n    try:\n        sql, params = self.as_sql()\n        if not sql:\n            raise EmptyResultSet\n    except EmptyResultSet:\n        if result_type == MULTI:\n            return iter([])\n        else:\n            return\n    if chunked_fetch:\n        cursor = self.connection.chunked_cursor()\n    else:\n        cursor = self.connection.cursor()\n    try:\n        cursor.execute(sql, params)\n    except Exception:\n        cursor.close()\n        raise\n    if result_type == CURSOR:\n        return cursor\n    if result_type == SINGLE:\n        try:\n            val = cursor.fetchone()\n            if val:\n                return val[0:self.col_count]\n            return val\n        finally:\n            cursor.close()\n    if result_type == NO_RESULTS:\n        cursor.close()\n        return\n    result = cursor_iter(cursor, self.connection.features.empty_fetchmany_value, self.col_count if self.has_extra_select else None, chunk_size)\n    if not chunked_fetch or not self.connection.features.can_use_chunked_reads:\n        return list(result)\n    return result",
    ".django.db.models.sql.compiler.py@@SQLCompiler.as_sql": "def as_sql(self, with_limits=True, with_col_aliases=False):\n    refcounts_before = self.query.alias_refcount.copy()\n    try:\n        extra_select, order_by, group_by = self.pre_sql_setup(with_col_aliases=with_col_aliases)\n        for_update_part = None\n        with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n        combinator = self.query.combinator\n        features = self.connection.features\n        if combinator:\n            if not getattr(features, 'supports_select_{}'.format(combinator)):\n                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n        elif self.qualify:\n            result, params = self.get_qualify_sql()\n            order_by = None\n        else:\n            distinct_fields, distinct_params = self.get_distinct()\n            from_, f_params = self.get_from_clause()\n            try:\n                where, w_params = self.compile(self.where) if self.where is not None else ('', [])\n            except EmptyResultSet:\n                if self.elide_empty:\n                    raise\n                where, w_params = ('0 = 1', [])\n            having, h_params = self.compile(self.having) if self.having is not None else ('', [])\n            result = ['SELECT']\n            params = []\n            if self.query.distinct:\n                distinct_result, distinct_params = self.connection.ops.distinct_sql(distinct_fields, distinct_params)\n                result += distinct_result\n                params += distinct_params\n            out_cols = []\n            for _, (s_sql, s_params), alias in self.select + extra_select:\n                if alias:\n                    s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n                params.extend(s_params)\n                out_cols.append(s_sql)\n            result += [', '.join(out_cols)]\n            if from_:\n                result += ['FROM', *from_]\n            elif self.connection.features.bare_select_suffix:\n                result += [self.connection.features.bare_select_suffix]\n            params.extend(f_params)\n            if self.query.select_for_update and features.has_select_for_update:\n                if self.connection.get_autocommit() and features.supports_transactions:\n                    raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')\n                if with_limit_offset and (not features.supports_select_for_update_with_limit):\n                    raise NotSupportedError('LIMIT/OFFSET is not supported with select_for_update on this database backend.')\n                nowait = self.query.select_for_update_nowait\n                skip_locked = self.query.select_for_update_skip_locked\n                of = self.query.select_for_update_of\n                no_key = self.query.select_for_no_key_update\n                if nowait and (not features.has_select_for_update_nowait):\n                    raise NotSupportedError('NOWAIT is not supported on this database backend.')\n                elif skip_locked and (not features.has_select_for_update_skip_locked):\n                    raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')\n                elif of and (not features.has_select_for_update_of):\n                    raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')\n                elif no_key and (not features.has_select_for_no_key_update):\n                    raise NotSupportedError('FOR NO KEY UPDATE is not supported on this database backend.')\n                for_update_part = self.connection.ops.for_update_sql(nowait=nowait, skip_locked=skip_locked, of=self.get_select_for_update_of_arguments(), no_key=no_key)\n            if for_update_part and features.for_update_after_from:\n                result.append(for_update_part)\n            if where:\n                result.append('WHERE %s' % where)\n                params.extend(w_params)\n            grouping = []\n            for g_sql, g_params in group_by:\n                grouping.append(g_sql)\n                params.extend(g_params)\n            if grouping:\n                if distinct_fields:\n                    raise NotImplementedError('annotate() + distinct(fields) is not implemented.')\n                order_by = order_by or self.connection.ops.force_no_ordering()\n                result.append('GROUP BY %s' % ', '.join(grouping))\n                if self._meta_ordering:\n                    order_by = None\n            if having:\n                result.append('HAVING %s' % having)\n                params.extend(h_params)\n        if self.query.explain_info:\n            result.insert(0, self.connection.ops.explain_query_prefix(self.query.explain_info.format, **self.query.explain_info.options))\n        if order_by:\n            ordering = []\n            for _, (o_sql, o_params, _) in order_by:\n                ordering.append(o_sql)\n                params.extend(o_params)\n            order_by_sql = 'ORDER BY %s' % ', '.join(ordering)\n            if combinator and features.requires_compound_order_by_subquery:\n                result = ['SELECT * FROM (', *result, ')', order_by_sql]\n            else:\n                result.append(order_by_sql)\n        if with_limit_offset:\n            result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))\n        if for_update_part and (not features.for_update_after_from):\n            result.append(for_update_part)\n        if self.query.subquery and extra_select:\n            sub_selects = []\n            sub_params = []\n            for index, (select, _, alias) in enumerate(self.select, start=1):\n                if alias:\n                    sub_selects.append('%s.%s' % (self.connection.ops.quote_name('subquery'), self.connection.ops.quote_name(alias)))\n                else:\n                    select_clone = select.relabeled_clone({select.alias: 'subquery'})\n                    subselect, subparams = select_clone.as_sql(self, self.connection)\n                    sub_selects.append(subselect)\n                    sub_params.extend(subparams)\n            return ('SELECT %s FROM (%s) subquery' % (', '.join(sub_selects), ' '.join(result)), tuple(sub_params + params))\n        return (' '.join(result), tuple(params))\n    finally:\n        self.query.reset_refcounts(refcounts_before)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.pre_sql_setup": "def pre_sql_setup(self, with_col_aliases=False):\n    self.setup_query(with_col_aliases=with_col_aliases)\n    order_by = self.get_order_by()\n    self.where, self.having, self.qualify = self.query.where.split_having_qualify(must_group_by=self.query.group_by is not None)\n    extra_select = self.get_extra_select(order_by, self.select)\n    self.has_extra_select = bool(extra_select)\n    group_by = self.get_group_by(self.select + extra_select, order_by)\n    return (extra_select, order_by, group_by)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.setup_query": "def setup_query(self, with_col_aliases=False):\n    if all((self.query.alias_refcount[a] == 0 for a in self.query.alias_map)):\n        self.query.get_initial_alias()\n    self.select, self.klass_info, self.annotation_col_map = self.get_select(with_col_aliases=with_col_aliases)\n    self.col_count = len(self.select)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_select": "def get_select(self, with_col_aliases=False):\n    select = []\n    klass_info = None\n    annotations = {}\n    select_idx = 0\n    for alias, (sql, params) in self.query.extra_select.items():\n        annotations[alias] = select_idx\n        select.append((RawSQL(sql, params), alias))\n        select_idx += 1\n    assert not (self.query.select and self.query.default_cols)\n    select_mask = self.query.get_select_mask()\n    if self.query.default_cols:\n        cols = self.get_default_columns(select_mask)\n    else:\n        cols = self.query.select\n    if cols:\n        select_list = []\n        for col in cols:\n            select_list.append(select_idx)\n            select.append((col, None))\n            select_idx += 1\n        klass_info = {'model': self.query.model, 'select_fields': select_list}\n    for alias, annotation in self.query.annotation_select.items():\n        annotations[alias] = select_idx\n        select.append((annotation, alias))\n        select_idx += 1\n    if self.query.select_related:\n        related_klass_infos = self.get_related_selections(select, select_mask)\n        klass_info['related_klass_infos'] = related_klass_infos\n\n        def get_select_from_parent(klass_info):\n            for ki in klass_info['related_klass_infos']:\n                if ki['from_parent']:\n                    ki['select_fields'] = klass_info['select_fields'] + ki['select_fields']\n                get_select_from_parent(ki)\n        get_select_from_parent(klass_info)\n    ret = []\n    col_idx = 1\n    for col, alias in select:\n        try:\n            sql, params = self.compile(col)\n        except EmptyResultSet:\n            empty_result_set_value = getattr(col, 'empty_result_set_value', NotImplemented)\n            if empty_result_set_value is NotImplemented:\n                sql, params = ('0', ())\n            else:\n                sql, params = self.compile(Value(empty_result_set_value))\n        else:\n            sql, params = col.select_format(self, sql, params)\n        if alias is None and with_col_aliases:\n            alias = f'col{col_idx}'\n            col_idx += 1\n        ret.append((col, (sql, params), alias))\n    return (ret, klass_info, annotations)",
    ".django.db.models.sql.query.py@@Query.extra_select": "def extra_select(self):\n    if self._extra_select_cache is not None:\n        return self._extra_select_cache\n    if not self.extra:\n        return {}\n    elif self.extra_select_mask is not None:\n        self._extra_select_cache = {k: v for k, v in self.extra.items() if k in self.extra_select_mask}\n        return self._extra_select_cache\n    else:\n        return self.extra",
    ".django.db.models.sql.query.py@@Query.get_select_mask": "def get_select_mask(self):\n    field_names, defer = self.deferred_loading\n    if not field_names:\n        return {}\n    mask = {}\n    for field_name in field_names:\n        part_mask = mask\n        for part in field_name.split(LOOKUP_SEP):\n            part_mask = part_mask.setdefault(part, {})\n    opts = self.get_meta()\n    if defer:\n        return self._get_defer_select_mask(opts, mask)\n    return self._get_only_select_mask(opts, mask)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_default_columns": "def get_default_columns(self, select_mask, start_alias=None, opts=None, from_parent=None):\n    result = []\n    if opts is None:\n        if (opts := self.query.get_meta()) is None:\n            return result\n    start_alias = start_alias or self.query.get_initial_alias()\n    seen_models = {None: start_alias}\n    for field in opts.concrete_fields:\n        model = field.model._meta.concrete_model\n        if model == opts.model:\n            model = None\n        if from_parent and model is not None and issubclass(from_parent._meta.concrete_model, model._meta.concrete_model):\n            continue\n        if select_mask and field not in select_mask:\n            continue\n        alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n        column = field.get_col(alias)\n        result.append(column)\n    return result",
    ".django.db.models.options.py@@Options.concrete_fields": "def concrete_fields(self):\n    return make_immutable_fields_list('concrete_fields', (f for f in self.fields if f.concrete))",
    ".django.db.models.options.py@@Options.fields": "def fields(self):\n\n    def is_not_an_m2m_field(f):\n        return not (f.is_relation and f.many_to_many)\n\n    def is_not_a_generic_relation(f):\n        return not (f.is_relation and f.one_to_many)\n\n    def is_not_a_generic_foreign_key(f):\n        return not (f.is_relation and f.many_to_one and (not (hasattr(f.remote_field, 'model') and f.remote_field.model)))\n    return make_immutable_fields_list('fields', (f for f in self._get_fields(reverse=False) if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f)))",
    ".django.db.models.options.py@@make_immutable_fields_list": "def make_immutable_fields_list(name, data):\n    return ImmutableList(data, warning=IMMUTABLE_WARNING % name)",
    ".django.db.models.options.py@@Options.is_not_an_m2m_field": "def is_not_an_m2m_field(f):\n    return not (f.is_relation and f.many_to_many)",
    ".django.db.models.options.py@@Options.is_not_a_generic_relation": "def is_not_a_generic_relation(f):\n    return not (f.is_relation and f.one_to_many)",
    ".django.db.models.options.py@@Options.is_not_a_generic_foreign_key": "def is_not_a_generic_foreign_key(f):\n    return not (f.is_relation and f.many_to_one and (not (hasattr(f.remote_field, 'model') and f.remote_field.model)))",
    ".django.db.models.sql.query.py@@Query.join_parent_model": "def join_parent_model(self, opts, model, alias, seen):\n    if model in seen:\n        return seen[model]\n    chain = opts.get_base_chain(model)\n    if not chain:\n        return alias\n    curr_opts = opts\n    for int_model in chain:\n        if int_model in seen:\n            curr_opts = int_model._meta\n            alias = seen[int_model]\n            continue\n        if not curr_opts.parents[int_model]:\n            curr_opts = int_model._meta\n            continue\n        link_field = curr_opts.get_ancestor_link(int_model)\n        join_info = self.setup_joins([link_field.name], curr_opts, alias)\n        curr_opts = int_model._meta\n        alias = seen[int_model] = join_info.joins[-1]\n    return alias or seen[None]",
    ".django.db.models.sql.query.py@@Query.annotation_select": "def annotation_select(self):\n    if self._annotation_select_cache is not None:\n        return self._annotation_select_cache\n    elif not self.annotations:\n        return {}\n    elif self.annotation_select_mask is not None:\n        self._annotation_select_cache = {k: v for k, v in self.annotations.items() if k in self.annotation_select_mask}\n        return self._annotation_select_cache\n    else:\n        return self.annotations",
    ".django.db.models.sql.compiler.py@@SQLCompiler.compile": "def compile(self, node):\n    vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)\n    if vendor_impl:\n        sql, params = vendor_impl(self, self.connection)\n    else:\n        sql, params = node.as_sql(self, self.connection)\n    return (sql, params)",
    ".django.db.models.expressions.py@@Col.as_sql": "def as_sql(self, compiler, connection):\n    alias, column = (self.alias, self.target.column)\n    identifiers = (alias, column) if alias else (column,)\n    sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))\n    return (sql, [])",
    ".django.db.models.sql.compiler.py@@SQLCompiler.quote_name_unless_alias": "def quote_name_unless_alias(self, name):\n    if name in self.quote_cache:\n        return self.quote_cache[name]\n    if name in self.query.alias_map and name not in self.query.table_map or name in self.query.extra_select or (self.query.external_aliases.get(name) and name not in self.query.table_map):\n        self.quote_cache[name] = name\n        return name\n    r = self.connection.ops.quote_name(name)\n    self.quote_cache[name] = r\n    return r",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.quote_name": "def quote_name(self, name):\n    if name.startswith('\"') and name.endswith('\"'):\n        return name\n    return '\"%s\"' % name",
    ".django.db.models.expressions.py@@BaseExpression.select_format": "def select_format(self, compiler, sql, params):\n    if hasattr(self.output_field, 'select_format'):\n        return self.output_field.select_format(compiler, sql, params)\n    return (sql, params)",
    ".django.db.models.fields.__init__.py@@Field.select_format": "def select_format(self, compiler, sql, params):\n    return (sql, params)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_order_by": "def get_order_by(self):\n    result = []\n    seen = set()\n    for expr, is_ref in self._order_by_pairs():\n        resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n        if not is_ref and self.query.combinator and self.select:\n            src = resolved.expression\n            expr_src = expr.expression\n            for sel_expr, _, col_alias in self.select:\n                if col_alias and (not (isinstance(expr_src, F) and col_alias == expr_src.name)):\n                    continue\n                if src == sel_expr:\n                    resolved.set_source_expressions([Ref(col_alias if col_alias else src.target.column, src)])\n                    break\n            else:\n                if col_alias:\n                    raise DatabaseError('ORDER BY term does not match any column in the result set.')\n                order_by_idx = len(self.query.select) + 1\n                col_name = f'__orderbycol{order_by_idx}'\n                for q in self.query.combined_queries:\n                    q.add_annotation(expr_src, col_name)\n                self.query.add_select_col(resolved, col_name)\n                resolved.set_source_expressions([RawSQL(f'{order_by_idx}', ())])\n        sql, params = self.compile(resolved)\n        without_ordering = self.ordering_parts.search(sql)[1]\n        params_hash = make_hashable(params)\n        if (without_ordering, params_hash) in seen:\n            continue\n        seen.add((without_ordering, params_hash))\n        result.append((resolved, (sql, params, is_ref)))\n    return result",
    ".django.db.models.sql.compiler.py@@SQLCompiler._order_by_pairs": "def _order_by_pairs(self):\n    if self.query.extra_order_by:\n        ordering = self.query.extra_order_by\n    elif not self.query.default_ordering:\n        ordering = self.query.order_by\n    elif self.query.order_by:\n        ordering = self.query.order_by\n    elif (meta := self.query.get_meta()) and meta.ordering:\n        ordering = meta.ordering\n        self._meta_ordering = ordering\n    else:\n        ordering = []\n    if self.query.standard_ordering:\n        default_order, _ = ORDER_DIR['ASC']\n    else:\n        default_order, _ = ORDER_DIR['DESC']\n    for field in ordering:\n        if hasattr(field, 'resolve_expression'):\n            if isinstance(field, Value):\n                field = Cast(field, field.output_field)\n            if not isinstance(field, OrderBy):\n                field = field.asc()\n            if not self.query.standard_ordering:\n                field = field.copy()\n                field.reverse_ordering()\n            if isinstance(field.expression, F) and (annotation := self.query.annotation_select.get(field.expression.name)):\n                field.expression = Ref(field.expression.name, annotation)\n            yield (field, isinstance(field.expression, Ref))\n            continue\n        if field == '?':\n            yield (OrderBy(Random()), False)\n            continue\n        col, order = get_order_dir(field, default_order)\n        descending = order == 'DESC'\n        if col in self.query.annotation_select:\n            yield (OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending), True)\n            continue\n        if col in self.query.annotations:\n            if self.query.combinator and self.select:\n                expr = F(col)\n            else:\n                expr = self.query.annotations[col]\n                if isinstance(expr, Value):\n                    expr = Cast(expr, expr.output_field)\n            yield (OrderBy(expr, descending=descending), False)\n            continue\n        if '.' in field:\n            table, col = col.split('.', 1)\n            yield (OrderBy(RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []), descending=descending), False)\n            continue\n        if self.query.extra and col in self.query.extra:\n            if col in self.query.extra_select:\n                yield (OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending), True)\n            else:\n                yield (OrderBy(RawSQL(*self.query.extra[col]), descending=descending), False)\n        elif self.query.combinator and self.select:\n            yield (OrderBy(F(col), descending=descending), False)\n        else:\n            yield from self.find_ordering_name(field, self.query.get_meta(), default_order=default_order)",
    ".django.db.models.sql.where.py@@WhereNode.split_having_qualify": "def split_having_qualify(self, negated=False, must_group_by=False):\n    if not self.contains_aggregate and (not self.contains_over_clause):\n        return (self, None, None)\n    in_negated = negated ^ self.negated\n    must_remain_connected = in_negated and self.connector == AND or (not in_negated and self.connector == OR) or self.connector == XOR\n    if must_remain_connected and self.contains_aggregate and (not self.contains_over_clause):\n        return (None, self, None)\n    where_parts = []\n    having_parts = []\n    qualify_parts = []\n    for c in self.children:\n        if hasattr(c, 'split_having_qualify'):\n            where_part, having_part, qualify_part = c.split_having_qualify(in_negated, must_group_by)\n            if where_part is not None:\n                where_parts.append(where_part)\n            if having_part is not None:\n                having_parts.append(having_part)\n            if qualify_part is not None:\n                qualify_parts.append(qualify_part)\n        elif c.contains_over_clause:\n            qualify_parts.append(c)\n        elif c.contains_aggregate:\n            having_parts.append(c)\n        else:\n            where_parts.append(c)\n    if must_remain_connected and qualify_parts:\n        if not where_parts or (where_parts and (not must_group_by)):\n            return (None, None, self)\n        elif where_parts:\n            raise NotImplementedError('Heterogeneous disjunctive predicates against window functions are not implemented when performing conditional aggregation.')\n    where_node = self.create(where_parts, self.connector, self.negated) if where_parts else None\n    having_node = self.create(having_parts, self.connector, self.negated) if having_parts else None\n    qualify_node = self.create(qualify_parts, self.connector, self.negated) if qualify_parts else None\n    return (where_node, having_node, qualify_node)",
    ".django.db.models.sql.where.py@@WhereNode.contains_aggregate": "def contains_aggregate(self):\n    return self._contains_aggregate(self)",
    ".django.db.models.sql.where.py@@WhereNode._contains_aggregate": "def _contains_aggregate(cls, obj):\n    if isinstance(obj, tree.Node):\n        return any((cls._contains_aggregate(c) for c in obj.children))\n    return obj.contains_aggregate",
    ".django.db.models.expressions.py@@BaseExpression.contains_aggregate": "def contains_aggregate(self):\n    return any((expr and expr.contains_aggregate for expr in self.get_source_expressions()))",
    ".django.db.models.lookups.py@@Lookup.get_source_expressions": "def get_source_expressions(self):\n    if self.rhs_is_direct_value():\n        return [self.lhs]\n    return [self.lhs, self.rhs]",
    ".django.db.models.lookups.py@@Lookup.rhs_is_direct_value": "def rhs_is_direct_value(self):\n    return not hasattr(self.rhs, 'as_sql')",
    ".django.db.models.expressions.py@@BaseExpression.get_source_expressions": "def get_source_expressions(self):\n    return []",
    ".django.db.models.sql.where.py@@WhereNode.contains_over_clause": "def contains_over_clause(self):\n    return self._contains_over_clause(self)",
    ".django.db.models.sql.where.py@@WhereNode._contains_over_clause": "def _contains_over_clause(cls, obj):\n    if isinstance(obj, tree.Node):\n        return any((cls._contains_over_clause(c) for c in obj.children))\n    return obj.contains_over_clause",
    ".django.db.models.expressions.py@@BaseExpression.contains_over_clause": "def contains_over_clause(self):\n    return any((expr and expr.contains_over_clause for expr in self.get_source_expressions()))",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_extra_select": "def get_extra_select(self, order_by, select):\n    extra_select = []\n    if self.query.distinct and (not self.query.distinct_fields):\n        select_sql = [t[1] for t in select]\n        for expr, (sql, params, is_ref) in order_by:\n            without_ordering = self.ordering_parts.search(sql)[1]\n            if not is_ref and (without_ordering, params) not in select_sql:\n                extra_select.append((expr, (without_ordering, params), None))\n    return extra_select",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_group_by": "def get_group_by(self, select, order_by):\n    if self.query.group_by is None:\n        return []\n    expressions = []\n    allows_group_by_refs = self.connection.features.allows_group_by_refs\n    if self.query.group_by is not True:\n        for expr in self.query.group_by:\n            if not hasattr(expr, 'as_sql'):\n                expr = self.query.resolve_ref(expr)\n            if not allows_group_by_refs and isinstance(expr, Ref):\n                expr = expr.source\n            expressions.append(expr)\n    ref_sources = {expr.source for expr in expressions if isinstance(expr, Ref)}\n    aliased_exprs = {}\n    for expr, _, alias in select:\n        if expr in ref_sources:\n            continue\n        if alias:\n            aliased_exprs[expr] = alias\n        cols = expr.get_group_by_cols()\n        for col in cols:\n            expressions.append(col)\n    if not self._meta_ordering:\n        for expr, (sql, params, is_ref) in order_by:\n            if not is_ref:\n                expressions.extend(expr.get_group_by_cols())\n    having_group_by = self.having.get_group_by_cols() if self.having else ()\n    for expr in having_group_by:\n        expressions.append(expr)\n    result = []\n    seen = set()\n    expressions = self.collapse_group_by(expressions, having_group_by)\n    for expr in expressions:\n        if allows_group_by_refs and (alias := aliased_exprs.get(expr)):\n            expr = Ref(alias, expr)\n        try:\n            sql, params = self.compile(expr)\n        except EmptyResultSet:\n            continue\n        sql, params = expr.select_format(self, sql, params)\n        params_hash = make_hashable(params)\n        if (sql, params_hash) not in seen:\n            result.append((sql, params))\n            seen.add((sql, params_hash))\n    return result",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_distinct": "def get_distinct(self):\n    result = []\n    params = []\n    opts = self.query.get_meta()\n    for name in self.query.distinct_fields:\n        parts = name.split(LOOKUP_SEP)\n        _, targets, alias, joins, path, _, transform_function = self._setup_joins(parts, opts, None)\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        for target in targets:\n            if name in self.query.annotation_select:\n                result.append(self.connection.ops.quote_name(name))\n            else:\n                r, p = self.compile(transform_function(target, alias))\n                result.append(r)\n                params.append(p)\n    return (result, params)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_from_clause": "def get_from_clause(self):\n    result = []\n    params = []\n    for alias in tuple(self.query.alias_map):\n        if not self.query.alias_refcount[alias]:\n            continue\n        try:\n            from_clause = self.query.alias_map[alias]\n        except KeyError:\n            continue\n        clause_sql, clause_params = self.compile(from_clause)\n        result.append(clause_sql)\n        params.extend(clause_params)\n    for t in self.query.extra_tables:\n        alias, _ = self.query.table_alias(t)\n        if alias not in self.query.alias_map or self.query.alias_refcount[alias] == 1:\n            result.append(', %s' % self.quote_name_unless_alias(alias))\n    return (result, params)",
    ".django.db.models.sql.datastructures.py@@BaseTable.as_sql": "def as_sql(self, compiler, connection):\n    alias_str = '' if self.table_alias == self.table_name else ' %s' % self.table_alias\n    base_sql = compiler.quote_name_unless_alias(self.table_name)\n    return (base_sql + alias_str, [])",
    ".django.db.models.sql.where.py@@WhereNode.as_sql": "def as_sql(self, compiler, connection):\n    result = []\n    result_params = []\n    if self.connector == AND:\n        full_needed, empty_needed = (len(self.children), 1)\n    else:\n        full_needed, empty_needed = (1, len(self.children))\n    if self.connector == XOR and (not connection.features.supports_logical_xor):\n        lhs = self.__class__(self.children, OR)\n        rhs_sum = reduce(operator.add, (Case(When(c, then=1), default=0) for c in self.children))\n        rhs = Exact(1, rhs_sum)\n        return self.__class__([lhs, rhs], AND, self.negated).as_sql(compiler, connection)\n    for child in self.children:\n        try:\n            sql, params = compiler.compile(child)\n        except EmptyResultSet:\n            empty_needed -= 1\n        else:\n            if sql:\n                result.append(sql)\n                result_params.extend(params)\n            else:\n                full_needed -= 1\n        if empty_needed == 0:\n            if self.negated:\n                return ('', [])\n            else:\n                raise EmptyResultSet\n        if full_needed == 0:\n            if self.negated:\n                raise EmptyResultSet\n            else:\n                return ('', [])\n    conn = ' %s ' % self.connector\n    sql_string = conn.join(result)\n    if sql_string:\n        if self.negated:\n            sql_string = 'NOT (%s)' % sql_string\n        elif len(result) > 1 or self.resolved:\n            sql_string = '(%s)' % sql_string\n    return (sql_string, result_params)",
    ".django.db.models.lookups.py@@BuiltinLookup.as_sql": "def as_sql(self, compiler, connection):\n    lhs_sql, params = self.process_lhs(compiler, connection)\n    rhs_sql, rhs_params = self.process_rhs(compiler, connection)\n    params.extend(rhs_params)\n    rhs_sql = self.get_rhs_op(connection, rhs_sql)\n    return ('%s %s' % (lhs_sql, rhs_sql), params)",
    ".django.db.models.lookups.py@@BuiltinLookup.process_lhs": "def process_lhs(self, compiler, connection, lhs=None):\n    lhs_sql, params = super().process_lhs(compiler, connection, lhs)\n    field_internal_type = self.lhs.output_field.get_internal_type()\n    db_type = self.lhs.output_field.db_type(connection=connection)\n    lhs_sql = connection.ops.field_cast_sql(db_type, field_internal_type) % lhs_sql\n    lhs_sql = connection.ops.lookup_cast(self.lookup_name, field_internal_type) % lhs_sql\n    return (lhs_sql, list(params))",
    ".django.db.models.lookups.py@@Lookup.process_lhs": "def process_lhs(self, compiler, connection, lhs=None):\n    lhs = lhs or self.lhs\n    if hasattr(lhs, 'resolve_expression'):\n        lhs = lhs.resolve_expression(compiler.query)\n    sql, params = compiler.compile(lhs)\n    if isinstance(lhs, Lookup):\n        sql = f'({sql})'\n    return (sql, params)",
    ".django.db.models.expressions.py@@BaseExpression.resolve_expression": "def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n    c = self.copy()\n    c.is_summary = summarize\n    c.set_source_expressions([expr.resolve_expression(query, allow_joins, reuse, summarize) if expr else None for expr in c.get_source_expressions()])\n    return c",
    ".django.db.models.expressions.py@@BaseExpression.copy": "def copy(self):\n    return copy.copy(self)",
    ".django.db.models.expressions.py@@BaseExpression.__getstate__": "def __getstate__(self):\n    state = self.__dict__.copy()\n    state.pop('convert_value', None)\n    return state",
    ".django.db.models.expressions.py@@BaseExpression.set_source_expressions": "def set_source_expressions(self, exprs):\n    assert not exprs",
    ".django.db.models.fields.__init__.py@@DateTimeField.get_internal_type": "def get_internal_type(self):\n    return 'DateTimeField'",
    ".django.db.models.fields.__init__.py@@Field.db_type": "def db_type(self, connection):\n    data = self.db_type_parameters(connection)\n    try:\n        return connection.data_types[self.get_internal_type()] % data\n    except KeyError:\n        return None",
    ".django.db.models.fields.__init__.py@@Field.db_type_parameters": "def db_type_parameters(self, connection):\n    return DictWrapper(self.__dict__, connection.ops.quote_name, 'qn_')",
    ".django.utils.datastructures.py@@DictWrapper.__init__": "def __init__(self, data, func, prefix):\n    super().__init__(data)\n    self.func = func\n    self.prefix = prefix",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.field_cast_sql": "def field_cast_sql(self, db_type, internal_type):\n    return '%s'",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.lookup_cast": "def lookup_cast(self, lookup_type, internal_type=None):\n    return '%s'",
    ".django.db.models.lookups.py@@Lookup.process_rhs": "def process_rhs(self, compiler, connection):\n    value = self.rhs\n    if self.bilateral_transforms:\n        if self.rhs_is_direct_value():\n            value = Value(value, output_field=self.lhs.output_field)\n        value = self.apply_bilateral_transforms(value)\n        value = value.resolve_expression(compiler.query)\n    if hasattr(value, 'as_sql'):\n        sql, params = compiler.compile(value)\n        if sql and sql[0] != '(':\n            sql = '(%s)' % sql\n        return (sql, params)\n    else:\n        return self.get_db_prep_lookup(value, connection)",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueMixin.get_db_prep_lookup": "def get_db_prep_lookup(self, value, connection):\n    field = getattr(self.lhs.output_field, 'target_field', None)\n    get_db_prep_value = getattr(field, 'get_db_prep_value', None) or self.lhs.output_field.get_db_prep_value\n    return ('%s', [get_db_prep_value(v, connection, prepared=True) for v in value] if self.get_db_prep_lookup_value_is_iterable else [get_db_prep_value(value, connection, prepared=True)])",
    ".django.db.models.fields.__init__.py@@DateTimeField.get_db_prep_value": "def get_db_prep_value(self, value, connection, prepared=False):\n    if not prepared:\n        value = self.get_prep_value(value)\n    return connection.ops.adapt_datetimefield_value(value)",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.adapt_datetimefield_value": "def adapt_datetimefield_value(self, value):\n    if value is None:\n        return None\n    if hasattr(value, 'resolve_expression'):\n        return value\n    if timezone.is_aware(value):\n        if settings.USE_TZ:\n            value = timezone.make_naive(value, self.connection.timezone)\n        else:\n            raise ValueError('SQLite backend does not support timezone-aware datetimes when USE_TZ is False.')\n    return str(value)",
    ".django.utils.timezone.py@@is_aware": "def is_aware(value):\n    return value.utcoffset() is not None",
    ".django.db.models.lookups.py@@BuiltinLookup.get_rhs_op": "def get_rhs_op(self, connection, rhs):\n    return connection.operators[self.lookup_name] % rhs",
    ".django.db.models.lookups.py@@Exact.as_sql": "def as_sql(self, compiler, connection):\n    if isinstance(self.rhs, bool) and getattr(self.lhs, 'conditional', False) and connection.ops.conditional_expression_supported_in_where_clause(self.lhs):\n        lhs_sql, params = self.process_lhs(compiler, connection)\n        template = '%s' if self.rhs else 'NOT %s'\n        return (template % lhs_sql, params)\n    return super().as_sql(compiler, connection)",
    ".django.db.models.fields.__init__.py@@CharField.get_internal_type": "def get_internal_type(self):\n    return 'CharField'",
    ".django.utils.datastructures.py@@DictWrapper.__getitem__": "def __getitem__(self, key):\n    use_func = key.startswith(self.prefix)\n    if use_func:\n        key = key[len(self.prefix):]\n    value = super().__getitem__(key)\n    if use_func:\n        return self.func(value)\n    return value",
    ".django.db.models.fields.__init__.py@@Field.get_db_prep_value": "def get_db_prep_value(self, value, connection, prepared=False):\n    if not prepared:\n        value = self.get_prep_value(value)\n    return value",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.limit_offset_sql": "def limit_offset_sql(self, low_mark, high_mark):\n    limit, offset = self._get_limit_offset_params(low_mark, high_mark)\n    return ' '.join((sql for sql in ('LIMIT %d' % limit if limit else None, 'OFFSET %d' % offset if offset else None) if sql))",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations._get_limit_offset_params": "def _get_limit_offset_params(self, low_mark, high_mark):\n    offset = low_mark or 0\n    if high_mark is not None:\n        return (high_mark - offset, offset)\n    elif offset:\n        return (self.connection.ops.no_limit_value(), offset)\n    return (None, offset)",
    ".django.db.models.sql.query.py@@Query.reset_refcounts": "def reset_refcounts(self, to_counts):\n    for alias, cur_refcount in self.alias_refcount.copy().items():\n        unref_amount = cur_refcount - to_counts.get(alias, 0)\n        self.unref_alias(alias, unref_amount)",
    ".django.db.models.sql.query.py@@Query.unref_alias": "def unref_alias(self, alias, amount=1):\n    self.alias_refcount[alias] -= amount",
    ".django.test.testcases.py@@_DatabaseFailure.__call__": "def __call__(self):\n    raise DatabaseOperationForbidden(self.message)",
    ".django.http.request.py@@QueryDict.appendlist": "def appendlist(self, key, value):\n    self._assert_mutable()\n    key = bytes_to_text(key, self.encoding)\n    value = bytes_to_text(value, self.encoding)\n    super().appendlist(key, value)",
    ".django.http.request.py@@QueryDict._assert_mutable": "def _assert_mutable(self):\n    if not self._mutable:\n        raise AttributeError('This QueryDict instance is immutable')",
    ".django.http.request.py@@bytes_to_text": "def bytes_to_text(s, encoding):\n    if isinstance(s, bytes):\n        return str(s, encoding, 'replace')\n    else:\n        return s",
    ".django.http.request.py@@QueryDict.setlistdefault": "def setlistdefault(self, key, default_list=None):\n    self._assert_mutable()\n    return super().setlistdefault(key, default_list)",
    ".django.http.request.py@@QueryDict.setlist": "def setlist(self, key, list_):\n    self._assert_mutable()\n    key = bytes_to_text(key, self.encoding)\n    list_ = [bytes_to_text(elt, self.encoding) for elt in list_]\n    super().setlist(key, list_)",
    ".django.utils.datastructures.py@@MultiValueDict.__getitem__": "def __getitem__(self, key):\n    try:\n        list_ = super().__getitem__(key)\n    except KeyError:\n        raise MultiValueDictKeyError(key)\n    try:\n        return list_[-1]\n    except IndexError:\n        return []",
    ".django.urls.resolvers.py@@URLPattern.resolve": "def resolve(self, path):\n    match = self.pattern.match(path)\n    if match:\n        new_path, args, captured_kwargs = match\n        kwargs = {**captured_kwargs, **self.default_args}\n        return ResolverMatch(self.callback, args, kwargs, self.pattern.name, route=str(self.pattern), captured_kwargs=captured_kwargs, extra_kwargs=self.default_args)",
    ".django.urls.resolvers.py@@RoutePattern.match": "def match(self, path):\n    match = self.regex.search(path)\n    if match:\n        kwargs = match.groupdict()\n        for key, value in kwargs.items():\n            converter = self.converters[key]\n            try:\n                kwargs[key] = converter.to_python(value)\n            except ValueError:\n                return None\n        return (path[match.end():], (), kwargs)\n    return None",
    ".django.urls.resolvers.py@@URLResolver._extend_tried": "def _extend_tried(tried, pattern, sub_tried=None):\n    if sub_tried is None:\n        tried.append([pattern])\n    else:\n        tried.extend(([pattern, *t] for t in sub_tried))",
    ".django.urls.resolvers.py@@LocalePrefixPattern.match": "def match(self, path):\n    language_prefix = self.language_prefix\n    if path.startswith(language_prefix):\n        return (path[len(language_prefix):], (), {})\n    return None",
    ".django.urls.resolvers.py@@LocalePrefixPattern.language_prefix": "def language_prefix(self):\n    language_code = get_language() or settings.LANGUAGE_CODE\n    if language_code == settings.LANGUAGE_CODE and (not self.prefix_default_language):\n        return ''\n    else:\n        return '%s/' % language_code",
    ".django.utils.translation.__init__.py@@get_language": "def get_language():\n    return _trans.get_language()",
    ".django.utils.translation.trans_real.py@@get_language": "def get_language():\n    t = getattr(_active, 'value', None)\n    if t is not None:\n        try:\n            return t.to_language()\n        except AttributeError:\n            pass\n    return settings.LANGUAGE_CODE",
    ".django.utils.translation.trans_real.py@@DjangoTranslation.to_language": "def to_language(self):\n    return self.__to_language",
    ".django.views.debug.py@@SafeExceptionReporterFilter.get_cleansed_multivaluedict": "def get_cleansed_multivaluedict(self, request, multivaluedict):\n    sensitive_post_parameters = getattr(request, 'sensitive_post_parameters', [])\n    if self.is_active(request) and sensitive_post_parameters:\n        multivaluedict = multivaluedict.copy()\n        for param in sensitive_post_parameters:\n            if param in multivaluedict:\n                multivaluedict[param] = self.cleansed_substitute\n    return multivaluedict",
    ".django.utils.datastructures.py@@MultiValueDict.__repr__": "def __repr__(self):\n    return '<%s: %s>' % (self.__class__.__name__, super().__repr__())",
    ".django.http.request.py@@QueryDict.copy": "def copy(self):\n    return self.__deepcopy__({})",
    ".django.http.request.py@@QueryDict.__deepcopy__": "def __deepcopy__(self, memo):\n    result = self.__class__('', mutable=True, encoding=self.encoding)\n    memo[id(self)] = result\n    for key, value in self.lists():\n        result.setlist(copy.deepcopy(key, memo), copy.deepcopy(value, memo))\n    return result",
    ".django.utils.datastructures.py@@MultiValueDict.lists": "def lists(self):\n    return iter(super().items())",
    ".django.http.request.py@@QueryDict.__setitem__": "def __setitem__(self, key, value):\n    self._assert_mutable()\n    key = bytes_to_text(key, self.encoding)\n    value = bytes_to_text(value, self.encoding)\n    super().__setitem__(key, value)",
    ".django.utils.datastructures.py@@MultiValueDict.__setitem__": "def __setitem__(self, key, value):\n    super().__setitem__(key, [value])",
    ".django.utils.functional.py@@SimpleLazyObject.__repr__": "def __repr__(self):\n    if self._wrapped is empty:\n        repr_attr = self._setupfunc\n    else:\n        repr_attr = self._wrapped\n    return '<%s: %r>' % (type(self).__name__, repr_attr)"
}