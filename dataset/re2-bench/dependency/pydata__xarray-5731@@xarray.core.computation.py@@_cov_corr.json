{
    ".xarray.core.alignment.py@@align": "def align(*objects: 'DataAlignable', join='inner', copy=True, indexes=None, exclude=frozenset(), fill_value=dtypes.NA) -> Tuple['DataAlignable', ...]:\n    if indexes is None:\n        indexes = {}\n    if not indexes and len(objects) == 1:\n        obj, = objects\n        return (obj.copy(deep=copy),)\n    all_indexes = defaultdict(list)\n    all_coords = defaultdict(list)\n    unlabeled_dim_sizes = defaultdict(set)\n    for obj in objects:\n        for dim in obj.dims:\n            if dim not in exclude:\n                all_coords[dim].append(obj.coords[dim])\n                try:\n                    index = obj.xindexes[dim]\n                except KeyError:\n                    unlabeled_dim_sizes[dim].add(obj.sizes[dim])\n                else:\n                    all_indexes[dim].append(index)\n    if join == 'override':\n        objects = _override_indexes(objects, all_indexes, exclude)\n    joined_indexes = {}\n    for dim, matching_indexes in all_indexes.items():\n        if dim in indexes:\n            index, _ = PandasIndex.from_pandas_index(safe_cast_to_index(indexes[dim]), dim)\n            if any((not index.equals(other) for other in matching_indexes)) or dim in unlabeled_dim_sizes:\n                joined_indexes[dim] = indexes[dim]\n        elif any((not matching_indexes[0].equals(other) for other in matching_indexes[1:])) or dim in unlabeled_dim_sizes:\n            if join == 'exact':\n                raise ValueError(f'indexes along dimension {dim!r} are not equal')\n            joiner = _get_joiner(join, type(matching_indexes[0]))\n            index = joiner(matching_indexes)\n            index = maybe_coerce_to_str(index.to_pandas_index(), all_coords[dim])\n            joined_indexes[dim] = index\n        else:\n            index = all_coords[dim][0]\n        if dim in unlabeled_dim_sizes:\n            unlabeled_sizes = unlabeled_dim_sizes[dim]\n            if isinstance(index, PandasIndex):\n                labeled_size = index.to_pandas_index().size\n            else:\n                labeled_size = index.size\n            if len(unlabeled_sizes | {labeled_size}) > 1:\n                raise ValueError(f'arguments without labels along dimension {dim!r} cannot be aligned because they have different dimension size(s) {unlabeled_sizes!r} than the size of the aligned dimension labels: {labeled_size!r}')\n    for dim, sizes in unlabeled_dim_sizes.items():\n        if dim not in all_indexes and len(sizes) > 1:\n            raise ValueError(f'arguments without labels along dimension {dim!r} cannot be aligned because they have different dimension sizes: {sizes!r}')\n    result = []\n    for obj in objects:\n        valid_indexers = {}\n        for k, index in joined_indexes.items():\n            if k in obj.dims:\n                if isinstance(index, Index):\n                    valid_indexers[k] = index.to_pandas_index()\n                else:\n                    valid_indexers[k] = index\n        if not valid_indexers:\n            new_obj = obj.copy(deep=copy)\n        else:\n            new_obj = obj.reindex(copy=copy, fill_value=fill_value, indexers=valid_indexers)\n        new_obj.encoding = obj.encoding\n        result.append(new_obj)\n    return tuple(result)",
    ".xarray.core.dataarray.py@@DataArray.dims": "def dims(self) -> Tuple[Hashable, ...]:\n    return self.variable.dims",
    ".xarray.core.dataarray.py@@DataArray.variable": "def variable(self) -> Variable:\n    return self._variable",
    ".xarray.core.variable.py@@Variable.dims": "def dims(self):\n    return self._dims",
    ".xarray.core.dataarray.py@@DataArray.coords": "def coords(self) -> DataArrayCoordinates:\n    return DataArrayCoordinates(self)",
    ".xarray.core.coordinates.py@@DataArrayCoordinates.__init__": "def __init__(self, dataarray: 'DataArray'):\n    self._data = dataarray",
    ".xarray.core.coordinates.py@@DataArrayCoordinates.__getitem__": "def __getitem__(self, key: Hashable) -> 'DataArray':\n    return self._data._getitem_coord(key)",
    ".xarray.core.dataarray.py@@DataArray._getitem_coord": "def _getitem_coord(self, key):\n    from .dataset import _get_virtual_variable\n    try:\n        var = self._coords[key]\n    except KeyError:\n        dim_sizes = dict(zip(self.dims, self.shape))\n        _, key, var = _get_virtual_variable(self._coords, key, self._level_coords, dim_sizes)\n    return self._replace_maybe_drop_dims(var, name=key)",
    ".xarray.core.dataarray.py@@DataArray.shape": "def shape(self) -> Tuple[int, ...]:\n    return self.variable.shape",
    ".xarray.core.variable.py@@Variable.shape": "def shape(self):\n    return self._data.shape",
    ".xarray.core.dataarray.py@@DataArray._level_coords": "def _level_coords(self) -> Dict[Hashable, Hashable]:\n    level_coords: Dict[Hashable, Hashable] = {}\n    for cname, var in self._coords.items():\n        if var.ndim == 1 and isinstance(var, IndexVariable):\n            level_names = var.level_names\n            if level_names is not None:\n                dim, = var.dims\n                level_coords.update({lname: dim for lname in level_names})\n    return level_coords",
    ".xarray.core.dataset.py@@_get_virtual_variable": "def _get_virtual_variable(variables, key: Hashable, level_vars: Mapping=None, dim_sizes: Mapping=None) -> Tuple[Hashable, Hashable, Variable]:\n    if level_vars is None:\n        level_vars = {}\n    if dim_sizes is None:\n        dim_sizes = {}\n    if key in dim_sizes:\n        data = pd.Index(range(dim_sizes[key]), name=key)\n        variable = IndexVariable((key,), data)\n        return (key, key, variable)\n    if not isinstance(key, str):\n        raise KeyError(key)\n    split_key = key.split('.', 1)\n    var_name: Optional[str]\n    if len(split_key) == 2:\n        ref_name, var_name = split_key\n    elif len(split_key) == 1:\n        ref_name, var_name = (key, None)\n    else:\n        raise KeyError(key)\n    if ref_name in level_vars:\n        dim_var = variables[level_vars[ref_name]]\n        ref_var = dim_var.to_index_variable().get_level_variable(ref_name)\n    else:\n        ref_var = variables[ref_name]\n    if var_name is None:\n        virtual_var = ref_var\n        var_name = key\n    else:\n        if _contains_datetime_like_objects(ref_var):\n            ref_var = xr.DataArray(ref_var)\n            data = getattr(ref_var.dt, var_name).data\n        else:\n            data = getattr(ref_var, var_name).data\n        virtual_var = Variable(ref_var.dims, data)\n    return (ref_name, var_name, virtual_var)",
    ".xarray.core.variable.py@@IndexVariable.__init__": "def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):\n    super().__init__(dims, data, attrs, encoding, fastpath)\n    if self.ndim != 1:\n        raise ValueError(f'{type(self).__name__} objects must be 1-dimensional')\n    if not isinstance(self._data, PandasIndexingAdapter):\n        self._data = PandasIndexingAdapter(self._data)",
    ".xarray.core.variable.py@@Variable.__init__": "def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):\n    self._data = as_compatible_data(data, fastpath=fastpath)\n    self._dims = self._parse_dimensions(dims)\n    self._attrs = None\n    self._encoding = None\n    if attrs is not None:\n        self.attrs = attrs\n    if encoding is not None:\n        self.encoding = encoding",
    ".xarray.core.variable.py@@as_compatible_data": "def as_compatible_data(data, fastpath=False):\n    if fastpath and getattr(data, 'ndim', 0) > 0:\n        return _maybe_wrap_data(data)\n    if isinstance(data, Variable):\n        return data.data\n    if isinstance(data, NON_NUMPY_SUPPORTED_ARRAY_TYPES):\n        return _maybe_wrap_data(data)\n    if isinstance(data, tuple):\n        data = utils.to_0d_object_array(data)\n    if isinstance(data, pd.Timestamp):\n        data = np.datetime64(data.value, 'ns')\n    if isinstance(data, timedelta):\n        data = np.timedelta64(getattr(data, 'value', data), 'ns')\n    if isinstance(data, (pd.Series, pd.Index, pd.DataFrame)):\n        data = data.values\n    if isinstance(data, np.ma.MaskedArray):\n        mask = np.ma.getmaskarray(data)\n        if mask.any():\n            dtype, fill_value = dtypes.maybe_promote(data.dtype)\n            data = np.asarray(data, dtype=dtype)\n            data[mask] = fill_value\n        else:\n            data = np.asarray(data)\n    if not isinstance(data, np.ndarray) and hasattr(data, '__array_function__'):\n        return data\n    data = np.asarray(data)\n    if isinstance(data, np.ndarray) and data.dtype.kind in 'OMm':\n        data = _possibly_convert_objects(data)\n    return _maybe_wrap_data(data)",
    ".xarray.core.variable.py@@_maybe_wrap_data": "def _maybe_wrap_data(data):\n    if isinstance(data, pd.Index):\n        return PandasIndexingAdapter(data)\n    return data",
    ".xarray.core.indexing.py@@PandasIndexingAdapter.__init__": "def __init__(self, array: pd.Index, dtype: DTypeLike=None):\n    self.array = utils.safe_cast_to_index(array)\n    if dtype is None:\n        if isinstance(array, pd.PeriodIndex):\n            dtype_ = np.dtype('O')\n        elif hasattr(array, 'categories'):\n            dtype_ = array.categories.dtype\n        elif not utils.is_valid_numpy_dtype(array.dtype):\n            dtype_ = np.dtype('O')\n        else:\n            dtype_ = array.dtype\n    else:\n        dtype_ = np.dtype(dtype)\n    self._dtype = dtype_",
    ".xarray.core.utils.py@@safe_cast_to_index": "def safe_cast_to_index(array: Any) -> pd.Index:\n    if isinstance(array, pd.Index):\n        index = array\n    elif hasattr(array, 'to_index'):\n        index = array.to_index()\n    elif hasattr(array, 'to_pandas_index'):\n        index = array.to_pandas_index()\n    else:\n        kwargs = {}\n        if hasattr(array, 'dtype') and array.dtype.kind == 'O':\n            kwargs['dtype'] = object\n        index = pd.Index(np.asarray(array), **kwargs)\n    return _maybe_cast_to_cftimeindex(index)",
    ".xarray.core.utils.py@@_maybe_cast_to_cftimeindex": "def _maybe_cast_to_cftimeindex(index: pd.Index) -> pd.Index:\n    from ..coding.cftimeindex import CFTimeIndex\n    if len(index) > 0 and index.dtype == 'O':\n        try:\n            return CFTimeIndex(index)\n        except (ImportError, TypeError):\n            return index\n    else:\n        return index",
    ".xarray.core.utils.py@@is_valid_numpy_dtype": "def is_valid_numpy_dtype(dtype: Any) -> bool:\n    try:\n        np.dtype(dtype)\n    except (TypeError, ValueError):\n        return False\n    else:\n        return True",
    ".xarray.core.variable.py@@Variable._parse_dimensions": "def _parse_dimensions(self, dims):\n    if isinstance(dims, str):\n        dims = (dims,)\n    dims = tuple(dims)\n    if len(dims) != self.ndim:\n        raise ValueError(f'dimensions {dims} must have the same length as the number of data dimensions, ndim={self.ndim}')\n    return dims",
    ".xarray.core.utils.py@@NdimSizeLenMixin.ndim": "def ndim(self: Any) -> int:\n    return len(self.shape)",
    ".xarray.core.indexing.py@@PandasIndexingAdapter.shape": "def shape(self) -> Tuple[int]:\n    return (len(self.array),)",
    ".xarray.core.dataarray.py@@DataArray._replace_maybe_drop_dims": "def _replace_maybe_drop_dims(self, variable: Variable, name: Union[Hashable, None, Default]=_default) -> 'DataArray':\n    if variable.dims == self.dims and variable.shape == self.shape:\n        coords = self._coords.copy()\n        indexes = self._indexes\n    elif variable.dims == self.dims:\n        new_sizes = dict(zip(self.dims, variable.shape))\n        coords = {k: v for k, v in self._coords.items() if v.shape == tuple((new_sizes[d] for d in v.dims))}\n        changed_dims = [k for k in variable.dims if variable.sizes[k] != self.sizes[k]]\n        indexes = propagate_indexes(self._indexes, exclude=changed_dims)\n    else:\n        allowed_dims = set(variable.dims)\n        coords = {k: v for k, v in self._coords.items() if set(v.dims) <= allowed_dims}\n        indexes = propagate_indexes(self._indexes, exclude=set(self.dims) - allowed_dims)\n    return self._replace(variable, coords, name, indexes=indexes)",
    ".xarray.core.indexes.py@@propagate_indexes": "def propagate_indexes(indexes: Optional[Dict[Hashable, Index]], exclude: Optional[Any]=None) -> Optional[Dict[Hashable, Index]]:\n    if exclude is None:\n        exclude = ()\n    if is_scalar(exclude):\n        exclude = (exclude,)\n    if indexes is not None:\n        new_indexes = {k: v for k, v in indexes.items() if k not in exclude}\n    else:\n        new_indexes = None\n    return new_indexes",
    ".xarray.core.utils.py@@is_scalar": "def is_scalar(value: Any, include_0d: bool=True) -> TypeGuard[Hashable]:\n    return _is_scalar(value, include_0d)",
    ".xarray.core.utils.py@@_is_scalar": "def _is_scalar(value, include_0d):\n    from .variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\n    if include_0d:\n        include_0d = getattr(value, 'ndim', None) == 0\n    return include_0d or isinstance(value, (str, bytes)) or (not (isinstance(value, (Iterable,) + NON_NUMPY_SUPPORTED_ARRAY_TYPES) or hasattr(value, '__array_function__')))",
    ".xarray.core.dataarray.py@@DataArray._replace": "def _replace(self: T_DataArray, variable: Variable=None, coords=None, name: Union[Hashable, None, Default]=_default, indexes=None) -> T_DataArray:\n    if variable is None:\n        variable = self.variable\n    if coords is None:\n        coords = self._coords\n    if name is _default:\n        name = self.name\n    return type(self)(variable, coords, name=name, fastpath=True, indexes=indexes)",
    ".xarray.core.dataarray.py@@DataArray.__init__": "def __init__(self, data: Any=dtypes.NA, coords: Union[Sequence[Tuple], Mapping[Any, Any], None]=None, dims: Union[Hashable, Sequence[Hashable], None]=None, name: Hashable=None, attrs: Mapping=None, indexes: Dict[Hashable, pd.Index]=None, fastpath: bool=False):\n    if fastpath:\n        variable = data\n        assert dims is None\n        assert attrs is None\n    else:\n        if coords is None:\n            if isinstance(data, DataArray):\n                coords = data.coords\n            elif isinstance(data, pd.Series):\n                coords = [data.index]\n            elif isinstance(data, pd.DataFrame):\n                coords = [data.index, data.columns]\n            elif isinstance(data, (pd.Index, IndexVariable)):\n                coords = [data]\n            elif isinstance(data, pdcompat.Panel):\n                coords = [data.items, data.major_axis, data.minor_axis]\n        if dims is None:\n            dims = getattr(data, 'dims', getattr(coords, 'dims', None))\n        if name is None:\n            name = getattr(data, 'name', None)\n        if attrs is None and (not isinstance(data, PANDAS_TYPES)):\n            attrs = getattr(data, 'attrs', None)\n        data = _check_data_shape(data, coords, dims)\n        data = as_compatible_data(data)\n        coords, dims = _infer_coords_and_dims(data.shape, coords, dims)\n        variable = Variable(dims, data, attrs, fastpath=True)\n        indexes = dict(_extract_indexes_from_coords(coords))\n    self._variable = variable\n    assert isinstance(coords, dict)\n    self._coords = coords\n    self._name = name\n    self._indexes = indexes\n    self._close = None",
    ".xarray.core.common.py@@AttrAccessMixin.__setattr__": "def __setattr__(self, name: str, value: Any) -> None:\n    try:\n        object.__setattr__(self, name, value)\n    except AttributeError as e:\n        if str(e) != '{!r} object has no attribute {!r}'.format(type(self).__name__, name):\n            raise\n        raise AttributeError(f\"cannot set attribute {name!r} on a {type(self).__name__!r} object. Use __setitem__ styleassignment (e.g., `ds['name'] = ...`) instead of assigning variables.\") from e",
    ".xarray.core.dataarray.py@@DataArray.xindexes": "def xindexes(self) -> Indexes:\n    if self._indexes is None:\n        self._indexes = default_indexes(self._coords, self.dims)\n    return Indexes(self._indexes)",
    ".xarray.core.indexes.py@@Indexes.__init__": "def __init__(self, indexes: Mapping[Any, Union[pd.Index, Index]]) -> None:\n    self._indexes = indexes",
    ".xarray.core.indexes.py@@Indexes.__getitem__": "def __getitem__(self, key) -> pd.Index:\n    return self._indexes[key]",
    ".xarray.core.common.py@@AbstractArray.sizes": "def sizes(self: Any) -> Mapping[Hashable, int]:\n    return Frozen(dict(zip(self.dims, self.shape)))",
    ".xarray.core.utils.py@@Frozen.__init__": "def __init__(self, mapping: Mapping[K, V]):\n    self.mapping = mapping",
    ".xarray.core.utils.py@@Frozen.__getitem__": "def __getitem__(self, key: K) -> V:\n    return self.mapping[key]",
    ".xarray.core.dataarray.py@@DataArray.copy": "def copy(self: T_DataArray, deep: bool=True, data: Any=None) -> T_DataArray:\n    variable = self.variable.copy(deep=deep, data=data)\n    coords = {k: v.copy(deep=deep) for k, v in self._coords.items()}\n    if self._indexes is None:\n        indexes = self._indexes\n    else:\n        indexes = {k: v.copy(deep=deep) for k, v in self._indexes.items()}\n    return self._replace(variable, coords, indexes=indexes)",
    ".xarray.core.variable.py@@Variable.copy": "def copy(self, deep=True, data=None):\n    if data is None:\n        data = self._data\n        if isinstance(data, indexing.MemoryCachedArray):\n            data = indexing.MemoryCachedArray(data.array)\n        if deep:\n            data = copy.deepcopy(data)\n    else:\n        data = as_compatible_data(data)\n        if self.shape != data.shape:\n            raise ValueError('Data shape {} must match shape of object {}'.format(data.shape, self.shape))\n    return self._replace(data=data)",
    ".xarray.core.variable.py@@Variable._replace": "def _replace(self: T_Variable, dims=_default, data=_default, attrs=_default, encoding=_default) -> T_Variable:\n    if dims is _default:\n        dims = copy.copy(self._dims)\n    if data is _default:\n        data = copy.copy(self.data)\n    if attrs is _default:\n        attrs = copy.copy(self._attrs)\n    if encoding is _default:\n        encoding = copy.copy(self._encoding)\n    return type(self)(dims, data, attrs, encoding, fastpath=True)",
    ".xarray.core.variable.py@@Variable.attrs": "def attrs(self) -> Dict[Hashable, Any]:\n    if self._attrs is None:\n        self._attrs = {}\n    return self._attrs",
    ".xarray.core.dataarray.py@@DataArray.name": "def name(self) -> Optional[Hashable]:\n    return self._name",
    ".xarray.core.dataarray.py@@DataArray.encoding": "def encoding(self) -> Dict[Hashable, Any]:\n    return self.variable.encoding",
    ".xarray.core.variable.py@@Variable.encoding": "def encoding(self):\n    if self._encoding is None:\n        self._encoding = {}\n    return self._encoding",
    ".xarray.core.common.py@@DataWithCoords.notnull": "def notnull(self, keep_attrs: bool=None):\n    from .computation import apply_ufunc\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=False)\n    return apply_ufunc(duck_array_ops.notnull, self, dask='allowed', keep_attrs=keep_attrs)",
    ".xarray.core.options.py@@_get_keep_attrs": "def _get_keep_attrs(default):\n    return _get_boolean_with_default('keep_attrs', default)",
    ".xarray.core.options.py@@_get_boolean_with_default": "def _get_boolean_with_default(option, default):\n    global_choice = OPTIONS[option]\n    if global_choice == 'default':\n        return default\n    elif global_choice in [True, False]:\n        return global_choice\n    else:\n        raise ValueError(f\"The global option {option} must be one of True, False or 'default'.\")",
    ".xarray.core.computation.py@@apply_ufunc": "def apply_ufunc(func: Callable, *args: Any, input_core_dims: Sequence[Sequence]=None, output_core_dims: Optional[Sequence[Sequence]]=((),), exclude_dims: AbstractSet=frozenset(), vectorize: bool=False, join: str='exact', dataset_join: str='exact', dataset_fill_value: object=_NO_FILL_VALUE, keep_attrs: Union[bool, str]=None, kwargs: Mapping=None, dask: str='forbidden', output_dtypes: Sequence=None, output_sizes: Mapping[Any, int]=None, meta: Any=None, dask_gufunc_kwargs: Dict[str, Any]=None) -> Any:\n    from .dataarray import DataArray\n    from .groupby import GroupBy\n    from .variable import Variable\n    if input_core_dims is None:\n        input_core_dims = ((),) * len(args)\n    elif len(input_core_dims) != len(args):\n        raise ValueError(f'input_core_dims must be None or a tuple with the length same to the number of arguments. Given {len(input_core_dims)} input_core_dims: {input_core_dims},  but number of args is {len(args)}.')\n    if kwargs is None:\n        kwargs = {}\n    signature = _UFuncSignature(input_core_dims, output_core_dims)\n    if exclude_dims:\n        if not isinstance(exclude_dims, set):\n            raise TypeError(f\"Expected exclude_dims to be a 'set'. Received '{type(exclude_dims).__name__}' instead.\")\n        if not exclude_dims <= signature.all_core_dims:\n            raise ValueError(f'each dimension in `exclude_dims` must also be a core dimension in the function signature. Please make {exclude_dims - signature.all_core_dims} a core dimension')\n    if dask == 'parallelized':\n        if dask_gufunc_kwargs is None:\n            dask_gufunc_kwargs = {}\n        else:\n            dask_gufunc_kwargs = dask_gufunc_kwargs.copy()\n        if meta is not None:\n            warnings.warn('``meta`` should be given in the ``dask_gufunc_kwargs`` parameter. It will be removed as direct parameter in a future version.', FutureWarning, stacklevel=2)\n            dask_gufunc_kwargs.setdefault('meta', meta)\n        if output_sizes is not None:\n            warnings.warn('``output_sizes`` should be given in the ``dask_gufunc_kwargs`` parameter. It will be removed as direct parameter in a future version.', FutureWarning, stacklevel=2)\n            dask_gufunc_kwargs.setdefault('output_sizes', output_sizes)\n    if kwargs:\n        func = functools.partial(func, **kwargs)\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=False)\n    if isinstance(keep_attrs, bool):\n        keep_attrs = 'override' if keep_attrs else 'drop'\n    variables_vfunc = functools.partial(apply_variable_ufunc, func, signature=signature, exclude_dims=exclude_dims, keep_attrs=keep_attrs, dask=dask, vectorize=vectorize, output_dtypes=output_dtypes, dask_gufunc_kwargs=dask_gufunc_kwargs)\n    if any((isinstance(a, GroupBy) for a in args)):\n        this_apply = functools.partial(apply_ufunc, func, input_core_dims=input_core_dims, output_core_dims=output_core_dims, exclude_dims=exclude_dims, join=join, dataset_join=dataset_join, dataset_fill_value=dataset_fill_value, keep_attrs=keep_attrs, dask=dask, vectorize=vectorize, output_dtypes=output_dtypes, dask_gufunc_kwargs=dask_gufunc_kwargs)\n        return apply_groupby_func(this_apply, *args)\n    elif any((is_dict_like(a) for a in args)):\n        return apply_dataset_vfunc(variables_vfunc, *args, signature=signature, join=join, exclude_dims=exclude_dims, dataset_join=dataset_join, fill_value=dataset_fill_value, keep_attrs=keep_attrs)\n    elif any((isinstance(a, DataArray) for a in args)):\n        return apply_dataarray_vfunc(variables_vfunc, *args, signature=signature, join=join, exclude_dims=exclude_dims, keep_attrs=keep_attrs)\n    elif any((isinstance(a, Variable) for a in args)):\n        return variables_vfunc(*args)\n    else:\n        return apply_array_ufunc(func, *args, dask=dask)",
    ".xarray.core.computation.py@@_UFuncSignature.__init__": "def __init__(self, input_core_dims, output_core_dims=((),)):\n    self.input_core_dims = tuple((tuple(a) for a in input_core_dims))\n    self.output_core_dims = tuple((tuple(a) for a in output_core_dims))\n    self._all_input_core_dims = None\n    self._all_output_core_dims = None\n    self._all_core_dims = None",
    ".xarray.core.utils.py@@is_dict_like": "def is_dict_like(value: Any) -> bool:\n    return hasattr(value, 'keys') and hasattr(value, '__getitem__')",
    ".xarray.core.common.py@@AttrAccessMixin.__getattr__": "def __getattr__(self, name: str) -> Any:\n    if name not in {'__dict__', '__setstate__'}:\n        for source in self._attr_sources:\n            with suppress(KeyError):\n                return source[name]\n    raise AttributeError('{!r} object has no attribute {!r}'.format(type(self).__name__, name))",
    ".xarray.core.dataarray.py@@DataArray._attr_sources": "def _attr_sources(self) -> Iterable[Mapping[Hashable, Any]]:\n    yield from self._item_sources\n    yield self.attrs",
    ".xarray.core.dataarray.py@@DataArray._item_sources": "def _item_sources(self) -> Iterable[Mapping[Hashable, Any]]:\n    yield HybridMappingProxy(keys=self._coords, mapping=self.coords)\n    yield HybridMappingProxy(keys=self.dims, mapping={})\n    yield HybridMappingProxy(keys=self._level_coords, mapping={})",
    ".xarray.core.utils.py@@HybridMappingProxy.__init__": "def __init__(self, keys: Collection[K], mapping: Mapping[K, V]):\n    self._keys = keys\n    self.mapping = mapping",
    ".xarray.core.utils.py@@HybridMappingProxy.__getitem__": "def __getitem__(self, key: K) -> V:\n    return self.mapping[key]",
    ".xarray.core.dataarray.py@@DataArray.attrs": "def attrs(self) -> Dict[Any, Any]:\n    return self.variable.attrs",
    ".xarray.core.computation.py@@apply_dataarray_vfunc": "def apply_dataarray_vfunc(func, *args, signature, join='inner', exclude_dims=frozenset(), keep_attrs='override'):\n    from .dataarray import DataArray\n    if len(args) > 1:\n        args = deep_align(args, join=join, copy=False, exclude=exclude_dims, raise_on_invalid=False)\n    objs = _all_of_type(args, DataArray)\n    if keep_attrs == 'drop':\n        name = result_name(args)\n    else:\n        first_obj = _first_of_type(args, DataArray)\n        name = first_obj.name\n    result_coords = build_output_coords(args, signature, exclude_dims, combine_attrs=keep_attrs)\n    data_vars = [getattr(a, 'variable', a) for a in args]\n    result_var = func(*data_vars)\n    if signature.num_outputs > 1:\n        out = tuple((DataArray(variable, coords, name=name, fastpath=True) for variable, coords in zip(result_var, result_coords)))\n    else:\n        coords, = result_coords\n        out = DataArray(result_var, coords, name=name, fastpath=True)\n    attrs = merge_attrs([x.attrs for x in objs], combine_attrs=keep_attrs)\n    if isinstance(out, tuple):\n        for da in out:\n            da.attrs = attrs\n    else:\n        out.attrs = attrs\n    return out",
    ".xarray.core.computation.py@@_all_of_type": "def _all_of_type(args, kind):\n    return [arg for arg in args if isinstance(arg, kind)]",
    ".xarray.core.computation.py@@result_name": "def result_name(objects: list) -> Any:\n    names = {getattr(obj, 'name', _DEFAULT_NAME) for obj in objects}\n    names.discard(_DEFAULT_NAME)\n    if len(names) == 1:\n        name, = names\n    else:\n        name = None\n    return name",
    ".xarray.core.utils.py@@ReprObject.__hash__": "def __hash__(self) -> int:\n    return hash((type(self), self._value))",
    ".xarray.core.computation.py@@build_output_coords": "def build_output_coords(args: list, signature: _UFuncSignature, exclude_dims: AbstractSet=frozenset(), combine_attrs: str='override') -> 'List[Dict[Any, Variable]]':\n    coords_list = _get_coords_list(args)\n    if len(coords_list) == 1 and (not exclude_dims):\n        unpacked_coords, = coords_list\n        merged_vars = dict(unpacked_coords.variables)\n    else:\n        merged_vars, unused_indexes = merge_coordinates_without_align(coords_list, exclude_dims=exclude_dims, combine_attrs=combine_attrs)\n    output_coords = []\n    for output_dims in signature.output_core_dims:\n        dropped_dims = signature.all_input_core_dims - set(output_dims)\n        if dropped_dims:\n            filtered = {k: v for k, v in merged_vars.items() if dropped_dims.isdisjoint(v.dims)}\n        else:\n            filtered = merged_vars\n        output_coords.append(filtered)\n    return output_coords",
    ".xarray.core.computation.py@@_get_coords_list": "def _get_coords_list(args) -> List[Coordinates]:\n    coords_list = []\n    for arg in args:\n        try:\n            coords = arg.coords\n        except AttributeError:\n            pass\n        else:\n            coords_list.append(coords)\n    return coords_list",
    ".xarray.core.coordinates.py@@DataArrayCoordinates.variables": "def variables(self):\n    return Frozen(self._data._coords)",
    ".xarray.core.utils.py@@Frozen.__iter__": "def __iter__(self) -> Iterator[K]:\n    return iter(self.mapping)",
    ".xarray.core.computation.py@@_UFuncSignature.all_input_core_dims": "def all_input_core_dims(self):\n    if self._all_input_core_dims is None:\n        self._all_input_core_dims = frozenset((dim for dims in self.input_core_dims for dim in dims))\n    return self._all_input_core_dims",
    ".xarray.core.computation.py@@apply_variable_ufunc": "def apply_variable_ufunc(func, *args, signature, exclude_dims=frozenset(), dask='forbidden', output_dtypes=None, vectorize=False, keep_attrs='override', dask_gufunc_kwargs=None):\n    from .variable import Variable, as_compatible_data\n    dim_sizes = unified_dim_sizes((a for a in args if hasattr(a, 'dims')), exclude_dims=exclude_dims)\n    broadcast_dims = tuple((dim for dim in dim_sizes if dim not in signature.all_core_dims))\n    output_dims = [broadcast_dims + out for out in signature.output_core_dims]\n    input_data = [broadcast_compat_data(arg, broadcast_dims, core_dims) if isinstance(arg, Variable) else arg for arg, core_dims in zip(args, signature.input_core_dims)]\n    if any((is_duck_dask_array(array) for array in input_data)):\n        if dask == 'forbidden':\n            raise ValueError('apply_ufunc encountered a dask array on an argument, but handling for dask arrays has not been enabled. Either set the ``dask`` argument or load your data into memory first with ``.load()`` or ``.compute()``')\n        elif dask == 'parallelized':\n            numpy_func = func\n            if dask_gufunc_kwargs is None:\n                dask_gufunc_kwargs = {}\n            else:\n                dask_gufunc_kwargs = dask_gufunc_kwargs.copy()\n            allow_rechunk = dask_gufunc_kwargs.get('allow_rechunk', None)\n            if allow_rechunk is None:\n                for n, (data, core_dims) in enumerate(zip(input_data, signature.input_core_dims)):\n                    if is_duck_dask_array(data):\n                        for axis, dim in enumerate(core_dims, start=-len(core_dims)):\n                            if len(data.chunks[axis]) != 1:\n                                raise ValueError(f\"dimension {dim} on {n}th function argument to apply_ufunc with dask='parallelized' consists of multiple chunks, but is also a core dimension. To fix, either rechunk into a single dask array chunk along this dimension, i.e., ``.chunk(dict({dim}=-1))``, or pass ``allow_rechunk=True`` in ``dask_gufunc_kwargs`` but beware that this may significantly increase memory usage.\")\n                dask_gufunc_kwargs['allow_rechunk'] = True\n            output_sizes = dask_gufunc_kwargs.pop('output_sizes', {})\n            if output_sizes:\n                output_sizes_renamed = {}\n                for key, value in output_sizes.items():\n                    if key not in signature.all_output_core_dims:\n                        raise ValueError(f\"dimension '{key}' in 'output_sizes' must correspond to output_core_dims\")\n                    output_sizes_renamed[signature.dims_map[key]] = value\n                dask_gufunc_kwargs['output_sizes'] = output_sizes_renamed\n            for key in signature.all_output_core_dims:\n                if key not in signature.all_input_core_dims and key not in output_sizes:\n                    raise ValueError(f\"dimension '{key}' in 'output_core_dims' needs corresponding (dim, size) in 'output_sizes'\")\n\n            def func(*arrays):\n                import dask.array as da\n                res = da.apply_gufunc(numpy_func, signature.to_gufunc_string(exclude_dims), *arrays, vectorize=vectorize, output_dtypes=output_dtypes, **dask_gufunc_kwargs)\n                return res\n        elif dask == 'allowed':\n            pass\n        else:\n            raise ValueError('unknown setting for dask array handling in apply_ufunc: {}'.format(dask))\n    elif vectorize:\n        func = _vectorize(func, signature, output_dtypes=output_dtypes, exclude_dims=exclude_dims)\n    result_data = func(*input_data)\n    if signature.num_outputs == 1:\n        result_data = (result_data,)\n    elif not isinstance(result_data, tuple) or len(result_data) != signature.num_outputs:\n        raise ValueError('applied function does not have the number of outputs specified in the ufunc signature. Result is not a tuple of {} elements: {!r}'.format(signature.num_outputs, result_data))\n    objs = _all_of_type(args, Variable)\n    attrs = merge_attrs([obj.attrs for obj in objs], combine_attrs=keep_attrs)\n    output = []\n    for dims, data in zip(output_dims, result_data):\n        data = as_compatible_data(data)\n        if data.ndim != len(dims):\n            raise ValueError(f'applied function returned data with unexpected number of dimensions. Received {data.ndim} dimension(s) but expected {len(dims)} dimensions with names: {dims!r}')\n        var = Variable(dims, data, fastpath=True)\n        for dim, new_size in var.sizes.items():\n            if dim in dim_sizes and new_size != dim_sizes[dim]:\n                raise ValueError('size of dimension {!r} on inputs was unexpectedly changed by applied function from {} to {}. Only dimensions specified in ``exclude_dims`` with xarray.apply_ufunc are allowed to change size.'.format(dim, dim_sizes[dim], new_size))\n        var.attrs = attrs\n        output.append(var)\n    if signature.num_outputs == 1:\n        return output[0]\n    else:\n        return tuple(output)",
    ".xarray.core.computation.py@@unified_dim_sizes": "def unified_dim_sizes(variables: Iterable[Variable], exclude_dims: AbstractSet=frozenset()) -> Dict[Hashable, int]:\n    dim_sizes: Dict[Hashable, int] = {}\n    for var in variables:\n        if len(set(var.dims)) < len(var.dims):\n            raise ValueError(f'broadcasting cannot handle duplicate dimensions on a variable: {list(var.dims)}')\n        for dim, size in zip(var.dims, var.shape):\n            if dim not in exclude_dims:\n                if dim not in dim_sizes:\n                    dim_sizes[dim] = size\n                elif dim_sizes[dim] != size:\n                    raise ValueError(f'operands cannot be broadcast together with mismatched lengths for dimension {dim}: {dim_sizes[dim]} vs {size}')\n    return dim_sizes",
    ".xarray.core.computation.py@@_UFuncSignature.all_core_dims": "def all_core_dims(self):\n    if self._all_core_dims is None:\n        self._all_core_dims = self.all_input_core_dims | self.all_output_core_dims\n    return self._all_core_dims",
    ".xarray.core.computation.py@@_UFuncSignature.all_output_core_dims": "def all_output_core_dims(self):\n    if self._all_output_core_dims is None:\n        self._all_output_core_dims = frozenset((dim for dims in self.output_core_dims for dim in dims))\n    return self._all_output_core_dims",
    ".xarray.core.computation.py@@broadcast_compat_data": "def broadcast_compat_data(variable: Variable, broadcast_dims: Tuple[Hashable, ...], core_dims: Tuple[Hashable, ...]) -> Any:\n    data = variable.data\n    old_dims = variable.dims\n    new_dims = broadcast_dims + core_dims\n    if new_dims == old_dims:\n        return data\n    set_old_dims = set(old_dims)\n    missing_core_dims = [d for d in core_dims if d not in set_old_dims]\n    if missing_core_dims:\n        raise ValueError('operand to apply_ufunc has required core dimensions {}, but some of these dimensions are absent on an input variable: {}'.format(list(core_dims), missing_core_dims))\n    set_new_dims = set(new_dims)\n    unexpected_dims = [d for d in old_dims if d not in set_new_dims]\n    if unexpected_dims:\n        raise ValueError(f'operand to apply_ufunc encountered unexpected dimensions {unexpected_dims!r} on an input variable: these are core dimensions on other input or output variables')\n    old_broadcast_dims = tuple((d for d in broadcast_dims if d in set_old_dims))\n    reordered_dims = old_broadcast_dims + core_dims\n    if reordered_dims != old_dims:\n        order = tuple((old_dims.index(d) for d in reordered_dims))\n        data = duck_array_ops.transpose(data, order)\n    if new_dims != reordered_dims:\n        key_parts: List[Optional[slice]] = []\n        for dim in new_dims:\n            if dim in set_old_dims:\n                key_parts.append(SLICE_NONE)\n            elif key_parts:\n                key_parts.append(np.newaxis)\n        data = data[tuple(key_parts)]\n    return data",
    ".xarray.core.variable.py@@Variable.data": "def data(self):\n    if is_duck_array(self._data):\n        return self._data\n    else:\n        return self.values",
    ".xarray.core.utils.py@@is_duck_array": "def is_duck_array(value: Any) -> bool:\n    if isinstance(value, np.ndarray):\n        return True\n    return hasattr(value, 'ndim') and hasattr(value, 'shape') and hasattr(value, 'dtype') and hasattr(value, '__array_function__') and hasattr(value, '__array_ufunc__')",
    ".xarray.core.pycompat.py@@is_duck_dask_array": "def is_duck_dask_array(x):\n    return is_duck_array(x) and is_dask_collection(x)",
    ".xarray.core.pycompat.py@@is_dask_collection": "def is_dask_collection(x):\n    if DuckArrayModule('dask').available:\n        from dask.base import is_dask_collection\n        return is_dask_collection(x)\n    else:\n        return False",
    ".xarray.core.pycompat.py@@DuckArrayModule.__init__": "def __init__(self, mod):\n    try:\n        duck_array_module = import_module(mod)\n        duck_array_version = LooseVersion(duck_array_module.__version__)\n        if mod == 'dask':\n            duck_array_type = (import_module('dask.array').Array,)\n        elif mod == 'pint':\n            duck_array_type = (duck_array_module.Quantity,)\n        elif mod == 'cupy':\n            duck_array_type = (duck_array_module.ndarray,)\n        elif mod == 'sparse':\n            duck_array_type = (duck_array_module.SparseArray,)\n        else:\n            raise NotImplementedError\n    except ImportError:\n        duck_array_module = None\n        duck_array_version = LooseVersion('0.0.0')\n        duck_array_type = ()\n    self.module = duck_array_module\n    self.version = duck_array_version\n    self.type = duck_array_type\n    self.available = duck_array_module is not None",
    ".xarray.core.duck_array_ops.py@@notnull": "def notnull(data):\n    return ~isnull(data)",
    ".xarray.core.duck_array_ops.py@@isnull": "def isnull(data):\n    data = asarray(data)\n    scalar_type = data.dtype.type\n    if issubclass(scalar_type, (np.datetime64, np.timedelta64)):\n        return isnat(data)\n    elif issubclass(scalar_type, np.inexact):\n        return isnan(data)\n    elif issubclass(scalar_type, (np.bool_, np.integer, np.character, np.void)):\n        return zeros_like(data, dtype=bool)\n    elif isinstance(data, (np.ndarray, dask_array_type)):\n        return pandas_isnull(data)\n    else:\n        return data != data",
    ".xarray.core.duck_array_ops.py@@asarray": "def asarray(data, xp=np):\n    return data if is_duck_array(data) else xp.asarray(data)",
    ".xarray.core.computation.py@@_UFuncSignature.num_outputs": "def num_outputs(self):\n    return len(self.output_core_dims)",
    ".xarray.core.merge.py@@merge_attrs": "def merge_attrs(variable_attrs, combine_attrs, context=None):\n    if not variable_attrs:\n        return None\n    if callable(combine_attrs):\n        return combine_attrs(variable_attrs, context=context)\n    elif combine_attrs == 'drop':\n        return {}\n    elif combine_attrs == 'override':\n        return dict(variable_attrs[0])\n    elif combine_attrs == 'no_conflicts':\n        result = dict(variable_attrs[0])\n        for attrs in variable_attrs[1:]:\n            try:\n                result = compat_dict_union(result, attrs)\n            except ValueError as e:\n                raise MergeError(f\"combine_attrs='no_conflicts', but some values are not the same. Merging {str(result)} with {str(attrs)}\") from e\n        return result\n    elif combine_attrs == 'drop_conflicts':\n        result = {}\n        dropped_keys = set()\n        for attrs in variable_attrs:\n            result.update({key: value for key, value in attrs.items() if key not in result and key not in dropped_keys})\n            result = {key: value for key, value in result.items() if key not in attrs or equivalent(attrs[key], value)}\n            dropped_keys |= {key for key in attrs if key not in result}\n        return result\n    elif combine_attrs == 'identical':\n        result = dict(variable_attrs[0])\n        for attrs in variable_attrs[1:]:\n            if not dict_equiv(result, attrs):\n                raise MergeError(f\"combine_attrs='identical', but attrs differ. First is {str(result)} , other is {str(attrs)}.\")\n        return result\n    else:\n        raise ValueError(f'Unrecognised value for combine_attrs={combine_attrs}')",
    ".xarray.core._typed_ops.py@@DataArrayOpsMixin.__and__": "def __and__(self, other):\n    return self._binary_op(other, operator.and_)",
    ".xarray.core.dataarray.py@@DataArray._binary_op": "def _binary_op(self, other, f: Callable, reflexive: bool=False):\n    if isinstance(other, (Dataset, groupby.GroupBy)):\n        return NotImplemented\n    if isinstance(other, DataArray):\n        align_type = OPTIONS['arithmetic_join']\n        self, other = align(self, other, join=align_type, copy=False)\n    other_variable = getattr(other, 'variable', other)\n    other_coords = getattr(other, 'coords', None)\n    variable = f(self.variable, other_variable) if not reflexive else f(other_variable, self.variable)\n    coords, indexes = self.coords._merge_raw(other_coords, reflexive)\n    name = self._result_name(other)\n    return self._replace(variable, coords, name, indexes=indexes)",
    ".xarray.core.indexes.py@@default_indexes": "def default_indexes(coords: Mapping[Any, 'Variable'], dims: Iterable) -> Dict[Hashable, Index]:\n    return {key: coords[key]._to_xindex() for key in dims if key in coords}",
    ".xarray.core._typed_ops.py@@VariableOpsMixin.__and__": "def __and__(self, other):\n    return self._binary_op(other, operator.and_)",
    ".xarray.core.variable.py@@Variable._binary_op": "def _binary_op(self, other, f, reflexive=False):\n    if isinstance(other, (xr.DataArray, xr.Dataset)):\n        return NotImplemented\n    if reflexive and issubclass(type(self), type(other)):\n        other_data, self_data, dims = _broadcast_compat_data(other, self)\n    else:\n        self_data, other_data, dims = _broadcast_compat_data(self, other)\n    keep_attrs = _get_keep_attrs(default=False)\n    attrs = self._attrs if keep_attrs else None\n    with np.errstate(all='ignore'):\n        new_data = f(self_data, other_data) if not reflexive else f(other_data, self_data)\n    result = Variable(dims, new_data, attrs=attrs)\n    return result",
    ".xarray.core.variable.py@@_broadcast_compat_data": "def _broadcast_compat_data(self, other):\n    if all((hasattr(other, attr) for attr in ['dims', 'data', 'shape', 'encoding'])):\n        new_self, new_other = _broadcast_compat_variables(self, other)\n        self_data = new_self.data\n        other_data = new_other.data\n        dims = new_self.dims\n    else:\n        self_data = self.data\n        other_data = other\n        dims = self.dims\n    return (self_data, other_data, dims)",
    ".xarray.core.variable.py@@_broadcast_compat_variables": "def _broadcast_compat_variables(*variables):\n    dims = tuple(_unified_dims(variables))\n    return tuple((var.set_dims(dims) if var.dims != dims else var for var in variables))",
    ".xarray.core.variable.py@@_unified_dims": "def _unified_dims(variables):\n    all_dims = {}\n    for var in variables:\n        var_dims = var.dims\n        if len(set(var_dims)) < len(var_dims):\n            raise ValueError(f'broadcasting cannot handle duplicate dimensions: {list(var_dims)!r}')\n        for d, s in zip(var_dims, var.shape):\n            if d not in all_dims:\n                all_dims[d] = s\n            elif all_dims[d] != s:\n                raise ValueError(f'operands cannot be broadcast together with mismatched lengths for dimension {d!r}: {(all_dims[d], s)}')\n    return all_dims",
    ".xarray.core.coordinates.py@@Coordinates._merge_raw": "def _merge_raw(self, other, reflexive):\n    if other is None:\n        variables = dict(self.variables)\n        indexes = dict(self.xindexes)\n    else:\n        coord_list = [self, other] if not reflexive else [other, self]\n        variables, indexes = merge_coordinates_without_align(coord_list)\n    return (variables, indexes)",
    ".xarray.core.merge.py@@merge_coordinates_without_align": "def merge_coordinates_without_align(objects: 'List[Coordinates]', prioritized: Mapping[Any, MergeElement]=None, exclude_dims: AbstractSet=frozenset(), combine_attrs: str='override') -> Tuple[Dict[Hashable, Variable], Dict[Hashable, Index]]:\n    collected = collect_from_coordinates(objects)\n    if exclude_dims:\n        filtered: Dict[Hashable, List[MergeElement]] = {}\n        for name, elements in collected.items():\n            new_elements = [(variable, index) for variable, index in elements if exclude_dims.isdisjoint(variable.dims)]\n            if new_elements:\n                filtered[name] = new_elements\n    else:\n        filtered = collected\n    return merge_collected(filtered, prioritized, combine_attrs=combine_attrs)",
    ".xarray.core.merge.py@@collect_from_coordinates": "def collect_from_coordinates(list_of_coords: 'List[Coordinates]') -> Dict[Hashable, List[MergeElement]]:\n    grouped: Dict[Hashable, List[Tuple[Variable, Optional[Index]]]] = {}\n    for coords in list_of_coords:\n        variables = coords.variables\n        indexes = coords.xindexes\n        for name, variable in variables.items():\n            value = grouped.setdefault(name, [])\n            value.append((variable, indexes.get(name)))\n    return grouped",
    ".xarray.core.coordinates.py@@Coordinates.xindexes": "def xindexes(self) -> Indexes:\n    return self._data.xindexes",
    ".xarray.core.merge.py@@merge_collected": "def merge_collected(grouped: Dict[Hashable, List[MergeElement]], prioritized: Mapping[Any, MergeElement]=None, compat: str='minimal', combine_attrs='override') -> Tuple[Dict[Hashable, Variable], Dict[Hashable, Index]]:\n    if prioritized is None:\n        prioritized = {}\n    _assert_compat_valid(compat)\n    merged_vars: Dict[Hashable, Variable] = {}\n    merged_indexes: Dict[Hashable, Index] = {}\n    for name, elements_list in grouped.items():\n        if name in prioritized:\n            variable, index = prioritized[name]\n            merged_vars[name] = variable\n            if index is not None:\n                merged_indexes[name] = index\n        else:\n            indexed_elements = [(variable, index) for variable, index in elements_list if index is not None]\n            if indexed_elements:\n                variable, index = indexed_elements[0]\n                for _, other_index in indexed_elements[1:]:\n                    if not index.equals(other_index):\n                        raise MergeError(f'conflicting values for index {name!r} on objects to be combined:\\nfirst value: {index!r}\\nsecond value: {other_index!r}')\n                if compat == 'identical':\n                    for other_variable, _ in indexed_elements[1:]:\n                        if not dict_equiv(variable.attrs, other_variable.attrs):\n                            raise MergeError(f'conflicting attribute values on combined variable {name!r}:\\nfirst value: {variable.attrs!r}\\nsecond value: {other_variable.attrs!r}')\n                merged_vars[name] = variable\n                merged_vars[name].attrs = merge_attrs([var.attrs for var, _ in indexed_elements], combine_attrs=combine_attrs)\n                merged_indexes[name] = index\n            else:\n                variables = [variable for variable, _ in elements_list]\n                try:\n                    merged_vars[name] = unique_variable(name, variables, compat)\n                except MergeError:\n                    if compat != 'minimal':\n                        raise\n                if name in merged_vars:\n                    merged_vars[name].attrs = merge_attrs([var.attrs for var in variables], combine_attrs=combine_attrs)\n    return (merged_vars, merged_indexes)",
    ".xarray.core.merge.py@@_assert_compat_valid": "def _assert_compat_valid(compat):\n    if compat not in _VALID_COMPAT:\n        raise ValueError('compat={!r} invalid: must be {}'.format(compat, set(_VALID_COMPAT)))",
    ".xarray.core.utils.py@@Frozen.__contains__": "def __contains__(self, key: object) -> bool:\n    return key in self.mapping",
    ".xarray.core.dataarray.py@@DataArray._result_name": "def _result_name(self, other: Any=None) -> Optional[Hashable]:\n    other_name = getattr(other, 'name', _default)\n    if other_name is _default or other_name == self.name:\n        return self.name\n    else:\n        return None",
    ".xarray.core.common.py@@ImplementsArrayReduce.wrapped_func": "def wrapped_func(self, dim=None, axis=None, **kwargs):\n    return self.reduce(func, dim, axis, **kwargs)",
    ".xarray.core.dataarray.py@@DataArray.reduce": "def reduce(self, func: Callable[..., Any], dim: Union[None, Hashable, Sequence[Hashable]]=None, axis: Union[None, int, Sequence[int]]=None, keep_attrs: bool=None, keepdims: bool=False, **kwargs: Any) -> 'DataArray':\n    var = self.variable.reduce(func, dim, axis, keep_attrs, keepdims, **kwargs)\n    return self._replace_maybe_drop_dims(var)",
    ".xarray.core.variable.py@@Variable.reduce": "def reduce(self, func, dim=None, axis=None, keep_attrs=None, keepdims=False, **kwargs):\n    if dim == ...:\n        dim = None\n    if dim is not None and axis is not None:\n        raise ValueError(\"cannot supply both 'axis' and 'dim' arguments\")\n    if dim is not None:\n        axis = self.get_axis_num(dim)\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', 'Mean of empty slice', category=RuntimeWarning)\n        if axis is not None:\n            data = func(self.data, axis=axis, **kwargs)\n        else:\n            data = func(self.data, **kwargs)\n    if getattr(data, 'shape', ()) == self.shape:\n        dims = self.dims\n    else:\n        removed_axes = range(self.ndim) if axis is None else np.atleast_1d(axis) % self.ndim\n        if keepdims:\n            slices = tuple((np.newaxis if i in removed_axes else slice(None, None) for i in range(self.ndim)))\n            if getattr(data, 'shape', None) is None:\n                data = np.asanyarray(data)[slices]\n            else:\n                data = data[slices]\n            dims = self.dims\n        else:\n            dims = [adim for n, adim in enumerate(self.dims) if n not in removed_axes]\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=False)\n    attrs = self._attrs if keep_attrs else None\n    return Variable(dims, data, attrs=attrs)",
    ".xarray.core.duck_array_ops.py@@f": "def f(values, axis=None, skipna=None, **kwargs):\n    if kwargs.pop('out', None) is not None:\n        raise TypeError(f'`out` is not valid for {name}')\n    if invariant_0d and axis == ():\n        return values\n    values = asarray(values)\n    if coerce_strings and values.dtype.kind in 'SU':\n        values = values.astype(object)\n    func = None\n    if skipna or (skipna is None and values.dtype.kind in 'cfO'):\n        nanname = 'nan' + name\n        func = getattr(nanops, nanname)\n    else:\n        if name in ['sum', 'prod']:\n            kwargs.pop('min_count', None)\n        func = getattr(np, name)\n    try:\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore', 'All-NaN slice encountered')\n            return func(values, axis=axis, **kwargs)\n    except AttributeError:\n        if not is_duck_dask_array(values):\n            raise\n        try:\n            return func(values, axis=axis, dtype=values.dtype, **kwargs)\n        except (AttributeError, TypeError):\n            raise NotImplementedError(f'{name} is not yet implemented on dask arrays')",
    ".xarray.core._typed_ops.py@@DataArrayOpsMixin.__sub__": "def __sub__(self, other):\n    return self._binary_op(other, operator.sub)",
    ".xarray.core._typed_ops.py@@VariableOpsMixin.__sub__": "def __sub__(self, other):\n    return self._binary_op(other, operator.sub)",
    ".xarray.core.indexes.py@@Indexes.__iter__": "def __iter__(self) -> Iterator[pd.Index]:\n    return iter(self._indexes)",
    ".xarray.core.dataarray.py@@DataArray.map_blocks": "def map_blocks(self, func: Callable[..., T_Xarray], args: Sequence[Any]=(), kwargs: Mapping[str, Any]=None, template: Union['DataArray', 'Dataset']=None) -> T_Xarray:\n    from .parallel import map_blocks\n    return map_blocks(func, self, args, kwargs, template)",
    ".xarray.core.parallel.py@@map_blocks": "def map_blocks(func: Callable[..., T_Xarray], obj: Union[DataArray, Dataset], args: Sequence[Any]=(), kwargs: Mapping[str, Any]=None, template: Union[DataArray, Dataset]=None) -> T_Xarray:\n\n    def _wrapper(func: Callable, args: List, kwargs: dict, arg_is_array: Iterable[bool], expected: dict):\n        converted_args = [dataset_to_dataarray(arg) if is_array else arg for is_array, arg in zip(arg_is_array, args)]\n        result = func(*converted_args, **kwargs)\n        missing_dimensions = set(expected['shapes']) - set(result.sizes)\n        if missing_dimensions:\n            raise ValueError(f'Dimensions {missing_dimensions} missing on returned object.')\n        for name, index in result.xindexes.items():\n            if name in expected['shapes']:\n                if result.sizes[name] != expected['shapes'][name]:\n                    raise ValueError(f'Received dimension {name!r} of length {result.sizes[name]}. Expected length {expected['shapes'][name]}.')\n            if name in expected['indexes']:\n                expected_index = expected['indexes'][name]\n                if not index.equals(expected_index):\n                    raise ValueError(f'Expected index {name!r} to be {expected_index!r}. Received {index!r} instead.')\n        check_result_variables(result, expected, 'coords')\n        if isinstance(result, Dataset):\n            check_result_variables(result, expected, 'data_vars')\n        return make_dict(result)\n    if template is not None and (not isinstance(template, (DataArray, Dataset))):\n        raise TypeError(f'template must be a DataArray or Dataset. Received {type(template).__name__} instead.')\n    if not isinstance(args, Sequence):\n        raise TypeError('args must be a sequence (for example, a list or tuple).')\n    if kwargs is None:\n        kwargs = {}\n    elif not isinstance(kwargs, Mapping):\n        raise TypeError('kwargs must be a mapping (for example, a dict)')\n    for value in kwargs.values():\n        if is_dask_collection(value):\n            raise TypeError('Cannot pass dask collections in kwargs yet. Please compute or load values before passing to map_blocks.')\n    if not is_dask_collection(obj):\n        return func(obj, *args, **kwargs)\n    all_args = [obj] + list(args)\n    is_xarray = [isinstance(arg, (Dataset, DataArray)) for arg in all_args]\n    is_array = [isinstance(arg, DataArray) for arg in all_args]\n    xarray_indices, xarray_objs = unzip(((index, arg) for index, arg in enumerate(all_args) if is_xarray[index]))\n    others = [(index, arg) for index, arg in enumerate(all_args) if not is_xarray[index]]\n    aligned = align(*xarray_objs, join='exact')\n    xarray_objs = tuple((dataarray_to_dataset(arg) if is_da else arg for is_da, arg in zip(is_array, aligned)))\n    _, npargs = unzip(sorted(list(zip(xarray_indices, xarray_objs)) + others, key=lambda x: x[0]))\n    input_chunks = dict(npargs[0].chunks)\n    input_indexes = dict(npargs[0].xindexes)\n    for arg in xarray_objs[1:]:\n        assert_chunks_compatible(npargs[0], arg)\n        input_chunks.update(arg.chunks)\n        input_indexes.update(arg.xindexes)\n    if template is None:\n        template = infer_template(func, aligned[0], *args, **kwargs)\n        template_indexes = set(template.xindexes)\n        preserved_indexes = template_indexes & set(input_indexes)\n        new_indexes = template_indexes - set(input_indexes)\n        indexes = {dim: input_indexes[dim] for dim in preserved_indexes}\n        indexes.update({k: template.xindexes[k] for k in new_indexes})\n        output_chunks = {dim: input_chunks[dim] for dim in template.dims if dim in input_chunks}\n    else:\n        indexes = dict(template.xindexes)\n        if isinstance(template, DataArray):\n            output_chunks = dict(zip(template.dims, template.chunks))\n        else:\n            output_chunks = dict(template.chunks)\n    for dim in output_chunks:\n        if dim in input_chunks and len(input_chunks[dim]) != len(output_chunks[dim]):\n            raise ValueError(f'map_blocks requires that one block of the input maps to one block of output. Expected number of output chunks along dimension {dim!r} to be {len(input_chunks[dim])}. Received {len(output_chunks[dim])} instead. Please provide template if not provided, or fix the provided template.')\n    if isinstance(template, DataArray):\n        result_is_array = True\n        template_name = template.name\n        template = template._to_temp_dataset()\n    elif isinstance(template, Dataset):\n        result_is_array = False\n    else:\n        raise TypeError(f'func output must be DataArray or Dataset; got {type(template)}')\n    graph: Dict[Any, Any] = {}\n    new_layers: DefaultDict[str, Dict[Any, Any]] = collections.defaultdict(dict)\n    gname = '{}-{}'.format(dask.utils.funcname(func), dask.base.tokenize(npargs[0], args, kwargs))\n    ichunk = {dim: range(len(chunks_v)) for dim, chunks_v in input_chunks.items()}\n    input_chunk_bounds = {dim: np.cumsum((0,) + chunks_v) for dim, chunks_v in input_chunks.items()}\n    output_chunk_bounds = {dim: np.cumsum((0,) + chunks_v) for dim, chunks_v in output_chunks.items()}\n\n    def subset_dataset_to_block(graph: dict, gname: str, dataset: Dataset, input_chunk_bounds, chunk_index):\n        data_vars = []\n        coords = []\n        chunk_tuple = tuple(chunk_index.values())\n        for name, variable in dataset.variables.items():\n            if dask.is_dask_collection(variable.data):\n                chunk = variable.__dask_keys__()\n                for dim in variable.dims:\n                    chunk = chunk[chunk_index[dim]]\n                chunk_variable_task = (f'{name}-{gname}-{chunk[0]}',) + chunk_tuple\n                graph[chunk_variable_task] = (tuple, [variable.dims, chunk, variable.attrs])\n            else:\n                subsetter = {dim: _get_chunk_slicer(dim, chunk_index, input_chunk_bounds) for dim in variable.dims}\n                subset = variable.isel(subsetter)\n                chunk_variable_task = (f'{name}-{gname}-{dask.base.tokenize(subset)}',) + chunk_tuple\n                graph[chunk_variable_task] = (tuple, [subset.dims, subset, subset.attrs])\n            if name in dataset._coord_names:\n                coords.append([name, chunk_variable_task])\n            else:\n                data_vars.append([name, chunk_variable_task])\n        return (Dataset, (dict, data_vars), (dict, coords), dataset.attrs)\n    for chunk_tuple in itertools.product(*ichunk.values()):\n        chunk_index = dict(zip(ichunk.keys(), chunk_tuple))\n        blocked_args = [subset_dataset_to_block(graph, gname, arg, input_chunk_bounds, chunk_index) if isxr else arg for isxr, arg in zip(is_xarray, npargs)]\n        expected = {}\n        expected['shapes'] = {k: output_chunks[k][v] for k, v in chunk_index.items() if k in output_chunks}\n        expected['data_vars'] = set(template.data_vars.keys())\n        expected['coords'] = set(template.coords.keys())\n        expected['indexes'] = {dim: indexes[dim][_get_chunk_slicer(dim, chunk_index, output_chunk_bounds)] for dim in indexes}\n        from_wrapper = (gname,) + chunk_tuple\n        graph[from_wrapper] = (_wrapper, func, blocked_args, kwargs, is_array, expected)\n        var_key_map: Dict[Hashable, str] = {}\n        for name, variable in template.variables.items():\n            if name in indexes:\n                continue\n            gname_l = f'{name}-{gname}'\n            var_key_map[name] = gname_l\n            key: Tuple[Any, ...] = (gname_l,)\n            for dim in variable.dims:\n                if dim in chunk_index:\n                    key += (chunk_index[dim],)\n                else:\n                    key += (0,)\n            new_layers[gname_l][key] = (operator.getitem, from_wrapper, name)\n    hlg = HighLevelGraph.from_collections(gname, graph, dependencies=[arg for arg in npargs if dask.is_dask_collection(arg)])\n    hlg = HighLevelGraph({**hlg.layers, **new_layers}, dependencies={**hlg.dependencies, **{name: {gname} for name in new_layers.keys()}})\n    result = Dataset(coords={k: idx.to_pandas_index() for k, idx in indexes.items()}, attrs=template.attrs)\n    for index in result.xindexes:\n        result[index].attrs = template[index].attrs\n        result[index].encoding = template[index].encoding\n    for name, gname_l in var_key_map.items():\n        dims = template[name].dims\n        var_chunks = []\n        for dim in dims:\n            if dim in output_chunks:\n                var_chunks.append(output_chunks[dim])\n            elif dim in result.xindexes:\n                var_chunks.append((result.sizes[dim],))\n            elif dim in template.dims:\n                var_chunks.append((template.sizes[dim],))\n        data = dask.array.Array(hlg, name=gname_l, chunks=var_chunks, dtype=template[name].dtype)\n        result[name] = (dims, data, template[name].attrs)\n        result[name].encoding = template[name].encoding\n    result = result.set_coords(template._coord_names)\n    if result_is_array:\n        da = dataset_to_dataarray(result)\n        da.name = template_name\n        return da\n    return result",
    ".xarray.core.dataarray.py@@DataArray.__dask_graph__": "def __dask_graph__(self):\n    return self._to_temp_dataset().__dask_graph__()",
    ".xarray.core.dataarray.py@@DataArray._to_temp_dataset": "def _to_temp_dataset(self) -> Dataset:\n    return self._to_dataset_whole(name=_THIS_ARRAY, shallow_copy=False)",
    ".xarray.core.dataarray.py@@DataArray._to_dataset_whole": "def _to_dataset_whole(self, name: Hashable=None, shallow_copy: bool=True) -> Dataset:\n    if name is None:\n        name = self.name\n    if name is None:\n        raise ValueError('unable to convert unnamed DataArray to a Dataset without providing an explicit name')\n    if name in self.coords:\n        raise ValueError('cannot create a Dataset from a DataArray with the same name as one of its coordinates')\n    variables = self._coords.copy()\n    variables[name] = self.variable\n    if shallow_copy:\n        for k in variables:\n            variables[k] = variables[k].copy(deep=False)\n    indexes = self._indexes\n    coord_names = set(self._coords)\n    return Dataset._construct_direct(variables, coord_names, indexes=indexes)",
    ".xarray.core.coordinates.py@@Coordinates.__contains__": "def __contains__(self, key: Hashable) -> bool:\n    return key in self._names",
    ".xarray.core.coordinates.py@@DataArrayCoordinates._names": "def _names(self) -> Set[Hashable]:\n    return set(self._data._coords)",
    ".xarray.core.dataset.py@@Dataset._construct_direct": "def _construct_direct(cls, variables, coord_names, dims=None, attrs=None, indexes=None, encoding=None, close=None):\n    if dims is None:\n        dims = calculate_dimensions(variables)\n    obj = object.__new__(cls)\n    obj._variables = variables\n    obj._coord_names = coord_names\n    obj._dims = dims\n    obj._indexes = indexes\n    obj._attrs = attrs\n    obj._close = close\n    obj._encoding = encoding\n    return obj",
    ".xarray.core.dataset.py@@calculate_dimensions": "def calculate_dimensions(variables: Mapping[Any, Variable]) -> Dict[Hashable, int]:\n    dims: Dict[Hashable, int] = {}\n    last_used = {}\n    scalar_vars = {k for k, v in variables.items() if not v.dims}\n    for k, var in variables.items():\n        for dim, size in zip(var.dims, var.shape):\n            if dim in scalar_vars:\n                raise ValueError(f'dimension {dim!r} already exists as a scalar variable')\n            if dim not in dims:\n                dims[dim] = size\n                last_used[dim] = k\n            elif dims[dim] != size:\n                raise ValueError(f'conflicting sizes for dimension {dim!r}: length {size} on {k!r} and length {dims[dim]} on {last_used!r}')\n    return dims",
    ".xarray.core.dataset.py@@Dataset.__dask_graph__": "def __dask_graph__(self):\n    graphs = {k: v.__dask_graph__() for k, v in self.variables.items()}\n    graphs = {k: v for k, v in graphs.items() if v is not None}\n    if not graphs:\n        return None\n    else:\n        try:\n            from dask.highlevelgraph import HighLevelGraph\n            return HighLevelGraph.merge(*graphs.values())\n        except ImportError:\n            from dask import sharedict\n            return sharedict.merge(*graphs.values())",
    ".xarray.core.dataset.py@@Dataset.variables": "def variables(self) -> Mapping[Hashable, Variable]:\n    return Frozen(self._variables)",
    ".xarray.core.variable.py@@Variable.__dask_graph__": "def __dask_graph__(self):\n    if is_duck_dask_array(self._data):\n        return self._data.__dask_graph__()\n    else:\n        return None",
    ".xarray.core.parallel.py@@unzip": "def unzip(iterable):\n    return zip(*iterable)",
    ".xarray.core.parallel.py@@dataarray_to_dataset": "def dataarray_to_dataset(obj: DataArray) -> Dataset:\n    if obj.name is None:\n        dataset = obj._to_temp_dataset()\n    else:\n        dataset = obj.to_dataset()\n    return dataset",
    ".xarray.core.dataset.py@@Dataset.chunks": "def chunks(self) -> Mapping[Hashable, Tuple[int, ...]]:\n    return get_chunksizes(self.variables.values())",
    ".xarray.core.common.py@@get_chunksizes": "def get_chunksizes(variables: Iterable[Variable]) -> Mapping[Any, Tuple[int, ...]]:\n    chunks: Dict[Any, Tuple[int, ...]] = {}\n    for v in variables:\n        if hasattr(v.data, 'chunks'):\n            for dim, c in v.chunksizes.items():\n                if dim in chunks and c != chunks[dim]:\n                    raise ValueError(f'Object has inconsistent chunks along dimension {dim}. This can be fixed by calling unify_chunks().')\n                chunks[dim] = c\n    return Frozen(chunks)",
    ".xarray.core.variable.py@@Variable.chunksizes": "def chunksizes(self) -> Mapping[Any, Tuple[int, ...]]:\n    if hasattr(self._data, 'chunks'):\n        return Frozen({dim: c for dim, c in zip(self.dims, self.data.chunks)})\n    else:\n        return {}",
    ".xarray.core.dataset.py@@Dataset.xindexes": "def xindexes(self) -> Indexes:\n    if self._indexes is None:\n        self._indexes = default_indexes(self._variables, self._dims)\n    return Indexes(self._indexes)",
    ".xarray.core.parallel.py@@assert_chunks_compatible": "def assert_chunks_compatible(a: Dataset, b: Dataset):\n    a = a.unify_chunks()\n    b = b.unify_chunks()\n    for dim in set(a.chunks).intersection(set(b.chunks)):\n        if a.chunks[dim] != b.chunks[dim]:\n            raise ValueError(f'Chunk sizes along dimension {dim!r} are not equal.')",
    ".xarray.core.dataset.py@@Dataset.unify_chunks": "def unify_chunks(self) -> 'Dataset':\n    return unify_chunks(self)[0]",
    ".xarray.core.computation.py@@unify_chunks": "def unify_chunks(*objects: T_Xarray) -> Tuple[T_Xarray, ...]:\n    from .dataarray import DataArray\n    datasets = [obj._to_temp_dataset() if isinstance(obj, DataArray) else obj.copy() for obj in objects]\n    unify_chunks_args = []\n    sizes: dict[Hashable, int] = {}\n    for ds in datasets:\n        for v in ds._variables.values():\n            if v.chunks is not None:\n                for dim, size in v.sizes.items():\n                    try:\n                        if sizes[dim] != size:\n                            raise ValueError(f'Dimension {dim!r} size mismatch: {sizes[dim]} != {size}')\n                    except KeyError:\n                        sizes[dim] = size\n                unify_chunks_args += [v._data, v._dims]\n    if not unify_chunks_args:\n        return objects\n    from dask.array.core import unify_chunks\n    _, dask_data = unify_chunks(*unify_chunks_args)\n    dask_data_iter = iter(dask_data)\n    out = []\n    for obj, ds in zip(objects, datasets):\n        for k, v in ds._variables.items():\n            if v.chunks is not None:\n                ds._variables[k] = v.copy(data=next(dask_data_iter))\n        out.append(obj._from_temp_dataset(ds) if isinstance(obj, DataArray) else ds)\n    return tuple(out)",
    ".xarray.core.dataset.py@@Dataset.copy": "def copy(self, deep: bool=False, data: Mapping=None) -> 'Dataset':\n    if data is None:\n        variables = {k: v.copy(deep=deep) for k, v in self._variables.items()}\n    elif not utils.is_dict_like(data):\n        raise ValueError('Data must be dict-like')\n    else:\n        var_keys = set(self.data_vars.keys())\n        data_keys = set(data.keys())\n        keys_not_in_vars = data_keys - var_keys\n        if keys_not_in_vars:\n            raise ValueError('Data must only contain variables in original dataset. Extra variables: {}'.format(keys_not_in_vars))\n        keys_missing_from_data = var_keys - data_keys\n        if keys_missing_from_data:\n            raise ValueError('Data must contain all variables in original dataset. Data is missing {}'.format(keys_missing_from_data))\n        variables = {k: v.copy(deep=deep, data=data.get(k)) for k, v in self._variables.items()}\n    attrs = copy.deepcopy(self._attrs) if deep else copy.copy(self._attrs)\n    return self._replace(variables, attrs=attrs)",
    ".xarray.core.dataset.py@@Dataset._replace": "def _replace(self, variables: Dict[Hashable, Variable]=None, coord_names: Set[Hashable]=None, dims: Dict[Any, int]=None, attrs: Union[Dict[Hashable, Any], None, Default]=_default, indexes: Union[Dict[Hashable, Index], None, Default]=_default, encoding: Union[dict, None, Default]=_default, inplace: bool=False) -> 'Dataset':\n    if inplace:\n        if variables is not None:\n            self._variables = variables\n        if coord_names is not None:\n            self._coord_names = coord_names\n        if dims is not None:\n            self._dims = dims\n        if attrs is not _default:\n            self._attrs = attrs\n        if indexes is not _default:\n            self._indexes = indexes\n        if encoding is not _default:\n            self._encoding = encoding\n        obj = self\n    else:\n        if variables is None:\n            variables = self._variables.copy()\n        if coord_names is None:\n            coord_names = self._coord_names.copy()\n        if dims is None:\n            dims = self._dims.copy()\n        if attrs is _default:\n            attrs = copy.copy(self._attrs)\n        if indexes is _default:\n            indexes = copy.copy(self._indexes)\n        if encoding is _default:\n            encoding = copy.copy(self._encoding)\n        obj = self._construct_direct(variables, coord_names, dims, attrs, indexes, encoding)\n    return obj",
    ".xarray.core.variable.py@@Variable.chunks": "def chunks(self) -> Optional[Tuple[Tuple[int, ...], ...]]:\n    return getattr(self._data, 'chunks', None)",
    ".xarray.core.parallel.py@@infer_template": "def infer_template(func: Callable[..., T_Xarray], obj: Union[DataArray, Dataset], *args, **kwargs) -> T_Xarray:\n    meta_args = [make_meta(arg) for arg in (obj,) + args]\n    try:\n        template = func(*meta_args, **kwargs)\n    except Exception as e:\n        raise Exception(\"Cannot infer object returned from running user provided function. Please supply the 'template' kwarg to map_blocks.\") from e\n    if not isinstance(template, (Dataset, DataArray)):\n        raise TypeError(f'Function must return an xarray DataArray or Dataset. Instead it returned {type(template)}')\n    return template",
    ".xarray.core.parallel.py@@make_meta": "def make_meta(obj):\n    if isinstance(obj, DataArray):\n        obj_array = obj\n        obj = dataarray_to_dataset(obj)\n    elif isinstance(obj, Dataset):\n        obj_array = None\n    else:\n        return obj\n    meta = Dataset()\n    for name, variable in obj.variables.items():\n        meta_obj = meta_from_array(variable.data, ndim=variable.ndim)\n        meta[name] = (variable.dims, meta_obj, variable.attrs)\n    meta.attrs = obj.attrs\n    meta = meta.set_coords(obj.coords)\n    if obj_array is not None:\n        return dataset_to_dataarray(meta)\n    return meta",
    ".xarray.core.dataset.py@@Dataset.__init__": "def __init__(self, data_vars: Mapping[Any, Any]=None, coords: Mapping[Any, Any]=None, attrs: Mapping[Any, Any]=None):\n    if data_vars is None:\n        data_vars = {}\n    if coords is None:\n        coords = {}\n    both_data_and_coords = set(data_vars) & set(coords)\n    if both_data_and_coords:\n        raise ValueError(f'variables {both_data_and_coords!r} are found in both data_vars and coords')\n    if isinstance(coords, Dataset):\n        coords = coords.variables\n    variables, coord_names, dims, indexes, _ = merge_data_and_coords(data_vars, coords, compat='broadcast_equals')\n    self._attrs = dict(attrs) if attrs is not None else None\n    self._close = None\n    self._encoding = None\n    self._variables = variables\n    self._coord_names = coord_names\n    self._dims = dims\n    self._indexes = indexes",
    ".xarray.core.merge.py@@merge_data_and_coords": "def merge_data_and_coords(data, coords, compat='broadcast_equals', join='outer'):\n    objects = [data, coords]\n    explicit_coords = coords.keys()\n    indexes = dict(_extract_indexes_from_coords(coords))\n    return merge_core(objects, compat, join, explicit_coords=explicit_coords, indexes=indexes)",
    ".xarray.core.merge.py@@_extract_indexes_from_coords": "def _extract_indexes_from_coords(coords):\n    for name, variable in coords.items():\n        variable = as_variable(variable, name=name)\n        if variable.dims == (name,):\n            yield (name, variable._to_xindex())",
    ".xarray.core.merge.py@@merge_core": "def merge_core(objects: Iterable['CoercibleMapping'], compat: str='broadcast_equals', join: str='outer', combine_attrs: Optional[str]='override', priority_arg: Optional[int]=None, explicit_coords: Optional[Sequence]=None, indexes: Optional[Mapping[Any, Any]]=None, fill_value: object=dtypes.NA) -> _MergeResult:\n    from .dataarray import DataArray\n    from .dataset import Dataset, calculate_dimensions\n    _assert_compat_valid(compat)\n    coerced = coerce_pandas_values(objects)\n    aligned = deep_align(coerced, join=join, copy=False, indexes=indexes, fill_value=fill_value)\n    collected = collect_variables_and_indexes(aligned)\n    prioritized = _get_priority_vars_and_indexes(aligned, priority_arg, compat=compat)\n    variables, out_indexes = merge_collected(collected, prioritized, compat=compat, combine_attrs=combine_attrs)\n    assert_unique_multiindex_level_names(variables)\n    dims = calculate_dimensions(variables)\n    coord_names, noncoord_names = determine_coords(coerced)\n    if explicit_coords is not None:\n        assert_valid_explicit_coords(variables, dims, explicit_coords)\n        coord_names.update(explicit_coords)\n    for dim, size in dims.items():\n        if dim in variables:\n            coord_names.add(dim)\n    ambiguous_coords = coord_names.intersection(noncoord_names)\n    if ambiguous_coords:\n        raise MergeError(f'unable to determine if these variables should be coordinates or not in the merged result: {ambiguous_coords}')\n    attrs = merge_attrs([var.attrs for var in coerced if isinstance(var, (Dataset, DataArray))], combine_attrs)\n    return _MergeResult(variables, coord_names, dims, out_indexes, attrs)",
    ".xarray.core.merge.py@@coerce_pandas_values": "def coerce_pandas_values(objects: Iterable['CoercibleMapping']) -> List['DatasetLike']:\n    from .dataarray import DataArray\n    from .dataset import Dataset\n    out = []\n    for obj in objects:\n        if isinstance(obj, Dataset):\n            variables: 'DatasetLike' = obj\n        else:\n            variables = {}\n            if isinstance(obj, PANDAS_TYPES):\n                obj = dict(obj.iteritems())\n            for k, v in obj.items():\n                if isinstance(v, PANDAS_TYPES):\n                    v = DataArray(v)\n                variables[k] = v\n        out.append(variables)\n    return out",
    ".xarray.core.alignment.py@@deep_align": "def deep_align(objects, join='inner', copy=True, indexes=None, exclude=frozenset(), raise_on_invalid=True, fill_value=dtypes.NA):\n    from .dataarray import DataArray\n    from .dataset import Dataset\n    if indexes is None:\n        indexes = {}\n\n    def is_alignable(obj):\n        return isinstance(obj, (DataArray, Dataset))\n    positions = []\n    keys = []\n    out = []\n    targets = []\n    no_key = object()\n    not_replaced = object()\n    for position, variables in enumerate(objects):\n        if is_alignable(variables):\n            positions.append(position)\n            keys.append(no_key)\n            targets.append(variables)\n            out.append(not_replaced)\n        elif is_dict_like(variables):\n            current_out = {}\n            for k, v in variables.items():\n                if is_alignable(v) and k not in indexes:\n                    positions.append(position)\n                    keys.append(k)\n                    targets.append(v)\n                    current_out[k] = not_replaced\n                else:\n                    current_out[k] = v\n            out.append(current_out)\n        elif raise_on_invalid:\n            raise ValueError('object to align is neither an xarray.Dataset, an xarray.DataArray nor a dictionary: {!r}'.format(variables))\n        else:\n            out.append(variables)\n    aligned = align(*targets, join=join, copy=copy, indexes=indexes, exclude=exclude, fill_value=fill_value)\n    for position, key, aligned_obj in zip(positions, keys, aligned):\n        if key is no_key:\n            out[position] = aligned_obj\n        else:\n            out[position][key] = aligned_obj\n    for arg in out:\n        assert arg is not not_replaced\n        if is_dict_like(arg):\n            assert all((value is not not_replaced for value in arg.values()))\n    return out",
    ".xarray.core.alignment.py@@is_alignable": "def is_alignable(obj):\n    return isinstance(obj, (DataArray, Dataset))",
    ".xarray.core.merge.py@@collect_variables_and_indexes": "def collect_variables_and_indexes(list_of_mappings: List[DatasetLike]) -> Dict[Hashable, List[MergeElement]]:\n    from .dataarray import DataArray\n    from .dataset import Dataset\n    grouped: Dict[Hashable, List[Tuple[Variable, Optional[Index]]]] = {}\n\n    def append(name, variable, index):\n        values = grouped.setdefault(name, [])\n        values.append((variable, index))\n\n    def append_all(variables, indexes):\n        for name, variable in variables.items():\n            append(name, variable, indexes.get(name))\n    for mapping in list_of_mappings:\n        if isinstance(mapping, Dataset):\n            append_all(mapping.variables, mapping.xindexes)\n            continue\n        for name, variable in mapping.items():\n            if isinstance(variable, DataArray):\n                coords = variable._coords.copy()\n                indexes = dict(variable.xindexes)\n                coords.pop(name, None)\n                indexes.pop(name, None)\n                append_all(coords, indexes)\n            variable = as_variable(variable, name=name)\n            if variable.dims == (name,):\n                idx_variable = variable.to_index_variable()\n                index = variable._to_xindex()\n                append(name, idx_variable, index)\n            else:\n                index = None\n                append(name, variable, index)\n    return grouped",
    ".xarray.core.merge.py@@_get_priority_vars_and_indexes": "def _get_priority_vars_and_indexes(objects: List['DatasetLike'], priority_arg: Optional[int], compat: str='equals') -> Dict[Hashable, MergeElement]:\n    if priority_arg is None:\n        return {}\n    collected = collect_variables_and_indexes([objects[priority_arg]])\n    variables, indexes = merge_collected(collected, compat=compat)\n    grouped: Dict[Hashable, MergeElement] = {}\n    for name, variable in variables.items():\n        grouped[name] = (variable, indexes.get(name))\n    return grouped",
    ".xarray.core.variable.py@@assert_unique_multiindex_level_names": "def assert_unique_multiindex_level_names(variables):\n    level_names = defaultdict(list)\n    all_level_names = set()\n    for var_name, var in variables.items():\n        if isinstance(var._data, PandasIndexingAdapter):\n            idx_level_names = var.to_index_variable().level_names\n            if idx_level_names is not None:\n                for n in idx_level_names:\n                    level_names[n].append(f'{n!r} ({var_name})')\n            if idx_level_names:\n                all_level_names.update(idx_level_names)\n    for k, v in level_names.items():\n        if k in variables:\n            v.append(f'({k})')\n    duplicate_names = [v for v in level_names.values() if len(v) > 1]\n    if duplicate_names:\n        conflict_str = '\\n'.join((', '.join(v) for v in duplicate_names))\n        raise ValueError(f'conflicting MultiIndex level name(s):\\n{conflict_str}')\n    for k, v in variables.items():\n        for d in v.dims:\n            if d in all_level_names:\n                raise ValueError('conflicting level / dimension names. {} already exists as a level name.'.format(d))",
    ".xarray.core.merge.py@@determine_coords": "def determine_coords(list_of_mappings: Iterable['DatasetLike']) -> Tuple[Set[Hashable], Set[Hashable]]:\n    from .dataarray import DataArray\n    from .dataset import Dataset\n    coord_names: Set[Hashable] = set()\n    noncoord_names: Set[Hashable] = set()\n    for mapping in list_of_mappings:\n        if isinstance(mapping, Dataset):\n            coord_names.update(mapping.coords)\n            noncoord_names.update(mapping.data_vars)\n        else:\n            for name, var in mapping.items():\n                if isinstance(var, DataArray):\n                    coords = set(var._coords)\n                    coords.discard(name)\n                    coord_names.update(coords)\n    return (coord_names, noncoord_names)",
    ".xarray.core.merge.py@@assert_valid_explicit_coords": "def assert_valid_explicit_coords(variables, dims, explicit_coords):\n    for coord_name in explicit_coords:\n        if coord_name in dims and variables[coord_name].dims != (coord_name,):\n            raise MergeError(f'coordinate {coord_name} shares a name with a dataset dimension, but is not a 1D variable along that dimension. This is disallowed by the xarray data model.')",
    ".xarray.core.dataset.py@@Dataset.__setitem__": "def __setitem__(self, key: Union[Hashable, List[Hashable], Mapping], value) -> None:\n    if utils.is_dict_like(key):\n        value = self._setitem_check(key, value)\n        processed = []\n        for name, var in self.items():\n            try:\n                var[key] = value[name]\n                processed.append(name)\n            except Exception as e:\n                if processed:\n                    raise RuntimeError(f\"An error occured while setting values of the variable '{name}'. The following variables have been successfully updated:\\n{processed}\") from e\n                else:\n                    raise e\n    elif isinstance(key, list):\n        if len(key) == 0:\n            raise ValueError('Empty list of variables to be set')\n        if len(key) == 1:\n            self.update({key[0]: value})\n        else:\n            if len(key) != len(value):\n                raise ValueError(f'Different lengths of variables to be set ({len(key)}) and data used as input for setting ({len(value)})')\n            if isinstance(value, Dataset):\n                self.update(dict(zip(key, value.data_vars.values())))\n            elif isinstance(value, xr.DataArray):\n                raise ValueError('Cannot assign single DataArray to multiple keys')\n            else:\n                self.update(dict(zip(key, value)))\n    else:\n        if isinstance(value, Dataset):\n            raise TypeError('Cannot assign a Dataset to a single key - only a DataArray or Variable object can be stored undera single key.')\n        self.update({key: value})",
    ".xarray.core.dataset.py@@Dataset.update": "def update(self, other: 'CoercibleMapping') -> 'Dataset':\n    merge_result = dataset_update_method(self, other)\n    return self._replace(inplace=True, **merge_result._asdict())",
    ".xarray.core.merge.py@@dataset_update_method": "def dataset_update_method(dataset: 'Dataset', other: 'CoercibleMapping') -> _MergeResult:\n    from .dataarray import DataArray\n    from .dataset import Dataset\n    if not isinstance(other, Dataset):\n        other = dict(other)\n        for key, value in other.items():\n            if isinstance(value, DataArray):\n                coord_names = [c for c in value.coords if c not in value.dims and c in dataset.coords]\n                if coord_names:\n                    other[key] = value.drop_vars(coord_names)\n    indexes = {}\n    for key, index in dataset.xindexes.items():\n        if isinstance(index, PandasIndex):\n            indexes[key] = dataset.coords[key]\n        else:\n            indexes[key] = index\n    return merge_core([dataset, other], priority_arg=1, indexes=indexes, combine_attrs='override')",
    ".xarray.core.dataset.py@@Dataset.__iter__": "def __iter__(self) -> Iterator[Hashable]:\n    return iter(self.data_vars)",
    ".xarray.core.dataset.py@@Dataset.data_vars": "def data_vars(self) -> DataVariables:\n    return DataVariables(self)",
    ".xarray.core.dataset.py@@DataVariables.__init__": "def __init__(self, dataset: 'Dataset'):\n    self._dataset = dataset",
    ".xarray.core.dataset.py@@DataVariables.__iter__": "def __iter__(self) -> Iterator[Hashable]:\n    return (key for key in self._dataset._variables if key not in self._dataset._coord_names)",
    ".xarray.core.merge.py@@append_all": "def append_all(variables, indexes):\n    for name, variable in variables.items():\n        append(name, variable, indexes.get(name))",
    ".xarray.core.variable.py@@as_variable": "def as_variable(obj, name=None) -> Union[Variable, IndexVariable]:\n    from .dataarray import DataArray\n    if isinstance(obj, DataArray):\n        obj = obj.variable\n    if isinstance(obj, Variable):\n        obj = obj.copy(deep=False)\n    elif isinstance(obj, tuple):\n        if isinstance(obj[1], DataArray):\n            raise TypeError('Using a DataArray object to construct a variable is ambiguous, please extract the data using the .data property.')\n        try:\n            obj = Variable(*obj)\n        except (TypeError, ValueError) as error:\n            raise error.__class__('Could not convert tuple of form (dims, data[, attrs, encoding]): {} to Variable.'.format(obj))\n    elif utils.is_scalar(obj):\n        obj = Variable([], obj)\n    elif isinstance(obj, (pd.Index, IndexVariable)) and obj.name is not None:\n        obj = Variable(obj.name, obj)\n    elif isinstance(obj, (set, dict)):\n        raise TypeError('variable {!r} has invalid type {!r}'.format(name, type(obj)))\n    elif name is not None:\n        data = as_compatible_data(obj)\n        if data.ndim != 1:\n            raise MissingDimensionsError(f'cannot set variable {name!r} with {data.ndim!r}-dimensional data without explicit dimension names. Pass a tuple of (dims, data) instead.')\n        obj = Variable(name, data, fastpath=True)\n    else:\n        raise TypeError(f'unable to convert object into a variable without an explicit list of dimensions: {obj!r}')\n    if name is not None and name in obj.dims:\n        if obj.ndim != 1:\n            raise MissingDimensionsError(f'{name!r} has more than 1-dimension and the same name as one of its dimensions {obj.dims!r}. xarray disallows such variables because they conflict with the coordinates used to label dimensions.')\n        obj = obj.to_index_variable()\n    return obj",
    ".xarray.core.utils.py@@ReprObject.__eq__": "def __eq__(self, other) -> bool:\n    if isinstance(other, ReprObject):\n        return self._value == other._value\n    return False",
    ".xarray.core.merge.py@@append": "def append(name, variable, index):\n    values = grouped.setdefault(name, [])\n    values.append((variable, index))",
    ".xarray.core.merge.py@@unique_variable": "def unique_variable(name: Hashable, variables: List[Variable], compat: str='broadcast_equals', equals: bool=None) -> Variable:\n    out = variables[0]\n    if len(variables) == 1 or compat == 'override':\n        return out\n    combine_method = None\n    if compat == 'minimal':\n        compat = 'broadcast_equals'\n    if compat == 'broadcast_equals':\n        dim_lengths = broadcast_dimension_size(variables)\n        out = out.set_dims(dim_lengths)\n    if compat == 'no_conflicts':\n        combine_method = 'fillna'\n    if equals is None:\n        for var in variables[1:]:\n            equals = getattr(out, compat)(var, equiv=lazy_array_equiv)\n            if equals is not True:\n                break\n        if equals is None:\n            out = out.compute()\n            for var in variables[1:]:\n                equals = getattr(out, compat)(var)\n                if not equals:\n                    break\n    if not equals:\n        raise MergeError(f\"conflicting values for variable {name!r} on objects to be combined. You can skip this check by specifying compat='override'.\")\n    if combine_method:\n        for var in variables[1:]:\n            out = getattr(out, combine_method)(var)\n    return out",
    ".xarray.core.dataset.py@@Dataset.coords": "def coords(self) -> DatasetCoordinates:\n    return DatasetCoordinates(self)",
    ".xarray.core.coordinates.py@@DatasetCoordinates.__init__": "def __init__(self, dataset: 'Dataset'):\n    self._data = dataset",
    ".xarray.core.coordinates.py@@Coordinates.__iter__": "def __iter__(self) -> Iterator['Hashable']:\n    for k in self.variables:\n        if k in self._names:\n            yield k",
    ".xarray.core.coordinates.py@@DatasetCoordinates.variables": "def variables(self) -> Mapping[Hashable, Variable]:\n    return Frozen({k: v for k, v in self._data.variables.items() if k in self._names})",
    ".xarray.core.dataset.py@@Dataset.attrs": "def attrs(self) -> Dict[Hashable, Any]:\n    if self._attrs is None:\n        self._attrs = {}\n    return self._attrs",
    ".xarray.core.dataset.py@@Dataset.set_coords": "def set_coords(self, names: 'Union[Hashable, Iterable[Hashable]]') -> 'Dataset':\n    if isinstance(names, str) or not isinstance(names, Iterable):\n        names = [names]\n    else:\n        names = list(names)\n    self._assert_all_in_dataset(names)\n    obj = self.copy()\n    obj._coord_names.update(names)\n    return obj",
    ".xarray.core.coordinates.py@@Coordinates.__len__": "def __len__(self) -> int:\n    return len(self._names)",
    ".xarray.core.coordinates.py@@DatasetCoordinates._names": "def _names(self) -> Set[Hashable]:\n    return self._data._coord_names",
    ".xarray.core.dataset.py@@Dataset._assert_all_in_dataset": "def _assert_all_in_dataset(self, names: Iterable[Hashable], virtual_okay: bool=False) -> None:\n    bad_names = set(names) - set(self._variables)\n    if virtual_okay:\n        bad_names -= self.virtual_variables\n    if bad_names:\n        raise ValueError('One or more of the specified variables cannot be found in this dataset')",
    ".xarray.core.parallel.py@@dataset_to_dataarray": "def dataset_to_dataarray(obj: Dataset) -> DataArray:\n    if not isinstance(obj, Dataset):\n        raise TypeError(f'Expected Dataset, got {type(obj)}')\n    if len(obj.data_vars) > 1:\n        raise TypeError('Trying to convert Dataset with more than one data variable to DataArray')\n    return next(iter(obj.data_vars.values()))",
    ".xarray.core.dataset.py@@DataVariables.__len__": "def __len__(self) -> int:\n    return len(self._dataset._variables) - len(self._dataset._coord_names)",
    ".xarray.core.dataset.py@@DataVariables.__getitem__": "def __getitem__(self, key: Hashable) -> 'DataArray':\n    if key not in self._dataset._coord_names:\n        return cast('DataArray', self._dataset[key])\n    raise KeyError(key)",
    ".xarray.core.dataset.py@@Dataset.__getitem__": "def __getitem__(self, key: Mapping) -> 'Dataset':\n    ...",
    ".xarray.core.utils.py@@hashable": "def hashable(v: Any) -> bool:\n    try:\n        hash(v)\n    except TypeError:\n        return False\n    return True",
    ".xarray.core.dataset.py@@Dataset._construct_dataarray": "def _construct_dataarray(self, name: Hashable) -> 'DataArray':\n    from .dataarray import DataArray\n    try:\n        variable = self._variables[name]\n    except KeyError:\n        _, name, variable = _get_virtual_variable(self._variables, name, self._level_coords, self.dims)\n    needed_dims = set(variable.dims)\n    coords: Dict[Hashable, Variable] = {}\n    for k in self._variables:\n        if k in self._coord_names and set(self.variables[k].dims) <= needed_dims:\n            coords[k] = self.variables[k]\n    if self._indexes is None:\n        indexes = None\n    else:\n        indexes = {k: v for k, v in self._indexes.items() if k in coords}\n    return DataArray(variable, coords, name=name, indexes=indexes, fastpath=True)",
    ".xarray.core.common.py@@DataWithCoords.isnull": "def isnull(self, keep_attrs: bool=None):\n    from .computation import apply_ufunc\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=False)\n    return apply_ufunc(duck_array_ops.isnull, self, dask='allowed', keep_attrs=keep_attrs)",
    ".xarray.core.arithmetic.py@@SupportsArithmetic.__array_ufunc__": "def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n    from .computation import apply_ufunc\n    out = kwargs.get('out', ())\n    for x in inputs + out:\n        if not isinstance(x, self._HANDLED_TYPES + (SupportsArithmetic,)):\n            return NotImplemented\n    if ufunc.signature is not None:\n        raise NotImplementedError('{} not supported: xarray objects do not directly implement generalized ufuncs. Instead, use xarray.apply_ufunc or explicitly convert to xarray objects to NumPy arrays (e.g., with `.values`).'.format(ufunc))\n    if method != '__call__':\n        raise NotImplementedError('{} method for ufunc {} is not implemented on xarray objects, which currently only support the __call__ method. As an alternative, consider explicitly converting xarray objects to NumPy arrays (e.g., with `.values`).'.format(method, ufunc))\n    if any((isinstance(o, SupportsArithmetic) for o in out)):\n        raise NotImplementedError('xarray objects are not yet supported in the `out` argument for ufuncs. As an alternative, consider explicitly converting xarray objects to NumPy arrays (e.g., with `.values`).')\n    join = dataset_join = OPTIONS['arithmetic_join']\n    return apply_ufunc(ufunc, *inputs, input_core_dims=((),) * ufunc.nin, output_core_dims=((),) * ufunc.nout, join=join, dataset_join=dataset_join, dataset_fill_value=np.nan, kwargs=kwargs, dask='allowed', keep_attrs=_get_keep_attrs(default=True))",
    ".xarray.core.computation.py@@_first_of_type": "def _first_of_type(args, kind):\n    for arg in args:\n        if isinstance(arg, kind):\n            return arg\n    raise ValueError('This should be unreachable.')",
    ".xarray.core.common.py@@AbstractArray.__bool__": "def __bool__(self: Any) -> bool:\n    return bool(self.values)",
    ".xarray.core.dataarray.py@@DataArray.values": "def values(self) -> np.ndarray:\n    return self.variable.values",
    ".xarray.core.variable.py@@Variable.values": "def values(self):\n    return _as_array_or_item(self._data)",
    ".xarray.core.variable.py@@_as_array_or_item": "def _as_array_or_item(data):\n    data = np.asarray(data)\n    if data.ndim == 0:\n        if data.dtype.kind == 'M':\n            data = np.datetime64(data, 'ns')\n        elif data.dtype.kind == 'm':\n            data = np.timedelta64(data, 'ns')\n    return data",
    ".xarray.core.common.py@@AbstractArray.get_axis_num": "def get_axis_num(self, dim: Union[Hashable, Iterable[Hashable]]) -> Union[int, Tuple[int, ...]]:\n    if isinstance(dim, Iterable) and (not isinstance(dim, str)):\n        return tuple((self._get_axis_num(d) for d in dim))\n    else:\n        return self._get_axis_num(dim)",
    ".xarray.core.common.py@@AbstractArray._get_axis_num": "def _get_axis_num(self: Any, dim: Hashable) -> int:\n    try:\n        return self.dims.index(dim)\n    except ValueError:\n        raise ValueError(f'{dim!r} not found in array dimensions {self.dims!r}')",
    ".xarray.core.variable.py@@IndexVariable.level_names": "def level_names(self):\n    index = self.to_index()\n    if isinstance(index, pd.MultiIndex):\n        return index.names\n    else:\n        return None",
    ".xarray.core.variable.py@@IndexVariable.to_index": "def to_index(self):\n    assert self.ndim == 1\n    index = self._data.array\n    if isinstance(index, pd.MultiIndex):\n        valid_level_names = [name or '{}_level_{}'.format(self.dims[0], i) for i, name in enumerate(index.names)]\n        index = index.set_names(valid_level_names)\n    else:\n        index = index.set_names(self.name)\n    return index",
    ".xarray.core.variable.py@@IndexVariable.name": "def name(self):\n    return self.dims[0]",
    ".xarray.core.indexes.py@@PandasIndex.equals": "def equals(self, other):\n    return self.index.equals(other.index)",
    ".xarray.core.variable.py@@IndexVariable.copy": "def copy(self, deep=True, data=None):\n    if data is None:\n        data = self._data.copy(deep=deep)\n    else:\n        data = as_compatible_data(data)\n        if self.shape != data.shape:\n            raise ValueError('Data shape {} must match shape of object {}'.format(data.shape, self.shape))\n    return self._replace(data=data)",
    ".xarray.core.indexing.py@@PandasIndexingAdapter.copy": "def copy(self, deep: bool=True) -> 'PandasIndexingAdapter':\n    array = self.array.copy(deep=True) if deep else self.array\n    return type(self)(array, self._dtype)",
    ".xarray.core.indexes.py@@PandasIndex.copy": "def copy(self, deep=True):\n    return type(self)(self.index.copy(deep=deep), self.dim)",
    ".xarray.core.indexes.py@@PandasIndex.__init__": "def __init__(self, array: Any, dim: Hashable):\n    self.index = utils.safe_cast_to_index(array)\n    self.dim = dim",
    ".xarray.core.variable.py@@Variable._to_xindex": "def _to_xindex(self):\n    index_var = self.to_index_variable()\n    index = index_var.to_index()\n    dim = index_var.dims[0]\n    if isinstance(index, pd.MultiIndex):\n        return PandasMultiIndex(index, dim)\n    else:\n        return PandasIndex(index, dim)",
    ".xarray.core.variable.py@@IndexVariable.to_index_variable": "def to_index_variable(self):\n    return self",
    ".xarray.core.indexing.py@@PandasIndexingAdapter.dtype": "def dtype(self) -> np.dtype:\n    return self._dtype",
    ".xarray.core.alignment.py@@_get_joiner": "def _get_joiner(join, index_cls):\n    if join == 'outer':\n        return functools.partial(functools.reduce, index_cls.union)\n    elif join == 'inner':\n        return functools.partial(functools.reduce, index_cls.intersection)\n    elif join == 'left':\n        return operator.itemgetter(0)\n    elif join == 'right':\n        return operator.itemgetter(-1)\n    elif join == 'exact':\n        return None\n    elif join == 'override':\n        return operator.itemgetter(0)\n    else:\n        raise ValueError(f'invalid value for join: {join}')",
    ".xarray.core.indexes.py@@PandasIndex.intersection": "def intersection(self, other):\n    new_index = self.index.intersection(other.index)\n    return type(self)(new_index, self.dim)",
    ".xarray.core.indexes.py@@PandasIndex.to_pandas_index": "def to_pandas_index(self) -> pd.Index:\n    return self.index",
    ".xarray.core.utils.py@@maybe_coerce_to_str": "def maybe_coerce_to_str(index, original_coords):\n    from . import dtypes\n    try:\n        result_type = dtypes.result_type(*original_coords)\n    except TypeError:\n        pass\n    else:\n        if result_type.kind in 'SU':\n            index = np.asarray(index, dtype=result_type.type)\n    return index",
    ".xarray.core.dtypes.py@@result_type": "def result_type(*arrays_and_dtypes):\n    types = {np.result_type(t).type for t in arrays_and_dtypes}\n    for left, right in PROMOTE_TO_OBJECT:\n        if any((issubclass(t, left) for t in types)) and any((issubclass(t, right) for t in types)):\n            return np.dtype(object)\n    return np.result_type(*arrays_and_dtypes)",
    ".xarray.core.dataarray.py@@DataArray.dtype": "def dtype(self) -> np.dtype:\n    return self.variable.dtype",
    ".xarray.core.variable.py@@Variable.dtype": "def dtype(self):\n    return self._data.dtype",
    ".xarray.core.dataarray.py@@DataArray.reindex": "def reindex(self, indexers: Mapping[Any, Any]=None, method: str=None, tolerance=None, copy: bool=True, fill_value=dtypes.NA, **indexers_kwargs: Any) -> 'DataArray':\n    indexers = either_dict_or_kwargs(indexers, indexers_kwargs, 'reindex')\n    if isinstance(fill_value, dict):\n        fill_value = fill_value.copy()\n        sentinel = object()\n        value = fill_value.pop(self.name, sentinel)\n        if value is not sentinel:\n            fill_value[_THIS_ARRAY] = value\n    ds = self._to_temp_dataset().reindex(indexers=indexers, method=method, tolerance=tolerance, copy=copy, fill_value=fill_value)\n    return self._from_temp_dataset(ds)",
    ".xarray.core.utils.py@@either_dict_or_kwargs": "def either_dict_or_kwargs(pos_kwargs: Optional[Mapping[Any, T]], kw_kwargs: Mapping[str, T], func_name: str) -> Mapping[Hashable, T]:\n    if pos_kwargs is None:\n        return cast(Mapping[Hashable, T], kw_kwargs)\n    if not is_dict_like(pos_kwargs):\n        raise ValueError(f'the first argument to .{func_name} must be a dictionary')\n    if kw_kwargs:\n        raise ValueError(f'cannot specify both keyword and positional arguments to .{func_name}')\n    return pos_kwargs",
    ".xarray.core.dataset.py@@Dataset.reindex": "def reindex(self, indexers: Mapping[Any, Any]=None, method: str=None, tolerance: Number=None, copy: bool=True, fill_value: Any=dtypes.NA, **indexers_kwargs: Any) -> 'Dataset':\n    return self._reindex(indexers, method, tolerance, copy, fill_value, sparse=False, **indexers_kwargs)",
    ".xarray.core.dataset.py@@Dataset._reindex": "def _reindex(self, indexers: Mapping[Any, Any]=None, method: str=None, tolerance: Number=None, copy: bool=True, fill_value: Any=dtypes.NA, sparse: bool=False, **indexers_kwargs: Any) -> 'Dataset':\n    indexers = utils.either_dict_or_kwargs(indexers, indexers_kwargs, 'reindex')\n    bad_dims = [d for d in indexers if d not in self.dims]\n    if bad_dims:\n        raise ValueError(f'invalid reindex dimensions: {bad_dims}')\n    variables, indexes = alignment.reindex_variables(self.variables, self.sizes, self.xindexes, indexers, method, tolerance, copy=copy, fill_value=fill_value, sparse=sparse)\n    coord_names = set(self._coord_names)\n    coord_names.update(indexers)\n    return self._replace_with_new_dims(variables, coord_names, indexes=indexes)",
    ".xarray.core.dataset.py@@Dataset.dims": "def dims(self) -> Mapping[Hashable, int]:\n    return Frozen(self._dims)",
    ".xarray.core.dataset.py@@Dataset.sizes": "def sizes(self) -> Mapping[Hashable, int]:\n    return self.dims",
    ".xarray.core.alignment.py@@reindex_variables": "def reindex_variables(variables: Mapping[Any, Variable], sizes: Mapping[Any, int], indexes: Mapping[Any, Index], indexers: Mapping, method: Optional[str]=None, tolerance: Any=None, copy: bool=True, fill_value: Optional[Any]=dtypes.NA, sparse: bool=False) -> Tuple[Dict[Hashable, Variable], Dict[Hashable, Index]]:\n    from .dataarray import DataArray\n    reindexed: Dict[Hashable, Variable] = {}\n    int_indexers = {}\n    new_indexes = dict(indexes)\n    masked_dims = set()\n    unchanged_dims = set()\n    for dim, indexer in indexers.items():\n        if isinstance(indexer, DataArray) and indexer.dims != (dim,):\n            raise ValueError('Indexer has dimensions {:s} that are different from that to be indexed along {:s}'.format(str(indexer.dims), dim))\n        target = safe_cast_to_index(indexers[dim])\n        new_indexes[dim] = PandasIndex(target, dim)\n        if dim in indexes:\n            index = indexes[dim].to_pandas_index()\n            if not index.is_unique:\n                raise ValueError(f'cannot reindex or align along dimension {dim!r} because the index has duplicate values')\n            int_indexer = get_indexer_nd(index, target, method, tolerance)\n            if (int_indexer < 0).any():\n                masked_dims.add(dim)\n            elif np.array_equal(int_indexer, np.arange(len(index))):\n                unchanged_dims.add(dim)\n            int_indexers[dim] = int_indexer\n        if dim in variables:\n            var = variables[dim]\n            args: tuple = (var.attrs, var.encoding)\n        else:\n            args = ()\n        reindexed[dim] = IndexVariable((dim,), indexers[dim], *args)\n    for dim in sizes:\n        if dim not in indexes and dim in indexers:\n            existing_size = sizes[dim]\n            new_size = indexers[dim].size\n            if existing_size != new_size:\n                raise ValueError(f'cannot reindex or align along dimension {dim!r} without an index because its size {existing_size!r} is different from the size of the new index {new_size!r}')\n    for name, var in variables.items():\n        if name not in indexers:\n            if isinstance(fill_value, dict):\n                fill_value_ = fill_value.get(name, dtypes.NA)\n            else:\n                fill_value_ = fill_value\n            if sparse:\n                var = var._as_sparse(fill_value=fill_value_)\n            key = tuple((slice(None) if d in unchanged_dims else int_indexers.get(d, slice(None)) for d in var.dims))\n            needs_masking = any((d in masked_dims for d in var.dims))\n            if needs_masking:\n                new_var = var._getitem_with_mask(key, fill_value=fill_value_)\n            elif all((is_full_slice(k) for k in key)):\n                new_var = var.copy(deep=copy)\n            else:\n                new_var = var[key]\n            reindexed[name] = new_var\n    return (reindexed, new_indexes)",
    ".xarray.core.indexes.py@@Indexes.__contains__": "def __contains__(self, key):\n    return key in self._indexes",
    ".xarray.core.indexes.py@@get_indexer_nd": "def get_indexer_nd(index, labels, method=None, tolerance=None):\n    flat_labels = np.ravel(labels)\n    flat_indexer = index.get_indexer(flat_labels, method=method, tolerance=tolerance)\n    indexer = flat_indexer.reshape(labels.shape)\n    return indexer",
    ".xarray.core.utils.py@@is_full_slice": "def is_full_slice(value: Any) -> bool:\n    return isinstance(value, slice) and value == slice(None)",
    ".xarray.core.variable.py@@Variable.__getitem__": "def __getitem__(self: T_Variable, key) -> T_Variable:\n    dims, indexer, new_order = self._broadcast_indexes(key)\n    data = as_indexable(self._data)[indexer]\n    if new_order:\n        data = np.moveaxis(data, range(len(new_order)), new_order)\n    return self._finalize_indexing_result(dims, data)",
    ".xarray.core.variable.py@@Variable._broadcast_indexes": "def _broadcast_indexes(self, key):\n    key = self._item_key_to_tuple(key)\n    key = indexing.expanded_indexer(key, self.ndim)\n    key = tuple((k.data.item() if isinstance(k, Variable) and k.ndim == 0 else k for k in key))\n    key = tuple((k.item() if isinstance(k, np.ndarray) and k.ndim == 0 else k for k in key))\n    if all((isinstance(k, BASIC_INDEXING_TYPES) for k in key)):\n        return self._broadcast_indexes_basic(key)\n    self._validate_indexers(key)\n    if all((not isinstance(k, Variable) for k in key)):\n        return self._broadcast_indexes_outer(key)\n    dims = []\n    for k, d in zip(key, self.dims):\n        if isinstance(k, Variable):\n            if len(k.dims) > 1:\n                return self._broadcast_indexes_vectorized(key)\n            dims.append(k.dims[0])\n        elif not isinstance(k, integer_types):\n            dims.append(d)\n    if len(set(dims)) == len(dims):\n        return self._broadcast_indexes_outer(key)\n    return self._broadcast_indexes_vectorized(key)",
    ".xarray.core.variable.py@@Variable._item_key_to_tuple": "def _item_key_to_tuple(self, key):\n    if utils.is_dict_like(key):\n        return tuple((key.get(dim, slice(None)) for dim in self.dims))\n    else:\n        return key",
    ".xarray.core.indexing.py@@expanded_indexer": "def expanded_indexer(key, ndim):\n    if not isinstance(key, tuple):\n        key = (key,)\n    new_key = []\n    found_ellipsis = False\n    for k in key:\n        if k is Ellipsis:\n            if not found_ellipsis:\n                new_key.extend((ndim + 1 - len(key)) * [slice(None)])\n                found_ellipsis = True\n            else:\n                new_key.append(slice(None))\n        else:\n            new_key.append(k)\n    if len(new_key) > ndim:\n        raise IndexError('too many indices')\n    new_key.extend((ndim - len(new_key)) * [slice(None)])\n    return tuple(new_key)",
    ".xarray.core.variable.py@@Variable._validate_indexers": "def _validate_indexers(self, key):\n    for dim, k in zip(self.dims, key):\n        if not isinstance(k, BASIC_INDEXING_TYPES):\n            if not isinstance(k, Variable):\n                k = np.asarray(k)\n                if k.ndim > 1:\n                    raise IndexError('Unlabeled multi-dimensional array cannot be used for indexing: {}'.format(k))\n            if k.dtype.kind == 'b':\n                if self.shape[self.get_axis_num(dim)] != len(k):\n                    raise IndexError('Boolean array size {:d} is used to index array with shape {:s}.'.format(len(k), str(self.shape)))\n                if k.ndim > 1:\n                    raise IndexError('{}-dimensional boolean indexing is not supported. '.format(k.ndim))\n                if getattr(k, 'dims', (dim,)) != (dim,):\n                    raise IndexError('Boolean indexer should be unlabeled or on the same dimension to the indexed array. Indexer is on {:s} but the target dimension is {:s}.'.format(str(k.dims), dim))",
    ".xarray.core.variable.py@@Variable._broadcast_indexes_outer": "def _broadcast_indexes_outer(self, key):\n    dims = tuple((k.dims[0] if isinstance(k, Variable) else dim for k, dim in zip(key, self.dims) if not isinstance(k, integer_types)))\n    new_key = []\n    for k in key:\n        if isinstance(k, Variable):\n            k = k.data\n        if not isinstance(k, BASIC_INDEXING_TYPES):\n            k = np.asarray(k)\n            if k.size == 0:\n                k = k.astype(int)\n            elif k.dtype.kind == 'b':\n                k, = np.nonzero(k)\n        new_key.append(k)\n    return (dims, OuterIndexer(tuple(new_key)), None)",
    ".xarray.core.indexing.py@@OuterIndexer.__init__": "def __init__(self, key):\n    if not isinstance(key, tuple):\n        raise TypeError(f'key must be a tuple: {key!r}')\n    new_key = []\n    for k in key:\n        if isinstance(k, integer_types):\n            k = int(k)\n        elif isinstance(k, slice):\n            k = as_integer_slice(k)\n        elif isinstance(k, np.ndarray):\n            if not np.issubdtype(k.dtype, np.integer):\n                raise TypeError(f'invalid indexer array, does not have integer dtype: {k!r}')\n            if k.ndim != 1:\n                raise TypeError(f'invalid indexer array for {type(self).__name__}; must have exactly 1 dimension: {k!r}')\n            k = np.asarray(k, dtype=np.int64)\n        else:\n            raise TypeError(f'unexpected indexer type for {type(self).__name__}: {k!r}')\n        new_key.append(k)\n    super().__init__(new_key)",
    ".xarray.core.indexing.py@@as_integer_slice": "def as_integer_slice(value):\n    start = as_integer_or_none(value.start)\n    stop = as_integer_or_none(value.stop)\n    step = as_integer_or_none(value.step)\n    return slice(start, stop, step)",
    ".xarray.core.indexing.py@@as_integer_or_none": "def as_integer_or_none(value):\n    return None if value is None else operator.index(value)",
    ".xarray.core.indexing.py@@ExplicitIndexer.__init__": "def __init__(self, key):\n    if type(self) is ExplicitIndexer:\n        raise TypeError('cannot instantiate base ExplicitIndexer objects')\n    self._key = tuple(key)",
    ".xarray.core.indexing.py@@as_indexable": "def as_indexable(array):\n    if isinstance(array, ExplicitlyIndexed):\n        return array\n    if isinstance(array, np.ndarray):\n        return NumpyIndexingAdapter(array)\n    if isinstance(array, pd.Index):\n        return PandasIndexingAdapter(array)\n    if isinstance(array, dask_array_type):\n        return DaskIndexingAdapter(array)\n    if hasattr(array, '__array_function__'):\n        return NdArrayLikeIndexingAdapter(array)\n    raise TypeError('Invalid array type: {}'.format(type(array)))",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.__init__": "def __init__(self, array):\n    if not isinstance(array, np.ndarray):\n        raise TypeError('NumpyIndexingAdapter only wraps np.ndarray. Trying to wrap {}'.format(type(array)))\n    self.array = array",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.__getitem__": "def __getitem__(self, key):\n    array, key = self._indexing_array_and_key(key)\n    return array[key]",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter._indexing_array_and_key": "def _indexing_array_and_key(self, key):\n    if isinstance(key, OuterIndexer):\n        array = self.array\n        key = _outer_to_numpy_indexer(key, self.array.shape)\n    elif isinstance(key, VectorizedIndexer):\n        array = nputils.NumpyVIndexAdapter(self.array)\n        key = key.tuple\n    elif isinstance(key, BasicIndexer):\n        array = self.array\n        key = key.tuple + (Ellipsis,)\n    else:\n        raise TypeError('unexpected key type: {}'.format(type(key)))\n    return (array, key)",
    ".xarray.core.indexing.py@@_outer_to_numpy_indexer": "def _outer_to_numpy_indexer(key, shape):\n    if len([k for k in key.tuple if not isinstance(k, slice)]) <= 1:\n        return key.tuple\n    else:\n        return _outer_to_vectorized_indexer(key, shape).tuple",
    ".xarray.core.indexing.py@@ExplicitIndexer.tuple": "def tuple(self):\n    return self._key",
    ".xarray.core.variable.py@@Variable._finalize_indexing_result": "def _finalize_indexing_result(self: T_Variable, dims, data) -> T_Variable:\n    return self._replace(dims=dims, data=data)",
    ".xarray.core.dataset.py@@Dataset._replace_with_new_dims": "def _replace_with_new_dims(self, variables: Dict[Hashable, Variable], coord_names: set=None, attrs: Union[Dict[Hashable, Any], None, Default]=_default, indexes: Union[Dict[Hashable, Index], None, Default]=_default, inplace: bool=False) -> 'Dataset':\n    dims = calculate_dimensions(variables)\n    return self._replace(variables, coord_names, dims, attrs, indexes, inplace=inplace)",
    ".xarray.core.dataarray.py@@DataArray._from_temp_dataset": "def _from_temp_dataset(self, dataset: Dataset, name: Union[Hashable, None, Default]=_default) -> 'DataArray':\n    variable = dataset._variables.pop(_THIS_ARRAY)\n    coords = dataset._variables\n    indexes = dataset._indexes\n    return self._replace(variable, coords, name, indexes=indexes)",
    ".xarray.core._typed_ops.py@@DataArrayOpsMixin.__invert__": "def __invert__(self):\n    return self._unary_op(operator.invert)",
    ".xarray.core.dataarray.py@@DataArray._unary_op": "def _unary_op(self, f: Callable, *args, **kwargs):\n    keep_attrs = kwargs.pop('keep_attrs', None)\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=True)\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', 'All-NaN (slice|axis) encountered')\n        warnings.filterwarnings('ignore', 'Mean of empty slice', category=RuntimeWarning)\n        with np.errstate(all='ignore'):\n            da = self.__array_wrap__(f(self.variable.data, *args, **kwargs))\n        if keep_attrs:\n            da.attrs = self.attrs\n        return da",
    ".xarray.core.dataarray.py@@DataArray.__array_wrap__": "def __array_wrap__(self, obj, context=None) -> 'DataArray':\n    new_var = self.variable.__array_wrap__(obj, context)\n    return self._replace(new_var)",
    ".xarray.core.variable.py@@Variable.__array_wrap__": "def __array_wrap__(self, obj, context=None):\n    return Variable(self.dims, obj)",
    ".xarray.core.common.py@@DataWithCoords.where": "def where(self, cond, other=dtypes.NA, drop: bool=False):\n    from .alignment import align\n    from .dataarray import DataArray\n    from .dataset import Dataset\n    if callable(cond):\n        cond = cond(self)\n    if drop:\n        if other is not dtypes.NA:\n            raise ValueError('cannot set `other` if drop=True')\n        if not isinstance(cond, (Dataset, DataArray)):\n            raise TypeError(f'cond argument is {cond!r} but must be a {Dataset!r} or {DataArray!r}')\n        self, cond = align(self, cond)\n        if isinstance(cond, Dataset):\n            clipcond = cond.to_array().any('variable')\n        else:\n            clipcond = cond\n        nonzeros = zip(clipcond.dims, np.nonzero(clipcond.values))\n        indexers = {k: np.unique(v) for k, v in nonzeros}\n        self = self.isel(**indexers)\n        cond = cond.isel(**indexers)\n    return ops.where_method(self, cond, other)",
    ".xarray.core.ops.py@@where_method": "def where_method(self, cond, other=dtypes.NA):\n    from .computation import apply_ufunc\n    join = 'inner' if other is dtypes.NA else 'exact'\n    return apply_ufunc(duck_array_ops.where_method, self, cond, other, join=join, dataset_join=join, dask='allowed', keep_attrs=True)",
    ".xarray.core.duck_array_ops.py@@where_method": "def where_method(data, cond, other=dtypes.NA):\n    if other is dtypes.NA:\n        other = dtypes.get_fill_value(data.dtype)\n    return where(cond, data, other)",
    ".xarray.core.dtypes.py@@get_fill_value": "def get_fill_value(dtype):\n    _, fill_value = maybe_promote(dtype)\n    return fill_value",
    ".xarray.core.dtypes.py@@maybe_promote": "def maybe_promote(dtype):\n    if np.issubdtype(dtype, np.floating):\n        fill_value = np.nan\n    elif np.issubdtype(dtype, np.timedelta64):\n        fill_value = np.timedelta64('NaT')\n    elif np.issubdtype(dtype, np.integer):\n        dtype = np.float32 if dtype.itemsize <= 2 else np.float64\n        fill_value = np.nan\n    elif np.issubdtype(dtype, np.complexfloating):\n        fill_value = np.nan + np.nan * 1j\n    elif np.issubdtype(dtype, np.datetime64):\n        fill_value = np.datetime64('NaT')\n    else:\n        dtype = object\n        fill_value = np.nan\n    return (np.dtype(dtype), fill_value)",
    ".xarray.core.duck_array_ops.py@@where": "def where(condition, x, y):\n    return _where(condition, *as_shared_dtype([x, y]))",
    ".xarray.core.duck_array_ops.py@@as_shared_dtype": "def as_shared_dtype(scalars_or_arrays):\n    if any((isinstance(x, cupy_array_type) for x in scalars_or_arrays)):\n        import cupy as cp\n        arrays = [asarray(x, xp=cp) for x in scalars_or_arrays]\n    else:\n        arrays = [asarray(x) for x in scalars_or_arrays]\n    out_type = dtypes.result_type(*arrays)\n    return [x.astype(out_type, copy=False) for x in arrays]",
    ".xarray.core.indexing.py@@PandasIndexingAdapter.__array__": "def __array__(self, dtype: DTypeLike=None) -> np.ndarray:\n    if dtype is None:\n        dtype = self.dtype\n    array = self.array\n    if isinstance(array, pd.PeriodIndex):\n        with suppress(AttributeError):\n            array = array.astype('object')\n    return np.asarray(array.values, dtype=dtype)",
    ".xarray.core.variable.py@@_possibly_convert_objects": "def _possibly_convert_objects(values):\n    return np.asarray(pd.Series(values.ravel())).reshape(values.shape)",
    ".xarray.core.variable.py@@Variable.to_index_variable": "def to_index_variable(self):\n    return IndexVariable(self.dims, self._data, self._attrs, encoding=self._encoding, fastpath=True)",
    ".xarray.core.coordinates.py@@DatasetCoordinates.__getitem__": "def __getitem__(self, key: Hashable) -> 'DataArray':\n    if key in self._data.data_vars:\n        raise KeyError(key)\n    return cast('DataArray', self._data[key])",
    ".xarray.core.dataset.py@@DataVariables.__contains__": "def __contains__(self, key: Hashable) -> bool:\n    return key in self._dataset._variables and key not in self._dataset._coord_names",
    ".xarray.core.dataarray.py@@DataArray.to_index": "def to_index(self) -> pd.Index:\n    return self.variable.to_index()",
    ".xarray.core.indexes.py@@PandasIndex.from_pandas_index": "def from_pandas_index(cls, index: pd.Index, dim: Hashable):\n    from .variable import IndexVariable\n    if index.name is None:\n        name = dim\n        index = index.copy()\n        index.name = dim\n    else:\n        name = index.name\n    data = PandasIndexingAdapter(index)\n    index_var = IndexVariable(dim, data, fastpath=True)\n    return (cls(index, dim), {name: index_var})",
    ".xarray.core.dataset.py@@Dataset.encoding": "def encoding(self) -> Dict:\n    if self._encoding is None:\n        self._encoding = {}\n    return self._encoding",
    ".xarray.core.indexing.py@@DaskIndexingAdapter.__init__": "def __init__(self, array):\n    self.array = array",
    ".xarray.core.indexing.py@@DaskIndexingAdapter.__getitem__": "def __getitem__(self, key):\n    if not isinstance(key, VectorizedIndexer):\n        rewritten_indexer = False\n        new_indexer = []\n        for idim, k in enumerate(key.tuple):\n            if isinstance(k, Iterable) and duck_array_ops.array_equiv(k, np.arange(self.array.shape[idim])):\n                new_indexer.append(slice(None))\n                rewritten_indexer = True\n            else:\n                new_indexer.append(k)\n        if rewritten_indexer:\n            key = type(key)(tuple(new_indexer))\n    if isinstance(key, BasicIndexer):\n        return self.array[key.tuple]\n    elif isinstance(key, VectorizedIndexer):\n        return self.array.vindex[key.tuple]\n    else:\n        assert isinstance(key, OuterIndexer)\n        key = key.tuple\n        try:\n            return self.array[key]\n        except NotImplementedError:\n            value = self.array\n            for axis, subkey in reversed(list(enumerate(key))):\n                value = value[(slice(None),) * axis + (subkey,)]\n            return value",
    ".xarray.core.duck_array_ops.py@@array_equiv": "def array_equiv(arr1, arr2):\n    arr1 = asarray(arr1)\n    arr2 = asarray(arr2)\n    lazy_equiv = lazy_array_equiv(arr1, arr2)\n    if lazy_equiv is None:\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore', \"In the future, 'NAT == x'\")\n            flag_array = (arr1 == arr2) | isnull(arr1) & isnull(arr2)\n            return bool(flag_array.all())\n    else:\n        return lazy_equiv",
    ".xarray.core.duck_array_ops.py@@lazy_array_equiv": "def lazy_array_equiv(arr1, arr2):\n    if arr1 is arr2:\n        return True\n    arr1 = asarray(arr1)\n    arr2 = asarray(arr2)\n    if arr1.shape != arr2.shape:\n        return False\n    if dask_array and is_duck_dask_array(arr1) and is_duck_dask_array(arr2):\n        if tokenize(arr1) == tokenize(arr2):\n            return True\n        else:\n            return None\n    return None"
}