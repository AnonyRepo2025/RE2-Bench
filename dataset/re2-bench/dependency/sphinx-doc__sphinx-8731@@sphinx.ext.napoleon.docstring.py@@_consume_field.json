{
    ".sphinx.ext.napoleon.iterators.py@@peek_iter.__next__": "def __next__(self, n: int=None) -> Any:\n    return self.next(n)",
    ".sphinx.ext.napoleon.iterators.py@@peek_iter.next": "def next(self, n: int=None) -> Any:\n    self._fillcache(n)\n    if not n:\n        if self._cache[0] == self.sentinel:\n            raise StopIteration\n        if n is None:\n            result = self._cache.popleft()\n        else:\n            result = []\n    else:\n        if self._cache[n - 1] == self.sentinel:\n            raise StopIteration\n        result = [self._cache.popleft() for i in range(n)]\n    return result",
    ".sphinx.ext.napoleon.iterators.py@@modify_iter._fillcache": "def _fillcache(self, n: Optional[int]) -> None:\n    if not n:\n        n = 1\n    try:\n        while len(self._cache) < n:\n            self._cache.append(self.modifier(next(self._iterable)))\n    except StopIteration:\n        while len(self._cache) < n:\n            self._cache.append(self.sentinel)",
    ".sphinx.ext.napoleon.docstring.py@@NumpyDocstring._escape_args_and_kwargs": "def _escape_args_and_kwargs(self, name: str) -> str:\n    func = super()._escape_args_and_kwargs\n    if ', ' in name:\n        return ', '.join((func(param) for param in name.split(', ')))\n    else:\n        return func(name)",
    ".sphinx.ext.napoleon.iterators.py@@peek_iter.peek": "def peek(self, n: Optional[int]=None) -> Any:\n    self._fillcache(n)\n    if n is None:\n        result = self._cache[0]\n    else:\n        result = [self._cache[i] for i in range(n)]\n    return result",
    ".sphinx.ext.napoleon.docstring.py@@NumpyDocstring._is_section_break": "def _is_section_break(self) -> bool:\n    line1, line2 = self._line_iter.peek(2)\n    return not self._line_iter.has_next() or self._is_section_header() or ['', ''] == [line1, line2] or (self._is_in_section and line1 and (not self._is_indented(line1, self._section_indent)))",
    ".sphinx.ext.napoleon.iterators.py@@peek_iter.has_next": "def has_next(self) -> bool:\n    return self.peek() != self.sentinel",
    ".sphinx.ext.napoleon.docstring.py@@NumpyDocstring._is_section_header": "def _is_section_header(self) -> bool:\n    section, underline = self._line_iter.peek(2)\n    section = section.lower()\n    if section in self._sections and isinstance(underline, str):\n        return bool(_numpy_section_regex.match(underline))\n    elif self._directive_sections:\n        if _directive_regex.match(section):\n            for directive_section in self._directive_sections:\n                if section.startswith(directive_section):\n                    return True\n    return False",
    ".sphinx.ext.napoleon.docstring.py@@NumpyDocstring.__init__": "def __init__(self, docstring: Union[str, List[str]], config: SphinxConfig=None, app: Sphinx=None, what: str='', name: str='', obj: Any=None, options: Any=None) -> None:\n    self._directive_sections = ['.. index::']\n    super().__init__(docstring, config, app, what, name, obj, options)",
    ".sphinx.ext.napoleon.iterators.py@@modify_iter.__init__": "def __init__(self, *args: Any, **kwargs: Any) -> None:\n    if 'modifier' in kwargs:\n        self.modifier = kwargs['modifier']\n    elif len(args) > 2:\n        self.modifier = args[2]\n        args = args[:2]\n    else:\n        self.modifier = lambda x: x\n    if not callable(self.modifier):\n        raise TypeError('modify_iter(o, modifier): modifier must be callable')\n    super().__init__(*args)",
    ".sphinx.ext.napoleon.iterators.py@@peek_iter.__init__": "def __init__(self, *args: Any) -> None:\n    self._iterable = iter(*args)\n    self._cache = collections.deque()\n    if len(args) == 2:\n        self.sentinel = args[1]\n    else:\n        self.sentinel = object()",
    ".sphinx.ext.napoleon.docstring.py@@NumpyDocstring._get_location": "def _get_location(self) -> str:\n    try:\n        filepath = inspect.getfile(self._obj) if self._obj is not None else None\n    except TypeError:\n        filepath = None\n    name = self._name\n    if filepath is None and name is None:\n        return None\n    elif filepath is None:\n        filepath = ''\n    return ':'.join([filepath, 'docstring of %s' % name])",
    ".sphinx.ext.napoleon.docstring.py@@_convert_numpy_type_spec": "def _convert_numpy_type_spec(_type: str, location: str=None, translations: dict={}) -> str:\n\n    def convert_obj(obj, translations, default_translation):\n        translation = translations.get(obj, obj)\n        if translation in _SINGLETONS and default_translation == ':class:`%s`':\n            default_translation = ':obj:`%s`'\n        elif translation == '...' and default_translation == ':class:`%s`':\n            default_translation = ':obj:`%s <Ellipsis>`'\n        if _xref_regex.match(translation) is None:\n            translation = default_translation % translation\n        return translation\n    tokens = _tokenize_type_spec(_type)\n    combined_tokens = _recombine_set_tokens(tokens)\n    types = [(token, _token_type(token, location)) for token in combined_tokens]\n    converters = {'literal': lambda x: '``%s``' % x, 'obj': lambda x: convert_obj(x, translations, ':class:`%s`'), 'control': lambda x: '*%s*' % x, 'delimiter': lambda x: x, 'reference': lambda x: x}\n    converted = ''.join((converters.get(type_)(token) for token, type_ in types))\n    return converted",
    ".sphinx.ext.napoleon.docstring.py@@_tokenize_type_spec": "def _tokenize_type_spec(spec: str) -> List[str]:\n\n    def postprocess(item):\n        if _default_regex.match(item):\n            default = item[:7]\n            other = item[8:]\n            return [default, ' ', other]\n        else:\n            return [item]\n    tokens = list((item for raw_token in _token_regex.split(spec) for item in postprocess(raw_token) if item))\n    return tokens",
    ".sphinx.ext.napoleon.docstring.py@@postprocess": "def postprocess(item):\n    if _default_regex.match(item):\n        default = item[:7]\n        other = item[8:]\n        return [default, ' ', other]\n    else:\n        return [item]",
    ".sphinx.ext.napoleon.docstring.py@@_recombine_set_tokens": "def _recombine_set_tokens(tokens: List[str]) -> List[str]:\n    token_queue = collections.deque(tokens)\n    keywords = ('optional', 'default')\n\n    def takewhile_set(tokens):\n        open_braces = 0\n        previous_token = None\n        while True:\n            try:\n                token = tokens.popleft()\n            except IndexError:\n                break\n            if token == ', ':\n                previous_token = token\n                continue\n            if not token.strip():\n                continue\n            if token in keywords:\n                tokens.appendleft(token)\n                if previous_token is not None:\n                    tokens.appendleft(previous_token)\n                break\n            if previous_token is not None:\n                yield previous_token\n                previous_token = None\n            if token == '{':\n                open_braces += 1\n            elif token == '}':\n                open_braces -= 1\n            yield token\n            if open_braces == 0:\n                break\n\n    def combine_set(tokens):\n        while True:\n            try:\n                token = tokens.popleft()\n            except IndexError:\n                break\n            if token == '{':\n                tokens.appendleft('{')\n                yield ''.join(takewhile_set(tokens))\n            else:\n                yield token\n    return list(combine_set(token_queue))",
    ".sphinx.ext.napoleon.docstring.py@@combine_set": "def combine_set(tokens):\n    while True:\n        try:\n            token = tokens.popleft()\n        except IndexError:\n            break\n        if token == '{':\n            tokens.appendleft('{')\n            yield ''.join(takewhile_set(tokens))\n        else:\n            yield token",
    ".sphinx.ext.napoleon.docstring.py@@_token_type": "def _token_type(token: str, location: str=None) -> str:\n\n    def is_numeric(token):\n        try:\n            complex(token)\n        except ValueError:\n            return False\n        else:\n            return True\n    if token.startswith(' ') or token.endswith(' '):\n        type_ = 'delimiter'\n    elif is_numeric(token) or (token.startswith('{') and token.endswith('}')) or (token.startswith('\"') and token.endswith('\"')) or (token.startswith(\"'\") and token.endswith(\"'\")):\n        type_ = 'literal'\n    elif token.startswith('{'):\n        logger.warning(__('invalid value set (missing closing brace): %s'), token, location=location)\n        type_ = 'literal'\n    elif token.endswith('}'):\n        logger.warning(__('invalid value set (missing opening brace): %s'), token, location=location)\n        type_ = 'literal'\n    elif token.startswith(\"'\") or token.startswith('\"'):\n        logger.warning(__('malformed string literal (missing closing quote): %s'), token, location=location)\n        type_ = 'literal'\n    elif token.endswith(\"'\") or token.endswith('\"'):\n        logger.warning(__('malformed string literal (missing opening quote): %s'), token, location=location)\n        type_ = 'literal'\n    elif token in ('optional', 'default'):\n        type_ = 'control'\n    elif _xref_regex.match(token):\n        type_ = 'reference'\n    else:\n        type_ = 'obj'\n    return type_",
    ".sphinx.ext.napoleon.docstring.py@@is_numeric": "def is_numeric(token):\n    try:\n        complex(token)\n    except ValueError:\n        return False\n    else:\n        return True",
    ".sphinx.ext.napoleon.docstring.py@@convert_obj": "def convert_obj(obj, translations, default_translation):\n    translation = translations.get(obj, obj)\n    if translation in _SINGLETONS and default_translation == ':class:`%s`':\n        default_translation = ':obj:`%s`'\n    elif translation == '...' and default_translation == ':class:`%s`':\n        default_translation = ':obj:`%s <Ellipsis>`'\n    if _xref_regex.match(translation) is None:\n        translation = default_translation % translation\n    return translation",
    ".sphinx.ext.napoleon.docstring.py@@takewhile_set": "def takewhile_set(tokens):\n    open_braces = 0\n    previous_token = None\n    while True:\n        try:\n            token = tokens.popleft()\n        except IndexError:\n            break\n        if token == ', ':\n            previous_token = token\n            continue\n        if not token.strip():\n            continue\n        if token in keywords:\n            tokens.appendleft(token)\n            if previous_token is not None:\n                tokens.appendleft(previous_token)\n            break\n        if previous_token is not None:\n            yield previous_token\n            previous_token = None\n        if token == '{':\n            open_braces += 1\n        elif token == '}':\n            open_braces -= 1\n        yield token\n        if open_braces == 0:\n            break",
    ".sphinx.util.typing.py@@get_type_hints": "def get_type_hints(obj: Any, globalns: Dict=None, localns: Dict=None) -> Dict[str, Any]:\n    from sphinx.util.inspect import safe_getattr\n    try:\n        return typing.get_type_hints(obj, globalns, localns)\n    except NameError:\n        return safe_getattr(obj, '__annotations__', {})\n    except TypeError:\n        return {}\n    except KeyError:\n        return {}\n    except AttributeError:\n        return {}",
    ".sphinx.util.typing.py@@stringify": "def stringify(annotation: Any) -> str:\n    from sphinx.util import inspect\n    if isinstance(annotation, str):\n        if annotation.startswith(\"'\") and annotation.endswith(\"'\"):\n            return annotation[1:-1]\n        else:\n            return annotation\n    elif isinstance(annotation, TypeVar):\n        return annotation.__name__\n    elif inspect.isNewType(annotation):\n        return annotation.__name__\n    elif not annotation:\n        return repr(annotation)\n    elif annotation is NoneType:\n        return 'None'\n    elif getattr(annotation, '__module__', None) == 'builtins' and hasattr(annotation, '__qualname__'):\n        return annotation.__qualname__\n    elif annotation is Ellipsis:\n        return '...'\n    elif annotation is Struct:\n        return 'struct.Struct'\n    if sys.version_info >= (3, 7):\n        return _stringify_py37(annotation)\n    else:\n        return _stringify_py36(annotation)",
    ".sphinx.util.inspect.py@@isNewType": "def isNewType(obj: Any) -> bool:\n    __module__ = safe_getattr(obj, '__module__', None)\n    __qualname__ = safe_getattr(obj, '__qualname__', None)\n    if __module__ == 'typing' and __qualname__ == 'NewType.<locals>.new_type':\n        return True\n    else:\n        return False",
    ".sphinx.util.inspect.py@@safe_getattr": "def safe_getattr(obj: Any, name: str, *defargs: Any) -> Any:\n    try:\n        return getattr(obj, name, *defargs)\n    except Exception as exc:\n        try:\n            return obj.__dict__[name]\n        except Exception:\n            pass\n        if defargs:\n            return defargs[0]\n        raise AttributeError(name) from exc"
}