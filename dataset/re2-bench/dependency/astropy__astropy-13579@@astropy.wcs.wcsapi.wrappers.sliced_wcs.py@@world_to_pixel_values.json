{
    ".astropy.wcs.wcsapi.fitswcs.py@@FITSWCSAPIMixin.pixel_n_dim": "def pixel_n_dim(self):\n    return self.naxis",
    ".astropy.wcs.wcsapi.fitswcs.py@@FITSWCSAPIMixin.pixel_to_world_values": "def pixel_to_world_values(self, *pixel_arrays):\n    world = self.all_pix2world(*pixel_arrays, 0)\n    return world[0] if self.world_n_dim == 1 else tuple(world)",
    ".astropy.wcs.wcs.py@@WCS.all_pix2world": "def all_pix2world(self, *args, **kwargs):\n    return self._array_converter(self._all_pix2world, 'output', *args, **kwargs)",
    ".astropy.wcs.wcs.py@@WCS._array_converter": "def _array_converter(self, func, sky, *args, ra_dec_order=False):\n\n    def _return_list_of_arrays(axes, origin):\n        if any([x.size == 0 for x in axes]):\n            return axes\n        try:\n            axes = np.broadcast_arrays(*axes)\n        except ValueError:\n            raise ValueError('Coordinate arrays are not broadcastable to each other')\n        xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n        if ra_dec_order and sky == 'input':\n            xy = self._denormalize_sky(xy)\n        output = func(xy, origin)\n        if ra_dec_order and sky == 'output':\n            output = self._normalize_sky(output)\n            return (output[:, 0].reshape(axes[0].shape), output[:, 1].reshape(axes[0].shape))\n        return [output[:, i].reshape(axes[0].shape) for i in range(output.shape[1])]\n\n    def _return_single_array(xy, origin):\n        if xy.shape[-1] != self.naxis:\n            raise ValueError('When providing two arguments, the array must be of shape (N, {})'.format(self.naxis))\n        if 0 in xy.shape:\n            return xy\n        if ra_dec_order and sky == 'input':\n            xy = self._denormalize_sky(xy)\n        result = func(xy, origin)\n        if ra_dec_order and sky == 'output':\n            result = self._normalize_sky(result)\n        return result\n    if len(args) == 2:\n        try:\n            xy, origin = args\n            xy = np.asarray(xy)\n            origin = int(origin)\n        except Exception:\n            raise TypeError('When providing two arguments, they must be (coords[N][{}], origin)'.format(self.naxis))\n        if xy.shape == () or len(xy.shape) == 1:\n            return _return_list_of_arrays([xy], origin)\n        return _return_single_array(xy, origin)\n    elif len(args) == self.naxis + 1:\n        axes = args[:-1]\n        origin = args[-1]\n        try:\n            axes = [np.asarray(x) for x in axes]\n            origin = int(origin)\n        except Exception:\n            raise TypeError('When providing more than two arguments, they must be ' + 'a 1-D array for each axis, followed by an origin.')\n        return _return_list_of_arrays(axes, origin)\n    raise TypeError('WCS projection has {0} dimensions, so expected 2 (an Nx{0} array and the origin argument) or {1} arguments (the position in each dimension, and the origin argument). Instead, {2} arguments were given.'.format(self.naxis, self.naxis + 1, len(args)))",
    ".astropy.wcs.wcs.py@@WCS._return_list_of_arrays": "def _return_list_of_arrays(axes, origin):\n    if any([x.size == 0 for x in axes]):\n        return axes\n    try:\n        axes = np.broadcast_arrays(*axes)\n    except ValueError:\n        raise ValueError('Coordinate arrays are not broadcastable to each other')\n    xy = np.hstack([x.reshape((x.size, 1)) for x in axes])\n    if ra_dec_order and sky == 'input':\n        xy = self._denormalize_sky(xy)\n    output = func(xy, origin)\n    if ra_dec_order and sky == 'output':\n        output = self._normalize_sky(output)\n        return (output[:, 0].reshape(axes[0].shape), output[:, 1].reshape(axes[0].shape))\n    return [output[:, i].reshape(axes[0].shape) for i in range(output.shape[1])]",
    ".astropy.wcs.wcsapi.fitswcs.py@@FITSWCSAPIMixin.world_n_dim": "def world_n_dim(self):\n    return len(self.wcs.ctype)",
    ".astropy.wcs.wcsapi.fitswcs.py@@FITSWCSAPIMixin.world_to_pixel_values": "def world_to_pixel_values(self, *world_arrays):\n    from astropy.wcs.wcs import NoConvergence\n    try:\n        pixel = self.all_world2pix(*world_arrays, 0)\n    except NoConvergence as e:\n        warnings.warn(str(e))\n        pixel = self._array_converter(lambda *args: e.best_solution, 'input', *world_arrays, 0)\n    return pixel[0] if self.pixel_n_dim == 1 else tuple(pixel)",
    ".astropy.utils.decorators.py@@wrapper": "def wrapper(func):\n    return cls(func, lazy=lazy)",
    ".astropy.wcs.wcs.py@@WCS.all_world2pix": "def all_world2pix(self, *args, tolerance=0.0001, maxiter=20, adaptive=False, detect_divergence=True, quiet=False, **kwargs):\n    if self.wcs is None:\n        raise ValueError('No basic WCS settings were created.')\n    return self._array_converter(lambda *args, **kwargs: self._all_world2pix(*args, tolerance=tolerance, maxiter=maxiter, adaptive=adaptive, detect_divergence=detect_divergence, quiet=quiet), 'input', *args, **kwargs)",
    ".astropy.wcs.wcs.py@@WCS._all_world2pix": "def _all_world2pix(self, world, origin, tolerance, maxiter, adaptive, detect_divergence, quiet):\n    pix0 = self.wcs_world2pix(world, origin)\n    if not self.has_distortion:\n        return pix0\n    pix = pix0.copy()\n    dpix = self.pix2foc(pix, origin) - pix0\n    pix -= dpix\n    dn = np.sum(dpix * dpix, axis=1)\n    dnprev = dn.copy()\n    tol2 = tolerance ** 2\n    k = 1\n    ind = None\n    inddiv = None\n    old_invalid = np.geterr()['invalid']\n    old_over = np.geterr()['over']\n    np.seterr(invalid='ignore', over='ignore')\n    if not adaptive:\n        while np.nanmax(dn) >= tol2 and k < maxiter:\n            dpix = self.pix2foc(pix, origin) - pix0\n            dn = np.sum(dpix * dpix, axis=1)\n            if detect_divergence:\n                divergent = dn >= dnprev\n                if np.any(divergent):\n                    slowconv = dn >= tol2\n                    inddiv, = np.where(divergent & slowconv)\n                    if inddiv.shape[0] > 0:\n                        conv = dn < dnprev\n                        iconv = np.where(conv)\n                        dpixgood = dpix[iconv]\n                        pix[iconv] -= dpixgood\n                        dpix[iconv] = dpixgood\n                        ind, = np.where(slowconv & conv)\n                        pix0 = pix0[ind]\n                        dnprev[ind] = dn[ind]\n                        k += 1\n                        adaptive = True\n                        break\n                dnprev = dn\n            pix -= dpix\n            k += 1\n    if adaptive:\n        if ind is None:\n            ind, = np.where(np.isfinite(pix).all(axis=1))\n            pix0 = pix0[ind]\n        while ind.shape[0] > 0 and k < maxiter:\n            dpixnew = self.pix2foc(pix[ind], origin) - pix0\n            dnnew = np.sum(np.square(dpixnew), axis=1)\n            dnprev[ind] = dn[ind].copy()\n            dn[ind] = dnnew\n            if detect_divergence:\n                conv = dnnew < dnprev[ind]\n                iconv = np.where(conv)\n                iiconv = ind[iconv]\n                dpixgood = dpixnew[iconv]\n                pix[iiconv] -= dpixgood\n                dpix[iiconv] = dpixgood\n                subind, = np.where((dnnew >= tol2) & conv)\n            else:\n                pix[ind] -= dpixnew\n                dpix[ind] = dpixnew\n                subind, = np.where(dnnew >= tol2)\n            ind = ind[subind]\n            pix0 = pix0[subind]\n            k += 1\n    invalid = ~np.all(np.isfinite(pix), axis=1) & np.all(np.isfinite(world), axis=1)\n    inddiv, = np.where((dn >= tol2) & (dn >= dnprev) | invalid)\n    if inddiv.shape[0] == 0:\n        inddiv = None\n    if k >= maxiter:\n        ind, = np.where((dn >= tol2) & (dn < dnprev) & ~invalid)\n        if ind.shape[0] == 0:\n            ind = None\n    else:\n        ind = None\n    np.seterr(invalid=old_invalid, over=old_over)\n    if (ind is not None or inddiv is not None) and (not quiet):\n        if inddiv is None:\n            raise NoConvergence(\"'WCS.all_world2pix' failed to converge to the requested accuracy after {:d} iterations.\".format(k), best_solution=pix, accuracy=np.abs(dpix), niter=k, slow_conv=ind, divergent=None)\n        else:\n            raise NoConvergence(\"'WCS.all_world2pix' failed to converge to the requested accuracy.\\nAfter {:d} iterations, the solution is diverging at least for one input point.\".format(k), best_solution=pix, accuracy=np.abs(dpix), niter=k, slow_conv=ind, divergent=inddiv)\n    return pix",
    ".astropy.wcs.wcs.py@@WCS.wcs_world2pix": "def wcs_world2pix(self, *args, **kwargs):\n    if self.wcs is None:\n        raise ValueError('No basic WCS settings were created.')\n    return self._array_converter(lambda xy, o: self.wcs.s2p(xy, o)['pixcrd'], 'input', *args, **kwargs)",
    ".astropy.wcs.wcs.py@@WCS._return_single_array": "def _return_single_array(xy, origin):\n    if xy.shape[-1] != self.naxis:\n        raise ValueError('When providing two arguments, the array must be of shape (N, {})'.format(self.naxis))\n    if 0 in xy.shape:\n        return xy\n    if ra_dec_order and sky == 'input':\n        xy = self._denormalize_sky(xy)\n    result = func(xy, origin)\n    if ra_dec_order and sky == 'output':\n        result = self._normalize_sky(result)\n    return result",
    ".astropy.wcs.wcs.py@@WCS.has_distortion": "def has_distortion(self):\n    return self.sip is not None or self.cpdis1 is not None or self.cpdis2 is not None or (self.det2im1 is not None and self.det2im2 is not None)"
}