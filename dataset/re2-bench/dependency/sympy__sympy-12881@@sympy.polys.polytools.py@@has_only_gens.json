{
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    from sympy import Pow\n    if self is other:\n        return True\n    from .function import AppliedUndef, UndefinedFunction as UndefFunc\n    if isinstance(self, UndefFunc) and isinstance(other, UndefFunc):\n        if self.class_key() == other.class_key():\n            return True\n        else:\n            return False\n    if type(self) is not type(other):\n        if isinstance(self, Pow) and self.exp == 1:\n            return self.base == other\n        if isinstance(other, Pow) and other.exp == 1:\n            return self == other.base\n        try:\n            other = _sympify(other)\n        except SympifyError:\n            return False\n        if isinstance(self, AppliedUndef) and isinstance(other, AppliedUndef):\n            if self.class_key() != other.class_key():\n                return False\n        elif type(self) is not type(other):\n            return False\n    return self._hashable_content() == other._hashable_content()",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return dict(((key, value) for key, value in self._assumptions.items() if value is not None))",
    ".sympy.polys.polyclasses.py@@DMP.monoms": "def monoms(f, order=None):\n    return [m for m, _ in dmp_list_terms(f.rep, f.lev, f.dom, order=order)]",
    ".sympy.polys.densebasic.py@@dmp_list_terms": "def dmp_list_terms(f, u, K, order=None):\n\n    def sort(terms, O):\n        return sorted(terms, key=lambda term: O(term[0]), reverse=True)\n    terms = _rec_list_terms(f, u, ())\n    if not terms:\n        return [((0,) * (u + 1), K.zero)]\n    if order is None:\n        return terms\n    else:\n        return sort(terms, monomial_key(order))",
    ".sympy.polys.densebasic.py@@_rec_list_terms": "def _rec_list_terms(g, v, monom):\n    d, terms = (dmp_degree(g, v), [])\n    if not v:\n        for i, c in enumerate(g):\n            if not c:\n                continue\n            terms.append((monom + (d - i,), c))\n    else:\n        w = v - 1\n        for i, c in enumerate(g):\n            terms.extend(_rec_list_terms(c, w, monom + (d - i,)))\n    return terms",
    ".sympy.polys.densebasic.py@@dmp_degree": "def dmp_degree(f, u):\n    if dmp_zero_p(f, u):\n        return -oo\n    else:\n        return len(f) - 1",
    ".sympy.polys.densebasic.py@@dmp_zero_p": "def dmp_zero_p(f, u):\n    while u:\n        if len(f) != 1:\n            return False\n        f = f[0]\n        u -= 1\n    return not f",
    ".sympy.core.numbers.py@@Infinity.__neg__": "def __neg__(self):\n    return S.NegativeInfinity"
}