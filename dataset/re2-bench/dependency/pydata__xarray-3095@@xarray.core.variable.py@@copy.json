{
    ".xarray.core.variable.py@@as_compatible_data": "def as_compatible_data(data, fastpath=False):\n    if fastpath and getattr(data, 'ndim', 0) > 0:\n        return _maybe_wrap_data(data)\n    if isinstance(data, Variable):\n        return data.data\n    if isinstance(data, NON_NUMPY_SUPPORTED_ARRAY_TYPES):\n        return _maybe_wrap_data(data)\n    if isinstance(data, tuple):\n        data = utils.to_0d_object_array(data)\n    if isinstance(data, pd.Timestamp):\n        data = np.datetime64(data.value, 'ns')\n    if isinstance(data, timedelta):\n        data = np.timedelta64(getattr(data, 'value', data), 'ns')\n    data = getattr(data, 'values', data)\n    if isinstance(data, np.ma.MaskedArray):\n        mask = np.ma.getmaskarray(data)\n        if mask.any():\n            dtype, fill_value = dtypes.maybe_promote(data.dtype)\n            data = np.asarray(data, dtype=dtype)\n            data[mask] = fill_value\n        else:\n            data = np.asarray(data)\n    data = np.asarray(data)\n    if isinstance(data, np.ndarray):\n        if data.dtype.kind == 'O':\n            data = _possibly_convert_objects(data)\n        elif data.dtype.kind == 'M':\n            data = np.asarray(data, 'datetime64[ns]')\n        elif data.dtype.kind == 'm':\n            data = np.asarray(data, 'timedelta64[ns]')\n    return _maybe_wrap_data(data)",
    ".xarray.core.variable.py@@_maybe_wrap_data": "def _maybe_wrap_data(data):\n    if isinstance(data, pd.Index):\n        return PandasIndexAdapter(data)\n    return data",
    ".xarray.core.variable.py@@Variable.shape": "def shape(self):\n    return self._data.shape",
    ".xarray.core.indexing.py@@PandasIndexAdapter.shape": "def shape(self) -> Tuple[int]:\n    return (len(self.array),)",
    ".xarray.core.indexing.py@@PandasIndexAdapter.copy": "def copy(self, deep: bool=True) -> 'PandasIndexAdapter':\n    array = self.array.copy(deep=True) if deep else self.array\n    return PandasIndexAdapter(array, self._dtype)",
    ".xarray.core.indexing.py@@PandasIndexAdapter.__init__": "def __init__(self, array: Any, dtype: DTypeLike=None):\n    self.array = utils.safe_cast_to_index(array)\n    if dtype is None:\n        if isinstance(array, pd.PeriodIndex):\n            dtype = np.dtype('O')\n        elif hasattr(array, 'categories'):\n            dtype = array.categories.dtype\n        elif not utils.is_valid_numpy_dtype(array.dtype):\n            dtype = np.dtype('O')\n        else:\n            dtype = array.dtype\n    else:\n        dtype = np.dtype(dtype)\n    self._dtype = dtype",
    ".xarray.core.utils.py@@safe_cast_to_index": "def safe_cast_to_index(array: Any) -> pd.Index:\n    if isinstance(array, pd.Index):\n        index = array\n    elif hasattr(array, 'to_index'):\n        index = array.to_index()\n    else:\n        kwargs = {}\n        if hasattr(array, 'dtype') and array.dtype.kind == 'O':\n            kwargs['dtype'] = object\n        index = pd.Index(np.asarray(array), **kwargs)\n    return _maybe_cast_to_cftimeindex(index)",
    ".xarray.core.utils.py@@_maybe_cast_to_cftimeindex": "def _maybe_cast_to_cftimeindex(index: pd.Index) -> pd.Index:\n    from ..coding.cftimeindex import CFTimeIndex\n    if len(index) > 0 and index.dtype == 'O':\n        try:\n            return CFTimeIndex(index)\n        except (ImportError, TypeError):\n            return index\n    else:\n        return index",
    ".conftest.py@@pytest_runtest_setup": "def pytest_runtest_setup(item):\n    if 'flaky' in item.keywords and (not item.config.getoption('--run-flaky')):\n        pytest.skip('set --run-flaky option to run flaky tests')\n    if 'network' in item.keywords and (not item.config.getoption('--run-network-tests')):\n        pytest.skip('set --run-network-tests to run test requiring an internet connection')",
    ".xarray.core.variable.py@@Variable.__init__": "def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):\n    self._data = as_compatible_data(data, fastpath=fastpath)\n    self._dims = self._parse_dimensions(dims)\n    self._attrs = None\n    self._encoding = None\n    if attrs is not None:\n        self.attrs = attrs\n    if encoding is not None:\n        self.encoding = encoding",
    ".xarray.core.variable.py@@Variable._parse_dimensions": "def _parse_dimensions(self, dims):\n    if isinstance(dims, str):\n        dims = (dims,)\n    dims = tuple(dims)\n    if len(dims) != self.ndim:\n        raise ValueError('dimensions %s must have the same length as the number of data dimensions, ndim=%s' % (dims, self.ndim))\n    return dims",
    ".xarray.core.utils.py@@NdimSizeLenMixin.ndim": "def ndim(self: Any) -> int:\n    return len(self.shape)",
    ".xarray.core.variable.py@@Variable.attrs": "def attrs(self) -> 'OrderedDict[Any, Any]':\n    if self._attrs is None:\n        self._attrs = OrderedDict()\n    return self._attrs",
    ".xarray.core.variable.py@@Variable.real": "def real(self):\n    return type(self)(self.dims, self.data.real, self._attrs)",
    ".xarray.core.variable.py@@Variable.dims": "def dims(self):\n    return self._dims",
    ".xarray.core.variable.py@@Variable.data": "def data(self):\n    if isinstance(self._data, dask_array_type):\n        return self._data\n    else:\n        return self.values",
    ".xarray.core.variable.py@@Variable.values": "def values(self):\n    return _as_array_or_item(self._data)",
    ".xarray.core.variable.py@@_as_array_or_item": "def _as_array_or_item(data):\n    data = np.asarray(data)\n    if data.ndim == 0:\n        if data.dtype.kind == 'M':\n            data = np.datetime64(data, 'ns')\n        elif data.dtype.kind == 'm':\n            data = np.timedelta64(data, 'ns')\n    return data",
    ".xarray.testing.py@@assert_identical": "def assert_identical(a, b):\n    __tracebackhide__ = True\n    assert type(a) == type(b)\n    if isinstance(a, Variable):\n        assert a.identical(b), formatting.diff_array_repr(a, b, 'identical')\n    elif isinstance(a, DataArray):\n        assert a.name == b.name\n        assert a.identical(b), formatting.diff_array_repr(a, b, 'identical')\n    elif isinstance(a, (Dataset, Variable)):\n        assert a.identical(b), formatting.diff_dataset_repr(a, b, 'identical')\n    else:\n        raise TypeError('{} not supported by assertion comparison'.format(type(a)))",
    ".xarray.core.variable.py@@Variable.identical": "def identical(self, other):\n    try:\n        return utils.dict_equiv(self.attrs, other.attrs) and self.equals(other)\n    except (TypeError, AttributeError):\n        return False",
    ".xarray.core.utils.py@@dict_equiv": "def dict_equiv(first: Mapping[K, V], second: Mapping[K, V], compat: Callable[[V, V], bool]=equivalent) -> bool:\n    for k in first:\n        if k not in second or not compat(first[k], second[k]):\n            return False\n    for k in second:\n        if k not in first:\n            return False\n    return True",
    ".xarray.core.utils.py@@equivalent": "def equivalent(first: T, second: T) -> bool:\n    from . import duck_array_ops\n    if isinstance(first, np.ndarray) or isinstance(second, np.ndarray):\n        return duck_array_ops.array_equiv(first, second)\n    else:\n        return first is second or first == second or (pd.isnull(first) and pd.isnull(second))",
    ".xarray.core.variable.py@@Variable.equals": "def equals(self, other, equiv=duck_array_ops.array_equiv):\n    other = getattr(other, 'variable', other)\n    try:\n        return self.dims == other.dims and (self._data is other._data or equiv(self.data, other.data))\n    except (TypeError, AttributeError):\n        return False",
    ".xarray.core.duck_array_ops.py@@array_equiv": "def array_equiv(arr1, arr2):\n    arr1, arr2 = as_like_arrays(arr1, arr2)\n    if arr1.shape != arr2.shape:\n        return False\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', \"In the future, 'NAT == x'\")\n        flag_array = arr1 == arr2\n        flag_array |= isnull(arr1) & isnull(arr2)\n        return bool(flag_array.all())",
    ".xarray.core.duck_array_ops.py@@as_like_arrays": "def as_like_arrays(*data):\n    if all((isinstance(d, dask_array_type) for d in data)):\n        return data\n    else:\n        return tuple((np.asarray(d) for d in data))",
    ".xarray.core.duck_array_ops.py@@isnull": "def isnull(data):\n    try:\n        return _isnull(data)\n    except TypeError:\n        return np.zeros(data.shape, dtype=bool)",
    ".xarray.core.duck_array_ops.py@@f": "def f(values, axis=None, skipna=None, **kwargs):\n    if kwargs.pop('out', None) is not None:\n        raise TypeError('`out` is not valid for {}'.format(name))\n    values = asarray(values)\n    if coerce_strings and values.dtype.kind in 'SU':\n        values = values.astype(object)\n    func = None\n    if skipna or (skipna is None and values.dtype.kind in 'cfO'):\n        nanname = 'nan' + name\n        func = getattr(nanops, nanname)\n    else:\n        func = _dask_or_eager_func(name)\n    try:\n        return func(values, axis=axis, **kwargs)\n    except AttributeError:\n        if isinstance(values, dask_array_type):\n            try:\n                return func(values, axis=axis, dtype=values.dtype, **kwargs)\n            except (AttributeError, TypeError):\n                msg = '%s is not yet implemented on dask arrays' % name\n        else:\n            msg = '%s is not available with skipna=False with the installed version of numpy; upgrade to numpy 1.12 or newer to use skipna=True or skipna=None' % name\n        raise NotImplementedError(msg)",
    ".xarray.testing.py@@_assert_internal_invariants": "def _assert_internal_invariants(xarray_obj: Union[DataArray, Dataset, Variable]):\n    if isinstance(xarray_obj, Variable):\n        _assert_variable_invariants(xarray_obj)\n    elif isinstance(xarray_obj, DataArray):\n        _assert_dataarray_invariants(xarray_obj)\n    elif isinstance(xarray_obj, Dataset):\n        _assert_dataset_invariants(xarray_obj)\n    else:\n        raise TypeError('{} is not a supported type for xarray invariant checks'.format(type(xarray_obj)))",
    ".xarray.testing.py@@_assert_variable_invariants": "def _assert_variable_invariants(var: Variable, name: Hashable=None):\n    if name is None:\n        name_or_empty = ()\n    else:\n        name_or_empty = (name,)\n    assert isinstance(var._dims, tuple), name_or_empty + (var._dims,)\n    assert len(var._dims) == len(var._data.shape), name_or_empty + (var._dims, var._data.shape)\n    assert isinstance(var._encoding, (type(None), dict)), name_or_empty + (var._encoding,)\n    assert isinstance(var._attrs, (type(None), OrderedDict)), name_or_empty + (var._attrs,)",
    ".xarray.core.variable.py@@Variable.imag": "def imag(self):\n    return type(self)(self.dims, self.data.imag, self._attrs)",
    ".xarray.core.variable.py@@Variable.to_base_variable": "def to_base_variable(self):\n    return Variable(self.dims, self._data, self._attrs, encoding=self._encoding, fastpath=True)",
    ".xarray.core.variable.py@@Variable.func": "def func(self, other):\n    if isinstance(other, xr.Dataset):\n        raise TypeError('cannot add a Dataset to a Variable in-place')\n    self_data, other_data, dims = _broadcast_compat_data(self, other)\n    if dims != self.dims:\n        raise ValueError('dimensions cannot change for in-place operations')\n    with np.errstate(all='ignore'):\n        self.values = f(self_data, other_data)\n    return self",
    ".xarray.core.variable.py@@Variable.__array_wrap__": "def __array_wrap__(self, obj, context=None):\n    return Variable(self.dims, obj)",
    ".xarray.testing.py@@assert_allclose": "def assert_allclose(a, b, rtol=1e-05, atol=1e-08, decode_bytes=True):\n    __tracebackhide__ = True\n    assert type(a) == type(b)\n    kwargs = dict(rtol=rtol, atol=atol, decode_bytes=decode_bytes)\n    if isinstance(a, Variable):\n        assert a.dims == b.dims\n        allclose = _data_allclose_or_equiv(a.values, b.values, **kwargs)\n        assert allclose, '{}\\n{}'.format(a.values, b.values)\n    elif isinstance(a, DataArray):\n        assert_allclose(a.variable, b.variable, **kwargs)\n        assert set(a.coords) == set(b.coords)\n        for v in a.coords.variables:\n            allclose = _data_allclose_or_equiv(a.coords[v].values, b.coords[v].values, **kwargs)\n            assert allclose, '{}\\n{}'.format(a.coords[v].values, b.coords[v].values)\n    elif isinstance(a, Dataset):\n        assert set(a.data_vars) == set(b.data_vars)\n        assert set(a.coords) == set(b.coords)\n        for k in list(a.variables) + list(a.coords):\n            assert_allclose(a[k], b[k], **kwargs)\n    else:\n        raise TypeError('{} not supported by assertion comparison'.format(type(a)))",
    ".xarray.testing.py@@_data_allclose_or_equiv": "def _data_allclose_or_equiv(arr1, arr2, rtol=1e-05, atol=1e-08, decode_bytes=True):\n    if any((arr.dtype.kind == 'S' for arr in [arr1, arr2])) and decode_bytes:\n        arr1 = _decode_string_data(arr1)\n        arr2 = _decode_string_data(arr2)\n    exact_dtypes = ['M', 'm', 'O', 'S', 'U']\n    if any((arr.dtype.kind in exact_dtypes for arr in [arr1, arr2])):\n        return duck_array_ops.array_equiv(arr1, arr2)\n    else:\n        return duck_array_ops.allclose_or_equiv(arr1, arr2, rtol=rtol, atol=atol)",
    ".xarray.core.duck_array_ops.py@@allclose_or_equiv": "def allclose_or_equiv(arr1, arr2, rtol=1e-05, atol=1e-08):\n    arr1, arr2 = as_like_arrays(arr1, arr2)\n    if arr1.shape != arr2.shape:\n        return False\n    return bool(isclose(arr1, arr2, rtol=rtol, atol=atol, equal_nan=True).all())",
    ".xarray.core.common.py@@ImplementsArrayReduce.wrapped_func": "def wrapped_func(self, dim=None, axis=None, **kwargs):\n    return self.reduce(func, dim, axis, allow_lazy=True, **kwargs)",
    ".xarray.core.variable.py@@Variable.reduce": "def reduce(self, func, dim=None, axis=None, keep_attrs=None, keepdims=False, allow_lazy=False, **kwargs):\n    if dim is common.ALL_DIMS:\n        dim = None\n    if dim is not None and axis is not None:\n        raise ValueError(\"cannot supply both 'axis' and 'dim' arguments\")\n    if dim is not None:\n        axis = self.get_axis_num(dim)\n    input_data = self.data if allow_lazy else self.values\n    if axis is not None:\n        data = func(input_data, axis=axis, **kwargs)\n    else:\n        data = func(input_data, **kwargs)\n    if getattr(data, 'shape', ()) == self.shape:\n        dims = self.dims\n    else:\n        removed_axes = range(self.ndim) if axis is None else np.atleast_1d(axis) % self.ndim\n        if keepdims:\n            slices = tuple((np.newaxis if i in removed_axes else slice(None, None) for i in range(self.ndim)))\n            if getattr(data, 'shape', None) is None:\n                data = np.asanyarray(data)[slices]\n            else:\n                data = data[slices]\n            dims = self.dims\n        else:\n            dims = [adim for n, adim in enumerate(self.dims) if n not in removed_axes]\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=False)\n    attrs = self._attrs if keep_attrs else None\n    return Variable(dims, data, attrs=attrs)",
    ".xarray.core.duck_array_ops.py@@mean": "def mean(array, axis=None, skipna=None, **kwargs):\n    from .common import _contains_cftime_datetimes\n    array = asarray(array)\n    if array.dtype.kind in 'Mm':\n        offset = min(array)\n        dtype = 'timedelta64[ns]'\n        return _mean(datetime_to_numeric(array, offset), axis=axis, skipna=skipna, **kwargs).astype(dtype) + offset\n    elif _contains_cftime_datetimes(array):\n        if isinstance(array, dask_array_type):\n            raise NotImplementedError('Computing the mean of an array containing cftime.datetime objects is not yet implemented on dask arrays.')\n        offset = min(array)\n        timedeltas = datetime_to_numeric(array, offset, datetime_unit='us')\n        mean_timedeltas = _mean(timedeltas, axis=axis, skipna=skipna, **kwargs)\n        return _to_pytimedelta(mean_timedeltas, unit='us') + offset\n    else:\n        return _mean(array, axis=axis, skipna=skipna, **kwargs)",
    ".xarray.core.duck_array_ops.py@@asarray": "def asarray(data):\n    return data if isinstance(data, dask_array_type) else np.asarray(data)",
    ".xarray.core.common.py@@_contains_cftime_datetimes": "def _contains_cftime_datetimes(array) -> bool:\n    try:\n        from cftime import datetime as cftime_datetime\n    except ImportError:\n        return False\n    else:\n        if array.dtype == np.dtype('O') and array.size > 0:\n            sample = array.ravel()[0]\n            if isinstance(sample, dask_array_type):\n                sample = sample.compute()\n                if isinstance(sample, np.ndarray):\n                    sample = sample.item()\n            return isinstance(sample, cftime_datetime)\n        else:\n            return False",
    ".xarray.core.nanops.py@@nanmean": "def nanmean(a, axis=None, dtype=None, out=None):\n    if a.dtype.kind == 'O':\n        return _nanmean_ddof_object(0, a, axis=axis, dtype=dtype)\n    if isinstance(a, dask_array_type):\n        return dask_array.nanmean(a, axis=axis, dtype=dtype)\n    return np.nanmean(a, axis=axis, dtype=dtype)",
    ".xarray.core.options.py@@_get_keep_attrs": "def _get_keep_attrs(default):\n    global_choice = OPTIONS['keep_attrs']\n    if global_choice == 'default':\n        return default\n    elif global_choice in [True, False]:\n        return global_choice\n    else:\n        raise ValueError(\"The global option keep_attrs must be one of True, False or 'default'.\")",
    ".xarray.core.common.py@@AbstractArray.__repr__": "def __repr__(self) -> str:\n    return formatting.array_repr(self)",
    ".xarray.core.formatting.py@@array_repr": "def array_repr(arr):\n    if hasattr(arr, 'name') and arr.name is not None:\n        name_str = '{!r} '.format(arr.name)\n    else:\n        name_str = ''\n    summary = ['<xarray.{} {}({})>'.format(type(arr).__name__, name_str, dim_summary(arr))]\n    summary.append(short_data_repr(arr))\n    if hasattr(arr, 'coords'):\n        if arr.coords:\n            summary.append(repr(arr.coords))\n        unindexed_dims_str = unindexed_dims_repr(arr.dims, arr.coords)\n        if unindexed_dims_str:\n            summary.append(unindexed_dims_str)\n    if arr.attrs:\n        summary.append(attrs_repr(arr.attrs))\n    return '\\n'.join(summary)",
    ".xarray.core.formatting.py@@dim_summary": "def dim_summary(obj):\n    elements = ['{}: {}'.format(k, v) for k, v in obj.sizes.items()]\n    return ', '.join(elements)",
    ".xarray.core.common.py@@AbstractArray.sizes": "def sizes(self: Any) -> Mapping[Hashable, int]:\n    return Frozen(OrderedDict(zip(self.dims, self.shape)))",
    ".xarray.core.utils.py@@Frozen.__init__": "def __init__(self, mapping: Mapping[K, V]):\n    self.mapping = mapping",
    ".xarray.core.utils.py@@Frozen.__iter__": "def __iter__(self) -> Iterator[K]:\n    return iter(self.mapping)",
    ".xarray.core.utils.py@@Frozen.__getitem__": "def __getitem__(self, key: K) -> V:\n    return self.mapping[key]",
    ".xarray.core.formatting.py@@short_data_repr": "def short_data_repr(array):\n    if isinstance(getattr(array, 'variable', array)._data, dask_array_type):\n        return short_dask_repr(array)\n    elif array._in_memory or array.size < 100000.0:\n        return short_array_repr(array.values)\n    else:\n        return u'[{} values with dtype={}]'.format(array.size, array.dtype)",
    ".xarray.core.variable.py@@Variable._in_memory": "def _in_memory(self):\n    return isinstance(self._data, (np.ndarray, np.number, PandasIndexAdapter)) or (isinstance(self._data, indexing.MemoryCachedArray) and isinstance(self._data.array, indexing.NumpyIndexingAdapter))",
    ".xarray.core.formatting.py@@short_array_repr": "def short_array_repr(array):\n    array = np.asarray(array)\n    options = {'precision': 6, 'linewidth': OPTIONS['display_width'], 'threshold': 200}\n    if array.ndim < 3:\n        edgeitems = 3\n    elif array.ndim == 3:\n        edgeitems = 2\n    else:\n        edgeitems = 1\n    options['edgeitems'] = edgeitems\n    with set_numpy_options(**options):\n        return repr(array)",
    ".xarray.core.formatting.py@@set_numpy_options": "def set_numpy_options(*args, **kwargs):\n    original = np.get_printoptions()\n    np.set_printoptions(*args, **kwargs)\n    yield\n    np.set_printoptions(**original)",
    ".xarray.core.variable.py@@Variable.dtype": "def dtype(self):\n    return self._data.dtype",
    ".xarray.core.utils.py@@is_valid_numpy_dtype": "def is_valid_numpy_dtype(dtype: Any) -> bool:\n    try:\n        np.dtype(dtype)\n    except (TypeError, ValueError):\n        return False\n    else:\n        return True",
    ".xarray.core.indexing.py@@PandasIndexAdapter.__array__": "def __array__(self, dtype: DTypeLike=None) -> np.ndarray:\n    if dtype is None:\n        dtype = self.dtype\n    array = self.array\n    if isinstance(array, pd.PeriodIndex):\n        with suppress(AttributeError):\n            array = array.astype('object')\n    return np.asarray(array.values, dtype=dtype)",
    ".xarray.core.indexing.py@@PandasIndexAdapter.dtype": "def dtype(self) -> np.dtype:\n    return self._dtype",
    ".xarray.coding.cftimeindex.py@@CFTimeIndex.__new__": "def __new__(cls, data, name=None):\n    assert_all_valid_date_type(data)\n    if name is None and hasattr(data, 'name'):\n        name = data.name\n    result = object.__new__(cls)\n    result._data = np.array(data, dtype='O')\n    result.name = name\n    return result",
    ".xarray.coding.cftimeindex.py@@assert_all_valid_date_type": "def assert_all_valid_date_type(data):\n    import cftime\n    if len(data) > 0:\n        sample = data[0]\n        date_type = type(sample)\n        if not isinstance(sample, cftime.datetime):\n            raise TypeError('CFTimeIndex requires cftime.datetime objects. Got object of {}.'.format(date_type))\n        if not all((isinstance(value, date_type) for value in data)):\n            raise TypeError('CFTimeIndex requires using datetime objects of all the same type.  Got\\n{}.'.format(data))",
    ".xarray.core.utils.py@@to_0d_object_array": "def to_0d_object_array(value: Any) -> np.ndarray:\n    result = np.empty((), dtype=object)\n    result[()] = value\n    return result",
    ".xarray.core.variable.py@@_possibly_convert_objects": "def _possibly_convert_objects(values):\n    return np.asarray(pd.Series(values.ravel())).reshape(values.shape)",
    ".xarray.core.variable.py@@Variable.__getitem__": "def __getitem__(self, key):\n    dims, indexer, new_order = self._broadcast_indexes(key)\n    data = as_indexable(self._data)[indexer]\n    if new_order:\n        data = duck_array_ops.moveaxis(data, range(len(new_order)), new_order)\n    return self._finalize_indexing_result(dims, data)",
    ".xarray.core.variable.py@@Variable._broadcast_indexes": "def _broadcast_indexes(self, key):\n    key = self._item_key_to_tuple(key)\n    key = indexing.expanded_indexer(key, self.ndim)\n    key = tuple((k.data.item() if isinstance(k, Variable) and k.ndim == 0 else k for k in key))\n    key = tuple((k.item() if isinstance(k, np.ndarray) and k.ndim == 0 else k for k in key))\n    if all((isinstance(k, BASIC_INDEXING_TYPES) for k in key)):\n        return self._broadcast_indexes_basic(key)\n    self._validate_indexers(key)\n    if all((not isinstance(k, Variable) for k in key)):\n        return self._broadcast_indexes_outer(key)\n    dims = []\n    for k, d in zip(key, self.dims):\n        if isinstance(k, Variable):\n            if len(k.dims) > 1:\n                return self._broadcast_indexes_vectorized(key)\n            dims.append(k.dims[0])\n        elif not isinstance(k, integer_types):\n            dims.append(d)\n    if len(set(dims)) == len(dims):\n        return self._broadcast_indexes_outer(key)\n    return self._broadcast_indexes_vectorized(key)",
    ".xarray.core.variable.py@@Variable._item_key_to_tuple": "def _item_key_to_tuple(self, key):\n    if utils.is_dict_like(key):\n        return tuple((key.get(dim, slice(None)) for dim in self.dims))\n    else:\n        return key",
    ".xarray.core.utils.py@@is_dict_like": "def is_dict_like(value: Any) -> bool:\n    return hasattr(value, 'keys') and hasattr(value, '__getitem__')",
    ".xarray.core.indexing.py@@expanded_indexer": "def expanded_indexer(key, ndim):\n    if not isinstance(key, tuple):\n        key = (key,)\n    new_key = []\n    found_ellipsis = False\n    for k in key:\n        if k is Ellipsis:\n            if not found_ellipsis:\n                new_key.extend((ndim + 1 - len(key)) * [slice(None)])\n                found_ellipsis = True\n            else:\n                new_key.append(slice(None))\n        else:\n            new_key.append(k)\n    if len(new_key) > ndim:\n        raise IndexError('too many indices')\n    new_key.extend((ndim - len(new_key)) * [slice(None)])\n    return tuple(new_key)",
    ".xarray.core.variable.py@@Variable._broadcast_indexes_basic": "def _broadcast_indexes_basic(self, key):\n    dims = tuple((dim for k, dim in zip(key, self.dims) if not isinstance(k, integer_types)))\n    return (dims, BasicIndexer(key), None)",
    ".xarray.core.indexing.py@@BasicIndexer.__init__": "def __init__(self, key):\n    if not isinstance(key, tuple):\n        raise TypeError('key must be a tuple: {!r}'.format(key))\n    new_key = []\n    for k in key:\n        if isinstance(k, integer_types):\n            k = int(k)\n        elif isinstance(k, slice):\n            k = as_integer_slice(k)\n        else:\n            raise TypeError('unexpected indexer type for {}: {!r}'.format(type(self).__name__, k))\n        new_key.append(k)\n    super().__init__(new_key)",
    ".xarray.core.indexing.py@@ExplicitIndexer.__init__": "def __init__(self, key):\n    if type(self) is ExplicitIndexer:\n        raise TypeError('cannot instantiate base ExplicitIndexer objects')\n    self._key = tuple(key)",
    ".xarray.core.indexing.py@@as_indexable": "def as_indexable(array):\n    if isinstance(array, ExplicitlyIndexed):\n        return array\n    if isinstance(array, np.ndarray):\n        return NumpyIndexingAdapter(array)\n    if isinstance(array, pd.Index):\n        return PandasIndexAdapter(array)\n    if isinstance(array, dask_array_type):\n        return DaskIndexingAdapter(array)\n    raise TypeError('Invalid array type: {}'.format(type(array)))",
    ".xarray.core.indexing.py@@PandasIndexAdapter.__getitem__": "def __getitem__(self, indexer) -> Union[NumpyIndexingAdapter, np.ndarray, np.datetime64, np.timedelta64]:\n    key = indexer.tuple\n    if isinstance(key, tuple) and len(key) == 1:\n        key, = key\n    if getattr(key, 'ndim', 0) > 1:\n        return NumpyIndexingAdapter(self.array.values)[indexer]\n    result = self.array[key]\n    if isinstance(result, pd.Index):\n        result = PandasIndexAdapter(result, dtype=self.dtype)\n    else:\n        if result is pd.NaT:\n            result = np.datetime64('NaT', 'ns')\n        elif isinstance(result, timedelta):\n            result = np.timedelta64(getattr(result, 'value', result), 'ns')\n        elif isinstance(result, pd.Timestamp):\n            result = np.asarray(result.to_datetime64())\n        elif self.dtype != object:\n            result = np.asarray(result, dtype=self.dtype)\n        result = utils.to_0d_array(result)\n    return result",
    ".xarray.core.indexing.py@@ExplicitIndexer.tuple": "def tuple(self):\n    return self._key",
    ".xarray.core.utils.py@@to_0d_array": "def to_0d_array(value: Any) -> np.ndarray:\n    if np.isscalar(value) or (isinstance(value, np.ndarray) and value.ndim == 0):\n        return np.array(value)\n    else:\n        return to_0d_object_array(value)",
    ".xarray.core.variable.py@@Variable._finalize_indexing_result": "def _finalize_indexing_result(self, dims, data):\n    return type(self)(dims, data, self._attrs, self._encoding, fastpath=True)",
    ".xarray.core.indexing.py@@as_integer_slice": "def as_integer_slice(value):\n    start = as_integer_or_none(value.start)\n    stop = as_integer_or_none(value.stop)\n    step = as_integer_or_none(value.step)\n    return slice(start, stop, step)",
    ".xarray.core.indexing.py@@as_integer_or_none": "def as_integer_or_none(value):\n    return None if value is None else operator.index(value)",
    ".xarray.core.variable.py@@Variable.copy": "def copy(self, deep=True, data=None):\n    if data is None:\n        data = self._data\n        if isinstance(data, indexing.MemoryCachedArray):\n            data = indexing.MemoryCachedArray(data.array)\n        if deep:\n            if isinstance(data, dask_array_type):\n                data = data.copy()\n            elif not isinstance(data, PandasIndexAdapter):\n                data = np.array(data)\n    else:\n        data = as_compatible_data(data)\n        if self.shape != data.shape:\n            raise ValueError('Data shape {} must match shape of object {}'.format(data.shape, self.shape))\n    return type(self)(self.dims, data, self._attrs, self._encoding, fastpath=True)",
    ".xarray.core.variable.py@@Variable.chunk": "def chunk(self, chunks=None, name=None, lock=False):\n    import dask\n    import dask.array as da\n    if utils.is_dict_like(chunks):\n        chunks = dict(((self.get_axis_num(dim), chunk) for dim, chunk in chunks.items()))\n    if chunks is None:\n        chunks = self.chunks or self.shape\n    data = self._data\n    if isinstance(data, da.Array):\n        data = data.rechunk(chunks)\n    else:\n        if utils.is_dict_like(chunks):\n            chunks = tuple((chunks.get(n, s) for n, s in enumerate(self.shape)))\n        data = indexing.ImplicitToExplicitIndexingAdapter(data, indexing.OuterIndexer)\n        if LooseVersion(dask.__version__) > '1.2.2':\n            kwargs = dict(meta=np.ndarray)\n        else:\n            kwargs = dict()\n        data = da.from_array(data, chunks, name=name, lock=lock, **kwargs)\n    return type(self)(self.dims, data, self._attrs, self._encoding, fastpath=True)",
    ".xarray.core.variable.py@@Variable.chunks": "def chunks(self):\n    return getattr(self._data, 'chunks', None)",
    ".xarray.core.indexing.py@@ImplicitToExplicitIndexingAdapter.__init__": "def __init__(self, array, indexer_cls=BasicIndexer):\n    self.array = as_indexable(array)\n    self.indexer_cls = indexer_cls",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.__init__": "def __init__(self, array):\n    if not isinstance(array, np.ndarray):\n        raise TypeError('NumpyIndexingAdapter only wraps np.ndarray. Trying to wrap {}'.format(type(array)))\n    self.array = array",
    ".xarray.core.utils.py@@NDArrayMixin.shape": "def shape(self: Any) -> Tuple[int]:\n    return self.array.shape",
    ".xarray.core.utils.py@@NDArrayMixin.dtype": "def dtype(self: Any) -> np.dtype:\n    return self.array.dtype",
    ".xarray.core.indexing.py@@ImplicitToExplicitIndexingAdapter.__getitem__": "def __getitem__(self, key):\n    key = expanded_indexer(key, self.ndim)\n    result = self.array[self.indexer_cls(key)]\n    if isinstance(result, ExplicitlyIndexed):\n        return type(self)(result, self.indexer_cls)\n    else:\n        return result",
    ".xarray.core.indexing.py@@OuterIndexer.__init__": "def __init__(self, key):\n    if not isinstance(key, tuple):\n        raise TypeError('key must be a tuple: {!r}'.format(key))\n    new_key = []\n    for k in key:\n        if isinstance(k, integer_types):\n            k = int(k)\n        elif isinstance(k, slice):\n            k = as_integer_slice(k)\n        elif isinstance(k, np.ndarray):\n            if not np.issubdtype(k.dtype, np.integer):\n                raise TypeError('invalid indexer array, does not have integer dtype: {!r}'.format(k))\n            if k.ndim != 1:\n                raise TypeError('invalid indexer array for {}, must have exactly 1 dimension: '.format(type(self).__name__, k))\n            k = np.asarray(k, dtype=np.int64)\n        else:\n            raise TypeError('unexpected indexer type for {}: {!r}'.format(type(self).__name__, k))\n        new_key.append(k)\n    super().__init__(new_key)",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.__getitem__": "def __getitem__(self, key):\n    array, key = self._indexing_array_and_key(key)\n    return array[key]",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter._indexing_array_and_key": "def _indexing_array_and_key(self, key):\n    if isinstance(key, OuterIndexer):\n        array = self.array\n        key = _outer_to_numpy_indexer(key, self.array.shape)\n    elif isinstance(key, VectorizedIndexer):\n        array = nputils.NumpyVIndexAdapter(self.array)\n        key = key.tuple\n    elif isinstance(key, BasicIndexer):\n        array = self.array\n        key = key.tuple + (Ellipsis,)\n    else:\n        raise TypeError('unexpected key type: {}'.format(type(key)))\n    return (array, key)",
    ".xarray.core.indexing.py@@_outer_to_numpy_indexer": "def _outer_to_numpy_indexer(key, shape):\n    if len([k for k in key.tuple if not isinstance(k, slice)]) <= 1:\n        return key.tuple\n    else:\n        return _outer_to_vectorized_indexer(key, shape).tuple",
    ".xarray.core.formatting.py@@short_dask_repr": "def short_dask_repr(array, show_dtype=True):\n    chunksize = tuple((c[0] for c in array.chunks))\n    if show_dtype:\n        return 'dask.array<shape={}, dtype={}, chunksize={}>'.format(array.shape, array.dtype, chunksize)\n    else:\n        return 'dask.array<shape={}, chunksize={}>'.format(array.shape, chunksize)",
    ".xarray.core.indexing.py@@DaskIndexingAdapter.__init__": "def __init__(self, array):\n    self.array = array",
    ".xarray.core.indexing.py@@DaskIndexingAdapter.__getitem__": "def __getitem__(self, key):\n    if isinstance(key, BasicIndexer):\n        return self.array[key.tuple]\n    elif isinstance(key, VectorizedIndexer):\n        return self.array.vindex[key.tuple]\n    else:\n        assert isinstance(key, OuterIndexer)\n        key = key.tuple\n        try:\n            return self.array[key]\n        except NotImplementedError:\n            value = self.array\n            for axis, subkey in reversed(list(enumerate(key))):\n                value = value[(slice(None),) * axis + (subkey,)]\n            return value"
}