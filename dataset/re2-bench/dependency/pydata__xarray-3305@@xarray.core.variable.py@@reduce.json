{
    ".xarray.core.variable.py@@Variable.data": "def data(self):\n    if hasattr(self._data, '__array_function__') or isinstance(self._data, dask_array_type):\n        return self._data\n    else:\n        return self.values",
    ".xarray.core.duck_array_ops.py@@mean": "def mean(array, axis=None, skipna=None, **kwargs):\n    from .common import _contains_cftime_datetimes\n    array = asarray(array)\n    if array.dtype.kind in 'Mm':\n        offset = min(array)\n        dtype = 'timedelta64[ns]'\n        return _mean(datetime_to_numeric(array, offset), axis=axis, skipna=skipna, **kwargs).astype(dtype) + offset\n    elif _contains_cftime_datetimes(array):\n        if isinstance(array, dask_array_type):\n            raise NotImplementedError('Computing the mean of an array containing cftime.datetime objects is not yet implemented on dask arrays.')\n        offset = min(array)\n        timedeltas = datetime_to_numeric(array, offset, datetime_unit='us')\n        mean_timedeltas = _mean(timedeltas, axis=axis, skipna=skipna, **kwargs)\n        return _to_pytimedelta(mean_timedeltas, unit='us') + offset\n    else:\n        return _mean(array, axis=axis, skipna=skipna, **kwargs)",
    ".xarray.core.duck_array_ops.py@@asarray": "def asarray(data):\n    return data if isinstance(data, dask_array_type) or hasattr(data, '__array_function__') else np.asarray(data)",
    ".xarray.core.common.py@@_contains_cftime_datetimes": "def _contains_cftime_datetimes(array) -> bool:\n    try:\n        from cftime import datetime as cftime_datetime\n    except ImportError:\n        return False\n    else:\n        if array.dtype == np.dtype('O') and array.size > 0:\n            sample = array.ravel()[0]\n            if isinstance(sample, dask_array_type):\n                sample = sample.compute()\n                if isinstance(sample, np.ndarray):\n                    sample = sample.item()\n            return isinstance(sample, cftime_datetime)\n        else:\n            return False",
    ".xarray.core.duck_array_ops.py@@f": "def f(values, axis=None, skipna=None, **kwargs):\n    if kwargs.pop('out', None) is not None:\n        raise TypeError('`out` is not valid for {}'.format(name))\n    values = asarray(values)\n    if coerce_strings and values.dtype.kind in 'SU':\n        values = values.astype(object)\n    func = None\n    if skipna or (skipna is None and values.dtype.kind in 'cfO'):\n        nanname = 'nan' + name\n        func = getattr(nanops, nanname)\n    else:\n        func = _dask_or_eager_func(name)\n    try:\n        return func(values, axis=axis, **kwargs)\n    except AttributeError:\n        if isinstance(values, dask_array_type):\n            try:\n                return func(values, axis=axis, dtype=values.dtype, **kwargs)\n            except (AttributeError, TypeError):\n                msg = '%s is not yet implemented on dask arrays' % name\n        else:\n            msg = '%s is not available with skipna=False with the installed version of numpy; upgrade to numpy 1.12 or newer to use skipna=True or skipna=None' % name\n        raise NotImplementedError(msg)",
    ".xarray.core.duck_array_ops.py@@_dask_or_eager_func": "def _dask_or_eager_func(name, eager_module=np, dask_module=dask_array, list_of_args=False, array_args=slice(1), requires_dask=None):\n    if dask_module is not None:\n\n        def f(*args, **kwargs):\n            if list_of_args:\n                dispatch_args = args[0]\n            else:\n                dispatch_args = args[array_args]\n            if any((isinstance(a, dask_array.Array) for a in dispatch_args)):\n                try:\n                    wrapped = getattr(dask_module, name)\n                except AttributeError as e:\n                    raise AttributeError('%s: requires dask >=%s' % (e, requires_dask))\n            else:\n                wrapped = getattr(eager_module, name)\n            return wrapped(*args, **kwargs)\n    else:\n\n        def f(*args, **kwargs):\n            return getattr(eager_module, name)(*args, **kwargs)\n    return f",
    ".xarray.core.utils.py@@NdimSizeLenMixin.ndim": "def ndim(self: Any) -> int:\n    return len(self.shape)",
    ".xarray.core.variable.py@@Variable.dims": "def dims(self):\n    return self._dims",
    ".xarray.core.options.py@@_get_keep_attrs": "def _get_keep_attrs(default):\n    global_choice = OPTIONS['keep_attrs']\n    if global_choice == 'default':\n        return default\n    elif global_choice in [True, False]:\n        return global_choice\n    else:\n        raise ValueError(\"The global option keep_attrs must be one of True, False or 'default'.\")",
    ".xarray.core.common.py@@AbstractArray.get_axis_num": "def get_axis_num(self, dim: Union[Hashable, Iterable[Hashable]]) -> Union[int, Tuple[int, ...]]:\n    if isinstance(dim, Iterable) and (not isinstance(dim, str)):\n        return tuple((self._get_axis_num(d) for d in dim))\n    else:\n        return self._get_axis_num(dim)",
    ".xarray.core.common.py@@AbstractArray._get_axis_num": "def _get_axis_num(self: Any, dim: Hashable) -> int:\n    try:\n        return self.dims.index(dim)\n    except ValueError:\n        raise ValueError('%r not found in array dimensions %r' % (dim, self.dims))",
    ".xarray.core.duck_array_ops.py@@count": "def count(data, axis=None):\n    return np.sum(np.logical_not(isnull(data)), axis=axis)",
    ".xarray.core.duck_array_ops.py@@isnull": "def isnull(data):\n    data = asarray(data)\n    scalar_type = data.dtype.type\n    if issubclass(scalar_type, (np.datetime64, np.timedelta64)):\n        return isnat(data)\n    elif issubclass(scalar_type, np.inexact):\n        return isnan(data)\n    elif issubclass(scalar_type, (np.bool_, np.integer, np.character, np.void)):\n        return zeros_like(data, dtype=bool)\n    elif isinstance(data, (np.ndarray, dask_array_type)):\n        return pandas_isnull(data)\n    else:\n        return data != data",
    ".xarray.core.duck_array_ops.py@@cumsum": "def cumsum(array, axis=None, **kwargs):\n    return _nd_cum_func(cumsum_1d, array, axis, **kwargs)",
    ".xarray.core.duck_array_ops.py@@_nd_cum_func": "def _nd_cum_func(cum_func, array, axis, **kwargs):\n    array = asarray(array)\n    if axis is None:\n        axis = tuple(range(array.ndim))\n    if isinstance(axis, int):\n        axis = (axis,)\n    out = array\n    for ax in axis:\n        out = cum_func(out, axis=ax, **kwargs)\n    return out",
    ".xarray.core.duck_array_ops.py@@cumprod": "def cumprod(array, axis=None, **kwargs):\n    return _nd_cum_func(cumprod_1d, array, axis, **kwargs)",
    ".xarray.core.variable.py@@Variable.values": "def values(self):\n    return _as_array_or_item(self._data)",
    ".xarray.core.variable.py@@_as_array_or_item": "def _as_array_or_item(data):\n    data = np.asarray(data)\n    if data.ndim == 0:\n        if data.dtype.kind == 'M':\n            data = np.datetime64(data, 'ns')\n        elif data.dtype.kind == 'm':\n            data = np.timedelta64(data, 'ns')\n    return data",
    ".xarray.core.nanops.py@@nanmean": "def nanmean(a, axis=None, dtype=None, out=None):\n    if a.dtype.kind == 'O':\n        return _nanmean_ddof_object(0, a, axis=axis, dtype=dtype)\n    if isinstance(a, dask_array_type):\n        return dask_array.nanmean(a, axis=axis, dtype=dtype)\n    return np.nanmean(a, axis=axis, dtype=dtype)",
    ".xarray.core.nanops.py@@nansum": "def nansum(a, axis=None, dtype=None, out=None, min_count=None):\n    a, mask = _replace_nan(a, 0)\n    result = _dask_or_eager_func('sum')(a, axis=axis, dtype=dtype)\n    if min_count is not None:\n        return _maybe_null_out(result, axis, mask, min_count)\n    else:\n        return result",
    ".xarray.core.nanops.py@@_replace_nan": "def _replace_nan(a, val):\n    mask = isnull(a)\n    return (where_method(val, mask, a), mask)",
    ".xarray.core.duck_array_ops.py@@where_method": "def where_method(data, cond, other=dtypes.NA):\n    if other is dtypes.NA:\n        other = dtypes.get_fill_value(data.dtype)\n    return where(cond, data, other)",
    ".xarray.core.duck_array_ops.py@@where": "def where(condition, x, y):\n    return _where(condition, *as_shared_dtype([x, y]))",
    ".xarray.core.duck_array_ops.py@@as_shared_dtype": "def as_shared_dtype(scalars_or_arrays):\n    arrays = [asarray(x) for x in scalars_or_arrays]\n    out_type = dtypes.result_type(*arrays)\n    return [x.astype(out_type, copy=False) for x in arrays]",
    ".xarray.core.dtypes.py@@result_type": "def result_type(*arrays_and_dtypes):\n    types = {np.result_type(t).type for t in arrays_and_dtypes}\n    for left, right in PROMOTE_TO_OBJECT:\n        if any((issubclass(t, left) for t in types)) and any((issubclass(t, right) for t in types)):\n            return np.dtype(object)\n    return np.result_type(*arrays_and_dtypes)",
    ".xarray.core.indexing.py@@PandasIndexAdapter.__array__": "def __array__(self, dtype: DTypeLike=None) -> np.ndarray:\n    if dtype is None:\n        dtype = self.dtype\n    array = self.array\n    if isinstance(array, pd.PeriodIndex):\n        with suppress(AttributeError):\n            array = array.astype('object')\n    return np.asarray(array.values, dtype=dtype)",
    ".xarray.core.indexing.py@@PandasIndexAdapter.dtype": "def dtype(self) -> np.dtype:\n    return self._dtype",
    ".xarray.core.indexing.py@@PandasIndexAdapter.shape": "def shape(self) -> Tuple[int]:\n    return (len(self.array),)",
    ".xarray.core.duck_array_ops.py@@first": "def first(values, axis, skipna=None):\n    if (skipna or skipna is None) and values.dtype.kind not in 'iSU':\n        _fail_on_dask_array_input_skipna(values)\n        return nanfirst(values, axis)\n    return take(values, 0, axis=axis)",
    ".xarray.core.duck_array_ops.py@@last": "def last(values, axis, skipna=None):\n    if (skipna or skipna is None) and values.dtype.kind not in 'iSU':\n        _fail_on_dask_array_input_skipna(values)\n        return nanlast(values, axis)\n    return take(values, -1, axis=axis)",
    ".xarray.core.duck_array_ops.py@@fail_on_dask_array_input": "def fail_on_dask_array_input(values, msg=None, func_name=None):\n    if isinstance(values, dask_array_type):\n        if msg is None:\n            msg = '%r is not yet a valid method on dask arrays'\n        if func_name is None:\n            func_name = inspect.stack()[1][3]\n        raise NotImplementedError(msg % func_name)",
    ".xarray.core.nputils.py@@nanfirst": "def nanfirst(values, axis):\n    axis = _validate_axis(values, axis)\n    idx_first = np.argmax(~pd.isnull(values), axis=axis)\n    return _select_along_axis(values, idx_first, axis)",
    ".xarray.core.nputils.py@@_validate_axis": "def _validate_axis(data, axis):\n    ndim = data.ndim\n    if not -ndim <= axis < ndim:\n        raise IndexError('axis %r out of bounds [-%r, %r)' % (axis, ndim, ndim))\n    if axis < 0:\n        axis += ndim\n    return axis",
    ".xarray.core.nputils.py@@_select_along_axis": "def _select_along_axis(values, idx, axis):\n    other_ind = np.ix_(*[np.arange(s) for s in idx.shape])\n    sl = other_ind[:axis] + (idx,) + other_ind[axis:]\n    return values[sl]",
    ".xarray.core.nputils.py@@nanlast": "def nanlast(values, axis):\n    axis = _validate_axis(values, axis)\n    rev = (slice(None),) * axis + (slice(None, None, -1),)\n    idx_last = -1 - np.argmax(~pd.isnull(values)[rev], axis=axis)\n    return _select_along_axis(values, idx_last, axis)",
    ".xarray.core.dask_array_ops.py@@func": "def func(x, window, axis=-1):\n    x = np.asarray(x)\n    rolling = nputils._rolling_window(x, window, axis)\n    return rolling[(slice(None),) * axis + (slice(offset, None),)]",
    ".xarray.core.nputils.py@@_rolling_window": "def _rolling_window(a, window, axis=-1):\n    axis = _validate_axis(a, axis)\n    a = np.swapaxes(a, axis, -1)\n    if window < 1:\n        raise ValueError('`window` must be at least 1. Given : {}'.format(window))\n    if window > a.shape[-1]:\n        raise ValueError('`window` is too long. Given : {}'.format(window))\n    shape = a.shape[:-1] + (a.shape[-1] - window + 1, window)\n    strides = a.strides + (a.strides[-1],)\n    rolling = np.lib.stride_tricks.as_strided(a, shape=shape, strides=strides, writeable=False)\n    return np.swapaxes(rolling, -2, axis)"
}