{
    ".astropy.io.fits.hdu.hdulist.py@@fitsopen": "def fitsopen(name, mode='readonly', memmap=None, save_backup=False, cache=True, lazy_load_hdus=None, ignore_missing_simple=False, **kwargs):\n    from astropy.io.fits import conf\n    if memmap is None:\n        memmap = None if conf.use_memmap else False\n    else:\n        memmap = bool(memmap)\n    if lazy_load_hdus is None:\n        lazy_load_hdus = conf.lazy_load_hdus\n    else:\n        lazy_load_hdus = bool(lazy_load_hdus)\n    if 'uint' not in kwargs:\n        kwargs['uint'] = conf.enable_uint\n    if not name:\n        raise ValueError(f'Empty filename: {name!r}')\n    return HDUList.fromfile(name, mode, memmap, save_backup, cache, lazy_load_hdus, ignore_missing_simple, **kwargs)",
    ".astropy.config.configuration.py@@ConfigItem.__get__": "def __get__(self, obj, objtype=None):\n    if obj is None:\n        return self\n    return self()",
    ".astropy.config.configuration.py@@ConfigItem.__call__": "def __call__(self):\n\n    def section_name(section):\n        if section == '':\n            return 'at the top-level'\n        else:\n            return f'in section [{section}]'\n    options = []\n    sec = get_config(self.module, rootname=self.rootname)\n    if self.name in sec:\n        options.append((sec[self.name], self.module, self.name))\n    for alias in self.aliases:\n        module, name = alias.rsplit('.', 1)\n        sec = get_config(module, rootname=self.rootname)\n        if '.' in module:\n            filename, module = module.split('.', 1)\n        else:\n            filename = module\n            module = ''\n        if name in sec:\n            if '.' in self.module:\n                new_module = self.module.split('.', 1)[1]\n            else:\n                new_module = ''\n            warn(\"Config parameter '{}' {} of the file '{}' is deprecated. Use '{}' {} instead.\".format(name, section_name(module), get_config_filename(filename, rootname=self.rootname), self.name, section_name(new_module)), AstropyDeprecationWarning)\n            options.append((sec[name], module, name))\n    if len(options) == 0:\n        self.set(self.defaultvalue)\n        options.append((self.defaultvalue, None, None))\n    if len(options) > 1:\n        filename, sec = self.module.split('.', 1)\n        warn(\"Config parameter '{}' {} of the file '{}' is given by more than one alias ({}). Using the first.\".format(self.name, section_name(sec), get_config_filename(filename, rootname=self.rootname), ', '.join(['.'.join(x[1:3]) for x in options if x[1] is not None])), AstropyDeprecationWarning)\n    val = options[0][0]\n    try:\n        return self._validate_val(val)\n    except validate.ValidateError as e:\n        raise TypeError('Configuration value not valid:' + e.args[0])",
    ".astropy.config.configuration.py@@get_config": "def get_config(packageormod=None, reload=False, rootname=None):\n    if packageormod is None:\n        packageormod = find_current_module(2)\n        if packageormod is None:\n            msg1 = 'Cannot automatically determine get_config module, '\n            msg2 = 'because it is not called from inside a valid module'\n            raise RuntimeError(msg1 + msg2)\n        else:\n            packageormod = packageormod.__name__\n        _autopkg = True\n    else:\n        _autopkg = False\n    packageormodspl = packageormod.split('.')\n    pkgname = packageormodspl[0]\n    secname = '.'.join(packageormodspl[1:])\n    if rootname is None:\n        if _autopkg:\n            rootname = pkgname\n        else:\n            rootname = 'astropy'\n    cobj = _cfgobjs.get(pkgname, None)\n    if cobj is None or reload:\n        cfgfn = None\n        try:\n            if _override_config_file is not None:\n                cfgfn = _override_config_file\n            else:\n                cfgfn = path.join(get_config_dir(rootname=rootname), pkgname + '.cfg')\n            cobj = configobj.ConfigObj(cfgfn, interpolation=False)\n        except OSError:\n            cobj = configobj.ConfigObj(interpolation=False)\n        _cfgobjs[pkgname] = cobj\n    if secname:\n        if secname not in cobj:\n            cobj[secname] = {}\n        return cobj[secname]\n    else:\n        return cobj",
    ".astropy.extern.configobj.configobj.py@@Section.__getitem__": "def __getitem__(self, key):\n    val = dict.__getitem__(self, key)\n    if self.main.interpolation:\n        if isinstance(val, str):\n            return self._interpolate(key, val)\n        if isinstance(val, list):\n\n            def _check(entry):\n                if isinstance(entry, str):\n                    return self._interpolate(key, entry)\n                return entry\n            new = [_check(entry) for entry in val]\n            if new != val:\n                return new\n    return val",
    ".astropy.config.configuration.py@@ConfigItem.set": "def set(self, value):\n    try:\n        value = self._validate_val(value)\n    except validate.ValidateError as e:\n        msg = 'Provided value for configuration item {0} not valid: {1}'\n        raise TypeError(msg.format(self.name, e.args[0]))\n    sec = get_config(self.module, rootname=self.rootname)\n    sec[self.name] = value",
    ".astropy.config.configuration.py@@ConfigItem._validate_val": "def _validate_val(self, val):\n    return self._validator.check(self.cfgtype, val)",
    ".astropy.extern.configobj.validate.py@@Validator.check": "def check(self, check, value, missing=False):\n    fun_name, fun_args, fun_kwargs, default = self._parse_with_caching(check)\n    if missing:\n        if default is None:\n            raise VdtMissingValue()\n        value = self._handle_none(default)\n    if value is None:\n        return None\n    return self._check_value(value, fun_name, fun_args, fun_kwargs)",
    ".astropy.extern.configobj.validate.py@@Validator._parse_with_caching": "def _parse_with_caching(self, check):\n    if check in self._cache:\n        fun_name, fun_args, fun_kwargs, default = self._cache[check]\n        fun_args = list(fun_args)\n        fun_kwargs = dict(fun_kwargs)\n    else:\n        fun_name, fun_args, fun_kwargs, default = self._parse_check(check)\n        fun_kwargs = dict([(str(key), value) for key, value in list(fun_kwargs.items())])\n        self._cache[check] = (fun_name, list(fun_args), dict(fun_kwargs), default)\n    return (fun_name, fun_args, fun_kwargs, default)",
    ".astropy.extern.configobj.validate.py@@Validator._check_value": "def _check_value(self, value, fun_name, fun_args, fun_kwargs):\n    try:\n        fun = self.functions[fun_name]\n    except KeyError:\n        raise VdtUnknownCheckError(fun_name)\n    else:\n        return fun(value, *fun_args, **fun_kwargs)",
    ".astropy.extern.configobj.validate.py@@is_boolean": "def is_boolean(value):\n    if isinstance(value, string_type):\n        try:\n            return bool_dict[value.lower()]\n        except KeyError:\n            raise VdtTypeError(value)\n    if value == False:\n        return False\n    elif value == True:\n        return True\n    else:\n        raise VdtTypeError(value)",
    ".astropy.extern.configobj.configobj.py@@Section.__setitem__": "def __setitem__(self, key, value, unrepr=False):\n    if not isinstance(key, str):\n        raise ValueError('The key \"%s\" is not a string.' % key)\n    if key not in self.comments:\n        self.comments[key] = []\n        self.inline_comments[key] = ''\n    if key in self.defaults:\n        self.defaults.remove(key)\n    if isinstance(value, Section):\n        if key not in self:\n            self.sections.append(key)\n        dict.__setitem__(self, key, value)\n    elif isinstance(value, Mapping) and (not unrepr):\n        if key not in self:\n            self.sections.append(key)\n        new_depth = self.depth + 1\n        dict.__setitem__(self, key, Section(self, new_depth, self.main, indict=value, name=key))\n    else:\n        if key not in self:\n            self.scalars.append(key)\n        if not self.main.stringify:\n            if isinstance(value, str):\n                pass\n            elif isinstance(value, (list, tuple)):\n                for entry in value:\n                    if not isinstance(entry, str):\n                        raise TypeError('Value is not a string \"%s\".' % entry)\n            else:\n                raise TypeError('Value is not a string \"%s\".' % value)\n        dict.__setitem__(self, key, value)",
    ".astropy.io.fits.hdu.hdulist.py@@HDUList.fromfile": "def fromfile(cls, fileobj, mode=None, memmap=None, save_backup=False, cache=True, lazy_load_hdus=True, ignore_missing_simple=False, **kwargs):\n    return cls._readfrom(fileobj=fileobj, mode=mode, memmap=memmap, save_backup=save_backup, cache=cache, ignore_missing_simple=ignore_missing_simple, lazy_load_hdus=lazy_load_hdus, **kwargs)",
    ".astropy.io.fits.hdu.hdulist.py@@HDUList._readfrom": "def _readfrom(cls, fileobj=None, data=None, mode=None, memmap=None, cache=True, lazy_load_hdus=True, ignore_missing_simple=False, **kwargs):\n    if fileobj is not None:\n        if not isinstance(fileobj, _File):\n            fileobj = _File(fileobj, mode=mode, memmap=memmap, cache=cache)\n        mode = fileobj.mode\n        hdulist = cls(file=fileobj)\n    else:\n        if mode is None:\n            mode = 'readonly'\n        hdulist = cls(file=data)\n    if not ignore_missing_simple and hdulist._file and (hdulist._file.mode != 'ostream') and (hdulist._file.size > 0):\n        pos = hdulist._file.tell()\n        simple = hdulist._file.read(80)\n        match_sig = simple[:29] == FITS_SIGNATURE[:-1] and simple[29:30] in (b'T', b'F')\n        if not match_sig:\n            match_sig_relaxed = re.match(b'SIMPLE\\\\s*=\\\\s*[T|F]', simple)\n            if match_sig_relaxed:\n                warnings.warn(\"Found a SIMPLE card but its format doesn't respect the FITS Standard\", VerifyWarning)\n            else:\n                if hdulist._file.close_on_error:\n                    hdulist._file.close()\n                raise OSError('No SIMPLE card found, this file does not appear to be a valid FITS file. If this is really a FITS file, try with ignore_missing_simple=True')\n        hdulist._file.seek(pos)\n    hdulist._open_kwargs = kwargs\n    if fileobj is not None and fileobj.writeonly:\n        return hdulist\n    read_one = hdulist._read_next_hdu()\n    if not read_one and mode in ('readonly', 'denywrite'):\n        if hdulist._file.close_on_error:\n            hdulist._file.close()\n        raise OSError('Empty or corrupt FITS file')\n    if not lazy_load_hdus or kwargs.get('checksum') is True:\n        while hdulist._read_next_hdu():\n            pass\n    hdulist._resize = False\n    hdulist._truncate = False\n    return hdulist",
    ".astropy.io.fits.file.py@@_File.__init__": "def __init__(self, fileobj=None, mode=None, memmap=None, overwrite=False, cache=True):\n    self.strict_memmap = bool(memmap)\n    memmap = True if memmap is None else memmap\n    self._file = None\n    self.closed = False\n    self.binary = True\n    self.mode = mode\n    self.memmap = memmap\n    self.compression = None\n    self.readonly = False\n    self.writeonly = False\n    self.close_on_error = False\n    self._mmap = None\n    if fileobj is None:\n        self.simulateonly = True\n        return\n    else:\n        self.simulateonly = False\n        if isinstance(fileobj, os.PathLike):\n            fileobj = os.fspath(fileobj)\n    if mode is not None and mode not in IO_FITS_MODES:\n        raise ValueError(f\"Mode '{mode}' not recognized\")\n    if isfile(fileobj):\n        objmode = _normalize_fits_mode(fileobj_mode(fileobj))\n        if mode is not None and mode != objmode:\n            raise ValueError(\"Requested FITS mode '{}' not compatible with open file handle mode '{}'\".format(mode, objmode))\n        mode = objmode\n    if mode is None:\n        mode = 'readonly'\n    if isinstance(fileobj, (str, bytes)) and mode not in ('ostream', 'append', 'update') and _is_url(fileobj):\n        self.name = download_file(fileobj, cache=cache)\n    elif isinstance(fileobj, http.client.HTTPResponse):\n        if mode in ('ostream', 'append', 'update'):\n            raise ValueError(f'Mode {mode} not supported for HTTPResponse')\n        fileobj = io.BytesIO(fileobj.read())\n    else:\n        self.name = fileobj_name(fileobj)\n    self.mode = mode\n    self.file_like = False\n    if isfile(fileobj):\n        self._open_fileobj(fileobj, mode, overwrite)\n    elif isinstance(fileobj, (str, bytes)):\n        self._open_filename(fileobj, mode, overwrite)\n    else:\n        self._open_filelike(fileobj, mode, overwrite)\n    self.fileobj_mode = fileobj_mode(self._file)\n    if isinstance(fileobj, gzip.GzipFile):\n        self.compression = 'gzip'\n    elif isinstance(fileobj, zipfile.ZipFile):\n        self.compression = 'zip'\n    elif _is_bz2file(fileobj):\n        self.compression = 'bzip2'\n    if mode in ('readonly', 'copyonwrite', 'denywrite') or (self.compression and mode == 'update'):\n        self.readonly = True\n    elif mode == 'ostream' or (self.compression and mode == 'append'):\n        self.writeonly = True\n    if mode == 'ostream' or self.compression or (not hasattr(self._file, 'seek')):\n        self.size = 0\n    else:\n        pos = self._file.tell()\n        self._file.seek(0, 2)\n        self.size = self._file.tell()\n        self._file.seek(pos)\n    if self.memmap:\n        if not isfile(self._file):\n            self.memmap = False\n        elif not self.readonly and (not self._mmap_available):\n            self.memmap = False",
    ".astropy.io.fits.util.py@@isfile": "def isfile(f):\n    if isinstance(f, io.FileIO):\n        return True\n    elif hasattr(f, 'buffer'):\n        return isfile(f.buffer)\n    elif hasattr(f, 'raw'):\n        return isfile(f.raw)\n    return False",
    ".astropy.io.fits.util.py@@fileobj_mode": "def fileobj_mode(f):\n    if hasattr(f, 'fileobj') and hasattr(f.fileobj, 'mode'):\n        fileobj = f.fileobj\n    elif hasattr(f, 'fileobj_mode'):\n        return f.fileobj_mode\n    elif hasattr(f, 'fp') and hasattr(f.fp, 'mode'):\n        fileobj = f.fp\n    elif hasattr(f, 'mode'):\n        fileobj = f\n    else:\n        return None\n    return _fileobj_normalize_mode(fileobj)",
    ".astropy.io.fits.util.py@@_fileobj_normalize_mode": "def _fileobj_normalize_mode(f):\n    mode = f.mode\n    if isinstance(f, gzip.GzipFile):\n        if mode == gzip.READ:\n            return 'rb'\n        elif mode == gzip.WRITE:\n            return 'wb'\n        else:\n            return None\n    if '+' in mode:\n        mode = mode.replace('+', '')\n        mode += '+'\n    return mode",
    ".astropy.io.fits.file.py@@_normalize_fits_mode": "def _normalize_fits_mode(mode):\n    if mode is not None and mode not in IO_FITS_MODES:\n        if TEXT_RE.match(mode):\n            raise ValueError(\"Text mode '{}' not supported: files must be opened in binary mode\".format(mode))\n        new_mode = FILE_MODES.get(mode)\n        if new_mode not in IO_FITS_MODES:\n            raise ValueError(f\"Mode '{mode}' not recognized\")\n        mode = new_mode\n    return mode",
    ".astropy.io.fits.util.py@@fileobj_name": "def fileobj_name(f):\n    if isinstance(f, (str, bytes)):\n        return f\n    elif isinstance(f, gzip.GzipFile):\n        return fileobj_name(f.fileobj)\n    elif hasattr(f, 'name'):\n        return f.name\n    elif hasattr(f, 'filename'):\n        return f.filename\n    elif hasattr(f, '__class__'):\n        return str(f.__class__)\n    else:\n        return str(type(f))",
    ".astropy.io.fits.file.py@@_File._open_fileobj": "def _open_fileobj(self, fileobj, mode, overwrite):\n    closed = fileobj_closed(fileobj)\n    if mode == 'ostream':\n        self._overwrite_existing(overwrite, fileobj, closed)\n    if not closed:\n        self._file = fileobj\n    elif isfile(fileobj):\n        self._file = open(self.name, IO_FITS_MODES[mode])\n    try:\n        if mode in ['ostream', 'append']:\n            self._file.seek(0)\n        magic = self._file.read(4)\n        self._file.seek(0)\n    except OSError:\n        return\n    self._try_read_compressed(fileobj, magic, mode)",
    ".astropy.io.fits.util.py@@fileobj_closed": "def fileobj_closed(f):\n    if isinstance(f, path_like):\n        return True\n    if hasattr(f, 'closed'):\n        return f.closed\n    elif hasattr(f, 'fileobj') and hasattr(f.fileobj, 'closed'):\n        return f.fileobj.closed\n    elif hasattr(f, 'fp') and hasattr(f.fp, 'closed'):\n        return f.fp.closed\n    else:\n        return False",
    ".astropy.io.fits.file.py@@_File._try_read_compressed": "def _try_read_compressed(self, obj_or_name, magic, mode, ext=''):\n    is_ostream = mode == 'ostream'\n    if is_ostream and ext == '.gz' or magic.startswith(GZIP_MAGIC):\n        if mode == 'append':\n            raise OSError(\"'append' mode is not supported with gzip files.Use 'update' mode instead\")\n        kwargs = dict(mode=IO_FITS_MODES[mode])\n        if isinstance(obj_or_name, str):\n            kwargs['filename'] = obj_or_name\n        else:\n            kwargs['fileobj'] = obj_or_name\n        self._file = gzip.GzipFile(**kwargs)\n        self.compression = 'gzip'\n    elif is_ostream and ext == '.zip' or magic.startswith(PKZIP_MAGIC):\n        self._open_zipfile(self.name, mode)\n        self.compression = 'zip'\n    elif is_ostream and ext == '.bz2' or magic.startswith(BZIP2_MAGIC):\n        if mode in ['update', 'append']:\n            raise OSError('update and append modes are not supported with bzip2 files')\n        if not HAS_BZ2:\n            raise ModuleNotFoundError('This Python installation does not provide the bz2 module.')\n        bzip2_mode = 'w' if is_ostream else 'r'\n        self._file = bz2.BZ2File(obj_or_name, mode=bzip2_mode)\n        self.compression = 'bzip2'\n    return self.compression is not None",
    ".astropy.io.fits.file.py@@_is_bz2file": "def _is_bz2file(fileobj):\n    if HAS_BZ2:\n        return isinstance(fileobj, bz2.BZ2File)\n    else:\n        return False",
    ".astropy.io.fits.hdu.hdulist.py@@HDUList.__init__": "def __init__(self, hdus=[], file=None):\n    if isinstance(file, bytes):\n        self._data = file\n        self._file = None\n    else:\n        self._file = file\n        self._data = None\n    self._open_kwargs = {}\n    self._in_read_next_hdu = False\n    if file is None:\n        self._read_all = True\n    elif self._file is not None:\n        self._read_all = self._file.mode == 'ostream'\n    else:\n        self._read_all = False\n    if hdus is None:\n        hdus = []\n    if isinstance(hdus, _ValidHDU):\n        hdus = [hdus]\n    elif not isinstance(hdus, (HDUList, list)):\n        raise TypeError('Invalid input for HDUList.')\n    for idx, hdu in enumerate(hdus):\n        if not isinstance(hdu, _BaseHDU):\n            raise TypeError(f'Element {idx} in the HDUList input is not an HDU.')\n    super().__init__(hdus)\n    if file is None:\n        self.update_extend()",
    ".astropy.io.fits.file.py@@_File.tell": "def tell(self):\n    if self.simulateonly:\n        raise OSError\n    if not hasattr(self._file, 'tell'):\n        raise EOFError\n    return self._file.tell()",
    ".astropy.io.fits.file.py@@_File.read": "def read(self, size=None):\n    if not hasattr(self._file, 'read'):\n        raise EOFError\n    try:\n        return self._file.read(size)\n    except OSError:\n        if self.compression == 'gzip':\n            return ''\n        raise",
    ".astropy.io.fits.file.py@@_File.seek": "def seek(self, offset, whence=0):\n    if not hasattr(self._file, 'seek'):\n        return\n    self._file.seek(offset, whence)\n    pos = self._file.tell()\n    if self.size and pos > self.size:\n        warnings.warn('File may have been truncated: actual file length ({}) is smaller than the expected size ({})'.format(self.size, pos), AstropyUserWarning)",
    ".astropy.io.fits.hdu.hdulist.py@@HDUList._read_next_hdu": "def _read_next_hdu(self):\n    if self._read_all:\n        return False\n    saved_compression_enabled = compressed.COMPRESSION_ENABLED\n    fileobj, data, kwargs = (self._file, self._data, self._open_kwargs)\n    if fileobj is not None and fileobj.closed:\n        return False\n    try:\n        self._in_read_next_hdu = True\n        if 'disable_image_compression' in kwargs and kwargs['disable_image_compression']:\n            compressed.COMPRESSION_ENABLED = False\n        try:\n            if fileobj is not None:\n                try:\n                    if len(self) > 0:\n                        last = self[len(self) - 1]\n                        if last._data_offset is not None:\n                            offset = last._data_offset + last._data_size\n                            fileobj.seek(offset, os.SEEK_SET)\n                    hdu = _BaseHDU.readfrom(fileobj, **kwargs)\n                except EOFError:\n                    self._read_all = True\n                    return False\n                except OSError:\n                    if self._file.close_on_error:\n                        self._file.close()\n                    if fileobj.writeonly:\n                        self._read_all = True\n                        return False\n                    else:\n                        raise\n            else:\n                if not data:\n                    self._read_all = True\n                    return False\n                hdu = _BaseHDU.fromstring(data, **kwargs)\n                self._data = data[hdu._data_offset + hdu._data_size:]\n            super().append(hdu)\n            if len(self) == 1:\n                self.update_extend()\n            hdu._new = False\n            if 'checksum' in kwargs:\n                hdu._output_checksum = kwargs['checksum']\n        except (VerifyError, ValueError) as exc:\n            warnings.warn('Error validating header for HDU #{} (note: Astropy uses zero-based indexing).\\n{}\\nThere may be extra bytes after the last HDU or the file is corrupted.'.format(len(self), indent(str(exc))), VerifyWarning)\n            del exc\n            self._read_all = True\n            return False\n    finally:\n        compressed.COMPRESSION_ENABLED = saved_compression_enabled\n        self._in_read_next_hdu = False\n    return True",
    ".astropy.io.fits.hdu.hdulist.py@@HDUList.__len__": "def __len__(self):\n    if not self._in_read_next_hdu:\n        self.readall()\n    return super().__len__()",
    ".astropy.io.fits.hdu.base.py@@_BaseHDU.readfrom": "def readfrom(cls, fileobj, checksum=False, ignore_missing_end=False, **kwargs):\n    if not isinstance(fileobj, _File):\n        fileobj = _File(fileobj)\n    hdu = cls._readfrom_internal(fileobj, checksum=checksum, ignore_missing_end=ignore_missing_end, **kwargs)\n    fileobj.seek(hdu._data_offset + hdu._data_size, os.SEEK_SET)\n    return hdu",
    ".astropy.io.fits.hdu.base.py@@_BaseHDU._readfrom_internal": "def _readfrom_internal(cls, data, header=None, checksum=False, ignore_missing_end=False, **kwargs):\n    hdu_buffer = None\n    hdu_fileobj = None\n    header_offset = 0\n    if isinstance(data, _File):\n        if header is None:\n            header_offset = data.tell()\n            try:\n                header_str, header = _BasicHeader.fromfile(data)\n            except Exception:\n                data.seek(header_offset)\n                header = Header.fromfile(data, endcard=not ignore_missing_end)\n        hdu_fileobj = data\n        data_offset = data.tell()\n    else:\n        try:\n            np.ndarray((), dtype='ubyte', buffer=data)\n        except TypeError:\n            raise TypeError('The provided object {!r} does not contain an underlying memory buffer.  fromstring() requires an object that supports the buffer interface such as bytes, buffer, memoryview, ndarray, etc.  This restriction is to ensure that efficient access to the array/table data is possible.'.format(data))\n        if header is None:\n\n            def block_iter(nbytes):\n                idx = 0\n                while idx < len(data):\n                    yield data[idx:idx + nbytes]\n                    idx += nbytes\n            header_str, header = Header._from_blocks(block_iter, True, '', not ignore_missing_end, True)\n            if len(data) > len(header_str):\n                hdu_buffer = data\n        elif data:\n            hdu_buffer = data\n        header_offset = 0\n        data_offset = len(header_str)\n    cls = _hdu_class_from_header(cls, header)\n    sig = signature(cls.__init__)\n    new_kwargs = kwargs.copy()\n    if Parameter.VAR_KEYWORD not in (x.kind for x in sig.parameters.values()):\n        for key in kwargs:\n            if key not in sig.parameters:\n                del new_kwargs[key]\n    try:\n        hdu = cls(data=DELAYED, header=header, **new_kwargs)\n    except TypeError:\n        if isinstance(header, _BasicHeader):\n            header = Header.fromstring(header_str)\n            hdu = cls(data=DELAYED, header=header, **new_kwargs)\n        else:\n            raise\n    hdu._file = hdu_fileobj\n    hdu._buffer = hdu_buffer\n    hdu._header_offset = header_offset\n    hdu._data_offset = data_offset\n    size = hdu.size\n    hdu._data_size = size + _pad_length(size)\n    if isinstance(hdu._header, _BasicHeader):\n        del hdu._header\n        hdu._header_str = header_str\n    if checksum and checksum != 'remove' and isinstance(hdu, _ValidHDU):\n        hdu._verify_checksum_datasum()\n    return hdu",
    ".astropy.io.fits.header.py@@_BasicHeader.fromfile": "def fromfile(cls, fileobj):\n    close_file = False\n    if isinstance(fileobj, str):\n        fileobj = open(fileobj, 'rb')\n        close_file = True\n    try:\n        header_str, cards = parse_header(fileobj)\n        _check_padding(header_str, BLOCK_SIZE, False)\n        return (header_str, cls(cards))\n    finally:\n        if close_file:\n            fileobj.close()",
    ".astropy.io.fits.header.py@@_check_padding": "def _check_padding(header_str, block_size, is_eof, check_block_size=True):\n    if header_str and header_str[-1] == '\\x00':\n        if is_eof and header_str.strip('\\x00') == '':\n            warnings.warn('Unexpected extra padding at the end of the file.  This padding may not be preserved when saving changes.', AstropyUserWarning)\n            raise EOFError()\n        else:\n            warnings.warn('Header block contains null bytes instead of spaces for padding, and is not FITS-compliant. Nulls may be replaced with spaces upon writing.', AstropyUserWarning)\n            header_str.replace('\\x00', ' ')\n    if check_block_size and len(header_str) % block_size != 0:\n        actual_len = len(header_str) - block_size + BLOCK_SIZE\n        raise ValueError(f'Header size is not multiple of {BLOCK_SIZE}: {actual_len}')",
    ".astropy.io.fits.header.py@@_BasicHeader.__init__": "def __init__(self, cards):\n    self._raw_cards = cards\n    self._keys = list(cards.keys())\n    self._cards = {}\n    self.cards = _BasicHeaderCards(self)\n    self._modified = False",
    ".astropy.io.fits.header.py@@_BasicHeaderCards.__init__": "def __init__(self, header):\n    self.header = header",
    ".astropy.io.fits.hdu.base.py@@_hdu_class_from_header": "def _hdu_class_from_header(cls, header):\n    klass = cls\n    if header:\n        for c in reversed(list(itersubclasses(cls))):\n            try:\n                if not (c.__module__.startswith('astropy.io.fits.') or c in cls._hdu_registry):\n                    continue\n                if c.match_header(header):\n                    klass = c\n                    break\n            except NotImplementedError:\n                continue\n            except Exception as exc:\n                warnings.warn('An exception occurred matching an HDU header to the appropriate HDU type: {}'.format(exc), AstropyUserWarning)\n                warnings.warn('The HDU will be treated as corrupted.', AstropyUserWarning)\n                klass = _CorruptedHDU\n                del exc\n                break\n    return klass",
    ".astropy.io.fits.header.py@@_BasicHeader.__len__": "def __len__(self):\n    return len(self._raw_cards)",
    ".astropy.io.fits.util.py@@itersubclasses": "def itersubclasses(cls, _seen=None):\n    if _seen is None:\n        _seen = set()\n    try:\n        subs = cls.__subclasses__()\n    except TypeError:\n        subs = cls.__subclasses__(cls)\n    for sub in sorted(subs, key=operator.attrgetter('__name__')):\n        if sub not in _seen:\n            _seen.add(sub)\n            yield sub\n            for sub in itersubclasses(sub, _seen):\n                yield sub",
    ".astropy.io.fits.hdu.table.py@@_TableLikeHDU.match_header": "def match_header(cls, header):\n    raise NotImplementedError",
    ".astropy.io.fits.hdu.groups.py@@GroupsHDU.match_header": "def match_header(cls, header):\n    keyword = header.cards[0].keyword\n    return keyword == 'SIMPLE' and 'GROUPS' in header and (header['GROUPS'] is True)",
    ".astropy.io.fits.header.py@@_BasicHeaderCards.__getitem__": "def __getitem__(self, key):\n    key = self.header._keys[key]\n    try:\n        return self.header._cards[key]\n    except KeyError:\n        cardstr = self.header._raw_cards[key]\n        card = Card.fromstring(cardstr)\n        self.header._cards[key] = card\n        return card",
    ".astropy.io.fits.card.py@@Card.fromstring": "def fromstring(cls, image):\n    card = cls()\n    if isinstance(image, bytes):\n        image = image.decode('latin1')\n    card._image = _pad(image)\n    card._verified = False\n    return card",
    ".astropy.io.fits.card.py@@Card.__init__": "def __init__(self, keyword=None, value=None, comment=None, **kwargs):\n    if keyword is None and 'key' in kwargs:\n        keyword = kwargs['key']\n    self._keyword = None\n    self._value = None\n    self._comment = None\n    self._valuestring = None\n    self._image = None\n    self._verified = True\n    self._hierarch = False\n    self._invalid = False\n    self._field_specifier = None\n    self._rawkeyword = None\n    self._rawvalue = None\n    if not (keyword is not None and value is not None and self._check_if_rvkc(keyword, value)):\n        if keyword is not None:\n            self.keyword = keyword\n        if value is not None:\n            self.value = value\n    if comment is not None:\n        self.comment = comment\n    self._modified = False\n    self._valuemodified = False",
    ".astropy.io.fits.card.py@@_pad": "def _pad(input):\n    _len = len(input)\n    if _len == Card.length:\n        return input\n    elif _len > Card.length:\n        strlen = _len % Card.length\n        if strlen == 0:\n            return input\n        else:\n            return input + ' ' * (Card.length - strlen)\n    else:\n        strlen = _len % Card.length\n        return input + ' ' * (Card.length - strlen)",
    ".astropy.io.fits.card.py@@Card.keyword": "def keyword(self):\n    if self._keyword is not None:\n        return self._keyword\n    elif self._image:\n        self._keyword = self._parse_keyword()\n        return self._keyword\n    else:\n        self.keyword = ''\n        return ''",
    ".astropy.io.fits.card.py@@Card._parse_keyword": "def _parse_keyword(self):\n    keyword = self._image[:KEYWORD_LENGTH].strip()\n    keyword_upper = keyword.upper()\n    if keyword_upper in self._special_keywords:\n        return keyword_upper\n    elif keyword_upper == 'HIERARCH' and self._image[8] == ' ' and (HIERARCH_VALUE_INDICATOR in self._image):\n        self._hierarch = True\n        self._value_indicator = HIERARCH_VALUE_INDICATOR\n        keyword = self._image.split(HIERARCH_VALUE_INDICATOR, 1)[0][9:]\n        return keyword.strip()\n    else:\n        val_ind_idx = self._image.find(VALUE_INDICATOR)\n        if 0 <= val_ind_idx <= KEYWORD_LENGTH:\n            if val_ind_idx < KEYWORD_LENGTH:\n                keyword = keyword[:val_ind_idx]\n                keyword_upper = keyword_upper[:val_ind_idx]\n            rest = self._image[val_ind_idx + VALUE_INDICATOR_LEN:]\n            if self._check_if_rvkc_image(keyword, rest):\n                return self._keyword\n            return keyword_upper\n        else:\n            warnings.warn('The following header keyword is invalid or follows an unrecognized non-standard convention:\\n{}'.format(self._image), AstropyUserWarning)\n            self._invalid = True\n            return keyword",
    ".astropy.io.fits.card.py@@Card._check_if_rvkc_image": "def _check_if_rvkc_image(self, *args):\n    if len(args) == 1:\n        image = args[0]\n        eq_idx = image.find(VALUE_INDICATOR)\n        if eq_idx < 0 or eq_idx > 9:\n            return False\n        keyword = image[:eq_idx]\n        rest = image[eq_idx + VALUE_INDICATOR_LEN:]\n    else:\n        keyword, rest = args\n    rest = rest.lstrip()\n    if not rest or rest[0] != \"'\" or rest.find(': ') < 2:\n        return False\n    match = self._rvkc_keyword_val_comm_RE.match(rest)\n    if match:\n        self._init_rvkc(keyword, match.group('keyword'), match.group('rawval'), match.group('val'))\n        return True",
    ".astropy.io.fits.header.py@@_BasicHeader.__getitem__": "def __getitem__(self, key):\n    if isinstance(key, numbers.Integral):\n        key = self._keys[key]\n    try:\n        return self._cards[key].value\n    except KeyError:\n        cardstr = self._raw_cards[key]\n        self._cards[key] = card = Card.fromstring(cardstr)\n        return card.value",
    ".astropy.io.fits.hdu.image.py@@PrimaryHDU.match_header": "def match_header(cls, header):\n    card = header.cards[0]\n    return card.keyword == 'SIMPLE' and ('GROUPS' not in header or header['GROUPS'] != True) and card.value",
    ".astropy.io.fits.card.py@@Card.value": "def value(self):\n    if self.field_specifier:\n        return float(self._value)\n    if self._value is not None:\n        value = self._value\n    elif self._valuestring is not None or self._image:\n        value = self._value = self._parse_value()\n    elif self._keyword == '':\n        self._value = value = ''\n    else:\n        self._value = value = UNDEFINED\n    if conf.strip_header_whitespace and isinstance(value, str):\n        value = value.rstrip()\n    return value",
    ".astropy.io.fits.card.py@@Card.field_specifier": "def field_specifier(self):\n    if self.keyword:\n        return self._field_specifier\n    else:\n        return None",
    ".astropy.io.fits.card.py@@Card._parse_value": "def _parse_value(self):\n    if self.keyword.upper() in self._commentary_keywords or self._invalid:\n        return self._image[KEYWORD_LENGTH:].rstrip()\n    if self._check_if_rvkc(self._image):\n        return self._value\n    m = self._value_NFSC_RE.match(self._split()[1])\n    if m is None:\n        raise VerifyError(\"Unparsable card ({}), fix it first with .verify('fix').\".format(self.keyword))\n    if m.group('bool') is not None:\n        value = m.group('bool') == 'T'\n    elif m.group('strg') is not None:\n        value = re.sub(\"''\", \"'\", m.group('strg'))\n    elif m.group('numr') is not None:\n        numr = self._number_NFSC_RE.match(m.group('numr'))\n        digt = translate(numr.group('digt'), FIX_FP_TABLE2, ' ')\n        if numr.group('sign') is None:\n            sign = ''\n        else:\n            sign = numr.group('sign')\n        value = _str_to_num(sign + digt)\n    elif m.group('cplx') is not None:\n        real = self._number_NFSC_RE.match(m.group('real'))\n        rdigt = translate(real.group('digt'), FIX_FP_TABLE2, ' ')\n        if real.group('sign') is None:\n            rsign = ''\n        else:\n            rsign = real.group('sign')\n        value = _str_to_num(rsign + rdigt)\n        imag = self._number_NFSC_RE.match(m.group('imag'))\n        idigt = translate(imag.group('digt'), FIX_FP_TABLE2, ' ')\n        if imag.group('sign') is None:\n            isign = ''\n        else:\n            isign = imag.group('sign')\n        value += _str_to_num(isign + idigt) * 1j\n    else:\n        value = UNDEFINED\n    if not self._valuestring:\n        self._valuestring = m.group('valu')\n    return value",
    ".astropy.io.fits.card.py@@Card._check_if_rvkc": "def _check_if_rvkc(self, *args):\n    if not conf.enable_record_valued_keyword_cards:\n        return False\n    if len(args) == 1:\n        return self._check_if_rvkc_image(*args)\n    elif len(args) == 2:\n        keyword, value = args\n        if not isinstance(keyword, str):\n            return False\n        if keyword in self._commentary_keywords:\n            return False\n        match = self._rvkc_keyword_name_RE.match(keyword)\n        if match and isinstance(value, (int, float)):\n            self._init_rvkc(match.group('keyword'), match.group('field_specifier'), None, value)\n            return True\n        if isinstance(value, str) and value.find(': ') > 0:\n            match = self._rvkc_field_specifier_val_RE.match(value)\n            if match and self._keywd_FSC_RE.match(keyword):\n                self._init_rvkc(keyword, match.group('keyword'), value, match.group('val'))\n                return True",
    ".astropy.io.fits.card.py@@Card._split": "def _split(self):\n    if self._image is not None:\n        image = self._image\n    else:\n        image = self.image\n    if len(self._image) > self.length:\n        values = []\n        comments = []\n        keyword = None\n        for card in self._itersubcards():\n            kw, vc = card._split()\n            if keyword is None:\n                keyword = kw\n            if keyword in self._commentary_keywords:\n                values.append(vc)\n                continue\n            m = self._strg_comment_RE.match(vc)\n            if not m:\n                return (kw, vc)\n            value = m.group('strg') or ''\n            value = value.rstrip().replace(\"''\", \"'\")\n            if value and value[-1] == '&':\n                value = value[:-1]\n            values.append(value)\n            comment = m.group('comm')\n            if comment:\n                comments.append(comment.rstrip())\n        if keyword in self._commentary_keywords:\n            valuecomment = ''.join(values)\n        else:\n            valuecomment = f\"'{''.join(values)}' / {' '.join(comments)}\"\n        return (keyword, valuecomment)\n    if self.keyword in self._special_keywords:\n        keyword, valuecomment = image.split(' ', 1)\n    else:\n        try:\n            delim_index = image.index(self._value_indicator)\n        except ValueError:\n            delim_index = None\n        if delim_index is None:\n            keyword = image[:KEYWORD_LENGTH]\n            valuecomment = image[KEYWORD_LENGTH:]\n        elif delim_index > 10 and image[:9] != 'HIERARCH ':\n            keyword = image[:8]\n            valuecomment = image[8:]\n        else:\n            keyword, valuecomment = image.split(self._value_indicator, 1)\n    return (keyword.strip(), valuecomment.strip())",
    ".astropy.io.fits.hdu.image.py@@PrimaryHDU.__init__": "def __init__(self, data=None, header=None, do_not_scale_image_data=False, ignore_blank=False, uint=True, scale_back=None):\n    super().__init__(data=data, header=header, do_not_scale_image_data=do_not_scale_image_data, uint=uint, ignore_blank=ignore_blank, scale_back=scale_back)\n    if header is None:\n        dim = self._header['NAXIS']\n        if dim == 0:\n            dim = ''\n        self._header.set('EXTEND', True, after='NAXIS' + str(dim))",
    ".astropy.io.fits.hdu.image.py@@_ImageBaseHDU.__init__": "def __init__(self, data=None, header=None, do_not_scale_image_data=False, uint=True, scale_back=False, ignore_blank=False, **kwargs):\n    from .groups import GroupsHDU\n    super().__init__(data=data, header=header)\n    if data is DELAYED:\n        if header is None:\n            raise ValueError('No header to setup HDU.')\n    else:\n        if isinstance(self, ExtensionHDU):\n            c0 = ('XTENSION', 'IMAGE', self.standard_keyword_comments['XTENSION'])\n        else:\n            c0 = ('SIMPLE', True, self.standard_keyword_comments['SIMPLE'])\n        cards = [c0, ('BITPIX', 8, self.standard_keyword_comments['BITPIX']), ('NAXIS', 0, self.standard_keyword_comments['NAXIS'])]\n        if isinstance(self, GroupsHDU):\n            cards.append(('GROUPS', True, self.standard_keyword_comments['GROUPS']))\n        if isinstance(self, (ExtensionHDU, GroupsHDU)):\n            cards.append(('PCOUNT', 0, self.standard_keyword_comments['PCOUNT']))\n            cards.append(('GCOUNT', 1, self.standard_keyword_comments['GCOUNT']))\n        if header is not None:\n            orig = header.copy()\n            header = Header(cards)\n            header.extend(orig, strip=True, update=True, end=True)\n        else:\n            header = Header(cards)\n        self._header = header\n    self._do_not_scale_image_data = do_not_scale_image_data\n    self._uint = uint\n    self._scale_back = scale_back\n    bzero_in_header = 'BZERO' in self._header\n    bscale_in_header = 'BSCALE' in self._header\n    self._bzero = self._header.get('BZERO', 0)\n    self._bscale = self._header.get('BSCALE', 1)\n    self._axes = [self._header.get('NAXIS' + str(axis + 1), 0) for axis in range(self._header.get('NAXIS', 0))]\n    self._bitpix = self._header.get('BITPIX')\n    self._gcount = self._header.get('GCOUNT', 1)\n    self._pcount = self._header.get('PCOUNT', 0)\n    self._blank = None if ignore_blank else self._header.get('BLANK')\n    self._verify_blank()\n    self._orig_bitpix = self._bitpix\n    self._orig_blank = self._header.get('BLANK')\n    self._orig_bzero = self._bzero\n    self._orig_bscale = self._bscale\n    if 'name' in kwargs and kwargs['name']:\n        self.name = kwargs['name']\n    if 'ver' in kwargs and kwargs['ver']:\n        self.ver = kwargs['ver']\n    self._modified = False\n    if data is DELAYED:\n        if not do_not_scale_image_data and (self._bscale != 1 or self._bzero != 0):\n            self._data_needs_rescale = True\n        return\n    else:\n        self.data = data\n        self._bitpix = self._header.get('BITPIX')\n        self._bzero = self._header.get('BZERO')\n        self._bscale = self._header.get('BSCALE')\n    if not bzero_in_header:\n        self._orig_bzero = self._bzero\n    if not bscale_in_header:\n        self._orig_bscale = self._bscale",
    ".astropy.io.fits.hdu.base.py@@_ValidHDU.__init__": "def __init__(self, data=None, header=None, name=None, ver=None, **kwargs):\n    super().__init__(data=data, header=header)\n    if header is not None and (not isinstance(header, (Header, _BasicHeader))):\n        raise ValueError('header must be a Header object')\n    self._checksum = None\n    self._checksum_valid = None\n    self._datasum = None\n    self._datasum_valid = None\n    if name is not None:\n        self.name = name\n    if ver is not None:\n        self.ver = ver",
    ".astropy.io.fits.hdu.base.py@@_BaseHDU.__init__": "def __init__(self, data=None, header=None, *args, **kwargs):\n    if header is None:\n        header = Header()\n    self._header = header\n    self._header_str = None\n    self._file = None\n    self._buffer = None\n    self._header_offset = None\n    self._data_offset = None\n    self._data_size = None\n    self._data_replaced = False\n    self._data_needs_rescale = False\n    self._new = True\n    self._output_checksum = False\n    if 'DATASUM' in self._header and 'CHECKSUM' not in self._header:\n        self._output_checksum = 'datasum'\n    elif 'CHECKSUM' in self._header:\n        self._output_checksum = True",
    ".astropy.io.fits.header.py@@_DelayedHeader.__set__": "def __set__(self, obj, val):\n    obj.__dict__['_header'] = val",
    ".astropy.io.fits.header.py@@_DelayedHeader.__get__": "def __get__(self, obj, owner=None):\n    try:\n        return obj.__dict__['_header']\n    except KeyError:\n        if obj._header_str is not None:\n            hdr = Header.fromstring(obj._header_str)\n            obj._header_str = None\n        else:\n            raise AttributeError(\"'{}' object has no attribute '_header'\".format(obj.__class__.__name__))\n        obj.__dict__['_header'] = hdr\n        return hdr",
    ".astropy.io.fits.util.py@@translate": "def translate(s, table, deletechars):\n    if deletechars:\n        table = table.copy()\n        for c in deletechars:\n            table[ord(c)] = None\n    return s.translate(table)",
    ".astropy.io.fits.util.py@@_str_to_num": "def _str_to_num(val):\n    try:\n        num = int(val)\n    except ValueError:\n        num = float(val)\n    return num",
    ".astropy.io.fits.hdu.image.py@@_ImageBaseHDU._verify_blank": "def _verify_blank(self):\n    if self._blank is None:\n        return\n    messages = []\n    if not _is_int(self._blank):\n        messages.append(\"Invalid value for 'BLANK' keyword in header: {!r} The 'BLANK' keyword must be an integer.  It will be ignored in the meantime.\".format(self._blank))\n        self._blank = None\n    if not self._bitpix > 0:\n        messages.append(\"Invalid 'BLANK' keyword in header.  The 'BLANK' keyword is only applicable to integer data, and will be ignored in this HDU.\")\n        self._blank = None\n    for msg in messages:\n        warnings.warn(msg, VerifyWarning)",
    ".astropy.io.fits.hdu.base.py@@_ValidHDU.size": "def size(self):\n    return self._header.data_size",
    ".astropy.io.fits.header.py@@_BasicHeader.data_size": "def data_size(self):\n    return _hdr_data_size(self)",
    ".astropy.io.fits.header.py@@_hdr_data_size": "def _hdr_data_size(header):\n    size = 0\n    naxis = header.get('NAXIS', 0)\n    if naxis > 0:\n        size = 1\n        for idx in range(naxis):\n            size = size * header['NAXIS' + str(idx + 1)]\n        bitpix = header['BITPIX']\n        gcount = header.get('GCOUNT', 1)\n        pcount = header.get('PCOUNT', 0)\n        size = abs(bitpix) * gcount * (pcount + size) // 8\n    return size",
    ".astropy.io.fits.header.py@@_pad_length": "def _pad_length(stringlen):\n    return (BLOCK_SIZE - stringlen % BLOCK_SIZE) % BLOCK_SIZE",
    ".astropy.io.fits.header.py@@_DelayedHeader.__delete__": "def __delete__(self, obj):\n    del obj.__dict__['_header']",
    ".astropy.io.fits.hdu.hdulist.py@@HDUList.update_extend": "def update_extend(self):\n    if not len(self):\n        return\n    if not isinstance(self[0], PrimaryHDU):\n        return\n    hdr = self[0].header\n\n    def get_first_ext():\n        try:\n            return self[1]\n        except IndexError:\n            return None\n    if 'EXTEND' in hdr:\n        if not hdr['EXTEND'] and get_first_ext() is not None:\n            hdr['EXTEND'] = True\n    elif get_first_ext() is not None:\n        if hdr['NAXIS'] == 0:\n            hdr.set('EXTEND', True, after='NAXIS')\n        else:\n            n = hdr['NAXIS']\n            hdr.set('EXTEND', True, after='NAXIS' + str(n))",
    ".astropy.io.fits.hdu.hdulist.py@@HDUList.__getitem__": "def __getitem__(self, key):\n    if isinstance(key, slice):\n        max_idx = key.stop\n        if max_idx is None:\n            max_idx = len(self)\n        max_idx = self._positive_index_of(max_idx)\n        number_loaded = super().__len__()\n        if max_idx >= number_loaded:\n            for i in range(number_loaded, max_idx):\n                if not self._read_next_hdu():\n                    break\n        try:\n            hdus = super().__getitem__(key)\n        except IndexError as e:\n            if self._read_all:\n                raise e\n            else:\n                raise IndexError('HDU not found, possibly because the index is out of range, or because the file was closed before all HDUs were read')\n        else:\n            return HDUList(hdus)\n    try:\n        return self._try_while_unread_hdus(super().__getitem__, self._positive_index_of(key))\n    except IndexError as e:\n        if self._read_all:\n            raise e\n        else:\n            raise IndexError('HDU not found, possibly because the index is out of range, or because the file was closed before all HDUs were read')",
    ".astropy.io.fits.hdu.hdulist.py@@HDUList._positive_index_of": "def _positive_index_of(self, key):\n    index = self.index_of(key)\n    if index >= 0:\n        return index\n    if abs(index) > len(self):\n        raise IndexError(f'Extension {index} is out of bound or not found.')\n    return len(self) + index",
    ".astropy.io.fits.hdu.hdulist.py@@HDUList.index_of": "def index_of(self, key):\n    if _is_int(key):\n        return key\n    elif isinstance(key, tuple):\n        _key, _ver = key\n    elif isinstance(key, _BaseHDU):\n        return self.index(key)\n    else:\n        _key = key\n        _ver = None\n    if not isinstance(_key, str):\n        raise KeyError('{} indices must be integers, extension names as strings, or (extname, version) tuples; got {}'.format(self.__class__.__name__, _key))\n    _key = _key.strip().upper()\n    found = None\n    for idx, hdu in enumerate(self):\n        name = hdu.name\n        if isinstance(name, str):\n            name = name.strip().upper()\n        if (name == _key or (_key == 'PRIMARY' and idx == 0)) and (_ver is None or _ver == hdu.ver):\n            found = idx\n            break\n    if found is None:\n        raise KeyError(f'Extension {key!r} not found.')\n    else:\n        return found",
    ".astropy.io.fits.util.py@@_is_int": "def _is_int(val):\n    return isinstance(val, all_integer_types)",
    ".astropy.io.fits.hdu.hdulist.py@@HDUList._try_while_unread_hdus": "def _try_while_unread_hdus(self, func, *args, **kwargs):\n    while True:\n        try:\n            return func(*args, **kwargs)\n        except Exception:\n            if self._read_next_hdu():\n                continue\n            else:\n                raise",
    ".astropy.io.fits.hdu.image.py@@_ImageBaseHDU.header": "def header(self):\n    return self._header",
    ".astropy.io.fits.header.py@@Header.fromstring": "def fromstring(cls, data, sep=''):\n    cards = []\n    require_full_cardlength = set(sep).issubset(VALID_HEADER_CHARS)\n    if isinstance(data, bytes):\n        CONTINUE = b'CONTINUE'\n        END = b'END'\n        end_card = END_CARD.encode('ascii')\n        sep = sep.encode('latin1')\n        empty = b''\n    else:\n        CONTINUE = 'CONTINUE'\n        END = 'END'\n        end_card = END_CARD\n        empty = ''\n    idx = 0\n    image = []\n    while idx < len(data):\n        if require_full_cardlength:\n            end_idx = idx + Card.length\n        else:\n            try:\n                end_idx = data.index(sep, idx)\n            except ValueError:\n                end_idx = len(data)\n        next_image = data[idx:end_idx]\n        idx = end_idx + len(sep)\n        if image:\n            if next_image[:8] == CONTINUE:\n                image.append(next_image)\n                continue\n            cards.append(Card.fromstring(empty.join(image)))\n        if require_full_cardlength:\n            if next_image == end_card:\n                image = []\n                break\n        elif next_image.split(sep)[0].rstrip() == END:\n            image = []\n            break\n        image = [next_image]\n    if image:\n        cards.append(Card.fromstring(empty.join(image)))\n    return cls._fromcards(cards)",
    ".astropy.io.fits.header.py@@Header._fromcards": "def _fromcards(cls, cards):\n    header = cls()\n    for idx, card in enumerate(cards):\n        header._cards.append(card)\n        keyword = Card.normalize_keyword(card.keyword)\n        header._keyword_indices[keyword].append(idx)\n        if card.field_specifier is not None:\n            header._rvkc_indices[card.rawkeyword].append(idx)\n    header._modified = False\n    return header",
    ".astropy.io.fits.header.py@@Header.__init__": "def __init__(self, cards=[], copy=False):\n    self.clear()\n    if isinstance(cards, Header):\n        if copy:\n            cards = cards.copy()\n        cards = cards.cards\n    elif isinstance(cards, dict):\n        cards = cards.items()\n    for card in cards:\n        self.append(card, end=True)\n    self._modified = False",
    ".astropy.io.fits.header.py@@Header.clear": "def clear(self):\n    self._cards = []\n    self._keyword_indices = collections.defaultdict(list)\n    self._rvkc_indices = collections.defaultdict(list)",
    ".astropy.io.fits.header.py@@Header._modified": "def _modified(self):\n    modified_cards = any((c._modified for c in self._cards))\n    if modified_cards:\n        self.__dict__['_modified'] = True\n    return self.__dict__['_modified']",
    ".astropy.io.fits.card.py@@Card.normalize_keyword": "def normalize_keyword(cls, keyword):\n    if len(keyword) <= KEYWORD_LENGTH and cls._keywd_FSC_RE.match(keyword):\n        return keyword\n    match = cls._rvkc_keyword_name_RE.match(keyword)\n    if match:\n        return '.'.join((match.group('keyword').strip().upper(), match.group('field_specifier')))\n    elif len(keyword) > 9 and keyword[:9].upper() == 'HIERARCH ':\n        return keyword[9:].strip().upper()\n    else:\n        return keyword.strip().upper()",
    ".astropy.io.fits.header.py@@Header.__contains__": "def __contains__(self, keyword):\n    if keyword in self._keyword_indices or keyword in self._rvkc_indices:\n        return True\n    try:\n        self._cardindex(keyword)\n    except (KeyError, IndexError):\n        return False\n    return True",
    ".astropy.io.fits.header.py@@Header.__getitem__": "def __getitem__(self, key):\n    if isinstance(key, slice):\n        return self.__class__([copy.copy(c) for c in self._cards[key]])\n    elif self._haswildcard(key):\n        return self.__class__([copy.copy(self._cards[idx]) for idx in self._wildcardmatch(key)])\n    elif isinstance(key, str):\n        key = key.strip()\n        if key.upper() in Card._commentary_keywords:\n            key = key.upper()\n            return _HeaderCommentaryCards(self, key)\n    if isinstance(key, tuple):\n        keyword = key[0]\n    else:\n        keyword = key\n    card = self._cards[self._cardindex(key)]\n    if card.field_specifier is not None and keyword == card.rawkeyword:\n        return card.rawvalue\n    value = card.value\n    if value == UNDEFINED:\n        return None\n    return value",
    ".astropy.io.fits.header.py@@Header._haswildcard": "def _haswildcard(self, keyword):\n    return isinstance(keyword, str) and (keyword.endswith('...') or '*' in keyword or '?' in keyword)",
    ".astropy.io.fits.header.py@@Header._cardindex": "def _cardindex(self, key):\n    if isinstance(key, str):\n        keyword = key\n        n = 0\n    elif isinstance(key, numbers.Integral):\n        if key < 0:\n            key += len(self._cards)\n        if key < 0 or key >= len(self._cards):\n            raise IndexError('Header index out of range.')\n        return key\n    elif isinstance(key, slice):\n        return key\n    elif isinstance(key, tuple):\n        if len(key) != 2 or not isinstance(key[0], str) or (not isinstance(key[1], numbers.Integral)):\n            raise ValueError('Tuple indices must be 2-tuples consisting of a keyword string and an integer index.')\n        keyword, n = key\n    else:\n        raise ValueError('Header indices must be either a string, a 2-tuple, or an integer.')\n    keyword = Card.normalize_keyword(keyword)\n    indices = self._keyword_indices.get(keyword, None)\n    if keyword and (not indices):\n        if len(keyword) > KEYWORD_LENGTH or '.' in keyword:\n            raise KeyError(f'Keyword {keyword!r} not found.')\n        else:\n            indices = self._rvkc_indices.get(keyword, None)\n    if not indices:\n        raise KeyError(f'Keyword {keyword!r} not found.')\n    try:\n        return indices[n]\n    except IndexError:\n        raise IndexError('There are only {} {!r} cards in the header.'.format(len(indices), keyword))",
    ".astropy.io.fits.hdu.hdulist.py@@HDUList.__iter__": "def __iter__(self):\n    for idx in itertools.count():\n        try:\n            yield self[idx]\n        except IndexError:\n            break",
    ".astropy.io.fits.hdu.image.py@@_ImageBaseHDU.match_header": "def match_header(cls, header):\n    raise NotImplementedError",
    ".astropy.io.fits.hdu.table.py@@TableHDU.match_header": "def match_header(cls, header):\n    card = header.cards[0]\n    xtension = card.value\n    if isinstance(xtension, str):\n        xtension = xtension.rstrip()\n    return card.keyword == 'XTENSION' and xtension == cls._extension",
    ".astropy.io.fits.hdu.compressed.py@@CompImageHDU.match_header": "def match_header(cls, header):\n    card = header.cards[0]\n    if card.keyword != 'XTENSION':\n        return False\n    xtension = card.value\n    if isinstance(xtension, str):\n        xtension = xtension.rstrip()\n    if xtension not in ('BINTABLE', 'A3DTABLE'):\n        return False\n    if 'ZIMAGE' not in header or not header['ZIMAGE']:\n        return False\n    if COMPRESSION_SUPPORTED and COMPRESSION_ENABLED:\n        return True\n    elif not COMPRESSION_SUPPORTED:\n        warnings.warn('Failure matching header to a compressed image HDU: The compression module is not available.\\nThe HDU will be treated as a Binary Table HDU.', AstropyUserWarning)\n        return False\n    else:\n        return False",
    ".astropy.io.fits.hdu.table.py@@BinTableHDU.match_header": "def match_header(cls, header):\n    card = header.cards[0]\n    xtension = card.value\n    if isinstance(xtension, str):\n        xtension = xtension.rstrip()\n    return card.keyword == 'XTENSION' and xtension in (cls._extension, 'A3DTABLE')",
    ".astropy.io.fits.hdu.table.py@@BinTableHDU.__init__": "def __init__(self, data=None, header=None, name=None, uint=False, ver=None, character_as_bytes=False):\n    from astropy.table import Table\n    if isinstance(data, Table):\n        from astropy.io.fits.convenience import table_to_hdu\n        hdu = table_to_hdu(data)\n        if header is not None:\n            hdu.header.update(header)\n        data = hdu.data\n        header = hdu.header\n    super().__init__(data, header, name=name, uint=uint, ver=ver, character_as_bytes=character_as_bytes)",
    ".astropy.io.fits.hdu.table.py@@_TableBaseHDU.__init__": "def __init__(self, data=None, header=None, name=None, uint=False, ver=None, character_as_bytes=False):\n    super().__init__(data=data, header=header, name=name, ver=ver)\n    self._uint = uint\n    self._character_as_bytes = character_as_bytes\n    if data is DELAYED:\n        if header is None:\n            raise ValueError('No header to setup HDU.')\n        else:\n            self._header = header\n    else:\n        cards = [('XTENSION', self._extension, self._ext_comment), ('BITPIX', 8, 'array data type'), ('NAXIS', 2, 'number of array dimensions'), ('NAXIS1', 0, 'length of dimension 1'), ('NAXIS2', 0, 'length of dimension 2'), ('PCOUNT', 0, 'number of group parameters'), ('GCOUNT', 1, 'number of groups'), ('TFIELDS', 0, 'number of table fields')]\n        if header is not None:\n            hcopy = header.copy(strip=True)\n            cards.extend(hcopy.cards)\n        self._header = Header(cards)\n        if isinstance(data, np.ndarray) and data.dtype.fields is not None:\n            if isinstance(data, self._data_type):\n                self.data = data\n            else:\n                self.data = self._data_type.from_columns(data)\n            if header is not None:\n                future_ignore = set()\n                for keyword in header.keys():\n                    match = TDEF_RE.match(keyword)\n                    try:\n                        base_keyword = match.group('label')\n                    except Exception:\n                        continue\n                    if base_keyword in {'TCTYP', 'TCUNI', 'TCRPX', 'TCRVL', 'TCDLT', 'TRPOS'}:\n                        future_ignore.add(base_keyword)\n                if future_ignore:\n                    keys = ', '.join((x + 'n' for x in sorted(future_ignore)))\n                    warnings.warn('The following keywords are now recognized as special column-related attributes and should be set via the Column objects: {}. In future, these values will be dropped from manually specified headers automatically and replaced with values generated based on the Column objects.'.format(keys), AstropyDeprecationWarning)\n            self._header['NAXIS1'] = self.data._raw_itemsize\n            self._header['NAXIS2'] = self.data.shape[0]\n            self._header['TFIELDS'] = len(self.data._coldefs)\n            self.columns = self.data._coldefs\n            self.columns._add_listener(self.data)\n            self.update()\n            with suppress(TypeError, AttributeError):\n                for idx, col in enumerate(self.columns):\n                    col.array = self.data.field(idx)\n                del self.columns._arrays\n        elif data is None:\n            pass\n        else:\n            raise TypeError('Table data has incorrect type.')\n    if name:\n        self.name = name\n    if ver is not None:\n        self.ver = ver",
    ".astropy.io.fits.header.py@@Header.fromfile": "def fromfile(cls, fileobj, sep='', endcard=True, padding=True):\n    close_file = False\n    if isinstance(fileobj, path_like):\n        if sep:\n            fileobj = open(fileobj, 'r', encoding='latin1')\n        else:\n            fileobj = open(fileobj, 'rb')\n        close_file = True\n    try:\n        is_binary = fileobj_is_binary(fileobj)\n\n        def block_iter(nbytes):\n            while True:\n                data = fileobj.read(nbytes)\n                if data:\n                    yield data\n                else:\n                    break\n        return cls._from_blocks(block_iter, is_binary, sep, endcard, padding)[1]\n    finally:\n        if close_file:\n            fileobj.close()",
    ".astropy.io.fits.util.py@@fileobj_is_binary": "def fileobj_is_binary(f):\n    if hasattr(f, 'binary'):\n        return f.binary\n    if isinstance(f, io.TextIOBase):\n        return False\n    mode = fileobj_mode(f)\n    if mode:\n        return 'b' in mode\n    else:\n        return True",
    ".astropy.io.fits.header.py@@Header._from_blocks": "def _from_blocks(cls, block_iter, is_binary, sep, endcard, padding):\n    actual_block_size = _block_size(sep)\n    clen = Card.length + len(sep)\n    blocks = block_iter(actual_block_size)\n    try:\n        block = next(blocks)\n    except StopIteration:\n        raise EOFError()\n    if not is_binary:\n        block = encode_ascii(block)\n    read_blocks = []\n    is_eof = False\n    end_found = False\n    while True:\n        end_found, block = cls._find_end_card(block, clen)\n        read_blocks.append(decode_ascii(block))\n        if end_found:\n            break\n        try:\n            block = next(blocks)\n        except StopIteration:\n            is_eof = True\n            break\n        if not block:\n            is_eof = True\n            break\n        if not is_binary:\n            block = encode_ascii(block)\n    header_str = ''.join(read_blocks)\n    _check_padding(header_str, actual_block_size, is_eof, check_block_size=padding)\n    if not end_found and is_eof and endcard:\n        raise OSError('Header missing END card.')\n    return (header_str, cls.fromstring(header_str, sep=sep))",
    ".astropy.io.fits.header.py@@_block_size": "def _block_size(sep):\n    return BLOCK_SIZE + len(sep) * (BLOCK_SIZE // Card.length - 1)",
    ".astropy.io.fits.header.py@@Header.block_iter": "def block_iter(nbytes):\n    while True:\n        data = fileobj.read(nbytes)\n        if data:\n            yield data\n        else:\n            break",
    ".astropy.io.fits.util.py@@first": "def first(iterable):\n    return next(iter(iterable))",
    ".astropy.utils.decorators.py@@lazyproperty.__get__": "def __get__(self, obj, owner=None):\n    try:\n        obj_dict = obj.__dict__\n        val = obj_dict.get(self._key, _NotFound)\n        if val is _NotFound:\n            with self._lock:\n                val = obj_dict.get(self._key, _NotFound)\n                if val is _NotFound:\n                    val = self.fget(obj)\n                    obj_dict[self._key] = val\n        return val\n    except AttributeError:\n        if obj is None:\n            return self\n        raise",
    ".astropy.io.fits.hdu.table.py@@_TableBaseHDU.data": "def data(self):\n    data = self._get_tbdata()\n    data._coldefs = self.columns\n    data._character_as_bytes = self._character_as_bytes\n    del self.columns\n    return data",
    ".astropy.io.fits.hdu.table.py@@_TableLikeHDU._get_tbdata": "def _get_tbdata(self):\n    columns = self.columns\n    if any((type(r) in (_FormatP, _FormatQ) for r in columns._recformats)) and self._data_size is not None and (self._data_size > self._theap):\n        raw_data = self._get_raw_data(self._data_size, np.uint8, self._data_offset)\n        tbsize = self._header['NAXIS1'] * self._header['NAXIS2']\n        data = raw_data[:tbsize].view(dtype=columns.dtype, type=np.rec.recarray)\n    else:\n        raw_data = self._get_raw_data(self._nrows, columns.dtype, self._data_offset)\n        if raw_data is None:\n            raw_data = np.array([], dtype=columns.dtype)\n        data = raw_data.view(np.rec.recarray)\n    self._init_tbdata(data)\n    data = data.view(self._data_type)\n    columns._add_listener(data)\n    return data",
    ".astropy.io.fits.hdu.table.py@@_TableBaseHDU.columns": "def columns(self):\n    if self._has_data and hasattr(self.data, '_coldefs'):\n        return self.data._coldefs\n    return self._columns_type(self)",
    ".astropy.io.fits.hdu.base.py@@_BaseHDU._has_data": "def _has_data(self):\n    return self._data_loaded and self.data is not None",
    ".astropy.io.fits.hdu.base.py@@_BaseHDU._data_loaded": "def _data_loaded(self):\n    return 'data' in self.__dict__ and self.data is not DELAYED",
    ".astropy.io.fits.column.py@@ColDefs.__new__": "def __new__(cls, input, ascii=False):\n    klass = cls\n    if hasattr(input, '_columns_type') and issubclass(input._columns_type, ColDefs):\n        klass = input._columns_type\n    elif hasattr(input, '_col_format_cls') and issubclass(input._col_format_cls, _AsciiColumnFormat):\n        klass = _AsciiColDefs\n    if ascii:\n        klass = _AsciiColDefs\n    return object.__new__(klass)",
    ".astropy.io.fits.column.py@@ColDefs.__init__": "def __init__(self, input, ascii=False):\n    from .hdu.table import _TableBaseHDU\n    from .fitsrec import FITS_rec\n    if isinstance(input, ColDefs):\n        self._init_from_coldefs(input)\n    elif isinstance(input, FITS_rec) and hasattr(input, '_coldefs') and input._coldefs:\n        self._init_from_coldefs(input._coldefs)\n    elif isinstance(input, np.ndarray) and input.dtype.fields is not None:\n        self._init_from_array(input)\n    elif isiterable(input):\n        self._init_from_sequence(input)\n    elif isinstance(input, _TableBaseHDU):\n        self._init_from_table(input)\n    else:\n        raise TypeError('Input to ColDefs must be a table HDU, a list of Columns, or a record/field array.')\n    for col in self.columns:\n        col._add_listener(self)",
    ".astropy.utils.misc.py@@isiterable": "def isiterable(obj):\n    try:\n        iter(obj)\n        return True\n    except TypeError:\n        return False",
    ".astropy.io.fits.column.py@@ColDefs._init_from_table": "def _init_from_table(self, table):\n    hdr = table._header\n    nfields = hdr['TFIELDS']\n    col_keywords = [{} for i in range(nfields)]\n    for keyword in hdr:\n        key = TDEF_RE.match(keyword)\n        try:\n            label = key.group('label')\n        except Exception:\n            continue\n        if label in KEYWORD_NAMES:\n            col = int(key.group('num'))\n            if 0 < col <= nfields:\n                attr = KEYWORD_TO_ATTRIBUTE[label]\n                value = hdr[keyword]\n                if attr == 'format':\n                    value = self._col_format_cls(value)\n                col_keywords[col - 1][attr] = value\n    for idx, kwargs in enumerate(col_keywords):\n        valid_kwargs, invalid_kwargs = Column._verify_keywords(**kwargs)\n        for val in invalid_kwargs.values():\n            warnings.warn(f'Invalid keyword for column {idx + 1}: {val[1]}', VerifyWarning)\n        del valid_kwargs['recformat']\n        if 'dim' in valid_kwargs:\n            valid_kwargs['dim'] = kwargs['dim']\n        col_keywords[idx] = valid_kwargs\n    for col in range(nfields):\n        col_keywords[col]['array'] = Delayed(table, col)\n    self.columns = [Column(**attrs) for attrs in col_keywords]\n    self._add_listener(table)",
    ".astropy.io.fits.header.py@@Header.__iter__": "def __iter__(self):\n    for card in self._cards:\n        yield card.keyword",
    ".astropy.io.fits.column.py@@_ColumnFormat.__new__": "def __new__(cls, format):\n    self = super().__new__(cls, format)\n    self.repeat, self.format, self.option = _parse_tformat(format)\n    self.format = self.format.upper()\n    if self.format in ('P', 'Q'):\n        if self.format == 'P':\n            recformat = _FormatP.from_tform(format)\n        else:\n            recformat = _FormatQ.from_tform(format)\n        self.p_format = recformat.format\n    else:\n        self.p_format = None\n    return self",
    ".astropy.io.fits.column.py@@_parse_tformat": "def _parse_tformat(tform):\n    try:\n        repeat, format, option = TFORMAT_RE.match(tform.strip()).groups()\n    except Exception:\n        raise VerifyError(f'Format {tform!r} is not recognized.')\n    if repeat == '':\n        repeat = 1\n    else:\n        repeat = int(repeat)\n    return (repeat, format.upper(), option)",
    ".astropy.io.fits.column.py@@Column._verify_keywords": "def _verify_keywords(cls, name=None, format=None, unit=None, null=None, bscale=None, bzero=None, disp=None, start=None, dim=None, ascii=None, coord_type=None, coord_unit=None, coord_ref_point=None, coord_ref_value=None, coord_inc=None, time_ref_pos=None):\n    valid = {}\n    invalid = {}\n    try:\n        format, recformat = cls._determine_formats(format, start, dim, ascii)\n        valid.update(format=format, recformat=recformat)\n    except (ValueError, VerifyError) as err:\n        msg = f'Column format option (TFORMn) failed verification: {err!s} The invalid value will be ignored for the purpose of formatting the data in this column.'\n        invalid['format'] = (format, msg)\n    except AttributeError as err:\n        msg = f'Column format option (TFORMn) must be a string with a valid FITS table format (got {format!s}: {err!s}). The invalid value will be ignored for the purpose of formatting the data in this column.'\n        invalid['format'] = (format, msg)\n    for k, v in [('name', name), ('unit', unit), ('bscale', bscale), ('bzero', bzero)]:\n        if v is not None and v != '':\n            valid[k] = v\n    if null is not None and null != '':\n        msg = None\n        if isinstance(format, _AsciiColumnFormat):\n            null = str(null)\n            if len(null) > format.width:\n                msg = \"ASCII table null option (TNULLn) is longer than the column's character width and will be truncated (got {!r}).\".format(null)\n        else:\n            tnull_formats = ('B', 'I', 'J', 'K')\n            if not _is_int(null):\n                msg = 'Column null option (TNULLn) must be an integer for binary table columns (got {!r}).  The invalid value will be ignored for the purpose of formatting the data in this column.'.format(null)\n            elif not (format.format in tnull_formats or (format.format in ('P', 'Q') and format.p_format in tnull_formats)):\n                msg = 'Column null option (TNULLn) is invalid for binary table columns of type {!r} (got {!r}).  The invalid value will be ignored for the purpose of formatting the data in this column.'.format(format, null)\n        if msg is None:\n            valid['null'] = null\n        else:\n            invalid['null'] = (null, msg)\n    if disp is not None and disp != '':\n        msg = None\n        if not isinstance(disp, str):\n            msg = f'Column disp option (TDISPn) must be a string (got {disp!r}). The invalid value will be ignored for the purpose of formatting the data in this column.'\n        elif isinstance(format, _AsciiColumnFormat) and disp[0].upper() == 'L':\n            msg = \"Column disp option (TDISPn) may not use the 'L' format with ASCII table columns.  The invalid value will be ignored for the purpose of formatting the data in this column.\"\n        if msg is None:\n            try:\n                _parse_tdisp_format(disp)\n                valid['disp'] = disp\n            except VerifyError as err:\n                msg = f'Column disp option (TDISPn) failed verification: {err!s} The invalid value will be ignored for the purpose of formatting the data in this column.'\n                invalid['disp'] = (disp, msg)\n        else:\n            invalid['disp'] = (disp, msg)\n    if start is not None and start != '':\n        msg = None\n        if not isinstance(format, _AsciiColumnFormat):\n            msg = 'Column start option (TBCOLn) is not allowed for binary table columns (got {!r}).  The invalid keyword will be ignored for the purpose of formatting the data in this column.'.format(start)\n        else:\n            try:\n                start = int(start)\n            except (TypeError, ValueError):\n                pass\n            if not _is_int(start) or start < 1:\n                msg = 'Column start option (TBCOLn) must be a positive integer (got {!r}).  The invalid value will be ignored for the purpose of formatting the data in this column.'.format(start)\n        if msg is None:\n            valid['start'] = start\n        else:\n            invalid['start'] = (start, msg)\n    if dim is not None and dim != '':\n        msg = None\n        dims_tuple = tuple()\n        if isinstance(format, _AsciiColumnFormat):\n            msg = 'Column dim option (TDIMn) is not allowed for ASCII table columns (got {!r}).  The invalid keyword will be ignored for the purpose of formatting this column.'.format(dim)\n        elif isinstance(dim, str):\n            dims_tuple = _parse_tdim(dim)\n        elif isinstance(dim, tuple):\n            dims_tuple = dim\n        else:\n            msg = '`dim` argument must be a string containing a valid value for the TDIMn header keyword associated with this column, or a tuple containing the C-order dimensions for the column.  The invalid value will be ignored for the purpose of formatting this column.'\n        if dims_tuple:\n            if reduce(operator.mul, dims_tuple) > format.repeat:\n                msg = 'The repeat count of the column format {!r} for column {!r} is fewer than the number of elements per the TDIM argument {!r}.  The invalid TDIMn value will be ignored for the purpose of formatting this column.'.format(name, format, dim)\n        if msg is None:\n            valid['dim'] = dims_tuple\n        else:\n            invalid['dim'] = (dim, msg)\n    if coord_type is not None and coord_type != '':\n        msg = None\n        if not isinstance(coord_type, str):\n            msg = 'Coordinate/axis type option (TCTYPn) must be a string (got {!r}). The invalid keyword will be ignored for the purpose of formatting this column.'.format(coord_type)\n        elif len(coord_type) > 8:\n            msg = 'Coordinate/axis type option (TCTYPn) must be a string of atmost 8 characters (got {!r}). The invalid keyword will be ignored for the purpose of formatting this column.'.format(coord_type)\n        if msg is None:\n            valid['coord_type'] = coord_type\n        else:\n            invalid['coord_type'] = (coord_type, msg)\n    if coord_unit is not None and coord_unit != '':\n        msg = None\n        if not isinstance(coord_unit, str):\n            msg = 'Coordinate/axis unit option (TCUNIn) must be a string (got {!r}). The invalid keyword will be ignored for the purpose of formatting this column.'.format(coord_unit)\n        if msg is None:\n            valid['coord_unit'] = coord_unit\n        else:\n            invalid['coord_unit'] = (coord_unit, msg)\n    for k, v in [('coord_ref_point', coord_ref_point), ('coord_ref_value', coord_ref_value), ('coord_inc', coord_inc)]:\n        if v is not None and v != '':\n            msg = None\n            if not isinstance(v, numbers.Real):\n                msg = 'Column {} option ({}n) must be a real floating type (got {!r}). The invalid value will be ignored for the purpose of formatting the data in this column.'.format(k, ATTRIBUTE_TO_KEYWORD[k], v)\n            if msg is None:\n                valid[k] = v\n            else:\n                invalid[k] = (v, msg)\n    if time_ref_pos is not None and time_ref_pos != '':\n        msg = None\n        if not isinstance(time_ref_pos, str):\n            msg = 'Time coordinate reference position option (TRPOSn) must be a string (got {!r}). The invalid keyword will be ignored for the purpose of formatting this column.'.format(time_ref_pos)\n        if msg is None:\n            valid['time_ref_pos'] = time_ref_pos\n        else:\n            invalid['time_ref_pos'] = (time_ref_pos, msg)\n    return (valid, invalid)",
    ".astropy.io.fits.column.py@@Column._determine_formats": "def _determine_formats(cls, format, start, dim, ascii):\n    if isinstance(format, np.dtype):\n        format, _, _ = _dtype_to_recformat(format)\n    if ascii is None and (not isinstance(format, _BaseColumnFormat)):\n        format, recformat = cls._guess_format(format, start, dim)\n    elif not ascii and (not isinstance(format, _BaseColumnFormat)):\n        format, recformat = cls._convert_format(format, _ColumnFormat)\n    elif ascii and (not isinstance(format, _AsciiColumnFormat)):\n        format, recformat = cls._convert_format(format, _AsciiColumnFormat)\n    else:\n        recformat = format.recformat\n    return (format, recformat)",
    ".astropy.io.fits.column.py@@_ColumnFormat.recformat": "def recformat(self):\n    return _convert_format(self)",
    ".astropy.io.fits.column.py@@_convert_format": "def _convert_format(format, reverse=False):\n    if reverse:\n        return _convert_record2fits(format)\n    else:\n        return _convert_fits2record(format)",
    ".astropy.io.fits.column.py@@_convert_fits2record": "def _convert_fits2record(format):\n    repeat, dtype, option = _parse_tformat(format)\n    if dtype in FITS2NUMPY:\n        if dtype == 'A':\n            output_format = FITS2NUMPY[dtype] + str(repeat)\n            if format.lstrip()[0] == 'A' and option != '':\n                output_format = FITS2NUMPY[dtype] + str(int(option))\n        else:\n            repeat_str = ''\n            if repeat != 1:\n                repeat_str = str(repeat)\n            output_format = repeat_str + FITS2NUMPY[dtype]\n    elif dtype == 'X':\n        output_format = _FormatX(repeat)\n    elif dtype == 'P':\n        output_format = _FormatP.from_tform(format)\n    elif dtype == 'Q':\n        output_format = _FormatQ.from_tform(format)\n    elif dtype == 'F':\n        output_format = 'f8'\n    else:\n        raise ValueError(f'Illegal format `{format}`.')\n    return output_format",
    ".astropy.io.fits.column.py@@Delayed.__init__": "def __init__(self, hdu=None, field=None):\n    self.hdu = weakref.proxy(hdu)\n    self.field = field",
    ".astropy.io.fits.column.py@@Column.__init__": "def __init__(self, name=None, format=None, unit=None, null=None, bscale=None, bzero=None, disp=None, start=None, dim=None, array=None, ascii=None, coord_type=None, coord_unit=None, coord_ref_point=None, coord_ref_value=None, coord_inc=None, time_ref_pos=None):\n    if format is None:\n        raise ValueError('Must specify format to construct Column.')\n    kwargs = {'ascii': ascii}\n    for attr in KEYWORD_ATTRIBUTES:\n        value = locals()[attr]\n        if isinstance(value, Card):\n            value = value.value\n        kwargs[attr] = value\n    valid_kwargs, invalid_kwargs = self._verify_keywords(**kwargs)\n    if invalid_kwargs:\n        msg = ['The following keyword arguments to Column were invalid:']\n        for val in invalid_kwargs.values():\n            msg.append(indent(val[1]))\n        raise VerifyError('\\n'.join(msg))\n    for attr in KEYWORD_ATTRIBUTES:\n        setattr(self, attr, valid_kwargs.get(attr))\n    recformat = valid_kwargs['recformat']\n    self._dims = self.dim\n    self.dim = dim\n    self._pseudo_unsigned_ints = False\n    if not isinstance(array, (np.ndarray, chararray.chararray, Delayed)):\n        try:\n            if array is not None:\n                array = np.array(array)\n        except Exception:\n            try:\n                itemsize = int(recformat[1:])\n                array = chararray.array(array, itemsize=itemsize)\n            except ValueError:\n                if isinstance(recformat, _FormatP):\n                    array = _VLF(array, dtype=recformat.dtype)\n                else:\n                    raise ValueError('Data is inconsistent with the format `{}`.'.format(format))\n    array = self._convert_to_valid_data_type(array)\n    if isinstance(array, np.ndarray):\n        self._physical_values = True\n    else:\n        self._physical_values = False\n    self._parent_fits_rec = None\n    self.array = array",
    ".astropy.io.fits.column.py@@ColumnAttribute.__set__": "def __set__(self, obj, value):\n    if self._validator is not None:\n        self._validator(obj, value)\n    old_value = getattr(obj, self._attr, None)\n    setattr(obj, self._attr, value)\n    obj._notify('column_attribute_changed', obj, self._attr[1:], old_value, value)",
    ".astropy.io.fits.column.py@@Column.name": "def name(col, name):\n    if name is None:\n        return\n    if isinstance(name, str) and (not TTYPE_RE.match(name)):\n        warnings.warn('It is strongly recommended that column names contain only upper and lower-case ASCII letters, digits, or underscores for maximum compatibility with other software (got {!r}).'.format(name), VerifyWarning)\n    if not isinstance(name, str) or len(str(Card('TTYPE', name))) != CARD_LENGTH:\n        raise AssertionError('Column name must be a string able to fit in a single FITS card--typically this means a maximum of 68 characters, though it may be fewer if the string contains special characters like quotes.')",
    ".astropy.io.fits.card.py@@Card.__str__": "def __str__(self):\n    return self.image",
    ".astropy.io.fits.card.py@@Card.image": "def image(self):\n    if self._image and (not self._verified):\n        self.verify('fix+warn')\n    if self._image is None or self._modified:\n        self._image = self._format_image()\n    return self._image",
    ".astropy.io.fits.card.py@@Card._format_image": "def _format_image(self):\n    keyword = self._format_keyword()\n    value = self._format_value()\n    is_commentary = keyword.strip() in self._commentary_keywords\n    if is_commentary:\n        comment = ''\n    else:\n        comment = self._format_comment()\n    delimiter = VALUE_INDICATOR\n    if is_commentary:\n        delimiter = ''\n    output = ''.join([keyword, delimiter, value, comment])\n    keywordvalue_length = len(keyword) + len(delimiter) + len(value)\n    if keywordvalue_length > self.length and keyword.startswith('HIERARCH'):\n        if keywordvalue_length == self.length + 1 and keyword[-1] == ' ':\n            output = ''.join([keyword[:-1], delimiter, value, comment])\n        else:\n            raise ValueError('The header keyword {!r} with its value is too long'.format(self.keyword))\n    if len(output) <= self.length:\n        output = f'{output:80}'\n    elif isinstance(self.value, str) and len(value) > self.length - 10:\n        output = self._format_long_image()\n    else:\n        warnings.warn('Card is too long, comment will be truncated.', VerifyWarning)\n        output = output[:Card.length]\n    return output",
    ".astropy.io.fits.card.py@@Card._format_keyword": "def _format_keyword(self):\n    if self.keyword:\n        if self.field_specifier:\n            return '{:{len}}'.format(self.keyword.split('.', 1)[0], len=KEYWORD_LENGTH)\n        elif self._hierarch:\n            return f'HIERARCH {self.keyword} '\n        else:\n            return '{:{len}}'.format(self.keyword, len=KEYWORD_LENGTH)\n    else:\n        return ' ' * KEYWORD_LENGTH",
    ".astropy.io.fits.card.py@@Card._format_value": "def _format_value(self):\n    float_types = (float, np.floating, complex, np.complexfloating)\n    value = self.value\n    value = self._value\n    if self.keyword in self._commentary_keywords:\n        value = str(value)\n    elif self._valuestring and (not self._valuemodified) and isinstance(self.value, float_types):\n        value = f'{self._valuestring:>20}'\n    elif self.field_specifier:\n        value = _format_value(self._value).strip()\n        value = f\"'{self.field_specifier}: {value}'\"\n    else:\n        value = _format_value(value)\n    if not self.field_specifier and len(self.keyword) > KEYWORD_LENGTH:\n        value = value.strip()\n    return value",
    ".astropy.io.fits.card.py@@_format_value": "def _format_value(value):\n    if isinstance(value, str):\n        if value == '':\n            return \"''\"\n        else:\n            exp_val_str = value.replace(\"'\", \"''\")\n            val_str = f\"'{exp_val_str:8}'\"\n            return f'{val_str:20}'\n    elif isinstance(value, (bool, np.bool_)):\n        return f'{repr(value)[0]:>20}'\n    elif _is_int(value):\n        return f'{value:>20d}'\n    elif isinstance(value, (float, np.floating)):\n        return f'{_format_float(value):>20}'\n    elif isinstance(value, (complex, np.complexfloating)):\n        val_str = f'({_format_float(value.real)}, {_format_float(value.imag)})'\n        return f'{val_str:>20}'\n    elif isinstance(value, Undefined):\n        return ''\n    else:\n        return ''",
    ".astropy.io.fits.card.py@@Card._format_comment": "def _format_comment(self):\n    if not self.comment:\n        return ''\n    else:\n        return f' / {self._comment}'",
    ".astropy.io.fits.card.py@@Card.comment": "def comment(self):\n    if self._comment is not None:\n        return self._comment\n    elif self._image:\n        self._comment = self._parse_comment()\n        return self._comment\n    else:\n        self._comment = ''\n        return ''",
    ".astropy.io.fits.util.py@@NotifierMixin._notify": "def _notify(self, notification, *args, **kwargs):\n    if self._listeners is None:\n        return\n    method_name = f'_update_{notification}'\n    for listener in self._listeners.valuerefs():\n        listener = listener()\n        if listener is None:\n            continue\n        if hasattr(listener, method_name):\n            method = getattr(listener, method_name)\n            if callable(method):\n                method(*args, **kwargs)",
    ".astropy.io.fits.column.py@@Column.coord_type": "def coord_type(col, coord_type):\n    if coord_type is None:\n        return\n    if not isinstance(coord_type, str) or len(coord_type) > 8:\n        raise AssertionError('Coordinate/axis type must be a string of atmost 8 characters.')",
    ".astropy.io.fits.column.py@@Column.coord_unit": "def coord_unit(col, coord_unit):\n    if coord_unit is not None and (not isinstance(coord_unit, str)):\n        raise AssertionError('Coordinate/axis unit must be a string.')",
    ".astropy.io.fits.column.py@@Column.coord_ref_point": "def coord_ref_point(col, coord_ref_point):\n    if coord_ref_point is not None and (not isinstance(coord_ref_point, numbers.Real)):\n        raise AssertionError('Pixel coordinate of the reference point must be real floating type.')",
    ".astropy.io.fits.column.py@@Column.coord_ref_value": "def coord_ref_value(col, coord_ref_value):\n    if coord_ref_value is not None and (not isinstance(coord_ref_value, numbers.Real)):\n        raise AssertionError('Coordinate value at reference point must be real floating type.')",
    ".astropy.io.fits.column.py@@Column.coord_inc": "def coord_inc(col, coord_inc):\n    if coord_inc is not None and (not isinstance(coord_inc, numbers.Real)):\n        raise AssertionError('Coordinate increment must be real floating type.')",
    ".astropy.io.fits.column.py@@Column.time_ref_pos": "def time_ref_pos(col, time_ref_pos):\n    if time_ref_pos is not None and (not isinstance(time_ref_pos, str)):\n        raise AssertionError('Time reference position must be a string.')",
    ".astropy.io.fits.column.py@@ColumnAttribute.__get__": "def __get__(self, obj, objtype=None):\n    if obj is None:\n        return self\n    else:\n        return getattr(obj, self._attr)",
    ".astropy.io.fits.column.py@@Column._convert_to_valid_data_type": "def _convert_to_valid_data_type(self, array):\n    if isinstance(array, Delayed):\n        return array\n    elif array is None:\n        return array\n    else:\n        format = self.format\n        dims = self._dims\n        if dims:\n            shape = dims[:-1] if 'A' in format else dims\n            shape = (len(array),) + shape\n            array = array.reshape(shape)\n        if 'P' in format or 'Q' in format:\n            return array\n        elif 'A' in format:\n            if array.dtype.char in 'SU':\n                if dims:\n                    fsize = dims[-1]\n                else:\n                    fsize = np.dtype(format.recformat).itemsize\n                return chararray.array(array, itemsize=fsize, copy=False)\n            else:\n                return _convert_array(array, np.dtype(format.recformat))\n        elif 'L' in format:\n            if array.dtype == np.dtype('bool'):\n                return np.where(array == np.False_, ord('F'), ord('T'))\n            else:\n                return np.where(array == 0, ord('F'), ord('T'))\n        elif 'X' in format:\n            return _convert_array(array, np.dtype('uint8'))\n        else:\n            numpy_format = array.dtype.byteorder + format.recformat\n            bzeros = {2: np.uint16(2 ** 15), 4: np.uint32(2 ** 31), 8: np.uint64(2 ** 63)}\n            if array.dtype.kind == 'u' and array.dtype.itemsize in bzeros and (self.bscale in (1, None, '')) and (self.bzero == bzeros[array.dtype.itemsize]):\n                numpy_format = numpy_format.replace('i', 'u')\n                self._pseudo_unsigned_ints = True\n            dtype = np.dtype(numpy_format).base\n            return _convert_array(array, dtype)",
    ".astropy.io.fits.column.py@@Column.array": "def array(self):\n    if 'array' in self.__dict__:\n        return self.__dict__['array']\n    elif self._parent_fits_rec is not None:\n        parent = self._parent_fits_rec()\n        if parent is not None:\n            return parent[self.name]\n    else:\n        return None",
    ".astropy.io.fits.util.py@@NotifierMixin._add_listener": "def _add_listener(self, listener):\n    if self._listeners is None:\n        self._listeners = weakref.WeakValueDictionary()\n    self._listeners[id(listener)] = listener",
    ".astropy.io.fits.column.py@@ColDefs._recformats": "def _recformats(self):\n    return [fmt.recformat for fmt in self.formats]",
    ".astropy.io.fits.column.py@@ColDefs.formats": "def formats(self):\n    return [col.format for col in self.columns]",
    ".astropy.io.fits.hdu.table.py@@_TableBaseHDU._nrows": "def _nrows(self):\n    if not self._data_loaded:\n        return self._header.get('NAXIS2', 0)\n    else:\n        return len(self.data)",
    ".astropy.io.fits.header.py@@Header.get": "def get(self, key, default=None):\n    try:\n        return self[key]\n    except (KeyError, IndexError):\n        return default",
    ".astropy.io.fits.column.py@@ColDefs.dtype": "def dtype(self):\n    formats = []\n    offsets = [0]\n    for format_, dim in zip(self.formats, self._dims):\n        dt = format_.dtype\n        if len(offsets) < len(self.formats):\n            offsets.append(offsets[-1] + dt.itemsize)\n        if dim:\n            if format_.format == 'A':\n                dt = np.dtype((dt.char + str(dim[-1]), dim[:-1]))\n            else:\n                dt = np.dtype((dt.base, dim))\n        formats.append(dt)\n    return np.dtype({'names': self.names, 'formats': formats, 'offsets': offsets})",
    ".astropy.io.fits.column.py@@ColDefs._dims": "def _dims(self):\n    return [col._dims for col in self.columns]",
    ".astropy.io.fits.column.py@@_BaseColumnFormat.dtype": "def dtype(self):\n    return np.dtype(self.recformat)",
    ".astropy.io.fits.column.py@@ColDefs.names": "def names(self):\n    return [col.name for col in self.columns]",
    ".astropy.io.fits.hdu.base.py@@_BaseHDU._get_raw_data": "def _get_raw_data(self, shape, code, offset):\n    if isinstance(shape, int):\n        shape = (shape,)\n    if self._buffer:\n        return np.ndarray(shape, dtype=code, buffer=self._buffer, offset=offset)\n    elif self._file:\n        return self._file.readarray(offset=offset, dtype=code, shape=shape)\n    else:\n        return None",
    ".astropy.io.fits.file.py@@_File.readarray": "def readarray(self, size=None, offset=0, dtype=np.uint8, shape=None):\n    if not hasattr(self._file, 'read'):\n        raise EOFError\n    if not isinstance(dtype, np.dtype):\n        dtype = np.dtype(dtype)\n    if size and size % dtype.itemsize != 0:\n        raise ValueError(f'size {size} not a multiple of {dtype}')\n    if isinstance(shape, int):\n        shape = (shape,)\n    if not (size or shape):\n        warnings.warn('No size or shape given to readarray(); assuming a shape of (1,)', AstropyUserWarning)\n        shape = (1,)\n    if size and (not shape):\n        shape = (size // dtype.itemsize,)\n    if size and shape:\n        actualsize = np.prod(shape) * dtype.itemsize\n        if actualsize > size:\n            raise ValueError('size {} is too few bytes for a {} array of {}'.format(size, shape, dtype))\n        elif actualsize < size:\n            raise ValueError('size {} is too many bytes for a {} array of {}'.format(size, shape, dtype))\n    filepos = self._file.tell()\n    try:\n        if self.memmap:\n            if self._mmap is None:\n                access_mode = MEMMAP_MODES[self.mode]\n                self._file.seek(0, 0)\n                try:\n                    self._mmap = mmap.mmap(self._file.fileno(), 0, access=access_mode, offset=0)\n                except OSError as exc:\n                    if exc.errno == errno.ENOMEM and self.mode == 'readonly':\n                        warnings.warn(\"Could not memory map array with mode='readonly', falling back to mode='denywrite', which means that the array will be read-only\", AstropyUserWarning)\n                        self._mmap = mmap.mmap(self._file.fileno(), 0, access=MEMMAP_MODES['denywrite'], offset=0)\n                    else:\n                        raise\n            return np.ndarray(shape=shape, dtype=dtype, offset=offset, buffer=self._mmap)\n        else:\n            count = reduce(operator.mul, shape)\n            self._file.seek(offset)\n            data = _array_from_file(self._file, dtype, count)\n            data.shape = shape\n            return data\n    finally:\n        self._file.tell()\n        self._file.seek(filepos)",
    ".astropy.io.fits.util.py@@_array_from_file": "def _array_from_file(infile, dtype, count):\n    if isfile(infile):\n        global CHUNKED_FROMFILE\n        if CHUNKED_FROMFILE is None:\n            if sys.platform == 'darwin' and Version(platform.mac_ver()[0]) < Version('10.9'):\n                CHUNKED_FROMFILE = True\n            else:\n                CHUNKED_FROMFILE = False\n        if CHUNKED_FROMFILE:\n            chunk_size = int(1024 ** 3 / dtype.itemsize)\n            if count < chunk_size:\n                return np.fromfile(infile, dtype=dtype, count=count)\n            else:\n                array = np.empty(count, dtype=dtype)\n                for beg in range(0, count, chunk_size):\n                    end = min(count, beg + chunk_size)\n                    array[beg:end] = np.fromfile(infile, dtype=dtype, count=end - beg)\n                return array\n        else:\n            return np.fromfile(infile, dtype=dtype, count=count)\n    else:\n        read_size = np.dtype(dtype).itemsize * count\n        s = infile.read(read_size)\n        array = np.ndarray(buffer=s, dtype=dtype, shape=(count,))\n        array = array.copy()\n        return array",
    ".astropy.io.fits.hdu.table.py@@_TableLikeHDU._init_tbdata": "def _init_tbdata(self, data):\n    columns = self.columns\n    data.dtype = data.dtype.newbyteorder('>')\n    data._uint = self._uint\n    data._heapoffset = self._theap\n    data._heapsize = self._header['PCOUNT']\n    tbsize = self._header['NAXIS1'] * self._header['NAXIS2']\n    data._gap = self._theap - tbsize\n    for idx, col in enumerate(columns):\n        col.array = data.field(idx)\n    del columns._arrays",
    ".astropy.io.fits.hdu.table.py@@_TableBaseHDU._theap": "def _theap(self):\n    size = self._header['NAXIS1'] * self._header['NAXIS2']\n    return self._header.get('THEAP', size)",
    ".astropy.io.fits.column.py@@ColDefs.__getitem__": "def __getitem__(self, key):\n    if isinstance(key, str):\n        key = _get_index(self.names, key)\n    x = self.columns[key]\n    if _is_int(key):\n        return x\n    else:\n        return ColDefs(x)",
    ".astropy.utils.decorators.py@@lazyproperty.__delete__": "def __delete__(self, obj):\n    if self.fdel:\n        self.fdel(obj)\n    obj.__dict__.pop(self._key, None)",
    ".astropy.io.fits.fitsrec.py@@FITS_rec.__array_finalize__": "def __array_finalize__(self, obj):\n    if obj is None:\n        return\n    if isinstance(obj, FITS_rec):\n        self._character_as_bytes = obj._character_as_bytes\n    if isinstance(obj, FITS_rec) and obj.dtype == self.dtype:\n        self._converted = obj._converted\n        self._heapoffset = obj._heapoffset\n        self._heapsize = obj._heapsize\n        self._col_weakrefs = obj._col_weakrefs\n        self._coldefs = obj._coldefs\n        self._nfields = obj._nfields\n        self._gap = obj._gap\n        self._uint = obj._uint\n    elif self.dtype.fields is not None:\n        self._nfields = len(self.dtype.fields)\n        self._converted = {}\n        self._heapoffset = getattr(obj, '_heapoffset', 0)\n        self._heapsize = getattr(obj, '_heapsize', 0)\n        self._gap = getattr(obj, '_gap', 0)\n        self._uint = getattr(obj, '_uint', False)\n        self._col_weakrefs = weakref.WeakSet()\n        self._coldefs = ColDefs(self)\n        for col in self._coldefs:\n            del col.array\n            col._parent_fits_rec = weakref.ref(self)\n    else:\n        self._init()",
    ".astropy.io.fits.fitsrec.py@@FITS_rec.__getattribute__": "def __getattribute__(self, attr):\n    try:\n        return object.__getattribute__(self, attr)\n    except AttributeError:\n        pass\n    if self._coldefs is not None and attr in self.columns.names:\n        return self.field(attr)\n    return super().__getattribute__(attr)",
    ".astropy.io.fits.fitsrec.py@@FITS_rec._coldefs": "def _coldefs(self):\n    return self.__dict__.get('_coldefs')",
    ".astropy.io.fits.column.py@@ColDefs._init_from_array": "def _init_from_array(self, array):\n    self.columns = []\n    for idx in range(len(array.dtype)):\n        cname = array.dtype.names[idx]\n        ftype = array.dtype.fields[cname][0]\n        format = self._col_format_cls.from_recformat(ftype)\n        dim = array.dtype[idx].shape[::-1]\n        if dim and (len(dim) > 0 or 'A' in format):\n            if 'A' in format:\n                dimel = int(re.findall('[0-9]+', str(ftype.subdtype[0]))[0])\n                dim = (dimel,) + dim\n            dim = '(' + ','.join((str(d) for d in dim)) + ')'\n        else:\n            dim = None\n        bzero = None\n        if ftype.base.kind == 'u':\n            if 'I' in format:\n                bzero = np.uint16(2 ** 15)\n            elif 'J' in format:\n                bzero = np.uint32(2 ** 31)\n            elif 'K' in format:\n                bzero = np.uint64(2 ** 63)\n        c = Column(name=cname, format=format, array=array.view(np.ndarray)[cname], bzero=bzero, dim=dim)\n        self.columns.append(c)",
    ".astropy.io.fits.column.py@@_ColumnFormat.from_recformat": "def from_recformat(cls, recformat):\n    return cls(_convert_format(recformat, reverse=True))",
    ".astropy.io.fits.column.py@@_convert_record2fits": "def _convert_record2fits(format):\n    recformat, kind, dtype = _dtype_to_recformat(format)\n    shape = dtype.shape\n    itemsize = dtype.base.itemsize\n    if dtype.char == 'U' or (dtype.subdtype is not None and dtype.subdtype[0].char == 'U'):\n        itemsize = itemsize // 4\n    option = str(itemsize)\n    ndims = len(shape)\n    repeat = 1\n    if ndims > 0:\n        nel = np.array(shape, dtype='i8').prod()\n        if nel > 1:\n            repeat = nel\n    if kind == 'a':\n        ntot = int(repeat) * int(option)\n        output_format = str(ntot) + 'A'\n    elif recformat in NUMPY2FITS:\n        if repeat != 1:\n            repeat = str(repeat)\n        else:\n            repeat = ''\n        output_format = repeat + NUMPY2FITS[recformat]\n    else:\n        raise ValueError(f'Illegal format `{format}`.')\n    return output_format",
    ".astropy.io.fits.column.py@@_dtype_to_recformat": "def _dtype_to_recformat(dtype):\n    if not isinstance(dtype, np.dtype):\n        dtype = np.dtype(dtype)\n    kind = dtype.base.kind\n    if kind in ('U', 'S'):\n        recformat = kind = 'a'\n    else:\n        itemsize = dtype.base.itemsize\n        recformat = kind + str(itemsize)\n    return (recformat, kind, dtype)",
    ".astropy.io.fits.util.py@@_convert_array": "def _convert_array(array, dtype):\n    if array.dtype == dtype:\n        return array\n    elif array.dtype.itemsize == dtype.itemsize and (not (np.issubdtype(array.dtype, np.number) and np.issubdtype(dtype, np.number))):\n        return array.view(dtype)\n    else:\n        return array.astype(dtype)",
    ".astropy.io.fits.column.py@@Column.__hash__": "def __hash__(self):\n    return hash((self.name.lower(), self.format))",
    ".astropy.io.fits.column.py@@_BaseColumnFormat.__hash__": "def __hash__(self):\n    return hash(self.canonical)",
    ".astropy.io.fits.column.py@@_ColumnFormat.canonical": "def canonical(self):\n    if self.repeat == 1:\n        repeat = ''\n    else:\n        repeat = str(self.repeat)\n    return f'{repeat}{self.format}{self.option}'",
    ".astropy.io.fits.fitsrec.py@@FITS_rec.columns": "def columns(self):\n    return self._coldefs",
    ".astropy.io.fits.column.py@@Column.dtype": "def dtype(self):\n    return self.format.dtype",
    ".astropy.io.fits.fitsrec.py@@FITS_rec.__getitem__": "def __getitem__(self, key):\n    if self._coldefs is None:\n        return super().__getitem__(key)\n    if isinstance(key, str):\n        return self.field(key)\n    out = self.view(np.recarray)[key]\n    if type(out) is not np.recarray:\n        return self._record_type(self, key)\n    out = out.view(type(self))\n    out._uint = self._uint\n    out._coldefs = ColDefs(self._coldefs)\n    arrays = []\n    out._converted = {}\n    for idx, name in enumerate(self._coldefs.names):\n        arrays.append(self._coldefs._arrays[idx][key])\n        if name in self._converted:\n            dummy = self._converted[name]\n            field = np.ndarray.__getitem__(dummy, key)\n            out._converted[name] = field\n    out._coldefs._arrays = arrays\n    return out",
    ".astropy.io.fits.fitsrec.py@@FITS_rec.field": "def field(self, key):\n    column = self.columns[key]\n    name = column.name\n    format = column.format\n    if format.dtype.itemsize == 0:\n        warnings.warn('Field {!r} has a repeat count of 0 in its format code, indicating an empty field.'.format(key))\n        return np.array([], dtype=format.dtype)\n    base = self\n    while isinstance(base, FITS_rec) and isinstance(base.base, np.recarray):\n        base = base.base\n    field = _get_recarray_field(base, name)\n    if name not in self._converted:\n        recformat = format.recformat\n        if isinstance(recformat, _FormatP):\n            converted = self._convert_p(column, field, recformat)\n        else:\n            converted = self._convert_other(column, field, recformat)\n        self._cache_field(name, converted)\n        return converted\n    return self._converted[name]",
    ".astropy.io.fits.column.py@@_get_index": "def _get_index(names, key):\n    if _is_int(key):\n        indx = int(key)\n    elif isinstance(key, str):\n        try:\n            indx = names.index(key.rstrip())\n        except ValueError:\n            _key = key.lower().rstrip()\n            names = [n.lower().rstrip() for n in names]\n            count = names.count(_key)\n            if count == 1:\n                indx = names.index(_key)\n            elif count == 0:\n                raise KeyError(f\"Key '{key}' does not exist.\")\n            else:\n                raise KeyError(f\"Ambiguous key name '{key}'.\")\n    else:\n        raise KeyError(f\"Illegal key '{key!r}'.\")\n    return indx",
    ".astropy.io.fits.fitsrec.py@@_get_recarray_field": "def _get_recarray_field(array, key):\n    field = np.recarray.field(array, key)\n    if field.dtype.char in ('S', 'U') and (not isinstance(field, chararray.chararray)):\n        field = field.view(chararray.chararray)\n    return field",
    ".astropy.io.fits.fitsrec.py@@FITS_rec._convert_other": "def _convert_other(self, column, field, recformat):\n    if isinstance(recformat, _FormatX):\n        return self._convert_x(field, recformat)\n    _str, _bool, _number, _scale, _zero, bscale, bzero, dim = self._get_scale_factors(column)\n    indx = self.names.index(column.name)\n    if not _str and isinstance(self._coldefs, _AsciiColDefs):\n        field = self._convert_ascii(column, field)\n    if dim:\n        if field.ndim > 1:\n            actual_shape = field.shape[1:]\n            if _str:\n                actual_shape = actual_shape + (field.itemsize,)\n        else:\n            actual_shape = field.shape[0]\n        if dim == actual_shape:\n            dim = None\n        else:\n            nitems = reduce(operator.mul, dim)\n            if _str:\n                actual_nitems = field.itemsize\n            elif len(field.shape) == 1:\n                actual_nitems = 1\n            else:\n                actual_nitems = field.shape[1]\n            if nitems > actual_nitems:\n                warnings.warn('TDIM{} value {:d} does not fit with the size of the array items ({:d}).  TDIM{:d} will be ignored.'.format(indx + 1, self._coldefs[indx].dims, actual_nitems, indx + 1))\n                dim = None\n    if not column.ascii and column.format.p_format:\n        format_code = column.format.p_format\n    else:\n        format_code = column.format.format\n    if _number and (_scale or _zero) and (not column._physical_values):\n        if self._uint:\n            if bzero == 2 ** 15 and format_code == 'I':\n                field = np.array(field, dtype=np.uint16)\n            elif bzero == 2 ** 31 and format_code == 'J':\n                field = np.array(field, dtype=np.uint32)\n            elif bzero == 2 ** 63 and format_code == 'K':\n                field = np.array(field, dtype=np.uint64)\n                bzero64 = np.uint64(2 ** 63)\n            else:\n                field = np.array(field, dtype=np.float64)\n        else:\n            field = np.array(field, dtype=np.float64)\n        if _scale:\n            np.multiply(field, bscale, field)\n        if _zero:\n            if self._uint and format_code == 'K':\n                test_overflow = field.copy()\n                try:\n                    test_overflow += bzero64\n                except OverflowError:\n                    warnings.warn('Overflow detected while applying TZERO{:d}. Returning unscaled data.'.format(indx + 1))\n                else:\n                    field = test_overflow\n            else:\n                field += bzero\n        column._physical_values = True\n    elif _bool and field.dtype != bool:\n        field = np.equal(field, ord('T'))\n    elif _str:\n        if not self._character_as_bytes:\n            with suppress(UnicodeDecodeError):\n                field = decode_ascii(field)\n    if dim:\n        nitems = reduce(operator.mul, dim)\n        if field.ndim > 1:\n            field = field[:, :nitems]\n        if _str:\n            fmt = field.dtype.char\n            dtype = (f'|{fmt}{dim[-1]}', dim[:-1])\n            field.dtype = dtype\n        else:\n            field.shape = (field.shape[0],) + dim\n    return field",
    ".astropy.io.fits.fitsrec.py@@FITS_rec._get_scale_factors": "def _get_scale_factors(self, column):\n    _str = column.format.format == 'A'\n    _bool = column.format.format == 'L'\n    _number = not (_bool or _str)\n    bscale = column.bscale\n    bzero = column.bzero\n    _scale = bscale not in ('', None, 1)\n    _zero = bzero not in ('', None, 0)\n    if not _scale:\n        bscale = 1\n    if not _zero:\n        bzero = 0\n    dim = column._dims\n    return (_str, _bool, _number, _scale, _zero, bscale, bzero, dim)",
    ".astropy.io.fits.fitsrec.py@@FITS_rec.names": "def names(self):\n    if self.dtype.fields:\n        return list(self.dtype.names)\n    elif getattr(self, '_coldefs', None) is not None:\n        return self._coldefs.names\n    else:\n        return None",
    ".astropy.io.fits.column.py@@Column.ascii": "def ascii(self):\n    return isinstance(self.format, _AsciiColumnFormat)",
    ".astropy.io.fits.fitsrec.py@@FITS_rec._cache_field": "def _cache_field(self, name, field):\n    base = field\n    while True:\n        self_base = self\n        while True:\n            if self_base is base:\n                return\n            if getattr(self_base, 'base', None) is not None:\n                self_base = self_base.base\n            else:\n                break\n        if getattr(base, 'base', None) is not None:\n            base = base.base\n        else:\n            break\n    self._converted[name] = field",
    ".astropy.table.column.py@@Column.__new__": "def __new__(cls, data=None, name=None, dtype=None, shape=(), length=0, description=None, unit=None, format=None, meta=None, copy=False, copy_indices=True):\n    if isinstance(data, MaskedColumn) and np.any(data.mask):\n        raise TypeError('Cannot convert a MaskedColumn with masked value to a Column')\n    self = super().__new__(cls, data=data, name=name, dtype=dtype, shape=shape, length=length, description=description, unit=unit, format=format, meta=meta, copy=copy, copy_indices=copy_indices)\n    return self",
    ".astropy.table.column.py@@BaseColumn.__new__": "def __new__(cls, data=None, name=None, dtype=None, shape=(), length=0, description=None, unit=None, format=None, meta=None, copy=False, copy_indices=True):\n    if data is None:\n        self_data = np.zeros((length,) + shape, dtype=dtype)\n    elif isinstance(data, BaseColumn) and hasattr(data, '_name'):\n        self_data = np.array(data.data, dtype=dtype, copy=copy)\n        if description is None:\n            description = data.description\n        if unit is None:\n            unit = unit or data.unit\n        if format is None:\n            format = data.format\n        if meta is None:\n            meta = data.meta\n        if name is None:\n            name = data.name\n    elif isinstance(data, Quantity):\n        if unit is None:\n            self_data = np.array(data, dtype=dtype, copy=copy)\n            unit = data.unit\n        else:\n            self_data = Quantity(data, unit, dtype=dtype, copy=copy).value\n        if 'info' in data.__dict__:\n            if description is None:\n                description = data.info.description\n            if format is None:\n                format = data.info.format\n            if meta is None:\n                meta = data.info.meta\n    else:\n        if np.dtype(dtype).char == 'S':\n            data = cls._encode_str(data)\n        self_data = np.array(data, dtype=dtype, copy=copy)\n    self = self_data.view(cls)\n    self._name = None if name is None else str(name)\n    self._parent_table = None\n    self.unit = unit\n    self._format = format\n    self.description = description\n    self.meta = meta\n    self.indices = deepcopy(getattr(data, 'indices', [])) if copy_indices else []\n    for index in self.indices:\n        index.replace_col(data, self)\n    return self",
    ".astropy.table.column.py@@BaseColumn.__array_finalize__": "def __array_finalize__(self, obj):\n    if obj is None:\n        return\n    if callable(super().__array_finalize__):\n        super().__array_finalize__(obj)\n    self.parent_table = None\n    if not hasattr(self, 'indices'):\n        self.indices = []\n    self._copy_attrs(obj)\n    if 'info' in getattr(obj, '__dict__', {}):\n        self.info = obj.info",
    ".astropy.table.column.py@@Column.__setattr__": "def __setattr__(self, item, value):\n    if not isinstance(self, MaskedColumn) and item == 'mask':\n        raise AttributeError('cannot set mask value to a column in non-masked Table')\n    super().__setattr__(item, value)\n    if item == 'unit' and issubclass(self.dtype.type, np.number):\n        try:\n            converted = self.parent_table._convert_col_for_table(self)\n        except AttributeError:\n            pass\n        else:\n            if converted is not self:\n                self.parent_table.replace_column(self.name, converted)",
    ".astropy.table.column.py@@BaseColumn.parent_table": "def parent_table(self):\n    if getattr(self, '_parent_table', None) is None:\n        return None\n    else:\n        return self._parent_table()",
    ".astropy.table.column.py@@BaseColumn._copy_attrs": "def _copy_attrs(self, obj):\n    for attr in ('name', 'unit', '_format', 'description'):\n        val = getattr(obj, attr, None)\n        setattr(self, attr, val)\n    obj_meta = getattr(obj, 'meta', None)\n    if obj_meta:\n        self.meta = obj_meta.copy()",
    ".astropy.table.column.py@@BaseColumn.name": "def name(self):\n    return self._name",
    ".astropy.table.column.py@@BaseColumn.unit": "def unit(self):\n    return self._unit",
    ".astropy.utils.metadata.py@@MetaData.__set__": "def __set__(self, instance, value):\n    if value is None:\n        instance._meta = OrderedDict()\n    elif isinstance(value, Mapping):\n        if self.copy:\n            instance._meta = deepcopy(value)\n        else:\n            instance._meta = value\n    else:\n        raise TypeError('meta attribute must be dict-like')",
    ".astropy.table.table.py@@Table.__init__": "def __init__(self, data=None, masked=False, names=None, dtype=None, meta=None, copy=True, rows=None, copy_indices=True, units=None, descriptions=None, **kwargs):\n    self._set_masked(masked)\n    self.columns = self.TableColumns()\n    self.formatter = self.TableFormatter()\n    self._copy_indices = True\n    self._init_indices = copy_indices\n    self.primary_key = None\n    if not copy and dtype is not None:\n        raise ValueError('Cannot specify dtype when copy=False')\n    names_from_list_of_dict = None\n    if rows is not None:\n        if data is not None:\n            raise ValueError('Cannot supply both `data` and `rows` values')\n        if isinstance(rows, types.GeneratorType):\n            rows = list(rows)\n        names_from_list_of_dict = _get_names_from_list_of_dict(rows)\n        if names_from_list_of_dict:\n            data = rows\n        elif isinstance(rows, self.Row):\n            data = rows\n        else:\n            data = list(zip(*rows))\n    default_names = None\n    meta_table_attrs = {}\n    if kwargs:\n        for attr in list(kwargs):\n            descr = getattr(self.__class__, attr, None)\n            if isinstance(descr, TableAttribute):\n                meta_table_attrs[attr] = kwargs.pop(attr)\n    if hasattr(data, '__astropy_table__'):\n        data = data.__astropy_table__(self.__class__, copy, **kwargs)\n        copy = False\n    elif kwargs:\n        raise TypeError('__init__() got unexpected keyword argument {!r}'.format(list(kwargs.keys())[0]))\n    if isinstance(data, np.ndarray) and data.shape == (0,) and (not data.dtype.names):\n        data = None\n    if isinstance(data, self.Row):\n        data = data._table[data._index:data._index + 1]\n    if isinstance(data, (list, tuple)):\n        names_from_list_of_dict = names_from_list_of_dict or _get_names_from_list_of_dict(data)\n        if names_from_list_of_dict:\n            init_func = self._init_from_list_of_dicts\n            n_cols = len(names_from_list_of_dict)\n        else:\n            init_func = self._init_from_list\n            n_cols = len(data)\n    elif isinstance(data, np.ndarray):\n        if data.dtype.names:\n            init_func = self._init_from_ndarray\n            n_cols = len(data.dtype.names)\n            default_names = data.dtype.names\n        else:\n            init_func = self._init_from_ndarray\n            if data.shape == ():\n                raise ValueError('Can not initialize a Table with a scalar')\n            elif len(data.shape) == 1:\n                data = data[np.newaxis, :]\n            n_cols = data.shape[1]\n    elif isinstance(data, Mapping):\n        init_func = self._init_from_dict\n        default_names = list(data)\n        n_cols = len(default_names)\n    elif isinstance(data, Table):\n        if meta is None and data.meta:\n            meta = data.meta if copy else data.meta.copy()\n        self.primary_key = data.primary_key\n        self._init_indices = self._init_indices and data._copy_indices\n        default_names = data.colnames\n        n_cols = len(default_names)\n        data = list(data.columns.values())\n        init_func = self._init_from_list\n    elif data is None:\n        if names is None:\n            if dtype is None:\n                names = []\n            else:\n                try:\n                    dtype = np.dtype(dtype)\n                    names = dtype.names\n                    dtype = [dtype[name] for name in names]\n                except Exception:\n                    raise ValueError('dtype was specified but could not be parsed for column names')\n        init_func = self._init_from_list\n        n_cols = len(names)\n        data = [[]] * n_cols\n    else:\n        raise ValueError(f'Data type {type(data)} not allowed to init Table')\n    if dtype is None:\n        dtype = [None] * n_cols\n    elif isinstance(dtype, np.dtype):\n        if default_names is None:\n            default_names = dtype.names\n        dtype = [dtype[name] for name in dtype.names]\n    if names is None:\n        names = default_names or [None] * n_cols\n    names = [None if name is None else str(name) for name in names]\n    self._check_names_dtype(names, dtype, n_cols)\n    init_func(data, names, dtype, n_cols, copy)\n    if meta is not None:\n        self.meta = deepcopy(meta) if copy else meta\n    if meta_table_attrs:\n        for attr, value in meta_table_attrs.items():\n            setattr(self, attr, value)\n    if self.masked not in (None, True, False):\n        raise TypeError('masked property must be None, True or False')\n    self._set_column_attribute('unit', units)\n    self._set_column_attribute('description', descriptions)",
    ".astropy.table.table.py@@Table._set_masked": "def _set_masked(self, masked):\n    if masked in [True, False, None]:\n        self._masked = masked\n    else:\n        raise ValueError('masked should be one of True, False, None')\n    self._column_class = self.MaskedColumn if self._masked else self.Column",
    ".astropy.table.table.py@@TableColumns.__init__": "def __init__(self, cols={}):\n    if isinstance(cols, (list, tuple)):\n        newcols = []\n        for col in cols:\n            if has_info_class(col, BaseColumnInfo):\n                newcols.append((col.info.name, col))\n            else:\n                newcols.append(col)\n        cols = newcols\n    super().__init__(cols)",
    ".astropy.table.table.py@@_get_names_from_list_of_dict": "def _get_names_from_list_of_dict(rows):\n    if rows is None:\n        return None\n    names = set()\n    for row in rows:\n        if not isinstance(row, Mapping):\n            return None\n        names.update(row)\n    return list(names)",
    ".astropy.table.table.py@@Table._check_names_dtype": "def _check_names_dtype(self, names, dtype, n_cols):\n    for inp_list, inp_str in ((dtype, 'dtype'), (names, 'names')):\n        if not isiterable(inp_list):\n            raise ValueError(f'{inp_str} must be a list or None')\n    if len(names) != n_cols or len(dtype) != n_cols:\n        raise ValueError('Arguments \"names\" and \"dtype\" must match number of columns')",
    ".astropy.table.table.py@@Table._init_from_list": "def _init_from_list(self, data, names, dtype, n_cols, copy):\n    if n_cols == 0:\n        return\n    cols = []\n    default_names = _auto_names(n_cols)\n    for col, name, default_name, dtype in zip(data, names, default_names, dtype):\n        col = self._convert_data_to_col(col, copy, default_name, dtype, name)\n        cols.append(col)\n    self._init_from_cols(cols)",
    ".astropy.table.column.py@@_auto_names": "def _auto_names(n_cols):\n    from . import conf\n    return [str(conf.auto_colname).format(i) for i in range(n_cols)]",
    ".astropy.extern.configobj.validate.py@@is_string": "def is_string(value, min=None, max=None):\n    if not isinstance(value, string_type):\n        raise VdtTypeError(value)\n    min_len, max_len = _is_num_param(('min', 'max'), (min, max))\n    try:\n        num_members = len(value)\n    except TypeError:\n        raise VdtTypeError(value)\n    if min_len is not None and num_members < min_len:\n        raise VdtValueTooShortError(value)\n    if max_len is not None and num_members > max_len:\n        raise VdtValueTooLongError(value)\n    return value",
    ".astropy.extern.configobj.validate.py@@_is_num_param": "def _is_num_param(names, values, to_float=False):\n    fun = to_float and float or int\n    out_params = []\n    for name, val in zip(names, values):\n        if val is None:\n            out_params.append(val)\n        elif isinstance(val, (int, long, float, string_type)):\n            try:\n                out_params.append(fun(val))\n            except ValueError as e:\n                raise VdtParamError(name, val)\n        else:\n            raise VdtParamError(name, val)\n    return out_params",
    ".astropy.table.table.py@@Table._convert_data_to_col": "def _convert_data_to_col(self, data, copy=True, default_name=None, dtype=None, name=None):\n    data_is_mixin = self._is_mixin_for_table(data)\n    masked_col_cls = self.ColumnClass if issubclass(self.ColumnClass, self.MaskedColumn) else self.MaskedColumn\n    try:\n        data0_is_mixin = self._is_mixin_for_table(data[0])\n    except Exception:\n        data0_is_mixin = False\n    if (handler := get_mixin_handler(data)) is not None:\n        original_data = data\n        data = handler(data)\n        if not (data_is_mixin := self._is_mixin_for_table(data)):\n            fully_qualified_name = original_data.__class__.__module__ + '.' + original_data.__class__.__name__\n            raise TypeError(f'Mixin handler for object of type {fully_qualified_name} did not return a valid mixin column')\n    if not isinstance(data, Column) and (not data_is_mixin) and isinstance(data, np.ndarray) and (len(data.dtype) > 1):\n        data = data.view(NdarrayMixin)\n        data_is_mixin = True\n    if not name:\n        if isinstance(data, Column):\n            name = data.name or default_name\n        elif 'info' in getattr(data, '__dict__', ()):\n            name = data.info.name or default_name\n        else:\n            name = default_name\n    if isinstance(data, Column):\n        col_cls = self._get_col_cls_for_table(data)\n    elif data_is_mixin:\n        col = col_copy(data, copy_indices=self._init_indices) if copy else data\n        col.info.name = name\n        return col\n    elif data0_is_mixin:\n        try:\n            col = data[0].__class__(data)\n            col.info.name = name\n            return col\n        except Exception:\n            data = np.array(data, dtype=object)\n            col_cls = self.ColumnClass\n    elif isinstance(data, (np.ma.MaskedArray, Masked)):\n        col_cls = masked_col_cls\n    elif data is None:\n        data = np.array(None)\n        col_cls = self.ColumnClass\n    elif not hasattr(data, 'dtype'):\n        data = _convert_sequence_data_to_array(data, dtype)\n        copy = False\n        col_cls = masked_col_cls if isinstance(data, np.ma.MaskedArray) else self.ColumnClass\n    else:\n        col_cls = self.ColumnClass\n    try:\n        col = col_cls(name=name, data=data, dtype=dtype, copy=copy, copy_indices=self._init_indices)\n    except Exception:\n        raise ValueError('unable to convert data to Column for Table')\n    col = self._convert_col_for_table(col)\n    return col",
    ".astropy.table.table.py@@Table._is_mixin_for_table": "def _is_mixin_for_table(self, col):\n    if isinstance(col, BaseColumn):\n        return False\n    return has_info_class(col, MixinInfo) and (not has_info_class(col, QuantityInfo))",
    ".astropy.table.table.py@@Table.ColumnClass": "def ColumnClass(self):\n    if self._column_class is None:\n        return self.Column\n    else:\n        return self._column_class",
    ".astropy.table.table.py@@has_info_class": "def has_info_class(obj, cls):\n    return isinstance(getattr(obj.__class__, 'info', None), cls)",
    ".astropy.table.mixins.registry.py@@get_mixin_handler": "def get_mixin_handler(obj):\n    if isinstance(obj, str):\n        return _handlers.get(obj, None)\n    else:\n        return _handlers.get(obj.__class__.__module__ + '.' + obj.__class__.__name__, None)",
    ".astropy.table.table.py@@Table._get_col_cls_for_table": "def _get_col_cls_for_table(self, col):\n    col_cls = col.__class__\n    if self.masked:\n        if isinstance(col, Column) and (not isinstance(col, self.MaskedColumn)):\n            col_cls = self.MaskedColumn\n    elif isinstance(col, MaskedColumn):\n        if not isinstance(col, self.MaskedColumn):\n            col_cls = self.MaskedColumn\n    elif isinstance(col, Column) and (not isinstance(col, self.Column)):\n        col_cls = self.Column\n    return col_cls",
    ".astropy.table.table.py@@Table.masked": "def masked(self):\n    return self._masked",
    ".astropy.table.column.py@@BaseColumn.data": "def data(self):\n    return self.view(np.ndarray)",
    ".astropy.table.column.py@@BaseColumn.format": "def format(self):\n    return self._format",
    ".astropy.utils.metadata.py@@MetaData.__get__": "def __get__(self, instance, owner):\n    if instance is None:\n        return self\n    if not hasattr(instance, '_meta'):\n        instance._meta = OrderedDict()\n    return instance._meta",
    ".astropy.table.table.py@@Table._convert_col_for_table": "def _convert_col_for_table(self, col):\n    if isinstance(col, Column) and (not isinstance(col, self.ColumnClass)):\n        col_cls = self._get_col_cls_for_table(col)\n        if col_cls is not col.__class__:\n            col = col_cls(col, copy=False)\n    return col",
    ".astropy.table.table.py@@Table._init_from_cols": "def _init_from_cols(self, cols):\n    lengths = set((len(col) for col in cols))\n    if len(lengths) > 1:\n        raise ValueError(f'Inconsistent data column lengths: {lengths}')\n    newcols = [self._convert_col_for_table(col) for col in cols]\n    self._make_table_from_cols(self, newcols)\n    index_dict = {}\n    for col in self.itercols():\n        for i, index in enumerate(col.info.indices or []):\n            names = tuple((ind_col.info.name for ind_col in index.columns))\n            if names in index_dict:\n                col.info.indices[i] = index_dict[names]\n            else:\n                index_dict[names] = index",
    ".astropy.table.table.py@@Table._make_table_from_cols": "def _make_table_from_cols(table, cols, verify=True, names=None):\n    if names is None:\n        names = [col.info.name for col in cols]\n    if verify:\n        if None in names:\n            raise TypeError('Cannot have None for column name')\n        if len(set(names)) != len(names):\n            raise ValueError('Duplicate column names')\n    table.columns = table.TableColumns(((name, col) for name, col in zip(names, cols)))\n    for col in cols:\n        table._set_col_parent_table_and_mask(col)",
    ".astropy.utils.data_info.py@@DataInfo.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        self._parent_cls = owner_cls\n        return self\n    info = instance.__dict__.get('info')\n    if info is None:\n        info = instance.__dict__['info'] = self.__class__(bound=True)\n    info._parent_ref = weakref.ref(instance)\n    return info",
    ".astropy.utils.data_info.py@@BaseColumnInfo.__init__": "def __init__(self, bound=False):\n    super().__init__(bound=bound)\n    if bound:\n        self._format_funcs = {}",
    ".astropy.utils.data_info.py@@DataInfo.__init__": "def __init__(self, bound=False):\n    if bound:\n        self._attrs = {}",
    ".astropy.utils.data_info.py@@ParentAttribute.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        return self\n    return getattr(instance._parent, self.attr)",
    ".astropy.utils.data_info.py@@DataInfo._parent": "def _parent(self):\n    try:\n        parent = self._parent_ref()\n    except AttributeError:\n        return None\n    if parent is None:\n        raise AttributeError('failed to access \"info\" attribute on a temporary object.\\n\\nIt looks like you have done something like ``col[3:5].info`` or\\n``col.quantity.info``, i.e.  you accessed ``info`` from a temporary slice\\nobject that only exists momentarily.  This has failed because the reference to\\nthat temporary object is now lost.  Instead force a permanent reference (e.g.\\n``c = col[3:5]`` followed by ``c.info``).')\n    return parent",
    ".astropy.table.table.py@@TableColumns.__setitem__": "def __setitem__(self, item, value, validated=False):\n    if item in self and (not validated):\n        raise ValueError(\"Cannot replace column '{}'.  Use Table.replace_column() instead.\".format(item))\n    super().__setitem__(item, value)",
    ".astropy.table.table.py@@Table._set_col_parent_table_and_mask": "def _set_col_parent_table_and_mask(self, col):\n    col_info = col if isinstance(col, Column) else col.info\n    col_info.parent_table = self\n    if self.masked and (not hasattr(col, 'mask')):\n        col.mask = FalseArray(col.shape)",
    ".astropy.table.table.py@@Table.itercols": "def itercols(self):\n    for colname in self.columns:\n        yield self[colname]",
    ".astropy.table.table.py@@Table.__getitem__": "def __getitem__(self, item):\n    if isinstance(item, str):\n        return self.columns[item]\n    elif isinstance(item, (int, np.integer)):\n        return self.Row(self, item)\n    elif isinstance(item, np.ndarray) and item.shape == () and (item.dtype.kind == 'i'):\n        return self.Row(self, item.item())\n    elif self._is_list_or_tuple_of_str(item):\n        out = self.__class__([self[x] for x in item], copy_indices=self._copy_indices)\n        out._groups = groups.TableGroups(out, indices=self.groups._indices, keys=self.groups._keys)\n        out.meta = self.meta.copy()\n        return out\n    elif isinstance(item, np.ndarray) and item.size == 0 or (isinstance(item, (tuple, list)) and (not item)):\n        return self._new_from_slice([])\n    elif isinstance(item, slice) or isinstance(item, np.ndarray) or isinstance(item, list) or (isinstance(item, tuple) and all((isinstance(x, np.ndarray) for x in item))):\n        return self._new_from_slice(item)\n    else:\n        raise ValueError(f'Illegal type {type(item)} for table item access')",
    ".astropy.table.table.py@@TableColumns.__getitem__": "def __getitem__(self, item):\n    if isinstance(item, str):\n        return OrderedDict.__getitem__(self, item)\n    elif isinstance(item, (int, np.integer)):\n        return list(self.values())[item]\n    elif isinstance(item, np.ndarray) and item.shape == () and (item.dtype.kind == 'i'):\n        return list(self.values())[item.item()]\n    elif isinstance(item, tuple):\n        return self.__class__([self[x] for x in item])\n    elif isinstance(item, slice):\n        return self.__class__([self[x] for x in list(self)[item]])\n    else:\n        raise IndexError('Illegal key or index value for {} object'.format(self.__class__.__name__))",
    ".astropy.table.table.py@@Table._set_column_attribute": "def _set_column_attribute(self, attr, values):\n    if not values:\n        return\n    if isinstance(values, Row):\n        values = {name: values[name] for name in values.colnames}\n    if not isinstance(values, Mapping):\n        if len(values) != len(self.columns):\n            raise ValueError(f'sequence of {attr} values must match number of columns')\n        values = dict(zip(self.colnames, values))\n    for name, value in values.items():\n        if name not in self.columns:\n            raise ValueError(f'invalid column name {name} for setting {attr} attribute')\n        if attr == 'unit' and isinstance(value, str):\n            if value.strip() == '':\n                value = None\n        if value not in (np.ma.masked, None):\n            setattr(self[name].info, attr, value)",
    ".astropy.io.fits.hdu.base.py@@_BaseHDU.header": "def header(self):\n    return self._header",
    ".astropy.io.fits.header.py@@Header.cards": "def cards(self):\n    return _CardAccessor(self)",
    ".astropy.io.fits.header.py@@_CardAccessor.__init__": "def __init__(self, header):\n    self._header = header",
    ".astropy.io.fits.header.py@@_CardAccessor.__iter__": "def __iter__(self):\n    return iter(self._header._cards)",
    ".astropy.io.fits.card.py@@Card.__getitem__": "def __getitem__(self, index):\n    return (self.keyword, self.value, self.comment)[index]",
    ".astropy.io.fits.card.py@@Card._parse_comment": "def _parse_comment(self):\n    if self.keyword in Card._commentary_keywords or self._invalid:\n        return ''\n    valuecomment = self._split()[1]\n    m = self._value_NFSC_RE.match(valuecomment)\n    comment = ''\n    if m is not None:\n        if m.group('comm'):\n            comment = m.group('comm').rstrip()\n    elif '/' in valuecomment:\n        comment = valuecomment.split('/', 1)[1].strip()\n    return comment",
    ".astropy.io.fits.connect.py@@is_column_keyword": "def is_column_keyword(keyword):\n    return re.match(COLUMN_KEYWORD_REGEXP, keyword) is not None",
    ".astropy.io.fits.connect.py@@_decode_mixins": "def _decode_mixins(tbl):\n    try:\n        i0 = tbl.meta['comments'].index('--BEGIN-ASTROPY-SERIALIZED-COLUMNS--')\n        i1 = tbl.meta['comments'].index('--END-ASTROPY-SERIALIZED-COLUMNS--')\n    except (ValueError, KeyError):\n        return tbl\n    continuation_line = False\n    lines = []\n    for line in tbl.meta['comments'][i0 + 1:i1]:\n        if continuation_line:\n            lines[-1] = lines[-1] + line[:70]\n        else:\n            lines.append(line[:70])\n        continuation_line = len(line) == 71\n    del tbl.meta['comments'][i0:i1 + 1]\n    if not tbl.meta['comments']:\n        del tbl.meta['comments']\n    info = meta.get_header_from_yaml(lines)\n    tbl.meta['__serialized_columns__'] = info['meta']['__serialized_columns__']\n    for col in info['datatype']:\n        for attr in ['description', 'meta']:\n            if attr in col:\n                setattr(tbl[col['name']].info, attr, col[attr])\n    tbl = serialize._construct_mixins_from_columns(tbl)\n    return tbl",
    ".astropy.units.core.py@@_UnitMetaClass.__call__": "def __call__(self, s='', represents=None, format=None, namespace=None, doc=None, parse_strict='raise'):\n    if hasattr(s, '_get_physical_type_id'):\n        return s\n    from .quantity import Quantity\n    if isinstance(represents, Quantity):\n        if is_effectively_unity(represents.value):\n            represents = represents.unit\n        else:\n            represents = CompositeUnit(represents.value * represents.unit.scale, bases=represents.unit.bases, powers=represents.unit.powers, _error_check=False)\n    if isinstance(s, Quantity):\n        if is_effectively_unity(s.value):\n            s = s.unit\n        else:\n            s = CompositeUnit(s.value * s.unit.scale, bases=s.unit.bases, powers=s.unit.powers, _error_check=False)\n    if isinstance(represents, UnitBase):\n        return super().__call__(s, represents, format=format, namespace=namespace, doc=doc)\n    if isinstance(s, UnitBase):\n        return s\n    elif isinstance(s, (bytes, str)):\n        if len(s.strip()) == 0:\n            return dimensionless_unscaled\n        if format is None:\n            format = unit_format.Generic\n        f = unit_format.get_format(format)\n        if isinstance(s, bytes):\n            s = s.decode('ascii')\n        try:\n            return f.parse(s)\n        except NotImplementedError:\n            raise\n        except Exception as e:\n            if parse_strict == 'silent':\n                pass\n            else:\n                if f is not unit_format.Generic:\n                    format_clause = f.name + ' '\n                else:\n                    format_clause = ''\n                msg = \"'{}' did not parse as {}unit: {} If this is meant to be a custom unit, define it with 'u.def_unit'. To have it recognized inside a file reader or other code, enable it with 'u.add_enabled_units'. For details, see https://docs.astropy.org/en/latest/units/combining_and_defining.html\".format(s, format_clause, str(e))\n                if parse_strict == 'raise':\n                    raise ValueError(msg)\n                elif parse_strict == 'warn':\n                    warnings.warn(msg, UnitsWarning)\n                else:\n                    raise ValueError(\"'parse_strict' must be 'warn', 'raise' or 'silent'\")\n            return UnrecognizedUnit(s)\n    elif isinstance(s, (int, float, np.floating, np.integer)):\n        return CompositeUnit(s, [], [], _error_check=False)\n    elif isinstance(s, tuple):\n        from .structured import StructuredUnit\n        return StructuredUnit(s)\n    elif s is None:\n        raise TypeError('None is not a valid Unit')\n    else:\n        raise TypeError(f'{s} can not be converted to a Unit')",
    ".astropy.units.format.__init__.py@@get_format": "def get_format(format=None):\n    if format is None:\n        return Generic\n    if isinstance(format, type) and issubclass(format, Base):\n        return format\n    elif not (isinstance(format, str) or format is None):\n        raise TypeError(f'Formatter must a subclass or instance of a subclass of {Base!r} or a string giving the name of the formatter. {_known_formats()}.')\n    format_lower = format.lower()\n    if format_lower in Base.registry:\n        return Base.registry[format_lower]\n    raise ValueError(f'Unknown format {format!r}.  {_known_formats()}')",
    ".astropy.units.format.fits.py@@Fits.parse": "def parse(cls, s, debug=False):\n    result = super().parse(s, debug)\n    if hasattr(result, 'function_unit'):\n        raise ValueError('Function units are not yet supported for FITS units.')\n    return result",
    ".astropy.units.format.generic.py@@Generic.parse": "def parse(cls, s, debug=False):\n    if not isinstance(s, str):\n        s = s.decode('ascii')\n    elif not s.isascii():\n        s = unicodedata.normalize('NFC', s)\n        s = s.translate(cls._translations)\n        s = cls._regex_superscript.sub(cls._convert_superscript, s)\n        s = cls._regex_deg.sub(cls._convert_deg, s)\n    result = cls._do_parse(s, debug=debug)\n    n_slashes = s.count('/')\n    if n_slashes > 1 and n_slashes - len(re.findall('\\\\(\\\\d+/\\\\d+\\\\)', s)) > 1:\n        warnings.warn(\"'{}' contains multiple slashes, which is discouraged by the FITS standard\".format(s), core.UnitsWarning)\n    return result",
    ".astropy.units.format.generic.py@@Generic._do_parse": "def _do_parse(cls, s, debug=False):\n    try:\n        return cls._parse_unit(s, detailed_exception=False)\n    except ValueError as e:\n        try:\n            return cls._parser.parse(s, lexer=cls._lexer, debug=debug)\n        except ValueError as e:\n            if str(e):\n                raise\n            else:\n                raise ValueError(f\"Syntax error parsing unit '{s}'\")",
    ".astropy.units.format.fits.py@@Fits._parse_unit": "def _parse_unit(cls, unit, detailed_exception=True):\n    cls._validate_unit(unit)\n    return cls._units[unit]",
    ".astropy.units.format.fits.py@@Fits._validate_unit": "def _validate_unit(cls, unit, detailed_exception=True):\n    if unit not in cls._units:\n        if detailed_exception:\n            raise ValueError(\"Unit '{}' not supported by the FITS standard. {}\".format(unit, utils.did_you_mean_units(unit, cls._units, cls._deprecated_units, cls._to_decomposed_alternative)))\n        else:\n            raise ValueError()\n    if unit in cls._deprecated_units:\n        utils.unit_deprecation_warning(unit, cls._units[unit], 'FITS', cls._to_decomposed_alternative)",
    ".astropy.utils.decorators.py@@classproperty.__get__": "def __get__(self, obj, objtype):\n    if self._lazy:\n        val = self._cache.get(objtype, _NotFound)\n        if val is _NotFound:\n            with self._lock:\n                val = self._cache.get(objtype, _NotFound)\n                if val is _NotFound:\n                    val = self.fget.__wrapped__(objtype)\n                    self._cache[objtype] = val\n    else:\n        val = self.fget.__wrapped__(objtype)\n    return val",
    ".astropy.units.format.utils.py@@did_you_mean_units": "def did_you_mean_units(s, all_units, deprecated_units, format_decomposed):\n\n    def fix_deprecated(x):\n        if x in deprecated_units:\n            results = [x + ' (deprecated)']\n            decomposed = _try_decomposed(all_units[x], format_decomposed)\n            if decomposed is not None:\n                results.append(decomposed)\n            return results\n        return (x,)\n    return did_you_mean(s, all_units, fix=fix_deprecated)",
    ".astropy.utils.misc.py@@did_you_mean": "def did_you_mean(s, candidates, n=3, cutoff=0.8, fix=None):\n    if isinstance(s, str):\n        s = strip_accents(s)\n    s_lower = s.lower()\n    candidates_lower = {}\n    for candidate in candidates:\n        candidate_lower = candidate.lower()\n        candidates_lower.setdefault(candidate_lower, [])\n        candidates_lower[candidate_lower].append(candidate)\n    if s_lower.endswith('s') and s_lower[:-1] in candidates_lower:\n        matches = [s_lower[:-1]]\n    else:\n        matches = difflib.get_close_matches(s_lower, candidates_lower, n=n, cutoff=cutoff)\n    if len(matches):\n        capitalized_matches = set()\n        for match in matches:\n            capitalized_matches.update(candidates_lower[match])\n        matches = capitalized_matches\n        if fix is not None:\n            mapped_matches = []\n            for match in matches:\n                mapped_matches.extend(fix(match))\n            matches = mapped_matches\n        matches = list(set(matches))\n        matches = sorted(matches)\n        if len(matches) == 1:\n            matches = matches[0]\n        else:\n            matches = ', '.join(matches[:-1]) + ' or ' + matches[-1]\n        return f'Did you mean {matches}?'\n    return ''",
    ".astropy.utils.misc.py@@strip_accents": "def strip_accents(s):\n    return ''.join((c for c in unicodedata.normalize('NFD', s) if unicodedata.category(c) != 'Mn'))",
    ".astropy.utils.parsing.py@@ThreadSafeParser.parse": "def parse(self, *args, **kwargs):\n    with self._lock:\n        return self.parser.parse(*args, **kwargs)",
    ".astropy.extern.ply.yacc.py@@LRParser.parse": "def parse(self, input=None, lexer=None, debug=False, tracking=False, tokenfunc=None):\n    if debug or yaccdevel:\n        if isinstance(debug, int):\n            debug = PlyLogger(sys.stderr)\n        return self.parsedebug(input, lexer, debug, tracking, tokenfunc)\n    elif tracking:\n        return self.parseopt(input, lexer, debug, tracking, tokenfunc)\n    else:\n        return self.parseopt_notrack(input, lexer, debug, tracking, tokenfunc)",
    ".astropy.extern.ply.yacc.py@@LRParser.parseopt_notrack": "def parseopt_notrack(self, input=None, lexer=None, debug=False, tracking=False, tokenfunc=None):\n    lookahead = None\n    lookaheadstack = []\n    actions = self.action\n    goto = self.goto\n    prod = self.productions\n    defaulted_states = self.defaulted_states\n    pslice = YaccProduction(None)\n    errorcount = 0\n    if not lexer:\n        from . import lex\n        lexer = lex.lexer\n    pslice.lexer = lexer\n    pslice.parser = self\n    if input is not None:\n        lexer.input(input)\n    if tokenfunc is None:\n        get_token = lexer.token\n    else:\n        get_token = tokenfunc\n    self.token = get_token\n    statestack = []\n    self.statestack = statestack\n    symstack = []\n    self.symstack = symstack\n    pslice.stack = symstack\n    errtoken = None\n    statestack.append(0)\n    sym = YaccSymbol()\n    sym.type = '$end'\n    symstack.append(sym)\n    state = 0\n    while True:\n        if state not in defaulted_states:\n            if not lookahead:\n                if not lookaheadstack:\n                    lookahead = get_token()\n                else:\n                    lookahead = lookaheadstack.pop()\n                if not lookahead:\n                    lookahead = YaccSymbol()\n                    lookahead.type = '$end'\n            ltype = lookahead.type\n            t = actions[state].get(ltype)\n        else:\n            t = defaulted_states[state]\n        if t is not None:\n            if t > 0:\n                statestack.append(t)\n                state = t\n                symstack.append(lookahead)\n                lookahead = None\n                if errorcount:\n                    errorcount -= 1\n                continue\n            if t < 0:\n                p = prod[-t]\n                pname = p.name\n                plen = p.len\n                sym = YaccSymbol()\n                sym.type = pname\n                sym.value = None\n                if plen:\n                    targ = symstack[-plen - 1:]\n                    targ[0] = sym\n                    pslice.slice = targ\n                    try:\n                        del symstack[-plen:]\n                        self.state = state\n                        p.callable(pslice)\n                        del statestack[-plen:]\n                        symstack.append(sym)\n                        state = goto[statestack[-1]][pname]\n                        statestack.append(state)\n                    except SyntaxError:\n                        lookaheadstack.append(lookahead)\n                        symstack.extend(targ[1:-1])\n                        statestack.pop()\n                        state = statestack[-1]\n                        sym.type = 'error'\n                        sym.value = 'error'\n                        lookahead = sym\n                        errorcount = error_count\n                        self.errorok = False\n                    continue\n                else:\n                    targ = [sym]\n                    pslice.slice = targ\n                    try:\n                        self.state = state\n                        p.callable(pslice)\n                        symstack.append(sym)\n                        state = goto[statestack[-1]][pname]\n                        statestack.append(state)\n                    except SyntaxError:\n                        lookaheadstack.append(lookahead)\n                        statestack.pop()\n                        state = statestack[-1]\n                        sym.type = 'error'\n                        sym.value = 'error'\n                        lookahead = sym\n                        errorcount = error_count\n                        self.errorok = False\n                    continue\n            if t == 0:\n                n = symstack[-1]\n                result = getattr(n, 'value', None)\n                return result\n        if t is None:\n            if errorcount == 0 or self.errorok:\n                errorcount = error_count\n                self.errorok = False\n                errtoken = lookahead\n                if errtoken.type == '$end':\n                    errtoken = None\n                if self.errorfunc:\n                    if errtoken and (not hasattr(errtoken, 'lexer')):\n                        errtoken.lexer = lexer\n                    self.state = state\n                    tok = call_errorfunc(self.errorfunc, errtoken, self)\n                    if self.errorok:\n                        lookahead = tok\n                        errtoken = None\n                        continue\n                elif errtoken:\n                    if hasattr(errtoken, 'lineno'):\n                        lineno = lookahead.lineno\n                    else:\n                        lineno = 0\n                    if lineno:\n                        sys.stderr.write('yacc: Syntax error at line %d, token=%s\\n' % (lineno, errtoken.type))\n                    else:\n                        sys.stderr.write('yacc: Syntax error, token=%s' % errtoken.type)\n                else:\n                    sys.stderr.write('yacc: Parse error in input. EOF\\n')\n                    return\n            else:\n                errorcount = error_count\n            if len(statestack) <= 1 and lookahead.type != '$end':\n                lookahead = None\n                errtoken = None\n                state = 0\n                del lookaheadstack[:]\n                continue\n            if lookahead.type == '$end':\n                return\n            if lookahead.type != 'error':\n                sym = symstack[-1]\n                if sym.type == 'error':\n                    lookahead = None\n                    continue\n                t = YaccSymbol()\n                t.type = 'error'\n                if hasattr(lookahead, 'lineno'):\n                    t.lineno = t.endlineno = lookahead.lineno\n                if hasattr(lookahead, 'lexpos'):\n                    t.lexpos = t.endlexpos = lookahead.lexpos\n                t.value = lookahead\n                lookaheadstack.append(lookahead)\n                lookahead = t\n            else:\n                sym = symstack.pop()\n                statestack.pop()\n                state = statestack[-1]\n            continue\n        raise RuntimeError('yacc: internal parser error!!!\\n')",
    ".astropy.extern.ply.yacc.py@@YaccProduction.__init__": "def __init__(self, s, stack=None):\n    self.slice = s\n    self.stack = stack\n    self.lexer = None\n    self.parser = None",
    ".astropy.extern.ply.lex.py@@Lexer.input": "def input(self, s):\n    c = s[:1]\n    if not isinstance(c, StringTypes):\n        raise ValueError('Expected a string')\n    self.lexdata = s\n    self.lexpos = 0\n    self.lexlen = len(s)",
    ".astropy.extern.ply.lex.py@@Lexer.token": "def token(self):\n    lexpos = self.lexpos\n    lexlen = self.lexlen\n    lexignore = self.lexignore\n    lexdata = self.lexdata\n    while lexpos < lexlen:\n        if lexdata[lexpos] in lexignore:\n            lexpos += 1\n            continue\n        for lexre, lexindexfunc in self.lexre:\n            m = lexre.match(lexdata, lexpos)\n            if not m:\n                continue\n            tok = LexToken()\n            tok.value = m.group()\n            tok.lineno = self.lineno\n            tok.lexpos = lexpos\n            i = m.lastindex\n            func, tok.type = lexindexfunc[i]\n            if not func:\n                if tok.type:\n                    self.lexpos = m.end()\n                    return tok\n                else:\n                    lexpos = m.end()\n                    break\n            lexpos = m.end()\n            tok.lexer = self\n            self.lexmatch = m\n            self.lexpos = lexpos\n            newtok = func(tok)\n            if not newtok:\n                lexpos = self.lexpos\n                lexignore = self.lexignore\n                break\n            if not self.lexoptimize:\n                if newtok.type not in self.lextokens_all:\n                    raise LexError(\"%s:%d: Rule '%s' returned an unknown token type '%s'\" % (func.__code__.co_filename, func.__code__.co_firstlineno, func.__name__, newtok.type), lexdata[lexpos:])\n            return newtok\n        else:\n            if lexdata[lexpos] in self.lexliterals:\n                tok = LexToken()\n                tok.value = lexdata[lexpos]\n                tok.lineno = self.lineno\n                tok.type = tok.value\n                tok.lexpos = lexpos\n                self.lexpos = lexpos + 1\n                return tok\n            if self.lexerrorf:\n                tok = LexToken()\n                tok.value = self.lexdata[lexpos:]\n                tok.lineno = self.lineno\n                tok.type = 'error'\n                tok.lexer = self\n                tok.lexpos = lexpos\n                self.lexpos = lexpos\n                newtok = self.lexerrorf(tok)\n                if lexpos == self.lexpos:\n                    raise LexError(\"Scanning error. Illegal character '%s'\" % lexdata[lexpos], lexdata[lexpos:])\n                lexpos = self.lexpos\n                if not newtok:\n                    continue\n                return newtok\n            self.lexpos = lexpos\n            raise LexError(\"Illegal character '%s' at index %d\" % (lexdata[lexpos], lexpos), lexdata[lexpos:])\n    if self.lexeoff:\n        tok = LexToken()\n        tok.type = 'eof'\n        tok.value = ''\n        tok.lineno = self.lineno\n        tok.lexpos = lexpos\n        tok.lexer = self\n        self.lexpos = lexpos\n        newtok = self.lexeoff(tok)\n        return newtok\n    self.lexpos = lexpos + 1\n    if self.lexdata is None:\n        raise RuntimeError('No input string given with input()')\n    return None",
    ".astropy.units.format.generic.py@@Generic.t_UNIT": "def t_UNIT(t):\n    t.value = cls._get_unit(t)\n    return t",
    ".astropy.units.format.generic.py@@Generic._get_unit": "def _get_unit(cls, t):\n    try:\n        return cls._parse_unit(t.value)\n    except ValueError as e:\n        registry = core.get_current_unit_registry()\n        if t.value in registry.aliases:\n            return registry.aliases[t.value]\n        raise ValueError(f'At col {t.lexpos}, {str(e)}')",
    ".astropy.units.format.generic.py@@Generic.p_unit_with_power": "def p_unit_with_power(p):\n    if len(p) == 2:\n        p[0] = p[1]\n    elif len(p) == 3:\n        p[0] = p[1] ** p[2]\n    else:\n        p[0] = p[1] ** p[3]",
    ".astropy.extern.ply.yacc.py@@YaccProduction.__len__": "def __len__(self):\n    return len(self.slice)",
    ".astropy.extern.ply.yacc.py@@YaccProduction.__getitem__": "def __getitem__(self, n):\n    if isinstance(n, slice):\n        return [s.value for s in self.slice[n]]\n    elif n >= 0:\n        return self.slice[n].value\n    else:\n        return self.stack[n].value",
    ".astropy.extern.ply.yacc.py@@YaccProduction.__setitem__": "def __setitem__(self, n, v):\n    self.slice[n].value = v",
    ".astropy.units.format.generic.py@@Generic.p_unit_expression": "def p_unit_expression(p):\n    if len(p) == 2:\n        p[0] = p[1]\n    else:\n        p[0] = p[2]",
    ".astropy.units.format.generic.py@@Generic.t_SIGN": "def t_SIGN(t):\n    t.value = int(t.value + '1')\n    return t",
    ".astropy.units.format.generic.py@@Generic.t_UFLOAT": "def t_UFLOAT(t):\n    if not re.search('[eE\\\\.]', t.value):\n        t.type = 'UINT'\n        t.value = int(t.value)\n    elif t.value.endswith('.'):\n        t.type = 'UINT'\n        t.value = int(t.value[:-1])\n    else:\n        t.value = float(t.value)\n    return t",
    ".astropy.units.format.generic.py@@Generic.p_sign": "def p_sign(p):\n    if len(p) == 2:\n        p[0] = p[1]\n    else:\n        p[0] = 1",
    ".astropy.units.format.generic.py@@Generic.p_numeric_power": "def p_numeric_power(p):\n    if len(p) == 3:\n        p[0] = p[1] * p[2]\n    elif len(p) == 4:\n        p[0] = p[2]",
    ".astropy.units.core.py@@UnitBase.__pow__": "def __pow__(self, p):\n    p = validate_power(p)\n    return CompositeUnit(1, [self], [p], _error_check=False)",
    ".astropy.units.utils.py@@validate_power": "def validate_power(p):\n    denom = getattr(p, 'denominator', None)\n    if denom is None:\n        try:\n            p = float(p)\n        except Exception:\n            if not np.isscalar(p):\n                raise ValueError('Quantities and Units may only be raised to a scalar power')\n            else:\n                raise\n        p = maybe_simple_fraction(p)\n        if isinstance(p, float):\n            return p\n        denom = p.denominator\n    if denom == 1:\n        p = p.numerator\n    elif denom & denom - 1 == 0:\n        p = float(p)\n    return p",
    ".astropy.units.core.py@@CompositeUnit.__init__": "def __init__(self, scale, bases, powers, decompose=False, decompose_bases=set(), _error_check=True):\n    if _error_check:\n        for base in bases:\n            if not isinstance(base, UnitBase):\n                raise TypeError('bases must be sequence of UnitBase instances')\n        powers = [validate_power(p) for p in powers]\n    if not decompose and len(bases) == 1 and (powers[0] >= 0):\n        unit = bases[0]\n        power = powers[0]\n        if power == 1:\n            scale *= unit.scale\n            self._bases = unit.bases\n            self._powers = unit.powers\n        elif power == 0:\n            self._bases = []\n            self._powers = []\n        else:\n            scale *= unit.scale ** power\n            self._bases = unit.bases\n            self._powers = [operator.mul(*resolve_fractions(p, power)) for p in unit.powers]\n        self._scale = sanitize_scale(scale)\n    else:\n        self._scale = scale\n        self._bases = bases\n        self._powers = powers\n        self._expand_and_gather(decompose=decompose, bases=decompose_bases)",
    ".astropy.units.core.py@@CompositeUnit._expand_and_gather": "def _expand_and_gather(self, decompose=False, bases=set()):\n\n    def add_unit(unit, power, scale):\n        if bases and unit not in bases:\n            for base in bases:\n                try:\n                    scale *= unit._to(base) ** power\n                except UnitsError:\n                    pass\n                else:\n                    unit = base\n                    break\n        if unit in new_parts:\n            a, b = resolve_fractions(new_parts[unit], power)\n            new_parts[unit] = a + b\n        else:\n            new_parts[unit] = power\n        return scale\n    new_parts = {}\n    scale = self._scale\n    for b, p in zip(self._bases, self._powers):\n        if decompose and b not in bases:\n            b = b.decompose(bases=bases)\n        if isinstance(b, CompositeUnit):\n            scale *= b._scale ** p\n            for b_sub, p_sub in zip(b._bases, b._powers):\n                a, b = resolve_fractions(p_sub, p)\n                scale = add_unit(b_sub, a * b, scale)\n        else:\n            scale = add_unit(b, p, scale)\n    new_parts = [x for x in new_parts.items() if x[1] != 0]\n    new_parts.sort(key=lambda x: (-x[1], getattr(x[0], 'name', '')))\n    self._bases = [x[0] for x in new_parts]\n    self._powers = [x[1] for x in new_parts]\n    self._scale = sanitize_scale(scale)",
    ".astropy.units.core.py@@CompositeUnit.add_unit": "def add_unit(unit, power, scale):\n    if bases and unit not in bases:\n        for base in bases:\n            try:\n                scale *= unit._to(base) ** power\n            except UnitsError:\n                pass\n            else:\n                unit = base\n                break\n    if unit in new_parts:\n        a, b = resolve_fractions(new_parts[unit], power)\n        new_parts[unit] = a + b\n    else:\n        new_parts[unit] = power\n    return scale",
    ".astropy.units.core.py@@UnitBase.__hash__": "def __hash__(self):\n    if self._hash is None:\n        parts = [str(self.scale)] + [x.name for x in self.bases] + [str(x) for x in self.powers]\n        self._hash = hash(tuple(parts))\n    return self._hash",
    ".astropy.units.core.py@@NamedUnit.name": "def name(self):\n    return self._names[0]",
    ".astropy.units.utils.py@@sanitize_scale": "def sanitize_scale(scale):\n    if is_effectively_unity(scale):\n        return 1.0\n    if scale.__class__ is float:\n        return scale\n    if hasattr(scale, 'dtype'):\n        scale = scale.item()\n    if scale.imag:\n        if abs(scale.real) > abs(scale.imag):\n            if is_effectively_unity(scale.imag / scale.real + 1):\n                return scale.real\n        elif is_effectively_unity(scale.real / scale.imag + 1):\n            return complex(0.0, scale.imag)\n        return scale\n    else:\n        return scale.real",
    ".astropy.units.utils.py@@is_effectively_unity": "def is_effectively_unity(value):\n    try:\n        return _JUST_BELOW_UNITY <= value <= _JUST_ABOVE_UNITY\n    except TypeError:\n        return _JUST_BELOW_UNITY <= value.real <= _JUST_ABOVE_UNITY and _JUST_BELOW_UNITY <= value.imag + 1 <= _JUST_ABOVE_UNITY",
    ".astropy.units.format.generic.py@@Generic.p_product_of_units": "def p_product_of_units(p):\n    if len(p) == 2:\n        p[0] = p[1]\n    elif len(p) == 3:\n        p[0] = p[1] * p[2]\n    else:\n        p[0] = p[1] * p[3]",
    ".astropy.units.core.py@@UnitBase.__mul__": "def __mul__(self, m):\n    if isinstance(m, (bytes, str)):\n        m = Unit(m)\n    if isinstance(m, UnitBase):\n        if m.is_unity():\n            return self\n        elif self.is_unity():\n            return m\n        return CompositeUnit(1, [self, m], [1, 1], _error_check=False)\n    try:\n        from .quantity import Quantity\n        return Quantity(1, self) * m\n    except TypeError:\n        return NotImplemented",
    ".astropy.units.core.py@@CompositeUnit.is_unity": "def is_unity(self):\n    unit = self.decompose()\n    return len(unit.bases) == 0 and unit.scale == 1.0",
    ".astropy.units.core.py@@CompositeUnit.decompose": "def decompose(self, bases=set()):\n    if len(bases) == 0 and self._decomposed_cache is not None:\n        return self._decomposed_cache\n    for base in self.bases:\n        if not isinstance(base, IrreducibleUnit) or (len(bases) and base not in bases):\n            break\n    else:\n        if len(bases) == 0:\n            self._decomposed_cache = self\n        return self\n    x = CompositeUnit(self.scale, self.bases, self.powers, decompose=True, decompose_bases=bases)\n    if len(bases) == 0:\n        self._decomposed_cache = x\n    return x",
    ".astropy.units.core.py@@CompositeUnit.bases": "def bases(self):\n    return self._bases",
    ".astropy.units.core.py@@Unit.is_unity": "def is_unity(self):\n    return self._represents.is_unity()",
    ".astropy.units.core.py@@Unit.__hash__": "def __hash__(self):\n    if self._hash is None:\n        self._hash = hash((self.name, self._represents))\n    return self._hash",
    ".astropy.units.utils.py@@resolve_fractions": "def resolve_fractions(a, b):\n    a_is_fraction = a.__class__ is not int and a.__class__ is not float and isinstance(a, Fraction)\n    b_is_fraction = b.__class__ is not int and b.__class__ is not float and isinstance(b, Fraction)\n    if a_is_fraction and (not b_is_fraction):\n        b = maybe_simple_fraction(b)\n    elif not a_is_fraction and b_is_fraction:\n        a = maybe_simple_fraction(a)\n    return (a, b)",
    ".astropy.units.format.generic.py@@Generic.p_unit": "def p_unit(p):\n    from astropy.units.core import Unit\n    if len(p) == 2:\n        p[0] = Unit(p[1])\n    elif len(p) == 3:\n        p[0] = Unit(p[1] * p[2])\n    elif len(p) == 4:\n        p[0] = Unit(p[1] * p[3])",
    ".astropy.units.format.generic.py@@Generic.p_main": "def p_main(p):\n    if isinstance(p[1], tuple):\n        p[0] = p[1][0]\n    else:\n        p[0] = p[1]",
    ".astropy.table.meta.py@@get_header_from_yaml": "def get_header_from_yaml(lines):\n    from astropy.io.misc.yaml import AstropyLoader\n\n    class TableLoader(AstropyLoader):\n    TableLoader.add_constructor('tag:yaml.org,2002:omap', _construct_odict)\n    header_yaml = textwrap.dedent('\\n'.join(lines))\n    try:\n        header = yaml.load(header_yaml, Loader=TableLoader)\n    except Exception as err:\n        raise YamlParseError() from err\n    return header",
    ".astropy.io.misc.yaml.py@@_unit_constructor": "def _unit_constructor(loader, node):\n    map = loader.construct_mapping(node)\n    return u.Unit(map['unit'], parse_strict='warn')",
    ".astropy.units.format.generic.py@@Generic._parse_unit": "def _parse_unit(cls, s, detailed_exception=True):\n    registry = core.get_current_unit_registry().registry\n    if s in cls._unit_symbols:\n        s = cls._unit_symbols[s]\n    elif not s.isascii():\n        if s[0] == '\u00b5':\n            s = 'u' + s[1:]\n        if s[-1] in cls._prefixable_unit_symbols:\n            s = s[:-1] + cls._prefixable_unit_symbols[s[-1]]\n        elif len(s) > 1 and s[-1] in cls._unit_suffix_symbols:\n            s = s[:-1] + cls._unit_suffix_symbols[s[-1]]\n        elif s.endswith('R\u221e'):\n            s = s[:-2] + 'Ry'\n    if s in registry:\n        return registry[s]\n    if detailed_exception:\n        raise ValueError(f'{s} is not a valid unit. {did_you_mean(s, registry)}')\n    else:\n        raise ValueError()",
    ".astropy.units.core.py@@get_current_unit_registry": "def get_current_unit_registry():\n    return _unit_registries[-1]",
    ".astropy.units.core.py@@_UnitRegistry.registry": "def registry(self):\n    return self._registry",
    ".astropy.io.misc.yaml.py@@_serialized_column_constructor": "def _serialized_column_constructor(loader, node):\n    map = loader.construct_mapping(node)\n    return SerializedColumn(map)",
    ".astropy.units.format.generic.py@@Generic.p_division_product_of_units": "def p_division_product_of_units(p):\n    from astropy.units.core import Unit\n    if len(p) == 4:\n        p[0] = Unit(p[1] / p[3])\n    else:\n        p[0] = p[1]",
    ".astropy.units.format.generic.py@@Generic.p_division": "def p_division(p):\n    pass",
    ".astropy.units.core.py@@UnitBase.__truediv__": "def __truediv__(self, m):\n    if isinstance(m, (bytes, str)):\n        m = Unit(m)\n    if isinstance(m, UnitBase):\n        if m.is_unity():\n            return self\n        return CompositeUnit(1, [self, m], [1, -1], _error_check=False)\n    try:\n        from .quantity import Quantity\n        return Quantity(1, self) / m\n    except TypeError:\n        return NotImplemented",
    ".astropy.units.core.py@@UnitBase.is_unity": "def is_unity(self):\n    return False",
    ".astropy.table.serialize.py@@_construct_mixins_from_columns": "def _construct_mixins_from_columns(tbl):\n    if '__serialized_columns__' not in tbl.meta:\n        return tbl\n    meta = tbl.meta.copy()\n    mixin_cols = meta.pop('__serialized_columns__')\n    out = _TableLite(tbl.columns)\n    for new_name, obj_attrs in mixin_cols.items():\n        _construct_mixin_from_columns(new_name, obj_attrs, out)\n    has_quantities = any((isinstance(col.info, QuantityInfo) for col in out.itercols()))\n    out_cls = QTable if has_quantities else Table\n    return out_cls(list(out.values()), names=out.colnames, copy=False, meta=meta)",
    ".astropy.table.serialize.py@@_construct_mixin_from_columns": "def _construct_mixin_from_columns(new_name, obj_attrs, out):\n    data_attrs_map = {}\n    for name, val in obj_attrs.items():\n        if isinstance(val, SerializedColumn):\n            if 'name' in val:\n                data_attrs_map[val['name']] = name\n            else:\n                out_name = f'{new_name}.{name}'\n                _construct_mixin_from_columns(out_name, val, out)\n                data_attrs_map[out_name] = name\n    for name in data_attrs_map.values():\n        del obj_attrs[name]\n    idx = min((out.colnames.index(name) for name in data_attrs_map))\n    for name, data_attr in data_attrs_map.items():\n        obj_attrs[data_attr] = out[name]\n        del out[name]\n    info = obj_attrs.pop('__info__', {})\n    if len(data_attrs_map) == 1:\n        data_attr = next(iter(data_attrs_map.values()))\n        col = obj_attrs[data_attr]\n        for attr, nontrivial in (('unit', lambda x: x not in (None, '')), ('format', lambda x: x is not None), ('description', lambda x: x is not None), ('meta', lambda x: x)):\n            col_attr = getattr(col.info, attr)\n            if nontrivial(col_attr):\n                info[attr] = col_attr\n    info['name'] = new_name\n    col = _construct_mixin_from_obj_attrs_and_info(obj_attrs, info)\n    out.add_column(col, index=idx)",
    ".astropy.table.serialize.py@@_TableLite.colnames": "def colnames(self):\n    return list(self.keys())",
    ".astropy.units.core.py@@UnitBase.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    try:\n        other = Unit(other, parse_strict='silent')\n    except (ValueError, UnitsError, TypeError):\n        return NotImplemented\n    if not isinstance(other, UnitBase):\n        return NotImplemented\n    try:\n        return is_effectively_unity(self._to(other))\n    except UnitsError:\n        return False",
    ".astropy.units.core.py@@UnitBase._to": "def _to(self, other):\n    if self is other:\n        return 1.0\n    if isinstance(other, UnitBase):\n        self_decomposed = self.decompose()\n        other_decomposed = other.decompose()\n        if self_decomposed.powers == other_decomposed.powers and all((self_base is other_base for self_base, other_base in zip(self_decomposed.bases, other_decomposed.bases))):\n            return self_decomposed.scale / other_decomposed.scale\n    raise UnitConversionError(f\"'{self!r}' is not a scaled version of '{other!r}'\")",
    ".astropy.units.core.py@@IrreducibleUnit.decompose": "def decompose(self, bases=set()):\n    if len(bases) and self not in bases:\n        for base in bases:\n            try:\n                scale = self._to(base)\n            except UnitsError:\n                pass\n            else:\n                if is_effectively_unity(scale):\n                    return base\n                else:\n                    return CompositeUnit(scale, [base], [1], _error_check=False)\n        raise UnitConversionError(f'Unit {self} can not be decomposed into the requested bases')\n    return self",
    ".astropy.units.core.py@@UnitBase.powers": "def powers(self):\n    return [1]",
    ".astropy.units.core.py@@CompositeUnit.powers": "def powers(self):\n    return self._powers",
    ".astropy.units.core.py@@UnitBase.__repr__": "def __repr__(self):\n    string = unit_format.Generic.to_string(self)\n    return f'Unit(\"{string}\")'",
    ".astropy.units.format.generic.py@@Generic.to_string": "def to_string(cls, unit):\n    return _to_string(cls, unit)",
    ".astropy.units.format.generic.py@@_to_string": "def _to_string(cls, unit):\n    if isinstance(unit, core.CompositeUnit):\n        parts = []\n        if cls._show_scale and unit.scale != 1:\n            parts.append(f'{unit.scale:g}')\n        if len(unit.bases):\n            positives, negatives = utils.get_grouped_by_powers(unit.bases, unit.powers)\n            if len(positives):\n                parts.append(cls._format_unit_list(positives))\n            elif len(parts) == 0:\n                parts.append('1')\n            if len(negatives):\n                parts.append('/')\n                unit_list = cls._format_unit_list(negatives)\n                if len(negatives) == 1:\n                    parts.append(f'{unit_list}')\n                else:\n                    parts.append(f'({unit_list})')\n        return ' '.join(parts)\n    elif isinstance(unit, core.NamedUnit):\n        return cls._get_unit_name(unit)",
    ".astropy.units.format.generic.py@@Generic._get_unit_name": "def _get_unit_name(cls, unit):\n    return unit.get_format_name('generic')",
    ".astropy.units.core.py@@NamedUnit.get_format_name": "def get_format_name(self, format):\n    return self._format.get(format, self.name)",
    ".astropy.units.core.py@@CompositeUnit.__repr__": "def __repr__(self):\n    if len(self._bases):\n        return super().__repr__()\n    elif self._scale != 1.0:\n        return f'Unit(dimensionless with a scale of {self._scale})'\n    else:\n        return 'Unit(dimensionless)'",
    ".astropy.table.serialize.py@@_construct_mixin_from_obj_attrs_and_info": "def _construct_mixin_from_obj_attrs_and_info(obj_attrs, info):\n    cls_full_name = obj_attrs.pop('__class__', None)\n    if cls_full_name is None:\n        cls = SerializedColumn\n    elif cls_full_name not in __construct_mixin_classes:\n        raise ValueError(f'unsupported class for construct {cls_full_name}')\n    else:\n        mod_name, _, cls_name = cls_full_name.rpartition('.')\n        module = import_module(mod_name)\n        cls = getattr(module, cls_name)\n    for attr, value in info.items():\n        if attr in cls.info.attrs_from_parent:\n            obj_attrs[attr] = value\n    mixin = cls.info._construct_from_dict(obj_attrs)\n    for attr, value in info.items():\n        if attr not in obj_attrs:\n            setattr(mixin.info, attr, value)\n    return mixin",
    ".astropy.utils.data_info.py@@DataInfo._construct_from_dict": "def _construct_from_dict(self, map):\n    args = [map.pop(attr) for attr in self._construct_from_dict_args]\n    return self._parent_cls(*args, **map)",
    ".astropy.units.quantity.py@@Quantity.__new__": "def __new__(cls, value, unit=None, dtype=None, copy=True, order=None, subok=False, ndmin=0):\n    if unit is not None:\n        unit = Unit(unit)\n    if isinstance(value, Quantity):\n        if unit is not None and unit is not value.unit:\n            value = value.to(unit)\n            copy = False\n        if type(value) is not cls and (not (subok and isinstance(value, cls))):\n            value = value.view(cls)\n        if dtype is None and value.dtype.kind in 'iu':\n            dtype = float\n        return np.array(value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin)\n    value_unit = None\n    if not isinstance(value, np.ndarray):\n        if isinstance(value, str):\n            pattern = '\\\\s*[+-]?((\\\\d+\\\\.?\\\\d*)|(\\\\.\\\\d+)|([nN][aA][nN])|([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))([eE][+-]?\\\\d+)?[.+-]?'\n            v = re.match(pattern, value)\n            unit_string = None\n            try:\n                value = float(v.group())\n            except Exception:\n                raise TypeError('Cannot parse \"{}\" as a {}. It does not start with a number.'.format(value, cls.__name__))\n            unit_string = v.string[v.end():].strip()\n            if unit_string:\n                value_unit = Unit(unit_string)\n                if unit is None:\n                    unit = value_unit\n        elif isiterable(value) and len(value) > 0:\n            if all((isinstance(v, Quantity) for v in value)):\n                if unit is None:\n                    unit = value[0].unit\n                value = [q.to_value(unit) for q in value]\n                value_unit = unit\n            elif dtype is None and (not hasattr(value, 'dtype')) and isinstance(unit, StructuredUnit):\n                dtype = unit._recursively_get_dtype(value)\n    if value_unit is None:\n        value_unit = getattr(value, 'unit', None)\n        if value_unit is None:\n            if unit is None:\n                unit = cls._default_unit\n            value_unit = unit\n        else:\n            try:\n                value_unit = Unit(value_unit)\n            except Exception as exc:\n                raise TypeError('The unit attribute {!r} of the input could not be parsed as an astropy Unit, raising the following exception:\\n{}'.format(value.unit, exc))\n            if unit is None:\n                unit = value_unit\n            elif unit is not value_unit:\n                copy = False\n    value = np.array(value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin)\n    if value.dtype.kind in 'OSU' and (not (value.dtype.kind == 'O' and isinstance(value.item(0), numbers.Number))):\n        raise TypeError('The value must be a valid Python or Numpy numeric type.')\n    if dtype is None and value.dtype.kind in 'iuO':\n        value = value.astype(float)\n    if subok:\n        qcls = getattr(unit, '_quantity_class', cls)\n        if issubclass(qcls, cls):\n            cls = qcls\n    value = value.view(cls)\n    value._set_unit(value_unit)\n    if unit is value_unit:\n        return value\n    else:\n        return value.to(unit)",
    ".astropy.utils.data_info.py@@BaseColumnInfo.__set__": "def __set__(self, instance, value):\n    try:\n        if not instance.shape:\n            return\n    except AttributeError:\n        pass\n    super().__set__(instance, value)",
    ".astropy.utils.data_info.py@@DataInfo.__set__": "def __set__(self, instance, value):\n    if instance is None:\n        raise ValueError('cannot set unbound descriptor')\n    if isinstance(value, DataInfo):\n        info = instance.__dict__['info'] = self.__class__(bound=True)\n        attr_names = info.attr_names\n        if value.__class__ is self.__class__:\n            attr_names = attr_names & set(value._attrs)\n        else:\n            attr_names = attr_names & value.attr_names - value._attrs_no_copy\n        for attr in attr_names - info.attrs_from_parent - info._attrs_no_copy:\n            info._attrs[attr] = deepcopy(getattr(value, attr))\n    else:\n        raise TypeError('info must be set with a DataInfo instance')",
    ".astropy.units.quantity.py@@Quantity.__array_finalize__": "def __array_finalize__(self, obj):\n    super_array_finalize = super().__array_finalize__\n    if super_array_finalize is not None:\n        super_array_finalize(obj)\n    if obj is None or obj.__class__ is np.ndarray:\n        return\n    if self._unit is None:\n        unit = getattr(obj, '_unit', None)\n        if unit is not None:\n            self._set_unit(unit)\n    if 'info' in obj.__dict__:\n        self.info = obj.info",
    ".astropy.units.quantity.py@@Quantity._set_unit": "def _set_unit(self, unit):\n    if not isinstance(unit, UnitBase):\n        if isinstance(self._unit, StructuredUnit) or isinstance(unit, StructuredUnit):\n            unit = StructuredUnit(unit, self.dtype)\n        else:\n            unit = Unit(str(unit), parse_strict='silent')\n            if not isinstance(unit, (UnitBase, StructuredUnit)):\n                raise UnitTypeError('{} instances require normal units, not {} instances.'.format(type(self).__name__, type(unit)))\n    self._unit = unit",
    ".astropy.utils.data_info.py@@MixinInfo.name": "def name(self):\n    return self._attrs.get('name')",
    ".astropy.utils.data_info.py@@BaseColumnInfo.parent_table": "def parent_table(self):\n    value = self._attrs.get('parent_table')\n    if callable(value):\n        value = value()\n    return value",
    ".astropy.table.serialize.py@@_TableLite.add_column": "def add_column(self, col, index=0):\n    colnames = self.colnames\n    self[col.info.name] = col\n    for ii, name in enumerate(colnames):\n        if ii >= index:\n            self.move_to_end(name)",
    ".astropy.units.core.py@@CompositeUnit.scale": "def scale(self):\n    return self._scale",
    ".astropy.units.core.py@@Unit.decompose": "def decompose(self, bases=set()):\n    return self._represents.decompose(bases=bases)",
    ".astropy.units.format.utils.py@@get_grouped_by_powers": "def get_grouped_by_powers(bases, powers):\n    positive = []\n    negative = []\n    for base, power in zip(bases, powers):\n        if power < 0:\n            negative.append((base, -power))\n        elif power > 0:\n            positive.append((base, power))\n        else:\n            raise ValueError('Unit with 0 power')\n    return (positive, negative)",
    ".astropy.units.format.generic.py@@Generic._format_unit_list": "def _format_unit_list(cls, units):\n    out = []\n    units.sort(key=lambda x: cls._get_unit_name(x[0]).lower())\n    for base, power in units:\n        if power == 1:\n            out.append(cls._get_unit_name(base))\n        else:\n            power = utils.format_power(power)\n            if '/' in power or '.' in power:\n                out.append(f'{cls._get_unit_name(base)}({power})')\n            else:\n                out.append(f'{cls._get_unit_name(base)}{power}')\n    return ' '.join(out)",
    ".astropy.table.serialize.py@@_TableLite.itercols": "def itercols(self):\n    return self.values()",
    ".astropy.table.table.py@@QTable._is_mixin_for_table": "def _is_mixin_for_table(self, col):\n    return has_info_class(col, MixinInfo)",
    ".astropy.units.quantity.py@@Quantity.__getitem__": "def __getitem__(self, key):\n    if isinstance(key, str) and isinstance(self.unit, StructuredUnit):\n        return self._new_view(self.view(np.ndarray)[key], self.unit[key])\n    try:\n        out = super().__getitem__(key)\n    except IndexError:\n        if self.isscalar:\n            raise TypeError(\"'{cls}' object with a scalar value does not support indexing\".format(cls=self.__class__.__name__))\n        else:\n            raise\n    if not isinstance(out, np.ndarray):\n        out = self._new_view(out)\n    return out",
    ".astropy.units.quantity.py@@Quantity._new_view": "def _new_view(self, obj=None, unit=None):\n    if unit is None:\n        unit = self.unit\n        quantity_subclass = self.__class__\n    elif unit is self.unit and self.__class__ is Quantity:\n        quantity_subclass = Quantity\n    else:\n        unit = Unit(unit)\n        quantity_subclass = getattr(unit, '_quantity_class', Quantity)\n        if isinstance(self, quantity_subclass):\n            quantity_subclass, subok = self.__quantity_subclass__(unit)\n            if subok:\n                quantity_subclass = self.__class__\n    if obj is None:\n        obj = self.view(np.ndarray)\n    else:\n        obj = np.array(obj, copy=False, subok=True)\n    view = obj.view(quantity_subclass)\n    view._set_unit(unit)\n    view.__array_finalize__(self)\n    return view",
    ".astropy.units.quantity.py@@Quantity.unit": "def unit(self):\n    return self._unit",
    ".astropy.table.table.py@@QTable._convert_col_for_table": "def _convert_col_for_table(self, col):\n    if isinstance(col, Column) and getattr(col, 'unit', None) is not None:\n        q_cls = Masked(Quantity) if isinstance(col, MaskedColumn) else Quantity\n        try:\n            qcol = q_cls(col.data, col.unit, copy=False, subok=True)\n        except Exception as exc:\n            warnings.warn(f'column {col.info.name} has a unit but is kept as a {col.__class__.__name__} as an attempt to convert it to Quantity failed with:\\n{exc!r}', AstropyUserWarning)\n        else:\n            qcol.info = col.info\n            qcol.info.indices = col.info.indices\n            col = qcol\n    else:\n        col = super()._convert_col_for_table(col)\n    return col",
    ".astropy.units.quantity.py@@Quantity.__len__": "def __len__(self):\n    if self.isscalar:\n        raise TypeError(\"'{cls}' object with a scalar value has no len()\".format(cls=self.__class__.__name__))\n    else:\n        return len(self.value)",
    ".astropy.units.quantity.py@@Quantity.isscalar": "def isscalar(self):\n    return not self.shape",
    ".astropy.units.quantity.py@@Quantity.to_value": "def to_value(self, unit=None, equivalencies=[]):\n    if unit is None or unit is self.unit:\n        value = self.view(np.ndarray)\n    elif not self.dtype.names:\n        unit = Unit(unit)\n        try:\n            scale = self.unit._to(unit)\n        except Exception:\n            value = self._to_value(unit, equivalencies)\n        else:\n            value = self.view(np.ndarray)\n            if not is_effectively_unity(scale):\n                value = value * scale\n    else:\n        value = self._to_value(unit, equivalencies)\n    return value if value.shape else value[()]",
    ".astropy.utils.data_info.py@@BaseColumnInfo.indices": "def indices(self):\n    return self._attrs.setdefault('indices', [])",
    ".astropy.io.fits.column.py@@_parse_tdisp_format": "def _parse_tdisp_format(tdisp):\n    tdisp = tdisp.strip()\n    fmt_key = tdisp[0] if tdisp[0] != 'E' or (len(tdisp) > 1 and tdisp[1] not in 'NS') else tdisp[:2]\n    try:\n        tdisp_re = TDISP_RE_DICT[fmt_key]\n    except KeyError:\n        raise VerifyError(f'Format {tdisp} is not recognized.')\n    match = tdisp_re.match(tdisp.strip())\n    if not match or match.group('formatc') is None:\n        raise VerifyError(f'Format {tdisp} is not recognized.')\n    formatc = match.group('formatc')\n    width = match.group('width')\n    precision = None\n    exponential = None\n    if tdisp[0] in ('I', 'B', 'O', 'Z', 'F', 'E', 'G', 'D'):\n        precision = match.group('precision')\n        if precision is None:\n            precision = 1\n    if tdisp[0] in ('E', 'D', 'G') and tdisp[1] not in ('N', 'S'):\n        exponential = match.group('exponential')\n        if exponential is None:\n            exponential = 1\n    return (formatc, width, precision, exponential)",
    ".astropy.io.fits.column.py@@_fortran_to_python_format": "def _fortran_to_python_format(tdisp):\n    format_type, width, precision, exponential = _parse_tdisp_format(tdisp)\n    try:\n        fmt = TDISP_FMT_DICT[format_type]\n        return fmt.format(width=width, precision=precision)\n    except KeyError:\n        raise VerifyError(f'Format {format_type} is not recognized.')",
    ".astropy.table.column.py@@BaseColumn.pformat": "def pformat(self, max_lines=None, show_name=True, show_unit=False, show_dtype=False, html=False):\n    _pformat_col = self._formatter._pformat_col\n    lines, outs = _pformat_col(self, max_lines, show_name=show_name, show_unit=show_unit, show_dtype=show_dtype, html=html)\n    return lines",
    ".astropy.table.column.py@@BaseColumn._formatter": "def _formatter(self):\n    return FORMATTER if self.parent_table is None else self.parent_table.formatter",
    ".astropy.table.pprint.py@@TableFormatter._pformat_col": "def _pformat_col(self, col, max_lines=None, show_name=True, show_unit=None, show_dtype=False, show_length=None, html=False, align=None):\n    if show_unit is None:\n        show_unit = col.info.unit is not None\n    outs = {}\n    col_strs_iter = self._pformat_col_iter(col, max_lines, show_name=show_name, show_unit=show_unit, show_dtype=show_dtype, show_length=show_length, outs=outs)\n    col_strs = [val.replace('\\t', '\\\\t').replace('\\n', '\\\\n') for val in col_strs_iter]\n    if len(col_strs) > 0:\n        col_width = max((len(x) for x in col_strs))\n    if html:\n        from astropy.utils.xml.writer import xml_escape\n        n_header = outs['n_header']\n        for i, col_str in enumerate(col_strs):\n            if i == n_header - 1:\n                continue\n            td = 'th' if i < n_header else 'td'\n            val = f'<{td}>{xml_escape(col_str.strip())}</{td}>'\n            row = '<tr>' + val + '</tr>'\n            if i < n_header:\n                row = '<thead>' + row + '</thead>'\n            col_strs[i] = row\n        if n_header > 0:\n            col_strs.pop(n_header - 1)\n        col_strs.insert(0, '<table>')\n        col_strs.append('</table>')\n    else:\n        col_width = max((len(x) for x in col_strs)) if col_strs else 1\n        for i in outs['i_centers']:\n            col_strs[i] = col_strs[i].center(col_width)\n        if outs['i_dashes'] is not None:\n            col_strs[outs['i_dashes']] = '-' * col_width\n        re_fill_align = re.compile('(?P<fill>.?)(?P<align>[<^>=])')\n        match = None\n        if align:\n            match = re_fill_align.match(align)\n            if not match:\n                raise ValueError(\"column align must be one of '<', '^', '>', or '='\")\n        elif isinstance(col.info.format, str):\n            match = re_fill_align.match(col.info.format)\n        if match:\n            fill_char = match.group('fill')\n            align_char = match.group('align')\n            if align_char == '=':\n                if fill_char != '0':\n                    raise ValueError(\"fill character must be '0' for '=' align\")\n                fill_char = ''\n        else:\n            fill_char = ''\n            align_char = '>'\n        justify_methods = {'<': 'ljust', '^': 'center', '>': 'rjust', '=': 'zfill'}\n        justify_method = justify_methods[align_char]\n        justify_args = (col_width, fill_char) if fill_char else (col_width,)\n        for i, col_str in enumerate(col_strs):\n            col_strs[i] = getattr(col_str, justify_method)(*justify_args)\n    if outs['show_length']:\n        col_strs.append(f'Length = {len(col)} rows')\n    return (col_strs, outs)",
    ".astropy.table.pprint.py@@TableFormatter._pformat_col_iter": "def _pformat_col_iter(self, col, max_lines, show_name, show_unit, outs, show_dtype=False, show_length=None):\n    max_lines, _ = self._get_pprint_size(max_lines, -1)\n    dtype = getattr(col, 'dtype', None)\n    multidims = getattr(col, 'shape', [0])[1:]\n    if multidims:\n        multidim0 = tuple((0 for n in multidims))\n        multidim1 = tuple((n - 1 for n in multidims))\n        trivial_multidims = np.prod(multidims) == 1\n    i_dashes = None\n    i_centers = []\n    n_header = 0\n    if show_name:\n        i_centers.append(n_header)\n        col_name = str(col.info.name)\n        n_header += 1\n        yield self._name_and_structure(col_name, dtype)\n    if show_unit:\n        i_centers.append(n_header)\n        n_header += 1\n        yield str(col.info.unit or '')\n    if show_dtype:\n        i_centers.append(n_header)\n        n_header += 1\n        if dtype is not None:\n            col_dtype = dtype_info_name((dtype, multidims))\n        else:\n            col_dtype = col.__class__.__qualname__ or 'object'\n        yield col_dtype\n    if show_unit or show_name or show_dtype:\n        i_dashes = n_header\n        n_header += 1\n        yield '---'\n    max_lines -= n_header\n    n_print2 = max_lines // 2\n    n_rows = len(col)\n    col_format = col.info.format or getattr(col.info, 'default_format', None)\n    pssf = getattr(col.info, 'possible_string_format_functions', None) or _possible_string_format_functions\n    auto_format_func = get_auto_format_func(col, pssf)\n    format_func = col.info._format_funcs.get(col_format, auto_format_func)\n    if len(col) > max_lines:\n        if show_length is None:\n            show_length = True\n        i0 = n_print2 - (1 if show_length else 0)\n        i1 = n_rows - n_print2 - max_lines % 2\n        indices = np.concatenate([np.arange(0, i0 + 1), np.arange(i1 + 1, len(col))])\n    else:\n        i0 = -1\n        indices = np.arange(len(col))\n\n    def format_col_str(idx):\n        if multidims:\n            if trivial_multidims:\n                return format_func(col_format, col[(idx,) + multidim0])\n            else:\n                left = format_func(col_format, col[(idx,) + multidim0])\n                right = format_func(col_format, col[(idx,) + multidim1])\n                return f'{left} .. {right}'\n        else:\n            return format_func(col_format, col[idx])\n    for idx in indices:\n        if idx == i0:\n            yield '...'\n        else:\n            try:\n                yield format_col_str(idx)\n            except ValueError:\n                raise ValueError('Unable to parse format string \"{}\" for entry \"{}\" in column \"{}\"'.format(col_format, col[idx], col.info.name))\n    outs['show_length'] = show_length\n    outs['n_header'] = n_header\n    outs['i_centers'] = i_centers\n    outs['i_dashes'] = i_dashes",
    ".astropy.table.pprint.py@@TableFormatter._get_pprint_size": "def _get_pprint_size(max_lines=None, max_width=None):\n    lines = None\n    width = None\n    if max_lines is None:\n        max_lines = conf.max_lines\n    if max_width is None:\n        max_width = conf.max_width\n    if max_lines is None or max_width is None:\n        lines, width = terminal_size()\n    if max_lines is None:\n        max_lines = lines\n    elif max_lines < 0:\n        max_lines = sys.maxsize\n    if max_lines < 8:\n        max_lines = 8\n    if max_width is None:\n        max_width = width\n    elif max_width < 0:\n        max_width = sys.maxsize\n    if max_width < 10:\n        max_width = 10\n    return (max_lines, max_width)",
    ".astropy.table.pprint.py@@TableFormatter._name_and_structure": "def _name_and_structure(self, name, dtype, sep=' '):\n    if dtype is None or dtype.names is None:\n        return name\n    structure = ', '.join([self._name_and_structure(name, dt, sep='') for name, (dt, _) in dtype.fields.items()])\n    return f'{name}{sep}[{structure}]'",
    ".astropy.table.pprint.py@@get_auto_format_func": "def get_auto_format_func(col=None, possible_string_format_functions=_possible_string_format_functions):\n\n    def _auto_format_func(format_, val):\n        if format_ is None:\n            return default_format_func(format_, val)\n        if format_ in col.info._format_funcs:\n            return col.info._format_funcs[format_](format_, val)\n        if callable(format_):\n            format_func = lambda format_, val: format_(val)\n            try:\n                out = format_func(format_, val)\n                if not isinstance(out, str):\n                    raise ValueError('Format function for value {} returned {} instead of string type'.format(val, type(val)))\n            except Exception as err:\n                if val is np.ma.masked:\n                    return str(val)\n                raise ValueError(f'Format function for value {val} failed.') from err\n            try:\n                format_func(format_, np.ma.masked)\n            except Exception:\n                format_func = _use_str_for_masked_values(format_func)\n        else:\n            if val is np.ma.masked:\n                return str(val)\n            for format_func in possible_string_format_functions(format_):\n                try:\n                    out = format_func(format_, val)\n                    if out == format_:\n                        raise ValueError('the format passed in did nothing.')\n                except Exception:\n                    continue\n                else:\n                    break\n            else:\n                raise ValueError('unable to parse format string {} for its column.'.format(format_))\n            format_func = _use_str_for_masked_values(format_func)\n        col.info._format_funcs[format_] = format_func\n        return out\n    return _auto_format_func",
    ".astropy.table.pprint.py@@TableFormatter.format_col_str": "def format_col_str(idx):\n    if multidims:\n        if trivial_multidims:\n            return format_func(col_format, col[(idx,) + multidim0])\n        else:\n            left = format_func(col_format, col[(idx,) + multidim0])\n            right = format_func(col_format, col[(idx,) + multidim1])\n            return f'{left} .. {right}'\n    else:\n        return format_func(col_format, col[idx])",
    ".astropy.table.pprint.py@@_auto_format_func": "def _auto_format_func(format_, val):\n    if format_ is None:\n        return default_format_func(format_, val)\n    if format_ in col.info._format_funcs:\n        return col.info._format_funcs[format_](format_, val)\n    if callable(format_):\n        format_func = lambda format_, val: format_(val)\n        try:\n            out = format_func(format_, val)\n            if not isinstance(out, str):\n                raise ValueError('Format function for value {} returned {} instead of string type'.format(val, type(val)))\n        except Exception as err:\n            if val is np.ma.masked:\n                return str(val)\n            raise ValueError(f'Format function for value {val} failed.') from err\n        try:\n            format_func(format_, np.ma.masked)\n        except Exception:\n            format_func = _use_str_for_masked_values(format_func)\n    else:\n        if val is np.ma.masked:\n            return str(val)\n        for format_func in possible_string_format_functions(format_):\n            try:\n                out = format_func(format_, val)\n                if out == format_:\n                    raise ValueError('the format passed in did nothing.')\n            except Exception:\n                continue\n            else:\n                break\n        else:\n            raise ValueError('unable to parse format string {} for its column.'.format(format_))\n        format_func = _use_str_for_masked_values(format_func)\n    col.info._format_funcs[format_] = format_func\n    return out",
    ".astropy.table.pprint.py@@_possible_string_format_functions": "def _possible_string_format_functions(format_):\n    yield (lambda format_, val: format(val, format_))\n    yield (lambda format_, val: format_.format(val))\n    yield (lambda format_, val: format_ % val)",
    ".astropy.table.pprint.py@@_use_str_for_masked_values": "def _use_str_for_masked_values(format_func):\n    return lambda format_, val: str(val) if val is np.ma.masked else format_func(format_, val)",
    ".astropy.io.fits.util.py@@decode_ascii": "def decode_ascii(s):\n    if isinstance(s, bytes):\n        try:\n            return s.decode('ascii')\n        except UnicodeDecodeError:\n            warnings.warn('non-ASCII characters are present in the FITS file header and have been replaced by \"?\" characters', AstropyUserWarning)\n            s = s.decode('ascii', errors='replace')\n            return s.replace('\ufffd', '?')\n    elif isinstance(s, np.ndarray) and issubclass(s.dtype.type, np.bytes_):\n        if s.size == 0:\n            dt = s.dtype.str.replace('S', 'U')\n            ns = np.array([], dtype=dt).view(type(s))\n        else:\n            ns = np.char.decode(s, 'ascii').view(type(s))\n        if ns.dtype.itemsize / 4 != s.dtype.itemsize:\n            ns = ns.astype((np.str_, s.dtype.itemsize))\n        return ns\n    elif isinstance(s, np.ndarray) and (not issubclass(s.dtype.type, np.str_)):\n        raise TypeError('string operation on non-string array')\n    return s",
    ".astropy.units.core.py@@_UnitRegistry.aliases": "def aliases(self):\n    return self._aliases",
    ".astropy.units.core.py@@NamedUnit.__init__": "def __init__(self, st, doc=None, format=None, namespace=None):\n    UnitBase.__init__(self)\n    if isinstance(st, (bytes, str)):\n        self._names = [st]\n        self._short_names = [st]\n        self._long_names = []\n    elif isinstance(st, tuple):\n        if not len(st) == 2:\n            raise ValueError('st must be string, list or 2-tuple')\n        self._names = st[0] + [n for n in st[1] if n not in st[0]]\n        if not len(self._names):\n            raise ValueError('must provide at least one name')\n        self._short_names = st[0][:]\n        self._long_names = st[1][:]\n    else:\n        if len(st) == 0:\n            raise ValueError('st list must have at least one entry')\n        self._names = st[:]\n        self._short_names = [st[0]]\n        self._long_names = st[1:]\n    if format is None:\n        format = {}\n    self._format = format\n    if doc is None:\n        doc = self._generate_doc()\n    else:\n        doc = textwrap.dedent(doc)\n        doc = textwrap.fill(doc)\n    self.__doc__ = doc\n    self._inject(namespace)",
    ".astropy.units.core.py@@NamedUnit._generate_doc": "def _generate_doc(self):\n    names = self.names\n    if len(self.names) > 1:\n        return '{1} ({0})'.format(*names[:2])\n    else:\n        return names[0]",
    ".astropy.units.core.py@@NamedUnit.names": "def names(self):\n    return self._names",
    ".astropy.units.core.py@@NamedUnit._inject": "def _inject(self, namespace=None):\n    if namespace is None:\n        return\n    for name in self._names:\n        if name in namespace and self != namespace[name]:\n            raise ValueError('Object with name {!r} already exists in given namespace ({!r}).'.format(name, namespace[name]))\n    for name in self._names:\n        namespace[name] = self",
    ".astropy.units.format.utils.py@@fix_deprecated": "def fix_deprecated(x):\n    if x in deprecated_units:\n        results = [x + ' (deprecated)']\n        decomposed = _try_decomposed(all_units[x], format_decomposed)\n        if decomposed is not None:\n            results.append(decomposed)\n        return results\n    return (x,)",
    ".astropy.units.format.generic.py@@Generic.p_product": "def p_product(p):\n    pass",
    ".astropy.table.column.py@@MaskedColumn.__new__": "def __new__(cls, data=None, name=None, mask=None, fill_value=None, dtype=None, shape=(), length=0, description=None, unit=None, format=None, meta=None, copy=False, copy_indices=True):\n    if mask is None:\n        mask = ma.MaskedArray(data).mask\n        if mask is np.ma.nomask:\n            mask = False\n        elif copy:\n            mask = mask.copy()\n    elif mask is np.ma.nomask:\n        mask = False\n    else:\n        mask = deepcopy(mask)\n    self_data = BaseColumn(data, dtype=dtype, shape=shape, length=length, name=name, unit=unit, format=format, description=description, meta=meta, copy=copy, copy_indices=copy_indices)\n    self = ma.MaskedArray.__new__(cls, data=self_data, mask=mask)\n    if 'info' in getattr(data, '__dict__', {}):\n        self.info = data.info\n    if fill_value is None and getattr(data, 'fill_value', None) is not None:\n        fill_value = np.array(data.fill_value, self.dtype)[()]\n    self.fill_value = fill_value\n    self.parent_table = None\n    for index in self.indices:\n        index.replace_col(self_data, self)\n    return self",
    ".astropy.table.column.py@@MaskedColumn.fill_value": "def fill_value(self):\n    return self.get_fill_value()",
    ".astropy.table.column.py@@MaskedColumn.data": "def data(self):\n    out = self.view(np.ma.MaskedArray)\n    out._baseclass = np.ndarray\n    return out",
    ".astropy.table.column.py@@MaskedColumn._copy_attrs_slice": "def _copy_attrs_slice(self, out):\n    if out.__class__ is self.__class__:\n        if 'info' in self.__dict__:\n            out.info = self.info\n        out.parent_table = None\n        if out.indices is self.indices:\n            out.indices = []\n        out._copy_attrs(self)\n    return out",
    ".astropy.table.column.py@@MaskedColumnInfo.__init__": "def __init__(self, bound=False):\n    super().__init__(bound)\n    if bound:\n        self.serialize_method = {'fits': 'null_value', 'ecsv': 'null_value', 'hdf5': 'data_mask', 'parquet': 'data_mask', None: 'null_value'}",
    ".astropy.utils.data_info.py@@InfoAttribute.__set__": "def __set__(self, instance, value):\n    if instance is None:\n        raise ValueError('cannot set unbound descriptor')\n    instance._attrs[self.attr] = value",
    ".astropy.io.fits.column.py@@_parse_tdim": "def _parse_tdim(tdim):\n    m = tdim and TDIM_RE.match(tdim)\n    if m:\n        dims = m.group('dims')\n        return tuple((int(d.strip()) for d in dims.split(',')))[::-1]\n    return tuple()",
    ".astropy.io.fits.hdu.table.py@@TableHDU.__init__": "def __init__(self, data=None, header=None, name=None, ver=None, character_as_bytes=False):\n    super().__init__(data, header, name=name, ver=ver, character_as_bytes=character_as_bytes)",
    ".astropy.io.fits.hdu.table.py@@TableHDU._get_tbdata": "def _get_tbdata(self):\n    columns = self.columns\n    names = [n for idx, n in enumerate(columns.names)]\n    dup = np.rec.find_duplicate(names)\n    if dup:\n        raise ValueError(f'Duplicate field names: {dup}')\n    itemsize = columns.spans[-1] + columns.starts[-1] - 1\n    dtype = {}\n    for idx in range(len(columns)):\n        data_type = 'S' + str(columns.spans[idx])\n        if idx == len(columns) - 1:\n            if self._header['NAXIS1'] > itemsize:\n                data_type = 'S' + str(columns.spans[idx] + self._header['NAXIS1'] - itemsize)\n        dtype[columns.names[idx]] = (data_type, columns.starts[idx] - 1)\n    raw_data = self._get_raw_data(self._nrows, dtype, self._data_offset)\n    data = raw_data.view(np.rec.recarray)\n    self._init_tbdata(data)\n    return data.view(self._data_type)",
    ".astropy.io.fits.column.py@@_AsciiColDefs.__init__": "def __init__(self, input, ascii=True):\n    super().__init__(input)\n    if not isinstance(input, _AsciiColDefs):\n        self._update_field_metrics()\n    else:\n        for idx, s in enumerate(input.starts):\n            self.columns[idx].start = s\n        self._spans = input.spans\n        self._width = input._width",
    ".astropy.io.fits.column.py@@_AsciiColumnFormat.__new__": "def __new__(cls, format, strict=False):\n    self = super().__new__(cls, format)\n    self.format, self.width, self.precision = _parse_ascii_tformat(format, strict)\n    if format == self.format:\n        self.recformat = ASCII2NUMPY[format]\n    self._pseudo_logical = False\n    return self",
    ".astropy.io.fits.column.py@@_parse_ascii_tformat": "def _parse_ascii_tformat(tform, strict=False):\n    match = TFORMAT_ASCII_RE.match(tform.strip())\n    if not match:\n        raise VerifyError(f'Format {tform!r} is not recognized.')\n    format = match.group('format')\n    if format is None:\n        format = match.group('formatf').upper()\n        width = match.group('widthf')\n        precision = match.group('precision')\n        if width is None or precision is None:\n            if strict:\n                raise VerifyError('Format {!r} is not unambiguously an ASCII table format.')\n            else:\n                width = 0 if width is None else width\n                precision = 1 if precision is None else precision\n    else:\n        format = format.upper()\n        width = match.group('width')\n        if width is None:\n            if strict:\n                raise VerifyError('Format {!r} is not unambiguously an ASCII table format.')\n            else:\n                width = 0\n        precision = 0\n\n    def convert_int(val):\n        msg = 'Format {!r} is not valid--field width and decimal precision must be integers.'\n        try:\n            val = int(val)\n        except (ValueError, TypeError):\n            raise VerifyError(msg.format(tform))\n        return val\n    if width and precision:\n        width, precision = (convert_int(width), convert_int(precision))\n    elif width:\n        width = convert_int(width)\n    else:\n        width, precision = ASCII_DEFAULT_WIDTHS[format]\n    if width <= 0:\n        raise VerifyError('Format {!r} not valid--field width must be a positive integeter.'.format(tform))\n    if precision >= width:\n        raise VerifyError(\"Format {!r} not valid--the number of decimal digits must be less than the format's total width {}.\".format(tform, width))\n    return (format, width, precision)",
    ".astropy.io.fits.column.py@@convert_int": "def convert_int(val):\n    msg = 'Format {!r} is not valid--field width and decimal precision must be integers.'\n    try:\n        val = int(val)\n    except (ValueError, TypeError):\n        raise VerifyError(msg.format(tform))\n    return val",
    ".astropy.io.fits.column.py@@_AsciiColumnFormat.recformat": "def recformat(self):\n    return _convert_ascii_format(self)",
    ".astropy.io.fits.column.py@@_convert_ascii_format": "def _convert_ascii_format(format, reverse=False):\n    if reverse:\n        recformat, kind, dtype = _dtype_to_recformat(format)\n        itemsize = dtype.itemsize\n        if kind == 'a':\n            return 'A' + str(itemsize)\n        elif NUMPY2FITS.get(recformat) == 'L':\n            return 'A1'\n        elif kind == 'i':\n            width = 1 + len(str(2 ** (itemsize * 8)))\n            width = max(width, ASCII_DEFAULT_WIDTHS['I'][0])\n            return 'I' + str(width)\n        elif kind == 'f':\n            if itemsize >= 8:\n                format = 'D'\n            else:\n                format = 'E'\n            width = '.'.join((str(w) for w in ASCII_DEFAULT_WIDTHS[format]))\n            return format + width\n    else:\n        format, width, precision = _parse_ascii_tformat(format)\n        recformat = ASCII2NUMPY[format]\n        if format == 'I':\n            if width <= 4:\n                recformat = 'i2'\n            elif width > 9:\n                recformat = 'i8'\n        elif format == 'A':\n            recformat += str(width)\n        return recformat",
    ".astropy.io.fits.column.py@@_AsciiColDefs._update_field_metrics": "def _update_field_metrics(self):\n    spans = [0] * len(self.columns)\n    end_col = 0\n    for idx, col in enumerate(self.columns):\n        width = col.format.width\n        if not col.start:\n            col.start = end_col + 1\n        end_col = col.start + width - 1\n        spans[idx] = width\n    self._spans = spans\n    self._width = end_col",
    ".astropy.io.fits.column.py@@_AsciiColDefs.spans": "def spans(self):\n    return self._spans",
    ".astropy.io.fits.column.py@@ColDefs.__getattr__": "def __getattr__(self, name):\n    cname = name[:-1]\n    if cname in KEYWORD_ATTRIBUTES and name[-1] == 's':\n        attr = []\n        for col in self.columns:\n            val = getattr(col, cname)\n            attr.append(val if val is not None else '')\n        return attr\n    raise AttributeError(name)",
    ".astropy.io.fits.column.py@@ColDefs.__len__": "def __len__(self):\n    return len(self.columns)",
    ".astropy.io.fits.column.py@@_AsciiColumnFormat.canonical": "def canonical(self):\n    if self.format in ('E', 'F', 'D'):\n        return f'{self.format}{self.width}.{self.precision}'\n    return f'{self.format}{self.width}'",
    ".astropy.io.fits.fitsrec.py@@FITS_rec._convert_ascii": "def _convert_ascii(self, column, field):\n    format = column.format\n    recformat = getattr(format, 'recformat', ASCII2NUMPY[format[0]])\n    nullval = str(column.null).strip().encode('ascii')\n    if len(nullval) > format.width:\n        nullval = nullval[:format.width]\n    dummy = np.char.ljust(field, format.width)\n    dummy = np.char.replace(dummy, encode_ascii('D'), encode_ascii('E'))\n    null_fill = encode_ascii(str(ASCIITNULL).rjust(format.width))\n    dummy = np.where(np.char.strip(dummy) == nullval, null_fill, dummy)\n    if nullval != b'':\n        dummy = np.where(np.char.strip(dummy) == b'', null_fill, dummy)\n    try:\n        dummy = np.array(dummy, dtype=recformat)\n    except ValueError as exc:\n        indx = self.names.index(column.name)\n        raise ValueError('{}; the header may be missing the necessary TNULL{} keyword or the table contains invalid data'.format(exc, indx + 1))\n    return dummy",
    ".astropy.io.fits.util.py@@encode_ascii": "def encode_ascii(s):\n    if isinstance(s, str):\n        return s.encode('ascii')\n    elif isinstance(s, np.ndarray) and issubclass(s.dtype.type, np.str_):\n        ns = np.char.encode(s, 'ascii').view(type(s))\n        if ns.dtype.itemsize != s.dtype.itemsize / 4:\n            ns = ns.astype((np.bytes_, s.dtype.itemsize / 4))\n        return ns\n    elif isinstance(s, np.ndarray) and (not issubclass(s.dtype.type, np.bytes_)):\n        raise TypeError('string operation on non-string array')\n    return s",
    ".astropy.io.fits.hdu.table.py@@_TableBaseHDU.match_header": "def match_header(cls, header):\n    raise NotImplementedError",
    ".astropy.io.fits.hdu.nonstandard.py@@FitsHDU.match_header": "def match_header(cls, header):\n    card = header.cards[0]\n    if card.keyword != 'XTENSION':\n        return False\n    xtension = card.value\n    if isinstance(xtension, str):\n        xtension = xtension.rstrip()\n    return xtension == cls._extension",
    ".astropy.io.fits.hdu.base.py@@NonstandardExtHDU.match_header": "def match_header(cls, header):\n    card = header.cards[0]\n    xtension = card.value\n    if isinstance(xtension, str):\n        xtension = xtension.rstrip()\n    standard_xtensions = ('IMAGE', 'TABLE', 'BINTABLE', 'A3DTABLE')\n    return card.keyword == 'XTENSION' and xtension not in standard_xtensions",
    ".astropy.io.fits.hdu.image.py@@ImageHDU.match_header": "def match_header(cls, header):\n    card = header.cards[0]\n    xtension = card.value\n    if isinstance(xtension, str):\n        xtension = xtension.rstrip()\n    return card.keyword == 'XTENSION' and xtension == cls._extension",
    ".astropy.io.fits.hdu.image.py@@ImageHDU.__init__": "def __init__(self, data=None, header=None, name=None, do_not_scale_image_data=False, uint=True, scale_back=None, ver=None):\n    super().__init__(data=data, header=header, name=name, do_not_scale_image_data=do_not_scale_image_data, uint=uint, scale_back=scale_back, ver=ver)",
    ".astropy.io.fits.hdu.base.py@@_BaseHDU.name": "def name(self):\n    return str(self._header.get('EXTNAME', self._default_name))",
    ".astropy.io.fits.hdu.hdulist.py@@HDUList.readall": "def readall(self):\n    while self._read_next_hdu():\n        pass",
    ".astropy.utils.data_info.py@@InfoAttribute.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        return self\n    return instance._attrs.get(self.attr, self.default)",
    ".astropy.utils.data.py@@is_url": "def is_url(string):\n    url = urllib.parse.urlparse(string)\n    return url.scheme.lower() in ['http', 'https', 'ftp', 'sftp', 'ssh', 'file']",
    ".astropy.io.fits.file.py@@_File._open_filename": "def _open_filename(self, filename, mode, overwrite):\n    if mode == 'ostream':\n        self._overwrite_existing(overwrite, None, True)\n    if os.path.exists(self.name):\n        with open(self.name, 'rb') as f:\n            magic = f.read(4)\n    else:\n        magic = b''\n    ext = os.path.splitext(self.name)[1]\n    if not self._try_read_compressed(self.name, magic, mode, ext=ext):\n        self._file = open(self.name, IO_FITS_MODES[mode])\n        self.close_on_error = True\n    if not (_is_bz2file(self._file) and mode == 'ostream'):\n        self._file.seek(0)",
    ".astropy.io.fits.fitstime.py@@fits_to_time": "def fits_to_time(hdr, table):\n    global_info = {'TIMESYS': 'UTC', 'TREFPOS': 'TOPOCENTER'}\n    time_columns = defaultdict(OrderedDict)\n    hcopy = hdr.copy(strip=True)\n    for key, value, comment in hdr.cards:\n        if key in TIME_KEYWORDS:\n            global_info[key] = value\n            hcopy.remove(key)\n        elif is_time_column_keyword(key):\n            base, idx = re.match('([A-Z]+)([0-9]+)', key).groups()\n            time_columns[int(idx)][base] = value\n            hcopy.remove(key)\n        elif value in ('OBSGEO-X', 'OBSGEO-Y', 'OBSGEO-Z') and re.match('TTYPE[0-9]+', key):\n            global_info[value] = table[value]\n    _verify_global_info(global_info)\n    _convert_global_time(table, global_info)\n    if time_columns:\n        for idx, column_info in time_columns.items():\n            if _verify_column_info(column_info, global_info):\n                colname = table.colnames[idx - 1]\n                table[colname] = _convert_time_column(table[colname], column_info)\n    for idx, colname in enumerate(table.colnames):\n        if idx + 1 not in time_columns:\n            column_info = _get_info_if_time_column(table[colname], global_info)\n            if column_info:\n                table[colname] = _convert_time_column(table[colname], column_info)\n    return hcopy",
    ".astropy.io.fits.header.py@@Header.copy": "def copy(self, strip=False):\n    tmp = self.__class__((copy.copy(card) for card in self._cards))\n    if strip:\n        tmp.strip()\n    return tmp",
    ".astropy.io.fits.header.py@@Header.append": "def append(self, card=None, useblanks=True, bottom=False, end=False):\n    if isinstance(card, str):\n        card = Card(card)\n    elif isinstance(card, tuple):\n        card = Card(*card)\n    elif card is None:\n        card = Card()\n    elif not isinstance(card, Card):\n        raise ValueError('The value appended to a Header must be either a keyword or (keyword, value, [comment]) tuple; got: {!r}'.format(card))\n    if not end and card.is_blank:\n        end = True\n    if end:\n        self._cards.append(card)\n        idx = len(self._cards) - 1\n    else:\n        idx = len(self._cards) - 1\n        while idx >= 0 and self._cards[idx].is_blank:\n            idx -= 1\n        if not bottom and card.keyword not in Card._commentary_keywords:\n            while idx >= 0 and self._cards[idx].keyword in Card._commentary_keywords:\n                idx -= 1\n        idx += 1\n        self._cards.insert(idx, card)\n        self._updateindices(idx)\n    keyword = Card.normalize_keyword(card.keyword)\n    self._keyword_indices[keyword].append(idx)\n    if card.field_specifier is not None:\n        self._rvkc_indices[card.rawkeyword].append(idx)\n    if not end:\n        if not bottom and card.keyword in Card._commentary_keywords:\n            self._keyword_indices[keyword].sort()\n        if useblanks and self._countblanks():\n            self._useblanks(len(str(card)) // Card.length)\n    self._modified = True",
    ".astropy.io.fits.header.py@@Header.strip": "def strip(self):\n    naxis = self.get('NAXIS', 0)\n    tfields = self.get('TFIELDS', 0)\n    for idx in range(naxis):\n        self.remove('NAXIS' + str(idx + 1), ignore_missing=True)\n    for name in ('TFORM', 'TSCAL', 'TZERO', 'TNULL', 'TTYPE', 'TUNIT', 'TDISP', 'TDIM', 'THEAP', 'TBCOL'):\n        for idx in range(tfields):\n            self.remove(name + str(idx + 1), ignore_missing=True)\n    for name in ('SIMPLE', 'XTENSION', 'BITPIX', 'NAXIS', 'EXTEND', 'PCOUNT', 'GCOUNT', 'GROUPS', 'BSCALE', 'BZERO', 'TFIELDS'):\n        self.remove(name, ignore_missing=True)",
    ".astropy.io.fits.header.py@@Header.remove": "def remove(self, keyword, ignore_missing=False, remove_all=False):\n    keyword = Card.normalize_keyword(keyword)\n    if keyword in self._keyword_indices:\n        del self[self._keyword_indices[keyword][0]]\n        if remove_all:\n            while keyword in self._keyword_indices:\n                del self[self._keyword_indices[keyword][0]]\n    elif not ignore_missing:\n        raise KeyError(f\"Keyword '{keyword}' not found.\")",
    ".astropy.io.fits.header.py@@Header.__delitem__": "def __delitem__(self, key):\n    if isinstance(key, slice) or self._haswildcard(key):\n        if isinstance(key, slice):\n            indices = range(*key.indices(len(self)))\n            if key.step and key.step < 0:\n                indices = reversed(indices)\n        else:\n            indices = self._wildcardmatch(key)\n        for idx in reversed(indices):\n            del self[idx]\n        return\n    elif isinstance(key, str):\n        key = Card.normalize_keyword(key)\n        indices = self._keyword_indices\n        if key not in self._keyword_indices:\n            indices = self._rvkc_indices\n        if key not in indices:\n            raise KeyError(f\"Keyword '{key}' not found.\")\n        for idx in reversed(indices[key]):\n            del self[idx]\n        return\n    idx = self._cardindex(key)\n    card = self._cards[idx]\n    keyword = card.keyword\n    del self._cards[idx]\n    keyword = Card.normalize_keyword(keyword)\n    indices = self._keyword_indices[keyword]\n    indices.remove(idx)\n    if not indices:\n        del self._keyword_indices[keyword]\n    if card.field_specifier is not None:\n        indices = self._rvkc_indices[card.rawkeyword]\n        indices.remove(idx)\n        if not indices:\n            del self._rvkc_indices[card.rawkeyword]\n    self._updateindices(idx, increment=False)\n    self._modified = True",
    ".astropy.io.fits.header.py@@Header._updateindices": "def _updateindices(self, idx, increment=True):\n    if idx > len(self._cards):\n        return\n    increment = 1 if increment else -1\n    for index_sets in (self._keyword_indices, self._rvkc_indices):\n        for indices in index_sets.values():\n            for jdx, keyword_index in enumerate(indices):\n                if keyword_index >= idx:\n                    indices[jdx] += increment",
    ".astropy.io.fits.fitstime.py@@is_time_column_keyword": "def is_time_column_keyword(keyword):\n    return re.match(COLUMN_TIME_KEYWORD_REGEXP, keyword) is not None",
    ".astropy.io.fits.fitstime.py@@_verify_global_info": "def _verify_global_info(global_info):\n    global_info['scale'] = FITS_DEPRECATED_SCALES.get(global_info['TIMESYS'], global_info['TIMESYS'].lower())\n    if global_info['scale'] not in Time.SCALES:\n        if global_info['scale'] == 'gps':\n            warnings.warn('Global time scale (TIMESYS) has a FITS recognized time scale value \"GPS\". In Astropy, \"GPS\" is a time from epoch format which runs synchronously with TAI; GPS is approximately 19 s ahead of TAI. Hence, this format will be used.', AstropyUserWarning)\n            global_info['scale'] = 'tai'\n            global_info['format'] = 'gps'\n        if global_info['scale'] == 'local':\n            warnings.warn('Global time scale (TIMESYS) has a FITS recognized time scale value \"LOCAL\". However, the standard states that \"LOCAL\" should be tied to one of the existing scales because it is intrinsically unreliable and/or ill-defined. Astropy will thus use the default global time scale \"UTC\" instead of \"LOCAL\".', AstropyUserWarning)\n            global_info['scale'] = 'utc'\n            global_info['format'] = None\n        else:\n            raise AssertionError('Global time scale (TIMESYS) should have a FITS recognized time scale value (got {!r}). The FITS standard states that the use of local time scales should be restricted to alternate coordinates.'.format(global_info['TIMESYS']))\n    else:\n        global_info['format'] = None\n    obs_geo = [global_info[attr] for attr in ('OBSGEO-X', 'OBSGEO-Y', 'OBSGEO-Z') if attr in global_info]\n    if len(obs_geo) == 3:\n        global_info['location'] = EarthLocation.from_geocentric(*obs_geo, unit=u.m)\n    else:\n        if obs_geo:\n            warnings.warn('The geocentric observatory location {} is not completely specified (X, Y, Z) and will be ignored.'.format(obs_geo), AstropyUserWarning)\n        obs_geo = [global_info[attr] for attr in ('OBSGEO-L', 'OBSGEO-B', 'OBSGEO-H') if attr in global_info]\n        if len(obs_geo) == 3:\n            global_info['location'] = EarthLocation.from_geodetic(*obs_geo)\n        else:\n            if obs_geo:\n                warnings.warn('The geodetic observatory location {} is not completely specified (lon, lat, alt) and will be ignored.'.format(obs_geo), AstropyUserWarning)\n            global_info['location'] = None\n    for key, format_ in (('MJDREF', 'mjd'), ('JDREF', 'jd'), ('DATEREF', 'fits')):\n        if key in global_info:\n            global_info['ref_time'] = {'val': global_info[key], 'format': format_}\n            break\n    else:\n        global_info['ref_time'] = {'val': 0, 'format': 'mjd'}",
    ".astropy.coordinates.earth.py@@EarthLocation.from_geocentric": "def from_geocentric(cls, x, y, z, unit=None):\n    if unit is None:\n        try:\n            unit = x.unit\n        except AttributeError:\n            raise TypeError('Geocentric coordinates should be Quantities unless an explicit unit is given.') from None\n    else:\n        unit = u.Unit(unit)\n    if unit.physical_type != 'length':\n        raise u.UnitsError('Geocentric coordinates should be in units of length.')\n    try:\n        x = u.Quantity(x, unit, copy=False)\n        y = u.Quantity(y, unit, copy=False)\n        z = u.Quantity(z, unit, copy=False)\n    except u.UnitsError:\n        raise u.UnitsError('Geocentric coordinate units should all be consistent.')\n    x, y, z = np.broadcast_arrays(x, y, z)\n    struc = np.empty(x.shape, cls._location_dtype)\n    struc['x'], struc['y'], struc['z'] = (x, y, z)\n    return super().__new__(cls, struc, unit, copy=False)",
    ".astropy.units.core.py@@UnitBase.physical_type": "def physical_type(self):\n    from . import physical\n    return physical.get_physical_type(self)",
    ".astropy.units.physical.py@@get_physical_type": "def get_physical_type(obj):\n    if isinstance(obj, PhysicalType):\n        return obj\n    if isinstance(obj, str):\n        return _physical_type_from_str(obj)\n    try:\n        unit = obj if isinstance(obj, core.UnitBase) else quantity.Quantity(obj, copy=False).unit\n    except TypeError as exc:\n        raise TypeError(f'{obj} does not correspond to a physical type.') from exc\n    unit = _replace_temperatures_with_kelvin(unit)\n    physical_type_id = unit._get_physical_type_id()\n    unit_has_known_physical_type = physical_type_id in _physical_unit_mapping\n    if unit_has_known_physical_type:\n        return _physical_unit_mapping[physical_type_id]\n    else:\n        return PhysicalType(unit, 'unknown')",
    ".astropy.units.physical.py@@_replace_temperatures_with_kelvin": "def _replace_temperatures_with_kelvin(unit):\n    physical_type_id = unit._get_physical_type_id()\n    physical_type_id_components = []\n    substitution_was_made = False\n    for base, power in physical_type_id:\n        if base in ['deg_F', 'deg_C', 'deg_R']:\n            base = 'K'\n            substitution_was_made = True\n        physical_type_id_components.append((base, power))\n    if substitution_was_made:\n        return core.Unit._from_physical_type_id(tuple(physical_type_id_components))\n    else:\n        return unit",
    ".astropy.units.core.py@@UnitBase._get_physical_type_id": "def _get_physical_type_id(self):\n    unit = self.decompose()\n    r = zip([x.name for x in unit.bases], unit.powers)\n    r = tuple(r)\n    return r",
    ".astropy.units.core.py@@UnitBase.bases": "def bases(self):\n    return [self]",
    ".astropy.units.physical.py@@PhysicalType.__ne__": "def __ne__(self, other):\n    equality = self.__eq__(other)\n    return not equality if isinstance(equality, bool) else NotImplemented",
    ".astropy.units.physical.py@@PhysicalType.__eq__": "def __eq__(self, other):\n    if isinstance(other, PhysicalType):\n        return self._physical_type_id == other._physical_type_id\n    elif isinstance(other, str):\n        other = _standardize_physical_type_names(other)\n        return other.issubset(self._physical_type)\n    else:\n        return NotImplemented",
    ".astropy.units.physical.py@@_standardize_physical_type_names": "def _standardize_physical_type_names(physical_type_input):\n    if isinstance(physical_type_input, str):\n        physical_type_input = {physical_type_input}\n    standardized_physical_types = set()\n    for ptype_input in physical_type_input:\n        if not isinstance(ptype_input, str):\n            raise ValueError(f'expecting a string, but got {ptype_input}')\n        input_set = set(ptype_input.split('/'))\n        processed_set = {s.strip().replace('_', ' ') for s in input_set}\n        standardized_physical_types |= processed_set\n    return standardized_physical_types",
    ".astropy.units.quantity.py@@Quantity.__array_function__": "def __array_function__(self, function, types, args, kwargs):\n    if function in SUBCLASS_SAFE_FUNCTIONS:\n        return super().__array_function__(function, types, args, kwargs)\n    elif function in FUNCTION_HELPERS:\n        function_helper = FUNCTION_HELPERS[function]\n        try:\n            args, kwargs, unit, out = function_helper(*args, **kwargs)\n        except NotImplementedError:\n            return self._not_implemented_or_raise(function, types)\n        result = super().__array_function__(function, types, args, kwargs)\n    elif function in DISPATCHED_FUNCTIONS:\n        dispatched_function = DISPATCHED_FUNCTIONS[function]\n        try:\n            result, unit, out = dispatched_function(*args, **kwargs)\n        except NotImplementedError:\n            return self._not_implemented_or_raise(function, types)\n    elif function in UNSUPPORTED_FUNCTIONS:\n        return NotImplemented\n    else:\n        warnings.warn(\"function '{}' is not known to astropy's Quantity. Will run it anyway, hoping it will treat ndarray subclasses correctly. Please raise an issue at https://github.com/astropy/astropy/issues. \".format(function.__name__), AstropyWarning)\n        return super().__array_function__(function, types, args, kwargs)\n    if unit is None or result is NotImplemented:\n        return result\n    return self._result_as_quantity(result, unit, out=out)",
    ".astropy.coordinates.earth.py@@EarthLocation.__array_finalize__": "def __array_finalize__(self, obj):\n    super().__array_finalize__(obj)\n    if hasattr(obj, '_ellipsoid'):\n        self._ellipsoid = obj._ellipsoid",
    ".astropy.io.fits.fitstime.py@@_convert_global_time": "def _convert_global_time(table, global_info):\n    for key, value in global_info.items():\n        if key not in table.meta:\n            try:\n                table.meta[key] = _convert_time_key(global_info, key)\n            except ValueError:\n                pass",
    ".astropy.io.fits.fitstime.py@@_convert_time_key": "def _convert_time_key(global_info, key):\n    value = global_info[key]\n    if key.startswith('DATE'):\n        scale = 'utc' if key == 'DATE' else global_info['scale']\n        precision = len(value.split('.')[-1]) if '.' in value else 0\n        return Time(value, format='fits', scale=scale, precision=precision)\n    elif key.startswith('MJD-'):\n        return Time(value, format='mjd', scale=global_info['scale'])\n    else:\n        raise ValueError('Key is not a valid global time keyword')",
    ".astropy.io.fits.fitstime.py@@_verify_column_info": "def _verify_column_info(column_info, global_info):\n    scale = column_info.get('TCTYP', None)\n    unit = column_info.get('TCUNI', None)\n    location = column_info.get('TRPOS', None)\n    if scale is not None:\n        if TCTYP_RE_TYPE.match(scale[:5]) and TCTYP_RE_ALGO.match(scale[5:]):\n            return False\n        elif scale.lower() in Time.SCALES:\n            column_info['scale'] = scale.lower()\n            column_info['format'] = None\n        elif scale in FITS_DEPRECATED_SCALES.keys():\n            column_info['scale'] = FITS_DEPRECATED_SCALES[scale]\n            column_info['format'] = None\n        elif scale == 'TIME':\n            column_info['scale'] = global_info['scale']\n            column_info['format'] = global_info['format']\n        elif scale == 'GPS':\n            warnings.warn('Table column \"{}\" has a FITS recognized time scale value \"GPS\". In Astropy, \"GPS\" is a time from epoch format which runs synchronously with TAI; GPS runs ahead of TAI approximately by 19 s. Hence, this format will be used.'.format(column_info), AstropyUserWarning)\n            column_info['scale'] = 'tai'\n            column_info['format'] = 'gps'\n        elif scale == 'LOCAL':\n            warnings.warn('Table column \"{}\" has a FITS recognized time scale value \"LOCAL\". However, the standard states that \"LOCAL\" should be tied to one of the existing scales because it is intrinsically unreliable and/or ill-defined. Astropy will thus use the global time scale (TIMESYS) as the default.'.format(column_info), AstropyUserWarning)\n            column_info['scale'] = global_info['scale']\n            column_info['format'] = global_info['format']\n        else:\n            return False\n    elif unit is not None and unit in FITS_TIME_UNIT or location is not None:\n        column_info['scale'] = global_info['scale']\n        column_info['format'] = global_info['format']\n    else:\n        return False\n    if location is not None:\n        if location == 'TOPOCENTER':\n            column_info['location'] = global_info['location']\n            if column_info['location'] is None:\n                warnings.warn('Time column reference position \"TRPOSn\" value is \"TOPOCENTER\". However, the observatory position is not properly specified. The FITS standard does not support this and hence reference position will be ignored.', AstropyUserWarning)\n        else:\n            column_info['location'] = None\n    elif global_info['TREFPOS'] == 'TOPOCENTER':\n        if global_info['location'] is not None:\n            warnings.warn('Time column reference position \"TRPOSn\" is not specified. The default value for it is \"TOPOCENTER\", and the observatory position has been specified. However, for supporting column-specific location, reference position will be ignored for this column.', AstropyUserWarning)\n        column_info['location'] = None\n    else:\n        column_info['location'] = None\n    column_info['ref_time'] = global_info['ref_time']\n    return True",
    ".astropy.table.table.py@@Table.colnames": "def colnames(self):\n    return list(self.columns.keys())",
    ".astropy.io.fits.fitstime.py@@_convert_time_column": "def _convert_time_column(col, column_info):\n    try:\n        if col.info.dtype.kind in ['S', 'U']:\n            precision = max(int(col.info.dtype.str[2:]) - 20, 0)\n            return Time(col, format='fits', scale=column_info['scale'], precision=precision, location=column_info['location'])\n        if column_info['format'] == 'gps':\n            return Time(col, format='gps', location=column_info['location'])\n        if column_info['ref_time']['val'] == 0 and column_info['ref_time']['format'] in ['jd', 'mjd']:\n            if col.shape[-1] == 2 and col.ndim > 1:\n                return Time(col[..., 0], col[..., 1], scale=column_info['scale'], format=column_info['ref_time']['format'], location=column_info['location'])\n            else:\n                return Time(col, scale=column_info['scale'], format=column_info['ref_time']['format'], location=column_info['location'])\n        ref_time = Time(column_info['ref_time']['val'], scale=column_info['scale'], format=column_info['ref_time']['format'], location=column_info['location'])\n        if col.shape[-1] == 2 and col.ndim > 1:\n            delta_time = TimeDelta(col[..., 0], col[..., 1])\n        else:\n            delta_time = TimeDelta(col)\n        return ref_time + delta_time\n    except Exception as err:\n        warnings.warn('The exception \"{}\" was encountered while trying to convert the time column \"{}\" to Astropy Time.'.format(err, col.info.name), AstropyUserWarning)\n        return col",
    ".astropy.time.core.py@@Time.__new__": "def __new__(cls, val, val2=None, format=None, scale=None, precision=None, in_subfmt=None, out_subfmt=None, location=None, copy=False):\n    if isinstance(val, Time):\n        self = val.replicate(format=format, copy=copy, cls=cls)\n    else:\n        self = super().__new__(cls)\n    return self",
    ".astropy.time.core.py@@Time.__init__": "def __init__(self, val, val2=None, format=None, scale=None, precision=None, in_subfmt=None, out_subfmt=None, location=None, copy=False):\n    if location is not None:\n        from astropy.coordinates import EarthLocation\n        if isinstance(location, EarthLocation):\n            self.location = location\n        else:\n            self.location = EarthLocation(*location)\n        if self.location.size == 1:\n            self.location = self.location.squeeze()\n    elif not hasattr(self, 'location'):\n        self.location = None\n    if isinstance(val, Time):\n        if precision is not None:\n            self._time.precision = precision\n        if in_subfmt is not None:\n            self._time.in_subfmt = in_subfmt\n        if out_subfmt is not None:\n            self._time.out_subfmt = out_subfmt\n        self.SCALES = TIME_TYPES[self.scale]\n        if scale is not None:\n            self._set_scale(scale)\n    else:\n        self._init_from_vals(val, val2, format, scale, copy, precision, in_subfmt, out_subfmt)\n        self.SCALES = TIME_TYPES[self.scale]\n    if self.location is not None and (self.location.size > 1 and self.location.shape != self.shape):\n        try:\n            self.location = np.broadcast_to(self.location, self.shape, subok=True)\n        except Exception as err:\n            raise ValueError('The location with shape {} cannot be broadcast against time with shape {}. Typically, either give a single location or one for each time.'.format(self.location.shape, self.shape)) from err",
    ".astropy.time.core.py@@TimeBase._init_from_vals": "def _init_from_vals(self, val, val2, format, scale, copy, precision=None, in_subfmt=None, out_subfmt=None):\n    if precision is None:\n        precision = 3\n    if in_subfmt is None:\n        in_subfmt = '*'\n    if out_subfmt is None:\n        out_subfmt = '*'\n    val = _make_array(val, copy)\n    if val2 is not None:\n        val2 = _make_array(val2, copy)\n        try:\n            np.broadcast(val, val2)\n        except ValueError:\n            raise ValueError('Input val and val2 have inconsistent shape; they cannot be broadcast together.')\n    if scale is not None:\n        if not (isinstance(scale, str) and scale.lower() in self.SCALES):\n            raise ScaleValueError('Scale {!r} is not in the allowed scales {}'.format(scale, sorted(self.SCALES)))\n    mask, val, val2 = _check_for_masked_and_fill(val, val2)\n    self._time = self._get_time_fmt(val, val2, format, scale, precision, in_subfmt, out_subfmt)\n    self._format = self._time.name\n    if hasattr(self._time, '_location'):\n        self.location = self._time._location\n        del self._time._location\n    if mask is not False:\n        mask = np.broadcast_to(mask, self._time.jd2.shape)\n        self._time.jd1[mask] = 2451544.5\n        self._time.jd2[mask] = np.nan",
    ".astropy.time.core.py@@_make_array": "def _make_array(val, copy=False):\n    if isinstance(val, (tuple, list)) and len(val) > 0 and isinstance(val[0], Time):\n        dtype = object\n    else:\n        dtype = None\n    val = np.array(val, copy=copy, subok=True, dtype=dtype)\n    if val.dtype.kind == 'f' and val.dtype.itemsize >= np.dtype(np.float64).itemsize:\n        pass\n    elif val.dtype.kind in 'OSUMaV':\n        pass\n    else:\n        val = np.asanyarray(val, dtype=np.float64)\n    return val",
    ".astropy.time.core.py@@_check_for_masked_and_fill": "def _check_for_masked_and_fill(val, val2):\n\n    def get_as_filled_ndarray(mask, val):\n        fill_value = None\n        if np.any(val.mask):\n            mask = mask | val.mask\n            val_unmasked = val.compressed()\n            if len(val_unmasked) > 0:\n                fill_value = val_unmasked[0]\n        val = val.filled(fill_value)\n        return (mask, val)\n    mask = False\n    if isinstance(val, np.ma.MaskedArray):\n        mask, val = get_as_filled_ndarray(mask, val)\n    if isinstance(val2, np.ma.MaskedArray):\n        mask, val2 = get_as_filled_ndarray(mask, val2)\n    return (mask, val, val2)",
    ".astropy.time.core.py@@TimeBase._get_time_fmt": "def _get_time_fmt(self, val, val2, format, scale, precision, in_subfmt, out_subfmt):\n    if format is None and (val.dtype.kind in ('S', 'U', 'O', 'M') or val.dtype.names):\n        formats = [(name, cls) for name, cls in self.FORMATS.items() if issubclass(cls, TimeUnique)]\n        formats.append(('astropy_time', TimeAstropyTime))\n    elif not (isinstance(format, str) and format.lower() in self.FORMATS):\n        if format is None:\n            raise ValueError('No time format was given, and the input is not unique')\n        else:\n            raise ValueError('Format {!r} is not one of the allowed formats {}'.format(format, sorted(self.FORMATS)))\n    else:\n        formats = [(format, self.FORMATS[format])]\n    assert formats\n    problems = {}\n    for name, cls in formats:\n        try:\n            return cls(val, val2, scale, precision, in_subfmt, out_subfmt)\n        except UnitConversionError:\n            raise\n        except (ValueError, TypeError) as err:\n            if len(formats) == 1:\n                raise ValueError(f'Input values did not match the format class {format}:' + os.linesep + f'{err.__class__.__name__}: {err}') from err\n            else:\n                problems[name] = err\n    else:\n        raise ValueError(f'Input values did not match any of the formats where the format keyword is optional: {problems}') from problems[formats[0][0]]",
    ".astropy.time.formats.py@@TimeFormat.__init__": "def __init__(self, val1, val2, scale, precision, in_subfmt, out_subfmt, from_jd=False):\n    self.scale = scale\n    self.precision = precision\n    self.in_subfmt = in_subfmt\n    self.out_subfmt = out_subfmt\n    self._jd1, self._jd2 = (None, None)\n    if from_jd:\n        self.jd1 = val1\n        self.jd2 = val2\n    else:\n        val1, val2 = self._check_val_type(val1, val2)\n        self.set_jds(val1, val2)",
    ".astropy.time.formats.py@@TimeFormat.scale": "def scale(self):\n    self._scale = self._check_scale(self._scale)\n    return self._scale",
    ".astropy.time.formats.py@@TimeFormat.in_subfmt": "def in_subfmt(self):\n    return self._in_subfmt",
    ".astropy.time.formats.py@@TimeFormat._select_subfmts": "def _select_subfmts(cls, pattern):\n    if not isinstance(pattern, str):\n        raise ValueError('subfmt attribute must be a string')\n    elif pattern == '*':\n        return cls.subfmts\n    subfmts = [x for x in cls.subfmts if fnmatch.fnmatchcase(x[0], pattern)]\n    if len(subfmts) == 0:\n        if len(cls.subfmts) == 0:\n            raise ValueError(f'subformat not allowed for format {cls.name}')\n        else:\n            subfmt_names = [x[0] for x in cls.subfmts]\n            raise ValueError(f'subformat {pattern!r} must match one of {subfmt_names} for format {cls.name}')\n    return subfmts",
    ".astropy.time.formats.py@@TimeFormat.out_subfmt": "def out_subfmt(self):\n    return self._out_subfmt",
    ".astropy.time.formats.py@@TimeNumeric._check_val_type": "def _check_val_type(self, val1, val2):\n    orig_val2_is_none = val2 is None\n    if val1.dtype.kind == 'f':\n        val1, val2 = super()._check_val_type(val1, val2)\n    elif not orig_val2_is_none or not (val1.dtype.kind in 'US' or (val1.dtype.kind == 'O' and all((isinstance(v, Decimal) for v in val1.flat)))):\n        raise TypeError('for {} class, input should be doubles, string, or Decimal, and second values are only allowed for doubles.'.format(self.name))\n    val_dtype = val1.dtype if orig_val2_is_none else np.result_type(val1.dtype, val2.dtype)\n    subfmts = self._select_subfmts(self.in_subfmt)\n    for subfmt, dtype, convert, _ in subfmts:\n        if np.issubdtype(val_dtype, dtype):\n            break\n    else:\n        raise ValueError('input type not among selected sub-formats.')\n    if convert is not None:\n        try:\n            val1, val2 = convert(val1, val2)\n        except Exception:\n            raise TypeError('for {} class, input should be (long) doubles, string, or Decimal, and second values are only allowed for (long) doubles.'.format(self.name))\n    return (val1, val2)",
    ".astropy.time.formats.py@@TimeFormat._check_val_type": "def _check_val_type(self, val1, val2):\n    isfinite1 = np.isfinite(val1)\n    if val1.size > 1:\n        isfinite1 = isfinite1.all()\n    elif val1.size == 0:\n        isfinite1 = False\n    ok1 = val1.dtype.kind == 'f' and val1.dtype.itemsize >= 8 and isfinite1 or val1.size == 0\n    ok2 = val2 is None or (val2.dtype.kind == 'f' and val2.dtype.itemsize >= 8 and (not np.any(np.isinf(val2)))) or val2.size == 0\n    if not (ok1 and ok2):\n        raise TypeError('Input values for {} class must be finite doubles'.format(self.name))\n    if getattr(val1, 'unit', None) is not None:\n        val1 = u.Quantity(val1, copy=False)\n        if val2 is not None:\n            val2 = u.Quantity(val2, copy=False)\n        try:\n            val1, val2 = quantity_day_frac(val1, val2)\n        except u.UnitsError:\n            raise u.UnitConversionError('only quantities with time units can be used to instantiate Time instances.')\n        factor = 1.0 / getattr(self, 'unit', 1.0)\n        if factor != 1.0:\n            val1, carry = two_product(val1, factor)\n            carry += val2 * factor\n            val1, val2 = two_sum(val1, carry)\n    elif getattr(val2, 'unit', None) is not None:\n        raise TypeError('Cannot mix float and Quantity inputs')\n    if val2 is None:\n        val2 = np.array(0, dtype=val1.dtype)\n\n    def asarray_or_scalar(val):\n        return np.asarray(val) if isinstance(val, np.ndarray) else val\n    return (asarray_or_scalar(val1), asarray_or_scalar(val2))",
    ".astropy.table.column.py@@BaseColumn.__array_wrap__": "def __array_wrap__(self, out_arr, context=None):\n    out_arr = super().__array_wrap__(out_arr, context)\n    if self.shape != out_arr.shape or (isinstance(out_arr, BaseColumn) and (context is not None and context[0] in _comparison_functions)):\n        return out_arr.data[()]\n    else:\n        return out_arr",
    ".astropy.time.utils.py@@quantity_day_frac": "def quantity_day_frac(val1, val2=None):\n    if val2 is not None:\n        res11, res12 = quantity_day_frac(val1)\n        res21, res22 = quantity_day_frac(val2)\n        return (res11 + res21, res12 + res22)\n    try:\n        factor = val1.unit.to(u.day)\n    except Exception:\n        return (val1.to_value(u.day), 0.0)\n    if factor == 1.0:\n        return day_frac(val1.value, 0.0)\n    if factor > 1:\n        return day_frac(val1.value, 0.0, factor=factor)\n    else:\n        divisor = u.day.to(val1.unit)\n        return day_frac(val1.value, 0.0, divisor=divisor)",
    ".astropy.units.core.py@@UnitBase.to": "def to(self, other, value=UNITY, equivalencies=[]):\n    if other is self and value is UNITY:\n        return UNITY\n    else:\n        return self._get_converter(Unit(other), equivalencies=equivalencies)(value)",
    ".astropy.time.utils.py@@day_frac": "def day_frac(val1, val2, factor=None, divisor=None):\n    sum12, err12 = two_sum(val1, val2)\n    if factor is not None:\n        sum12, carry = two_product(sum12, factor)\n        carry += err12 * factor\n        sum12, err12 = two_sum(sum12, carry)\n    if divisor is not None:\n        q1 = sum12 / divisor\n        p1, p2 = two_product(q1, divisor)\n        d1, d2 = two_sum(sum12, -p1)\n        d2 += err12\n        d2 -= p2\n        q2 = (d1 + d2) / divisor\n        sum12, err12 = two_sum(q1, q2)\n    day = np.round(sum12)\n    extra, frac = two_sum(sum12, -day)\n    frac += extra + err12\n    excess = np.round(frac)\n    day += excess\n    extra, frac = two_sum(sum12, -day)\n    frac += extra + err12\n    return (day, frac)",
    ".astropy.time.utils.py@@two_sum": "def two_sum(a, b):\n    x = a + b\n    eb = x - a\n    ea = x - eb\n    eb = b - eb\n    ea = a - ea\n    return (x, ea + eb)",
    ".astropy.time.formats.py@@TimeFormat.asarray_or_scalar": "def asarray_or_scalar(val):\n    return np.asarray(val) if isinstance(val, np.ndarray) else val",
    ".astropy.time.formats.py@@TimeJD.set_jds": "def set_jds(self, val1, val2):\n    self._check_scale(self._scale)\n    self.jd1, self.jd2 = day_frac(val1, val2)",
    ".astropy.time.formats.py@@TimeFormat._check_scale": "def _check_scale(self, scale):\n    if scale is None:\n        scale = self._default_scale\n    if scale not in TIME_SCALES:\n        raise ScaleValueError(\"Scale value '{}' not in allowed values {}\".format(scale, TIME_SCALES))\n    return scale",
    ".astropy.time.formats.py@@TimeFormat.jd1": "def jd1(self):\n    return self._jd1",
    ".astropy.time.formats.py@@_validate_jd_for_storage": "def _validate_jd_for_storage(jd):\n    if isinstance(jd, (float, int)):\n        return np.array(jd, dtype=np.float_)\n    if isinstance(jd, np.generic) and (jd.dtype.kind == 'f' and jd.dtype.itemsize <= 8 or jd.dtype.kind in 'iu'):\n        return np.array(jd, dtype=np.float_)\n    elif isinstance(jd, np.ndarray) and jd.dtype.kind == 'f' and (jd.dtype.itemsize == 8):\n        return jd\n    else:\n        raise TypeError(f'JD values must be arrays (possibly zero-dimensional) of floats but we got {jd!r} of type {type(jd)}')",
    ".astropy.time.formats.py@@TimeFormat.jd2": "def jd2(self):\n    return self._jd2",
    ".astropy.time.formats.py@@_broadcast_writeable": "def _broadcast_writeable(jd1, jd2):\n    if jd1.shape == jd2.shape:\n        return (jd1, jd2)\n    shape = np.broadcast(jd1, jd2).shape\n    if jd1.shape == shape:\n        s_jd1 = jd1\n    else:\n        s_jd1 = np.require(np.broadcast_to(jd1, shape), requirements=['C', 'W'])\n    if jd2.shape == shape:\n        s_jd2 = jd2\n    else:\n        s_jd2 = np.require(np.broadcast_to(jd2, shape), requirements=['C', 'W'])\n    return (s_jd1, s_jd2)",
    ".astropy.time.core.py@@TimeBase.scale": "def scale(self):\n    return self._time.scale",
    ".astropy.table.table.py@@Table.__setitem__": "def __setitem__(self, item, value):\n    if isinstance(item, str) and item not in self.colnames:\n        self.add_column(value, name=item, copy=True)\n    else:\n        n_cols = len(self.columns)\n        if isinstance(item, str):\n            if not getattr(self, '_setitem_inplace', False) and (not conf.replace_inplace):\n                try:\n                    self._replace_column_warnings(item, value)\n                    return\n                except Exception:\n                    pass\n            self.columns[item][:] = value\n        elif isinstance(item, (int, np.integer)):\n            self._set_row(idx=item, colnames=self.colnames, vals=value)\n        elif isinstance(item, slice) or isinstance(item, np.ndarray) or isinstance(item, list) or (isinstance(item, tuple) and all((isinstance(x, np.ndarray) for x in item))):\n            if isinstance(value, Table):\n                vals = (col for col in value.columns.values())\n            elif isinstance(value, np.ndarray) and value.dtype.names:\n                vals = (value[name] for name in value.dtype.names)\n            elif np.isscalar(value):\n                vals = itertools.repeat(value, n_cols)\n            else:\n                if len(value) != n_cols:\n                    raise ValueError('Right side value needs {} elements (one for each column)'.format(n_cols))\n                vals = value\n            for col, val in zip(self.columns.values(), vals):\n                col[item] = val\n        else:\n            raise ValueError(f'Illegal type {type(item)} for table item access')",
    ".astropy.table.table.py@@Table._replace_column_warnings": "def _replace_column_warnings(self, name, col):\n    warns = conf.replace_warnings\n    refcount = None\n    old_col = None\n    if 'refcount' in warns and name in self.colnames:\n        refcount = sys.getrefcount(self[name])\n    if name in self.colnames:\n        old_col = self[name]\n    self.replace_column(name, col)\n    if 'always' in warns:\n        warnings.warn(f\"replaced column '{name}'\", TableReplaceWarning, stacklevel=3)\n    if 'slice' in warns:\n        try:\n            if isinstance(old_col.base, old_col.__class__):\n                msg = \"replaced column '{}' which looks like an array slice. The new column no longer shares memory with the original array.\".format(name)\n                warnings.warn(msg, TableReplaceWarning, stacklevel=3)\n        except AttributeError:\n            pass\n    if 'refcount' in warns:\n        new_refcount = sys.getrefcount(self[name])\n        if refcount != new_refcount:\n            msg = \"replaced column '{}' and the number of references to the column changed.\".format(name)\n            warnings.warn(msg, TableReplaceWarning, stacklevel=3)\n    if 'attributes' in warns:\n        changed_attrs = []\n        new_col = self[name]\n        for attr in DataInfo.attr_names:\n            if getattr(old_col.info, attr) != getattr(new_col.info, attr):\n                changed_attrs.append(attr)\n        if changed_attrs:\n            msg = \"replaced column '{}' and column attributes {} changed.\".format(name, changed_attrs)\n            warnings.warn(msg, TableReplaceWarning, stacklevel=3)",
    ".astropy.extern.configobj.validate.py@@is_string_list": "def is_string_list(value, min=None, max=None):\n    if isinstance(value, string_type):\n        raise VdtTypeError(value)\n    return [is_string(mem) for mem in is_list(value, min, max)]",
    ".astropy.extern.configobj.validate.py@@is_list": "def is_list(value, min=None, max=None):\n    min_len, max_len = _is_num_param(('min', 'max'), (min, max))\n    if isinstance(value, string_type):\n        raise VdtTypeError(value)\n    try:\n        num_members = len(value)\n    except TypeError:\n        raise VdtTypeError(value)\n    if min_len is not None and num_members < min_len:\n        raise VdtValueTooShortError(value)\n    if max_len is not None and num_members > max_len:\n        raise VdtValueTooLongError(value)\n    return list(value)",
    ".astropy.table.table.py@@Table.replace_column": "def replace_column(self, name, col, copy=True):\n    if name not in self.colnames:\n        raise ValueError(f'column name {name} is not in the table')\n    if self[name].info.indices:\n        raise ValueError('cannot replace a table index column')\n    col = self._convert_data_to_col(col, name=name, copy=copy)\n    self._set_col_parent_table_and_mask(col)\n    if len(self.columns) > 1 and len(col) != len(self[name]):\n        raise ValueError('length of new column must match table length')\n    self.columns.__setitem__(name, col, validated=True)",
    ".astropy.utils.shapes.py@@ShapedLikeNDArray.__getitem__": "def __getitem__(self, item):\n    try:\n        return self._apply('__getitem__', item)\n    except IndexError:\n        if self.isscalar:\n            raise TypeError('scalar {!r} object is not subscriptable.'.format(self.__class__.__name__))\n        else:\n            raise",
    ".astropy.time.core.py@@TimeBase._apply": "def _apply(self, method, *args, format=None, cls=None, **kwargs):\n    new_format = self.format if format is None else format\n    if callable(method):\n        apply_method = lambda array: method(array, *args, **kwargs)\n    elif method == 'replicate':\n        apply_method = None\n    else:\n        apply_method = operator.methodcaller(method, *args, **kwargs)\n    jd1, jd2 = (self._time.jd1, self._time.jd2)\n    if apply_method:\n        jd1 = apply_method(jd1)\n        jd2 = apply_method(jd2)\n    tm = super().__new__(cls or self.__class__)\n    tm._time = TimeJD(jd1, jd2, self.scale, precision=0, in_subfmt='*', out_subfmt='*', from_jd=True)\n    for attr in ('_delta_ut1_utc', '_delta_tdb_tt', 'location'):\n        try:\n            val = getattr(self, attr)\n        except AttributeError:\n            continue\n        if apply_method:\n            if getattr(val, 'shape', ()):\n                val = apply_method(val)\n            elif method == 'copy' or method == 'flatten':\n                val = copy.copy(val)\n        setattr(tm, attr, val)\n    if 'info' in self.__dict__:\n        tm.info = self.info\n    if new_format not in tm.FORMATS:\n        raise ValueError(f'format must be one of {list(tm.FORMATS)}')\n    NewFormat = tm.FORMATS[new_format]\n    tm._time = NewFormat(tm._time.jd1, tm._time.jd2, tm._time._scale, precision=self.precision, in_subfmt=NewFormat._get_allowed_subfmt(self.in_subfmt), out_subfmt=NewFormat._get_allowed_subfmt(self.out_subfmt), from_jd=True)\n    tm._format = new_format\n    tm.SCALES = self.SCALES\n    return tm",
    ".astropy.time.core.py@@TimeBase.format": "def format(self):\n    return self._format",
    ".astropy.time.core.py@@TimeBase.__getattr__": "def __getattr__(self, attr):\n    if attr in self.SCALES and self.scale is not None:\n        cache = self.cache['scale']\n        if attr not in cache:\n            if attr == self.scale:\n                tm = self\n            else:\n                tm = self.replicate()\n                tm._set_scale(attr)\n                if tm.shape:\n                    tm.writeable = False\n            cache[attr] = tm\n        return cache[attr]\n    elif attr in self.FORMATS:\n        return self.to_value(attr, subfmt=None)\n    elif attr in TIME_SCALES:\n        if self.scale is None:\n            raise ScaleValueError('Cannot convert TimeDelta with undefined scale to any defined scale.')\n        else:\n            raise ScaleValueError(\"Cannot convert {} with scale '{}' to scale '{}'\".format(self.__class__.__name__, self.scale, attr))\n    else:\n        return self.__getattribute__(attr)",
    ".astropy.time.core.py@@TimeBase.precision": "def precision(self):\n    return self._time.precision",
    ".astropy.time.core.py@@TimeBase.in_subfmt": "def in_subfmt(self):\n    return self._time.in_subfmt",
    ".astropy.time.formats.py@@TimeFormat._get_allowed_subfmt": "def _get_allowed_subfmt(cls, subfmt):\n    try:\n        cls._select_subfmts(subfmt)\n    except ValueError:\n        subfmt = '*'\n    return subfmt",
    ".astropy.time.core.py@@TimeBase.out_subfmt": "def out_subfmt(self):\n    return self._time.out_subfmt",
    ".astropy.table.column.py@@col_copy": "def col_copy(col, copy_indices=True):\n    if isinstance(col, BaseColumn):\n        return col.copy()\n    newcol = col.copy() if hasattr(col, 'copy') else deepcopy(col)\n    if 'info' in col.__dict__:\n        newcol.info = col.info\n        if copy_indices and col.info.indices:\n            newcol.info.indices = deepcopy(col.info.indices)\n            for index in newcol.info.indices:\n                index.replace_col(col, newcol)\n    return newcol",
    ".astropy.time.core.py@@TimeBase.copy": "def copy(self, format=None):\n    return self._apply('copy', format=format)",
    ".astropy.time.core.py@@TimeInfo.__init__": "def __init__(self, bound=False):\n    super().__init__(bound)\n    if bound:\n        self.serialize_method = {'fits': 'jd1_jd2', 'ecsv': 'formatted_value', 'hdf5': 'jd1_jd2', 'yaml': 'jd1_jd2', 'parquet': 'jd1_jd2', None: 'jd1_jd2'}",
    ".astropy.utils.shapes.py@@ShapedLikeNDArray.__len__": "def __len__(self):\n    if self.isscalar:\n        raise TypeError('Scalar {!r} object has no len()'.format(self.__class__.__name__))\n    return self.shape[0]",
    ".astropy.utils.shapes.py@@ShapedLikeNDArray.isscalar": "def isscalar(self):\n    return self.shape == ()",
    ".astropy.time.core.py@@TimeBase.shape": "def shape(self):\n    return self._time.jd1.shape",
    ".astropy.io.fits.fitstime.py@@_get_info_if_time_column": "def _get_info_if_time_column(col, global_info):\n    if col.info.name.upper() == 'TIME' and col.info.unit in FITS_TIME_UNIT:\n        column_info = {'scale': global_info['scale'], 'format': global_info['format'], 'ref_time': global_info['ref_time'], 'location': None}\n        if global_info['TREFPOS'] == 'TOPOCENTER':\n            column_info['location'] = global_info['location']\n            if column_info['location'] is None:\n                warnings.warn('Time column \"{}\" reference position will be ignored due to unspecified observatory position.'.format(col.info.name), AstropyUserWarning)\n        return column_info\n    return None",
    ".astropy.table.table.py@@TableColumns._rename_column": "def _rename_column(self, name, new_name):\n    if name == new_name:\n        return\n    if new_name in self:\n        raise KeyError(f'Column {new_name} already exists')\n    parent_table = self[name].info.parent_table\n    if parent_table is not None:\n        parent_table.pprint_exclude_names._rename(name, new_name)\n        parent_table.pprint_include_names._rename(name, new_name)\n    mapper = {name: new_name}\n    new_names = [mapper.get(name, name) for name in self]\n    cols = list(self.values())\n    self.clear()\n    self.update(list(zip(new_names, cols)))",
    ".astropy.time.core.py@@TimeDeltaInfo._construct_from_dict": "def _construct_from_dict(self, map):\n    return self._construct_from_dict_base(map)",
    ".astropy.time.core.py@@TimeInfo._construct_from_dict_base": "def _construct_from_dict_base(self, map):\n    if 'jd1' in map and 'jd2' in map:\n        format = map.pop('format')\n        out_subfmt = map.pop('out_subfmt', None)\n        map['format'] = 'jd'\n        map['val'] = map.pop('jd1')\n        map['val2'] = map.pop('jd2')\n        out = self._parent_cls(**map)\n        out.format = format\n        if out_subfmt is not None:\n            out.out_subfmt = out_subfmt\n    else:\n        map['val'] = map.pop('value')\n        out = self._parent_cls(**map)\n    return out",
    ".astropy.time.core.py@@TimeDelta.__new__": "def __new__(cls, val, val2=None, format=None, scale=None, precision=None, in_subfmt=None, out_subfmt=None, location=None, copy=False):\n    if isinstance(val, TimeDelta):\n        self = val.replicate(format=format, copy=copy, cls=cls)\n    else:\n        self = super().__new__(cls)\n    return self",
    ".astropy.time.core.py@@TimeDelta.__init__": "def __init__(self, val, val2=None, format=None, scale=None, copy=False):\n    if isinstance(val, TimeDelta):\n        if scale is not None:\n            self._set_scale(scale)\n    else:\n        format = format or self._get_format(val)\n        self._init_from_vals(val, val2, format, scale, copy)\n        if scale is not None:\n            self.SCALES = TIME_DELTA_TYPES[scale]",
    ".astropy.time.formats.py@@TimeDeltaNumeric.set_jds": "def set_jds(self, val1, val2):\n    self._check_scale(self._scale)\n    self.jd1, self.jd2 = day_frac(val1, val2, divisor=1.0 / self.unit)",
    ".astropy.time.formats.py@@TimeDeltaFormat._check_scale": "def _check_scale(self, scale):\n    if scale is not None and scale not in TIME_DELTA_SCALES:\n        raise ScaleValueError(\"Scale value '{}' not in allowed values {}\".format(scale, TIME_DELTA_SCALES))\n    return scale",
    ".astropy.time.utils.py@@two_product": "def two_product(a, b):\n    x = a * b\n    ah, al = split(a)\n    bh, bl = split(b)\n    y1 = ah * bh\n    y = x - y1\n    y2 = al * bh\n    y -= y2\n    y3 = ah * bl\n    y -= y3\n    y4 = al * bl\n    y = y4 - y\n    return (x, y)",
    ".astropy.time.utils.py@@split": "def split(a):\n    c = 134217729.0 * a\n    abig = c - a\n    ah = c - abig\n    al = a - ah\n    return (ah, al)",
    ".astropy.io.misc.yaml.py@@_time_constructor": "def _time_constructor(loader, node):\n    map = loader.construct_mapping(node)\n    out = Time.info._construct_from_dict(map)\n    return out",
    ".astropy.time.core.py@@TimeInfo._construct_from_dict": "def _construct_from_dict(self, map):\n    delta_ut1_utc = map.pop('_delta_ut1_utc', None)\n    delta_tdb_tt = map.pop('_delta_tdb_tt', None)\n    out = self._construct_from_dict_base(map)\n    if delta_ut1_utc is not None:\n        out._delta_ut1_utc = delta_ut1_utc\n    if delta_tdb_tt is not None:\n        out._delta_tdb_tt = delta_tdb_tt\n    return out",
    ".astropy.time.core.py@@TimeBase.cache": "def cache(self):\n    return self._time.cache",
    ".astropy.io.misc.yaml.py@@constructor": "def constructor(loader, node):\n    map = loader.construct_mapping(node)\n    return cls.info._construct_from_dict(map)",
    ".astropy.coordinates.angles.py@@Angle.__new__": "def __new__(cls, angle, unit=None, dtype=None, copy=True, **kwargs):\n    if not isinstance(angle, u.Quantity):\n        if unit is not None:\n            unit = cls._convert_unit_to_angle_unit(u.Unit(unit))\n        if isinstance(angle, tuple):\n            angle = cls._tuple_to_float(angle, unit)\n        elif isinstance(angle, str):\n            angle, angle_unit = form.parse_angle(angle, unit)\n            if angle_unit is None:\n                angle_unit = unit\n            if isinstance(angle, tuple):\n                angle = cls._tuple_to_float(angle, angle_unit)\n            if angle_unit is not unit:\n                angle = u.Quantity(angle, angle_unit, copy=False)\n        elif isiterable(angle) and (not (isinstance(angle, np.ndarray) and angle.dtype.kind not in 'SUVO')):\n            angle = [Angle(x, unit, copy=False) for x in angle]\n    return super().__new__(cls, angle, unit, dtype=dtype, copy=copy, **kwargs)",
    ".astropy.coordinates.angles.py@@Angle._convert_unit_to_angle_unit": "def _convert_unit_to_angle_unit(unit):\n    return u.hourangle if unit is u.hour else unit",
    ".astropy.coordinates.angles.py@@Angle._set_unit": "def _set_unit(self, unit):\n    super()._set_unit(self._convert_unit_to_angle_unit(unit))",
    ".astropy.units.quantity.py@@SpecificTypeQuantity._set_unit": "def _set_unit(self, unit):\n    if unit is None or not unit.is_equivalent(self._equivalent_unit):\n        raise UnitTypeError(\"{} instances require units equivalent to '{}'\".format(type(self).__name__, self._equivalent_unit) + (', but no unit was given.' if unit is None else f\", so cannot set it to '{unit}'.\"))\n    super()._set_unit(unit)",
    ".astropy.units.core.py@@UnitBase.is_equivalent": "def is_equivalent(self, other, equivalencies=[]):\n    equivalencies = self._normalize_equivalencies(equivalencies)\n    if isinstance(other, tuple):\n        return any((self.is_equivalent(u, equivalencies=equivalencies) for u in other))\n    other = Unit(other, parse_strict='silent')\n    return self._is_equivalent(other, equivalencies)",
    ".astropy.units.core.py@@UnitBase._normalize_equivalencies": "def _normalize_equivalencies(equivalencies):\n    normalized = _normalize_equivalencies(equivalencies)\n    if equivalencies is not None:\n        normalized += get_current_unit_registry().equivalencies\n    return normalized",
    ".astropy.units.core.py@@_normalize_equivalencies": "def _normalize_equivalencies(equivalencies):\n    if equivalencies is None:\n        return []\n    normalized = []\n    for i, equiv in enumerate(equivalencies):\n        if len(equiv) == 2:\n            funit, tunit = equiv\n            a = b = lambda x: x\n        elif len(equiv) == 3:\n            funit, tunit, a = equiv\n            b = a\n        elif len(equiv) == 4:\n            funit, tunit, a, b = equiv\n        else:\n            raise ValueError(f'Invalid equivalence entry {i}: {equiv!r}')\n        if not (funit is Unit(funit) and (tunit is None or tunit is Unit(tunit)) and callable(a) and callable(b)):\n            raise ValueError(f'Invalid equivalence entry {i}: {equiv!r}')\n        normalized.append((funit, tunit, a, b))\n    return normalized",
    ".astropy.units.core.py@@_UnitRegistry.equivalencies": "def equivalencies(self):\n    return list(self._equivalencies)",
    ".astropy.units.core.py@@UnitBase._is_equivalent": "def _is_equivalent(self, other, equivalencies=[]):\n    if isinstance(other, UnrecognizedUnit):\n        return False\n    if self._get_physical_type_id() == other._get_physical_type_id():\n        return True\n    elif len(equivalencies):\n        unit = self.decompose()\n        other = other.decompose()\n        for a, b, forward, backward in equivalencies:\n            if b is None:\n                try:\n                    (other / unit).decompose([a])\n                    return True\n                except Exception:\n                    pass\n            elif a._is_equivalent(unit) and b._is_equivalent(other) or (b._is_equivalent(unit) and a._is_equivalent(other)):\n                return True\n    return False",
    ".astropy.coordinates.angles.py@@Latitude.__new__": "def __new__(cls, angle, unit=None, **kwargs):\n    if isinstance(angle, Longitude):\n        raise TypeError('A Latitude angle cannot be created from a Longitude angle')\n    self = super().__new__(cls, angle, unit=unit, **kwargs)\n    self._validate_angles()\n    return self",
    ".astropy.coordinates.angles.py@@Latitude._validate_angles": "def _validate_angles(self, angles=None):\n    if angles is None:\n        angles = self\n    lower = u.degree.to(angles.unit, -90.0)\n    upper = u.degree.to(angles.unit, 90.0)\n    with np.errstate(invalid='ignore'):\n        invalid_angles = np.any(angles.value < lower) or np.any(angles.value > upper)\n    if invalid_angles:\n        raise ValueError('Latitude angle(s) must be within -90 deg <= angle <= 90 deg, got {}'.format(angles.to(u.degree)))",
    ".astropy.units.core.py@@UnitBase._get_converter": "def _get_converter(self, other, equivalencies=[]):\n    try:\n        scale = self._to(other)\n    except UnitsError:\n        pass\n    else:\n        if scale == 1.0:\n            return unit_scale_converter\n        else:\n            return lambda val: scale * _condition_arg(val)\n    try:\n        return self._apply_equivalencies(self, other, self._normalize_equivalencies(equivalencies))\n    except UnitsError as exc:\n        if hasattr(other, 'equivalencies'):\n            for funit, tunit, a, b in other.equivalencies:\n                if other is funit:\n                    try:\n                        return lambda v: b(self._get_converter(tunit, equivalencies=equivalencies)(v))\n                    except Exception:\n                        pass\n        raise exc",
    ".astropy.units.core.py@@unit_scale_converter": "def unit_scale_converter(val):\n    return 1.0 * _condition_arg(val)",
    ".astropy.units.core.py@@_condition_arg": "def _condition_arg(value):\n    if isinstance(value, (np.ndarray, float, int, complex, np.void)):\n        return value\n    avalue = np.array(value)\n    if avalue.dtype.kind not in ['i', 'f', 'c']:\n        raise ValueError('Value not scalar compatible or convertible to an int, float, or complex array')\n    return avalue",
    ".astropy.coordinates.angles.py@@Longitude.__new__": "def __new__(cls, angle, unit=None, wrap_angle=None, **kwargs):\n    if isinstance(angle, Latitude):\n        raise TypeError('A Longitude angle cannot be created from a Latitude angle.')\n    self = super().__new__(cls, angle, unit=unit, **kwargs)\n    if wrap_angle is None:\n        wrap_angle = getattr(angle, 'wrap_angle', self._default_wrap_angle)\n    self.wrap_angle = wrap_angle\n    return self",
    ".astropy.coordinates.angles.py@@Longitude.__array_finalize__": "def __array_finalize__(self, obj):\n    super().__array_finalize__(obj)\n    self._wrap_angle = getattr(obj, '_wrap_angle', self._default_wrap_angle)",
    ".astropy.coordinates.angles.py@@Longitude.wrap_angle": "def wrap_angle(self):\n    return self._wrap_angle",
    ".astropy.coordinates.angles.py@@Angle._wrap_at": "def _wrap_at(self, wrap_angle):\n    a360 = u.degree.to(self.unit, 360.0)\n    wrap_angle = wrap_angle.to_value(self.unit)\n    wrap_angle_floor = wrap_angle - a360\n    self_angle = self.view(np.ndarray)\n    with np.errstate(invalid='ignore'):\n        wraps = (self_angle - wrap_angle_floor) // a360\n        np.nan_to_num(wraps, copy=False)\n        if np.any(wraps != 0):\n            self_angle -= wraps * a360\n            self_angle[self_angle >= wrap_angle] -= a360\n            self_angle[self_angle < wrap_angle_floor] += a360",
    ".astropy.coordinates.sky_coordinate.py@@SkyCoord.__init__": "def __init__(self, *args, copy=True, **kwargs):\n    self._extra_frameattr_names = set()\n    if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], (BaseCoordinateFrame, SkyCoord)):\n        coords = args[0]\n        if isinstance(coords, SkyCoord):\n            self._extra_frameattr_names = coords._extra_frameattr_names\n            self.info = coords.info\n            for attr_name in self._extra_frameattr_names:\n                setattr(self, attr_name, getattr(coords, attr_name))\n            coords = coords.frame\n        if not coords.has_data:\n            raise ValueError('Cannot initialize from a coordinate frame instance without coordinate data')\n        if copy:\n            self._sky_coord_frame = coords.copy()\n        else:\n            self._sky_coord_frame = coords\n    else:\n        frame_cls, frame_kwargs = _get_frame_without_data(args, kwargs)\n        args = list(args)\n        skycoord_kwargs, components, info = _parse_coordinate_data(frame_cls(**frame_kwargs), args, kwargs)\n        for attr in skycoord_kwargs:\n            setattr(self, attr, skycoord_kwargs[attr])\n        if info is not None:\n            self.info = info\n        frame_kwargs.update(components)\n        self._sky_coord_frame = frame_cls(copy=copy, **frame_kwargs)\n        if not self._sky_coord_frame.has_data:\n            raise ValueError('Cannot create a SkyCoord without data')",
    ".astropy.coordinates.sky_coordinate.py@@SkyCoord.__setattr__": "def __setattr__(self, attr, val):\n    if '_sky_coord_frame' in self.__dict__:\n        if self._is_name(attr):\n            raise AttributeError(f\"'{attr}' is immutable\")\n        if not attr.startswith('_') and hasattr(self._sky_coord_frame, attr):\n            setattr(self._sky_coord_frame, attr, val)\n            return\n        frame_cls = frame_transform_graph.lookup_name(attr)\n        if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n            raise AttributeError(f\"'{attr}' is immutable\")\n    if attr in frame_transform_graph.frame_attributes:\n        super().__setattr__('_' + attr, val)\n        frame_transform_graph.frame_attributes[attr].__get__(self)\n        self._extra_frameattr_names |= {attr}\n    else:\n        super().__setattr__(attr, val)",
    ".astropy.coordinates.transformations.py@@TransformGraph.frame_attributes": "def frame_attributes(self):\n    if self._cached_frame_attributes is None:\n        self._cached_frame_attributes = frame_attrs_from_set(self.frame_set)\n    return self._cached_frame_attributes",
    ".astropy.coordinates.sky_coordinate_parsers.py@@_get_frame_without_data": "def _get_frame_without_data(args, kwargs):\n    from .sky_coordinate import SkyCoord\n    frame_cls = None\n    frame_cls_kwargs = {}\n    frame = kwargs.pop('frame', None)\n    if frame is not None:\n        if isinstance(frame, SkyCoord):\n            for attr in frame._extra_frameattr_names:\n                if attr in kwargs and np.any(getattr(frame, attr) != kwargs[attr]):\n                    raise ValueError(_conflict_err_msg.format(attr, getattr(frame, attr), kwargs[attr], 'SkyCoord'))\n                else:\n                    kwargs[attr] = getattr(frame, attr)\n            frame = frame.frame\n        if isinstance(frame, BaseCoordinateFrame):\n            for attr in frame.get_frame_attr_names():\n                if attr in kwargs:\n                    raise ValueError(\"Cannot specify frame attribute '{}' directly as an argument to SkyCoord because a frame instance was passed in. Either pass a frame class, or modify the frame attributes of the input frame instance.\".format(attr))\n                elif not frame.is_frame_attr_default(attr):\n                    kwargs[attr] = getattr(frame, attr)\n            frame_cls = frame.__class__\n            kwargs.setdefault('representation_type', frame.representation_type)\n            kwargs.setdefault('differential_type', frame.differential_type)\n        if frame_cls is None:\n            frame_cls = _get_frame_class(frame)\n    for arg in args:\n        if isinstance(arg, (Sequence, np.ndarray)) and len(args) == 1 and (len(arg) > 0):\n            arg = arg[0]\n        coord_frame_obj = coord_frame_cls = None\n        if isinstance(arg, BaseCoordinateFrame):\n            coord_frame_obj = arg\n        elif isinstance(arg, SkyCoord):\n            coord_frame_obj = arg.frame\n        if coord_frame_obj is not None:\n            coord_frame_cls = coord_frame_obj.__class__\n            frame_diff = coord_frame_obj.get_representation_cls('s')\n            if frame_diff is not None:\n                kwargs.setdefault('differential_type', frame_diff)\n            for attr in coord_frame_obj.get_frame_attr_names():\n                if attr in kwargs and (not coord_frame_obj.is_frame_attr_default(attr)) and np.any(kwargs[attr] != getattr(coord_frame_obj, attr)):\n                    raise ValueError(\"Frame attribute '{}' has conflicting values between the input coordinate data and either keyword arguments or the frame specification (frame=...): {} =/= {}\".format(attr, getattr(coord_frame_obj, attr), kwargs[attr]))\n                elif attr not in kwargs and (not coord_frame_obj.is_frame_attr_default(attr)):\n                    kwargs[attr] = getattr(coord_frame_obj, attr)\n        if coord_frame_cls is not None:\n            if frame_cls is None:\n                frame_cls = coord_frame_cls\n            elif frame_cls is not coord_frame_cls:\n                raise ValueError(\"Cannot override frame='{}' of input coordinate with new frame='{}'. Instead, transform the coordinate.\".format(coord_frame_cls.__name__, frame_cls.__name__))\n    if frame_cls is None:\n        frame_cls = ICRS\n    if not issubclass(frame_cls, BaseCoordinateFrame):\n        raise ValueError(f'Frame class has unexpected type: {frame_cls.__name__}')\n    for attr in frame_cls.frame_attributes:\n        if attr in kwargs:\n            frame_cls_kwargs[attr] = kwargs.pop(attr)\n    if 'representation_type' in kwargs:\n        frame_cls_kwargs['representation_type'] = _get_repr_cls(kwargs.pop('representation_type'))\n    differential_type = kwargs.pop('differential_type', None)\n    if differential_type is not None:\n        frame_cls_kwargs['differential_type'] = _get_diff_cls(differential_type)\n    return (frame_cls, frame_cls_kwargs)",
    ".astropy.coordinates.sky_coordinate_parsers.py@@_get_frame_class": "def _get_frame_class(frame):\n    if isinstance(frame, str):\n        frame_names = frame_transform_graph.get_names()\n        if frame not in frame_names:\n            raise ValueError('Coordinate frame name \"{}\" is not a known coordinate frame ({})'.format(frame, sorted(frame_names)))\n        frame_cls = frame_transform_graph.lookup_name(frame)\n    elif inspect.isclass(frame) and issubclass(frame, BaseCoordinateFrame):\n        frame_cls = frame\n    else:\n        raise ValueError(\"Coordinate frame must be a frame name or frame class, not a '{}'\".format(frame.__class__.__name__))\n    return frame_cls",
    ".astropy.coordinates.transformations.py@@TransformGraph.get_names": "def get_names(self):\n    return list(self._cached_names.keys())",
    ".astropy.coordinates.transformations.py@@TransformGraph._cached_names": "def _cached_names(self):\n    if self._cached_names_dct is None:\n        self._cached_names_dct = dct = {}\n        for c in self.frame_set:\n            nm = getattr(c, 'name', None)\n            if nm is not None:\n                if not isinstance(nm, list):\n                    nm = [nm]\n                for name in nm:\n                    dct[name] = c\n    return self._cached_names_dct",
    ".astropy.coordinates.transformations.py@@TransformGraph.lookup_name": "def lookup_name(self, name):\n    return self._cached_names.get(name, None)",
    ".astropy.coordinates.baseframe.py@@_get_repr_cls": "def _get_repr_cls(value):\n    if value in r.REPRESENTATION_CLASSES:\n        value = r.REPRESENTATION_CLASSES[value]\n    elif not isinstance(value, type) or not issubclass(value, r.BaseRepresentation):\n        raise ValueError('Representation is {!r} but must be a BaseRepresentation class or one of the string aliases {}'.format(value, list(r.REPRESENTATION_CLASSES)))\n    return value",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.__init__": "def __init__(self, *args, copy=True, representation_type=None, differential_type=None, **kwargs):\n    self._attr_names_with_defaults = []\n    self._representation = self._infer_representation(representation_type, differential_type)\n    self._data = self._infer_data(args, copy, kwargs)\n    values = {}\n    for fnm, fdefault in self.get_frame_attr_names().items():\n        if fnm in kwargs:\n            value = kwargs.pop(fnm)\n            setattr(self, '_' + fnm, value)\n            values[fnm] = getattr(self, fnm)\n        else:\n            setattr(self, '_' + fnm, fdefault)\n            self._attr_names_with_defaults.append(fnm)\n    if kwargs:\n        raise TypeError(f'Coordinate frame {self.__class__.__name__} got unexpected keywords: {list(kwargs)}')\n    if self._data is None:\n        shapes = {fnm: value.shape for fnm, value in values.items() if getattr(value, 'shape', ())}\n        if shapes:\n            if len(shapes) > 1:\n                try:\n                    self._no_data_shape = check_broadcast(*shapes.values())\n                except ValueError as err:\n                    raise ValueError(f'non-scalar attributes with inconsistent shapes: {shapes}') from err\n                for fnm in shapes:\n                    getattr(self, fnm)\n            else:\n                self._no_data_shape = shapes.popitem()[1]\n        else:\n            self._no_data_shape = ()\n    if self._data is not None:\n        if 's' in self._data.differentials:\n            key = (self._data.__class__.__name__, self._data.differentials['s'].__class__.__name__, False)\n        else:\n            key = (self._data.__class__.__name__, False)\n        self.cache['representation'][key] = self._data",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.__setattr__": "def __setattr__(self, attr, value):\n    if not attr.startswith('_'):\n        if hasattr(self, 'representation_info'):\n            repr_attr_names = set()\n            for representation_attr in self.representation_info.values():\n                repr_attr_names.update(representation_attr['names'])\n            if attr in repr_attr_names:\n                raise AttributeError(f'Cannot set any frame attribute {attr}')\n    super().__setattr__(attr, value)",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame._infer_representation": "def _infer_representation(self, representation_type, differential_type):\n    if representation_type is None and differential_type is None:\n        return {'base': self.default_representation, 's': self.default_differential}\n    if representation_type is None:\n        representation_type = self.default_representation\n    if inspect.isclass(differential_type) and issubclass(differential_type, r.BaseDifferential):\n        differential_type = {'s': differential_type}\n    elif isinstance(differential_type, str):\n        diff_cls = r.DIFFERENTIAL_CLASSES[differential_type]\n        differential_type = {'s': diff_cls}\n    elif differential_type is None:\n        if representation_type == self.default_representation:\n            differential_type = {'s': self.default_differential}\n        else:\n            differential_type = {'s': 'base'}\n    return _get_repr_classes(representation_type, **differential_type)",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.getter": "def getter(self):\n    return getattr(self, private_attr)",
    ".astropy.coordinates.baseframe.py@@_get_repr_classes": "def _get_repr_classes(base, **differentials):\n    base = _get_repr_cls(base)\n    repr_classes = {'base': base}\n    for name, differential_type in differentials.items():\n        if differential_type == 'base':\n            differential_type = r.DIFFERENTIAL_CLASSES.get(base.get_name(), None)\n        elif differential_type in r.DIFFERENTIAL_CLASSES:\n            differential_type = r.DIFFERENTIAL_CLASSES[differential_type]\n        elif differential_type is not None and (not isinstance(differential_type, type) or not issubclass(differential_type, r.BaseDifferential)):\n            raise ValueError('Differential is {!r} but must be a BaseDifferential class or one of the string aliases {}'.format(differential_type, list(r.DIFFERENTIAL_CLASSES)))\n        repr_classes[name] = differential_type\n    return repr_classes",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame._infer_data": "def _infer_data(self, args, copy, kwargs):\n    representation_data = None\n    differential_data = None\n    args = list(args)\n    if len(args) > 0 and (isinstance(args[0], r.BaseRepresentation) or args[0] is None):\n        representation_data = args.pop(0)\n        if len(args) > 0:\n            raise TypeError('Cannot create a frame with both a representation object and other positional arguments')\n        if representation_data is not None:\n            diffs = representation_data.differentials\n            differential_data = diffs.get('s', None)\n            if differential_data is None and len(diffs) > 0 or (differential_data is not None and len(diffs) > 1):\n                raise ValueError('Multiple differentials are associated with the representation object passed in to the frame initializer. Only a single velocity differential is supported. Got: {}'.format(diffs))\n    else:\n        representation_cls = self.get_representation_cls()\n        repr_kwargs = {}\n        for nmkw, nmrep in self.representation_component_names.items():\n            if len(args) > 0:\n                repr_kwargs[nmrep] = args.pop(0)\n            elif nmkw in kwargs:\n                repr_kwargs[nmrep] = kwargs.pop(nmkw)\n        if repr_kwargs:\n            if repr_kwargs.get('distance', True) is None:\n                del repr_kwargs['distance']\n            if issubclass(representation_cls, r.SphericalRepresentation) and 'distance' not in repr_kwargs:\n                representation_cls = representation_cls._unit_representation\n            try:\n                representation_data = representation_cls(copy=copy, **repr_kwargs)\n            except TypeError as e:\n                try:\n                    representation_data = representation_cls._unit_representation(copy=copy, **repr_kwargs)\n                except Exception:\n                    msg = str(e)\n                    names = self.get_representation_component_names()\n                    for frame_name, repr_name in names.items():\n                        msg = msg.replace(repr_name, frame_name)\n                    msg = msg.replace('__init__()', f'{self.__class__.__name__}()')\n                    e.args = (msg,)\n                    raise e\n        differential_cls = self.get_representation_cls('s')\n        diff_component_names = self.get_representation_component_names('s')\n        diff_kwargs = {}\n        for nmkw, nmrep in diff_component_names.items():\n            if len(args) > 0:\n                diff_kwargs[nmrep] = args.pop(0)\n            elif nmkw in kwargs:\n                diff_kwargs[nmrep] = kwargs.pop(nmkw)\n        if diff_kwargs:\n            if hasattr(differential_cls, '_unit_differential') and 'd_distance' not in diff_kwargs:\n                differential_cls = differential_cls._unit_differential\n            elif len(diff_kwargs) == 1 and 'd_distance' in diff_kwargs:\n                differential_cls = r.RadialDifferential\n            try:\n                differential_data = differential_cls(copy=copy, **diff_kwargs)\n            except TypeError as e:\n                msg = str(e)\n                names = self.get_representation_component_names('s')\n                for frame_name, repr_name in names.items():\n                    msg = msg.replace(repr_name, frame_name)\n                msg = msg.replace('__init__()', f'{self.__class__.__name__}()')\n                e.args = (msg,)\n                raise\n    if len(args) > 0:\n        raise TypeError('{}.__init__ had {} remaining unhandled arguments'.format(self.__class__.__name__, len(args)))\n    if representation_data is None and differential_data is not None:\n        raise ValueError('Cannot pass in differential component data without positional (representation) data.')\n    if differential_data:\n        for comp in representation_data.components:\n            if (diff_comp := f'd_{comp}') in differential_data.components:\n                current_repr_unit = representation_data._units[comp]\n                current_diff_unit = differential_data._units[diff_comp]\n                expected_unit = current_repr_unit / u.s\n                if not current_diff_unit.is_equivalent(expected_unit):\n                    for key, val in self.get_representation_component_names().items():\n                        if val == comp:\n                            current_repr_name = key\n                            break\n                    for key, val in self.get_representation_component_names('s').items():\n                        if val == diff_comp:\n                            current_diff_name = key\n                            break\n                    raise ValueError(f'{current_repr_name} has unit \"{current_repr_unit}\" with physical type \"{current_repr_unit.physical_type}\", but {current_diff_name} has incompatible unit \"{current_diff_unit}\" with physical type \"{current_diff_unit.physical_type}\" instead of the expected \"{expected_unit.physical_type}\".')\n        representation_data = representation_data.with_differentials({'s': differential_data})\n    return representation_data",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.get_representation_cls": "def get_representation_cls(self, which='base'):\n    if which is not None:\n        return self._representation[which]\n    else:\n        return self._representation",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.get_representation_component_names": "def get_representation_component_names(self, which='base'):\n    out = {}\n    repr_or_diff_cls = self.get_representation_cls(which)\n    if repr_or_diff_cls is None:\n        return out\n    data_names = repr_or_diff_cls.attr_classes.keys()\n    repr_names = self.representation_info[repr_or_diff_cls]['names']\n    for repr_name, data_name in zip(repr_names, data_names):\n        out[repr_name] = data_name\n    return out",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.representation_info": "def representation_info(self):\n    return self._get_representation_info()",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame._get_representation_info": "def _get_representation_info(cls):\n    if cls._frame_class_cache.get('last_reprdiff_hash', None) != r.get_reprdiff_cls_hash():\n        repr_attrs = {}\n        for repr_diff_cls in list(r.REPRESENTATION_CLASSES.values()) + list(r.DIFFERENTIAL_CLASSES.values()):\n            repr_attrs[repr_diff_cls] = {'names': [], 'units': []}\n            for c, c_cls in repr_diff_cls.attr_classes.items():\n                repr_attrs[repr_diff_cls]['names'].append(c)\n                rec_unit = u.deg if issubclass(c_cls, Angle) else None\n                repr_attrs[repr_diff_cls]['units'].append(rec_unit)\n        for repr_diff_cls, mappings in cls._frame_specific_representation_info.items():\n            nms = repr_attrs[repr_diff_cls]['names']\n            uns = repr_attrs[repr_diff_cls]['units']\n            comptomap = dict([(m.reprname, m) for m in mappings])\n            for i, c in enumerate(repr_diff_cls.attr_classes.keys()):\n                if c in comptomap:\n                    mapp = comptomap[c]\n                    nms[i] = mapp.framename\n                    if not (isinstance(mapp.defaultunit, str) and mapp.defaultunit == 'recommended'):\n                        uns[i] = mapp.defaultunit\n            repr_attrs[repr_diff_cls]['names'] = tuple(nms)\n            repr_attrs[repr_diff_cls]['units'] = tuple(uns)\n        cls._frame_class_cache['representation_info'] = repr_attrs\n        cls._frame_class_cache['last_reprdiff_hash'] = r.get_reprdiff_cls_hash()\n    return cls._frame_class_cache['representation_info']",
    ".astropy.coordinates.representation.py@@get_reprdiff_cls_hash": "def get_reprdiff_cls_hash():\n    global _REPRDIFF_HASH\n    if _REPRDIFF_HASH is None:\n        _REPRDIFF_HASH = hash(tuple(REPRESENTATION_CLASSES.items())) + hash(tuple(DIFFERENTIAL_CLASSES.items()))\n    return _REPRDIFF_HASH",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.get_frame_attr_names": "def get_frame_attr_names(cls):\n    return {name: getattr(cls, name) for name in cls.frame_attributes}",
    ".astropy.coordinates.attributes.py@@Attribute.__get__": "def __get__(self, instance, frame_cls=None):\n    if instance is None:\n        out = self.default\n    else:\n        out = getattr(instance, '_' + self.name, self.default)\n        if out is None:\n            out = getattr(instance, self.secondary_attribute, self.default)\n    out, converted = self.convert_input(out)\n    if instance is not None:\n        instance_shape = getattr(instance, 'shape', None)\n        if instance_shape is not None and (getattr(out, 'shape', ()) and out.shape != instance_shape):\n            try:\n                if isinstance(out, ShapedLikeNDArray):\n                    out = out._apply(np.broadcast_to, shape=instance_shape, subok=True)\n                else:\n                    out = np.broadcast_to(out, instance_shape, subok=True)\n            except ValueError:\n                raise ValueError('attribute {} should be scalar or have shape {}, but is has shape {} and could not be broadcast.'.format(self.name, instance_shape, out.shape))\n            converted = True\n        if converted:\n            setattr(instance, '_' + self.name, out)\n    return out",
    ".astropy.coordinates.attributes.py@@TimeAttribute.convert_input": "def convert_input(self, value):\n    from astropy.time import Time\n    if value is None:\n        return (None, False)\n    if isinstance(value, Time):\n        out = value\n        converted = False\n    else:\n        try:\n            out = Time(value)\n        except Exception as err:\n            raise ValueError(f'Invalid time input {self.name}={value!r}.') from err\n        converted = True\n    if out.shape:\n        out.writeable = False\n    return (out, converted)",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.shape": "def shape(self):\n    return self.data.shape if self.has_data else self._no_data_shape",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.has_data": "def has_data(self):\n    return self._data is not None",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.__getattr__": "def __getattr__(self, attr):\n    if attr.startswith('_'):\n        return self.__getattribute__(attr)\n    repr_names = self.representation_component_names\n    if attr in repr_names:\n        if self._data is None:\n            self.data\n        rep = self.represent_as(self.representation_type, in_frame_units=True)\n        val = getattr(rep, repr_names[attr])\n        return val\n    diff_names = self.get_representation_component_names('s')\n    if attr in diff_names:\n        if self._data is None:\n            self.data\n        rep = self.represent_as(in_frame_units=True, **self.get_representation_cls(None))\n        val = getattr(rep.differentials['s'], diff_names[attr])\n        return val\n    return self.__getattribute__(attr)",
    ".astropy.coordinates.sky_coordinate_parsers.py@@_parse_coordinate_data": "def _parse_coordinate_data(frame, args, kwargs):\n    valid_skycoord_kwargs = {}\n    valid_components = {}\n    info = None\n    attr_names = list(kwargs.keys())\n    for attr in attr_names:\n        if attr in frame_transform_graph.frame_attributes:\n            valid_skycoord_kwargs[attr] = kwargs.pop(attr)\n    units = _get_representation_component_units(args, kwargs)\n    valid_components.update(_get_representation_attrs(frame, units, kwargs))\n    if kwargs:\n        pm_message = ''\n        if frame.representation_type == SphericalRepresentation:\n            frame_names = list(frame.get_representation_component_names().keys())\n            lon_name = frame_names[0]\n            lat_name = frame_names[1]\n            if f'pm_{lon_name}' in list(kwargs.keys()):\n                pm_message = '\\n\\n By default, most frame classes expect the longitudinal proper motion to include the cos(latitude) term, named `pm_{}_cos{}`. Did you mean to pass in this component?'.format(lon_name, lat_name)\n        raise ValueError('Unrecognized keyword argument(s) {}{}'.format(', '.join((f\"'{key}'\" for key in kwargs)), pm_message))\n    if args:\n        if len(args) == 1:\n            _skycoord_kwargs, _components = _parse_coordinate_arg(args[0], frame, units, kwargs)\n            if 'info' in getattr(args[0], '__dict__', ()):\n                info = args[0].info\n        elif len(args) <= 3:\n            _skycoord_kwargs = {}\n            _components = {}\n            frame_attr_names = frame.representation_component_names.keys()\n            repr_attr_names = frame.representation_component_names.values()\n            for arg, frame_attr_name, repr_attr_name, unit in zip(args, frame_attr_names, repr_attr_names, units):\n                attr_class = frame.representation_type.attr_classes[repr_attr_name]\n                _components[frame_attr_name] = attr_class(arg, unit=unit)\n        else:\n            raise ValueError('Must supply no more than three positional arguments, got {}'.format(len(args)))\n        for attr, coord_value in _components.items():\n            if attr in valid_components:\n                raise ValueError(_conflict_err_msg.format(attr, coord_value, valid_components[attr], 'SkyCoord'))\n            valid_components[attr] = coord_value\n        for attr, value in _skycoord_kwargs.items():\n            if attr in valid_skycoord_kwargs and np.any(valid_skycoord_kwargs[attr] != value):\n                raise ValueError(_conflict_err_msg.format(attr, value, valid_skycoord_kwargs[attr], 'SkyCoord'))\n            valid_skycoord_kwargs[attr] = value\n    return (valid_skycoord_kwargs, valid_components, info)",
    ".astropy.coordinates.sky_coordinate_parsers.py@@_get_representation_component_units": "def _get_representation_component_units(args, kwargs):\n    if 'unit' not in kwargs:\n        units = [None, None, None]\n    else:\n        units = kwargs.pop('unit')\n        if isinstance(units, str):\n            units = [x.strip() for x in units.split(',')]\n            if len(units) == 1:\n                units = [units[0], units[0], units[0]]\n        elif isinstance(units, (Unit, IrreducibleUnit)):\n            units = [units, units, units]\n        try:\n            units = [Unit(x) if x else None for x in units]\n            units.extend((None for x in range(3 - len(units))))\n            if len(units) > 3:\n                raise ValueError()\n        except Exception as err:\n            raise ValueError('Unit keyword must have one to three unit values as tuple or comma-separated string.') from err\n    return units",
    ".astropy.coordinates.sky_coordinate_parsers.py@@_get_representation_attrs": "def _get_representation_attrs(frame, units, kwargs):\n    frame_attr_names = frame.representation_component_names.keys()\n    repr_attr_classes = frame.representation_type.attr_classes.values()\n    valid_kwargs = {}\n    for frame_attr_name, repr_attr_class, unit in zip(frame_attr_names, repr_attr_classes, units):\n        value = kwargs.pop(frame_attr_name, None)\n        if value is not None:\n            try:\n                valid_kwargs[frame_attr_name] = repr_attr_class(value, unit=unit)\n            except u.UnitConversionError as err:\n                error_message = f\"Unit '{unit}' ({unit.physical_type}) could not be applied to '{frame_attr_name}'. This can occur when passing units for some coordinate components when other components are specified as Quantity objects. Either pass a list of units for all components (and unit-less coordinate data), or pass Quantities for all components.\"\n                raise u.UnitConversionError(error_message) from err\n    differential_type = frame.differential_type\n    if differential_type is not None:\n        for frame_name, repr_name in frame.get_representation_component_names('s').items():\n            diff_attr_class = differential_type.attr_classes[repr_name]\n            value = kwargs.pop(frame_name, None)\n            if value is not None:\n                valid_kwargs[frame_name] = diff_attr_class(value)\n    return valid_kwargs",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.differential_type": "def differential_type(self):\n    return self.get_representation_cls('s')",
    ".astropy.coordinates.representation.py@@UnitSphericalRepresentation.__init__": "def __init__(self, lon, lat=None, differentials=None, copy=True):\n    super().__init__(lon, lat, differentials=differentials, copy=copy)",
    ".astropy.coordinates.representation.py@@BaseRepresentation.__init__": "def __init__(self, *args, differentials=None, **kwargs):\n    super().__init__(*args, **kwargs)\n    if differentials is None and args and isinstance(args[0], self.__class__):\n        differentials = args[0]._differentials\n    self._differentials = self._validate_differentials(differentials)",
    ".astropy.coordinates.representation.py@@BaseRepresentationOrDifferential.__init__": "def __init__(self, *args, **kwargs):\n    args = list(args)\n    components = self.components\n    if args and isinstance(args[0], self.__class__) and all((arg is None for arg in args[1:])):\n        rep_or_diff = args[0]\n        copy = kwargs.pop('copy', True)\n        attrs = [getattr(rep_or_diff, component) for component in components]\n        if 'info' in rep_or_diff.__dict__:\n            self.info = rep_or_diff.info\n        if kwargs:\n            raise TypeError(f'unexpected keyword arguments for case where class instance is passed in: {kwargs}')\n    else:\n        attrs = []\n        for component in components:\n            try:\n                attr = args.pop(0) if args else kwargs.pop(component)\n            except KeyError:\n                raise TypeError(f'__init__() missing 1 required positional argument: {component!r}') from None\n            if attr is None:\n                raise TypeError(f'__init__() missing 1 required positional argument: {component!r} (or first argument should be an instance of {self.__class__.__name__}).')\n            attrs.append(attr)\n        copy = args.pop(0) if args else kwargs.pop('copy', True)\n        if args:\n            raise TypeError(f'unexpected arguments: {args}')\n        if kwargs:\n            for component in components:\n                if component in kwargs:\n                    raise TypeError(f'__init__() got multiple values for argument {component!r}')\n            raise TypeError(f'unexpected keyword arguments: {kwargs}')\n    attrs = [self.attr_classes[component](attr, copy=copy, subok=True) for component, attr in zip(components, attrs)]\n    try:\n        bc_attrs = np.broadcast_arrays(*attrs, subok=True)\n    except ValueError as err:\n        if len(components) <= 2:\n            c_str = ' and '.join(components)\n        else:\n            c_str = ', '.join(components[:2]) + ', and ' + components[2]\n        raise ValueError(f'Input parameters {c_str} cannot be broadcast') from err\n    attrs = [(bc_attr.copy() if copy else bc_attr) if bc_attr.shape != attr.shape else attr for attr, bc_attr in zip(attrs, bc_attrs)]\n    for component, attr in zip(components, attrs):\n        setattr(self, '_' + component, attr)",
    ".astropy.coordinates.representation.py@@BaseRepresentationOrDifferential.components": "def components(self):\n    return tuple(self.attr_classes)",
    ".astropy.coordinates.representation.py@@BaseRepresentation._validate_differentials": "def _validate_differentials(self, differentials):\n    if differentials is None:\n        differentials = dict()\n    elif isinstance(differentials, BaseDifferential):\n        if isinstance(differentials, RadialDifferential) and isinstance(self, UnitSphericalRepresentation):\n            raise ValueError('To attach a RadialDifferential to a UnitSphericalRepresentation, you must supply a dictionary with an appropriate key.')\n        key = differentials._get_deriv_key(self)\n        differentials = {key: differentials}\n    for key in differentials:\n        try:\n            diff = differentials[key]\n        except TypeError as err:\n            raise TypeError(\"'differentials' argument must be a dictionary-like object\") from err\n        diff._check_base(self)\n        if isinstance(diff, RadialDifferential) and isinstance(self, UnitSphericalRepresentation):\n            pass\n        else:\n            expected_key = diff._get_deriv_key(self)\n            if key != expected_key:\n                raise ValueError(\"For differential object '{}', expected unit key = '{}' but received key = '{}'\".format(repr(diff), expected_key, key))\n        if diff.shape != self.shape:\n            raise ValueError('Shape of differentials must be the same as the shape of the representation ({} vs {})'.format(diff.shape, self.shape))\n    return differentials",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.data": "def data(self):\n    if self._data is None:\n        raise ValueError('The frame object \"{!r}\" does not have associated data'.format(self))\n    return self._data",
    ".astropy.coordinates.representation.py@@BaseRepresentationOrDifferential.shape": "def shape(self):\n    return getattr(self, self.components[0]).shape",
    ".astropy.coordinates.representation.py@@UnitSphericalRepresentation.lon": "def lon(self):\n    return self._lon",
    ".astropy.coordinates.representation.py@@BaseRepresentation.differentials": "def differentials(self):\n    return self._differentials",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.cache": "def cache(self):\n    return defaultdict(dict)",
    ".astropy.coordinates.sky_coordinate.py@@SkyCoord._apply": "def _apply(self, method, *args, **kwargs):\n\n    def apply_method(value):\n        if isinstance(value, ShapedLikeNDArray):\n            return value._apply(method, *args, **kwargs)\n        elif callable(method):\n            return method(value, *args, **kwargs)\n        else:\n            return getattr(value, method)(*args, **kwargs)\n    new = super().__new__(self.__class__)\n    new._sky_coord_frame = self._sky_coord_frame._apply(method, *args, **kwargs)\n    new._extra_frameattr_names = self._extra_frameattr_names.copy()\n    for attr in self._extra_frameattr_names:\n        value = getattr(self, attr)\n        if getattr(value, 'shape', ()):\n            value = apply_method(value)\n        elif method == 'copy' or method == 'flatten':\n            value = copy.copy(value)\n        setattr(new, '_' + attr, value)\n    if 'info' in self.__dict__:\n        new.info = self.info\n    return new",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame._apply": "def _apply(self, method, *args, **kwargs):\n\n    def apply_method(value):\n        if isinstance(value, ShapedLikeNDArray):\n            return value._apply(method, *args, **kwargs)\n        elif callable(method):\n            return method(value, *args, **kwargs)\n        else:\n            return getattr(value, method)(*args, **kwargs)\n    new = super().__new__(self.__class__)\n    if hasattr(self, '_representation'):\n        new._representation = self._representation.copy()\n    new._attr_names_with_defaults = self._attr_names_with_defaults.copy()\n    for attr in self.frame_attributes:\n        _attr = '_' + attr\n        if attr in self._attr_names_with_defaults:\n            setattr(new, _attr, getattr(self, _attr))\n        else:\n            value = getattr(self, _attr)\n            if getattr(value, 'shape', ()):\n                value = apply_method(value)\n            elif method == 'copy' or method == 'flatten':\n                value = copy.copy(value)\n            setattr(new, _attr, value)\n    if self.has_data:\n        new._data = apply_method(self.data)\n    else:\n        new._data = None\n        shapes = [getattr(new, '_' + attr).shape for attr in new.frame_attributes if attr not in new._attr_names_with_defaults and getattr(getattr(new, '_' + attr), 'shape', ())]\n        if shapes:\n            new._no_data_shape = check_broadcast(*shapes) if len(shapes) > 1 else shapes[0]\n        else:\n            new._no_data_shape = ()\n    return new",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.apply_method": "def apply_method(value):\n    if isinstance(value, ShapedLikeNDArray):\n        return value._apply(method, *args, **kwargs)\n    elif callable(method):\n        return method(value, *args, **kwargs)\n    else:\n        return getattr(value, method)(*args, **kwargs)",
    ".astropy.coordinates.representation.py@@BaseRepresentation._apply": "def _apply(self, method, *args, **kwargs):\n    rep = super()._apply(method, *args, **kwargs)\n    rep._differentials = dict([(k, diff._apply(method, *args, **kwargs)) for k, diff in self._differentials.items()])\n    return rep",
    ".astropy.coordinates.representation.py@@BaseRepresentationOrDifferential._apply": "def _apply(self, method, *args, **kwargs):\n    if callable(method):\n        apply_method = lambda array: method(array, *args, **kwargs)\n    else:\n        apply_method = operator.methodcaller(method, *args, **kwargs)\n    new = super().__new__(self.__class__)\n    for component in self.components:\n        setattr(new, '_' + component, apply_method(getattr(self, component)))\n    if 'info' in self.__dict__:\n        new.info = self.info\n    return new",
    ".astropy.coordinates.representation.py@@UnitSphericalRepresentation.lat": "def lat(self):\n    return self._lat",
    ".astropy.coordinates.sky_coordinate.py@@SkyCoord._is_name": "def _is_name(self, string):\n    return self.frame.name == string or (isinstance(self.frame.name, list) and string in self.frame.name)",
    ".astropy.coordinates.sky_coordinate.py@@SkyCoord.frame": "def frame(self):\n    return self._sky_coord_frame",
    ".astropy.coordinates.sky_coordinate.py@@SkyCoord.shape": "def shape(self):\n    return self.frame.shape",
    ".astropy.coordinates.distances.py@@Distance.__new__": "def __new__(cls, value=None, unit=None, z=None, cosmology=None, distmod=None, parallax=None, dtype=None, copy=True, order=None, subok=False, ndmin=0, allow_negative=False):\n    n_not_none = sum((x is not None for x in [value, z, distmod, parallax]))\n    if n_not_none == 0:\n        raise ValueError('none of `value`, `z`, `distmod`, or `parallax` were given to Distance constructor')\n    elif n_not_none > 1:\n        raise ValueError('more than one of `value`, `z`, `distmod`, or `parallax` were given to Distance constructor')\n    if value is None:\n        copy = False\n    if z is not None:\n        if cosmology is None:\n            from astropy.cosmology import default_cosmology\n            cosmology = default_cosmology.get()\n        value = cosmology.luminosity_distance(z)\n    elif cosmology is not None:\n        raise ValueError('a `cosmology` was given but `z` was not provided in Distance constructor')\n    elif distmod is not None:\n        value = cls._distmod_to_pc(distmod)\n        if unit is None:\n            meanlogval = np.log10(value.value).mean()\n            if meanlogval > 6:\n                unit = u.Mpc\n            elif meanlogval > 3:\n                unit = u.kpc\n            elif meanlogval < -3:\n                unit = u.AU\n            else:\n                unit = u.pc\n    elif parallax is not None:\n        if unit is None:\n            unit = u.pc\n        value = parallax.to_value(unit, equivalencies=u.parallax())\n        if np.any(parallax < 0):\n            if allow_negative:\n                warnings.warn('negative parallaxes are converted to NaN distances even when `allow_negative=True`, because negative parallaxes cannot be transformed into distances. See the discussion in this paper: https://arxiv.org/abs/1507.02105', AstropyWarning)\n            else:\n                raise ValueError('some parallaxes are negative, which are not interpretable as distances. See the discussion in this paper: https://arxiv.org/abs/1507.02105 . You can convert negative parallaxes to NaN distances by providing the `allow_negative=True` argument.')\n    distance = super().__new__(cls, value, unit, dtype=dtype, copy=copy, order=order, subok=subok, ndmin=ndmin)\n    with np.errstate(invalid='ignore'):\n        any_negative = np.any(distance.value < 0)\n    if not allow_negative and any_negative:\n        raise ValueError('distance must be >= 0. Use the argument `allow_negative=True` to allow negative values.')\n    return distance",
    ".astropy.time.core.py@@TimeBase.writeable": "def writeable(self):\n    return self._time.jd1.flags.writeable & self._time.jd2.flags.writeable",
    ".astropy.coordinates.representation.py@@SphericalRepresentation.__init__": "def __init__(self, lon, lat=None, distance=None, differentials=None, copy=True):\n    super().__init__(lon, lat, distance, copy=copy, differentials=differentials)\n    if not isinstance(self._distance, Distance) and self._distance.unit.physical_type == 'length':\n        try:\n            self._distance = Distance(self._distance, copy=False)\n        except ValueError as e:\n            if e.args[0].startswith('distance must be >= 0'):\n                raise ValueError(\"Distance must be >= 0. To allow negative distance values, you must explicitly pass in a `Distance` object with the the argument 'allow_negative=True'.\") from e\n            else:\n                raise",
    ".astropy.coordinates.representation.py@@SphericalRepresentation.lon": "def lon(self):\n    return self._lon",
    ".astropy.coordinates.representation.py@@SphericalRepresentation.lat": "def lat(self):\n    return self._lat",
    ".astropy.coordinates.representation.py@@SphericalRepresentation.distance": "def distance(self):\n    return self._distance",
    ".astropy.coordinates.representation.py@@BaseRepresentationOrDifferential.get_name": "def get_name(cls):\n    name = cls.__name__.lower()\n    if name.endswith('representation'):\n        name = name[:-14]\n    elif name.endswith('differential'):\n        name = name[:-12]\n    return name",
    ".astropy.coordinates.representation.py@@CartesianRepresentation.__init__": "def __init__(self, x, y=None, z=None, unit=None, xyz_axis=None, differentials=None, copy=True):\n    if y is None and z is None:\n        if isinstance(x, np.ndarray) and x.dtype.kind not in 'OV':\n            x = u.Quantity(x, unit, copy=copy, subok=True)\n            self._xyz = x\n            if xyz_axis:\n                x = np.moveaxis(x, xyz_axis, 0)\n                self._xyz_axis = xyz_axis\n            else:\n                self._xyz_axis = 0\n            self._x, self._y, self._z = x\n            self._differentials = self._validate_differentials(differentials)\n            return\n        elif isinstance(x, CartesianRepresentation) and unit is None and (xyz_axis is None):\n            if differentials is None:\n                differentials = x._differentials\n            return super().__init__(x, differentials=differentials, copy=copy)\n        else:\n            x, y, z = x\n    if xyz_axis is not None:\n        raise ValueError('xyz_axis should only be set if x, y, and z are in a single array passed in through x, i.e., y and z should not be not given.')\n    if y is None or z is None:\n        raise ValueError('x, y, and z are required to instantiate {}'.format(self.__class__.__name__))\n    if unit is not None:\n        x = u.Quantity(x, unit, copy=copy, subok=True)\n        y = u.Quantity(y, unit, copy=copy, subok=True)\n        z = u.Quantity(z, unit, copy=copy, subok=True)\n        copy = False\n    super().__init__(x, y, z, copy=copy, differentials=differentials)\n    if not (self._x.unit.is_equivalent(self._y.unit) and self._x.unit.is_equivalent(self._z.unit)):\n        raise u.UnitsError('x, y, and z should have matching physical types')",
    ".astropy.coordinates.representation.py@@get_component": "def get_component(self):\n    return getattr(self, component)",
    ".astropy.coordinates.representation.py@@SphericalCosLatDifferential.__init__": "def __init__(self, d_lon_coslat, d_lat=None, d_distance=None, copy=True):\n    super().__init__(d_lon_coslat, d_lat, d_distance, copy=copy)\n    if not self._d_lon_coslat.unit.is_equivalent(self._d_lat.unit):\n        raise u.UnitsError('d_lon_coslat and d_lat should have equivalent units.')",
    ".astropy.utils.shapes.py@@ShapedLikeNDArray.__bool__": "def __bool__(self):\n    return self.size > 0",
    ".astropy.utils.shapes.py@@ShapedLikeNDArray.size": "def size(self):\n    size = 1\n    for sh in self.shape:\n        size *= sh\n    return size",
    ".astropy.coordinates.representation.py@@BaseRepresentationOrDifferential._units": "def _units(self):\n    return dict([(component, getattr(self, component).unit) for component in self.components])",
    ".astropy.coordinates.representation.py@@BaseRepresentation.with_differentials": "def with_differentials(self, differentials):\n    if not differentials:\n        return self\n    args = [getattr(self, component) for component in self.components]\n    new_rep = self.__class__(*args, differentials=self.differentials.copy(), copy=False)\n    new_rep._differentials.update(new_rep._validate_differentials(differentials))\n    return new_rep",
    ".astropy.coordinates.representation.py@@BaseDifferential._check_base": "def _check_base(cls, base):\n    if cls not in base._compatible_differentials:\n        raise TypeError(f'Differential class {cls} is not compatible with the base (representation) class {base.__class__}')",
    ".astropy.coordinates.representation.py@@SphericalRepresentation._compatible_differentials": "def _compatible_differentials(cls):\n    return [UnitSphericalDifferential, UnitSphericalCosLatDifferential, SphericalDifferential, SphericalCosLatDifferential, RadialDifferential]",
    ".astropy.coordinates.representation.py@@BaseDifferential._get_deriv_key": "def _get_deriv_key(self, base):\n    self._check_base(base)\n    for name in base.components:\n        comp = getattr(base, name)\n        d_comp = getattr(self, f'd_{name}', None)\n        if d_comp is not None:\n            d_unit = comp.unit / d_comp.unit\n            d_unit_si = d_unit.decompose(u.si.bases)\n            d_unit_si._scale = 1\n            return str(d_unit_si)\n    else:\n        raise RuntimeError('Invalid representation-differential units! This likely happened because either the representation or the associated differential have non-standard units. Check that the input positional data have positional units, and the input velocity data have velocity units, or are both dimensionless.')",
    ".astropy.units.core.py@@UnitBase.__str__": "def __str__(self):\n    return unit_format.Generic.to_string(self)",
    ".astropy.utils.data_info.py@@ParentAttribute.__set__": "def __set__(self, instance, value):\n    if instance is None:\n        raise ValueError('cannot set unbound descriptor')\n    setattr(instance._parent, self.attr, value)",
    ".astropy.coordinates.earth.py@@EarthLocationInfo._construct_from_dict": "def _construct_from_dict(self, map):\n    ellipsoid = map.pop('ellipsoid')\n    out = self._parent_cls(**map)\n    out.ellipsoid = ellipsoid\n    return out",
    ".astropy.coordinates.earth.py@@EarthLocation.__new__": "def __new__(cls, *args, **kwargs):\n    if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], EarthLocation):\n        return args[0].copy()\n    try:\n        self = cls.from_geocentric(*args, **kwargs)\n    except (u.UnitsError, TypeError) as exc_geocentric:\n        try:\n            self = cls.from_geodetic(*args, **kwargs)\n        except Exception as exc_geodetic:\n            raise TypeError('Coordinates could not be parsed as either geocentric or geodetic, with respective exceptions \"{}\" and \"{}\"'.format(exc_geocentric, exc_geodetic))\n    return self",
    ".astropy.coordinates.earth.py@@EarthLocation.ellipsoid": "def ellipsoid(self):\n    return self._ellipsoid",
    ".astropy.coordinates.earth.py@@_check_ellipsoid": "def _check_ellipsoid(ellipsoid=None, default='WGS84'):\n    if ellipsoid is None:\n        ellipsoid = default\n    if ellipsoid not in ELLIPSOIDS:\n        raise ValueError(f'Ellipsoid {ellipsoid} not among known ones ({ELLIPSOIDS})')\n    return ellipsoid",
    ".astropy.coordinates.earth.py@@EarthLocation.__getitem__": "def __getitem__(self, item):\n    result = super().__getitem__(item)\n    if result.dtype is self.dtype:\n        return result.view(self.__class__)\n    else:\n        return result.view(u.Quantity)",
    ".astropy.coordinates.earth.py@@EarthLocation.__len__": "def __len__(self):\n    if self.shape == ():\n        raise IndexError('0-d EarthLocation arrays cannot be indexed')\n    else:\n        return super().__len__()",
    ".astropy.coordinates.representation.py@@RepresentationInfo._construct_from_dict": "def _construct_from_dict(self, map):\n    differentials = {}\n    for key in list(map.keys()):\n        if key.startswith('differentials.'):\n            differentials[key[14:]] = map.pop(key)\n    map['differentials'] = differentials\n    return super()._construct_from_dict(map)",
    ".astropy.table.ndarray_mixin.py@@NdarrayMixinInfo._construct_from_dict": "def _construct_from_dict(self, map):\n    data = map.pop('data')\n    out = self._parent_cls(data, **map)\n    return out",
    ".astropy.table.ndarray_mixin.py@@NdarrayMixin.__new__": "def __new__(cls, obj, *args, **kwargs):\n    self = np.array(obj, *args, **kwargs).view(cls)\n    if 'info' in getattr(obj, '__dict__', ()):\n        self.info = obj.info\n    return self",
    ".astropy.table.ndarray_mixin.py@@NdarrayMixin.__array_finalize__": "def __array_finalize__(self, obj):\n    if obj is None:\n        return\n    if callable(super().__array_finalize__):\n        super().__array_finalize__(obj)\n    if 'info' in getattr(obj, '__dict__', ()):\n        self.info = obj.info"
}