{
    ".sympy.core.compatibility.py@@is_sequence": "def is_sequence(i, include=None):\n    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))",
    ".sympy.core.compatibility.py@@iterable": "def iterable(i, exclude=(string_types, dict, NotIterable)):\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    ".sympy.utilities.iterables.py@@has_variety": "def has_variety(seq):\n    for i, s in enumerate(seq):\n        if i == 0:\n            sentinel = s\n        elif s != sentinel:\n            return True\n    return False",
    ".sympy.utilities.iterables.py@@flatten": "def flatten(iterable, levels=None, cls=None):\n    if levels is not None:\n        if not levels:\n            return iterable\n        elif levels > 0:\n            levels -= 1\n        else:\n            raise ValueError('expected non-negative number of levels, got %s' % levels)\n    if cls is None:\n        reducible = lambda x: is_sequence(x, set)\n    else:\n        reducible = lambda x: isinstance(x, cls)\n    result = []\n    for el in iterable:\n        if reducible(el):\n            if hasattr(el, 'args'):\n                el = el.args\n            result.extend(flatten(el, levels=levels, cls=cls))\n        else:\n            result.append(el)\n    return result",
    ".sympy.utilities.iterables.py@@has_dups": "def has_dups(seq):\n    from sympy.core.containers import Dict\n    from sympy.sets.sets import Set\n    if isinstance(seq, (dict, set, Dict, Set)):\n        return False\n    uniq = set()\n    return any((True for s in seq if s in uniq or uniq.add(s)))",
    ".sympy.combinatorics.permutations.py@@Cycle.__init__": "def __init__(self, *args):\n    if not args:\n        return\n    if len(args) == 1:\n        if isinstance(args[0], Permutation):\n            for c in args[0].cyclic_form:\n                self.update(self(*c))\n            return\n        elif isinstance(args[0], Cycle):\n            for k, v in args[0].items():\n                self[k] = v\n            return\n    args = [as_int(a) for a in args]\n    if any((i < 0 for i in args)):\n        raise ValueError('negative integers are not allowed in a cycle.')\n    if has_dups(args):\n        raise ValueError('All elements must be unique in a cycle.')\n    for i in range(-len(args), 0):\n        self[args[i]] = args[i + 1]",
    ".sympy.combinatorics.permutations.py@@Cycle.__call__": "def __call__(self, *other):\n    rv = Cycle(*other)\n    for k, v in zip(list(self.keys()), [rv[self[k]] for k in self.keys()]):\n        rv[k] = v\n    return rv",
    ".sympy.core.compatibility.py@@as_int": "def as_int(n):\n    try:\n        result = int(n)\n        if result != n:\n            raise TypeError\n    except TypeError:\n        raise ValueError('%s is not an integer' % (n,))\n    return result",
    ".sympy.combinatorics.permutations.py@@Cycle.__missing__": "def __missing__(self, arg):\n    arg = as_int(arg)\n    self[arg] = arg\n    return arg",
    ".sympy.combinatorics.permutations.py@@Cycle.list": "def list(self, size=None):\n    if not self and size is None:\n        raise ValueError('must give size for empty Cycle')\n    if size is not None:\n        big = max([i for i in self.keys() if self[i] != i] + [0])\n        size = max(size, big + 1)\n    else:\n        size = self.size\n    return [self[i] for i in range(size)]",
    ".sympy.combinatorics.permutations.py@@Cycle.size": "def size(self):\n    if not self:\n        return 0\n    return max(self.keys()) + 1"
}