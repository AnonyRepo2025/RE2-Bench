{
    ".astropy.utils.data_info.py@@DataInfo.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        self._parent_cls = owner_cls\n        return self\n    info = instance.__dict__.get('info')\n    if info is None:\n        info = instance.__dict__['info'] = self.__class__(bound=True)\n    info._parent_ref = weakref.ref(instance)\n    return info",
    ".astropy.utils.data_info.py@@BaseColumnInfo.__set__": "def __set__(self, instance, value):\n    try:\n        if not instance.shape:\n            return\n    except AttributeError:\n        pass\n    super().__set__(instance, value)",
    ".astropy.utils.data_info.py@@DataInfo.__set__": "def __set__(self, instance, value):\n    if instance is None:\n        raise ValueError('cannot set unbound descriptor')\n    if isinstance(value, DataInfo):\n        info = instance.__dict__['info'] = self.__class__(bound=True)\n        attr_names = info.attr_names\n        if value.__class__ is self.__class__:\n            attr_names = attr_names & set(value._attrs)\n        else:\n            attr_names = attr_names & value.attr_names - value._attrs_no_copy\n        for attr in attr_names - info.attrs_from_parent - info._attrs_no_copy:\n            info._attrs[attr] = deepcopy(getattr(value, attr))\n    else:\n        raise TypeError('info must be set with a DataInfo instance')",
    ".astropy.utils.data_info.py@@BaseColumnInfo.__init__": "def __init__(self, bound=False):\n    super().__init__(bound=bound)\n    if bound:\n        self._format_funcs = {}",
    ".astropy.utils.data_info.py@@DataInfo.__init__": "def __init__(self, bound=False):\n    if bound:\n        self._attrs = {}",
    ".astropy.utils.data_info.py@@InfoAttribute.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        return self\n    return instance._attrs.get(self.attr, self.default)",
    ".astropy.utils.data_info.py@@MixinInfo.name": "def name(self):\n    return self._attrs.get('name')",
    ".astropy.units.structured.py@@StructuredUnit.__new__": "def __new__(cls, units, names=None):\n    dtype = None\n    if names is not None:\n        if isinstance(names, StructuredUnit):\n            dtype = names._units.dtype\n            names = names.field_names\n        elif isinstance(names, np.dtype):\n            if not names.fields:\n                raise ValueError('dtype should be structured, with fields.')\n            dtype = np.dtype([(name, DTYPE_OBJECT) for name in names.names])\n            names = _names_from_dtype(names)\n        else:\n            if not isinstance(names, tuple):\n                names = (names,)\n            names = _normalize_names(names)\n    if not isinstance(units, tuple):\n        units = Unit(units)\n        if isinstance(units, StructuredUnit):\n            if names is None or units.field_names == names:\n                return units\n            units = units.values()\n        else:\n            units = (units,)\n    if names is None:\n        names = tuple((f'f{i}' for i in range(len(units))))\n    elif len(units) != len(names):\n        raise ValueError('lengths of units and field names must match.')\n    converted = []\n    for unit, name in zip(units, names):\n        if isinstance(name, list):\n            unit = cls(unit, name[1])\n            name = name[0]\n        else:\n            unit = Unit(unit)\n            if dtype is not None and isinstance(unit, StructuredUnit):\n                raise ValueError('units do not match in depth with field names from dtype or structured unit.')\n        converted.append(unit)\n    self = super().__new__(cls)\n    if dtype is None:\n        dtype = np.dtype([(name[0] if isinstance(name, list) else name, DTYPE_OBJECT) for name in names])\n    self._units = np.array(tuple(converted), dtype)[()]\n    return self",
    ".astropy.units.structured.py@@_names_from_dtype": "def _names_from_dtype(dtype):\n    names = []\n    for name in dtype.names:\n        subdtype = dtype.fields[name][0]\n        if subdtype.names:\n            names.append([name, _names_from_dtype(subdtype)])\n        else:\n            names.append(name)\n    return tuple(names)",
    ".astropy.units.core.py@@_UnitMetaClass.__call__": "def __call__(self, s='', represents=None, format=None, namespace=None, doc=None, parse_strict='raise'):\n    if hasattr(s, '_get_physical_type_id'):\n        return s\n    from .quantity import Quantity\n    if isinstance(represents, Quantity):\n        if is_effectively_unity(represents.value):\n            represents = represents.unit\n        else:\n            represents = CompositeUnit(represents.value * represents.unit.scale, bases=represents.unit.bases, powers=represents.unit.powers, _error_check=False)\n    if isinstance(s, Quantity):\n        if is_effectively_unity(s.value):\n            s = s.unit\n        else:\n            s = CompositeUnit(s.value * s.unit.scale, bases=s.unit.bases, powers=s.unit.powers, _error_check=False)\n    if isinstance(represents, UnitBase):\n        return super().__call__(s, represents, format=format, namespace=namespace, doc=doc)\n    if isinstance(s, UnitBase):\n        return s\n    elif isinstance(s, (bytes, str)):\n        if len(s.strip()) == 0:\n            return dimensionless_unscaled\n        if format is None:\n            format = unit_format.Generic\n        f = unit_format.get_format(format)\n        if isinstance(s, bytes):\n            s = s.decode('ascii')\n        try:\n            return f.parse(s)\n        except NotImplementedError:\n            raise\n        except Exception as e:\n            if parse_strict == 'silent':\n                pass\n            else:\n                if f is not unit_format.Generic:\n                    format_clause = f.name + ' '\n                else:\n                    format_clause = ''\n                msg = f\"'{s}' did not parse as {format_clause}unit: {str(e)} If this is meant to be a custom unit, define it with 'u.def_unit'. To have it recognized inside a file reader or other code, enable it with 'u.add_enabled_units'. For details, see https://docs.astropy.org/en/latest/units/combining_and_defining.html\"\n                if parse_strict == 'raise':\n                    raise ValueError(msg)\n                elif parse_strict == 'warn':\n                    warnings.warn(msg, UnitsWarning)\n                else:\n                    raise ValueError(\"'parse_strict' must be 'warn', 'raise' or 'silent'\")\n            return UnrecognizedUnit(s)\n    elif isinstance(s, (int, float, np.floating, np.integer)):\n        return CompositeUnit(s, [], [], _error_check=False)\n    elif isinstance(s, tuple):\n        from .structured import StructuredUnit\n        return StructuredUnit(s)\n    elif s is None:\n        raise TypeError('None is not a valid Unit')\n    else:\n        raise TypeError(f'{s} can not be converted to a Unit')",
    ".astropy.units.structured.py@@StructuredUnit.field_names": "def field_names(self):\n    return tuple(([name, unit.field_names] if isinstance(unit, StructuredUnit) else name for name, unit in self.items()))",
    ".astropy.units.structured.py@@StructuredUnit.items": "def items(self):\n    return tuple(zip(self._units.dtype.names, self._units.item()))"
}