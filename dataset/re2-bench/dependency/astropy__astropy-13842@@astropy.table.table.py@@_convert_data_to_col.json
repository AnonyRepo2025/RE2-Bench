{
    ".astropy.table.table.py@@has_info_class": "def has_info_class(obj, cls):\n    return isinstance(getattr(obj.__class__, 'info', None), cls)",
    ".astropy.table.mixins.registry.py@@get_mixin_handler": "def get_mixin_handler(obj):\n    if isinstance(obj, str):\n        return _handlers.get(obj, None)\n    else:\n        return _handlers.get(obj.__class__.__module__ + '.' + obj.__class__.__name__, None)",
    ".astropy.table.table.py@@Table.masked": "def masked(self):\n    return self._masked",
    ".astropy.table.column.py@@Column.__new__": "def __new__(cls, data=None, name=None, dtype=None, shape=(), length=0, description=None, unit=None, format=None, meta=None, copy=False, copy_indices=True):\n    if isinstance(data, MaskedColumn) and np.any(data.mask):\n        raise TypeError('Cannot convert a MaskedColumn with masked value to a Column')\n    self = super().__new__(cls, data=data, name=name, dtype=dtype, shape=shape, length=length, description=description, unit=unit, format=format, meta=meta, copy=copy, copy_indices=copy_indices)\n    return self",
    ".astropy.table.column.py@@BaseColumn.__new__": "def __new__(cls, data=None, name=None, dtype=None, shape=(), length=0, description=None, unit=None, format=None, meta=None, copy=False, copy_indices=True):\n    if data is None:\n        self_data = np.zeros((length,) + shape, dtype=dtype)\n    elif isinstance(data, BaseColumn) and hasattr(data, '_name'):\n        self_data = np.array(data.data, dtype=dtype, copy=copy)\n        if description is None:\n            description = data.description\n        if unit is None:\n            unit = unit or data.unit\n        if format is None:\n            format = data.format\n        if meta is None:\n            meta = data.meta\n        if name is None:\n            name = data.name\n    elif isinstance(data, Quantity):\n        if unit is None:\n            self_data = np.array(data, dtype=dtype, copy=copy)\n            unit = data.unit\n        else:\n            self_data = Quantity(data, unit, dtype=dtype, copy=copy).value\n        if 'info' in data.__dict__:\n            if description is None:\n                description = data.info.description\n            if format is None:\n                format = data.info.format\n            if meta is None:\n                meta = data.info.meta\n    else:\n        if np.dtype(dtype).char == 'S':\n            data = cls._encode_str(data)\n        self_data = np.array(data, dtype=dtype, copy=copy)\n    self = self_data.view(cls)\n    self._name = None if name is None else str(name)\n    self._parent_table = None\n    self.unit = unit\n    self._format = format\n    self.description = description\n    self.meta = meta\n    self.indices = deepcopy(getattr(data, 'indices', [])) if copy_indices else []\n    for index in self.indices:\n        index.replace_col(data, self)\n    return self",
    ".astropy.table.column.py@@BaseColumn.data": "def data(self):\n    return self.view(np.ndarray)",
    ".astropy.table.column.py@@BaseColumn.unit": "def unit(self):\n    return self._unit",
    ".astropy.table.column.py@@BaseColumn.format": "def format(self):\n    return self._format",
    ".astropy.utils.metadata.py@@MetaData.__get__": "def __get__(self, instance, owner):\n    if instance is None:\n        return self\n    if not hasattr(instance, '_meta'):\n        instance._meta = OrderedDict()\n    return instance._meta",
    ".astropy.table.column.py@@BaseColumn.__array_finalize__": "def __array_finalize__(self, obj):\n    if obj is None:\n        return\n    if callable(super().__array_finalize__):\n        super().__array_finalize__(obj)\n    self.parent_table = None\n    if not hasattr(self, 'indices'):\n        self.indices = []\n    self._copy_attrs(obj)\n    if 'info' in getattr(obj, '__dict__', {}):\n        self.info = obj.info",
    ".astropy.table.column.py@@Column.__setattr__": "def __setattr__(self, item, value):\n    if not isinstance(self, MaskedColumn) and item == 'mask':\n        raise AttributeError('cannot set mask value to a column in non-masked Table')\n    super().__setattr__(item, value)\n    if item == 'unit' and issubclass(self.dtype.type, np.number):\n        try:\n            converted = self.parent_table._convert_col_for_table(self)\n        except AttributeError:\n            pass\n        else:\n            if converted is not self:\n                self.parent_table.replace_column(self.name, converted)",
    ".astropy.table.column.py@@BaseColumn.parent_table": "def parent_table(self):\n    if getattr(self, '_parent_table', None) is None:\n        return None\n    else:\n        return self._parent_table()",
    ".astropy.table.column.py@@BaseColumn._copy_attrs": "def _copy_attrs(self, obj):\n    for attr in ('name', 'unit', '_format', 'description'):\n        val = getattr(obj, attr, None)\n        setattr(self, attr, val)\n    obj_meta = getattr(obj, 'meta', None)\n    if obj_meta:\n        self.meta = obj_meta.copy()",
    ".astropy.table.column.py@@BaseColumn.name": "def name(self):\n    return self._name",
    ".astropy.utils.metadata.py@@MetaData.__set__": "def __set__(self, instance, value):\n    if value is None:\n        instance._meta = OrderedDict()\n    elif isinstance(value, Mapping):\n        if self.copy:\n            instance._meta = deepcopy(value)\n        else:\n            instance._meta = value\n    else:\n        raise TypeError('meta attribute must be dict-like')",
    ".astropy.utils.data_info.py@@DataInfo.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        self._parent_cls = owner_cls\n        return self\n    info = instance.__dict__.get('info')\n    if info is None:\n        info = instance.__dict__['info'] = self.__class__(bound=True)\n    info._parent_ref = weakref.ref(instance)\n    return info",
    ".astropy.table.table_helpers.py@@ArrayWrapper.__getitem__": "def __getitem__(self, item):\n    if isinstance(item, (int, np.integer)):\n        out = self.data[item]\n    else:\n        out = self.__class__(self.data[item], copy=False)\n        if 'info' in self.__dict__:\n            out.info = self.info\n    return out",
    ".astropy.table.column.py@@col_copy": "def col_copy(col, copy_indices=True):\n    if isinstance(col, BaseColumn):\n        return col.copy()\n    newcol = col.copy() if hasattr(col, 'copy') else deepcopy(col)\n    if 'info' in col.__dict__:\n        newcol.info = col.info\n        if copy_indices and col.info.indices:\n            newcol.info.indices = deepcopy(col.info.indices)\n            for index in newcol.info.indices:\n                index.replace_col(col, newcol)\n    return newcol",
    ".astropy.utils.data_info.py@@BaseColumnInfo.__init__": "def __init__(self, bound=False):\n    super().__init__(bound=bound)\n    if bound:\n        self._format_funcs = {}",
    ".astropy.utils.data_info.py@@DataInfo.__init__": "def __init__(self, bound=False):\n    if bound:\n        self._attrs = {}",
    ".astropy.utils.data_info.py@@MixinInfo.name": "def name(self):\n    return self._attrs.get('name')",
    ".astropy.utils.data_info.py@@BaseColumnInfo.parent_table": "def parent_table(self):\n    value = self._attrs.get('parent_table')\n    if callable(value):\n        value = value()\n    return value",
    ".astropy.utils.data_info.py@@DataInfo.__getstate__": "def __getstate__(self):\n    return self._attrs",
    ".astropy.utils.data_info.py@@DataInfo.__setstate__": "def __setstate__(self, state):\n    self._attrs = state",
    ".astropy.utils.data_info.py@@BaseColumnInfo.__set__": "def __set__(self, instance, value):\n    try:\n        if not instance.shape:\n            return\n    except AttributeError:\n        pass\n    super().__set__(instance, value)",
    ".astropy.table.table_helpers.py@@ArrayWrapper.shape": "def shape(self):\n    return self.data.shape",
    ".astropy.utils.data_info.py@@DataInfo.__set__": "def __set__(self, instance, value):\n    if instance is None:\n        raise ValueError('cannot set unbound descriptor')\n    if isinstance(value, DataInfo):\n        info = instance.__dict__['info'] = self.__class__(bound=True)\n        attr_names = info.attr_names\n        if value.__class__ is self.__class__:\n            attr_names = attr_names & set(value._attrs)\n        else:\n            attr_names = attr_names & value.attr_names - value._attrs_no_copy\n        for attr in attr_names - info.attrs_from_parent - info._attrs_no_copy:\n            info._attrs[attr] = deepcopy(getattr(value, attr))\n    else:\n        raise TypeError('info must be set with a DataInfo instance')",
    ".astropy.utils.data_info.py@@BaseColumnInfo.indices": "def indices(self):\n    return self._attrs.setdefault('indices', [])",
    ".astropy.utils.shapes.py@@ShapedLikeNDArray.__getitem__": "def __getitem__(self, item):\n    try:\n        return self._apply('__getitem__', item)\n    except IndexError:\n        if self.isscalar:\n            raise TypeError('scalar {!r} object is not subscriptable.'.format(self.__class__.__name__))\n        else:\n            raise",
    ".astropy.coordinates.representation.py@@BaseRepresentation._apply": "def _apply(self, method, *args, **kwargs):\n    rep = super()._apply(method, *args, **kwargs)\n    rep._differentials = {k: diff._apply(method, *args, **kwargs) for k, diff in self._differentials.items()}\n    return rep",
    ".astropy.coordinates.representation.py@@BaseRepresentationOrDifferential._apply": "def _apply(self, method, *args, **kwargs):\n    if callable(method):\n        apply_method = lambda array: method(array, *args, **kwargs)\n    else:\n        apply_method = operator.methodcaller(method, *args, **kwargs)\n    new = super().__new__(self.__class__)\n    for component in self.components:\n        setattr(new, '_' + component, apply_method(getattr(self, component)))\n    if 'info' in self.__dict__:\n        new.info = self.info\n    return new",
    ".astropy.coordinates.representation.py@@BaseRepresentationOrDifferential.components": "def components(self):\n    return tuple(self.attr_classes)",
    ".astropy.coordinates.representation.py@@get_component": "def get_component(self):\n    return getattr(self, component)",
    ".astropy.units.quantity.py@@Quantity.__getitem__": "def __getitem__(self, key):\n    if isinstance(key, str) and isinstance(self.unit, StructuredUnit):\n        return self._new_view(self.view(np.ndarray)[key], self.unit[key])\n    try:\n        out = super().__getitem__(key)\n    except IndexError:\n        if self.isscalar:\n            raise TypeError(\"'{cls}' object with a scalar value does not support indexing\".format(cls=self.__class__.__name__))\n        else:\n            raise\n    if not isinstance(out, np.ndarray):\n        out = self._new_view(out)\n    return out",
    ".astropy.units.quantity.py@@Quantity._new_view": "def _new_view(self, obj=None, unit=None):\n    if unit is None:\n        unit = self.unit\n        quantity_subclass = self.__class__\n    elif unit is self.unit and self.__class__ is Quantity:\n        quantity_subclass = Quantity\n    else:\n        unit = Unit(unit)\n        quantity_subclass = getattr(unit, '_quantity_class', Quantity)\n        if isinstance(self, quantity_subclass):\n            quantity_subclass, subok = self.__quantity_subclass__(unit)\n            if subok:\n                quantity_subclass = self.__class__\n    if obj is None:\n        obj = self.view(np.ndarray)\n    else:\n        obj = np.array(obj, copy=False, subok=True)\n    view = obj.view(quantity_subclass)\n    view._set_unit(unit)\n    view.__array_finalize__(self)\n    return view",
    ".astropy.units.quantity.py@@Quantity.unit": "def unit(self):\n    return self._unit",
    ".astropy.units.quantity.py@@Quantity.__array_finalize__": "def __array_finalize__(self, obj):\n    super_array_finalize = super().__array_finalize__\n    if super_array_finalize is not None:\n        super_array_finalize(obj)\n    if obj is None or obj.__class__ is np.ndarray:\n        return\n    if self._unit is None:\n        unit = getattr(obj, '_unit', None)\n        if unit is not None:\n            self._set_unit(unit)\n    if 'info' in obj.__dict__:\n        self.info = obj.info",
    ".astropy.units.quantity.py@@Quantity._set_unit": "def _set_unit(self, unit):\n    if not isinstance(unit, UnitBase):\n        if isinstance(self._unit, StructuredUnit) or isinstance(unit, StructuredUnit):\n            unit = StructuredUnit(unit, self.dtype)\n        else:\n            unit = Unit(str(unit), parse_strict='silent')\n            if not isinstance(unit, (UnitBase, StructuredUnit)):\n                raise UnitTypeError('{} instances require normal units, not {} instances.'.format(type(self).__name__, type(unit)))\n    self._unit = unit",
    ".astropy.utils.shapes.py@@NDArrayShapeMethods.copy": "def copy(self, *args, **kwargs):\n    return self._apply('copy', *args, **kwargs)",
    ".astropy.coordinates.representation.py@@BaseRepresentationOrDifferential.shape": "def shape(self):\n    return getattr(self, self.components[0]).shape",
    ".astropy.coordinates.earth.py@@EarthLocation.__getitem__": "def __getitem__(self, item):\n    result = super().__getitem__(item)\n    if result.dtype is self.dtype:\n        return result.view(self.__class__)\n    else:\n        return result.view(u.Quantity)",
    ".astropy.coordinates.earth.py@@EarthLocation.__array_finalize__": "def __array_finalize__(self, obj):\n    super().__array_finalize__(obj)\n    if hasattr(obj, '_ellipsoid'):\n        self._ellipsoid = obj._ellipsoid",
    ".astropy.coordinates.angles.py@@Angle._set_unit": "def _set_unit(self, unit):\n    super()._set_unit(self._convert_unit_to_angle_unit(unit))",
    ".astropy.coordinates.angles.py@@Angle._convert_unit_to_angle_unit": "def _convert_unit_to_angle_unit(unit):\n    return u.hourangle if unit is u.hour else unit",
    ".astropy.units.quantity.py@@SpecificTypeQuantity._set_unit": "def _set_unit(self, unit):\n    if unit is None or not unit.is_equivalent(self._equivalent_unit):\n        raise UnitTypeError(\"{} instances require units equivalent to '{}'\".format(type(self).__name__, self._equivalent_unit) + (', but no unit was given.' if unit is None else f\", so cannot set it to '{unit}'.\"))\n    super()._set_unit(unit)",
    ".astropy.units.core.py@@UnitBase.is_equivalent": "def is_equivalent(self, other, equivalencies=[]):\n    equivalencies = self._normalize_equivalencies(equivalencies)\n    if isinstance(other, tuple):\n        return any((self.is_equivalent(u, equivalencies=equivalencies) for u in other))\n    other = Unit(other, parse_strict='silent')\n    return self._is_equivalent(other, equivalencies)",
    ".astropy.units.core.py@@UnitBase._normalize_equivalencies": "def _normalize_equivalencies(equivalencies):\n    normalized = _normalize_equivalencies(equivalencies)\n    if equivalencies is not None:\n        normalized += get_current_unit_registry().equivalencies\n    return normalized",
    ".astropy.units.core.py@@_normalize_equivalencies": "def _normalize_equivalencies(equivalencies):\n    if equivalencies is None:\n        return []\n    normalized = []\n    for i, equiv in enumerate(equivalencies):\n        if len(equiv) == 2:\n            funit, tunit = equiv\n            a = b = lambda x: x\n        elif len(equiv) == 3:\n            funit, tunit, a = equiv\n            b = a\n        elif len(equiv) == 4:\n            funit, tunit, a, b = equiv\n        else:\n            raise ValueError(f'Invalid equivalence entry {i}: {equiv!r}')\n        if not (funit is Unit(funit) and (tunit is None or tunit is Unit(tunit)) and callable(a) and callable(b)):\n            raise ValueError(f'Invalid equivalence entry {i}: {equiv!r}')\n        normalized.append((funit, tunit, a, b))\n    return normalized",
    ".astropy.units.core.py@@get_current_unit_registry": "def get_current_unit_registry():\n    return _unit_registries[-1]",
    ".astropy.units.core.py@@_UnitRegistry.equivalencies": "def equivalencies(self):\n    return list(self._equivalencies)",
    ".astropy.units.core.py@@_UnitMetaClass.__call__": "def __call__(self, s='', represents=None, format=None, namespace=None, doc=None, parse_strict='raise'):\n    if hasattr(s, '_get_physical_type_id'):\n        return s\n    from .quantity import Quantity\n    if isinstance(represents, Quantity):\n        if is_effectively_unity(represents.value):\n            represents = represents.unit\n        else:\n            represents = CompositeUnit(represents.value * represents.unit.scale, bases=represents.unit.bases, powers=represents.unit.powers, _error_check=False)\n    if isinstance(s, Quantity):\n        if is_effectively_unity(s.value):\n            s = s.unit\n        else:\n            s = CompositeUnit(s.value * s.unit.scale, bases=s.unit.bases, powers=s.unit.powers, _error_check=False)\n    if isinstance(represents, UnitBase):\n        return super().__call__(s, represents, format=format, namespace=namespace, doc=doc)\n    if isinstance(s, UnitBase):\n        return s\n    elif isinstance(s, (bytes, str)):\n        if len(s.strip()) == 0:\n            return dimensionless_unscaled\n        if format is None:\n            format = unit_format.Generic\n        f = unit_format.get_format(format)\n        if isinstance(s, bytes):\n            s = s.decode('ascii')\n        try:\n            return f.parse(s)\n        except NotImplementedError:\n            raise\n        except Exception as e:\n            if parse_strict == 'silent':\n                pass\n            else:\n                if f is not unit_format.Generic:\n                    format_clause = f.name + ' '\n                else:\n                    format_clause = ''\n                msg = \"'{}' did not parse as {}unit: {} If this is meant to be a custom unit, define it with 'u.def_unit'. To have it recognized inside a file reader or other code, enable it with 'u.add_enabled_units'. For details, see https://docs.astropy.org/en/latest/units/combining_and_defining.html\".format(s, format_clause, str(e))\n                if parse_strict == 'raise':\n                    raise ValueError(msg)\n                elif parse_strict == 'warn':\n                    warnings.warn(msg, UnitsWarning)\n                else:\n                    raise ValueError(\"'parse_strict' must be 'warn', 'raise' or 'silent'\")\n            return UnrecognizedUnit(s)\n    elif isinstance(s, (int, float, np.floating, np.integer)):\n        return CompositeUnit(s, [], [], _error_check=False)\n    elif isinstance(s, tuple):\n        from .structured import StructuredUnit\n        return StructuredUnit(s)\n    elif s is None:\n        raise TypeError('None is not a valid Unit')\n    else:\n        raise TypeError(f'{s} can not be converted to a Unit')",
    ".astropy.units.core.py@@UnitBase._is_equivalent": "def _is_equivalent(self, other, equivalencies=[]):\n    if isinstance(other, UnrecognizedUnit):\n        return False\n    if self._get_physical_type_id() == other._get_physical_type_id():\n        return True\n    elif len(equivalencies):\n        unit = self.decompose()\n        other = other.decompose()\n        for a, b, forward, backward in equivalencies:\n            if b is None:\n                try:\n                    (other / unit).decompose([a])\n                    return True\n                except Exception:\n                    pass\n            elif a._is_equivalent(unit) and b._is_equivalent(other) or (b._is_equivalent(unit) and a._is_equivalent(other)):\n                return True\n    return False",
    ".astropy.units.core.py@@UnitBase._get_physical_type_id": "def _get_physical_type_id(self):\n    if self._type_id is None:\n        unit = self.decompose()\n        self._type_id = tuple(zip((base.name for base in unit.bases), unit.powers))\n    return self._type_id",
    ".astropy.units.quantity.py@@Quantity.__getattr__": "def __getattr__(self, attr):\n    if not self._include_easy_conversion_members:\n        raise AttributeError(f\"'{self.__class__.__name__}' object has no '{attr}' member\")\n\n    def get_virtual_unit_attribute():\n        registry = get_current_unit_registry().registry\n        to_unit = registry.get(attr, None)\n        if to_unit is None:\n            return None\n        try:\n            return self.unit.to(to_unit, self.value, equivalencies=self.equivalencies)\n        except UnitsError:\n            return None\n    value = get_virtual_unit_attribute()\n    if value is None:\n        raise AttributeError(f\"{self.__class__.__name__} instance has no attribute '{attr}'\")\n    else:\n        return value",
    ".astropy.units.quantity.py@@Quantity.get_virtual_unit_attribute": "def get_virtual_unit_attribute():\n    registry = get_current_unit_registry().registry\n    to_unit = registry.get(attr, None)\n    if to_unit is None:\n        return None\n    try:\n        return self.unit.to(to_unit, self.value, equivalencies=self.equivalencies)\n    except UnitsError:\n        return None",
    ".astropy.units.core.py@@_UnitRegistry.registry": "def registry(self):\n    return self._registry",
    ".astropy.utils.data_info.py@@InfoAttribute.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        return self\n    return instance._attrs.get(self.attr, self.default)",
    ".astropy.coordinates.angles.py@@Longitude.__array_finalize__": "def __array_finalize__(self, obj):\n    super().__array_finalize__(obj)\n    self._wrap_angle = getattr(obj, '_wrap_angle', self._default_wrap_angle)",
    ".astropy.table.ndarray_mixin.py@@NdarrayMixin.__array_finalize__": "def __array_finalize__(self, obj):\n    if obj is None:\n        return\n    if callable(super().__array_finalize__):\n        super().__array_finalize__(obj)\n    if 'info' in getattr(obj, '__dict__', ()):\n        self.info = obj.info",
    ".astropy.coordinates.sky_coordinate.py@@SkyCoord._apply": "def _apply(self, method, *args, **kwargs):\n\n    def apply_method(value):\n        if isinstance(value, ShapedLikeNDArray):\n            return value._apply(method, *args, **kwargs)\n        elif callable(method):\n            return method(value, *args, **kwargs)\n        else:\n            return getattr(value, method)(*args, **kwargs)\n    new = super().__new__(self.__class__)\n    new._sky_coord_frame = self._sky_coord_frame._apply(method, *args, **kwargs)\n    new._extra_frameattr_names = self._extra_frameattr_names.copy()\n    for attr in self._extra_frameattr_names:\n        value = getattr(self, attr)\n        if getattr(value, 'shape', ()):\n            value = apply_method(value)\n        elif method == 'copy' or method == 'flatten':\n            value = copy.copy(value)\n        setattr(new, '_' + attr, value)\n    if 'info' in self.__dict__:\n        new.info = self.info\n    return new",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame._apply": "def _apply(self, method, *args, **kwargs):\n\n    def apply_method(value):\n        if isinstance(value, ShapedLikeNDArray):\n            return value._apply(method, *args, **kwargs)\n        elif callable(method):\n            return method(value, *args, **kwargs)\n        else:\n            return getattr(value, method)(*args, **kwargs)\n    new = super().__new__(self.__class__)\n    if hasattr(self, '_representation'):\n        new._representation = self._representation.copy()\n    new._attr_names_with_defaults = self._attr_names_with_defaults.copy()\n    for attr in self.frame_attributes:\n        _attr = '_' + attr\n        if attr in self._attr_names_with_defaults:\n            setattr(new, _attr, getattr(self, _attr))\n        else:\n            value = getattr(self, _attr)\n            if getattr(value, 'shape', ()):\n                value = apply_method(value)\n            elif method == 'copy' or method == 'flatten':\n                value = copy.copy(value)\n            setattr(new, _attr, value)\n    if self.has_data:\n        new._data = apply_method(self.data)\n    else:\n        new._data = None\n        shapes = [getattr(new, '_' + attr).shape for attr in new.frame_attributes if attr not in new._attr_names_with_defaults and getattr(getattr(new, '_' + attr), 'shape', ())]\n        if shapes:\n            new._no_data_shape = check_broadcast(*shapes) if len(shapes) > 1 else shapes[0]\n        else:\n            new._no_data_shape = ()\n    return new",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.__setattr__": "def __setattr__(self, attr, value):\n    if not attr.startswith('_'):\n        if hasattr(self, 'representation_info'):\n            repr_attr_names = set()\n            for representation_attr in self.representation_info.values():\n                repr_attr_names.update(representation_attr['names'])\n            if attr in repr_attr_names:\n                raise AttributeError(f'Cannot set any frame attribute {attr}')\n    super().__setattr__(attr, value)",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.has_data": "def has_data(self):\n    return self._data is not None",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.data": "def data(self):\n    if self._data is None:\n        raise ValueError('The frame object \"{!r}\" does not have associated data'.format(self))\n    return self._data",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.apply_method": "def apply_method(value):\n    if isinstance(value, ShapedLikeNDArray):\n        return value._apply(method, *args, **kwargs)\n    elif callable(method):\n        return method(value, *args, **kwargs)\n    else:\n        return getattr(value, method)(*args, **kwargs)",
    ".astropy.coordinates.representation.py@@UnitSphericalRepresentation.lon": "def lon(self):\n    return self._lon",
    ".astropy.coordinates.representation.py@@UnitSphericalRepresentation.lat": "def lat(self):\n    return self._lat",
    ".astropy.coordinates.sky_coordinate.py@@SkyCoord.__setattr__": "def __setattr__(self, attr, val):\n    if '_sky_coord_frame' in self.__dict__:\n        if self._is_name(attr):\n            raise AttributeError(f\"'{attr}' is immutable\")\n        if not attr.startswith('_') and hasattr(self._sky_coord_frame, attr):\n            setattr(self._sky_coord_frame, attr, val)\n            return\n        frame_cls = frame_transform_graph.lookup_name(attr)\n        if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n            raise AttributeError(f\"'{attr}' is immutable\")\n    if attr in frame_transform_graph.frame_attributes:\n        super().__setattr__('_' + attr, val)\n        frame_transform_graph.frame_attributes[attr].__get__(self)\n        self._extra_frameattr_names |= {attr}\n    else:\n        super().__setattr__(attr, val)",
    ".astropy.coordinates.transformations.py@@TransformGraph.frame_attributes": "def frame_attributes(self):\n    if self._cached_frame_attributes is None:\n        self._cached_frame_attributes = frame_attrs_from_set(self.frame_set)\n    return self._cached_frame_attributes",
    ".astropy.coordinates.sky_coordinate.py@@SkyCoord._is_name": "def _is_name(self, string):\n    return self.frame.name == string or (isinstance(self.frame.name, list) and string in self.frame.name)",
    ".astropy.coordinates.sky_coordinate.py@@SkyCoord.frame": "def frame(self):\n    return self._sky_coord_frame",
    ".astropy.coordinates.transformations.py@@TransformGraph.lookup_name": "def lookup_name(self, name):\n    return self._cached_names.get(name, None)",
    ".astropy.coordinates.transformations.py@@TransformGraph._cached_names": "def _cached_names(self):\n    if self._cached_names_dct is None:\n        self._cached_names_dct = dct = {}\n        for c in self.frame_set:\n            nm = getattr(c, 'name', None)\n            if nm is not None:\n                if not isinstance(nm, list):\n                    nm = [nm]\n                for name in nm:\n                    dct[name] = c\n    return self._cached_names_dct",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.__getattr__": "def __getattr__(self, attr):\n    if attr.startswith('_'):\n        return self.__getattribute__(attr)\n    repr_names = self.representation_component_names\n    if attr in repr_names:\n        if self._data is None:\n            self.data\n        rep = self.represent_as(self.representation_type, in_frame_units=True)\n        val = getattr(rep, repr_names[attr])\n        return val\n    diff_names = self.get_representation_component_names('s')\n    if attr in diff_names:\n        if self._data is None:\n            self.data\n        rep = self.represent_as(in_frame_units=True, **self.get_representation_cls(None))\n        val = getattr(rep.differentials['s'], diff_names[attr])\n        return val\n    return self.__getattribute__(attr)",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.get_representation_component_names": "def get_representation_component_names(self, which='base'):\n    out = {}\n    repr_or_diff_cls = self.get_representation_cls(which)\n    if repr_or_diff_cls is None:\n        return out\n    data_names = repr_or_diff_cls.attr_classes.keys()\n    repr_names = self.representation_info[repr_or_diff_cls]['names']\n    for repr_name, data_name in zip(repr_names, data_names):\n        out[repr_name] = data_name\n    return out",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.get_representation_cls": "def get_representation_cls(self, which='base'):\n    if which is not None:\n        return self._representation[which]\n    else:\n        return self._representation",
    ".astropy.utils.decorators.py@@lazyproperty.__get__": "def __get__(self, obj, owner=None):\n    try:\n        obj_dict = obj.__dict__\n        val = obj_dict.get(self._key, _NotFound)\n        if val is _NotFound:\n            with self._lock:\n                val = obj_dict.get(self._key, _NotFound)\n                if val is _NotFound:\n                    val = self.fget(obj)\n                    obj_dict[self._key] = val\n        return val\n    except AttributeError:\n        if obj is None:\n            return self\n        raise",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.representation_info": "def representation_info(self):\n    return self._get_representation_info()",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame._get_representation_info": "def _get_representation_info(cls):\n    if cls._frame_class_cache.get('last_reprdiff_hash', None) != r.get_reprdiff_cls_hash():\n        repr_attrs = {}\n        for repr_diff_cls in list(r.REPRESENTATION_CLASSES.values()) + list(r.DIFFERENTIAL_CLASSES.values()):\n            repr_attrs[repr_diff_cls] = {'names': [], 'units': []}\n            for c, c_cls in repr_diff_cls.attr_classes.items():\n                repr_attrs[repr_diff_cls]['names'].append(c)\n                rec_unit = u.deg if issubclass(c_cls, Angle) else None\n                repr_attrs[repr_diff_cls]['units'].append(rec_unit)\n        for repr_diff_cls, mappings in cls._frame_specific_representation_info.items():\n            nms = repr_attrs[repr_diff_cls]['names']\n            uns = repr_attrs[repr_diff_cls]['units']\n            comptomap = {m.reprname: m for m in mappings}\n            for i, c in enumerate(repr_diff_cls.attr_classes.keys()):\n                if c in comptomap:\n                    mapp = comptomap[c]\n                    nms[i] = mapp.framename\n                    if not (isinstance(mapp.defaultunit, str) and mapp.defaultunit == 'recommended'):\n                        uns[i] = mapp.defaultunit\n            repr_attrs[repr_diff_cls]['names'] = tuple(nms)\n            repr_attrs[repr_diff_cls]['units'] = tuple(uns)\n        cls._frame_class_cache['representation_info'] = repr_attrs\n        cls._frame_class_cache['last_reprdiff_hash'] = r.get_reprdiff_cls_hash()\n    return cls._frame_class_cache['representation_info']",
    ".astropy.coordinates.representation.py@@get_reprdiff_cls_hash": "def get_reprdiff_cls_hash():\n    global _REPRDIFF_HASH\n    if _REPRDIFF_HASH is None:\n        _REPRDIFF_HASH = hash(tuple(REPRESENTATION_CLASSES.items())) + hash(tuple(DIFFERENTIAL_CLASSES.items()))\n    return _REPRDIFF_HASH",
    ".astropy.coordinates.sky_coordinate.py@@SkyCoord.shape": "def shape(self):\n    return self.frame.shape",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.shape": "def shape(self):\n    return self.data.shape if self.has_data else self._no_data_shape",
    ".astropy.coordinates.representation.py@@SphericalRepresentation.lon": "def lon(self):\n    return self._lon",
    ".astropy.coordinates.representation.py@@SphericalRepresentation.lat": "def lat(self):\n    return self._lat",
    ".astropy.coordinates.representation.py@@SphericalRepresentation.distance": "def distance(self):\n    return self._distance",
    ".astropy.time.core.py@@TimeBase._apply": "def _apply(self, method, *args, format=None, cls=None, **kwargs):\n    new_format = self.format if format is None else format\n    if callable(method):\n        apply_method = lambda array: method(array, *args, **kwargs)\n    elif method == 'replicate':\n        apply_method = None\n    else:\n        apply_method = operator.methodcaller(method, *args, **kwargs)\n    jd1, jd2 = (self._time.jd1, self._time.jd2)\n    if apply_method:\n        jd1 = apply_method(jd1)\n        jd2 = apply_method(jd2)\n    tm = super().__new__(cls or self.__class__)\n    tm._time = TimeJD(jd1, jd2, self.scale, precision=0, in_subfmt='*', out_subfmt='*', from_jd=True)\n    for attr in ('_delta_ut1_utc', '_delta_tdb_tt', 'location'):\n        try:\n            val = getattr(self, attr)\n        except AttributeError:\n            continue\n        if apply_method:\n            if getattr(val, 'shape', ()):\n                val = apply_method(val)\n            elif method == 'copy' or method == 'flatten':\n                val = copy.copy(val)\n        setattr(tm, attr, val)\n    if 'info' in self.__dict__:\n        tm.info = self.info\n    if new_format not in tm.FORMATS:\n        raise ValueError(f'format must be one of {list(tm.FORMATS)}')\n    NewFormat = tm.FORMATS[new_format]\n    tm._time = NewFormat(tm._time.jd1, tm._time.jd2, tm._time._scale, precision=self.precision, in_subfmt=NewFormat._get_allowed_subfmt(self.in_subfmt), out_subfmt=NewFormat._get_allowed_subfmt(self.out_subfmt), from_jd=True)\n    tm._format = new_format\n    tm.SCALES = self.SCALES\n    return tm",
    ".astropy.time.core.py@@TimeBase.format": "def format(self):\n    return self._format",
    ".astropy.time.formats.py@@TimeFormat.jd1": "def jd1(self):\n    return self._jd1",
    ".astropy.time.formats.py@@TimeFormat.jd2": "def jd2(self):\n    return self._jd2",
    ".astropy.time.core.py@@TimeBase.scale": "def scale(self):\n    return self._time.scale",
    ".astropy.time.formats.py@@TimeFormat.scale": "def scale(self):\n    self._scale = self._check_scale(self._scale)\n    return self._scale",
    ".astropy.time.formats.py@@TimeFormat._check_scale": "def _check_scale(self, scale):\n    if scale is None:\n        scale = self._default_scale\n    if scale not in TIME_SCALES:\n        raise ScaleValueError(\"Scale value '{}' not in allowed values {}\".format(scale, TIME_SCALES))\n    return scale",
    ".astropy.time.formats.py@@TimeFormat.__init__": "def __init__(self, val1, val2, scale, precision, in_subfmt, out_subfmt, from_jd=False):\n    self.scale = scale\n    self.precision = precision\n    self.in_subfmt = in_subfmt\n    self.out_subfmt = out_subfmt\n    self._jd1, self._jd2 = (None, None)\n    if from_jd:\n        self.jd1 = val1\n        self.jd2 = val2\n    else:\n        val1, val2 = self._check_val_type(val1, val2)\n        self.set_jds(val1, val2)",
    ".astropy.time.formats.py@@TimeFormat.precision": "def precision(self):\n    return self._precision",
    ".astropy.time.formats.py@@TimeFormat.in_subfmt": "def in_subfmt(self):\n    return self._in_subfmt",
    ".astropy.time.formats.py@@TimeFormat._select_subfmts": "def _select_subfmts(cls, pattern):\n    if not isinstance(pattern, str):\n        raise ValueError('subfmt attribute must be a string')\n    elif pattern == '*':\n        return cls.subfmts\n    subfmts = [x for x in cls.subfmts if fnmatch.fnmatchcase(x[0], pattern)]\n    if len(subfmts) == 0:\n        if len(cls.subfmts) == 0:\n            raise ValueError(f'subformat not allowed for format {cls.name}')\n        else:\n            subfmt_names = [x[0] for x in cls.subfmts]\n            raise ValueError(f'subformat {pattern!r} must match one of {subfmt_names} for format {cls.name}')\n    return subfmts",
    ".astropy.time.formats.py@@TimeFormat.out_subfmt": "def out_subfmt(self):\n    return self._out_subfmt",
    ".astropy.time.formats.py@@_validate_jd_for_storage": "def _validate_jd_for_storage(jd):\n    if isinstance(jd, (float, int)):\n        return np.array(jd, dtype=np.float_)\n    if isinstance(jd, np.generic) and (jd.dtype.kind == 'f' and jd.dtype.itemsize <= 8 or jd.dtype.kind in 'iu'):\n        return np.array(jd, dtype=np.float_)\n    elif isinstance(jd, np.ndarray) and jd.dtype.kind == 'f' and (jd.dtype.itemsize == 8):\n        return jd\n    else:\n        raise TypeError(f'JD values must be arrays (possibly zero-dimensional) of floats but we got {jd!r} of type {type(jd)}')",
    ".astropy.time.formats.py@@_broadcast_writeable": "def _broadcast_writeable(jd1, jd2):\n    if jd1.shape == jd2.shape:\n        return (jd1, jd2)\n    shape = np.broadcast(jd1, jd2).shape\n    if jd1.shape == shape:\n        s_jd1 = jd1\n    else:\n        s_jd1 = np.require(np.broadcast_to(jd1, shape), requirements=['C', 'W'])\n    if jd2.shape == shape:\n        s_jd2 = jd2\n    else:\n        s_jd2 = np.require(np.broadcast_to(jd2, shape), requirements=['C', 'W'])\n    return (s_jd1, s_jd2)",
    ".astropy.time.core.py@@TimeBase.__getattr__": "def __getattr__(self, attr):\n    if attr in self.SCALES and self.scale is not None:\n        cache = self.cache['scale']\n        if attr not in cache:\n            if attr == self.scale:\n                tm = self\n            else:\n                tm = self.replicate()\n                tm._set_scale(attr)\n                if tm.shape:\n                    tm.writeable = False\n            cache[attr] = tm\n        return cache[attr]\n    elif attr in self.FORMATS:\n        return self.to_value(attr, subfmt=None)\n    elif attr in TIME_SCALES:\n        if self.scale is None:\n            raise ScaleValueError('Cannot convert TimeDelta with undefined scale to any defined scale.')\n        else:\n            raise ScaleValueError(\"Cannot convert {} with scale '{}' to scale '{}'\".format(self.__class__.__name__, self.scale, attr))\n    else:\n        return self.__getattribute__(attr)",
    ".astropy.time.core.py@@TimeBase.precision": "def precision(self):\n    return self._time.precision",
    ".astropy.time.core.py@@TimeBase.in_subfmt": "def in_subfmt(self):\n    return self._time.in_subfmt",
    ".astropy.time.formats.py@@TimeFormat._get_allowed_subfmt": "def _get_allowed_subfmt(cls, subfmt):\n    try:\n        cls._select_subfmts(subfmt)\n    except ValueError:\n        subfmt = '*'\n    return subfmt",
    ".astropy.time.core.py@@TimeBase.out_subfmt": "def out_subfmt(self):\n    return self._time.out_subfmt",
    ".astropy.time.core.py@@TimeBase.copy": "def copy(self, format=None):\n    return self._apply('copy', format=format)",
    ".astropy.time.core.py@@TimeInfoBase.__init__": "def __init__(self, bound=False):\n    super().__init__(bound)\n    if bound:\n        self.serialize_method = {'fits': 'jd1_jd2', 'ecsv': 'formatted_value', 'hdf5': 'jd1_jd2', 'yaml': 'jd1_jd2', 'parquet': 'jd1_jd2', None: 'jd1_jd2'}",
    ".astropy.utils.data_info.py@@InfoAttribute.__set__": "def __set__(self, instance, value):\n    if instance is None:\n        raise ValueError('cannot set unbound descriptor')\n    instance._attrs[self.attr] = value",
    ".astropy.time.core.py@@TimeBase.shape": "def shape(self):\n    return self._time.jd1.shape",
    ".astropy.time.formats.py@@TimeDeltaFormat._check_scale": "def _check_scale(self, scale):\n    if scale is not None and scale not in TIME_DELTA_SCALES:\n        raise ScaleValueError(\"Scale value '{}' not in allowed values {}\".format(scale, TIME_DELTA_SCALES))\n    return scale",
    ".astropy.table.column.py@@MaskedColumn.__new__": "def __new__(cls, data=None, name=None, mask=None, fill_value=None, dtype=None, shape=(), length=0, description=None, unit=None, format=None, meta=None, copy=False, copy_indices=True):\n    if mask is None:\n        mask = ma.MaskedArray(data).mask\n        if mask is np.ma.nomask:\n            mask = False\n        elif copy:\n            mask = mask.copy()\n    elif mask is np.ma.nomask:\n        mask = False\n    else:\n        mask = deepcopy(mask)\n    self_data = BaseColumn(data, dtype=dtype, shape=shape, length=length, name=name, unit=unit, format=format, description=description, meta=meta, copy=copy, copy_indices=copy_indices)\n    self = ma.MaskedArray.__new__(cls, data=self_data, mask=mask)\n    if 'info' in getattr(data, '__dict__', {}):\n        self.info = data.info\n    if fill_value is None:\n        data_fill_value = getattr(data, 'fill_value', None)\n        if data_fill_value is not None and data_fill_value != np.ma.default_fill_value(data.dtype):\n            fill_value = np.array(data_fill_value, self.dtype)[()]\n    self.fill_value = fill_value\n    self.parent_table = None\n    for index in self.indices:\n        index.replace_col(self_data, self)\n    return self",
    ".astropy.table.column.py@@MaskedColumn.fill_value": "def fill_value(self):\n    return self.get_fill_value()",
    ".astropy.table.column.py@@MaskedColumnInfo.__init__": "def __init__(self, bound=False):\n    super().__init__(bound)\n    if bound:\n        self.serialize_method = {'fits': 'null_value', 'ecsv': 'null_value', 'hdf5': 'data_mask', 'parquet': 'data_mask', None: 'null_value'}",
    ".astropy.table.table.py@@QTable._is_mixin_for_table": "def _is_mixin_for_table(self, col):\n    return has_info_class(col, MixinInfo)",
    ".astropy.table.column.py@@_convert_sequence_data_to_array": "def _convert_sequence_data_to_array(data, dtype=None):\n    np_ma_masked = np.ma.masked\n    if hasattr(data, '__len__') and len(data) > 0 and all((isinstance(val, np.ma.MaskedArray) and val is not np_ma_masked for val in data)):\n        np_data = np.ma.array(data, dtype=dtype)\n        return np_data\n    with warnings.catch_warnings(record=True) as warns:\n        warnings.filterwarnings('always', category=UserWarning, message='.*converting a masked element.*')\n        warnings.filterwarnings('always', category=FutureWarning, message='.*Promotion of numbers and bools to strings.*')\n        try:\n            np_data = np.array(data, dtype=dtype)\n        except np.ma.MaskError:\n            np_data = np.array(data)\n        except Exception:\n            try:\n                np_data = Quantity(data, dtype)\n            except Exception:\n                dtype = object\n                np_data = np.array(data, dtype=dtype)\n    if np_data.ndim == 0 or (np_data.ndim > 0 and len(np_data) == 0):\n        return data\n    if len(warns) == 0 and np_data.dtype.kind in ('i', 'f'):\n        return np_data\n    any_statement = 'd0 is ma_masked'\n    for ii in reversed(range(np_data.ndim)):\n        if ii == 0:\n            any_statement = f'any({any_statement} for d0 in data)'\n        elif ii == np_data.ndim - 1:\n            any_statement = f'any(d{ii} is ma_masked for d{ii} in d{ii - 1})'\n        else:\n            any_statement = f'any({any_statement} for d{ii} in d{ii - 1})'\n    context = {'ma_masked': np.ma.masked, 'data': data}\n    has_masked = eval(any_statement, context)\n    if has_masked:\n        mask = np.zeros(np_data.shape, dtype=bool)\n        data_filled = np.array(data, dtype=object)\n        if np_data.dtype.kind == 'U':\n            fill = ''\n        elif np_data.dtype.kind == 'S':\n            fill = b''\n        else:\n            fill = 0\n        ranges = [range(dim) for dim in np_data.shape]\n        for idxs in itertools.product(*ranges):\n            val = data_filled[idxs]\n            if val is np_ma_masked:\n                data_filled[idxs] = fill\n                mask[idxs] = True\n            elif isinstance(val, bool) and dtype is None:\n                dtype = bool\n        if dtype is None:\n            data_filled = data_filled.tolist()\n        np_data = np.ma.array(np.array(data_filled, dtype=dtype), mask=mask)\n    return np_data",
    ".astropy.table.table_helpers.py@@ArrayWrapper.__init__": "def __init__(self, data, copy=True):\n    self.data = np.array(data, copy=copy)\n    if 'info' in getattr(data, '__dict__', ()):\n        self.info = data.info",
    ".astropy.units.quantity.py@@Quantity.isscalar": "def isscalar(self):\n    return not self.shape",
    ".astropy.utils.shapes.py@@ShapedLikeNDArray.isscalar": "def isscalar(self):\n    return self.shape == ()",
    ".astropy.table.column.py@@MaskedColumn.data": "def data(self):\n    out = self.view(np.ma.MaskedArray)\n    out._baseclass = np.ndarray\n    return out",
    ".astropy.table.column.py@@MaskedColumn._copy_attrs_slice": "def _copy_attrs_slice(self, out):\n    if out.__class__ is self.__class__:\n        if 'info' in self.__dict__:\n            out.info = self.info\n        out.parent_table = None\n        if out.indices is self.indices:\n            out.indices = []\n        out._copy_attrs(self)\n    return out",
    ".astropy.table.table.py@@QTable._convert_col_for_table": "def _convert_col_for_table(self, col):\n    if isinstance(col, Column) and getattr(col, 'unit', None) is not None:\n        q_cls = Masked(Quantity) if isinstance(col, MaskedColumn) else Quantity\n        try:\n            qcol = q_cls(col.data, col.unit, copy=False, subok=True)\n        except Exception as exc:\n            warnings.warn(f'column {col.info.name} has a unit but is kept as a {col.__class__.__name__} as an attempt to convert it to Quantity failed with:\\n{exc!r}', AstropyUserWarning)\n        else:\n            qcol.info = col.info\n            qcol.info.indices = col.info.indices\n            col = qcol\n    else:\n        col = super()._convert_col_for_table(col)\n    return col",
    ".astropy.utils.masked.core.py@@Masked.__new__": "def __new__(cls, *args, **kwargs):\n    if cls is Masked:\n        if not kwargs and len(args) == 1 and isinstance(args[0], type):\n            return cls._get_masked_cls(args[0])\n        else:\n            return cls._get_masked_instance(*args, **kwargs)\n    else:\n        return super().__new__(cls, *args, **kwargs)",
    ".astropy.utils.masked.core.py@@Masked._get_masked_cls": "def _get_masked_cls(cls, data_cls):\n    if issubclass(data_cls, (Masked, np.ma.MaskedArray)):\n        return data_cls\n    masked_cls = cls._masked_classes.get(data_cls)\n    if masked_cls is None:\n        for mro_item in data_cls.__mro__:\n            base_cls = cls._base_classes.get(mro_item)\n            if base_cls is not None:\n                break\n        else:\n            return MaskedNDArray\n        masked_cls = type('Masked' + data_cls.__name__, (data_cls, base_cls), {}, data_cls=data_cls)\n    return masked_cls",
    ".astropy.utils.masked.core.py@@MaskedNDArray.__init_subclass__": "def __init_subclass__(cls, **kwargs):\n    super().__init_subclass__(cls, **kwargs)\n    if '__new__' not in cls.__dict__:\n\n        def __new__(newcls, *args, mask=None, **kwargs):\n            self = super(cls, newcls).__new__(newcls, *args, **kwargs)\n            if mask is not None:\n                self.mask = mask\n            elif self._mask is None:\n                self.mask = False\n            return self\n        cls.__new__ = __new__\n    if 'info' not in cls.__dict__ and hasattr(cls._data_cls, 'info'):\n        data_info = cls._data_cls.info\n        attr_names = data_info.attr_names | {'serialize_method'}\n        new_info = type(cls.__name__ + 'Info', (MaskedArraySubclassInfo, data_info.__class__), dict(attr_names=attr_names))\n        cls.info = new_info()",
    ".astropy.utils.masked.core.py@@Masked.__init_subclass__": "def __init_subclass__(cls, base_cls=None, data_cls=None, **kwargs):\n    if base_cls is not None:\n        Masked._base_classes[base_cls] = cls\n    if data_cls is not None:\n        cls._data_cls = data_cls\n        cls._masked_classes[data_cls] = cls\n        if cls.__doc__ is None:\n            cls.__doc__ = get__doc__(data_cls)\n    super().__init_subclass__(**kwargs)",
    ".astropy.utils.data_info.py@@DataInfoMeta.__new__": "def __new__(mcls, name, bases, dct):\n    dct.setdefault('__slots__', [])\n    return super().__new__(mcls, name, bases, dct)",
    ".astropy.utils.data_info.py@@DataInfoMeta.__init__": "def __init__(cls, name, bases, dct):\n    super().__init__(name, bases, dct)\n    for attr in cls.attr_names:\n        if attr not in dct:\n            cls_attr = getattr(cls, attr, None)\n            if attr in cls.attrs_from_parent:\n                if 'attrs_from_parent' in dct and (not isinstance(cls_attr, ParentAttribute)):\n                    setattr(cls, attr, ParentAttribute(attr))\n            elif not cls_attr or isinstance(cls_attr, ParentAttribute):\n                setattr(cls, attr, InfoAttribute(attr, cls._attr_defaults.get(attr)))",
    ".astropy.utils.data_info.py@@InfoAttribute.__init__": "def __init__(self, attr, default=None):\n    self.attr = attr\n    self.default = default",
    ".astropy.utils.data_info.py@@ParentAttribute.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        return self\n    return getattr(instance._parent, self.attr)",
    ".astropy.utils.masked.core.py@@MaskedInfoBase.__init__": "def __init__(self, bound=False):\n    super().__init__(bound)\n    if bound:\n        self.serialize_method = {'fits': 'null_value', 'ecsv': 'null_value', 'hdf5': 'data_mask', 'parquet': 'data_mask', None: 'null_value'}",
    ".astropy.utils.masked.core.py@@MaskedNDArray.__new__": "def __new__(cls, *args, mask=None, **kwargs):\n    self = super().__new__(cls, *args, **kwargs)\n    if mask is not None:\n        self.mask = mask\n    elif self._mask is None:\n        self.mask = False\n    return self",
    ".astropy.units.quantity.py@@Quantity.__new__": "def __new__(cls, value, unit=None, dtype=np.inexact, copy=True, order=None, subok=False, ndmin=0):\n    if unit is not None:\n        unit = Unit(unit)\n    float_default = dtype is np.inexact\n    if float_default:\n        dtype = None\n    if isinstance(value, Quantity):\n        if unit is not None and unit is not value.unit:\n            value = value.to(unit)\n            copy = False\n        if type(value) is not cls and (not (subok and isinstance(value, cls))):\n            value = value.view(cls)\n        if float_default and value.dtype.kind in 'iu':\n            dtype = float\n        return np.array(value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin)\n    value_unit = None\n    if not isinstance(value, np.ndarray):\n        if isinstance(value, str):\n            pattern = '\\\\s*[+-]?((\\\\d+\\\\.?\\\\d*)|(\\\\.\\\\d+)|([nN][aA][nN])|([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))([eE][+-]?\\\\d+)?[.+-]?'\n            v = re.match(pattern, value)\n            unit_string = None\n            try:\n                value = float(v.group())\n            except Exception:\n                raise TypeError('Cannot parse \"{}\" as a {}. It does not start with a number.'.format(value, cls.__name__))\n            unit_string = v.string[v.end():].strip()\n            if unit_string:\n                value_unit = Unit(unit_string)\n                if unit is None:\n                    unit = value_unit\n        elif isiterable(value) and len(value) > 0:\n            if all((isinstance(v, Quantity) for v in value)):\n                if unit is None:\n                    unit = value[0].unit\n                value = [q.to_value(unit) for q in value]\n                value_unit = unit\n            elif dtype is None and (not hasattr(value, 'dtype')) and isinstance(unit, StructuredUnit):\n                dtype = unit._recursively_get_dtype(value)\n    using_default_unit = False\n    if value_unit is None:\n        value_unit = getattr(value, 'unit', None)\n        if value_unit is None:\n            if unit is None:\n                using_default_unit = True\n                unit = cls._default_unit\n            value_unit = unit\n        else:\n            try:\n                value_unit = Unit(value_unit)\n            except Exception as exc:\n                raise TypeError('The unit attribute {!r} of the input could not be parsed as an astropy Unit, raising the following exception:\\n{}'.format(value.unit, exc))\n            if unit is None:\n                unit = value_unit\n            elif unit is not value_unit:\n                copy = False\n    value = np.array(value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin)\n    if using_default_unit and value.dtype.names is not None:\n        unit = value_unit = _structured_unit_like_dtype(value_unit, value.dtype)\n    if value.dtype.kind in 'OSU' and (not (value.dtype.kind == 'O' and isinstance(value.item(0), numbers.Number))):\n        raise TypeError('The value must be a valid Python or Numpy numeric type.')\n    if float_default and value.dtype.kind in 'iuO':\n        value = value.astype(float)\n    if subok:\n        qcls = getattr(unit, '_quantity_class', cls)\n        if issubclass(qcls, cls):\n            cls = qcls\n    value = value.view(cls)\n    value._set_unit(value_unit)\n    if unit is value_unit:\n        return value\n    else:\n        return value.to(unit)",
    ".astropy.utils.masked.core.py@@MaskedNDArray.__array_finalize__": "def __array_finalize__(self, obj):\n    if obj is None or obj.__class__ is np.ndarray:\n        return\n    super_array_finalize = super().__array_finalize__\n    if super_array_finalize:\n        super_array_finalize(obj)\n    if self._mask is None:\n        self._set_mask(getattr(obj, '_mask', False))\n    if 'info' in obj.__dict__:\n        self.info = obj.info",
    ".astropy.utils.masked.core.py@@Masked._set_mask": "def _set_mask(self, mask, copy=False):\n    self_dtype = getattr(self, 'dtype', None)\n    mask_dtype = np.ma.make_mask_descr(self_dtype) if self_dtype and self_dtype.names else np.dtype('?')\n    ma = np.asanyarray(mask, dtype=mask_dtype)\n    if ma.shape != self.shape:\n        self._mask = np.empty(self.shape, dtype=mask_dtype)\n        self._mask[...] = ma\n    elif ma is mask:\n        self._mask = mask.copy() if copy else mask.view()\n    else:\n        self._mask = ma",
    ".astropy.utils.masked.core.py@@MaskedNDArray.shape": "def shape(self):\n    return super().shape",
    ".astropy.utils.data_info.py@@DataInfo._parent": "def _parent(self):\n    try:\n        parent = self._parent_ref()\n    except AttributeError:\n        return None\n    if parent is None:\n        raise AttributeError('failed to access \"info\" attribute on a temporary object.\\n\\nIt looks like you have done something like ``col[3:5].info`` or\\n``col.quantity.info``, i.e.  you accessed ``info`` from a temporary slice\\nobject that only exists momentarily.  This has failed because the reference to\\nthat temporary object is now lost.  Instead force a permanent reference (e.g.\\n``c = col[3:5]`` followed by ``c.info``).')\n    return parent",
    ".astropy.coordinates.sky_coordinate.py@@SkyCoord.__getattr__": "def __getattr__(self, attr):\n    if '_sky_coord_frame' in self.__dict__:\n        if self._is_name(attr):\n            return self\n        if attr in frame_transform_graph.frame_attributes:\n            if attr in self.frame.get_frame_attr_names():\n                return getattr(self.frame, attr)\n            else:\n                return getattr(self, '_' + attr, None)\n        if not attr.startswith('_') and hasattr(self._sky_coord_frame, attr):\n            return getattr(self._sky_coord_frame, attr)\n        frame_cls = frame_transform_graph.lookup_name(attr)\n        if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n            return self.transform_to(attr)\n    raise AttributeError(\"'{}' object has no attribute '{}'\".format(self.__class__.__name__, attr))",
    ".astropy.coordinates.baseframe.py@@BaseCoordinateFrame.get_frame_attr_names": "def get_frame_attr_names(cls):\n    return {name: getattr(cls, name) for name in cls.frame_attributes}"
}