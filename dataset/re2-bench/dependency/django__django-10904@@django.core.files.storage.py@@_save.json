{
    ".django.utils._os.py@@safe_join": "def safe_join(base, *paths):\n    final_path = abspath(join(base, *paths))\n    base_path = abspath(base)\n    if not normcase(final_path).startswith(normcase(base_path + sep)) and normcase(final_path) != normcase(base_path) and (dirname(normcase(base_path)) != normcase(base_path)):\n        raise SuspiciousFileOperation('The joined path ({}) is located outside of the base path component ({})'.format(final_path, base_path))\n    return final_path",
    ".django.utils.functional.py@@cached_property.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    res = instance.__dict__[self.name] = self.func(instance)\n    return res",
    ".django.conf.__init__.py@@LazySettings.__getattr__": "def __getattr__(self, name):\n    if self._wrapped is empty:\n        self._setup(name)\n    val = getattr(self._wrapped, name)\n    self.__dict__[name] = val\n    return val",
    ".django.core.files.locks.py@@lock": "def lock(f, flags):\n    ret = fcntl.flock(_fd(f), flags)\n    return ret == 0",
    ".django.core.files.locks.py@@_fd": "def _fd(f):\n    return f.fileno() if hasattr(f, 'fileno') else f",
    ".django.core.files.base.py@@File.chunks": "def chunks(self, chunk_size=None):\n    chunk_size = chunk_size or self.DEFAULT_CHUNK_SIZE\n    try:\n        self.seek(0)\n    except (AttributeError, UnsupportedOperation):\n        pass\n    while True:\n        data = self.read(chunk_size)\n        if not data:\n            break\n        yield data",
    ".django.core.files.locks.py@@unlock": "def unlock(f):\n    ret = fcntl.flock(_fd(f), fcntl.LOCK_UN)\n    return ret == 0",
    ".django.core.files.uploadedfile.py@@InMemoryUploadedFile.chunks": "def chunks(self, chunk_size=None):\n    self.file.seek(0)\n    yield self.read()",
    ".django.core.files.uploadedfile.py@@TemporaryUploadedFile.temporary_file_path": "def temporary_file_path(self):\n    return self.file.name",
    ".django.core.files.move.py@@file_move_safe": "def file_move_safe(old_file_name, new_file_name, chunk_size=1024 * 64, allow_overwrite=False):\n    if _samefile(old_file_name, new_file_name):\n        return\n    try:\n        if not allow_overwrite and os.access(new_file_name, os.F_OK):\n            raise FileExistsError('Destination file %s exists and allow_overwrite is False.' % new_file_name)\n        os.rename(old_file_name, new_file_name)\n        return\n    except OSError:\n        pass\n    with open(old_file_name, 'rb') as old_file:\n        fd = os.open(new_file_name, os.O_WRONLY | os.O_CREAT | getattr(os, 'O_BINARY', 0) | (os.O_EXCL if not allow_overwrite else 0))\n        try:\n            locks.lock(fd, locks.LOCK_EX)\n            current_chunk = None\n            while current_chunk != b'':\n                current_chunk = old_file.read(chunk_size)\n                os.write(fd, current_chunk)\n        finally:\n            locks.unlock(fd)\n            os.close(fd)\n    try:\n        copystat(old_file_name, new_file_name)\n    except PermissionError as e:\n        if e.errno != errno.EPERM:\n            raise\n    try:\n        os.remove(old_file_name)\n    except PermissionError as e:\n        if getattr(e, 'winerror', 0) != 32:\n            raise",
    ".django.core.files.move.py@@_samefile": "def _samefile(src, dst):\n    if hasattr(os.path, 'samefile'):\n        try:\n            return os.path.samefile(src, dst)\n        except OSError:\n            return False\n    return os.path.normcase(os.path.abspath(src)) == os.path.normcase(os.path.abspath(dst))",
    ".django.conf.__init__.py@@UserSettingsHolder.__getattr__": "def __getattr__(self, name):\n    if name in self._deleted:\n        raise AttributeError\n    return getattr(self.default_settings, name)",
    ".django.core.servers.basehttp.py@@ServerHandler.close": "def close(self):\n    self.get_stdin()._read_limited()\n    super().close()",
    ".django.core.handlers.wsgi.py@@LimitedStream._read_limited": "def _read_limited(self, size=None):\n    if size is None or size > self.remaining:\n        size = self.remaining\n    if size == 0:\n        return b''\n    result = self.stream.read(size)\n    self.remaining -= len(result)\n    return result",
    ".django.test.testcases.py@@QuietWSGIRequestHandler.log_message": "def log_message(*args):\n    pass",
    ".django.http.response.py@@HttpResponseBase.close": "def close(self):\n    for closable in self._closable_objects:\n        try:\n            closable.close()\n        except Exception:\n            pass\n    self.closed = True\n    signals.request_finished.send(sender=self._handler_class)",
    ".django.http.request.py@@HttpRequest.close": "def close(self):\n    if hasattr(self, '_files'):\n        for f in chain.from_iterable((l[1] for l in self._files.lists())):\n            f.close()",
    ".django.dispatch.dispatcher.py@@Signal.send": "def send(self, sender, **named):\n    if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS:\n        return []\n    return [(receiver, receiver(signal=self, sender=sender, **named)) for receiver in self._live_receivers(sender)]",
    ".django.dispatch.dispatcher.py@@Signal._live_receivers": "def _live_receivers(self, sender):\n    receivers = None\n    if self.use_caching and (not self._dead_receivers):\n        receivers = self.sender_receivers_cache.get(sender)\n        if receivers is NO_RECEIVERS:\n            return []\n    if receivers is None:\n        with self.lock:\n            self._clear_dead_receivers()\n            senderkey = _make_id(sender)\n            receivers = []\n            for (receiverkey, r_senderkey), receiver in self.receivers:\n                if r_senderkey == NONE_ID or r_senderkey == senderkey:\n                    receivers.append(receiver)\n            if self.use_caching:\n                if not receivers:\n                    self.sender_receivers_cache[sender] = NO_RECEIVERS\n                else:\n                    self.sender_receivers_cache[sender] = receivers\n    non_weak_receivers = []\n    for receiver in receivers:\n        if isinstance(receiver, weakref.ReferenceType):\n            receiver = receiver()\n            if receiver is not None:\n                non_weak_receivers.append(receiver)\n        else:\n            non_weak_receivers.append(receiver)\n    return non_weak_receivers",
    ".django.dispatch.dispatcher.py@@Signal._clear_dead_receivers": "def _clear_dead_receivers(self):\n    if self._dead_receivers:\n        self._dead_receivers = False\n        self.receivers = [r for r in self.receivers if not (isinstance(r[1], weakref.ReferenceType) and r[1]() is None)]",
    ".django.dispatch.dispatcher.py@@_make_id": "def _make_id(target):\n    if hasattr(target, '__func__'):\n        return (id(target.__self__), id(target.__func__))\n    return id(target)",
    ".django.core.cache.__init__.py@@close_caches": "def close_caches(**kwargs):\n    for cache in caches.all():\n        cache.close()",
    ".django.core.cache.__init__.py@@CacheHandler.all": "def all(self):\n    return getattr(self._caches, 'caches', {}).values()",
    ".django.core.handlers.base.py@@reset_urlconf": "def reset_urlconf(sender, **kwargs):\n    set_urlconf(None)",
    ".django.urls.base.py@@set_urlconf": "def set_urlconf(urlconf_name):\n    if urlconf_name:\n        _urlconfs.value = urlconf_name\n    elif hasattr(_urlconfs, 'value'):\n        del _urlconfs.value",
    ".django.db.__init__.py@@close_old_connections": "def close_old_connections(**kwargs):\n    for conn in connections.all():\n        conn.close_if_unusable_or_obsolete()",
    ".django.db.utils.py@@ConnectionHandler.all": "def all(self):\n    return [self[alias] for alias in self]",
    ".django.db.utils.py@@ConnectionHandler.__iter__": "def __iter__(self):\n    return iter(self.databases)",
    ".django.db.utils.py@@ConnectionHandler.__getitem__": "def __getitem__(self, alias):\n    if hasattr(self._connections, alias):\n        return getattr(self._connections, alias)\n    self.ensure_defaults(alias)\n    self.prepare_test_settings(alias)\n    db = self.databases[alias]\n    backend = load_backend(db['ENGINE'])\n    conn = backend.DatabaseWrapper(db, alias)\n    setattr(self._connections, alias, conn)\n    return conn",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.close_if_unusable_or_obsolete": "def close_if_unusable_or_obsolete(self):\n    if self.connection is not None:\n        if self.get_autocommit() != self.settings_dict['AUTOCOMMIT']:\n            self.close()\n            return\n        if self.errors_occurred:\n            if self.is_usable():\n                self.errors_occurred = False\n            else:\n                self.close()\n                return\n        if self.close_at is not None and time.time() >= self.close_at:\n            self.close()\n            return"
}