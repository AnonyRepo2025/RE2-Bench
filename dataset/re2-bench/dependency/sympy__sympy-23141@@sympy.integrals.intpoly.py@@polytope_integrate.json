{
    ".sympy.integrals.intpoly.py@@hyperplane_parameters": "def hyperplane_parameters(poly, vertices=None):\n    if isinstance(poly, Polygon):\n        vertices = list(poly.vertices) + [poly.vertices[0]]\n        params = [None] * (len(vertices) - 1)\n        for i in range(len(vertices) - 1):\n            v1 = vertices[i]\n            v2 = vertices[i + 1]\n            a1 = v1[1] - v2[1]\n            a2 = v2[0] - v1[0]\n            b = v2[0] * v1[1] - v2[1] * v1[0]\n            factor = gcd_list([a1, a2, b])\n            b = S(b) / factor\n            a = (S(a1) / factor, S(a2) / factor)\n            params[i] = (a, b)\n    else:\n        params = [None] * len(poly)\n        for i, polygon in enumerate(poly):\n            v1, v2, v3 = [vertices[vertex] for vertex in polygon[:3]]\n            normal = cross_product(v1, v2, v3)\n            b = sum([normal[j] * v1[j] for j in range(0, 3)])\n            fac = gcd_list(normal)\n            if fac.is_zero:\n                fac = 1\n            normal = [j / fac for j in normal]\n            b = b / fac\n            params[i] = (normal, b)\n    return params",
    ".sympy.geometry.polygon.py@@Triangle.vertices": "def vertices(self):\n    return self.args",
    ".sympy.core.basic.py@@Basic.args": "def args(self) -> 'Tuple[Basic, ...]':\n    return self._args",
    ".sympy.geometry.point.py@@Point.__getitem__": "def __getitem__(self, key):\n    return self.args[key]",
    ".sympy.core.numbers.py@@Integer.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, str):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    if ival == 1:\n        return S.One\n    if ival == -1:\n        return S.NegativeOne\n    if ival == 0:\n        return S.Zero\n    obj = Expr.__new__(cls)\n    obj.p = ival\n    return obj",
    ".sympy.core.numbers.py@@Integer.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p * other)\n        elif isinstance(other, Integer):\n            return Integer(self.p * other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    ".sympy.polys.polytools.py@@gcd_list": "def gcd_list(seq, *gens, **args):\n    seq = sympify(seq)\n\n    def try_non_polynomial_gcd(seq):\n        if not gens and (not args):\n            domain, numbers = construct_domain(seq)\n            if not numbers:\n                return domain.zero\n            elif domain.is_Numerical:\n                result, numbers = (numbers[0], numbers[1:])\n                for number in numbers:\n                    result = domain.gcd(result, number)\n                    if domain.is_one(result):\n                        break\n                return domain.to_sympy(result)\n        return None\n    result = try_non_polynomial_gcd(seq)\n    if result is not None:\n        return result\n    options.allowed_flags(args, ['polys'])\n    try:\n        polys, opt = parallel_poly_from_expr(seq, *gens, **args)\n        if len(seq) > 1 and all((elt.is_algebraic and elt.is_irrational for elt in seq)):\n            a = seq[-1]\n            lst = [(a / elt).ratsimp() for elt in seq[:-1]]\n            if all((frc.is_rational for frc in lst)):\n                lc = 1\n                for frc in lst:\n                    lc = lcm(lc, frc.as_numer_denom()[0])\n                return abs(a / lc)\n    except PolificationFailed as exc:\n        result = try_non_polynomial_gcd(exc.exprs)\n        if result is not None:\n            return result\n        else:\n            raise ComputationFailed('gcd_list', len(seq), exc)\n    if not polys:\n        if not opt.polys:\n            return S.Zero\n        else:\n            return Poly(0, opt=opt)\n    result, polys = (polys[0], polys[1:])\n    for poly in polys:\n        result = result.gcd(poly)\n        if result.is_one:\n            break\n    if not opt.polys:\n        return result.as_expr()\n    else:\n        return result",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    cls = getattr(a, '__class__', None)\n    for superclass in getmro(cls):\n        conv = _external_converter.get(superclass)\n        if conv is None:\n            conv = _sympy_converter.get(superclass)\n        if conv is not None:\n            return conv(a)\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from sympy.tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(), locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        else:\n            for coerce in (float, int):\n                try:\n                    return sympify(coerce(a))\n                except (TypeError, ValueError, AttributeError, SympifyError):\n                    continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational, evaluate=evaluate) for x in a])\n        except TypeError:\n            pass\n    if not isinstance(a, str):\n        try:\n            a = str(a)\n        except Exception as exc:\n            raise SympifyError(a, exc)\n        sympy_deprecation_warning(f'\\nThe string fallback in sympify() is deprecated.\\n\\nTo explicitly convert the string form of an object, use\\nsympify(str(obj)). To add define sympify behavior on custom\\nobjects, use sympy.core.sympify.converter or define obj._sympy_\\n(see the sympify() docstring).\\n\\nsympify() performed the string fallback resulting in the following string:\\n\\n{a!r}\\n            ', deprecated_since_version='1.6', active_deprecations_target='deprecated-sympify-string-fallback')\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.sympify.py@@_is_numpy_instance": "def _is_numpy_instance(a):\n    return any((type_.__module__ == 'numpy' for type_ in type(a).__mro__))",
    ".sympy.utilities.iterables.py@@iterable": "def iterable(i, exclude=(str, dict, NotIterable)):\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    ".sympy.polys.polytools.py@@try_non_polynomial_gcd": "def try_non_polynomial_gcd(seq):\n    if not gens and (not args):\n        domain, numbers = construct_domain(seq)\n        if not numbers:\n            return domain.zero\n        elif domain.is_Numerical:\n            result, numbers = (numbers[0], numbers[1:])\n            for number in numbers:\n                result = domain.gcd(result, number)\n                if domain.is_one(result):\n                    break\n            return domain.to_sympy(result)\n    return None",
    ".sympy.polys.constructor.py@@construct_domain": "def construct_domain(obj, **args):\n    opt = build_options(args)\n    if hasattr(obj, '__iter__'):\n        if isinstance(obj, dict):\n            if not obj:\n                monoms, coeffs = ([], [])\n            else:\n                monoms, coeffs = list(zip(*list(obj.items())))\n        else:\n            coeffs = obj\n    else:\n        coeffs = [obj]\n    coeffs = list(map(sympify, coeffs))\n    result = _construct_simple(coeffs, opt)\n    if result is not None:\n        if result is not False:\n            domain, coeffs = result\n        else:\n            domain, coeffs = _construct_expression(coeffs, opt)\n    else:\n        if opt.composite is False:\n            result = None\n        else:\n            result = _construct_composite(coeffs, opt)\n        if result is not None:\n            domain, coeffs = result\n        else:\n            domain, coeffs = _construct_expression(coeffs, opt)\n    if hasattr(obj, '__iter__'):\n        if isinstance(obj, dict):\n            return (domain, dict(list(zip(monoms, coeffs))))\n        else:\n            return (domain, coeffs)\n    else:\n        return (domain, coeffs[0])",
    ".sympy.polys.polyoptions.py@@build_options": "def build_options(gens, args=None):\n    if args is None:\n        gens, args = ((), gens)\n    if len(args) != 1 or 'opt' not in args or gens:\n        return Options(gens, args)\n    else:\n        return args['opt']",
    ".sympy.polys.polyoptions.py@@Options.__init__": "def __init__(self, gens, args, flags=None, strict=False):\n    dict.__init__(self)\n    if gens and args.get('gens', ()):\n        raise OptionError(\"both '*gens' and keyword argument 'gens' supplied\")\n    elif gens:\n        args = dict(args)\n        args['gens'] = gens\n    defaults = args.pop('defaults', {})\n\n    def preprocess_options(args):\n        for option, value in args.items():\n            try:\n                cls = self.__options__[option]\n            except KeyError:\n                raise OptionError(\"'%s' is not a valid option\" % option)\n            if issubclass(cls, Flag):\n                if flags is None or option not in flags:\n                    if strict:\n                        raise OptionError(\"'%s' flag is not allowed in this context\" % option)\n            if value is not None:\n                self[option] = cls.preprocess(value)\n    preprocess_options(args)\n    for key, value in dict(defaults).items():\n        if key in self:\n            del defaults[key]\n        else:\n            for option in self.keys():\n                cls = self.__options__[option]\n                if key in cls.excludes:\n                    del defaults[key]\n                    break\n    preprocess_options(defaults)\n    for option in self.keys():\n        cls = self.__options__[option]\n        for require_option in cls.requires:\n            if self.get(require_option) is None:\n                raise OptionError(\"'%s' option is only allowed together with '%s'\" % (option, require_option))\n        for exclude_option in cls.excludes:\n            if self.get(exclude_option) is not None:\n                raise OptionError(\"'%s' option is not allowed together with '%s'\" % (option, exclude_option))\n    for option in self.__order__:\n        self.__options__[option].postprocess(self)",
    ".sympy.polys.polyoptions.py@@Options.preprocess_options": "def preprocess_options(args):\n    for option, value in args.items():\n        try:\n            cls = self.__options__[option]\n        except KeyError:\n            raise OptionError(\"'%s' is not a valid option\" % option)\n        if issubclass(cls, Flag):\n            if flags is None or option not in flags:\n                if strict:\n                    raise OptionError(\"'%s' flag is not allowed in this context\" % option)\n        if value is not None:\n            self[option] = cls.preprocess(value)",
    ".sympy.polys.polyoptions.py@@Option.postprocess": "def postprocess(cls, options):\n    pass",
    ".sympy.polys.polyoptions.py@@Extension.postprocess": "def postprocess(cls, options):\n    if 'extension' in options and options['extension'] is not True:\n        options['domain'] = sympy.polys.domains.QQ.algebraic_field(*options['extension'])",
    ".sympy.polys.polyoptions.py@@Gaussian.postprocess": "def postprocess(cls, options):\n    if 'gaussian' in options and options['gaussian'] is True:\n        options['domain'] = sympy.polys.domains.QQ_I\n        Extension.postprocess(options)",
    ".sympy.polys.polyoptions.py@@Domain.postprocess": "def postprocess(cls, options):\n    if 'gens' in options and 'domain' in options and options['domain'].is_Composite and set(options['domain'].symbols) & set(options['gens']):\n        raise GeneratorsError('ground domain and generators interfere together')\n    elif ('gens' not in options or not options['gens']) and 'domain' in options and (options['domain'] == sympy.polys.domains.EX):\n        raise GeneratorsError('you have to provide generators because EX domain was requested')",
    ".sympy.polys.polyoptions.py@@Auto.postprocess": "def postprocess(cls, options):\n    if ('domain' in options or 'field' in options) and 'auto' not in options:\n        options['auto'] = False",
    ".sympy.polys.polyoptions.py@@Modulus.postprocess": "def postprocess(cls, options):\n    if 'modulus' in options:\n        modulus = options['modulus']\n        symmetric = options.get('symmetric', True)\n        options['domain'] = sympy.polys.domains.FF(modulus, symmetric)",
    ".sympy.polys.polyoptions.py@@Split.postprocess": "def postprocess(cls, options):\n    if 'split' in options:\n        raise NotImplementedError(\"'split' option is not implemented yet\")",
    ".sympy.polys.constructor.py@@_construct_simple": "def _construct_simple(coeffs, opt):\n    rationals = floats = complexes = algebraics = False\n    float_numbers = []\n    if opt.extension is True:\n        is_algebraic = lambda coeff: coeff.is_number and coeff.is_algebraic\n    else:\n        is_algebraic = lambda coeff: False\n    for coeff in coeffs:\n        if coeff.is_Rational:\n            if not coeff.is_Integer:\n                rationals = True\n        elif coeff.is_Float:\n            if algebraics:\n                return False\n            else:\n                floats = True\n                float_numbers.append(coeff)\n        else:\n            is_complex = pure_complex(coeff)\n            if is_complex:\n                complexes = True\n                x, y = is_complex\n                if x.is_Rational and y.is_Rational:\n                    if not (x.is_Integer and y.is_Integer):\n                        rationals = True\n                    continue\n                else:\n                    floats = True\n                    if x.is_Float:\n                        float_numbers.append(x)\n                    if y.is_Float:\n                        float_numbers.append(y)\n            elif is_algebraic(coeff):\n                if floats:\n                    return False\n                algebraics = True\n            else:\n                return None\n    max_prec = max((c._prec for c in float_numbers)) if float_numbers else 53\n    if algebraics:\n        domain, result = _construct_algebraic(coeffs, opt)\n    else:\n        if floats and complexes:\n            domain = ComplexField(prec=max_prec)\n        elif floats:\n            domain = RealField(prec=max_prec)\n        elif rationals or opt.field:\n            domain = QQ_I if complexes else QQ\n        else:\n            domain = ZZ_I if complexes else ZZ\n        result = [domain.from_sympy(coeff) for coeff in coeffs]\n    return (domain, result)",
    ".sympy.polys.polyoptions.py@@OptionType.getter": "def getter(self):\n    try:\n        return self[cls.option]\n    except KeyError:\n        return cls.default()",
    ".sympy.polys.polyoptions.py@@Option.default": "def default(cls):\n    return None",
    ".sympy.polys.domains.integerring.py@@IntegerRing.from_sympy": "def from_sympy(self, a):\n    if a.is_Integer:\n        return MPZ(a.p)\n    elif a.is_Float and int(a) == a:\n        return MPZ(int(a))\n    else:\n        raise CoercionFailed('expected an integer, got %s' % a)",
    ".sympy.polys.domains.integerring.py@@IntegerRing.gcd": "def gcd(self, a, b):\n    return gcd(a, b)",
    ".sympy.polys.domains.domain.py@@Domain.is_one": "def is_one(self, a):\n    return a == self.one",
    ".sympy.polys.domains.integerring.py@@IntegerRing.to_sympy": "def to_sympy(self, a):\n    return SymPyInteger(int(a))",
    ".sympy.core.decorators.py@@__sympifyit_wrapper": "def __sympifyit_wrapper(a, b):\n    try:\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    ".sympy.core.numbers.py@@Rational.__truediv__": "def __truediv__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            if self.p and other.p == S.Zero:\n                return S.ComplexInfinity\n            else:\n                return Rational(self.p, self.q * other.p, igcd(self.p, other.p))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q, self.q * other.p, igcd(self.p, other.p) * igcd(self.q, other.q))\n        elif isinstance(other, Float):\n            return self * (1 / other)\n        else:\n            return Number.__truediv__(self, other)\n    return Number.__truediv__(self, other)",
    ".sympy.core.numbers.py@@igcd": "def igcd(*args):\n    if len(args) < 2:\n        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))\n    args_temp = [abs(as_int(i)) for i in args]\n    if 1 in args_temp:\n        return 1\n    a = args_temp.pop()\n    if HAS_GMPY:\n        for b in args_temp:\n            a = gmpy.gcd(a, b) if b else a\n        return as_int(a)\n    for b in args_temp:\n        a = math.gcd(a, b)\n    return a",
    ".sympy.utilities.misc.py@@as_int": "def as_int(n, strict=True):\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n != result:\n            raise ValueError('%s is not an integer' % (n,))\n        return result",
    ".sympy.core.numbers.py@@Rational.__new__": "def __new__(cls, p, q=None, gcd=None):\n    if q is None:\n        if isinstance(p, Rational):\n            return p\n        if isinstance(p, SYMPY_INTS):\n            pass\n        else:\n            if isinstance(p, (float, Float)):\n                return Rational(*_as_integer_ratio(p))\n            if not isinstance(p, str):\n                try:\n                    p = sympify(p)\n                except (SympifyError, SyntaxError):\n                    pass\n            else:\n                if p.count('/') > 1:\n                    raise TypeError('invalid input: %s' % p)\n                p = p.replace(' ', '')\n                pq = p.rsplit('/', 1)\n                if len(pq) == 2:\n                    p, q = pq\n                    fp = fractions.Fraction(p)\n                    fq = fractions.Fraction(q)\n                    p = fp / fq\n                try:\n                    p = fractions.Fraction(p)\n                except ValueError:\n                    pass\n                else:\n                    return Rational(p.numerator, p.denominator, 1)\n            if not isinstance(p, Rational):\n                raise TypeError('invalid input: %s' % p)\n        q = 1\n        gcd = 1\n    if not isinstance(p, SYMPY_INTS):\n        p = Rational(p)\n        q *= p.q\n        p = p.p\n    else:\n        p = int(p)\n    if not isinstance(q, SYMPY_INTS):\n        q = Rational(q)\n        p *= q.q\n        q = q.p\n    else:\n        q = int(q)\n    if q == 0:\n        if p == 0:\n            if _errdict['divide']:\n                raise ValueError('Indeterminate 0/0')\n            else:\n                return S.NaN\n        return S.ComplexInfinity\n    if q < 0:\n        q = -q\n        p = -p\n    if not gcd:\n        gcd = igcd(abs(p), q)\n    if gcd > 1:\n        p //= gcd\n        q //= gcd\n    if q == 1:\n        return Integer(p)\n    if p == 1 and q == 2:\n        return S.Half\n    obj = Expr.__new__(cls)\n    obj.p = p\n    obj.q = q\n    return obj",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.geometry.polygon.py@@Polygon.sides": "def sides(self):\n    res = []\n    args = self.vertices\n    for i in range(-len(args), 0):\n        res.append(Segment(args[i], args[i + 1]))\n    return res",
    ".sympy.geometry.line.py@@Segment.__new__": "def __new__(cls, p1, p2, **kwargs):\n    p1, p2 = Point._normalize_dimension(Point(p1), Point(p2))\n    dim = len(p1)\n    if dim == 2:\n        return Segment2D(p1, p2, **kwargs)\n    elif dim == 3:\n        return Segment3D(p1, p2, **kwargs)\n    return LinearEntity.__new__(cls, p1, p2, **kwargs)",
    ".sympy.geometry.point.py@@Point.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n    on_morph = kwargs.get('on_morph', 'ignore')\n    coords = args[0] if len(args) == 1 else args\n    if isinstance(coords, Point):\n        evaluate = False\n        if len(coords) == kwargs.get('dim', len(coords)):\n            return coords\n    if not is_sequence(coords):\n        raise TypeError(filldedent('\\n            Expecting sequence of coordinates, not `{}`'.format(func_name(coords))))\n    if len(coords) == 0 and kwargs.get('dim', None):\n        coords = (S.Zero,) * kwargs.get('dim')\n    coords = Tuple(*coords)\n    dim = kwargs.get('dim', len(coords))\n    if len(coords) < 2:\n        raise ValueError(filldedent('\\n            Point requires 2 or more coordinates or\\n            keyword `dim` > 1.'))\n    if len(coords) != dim:\n        message = 'Dimension of {} needs to be changed from {} to {}.'.format(coords, len(coords), dim)\n        if on_morph == 'ignore':\n            pass\n        elif on_morph == 'error':\n            raise ValueError(message)\n        elif on_morph == 'warn':\n            warnings.warn(message, stacklevel=2)\n        else:\n            raise ValueError(filldedent(\"\\n                    on_morph value should be 'error',\\n                    'warn' or 'ignore'.\"))\n    if any(coords[dim:]):\n        raise ValueError('Nonzero coordinates cannot be removed.')\n    if any((a.is_number and im(a).is_zero is False for a in coords)):\n        raise ValueError('Imaginary coordinates are not permitted.')\n    if not all((isinstance(a, Expr) for a in coords)):\n        raise TypeError('Coordinates must be valid SymPy expressions.')\n    coords = coords[:dim] + (S.Zero,) * (dim - len(coords))\n    if evaluate:\n        coords = coords.xreplace({f: simplify(nsimplify(f, rational=True)) for f in coords.atoms(Float)})\n    if len(coords) == 2:\n        kwargs['_nocheck'] = True\n        return Point2D(*coords, **kwargs)\n    elif len(coords) == 3:\n        kwargs['_nocheck'] = True\n        return Point3D(*coords, **kwargs)\n    return GeometryEntity.__new__(cls, *coords)",
    ".sympy.geometry.point.py@@Point.__len__": "def __len__(self):\n    return len(self.args)",
    ".sympy.geometry.point.py@@Point._normalize_dimension": "def _normalize_dimension(cls, *points, **kwargs):\n    dim = getattr(cls, '_ambient_dimension', None)\n    dim = kwargs.get('dim', dim)\n    if dim is None:\n        dim = max((i.ambient_dimension for i in points))\n    if all((i.ambient_dimension == dim for i in points)):\n        return list(points)\n    kwargs['dim'] = dim\n    kwargs['on_morph'] = kwargs.get('on_morph', 'warn')\n    return [Point(i, **kwargs) for i in points]",
    ".sympy.geometry.point.py@@Point.ambient_dimension": "def ambient_dimension(self):\n    return getattr(self, '_ambient_dimension', len(self))",
    ".sympy.geometry.line.py@@Segment2D.__new__": "def __new__(cls, p1, p2, **kwargs):\n    p1 = Point(p1, dim=2)\n    p2 = Point(p2, dim=2)\n    if p1 == p2:\n        return p1\n    return LinearEntity2D.__new__(cls, p1, p2, **kwargs)",
    ".sympy.geometry.point.py@@Point.__eq__": "def __eq__(self, other):\n    if not isinstance(other, Point) or len(self.args) != len(other.args):\n        return False\n    return self.args == other.args",
    ".sympy.geometry.line.py@@LinearEntity.__new__": "def __new__(cls, p1, p2=None, **kwargs):\n    p1, p2 = Point._normalize_dimension(p1, p2)\n    if p1 == p2:\n        raise ValueError('%s.__new__ requires two unique Points.' % cls.__name__)\n    if len(p1) != len(p2):\n        raise ValueError('%s.__new__ requires two Points of equal dimension.' % cls.__name__)\n    return GeometryEntity.__new__(cls, p1, p2, **kwargs)",
    ".sympy.geometry.entity.py@@GeometryEntity.__new__": "def __new__(cls, *args, **kwargs):\n\n    def is_seq_and_not_point(a):\n        if hasattr(a, 'is_Point') and a.is_Point:\n            return False\n        return is_sequence(a)\n    args = [Tuple(*a) if is_seq_and_not_point(a) else sympify(a) for a in args]\n    return Basic.__new__(cls, *args)",
    ".sympy.geometry.entity.py@@GeometryEntity.is_seq_and_not_point": "def is_seq_and_not_point(a):\n    if hasattr(a, 'is_Point') and a.is_Point:\n        return False\n    return is_sequence(a)",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.integrals.intpoly.py@@point_sort": "def point_sort(poly, normal=None, clockwise=True):\n    pts = poly.vertices if isinstance(poly, Polygon) else poly\n    n = len(pts)\n    if n < 2:\n        return list(pts)\n    order = S.One if clockwise else S.NegativeOne\n    dim = len(pts[0])\n    if dim == 2:\n        center = Point(sum(map(lambda vertex: vertex.x, pts)) / n, sum(map(lambda vertex: vertex.y, pts)) / n)\n    else:\n        center = Point(sum(map(lambda vertex: vertex.x, pts)) / n, sum(map(lambda vertex: vertex.y, pts)) / n, sum(map(lambda vertex: vertex.z, pts)) / n)\n\n    def compare(a, b):\n        if a.x - center.x >= S.Zero and b.x - center.x < S.Zero:\n            return -order\n        elif a.x - center.x < 0 and b.x - center.x >= 0:\n            return order\n        elif a.x - center.x == 0 and b.x - center.x == 0:\n            if a.y - center.y >= 0 or b.y - center.y >= 0:\n                return -order if a.y > b.y else order\n            return -order if b.y > a.y else order\n        det = (a.x - center.x) * (b.y - center.y) - (b.x - center.x) * (a.y - center.y)\n        if det < 0:\n            return -order\n        elif det > 0:\n            return order\n        first = (a.x - center.x) * (a.x - center.x) + (a.y - center.y) * (a.y - center.y)\n        second = (b.x - center.x) * (b.x - center.x) + (b.y - center.y) * (b.y - center.y)\n        return -order if first > second else order\n\n    def compare3d(a, b):\n        det = cross_product(center, a, b)\n        dot_product = sum([det[i] * normal[i] for i in range(0, 3)])\n        if dot_product < 0:\n            return -order\n        elif dot_product > 0:\n            return order\n    return sorted(pts, key=cmp_to_key(compare if dim == 2 else compare3d))",
    ".sympy.geometry.point.py@@Point2D.x": "def x(self):\n    return self.args[0]",
    ".sympy.core.numbers.py@@Integer.__radd__": "def __radd__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other + self.p)\n        elif isinstance(other, Rational):\n            return Rational(other.p + self.p * other.q, other.q, 1)\n        return Rational.__radd__(self, other)\n    return Rational.__radd__(self, other)",
    ".sympy.core.numbers.py@@Integer.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    ".sympy.geometry.point.py@@Point2D.y": "def y(self):\n    return self.args[1]",
    ".sympy.utilities.iterables.py@@is_sequence": "def is_sequence(i, include=None):\n    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))",
    ".sympy.core.containers.py@@Tuple.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    ".sympy.core.containers.py@@Tuple.__len__": "def __len__(self):\n    return len(self.args)",
    ".sympy.core.containers.py@@Tuple.__getitem__": "def __getitem__(self, i):\n    if isinstance(i, slice):\n        indices = i.indices(len(self))\n        return Tuple(*(self.args[j] for j in range(*indices)))\n    return self.args[i]",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.function.py@@Function.__new__": "def __new__(cls, *args, **options):\n    if cls is Function:\n        return UndefinedFunction(*args, **options)\n    n = len(args)\n    if n not in cls.nargs:\n        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'\n        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})\n    evaluate = options.get('evaluate', global_parameters.evaluate)\n    result = super().__new__(cls, *args, **options)\n    if evaluate and isinstance(result, cls) and result.args:\n        pr2 = min((cls._should_evalf(a) for a in result.args))\n        if pr2 > 0:\n            pr = max((cls._should_evalf(a) for a in result.args))\n            result = result.evalf(prec_to_dps(pr))\n    return result",
    ".sympy.core.function.py@@FunctionClass.nargs": "def nargs(self):\n    from sympy.sets.sets import FiniteSet\n    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0",
    ".sympy.sets.sets.py@@FiniteSet.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n    if evaluate:\n        args = list(map(sympify, args))\n        if len(args) == 0:\n            return S.EmptySet\n    else:\n        args = list(map(sympify, args))\n    dargs = {}\n    for i in reversed(list(ordered(args))):\n        if i.is_Symbol:\n            dargs[i] = i\n        else:\n            try:\n                dargs[i.as_dummy()] = i\n            except TypeError:\n                dargs[i] = i\n    _args_set = set(dargs.values())\n    args = list(ordered(_args_set, Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._args_set = _args_set\n    return obj",
    ".sympy.core.sorting.py@@ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    d = defaultdict(list)\n    if keys:\n        if not isinstance(keys, (list, tuple)):\n            keys = [keys]\n        keys = list(keys)\n        f = keys.pop(0)\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n    for k in sorted(d.keys()):\n        if len(d[k]) > 1:\n            if keys:\n                d[k] = ordered(d[k], keys, default, warn)\n            elif default:\n                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)\n            elif warn:\n                u = list(uniq(d[k]))\n                if len(u) > 1:\n                    raise ValueError('not enough keys to break ties: %s' % u)\n        yield from d[k]\n        d.pop(k)",
    ".sympy.core.basic.py@@Basic.as_dummy": "def as_dummy(self):\n    from .symbol import Dummy, Symbol\n\n    def can(x):\n        free = x.free_symbols\n        bound = set(x.bound_symbols)\n        d = {i: Dummy() for i in bound & free}\n        x = x.subs(d)\n        x = x.xreplace(x.canonical_variables)\n        return x.xreplace({v: k for k, v in d.items()})\n    if not self.has(Symbol):\n        return self\n    return self.replace(lambda x: hasattr(x, 'bound_symbols'), can, simultaneous=False)",
    ".sympy.core.basic.py@@Basic.has": "def has(self, *patterns):\n    return self._has(iterargs, *patterns)",
    ".sympy.core.basic.py@@Basic._has": "def _has(self, iterargs, *patterns):\n    type_set = set()\n    p_set = set()\n    for p in patterns:\n        if isinstance(p, BasicMeta):\n            type_set.add(p)\n            continue\n        if not isinstance(p, Basic):\n            try:\n                p = _sympify(p)\n            except SympifyError:\n                continue\n        p_set.add(p)\n    types = tuple(type_set)\n    for i in iterargs(self):\n        if i in p_set:\n            return True\n        if isinstance(i, types):\n            return True\n    for i in p_set - type_set:\n        if not hasattr(i, '_has_matcher'):\n            continue\n        match = i._has_matcher()\n        if any((match(arg) for arg in iterargs(self))):\n            return True\n    return False",
    ".sympy.core.traversal.py@@iterargs": "def iterargs(expr):\n    args = [expr]\n    for i in args:\n        yield i\n        try:\n            args.extend(i.args)\n        except TypeError:\n            pass",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.sets.sets.py@@Set._infimum_key": "def _infimum_key(expr):\n    try:\n        infimum = expr.inf\n        assert infimum.is_comparable\n        infimum = infimum.evalf()\n    except (NotImplementedError, AttributeError, AssertionError, ValueError):\n        infimum = S.Infinity\n    return infimum",
    ".sympy.core.numbers.py@@Infinity.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self) -> int:\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.sets.sets.py@@Set.__contains__": "def __contains__(self, other):\n    other = _sympify(other)\n    c = self._contains(other)\n    b = tfn[c]\n    if b is None:\n        raise TypeError('did not evaluate to a bool: %r' % c)\n    return b",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.sets.sets.py@@FiniteSet._contains": "def _contains(self, other):\n    if other in self._args_set:\n        return True\n    else:\n        return fuzzy_or((fuzzy_bool(Eq(e, other, evaluate=True)) for e in self.args))",
    ".sympy.logic.boolalg.py@@BooleanTrue.__bool__": "def __bool__(self):\n    return True",
    ".sympy.core.function.py@@Application.__new__": "def __new__(cls, *args, **options):\n    from sympy.sets.fancysets import Naturals0\n    from sympy.sets.sets import FiniteSet\n    args = list(map(sympify, args))\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    options.pop('nargs', None)\n    if options:\n        raise ValueError('Unknown options: %s' % options)\n    if evaluate:\n        evaluated = cls.eval(*args)\n        if evaluated is not None:\n            return evaluated\n    obj = super().__new__(cls, *args, **options)\n    sentinel = object()\n    objnargs = getattr(obj, 'nargs', sentinel)\n    if objnargs is not sentinel:\n        if is_sequence(objnargs):\n            nargs = tuple(ordered(set(objnargs)))\n        elif objnargs is not None:\n            nargs = (as_int(objnargs),)\n        else:\n            nargs = None\n    else:\n        nargs = obj._nargs\n    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()\n    return obj",
    ".sympy.functions.elementary.complexes.py@@im.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_extended_real:\n        return S.Zero\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_extended_real:\n        return -S.ImaginaryUnit * arg\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[1]\n    elif arg.is_Function and isinstance(arg, conjugate):\n        return -im(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_extended_real:\n                    reverted.append(coeff)\n                else:\n                    excluded.append(coeff)\n            elif term.has(S.ImaginaryUnit) or not term.is_extended_real:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[1])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) + re(b) + c",
    ".sympy.core.containers.py@@Tuple.__add__": "def __add__(self, other):\n    if isinstance(other, Tuple):\n        return Tuple(*self.args + other.args)\n    elif isinstance(other, tuple):\n        return Tuple(*self.args + other)\n    else:\n        return NotImplemented",
    ".sympy.core.basic.py@@Basic.atoms": "def atoms(self, *types):\n    if types:\n        types = tuple([t if isinstance(t, type) else type(t) for t in types])\n    nodes = _preorder_traversal(self)\n    if types:\n        result = {node for node in nodes if isinstance(node, types)}\n    else:\n        result = {node for node in nodes if not node.args}\n    return result",
    ".sympy.core.traversal.py@@preorder_traversal.__init__": "def __init__(self, node, keys=None):\n    self._skip_flag = False\n    self._pt = self._preorder_traversal(node, keys)",
    ".sympy.core.traversal.py@@preorder_traversal.__iter__": "def __iter__(self):\n    return self",
    ".sympy.core.traversal.py@@preorder_traversal.__next__": "def __next__(self):\n    return next(self._pt)",
    ".sympy.core.traversal.py@@preorder_traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    ".sympy.core.basic.py@@Basic.xreplace": "def xreplace(self, rule):\n    value, _ = self._xreplace(rule)\n    return value",
    ".sympy.core.basic.py@@Basic._xreplace": "def _xreplace(self, rule):\n    if self in rule:\n        return (rule[self], True)\n    elif rule:\n        args = []\n        changed = False\n        for a in self.args:\n            _xreplace = getattr(a, '_xreplace', None)\n            if _xreplace is not None:\n                a_xr = _xreplace(rule)\n                args.append(a_xr[0])\n                changed |= a_xr[1]\n            else:\n                args.append(a)\n        args = tuple(args)\n        if changed:\n            return (self.func(*args), True)\n    return (self, False)",
    ".sympy.core.containers.py@@Tuple.__hash__": "def __hash__(self):\n    return hash(self.args)",
    ".sympy.core.numbers.py@@Rational.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.numbers.py@@Rational._hashable_content": "def _hashable_content(self):\n    return (self.p, self.q)",
    ".sympy.geometry.point.py@@Point2D.__new__": "def __new__(cls, *args, _nocheck=False, **kwargs):\n    if not _nocheck:\n        kwargs['dim'] = 2\n        args = Point(*args, **kwargs)\n    return GeometryEntity.__new__(cls, *args)",
    ".sympy.integrals.intpoly.py@@compare": "def compare(a, b):\n    if a.x - center.x >= S.Zero and b.x - center.x < S.Zero:\n        return -order\n    elif a.x - center.x < 0 and b.x - center.x >= 0:\n        return order\n    elif a.x - center.x == 0 and b.x - center.x == 0:\n        if a.y - center.y >= 0 or b.y - center.y >= 0:\n            return -order if a.y > b.y else order\n        return -order if b.y > a.y else order\n    det = (a.x - center.x) * (b.y - center.y) - (b.x - center.x) * (a.y - center.y)\n    if det < 0:\n        return -order\n    elif det > 0:\n        return order\n    first = (a.x - center.x) * (a.x - center.x) + (a.y - center.y) * (a.y - center.y)\n    second = (b.x - center.x) * (b.x - center.x) + (b.y - center.y) * (b.y - center.y)\n    return -order if first > second else order",
    ".sympy.core.numbers.py@@Integer.__le__": "def __le__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p <= other.p)\n    return Rational.__le__(self, other)",
    ".sympy.core.numbers.py@@Rational.__le__": "def __le__(self, other):\n    rv = self._Rrel(other, '__ge__')\n    if rv is None:\n        rv = (self, other)\n    elif not isinstance(rv, tuple):\n        return rv\n    return Expr.__le__(*rv)",
    ".sympy.core.numbers.py@@Rational._Rrel": "def _Rrel(self, other, attr):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Number:\n        op = None\n        s, o = (self, other)\n        if other.is_NumberSymbol:\n            op = getattr(o, attr)\n        elif other.is_Float:\n            op = getattr(o, attr)\n        elif other.is_Rational:\n            s, o = (Integer(s.p * o.q), Integer(s.q * o.p))\n            op = getattr(o, attr)\n        if op:\n            return op(s)\n        if o.is_number and o.is_extended_real:\n            return (Integer(s.p), s.q * o)",
    ".sympy.core.numbers.py@@Integer.__ge__": "def __ge__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p >= other.p)\n    return Rational.__ge__(self, other)",
    ".sympy.core.numbers.py@@Integer.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    ".sympy.core.numbers.py@@Rational.__gt__": "def __gt__(self, other):\n    rv = self._Rrel(other, '__lt__')\n    if rv is None:\n        rv = (self, other)\n    elif not isinstance(rv, tuple):\n        return rv\n    return Expr.__gt__(*rv)",
    ".sympy.core.numbers.py@@Integer.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    ".sympy.core.numbers.py@@One.__neg__": "def __neg__():\n    return S.NegativeOne",
    ".sympy.logic.boolalg.py@@BooleanFalse.__bool__": "def __bool__(self):\n    return False",
    ".sympy.core.numbers.py@@Rational.__lt__": "def __lt__(self, other):\n    rv = self._Rrel(other, '__gt__')\n    if rv is None:\n        rv = (self, other)\n    elif not isinstance(rv, tuple):\n        return rv\n    return Expr.__lt__(*rv)",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if not isinstance(other, Number):\n        return False\n    if not self:\n        return not other\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Rational:\n        return self.p == other.p and self.q == other.q\n    if other.is_Float:\n        if self.q & self.q - 1:\n            return False\n        s, m, t = other._mpf_[:3]\n        if s:\n            m = -m\n        if not t:\n            if not self.is_Integer or self.is_even:\n                return False\n            return m == self.p\n        from .power import integer_log\n        if t > 0:\n            if not self.is_Integer:\n                return False\n            return self.p and (not self.p % m) and (integer_log(self.p // m, 2) == (t, True))\n        if self.is_Integer:\n            return False\n        return m == self.p and integer_log(self.q, 2) == (-t, True)\n    return False",
    ".sympy.core.numbers.py@@Rational.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))\n        elif isinstance(other, Float):\n            return other * self\n        else:\n            return Number.__mul__(self, other)\n    return Number.__mul__(self, other)",
    ".sympy.core.numbers.py@@Rational.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(self.p - self.q * other.p, self.q, 1)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - self.q * other.p, self.q * other.q)\n        elif isinstance(other, Float):\n            return -other + self\n        else:\n            return Number.__sub__(self, other)\n    return Number.__sub__(self, other)",
    ".sympy.geometry.polygon.py@@Polygon.__new__": "def __new__(cls, *args, n=0, **kwargs):\n    if n:\n        args = list(args)\n        if len(args) == 2:\n            args.append(n)\n        elif len(args) == 3:\n            args.insert(2, n)\n        return RegularPolygon(*args, **kwargs)\n    vertices = [Point(a, dim=2, **kwargs) for a in args]\n    nodup = []\n    for p in vertices:\n        if nodup and p == nodup[-1]:\n            continue\n        nodup.append(p)\n    if len(nodup) > 1 and nodup[-1] == nodup[0]:\n        nodup.pop()\n    i = -3\n    while i < len(nodup) - 3 and len(nodup) > 2:\n        a, b, c = (nodup[i], nodup[i + 1], nodup[i + 2])\n        if Point.is_collinear(a, b, c):\n            nodup.pop(i + 1)\n            if a == c:\n                nodup.pop(i)\n        else:\n            i += 1\n    vertices = list(nodup)\n    if len(vertices) > 3:\n        return GeometryEntity.__new__(cls, *vertices, **kwargs)\n    elif len(vertices) == 3:\n        return Triangle(*vertices, **kwargs)\n    elif len(vertices) == 2:\n        return Segment(*vertices, **kwargs)\n    else:\n        return Point(*vertices, **kwargs)",
    ".sympy.geometry.point.py@@Point.is_collinear": "def is_collinear(self, *args):\n    points = (self,) + args\n    points = Point._normalize_dimension(*[Point(i) for i in points])\n    points = list(uniq(points))\n    return Point.affine_rank(*points) <= 1",
    ".sympy.utilities.iterables.py@@uniq": "def uniq(seq, result=None):\n    try:\n        n = len(seq)\n    except TypeError:\n        n = None\n\n    def check():\n        if n is not None and len(seq) != n:\n            raise RuntimeError('sequence changed size during iteration')\n    try:\n        seen = set()\n        result = result or []\n        for i, s in enumerate(seq):\n            if not (s in seen or seen.add(s)):\n                yield s\n                check()\n    except TypeError:\n        if s not in result:\n            yield s\n            check()\n            result.append(s)\n        if hasattr(seq, '__getitem__'):\n            yield from uniq(seq[i + 1:], result)\n        else:\n            yield from uniq(seq, result)",
    ".sympy.geometry.point.py@@Point.__hash__": "def __hash__(self):\n    return hash(self.args)",
    ".sympy.utilities.iterables.py@@check": "def check():\n    if n is not None and len(seq) != n:\n        raise RuntimeError('sequence changed size during iteration')",
    ".sympy.geometry.point.py@@Point.affine_rank": "def affine_rank(*args):\n    if len(args) == 0:\n        return -1\n    points = Point._normalize_dimension(*[Point(i) for i in args])\n    origin = points[0]\n    points = [i - origin for i in points[1:]]\n    m = Matrix([i.args for i in points])\n    return m.rank(iszerofunc=lambda x: abs(x.n(2)) < 1e-12 if x.is_number else x.is_zero)",
    ".sympy.geometry.point.py@@Point.__sub__": "def __sub__(self, other):\n    return self + [-x for x in other]",
    ".sympy.geometry.point.py@@Point.__iter__": "def __iter__(self):\n    return self.args.__iter__()",
    ".sympy.geometry.point.py@@Point.__add__": "def __add__(self, other):\n    try:\n        s, o = Point._normalize_dimension(self, Point(other, evaluate=False))\n    except TypeError:\n        raise GeometryError(\"Don't know how to add {} and a Point object\".format(other))\n    coords = [simplify(a + b) for a, b in zip(s, o)]\n    return Point(coords, evaluate=False)",
    ".sympy.simplify.simplify.py@@simplify": "def simplify(expr, ratio=1.7, measure=count_ops, rational=False, inverse=False, doit=True, **kwargs):\n\n    def shorter(*choices):\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n\n    def done(e):\n        rv = e.doit() if doit else e\n        return shorter(rv, collect_abs(rv))\n    expr = sympify(expr, rational=rational)\n    kwargs = dict(ratio=kwargs.get('ratio', ratio), measure=kwargs.get('measure', measure), rational=kwargs.get('rational', rational), inverse=kwargs.get('inverse', inverse), doit=kwargs.get('doit', doit))\n    if isinstance(expr, Expr) and expr.is_zero:\n        return S.Zero if not expr.is_Number else expr\n    _eval_simplify = getattr(expr, '_eval_simplify', None)\n    if _eval_simplify is not None:\n        return _eval_simplify(**kwargs)\n    original_expr = expr = collect_abs(signsimp(expr))\n    if not isinstance(expr, Basic) or not expr.args:\n        return expr\n    if inverse and expr.has(Function):\n        expr = inversecombine(expr)\n        if not expr.args:\n            return expr\n    handled = (Add, Mul, Pow, ExpBase)\n    expr = expr.replace(lambda x: isinstance(x, Expr) and x.args and (not isinstance(x, handled)), lambda x: x.func(*[simplify(i, **kwargs) for i in x.args]), simultaneous=False)\n    if not isinstance(expr, handled):\n        return done(expr)\n    if not expr.is_commutative:\n        expr = nc_simplify(expr)\n    floats = False\n    if rational is not False and expr.has(Float):\n        floats = True\n        expr = nsimplify(expr, rational=True)\n    expr = _bottom_up(expr, lambda w: getattr(w, 'normal', lambda: w)())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):\n        return expr\n    expr = factor_terms(expr, sign=False)\n    if expr.has(sign):\n        expr = expr.rewrite(Abs)\n    if expr.has(Piecewise):\n        expr = piecewise_fold(expr)\n        expr = done(expr)\n        if expr.has(Piecewise):\n            expr = piecewise_fold(expr)\n            if expr.has(KroneckerDelta):\n                expr = kroneckersimp(expr)\n            if expr.has(Piecewise):\n                expr = piecewise_simplify(expr, deep=True, doit=False)\n                if expr.has(Piecewise):\n                    expr = shorter(expr, factor_terms(expr))\n                    return expr\n    expr = hyperexpand(expr)\n    if expr.has(KroneckerDelta):\n        expr = kroneckersimp(expr)\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n    if expr.has(TrigonometricFunction, HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n    if expr.has(CombinatorialFunction, gamma):\n        expr = combsimp(expr)\n    if expr.has(Sum):\n        expr = sum_simplify(expr, **kwargs)\n    if expr.has(Integral):\n        expr = expr.xreplace({i: factor_terms(i) for i in expr.atoms(Integral)})\n    if expr.has(Product):\n        expr = product_simplify(expr)\n    from sympy.physics.units import Quantity\n    if expr.has(Quantity):\n        from sympy.physics.units.util import quantity_simplify\n        expr = quantity_simplify(expr)\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, cancel(short))\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase, exp):\n        short = exptrigsimp(short)\n    hollow_mul = Transform(lambda x: Mul(*x.args), lambda x: x.is_Mul and len(x.args) == 2 and x.args[0].is_Number and x.args[1].is_Add and x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1 / denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer * n).expand() / d\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n / -d)\n    if measure(expr) > ratio * measure(original_expr):\n        expr = original_expr\n    if floats and rational is None:\n        expr = nfloat(expr, exponent=False)\n    return done(expr)",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.basic.py@@Atom._eval_simplify": "def _eval_simplify(self, **kwargs):\n    return self",
    ".sympy.matrices.repmatrix.py@@MutableRepMatrix.__new__": "def __new__(cls, *args, **kwargs):\n    return cls._new(*args, **kwargs)",
    ".sympy.matrices.repmatrix.py@@MutableRepMatrix._new": "def _new(cls, *args, copy=True, **kwargs):\n    if copy is False:\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list)\n    rep = cls._flat_list_to_DomainMatrix(rows, cols, flat_list)\n    return cls._fromrep(rep)",
    ".sympy.matrices.matrices.py@@MatrixBase._handle_creation_inputs": "def _handle_creation_inputs(cls, *args, **kwargs):\n    from sympy.matrices import SparseMatrix\n    from sympy.matrices.expressions.matexpr import MatrixSymbol\n    from sympy.matrices.expressions.blockmatrix import BlockMatrix\n    flat_list = None\n    if len(args) == 1:\n        if isinstance(args[0], SparseMatrix):\n            return (args[0].rows, args[0].cols, flatten(args[0].tolist()))\n        elif isinstance(args[0], MatrixBase):\n            return (args[0].rows, args[0].cols, args[0].flat())\n        elif isinstance(args[0], Basic) and args[0].is_Matrix:\n            return (args[0].rows, args[0].cols, args[0].as_explicit().flat())\n        elif isinstance(args[0], mp.matrix):\n            M = args[0]\n            flat_list = [cls._sympify(x) for x in M]\n            return (M.rows, M.cols, flat_list)\n        elif hasattr(args[0], '__array__'):\n            return cls._handle_ndarray(args[0])\n        elif is_sequence(args[0]) and (not isinstance(args[0], DeferredVector)):\n            dat = list(args[0])\n            ismat = lambda i: isinstance(i, MatrixBase) and (evaluate or isinstance(i, BlockMatrix) or isinstance(i, MatrixSymbol))\n            raw = lambda i: is_sequence(i) and (not ismat(i))\n            evaluate = kwargs.get('evaluate', True)\n            if evaluate:\n\n                def make_explicit(x):\n                    if isinstance(x, BlockMatrix):\n                        return x.as_explicit()\n                    elif isinstance(x, MatrixSymbol) and all((_.is_Integer for _ in x.shape)):\n                        return x.as_explicit()\n                    else:\n                        return x\n\n                def make_explicit_row(row):\n                    if isinstance(row, (list, tuple)):\n                        return [make_explicit(x) for x in row]\n                    else:\n                        return make_explicit(row)\n                if isinstance(dat, (list, tuple)):\n                    dat = [make_explicit_row(row) for row in dat]\n            if dat in ([], [[]]):\n                rows = cols = 0\n                flat_list = []\n            elif not any((raw(i) or ismat(i) for i in dat)):\n                flat_list = [cls._sympify(i) for i in dat]\n                rows = len(flat_list)\n                cols = 1 if rows else 0\n            elif evaluate and all((ismat(i) for i in dat)):\n                ncol = {i.cols for i in dat if any(i.shape)}\n                if ncol:\n                    if len(ncol) != 1:\n                        raise ValueError('mismatched dimensions')\n                    flat_list = [_ for i in dat for r in i.tolist() for _ in r]\n                    cols = ncol.pop()\n                    rows = len(flat_list) // cols\n                else:\n                    rows = cols = 0\n                    flat_list = []\n            elif evaluate and any((ismat(i) for i in dat)):\n                ncol = set()\n                flat_list = []\n                for i in dat:\n                    if ismat(i):\n                        flat_list.extend([k for j in i.tolist() for k in j])\n                        if any(i.shape):\n                            ncol.add(i.cols)\n                    elif raw(i):\n                        if i:\n                            ncol.add(len(i))\n                            flat_list.extend([cls._sympify(ij) for ij in i])\n                    else:\n                        ncol.add(1)\n                        flat_list.append(i)\n                    if len(ncol) > 1:\n                        raise ValueError('mismatched dimensions')\n                cols = ncol.pop()\n                rows = len(flat_list) // cols\n            else:\n                flat_list = []\n                ncol = set()\n                rows = cols = 0\n                for row in dat:\n                    if not is_sequence(row) and (not getattr(row, 'is_Matrix', False)):\n                        raise ValueError('expecting list of lists')\n                    if hasattr(row, '__array__'):\n                        if 0 in row.shape:\n                            continue\n                    elif not row:\n                        continue\n                    if evaluate and all((ismat(i) for i in row)):\n                        r, c, flatT = cls._handle_creation_inputs([i.T for i in row])\n                        T = reshape(flatT, [c])\n                        flat = [T[i][j] for j in range(c) for i in range(r)]\n                        r, c = (c, r)\n                    else:\n                        r = 1\n                        if getattr(row, 'is_Matrix', False):\n                            c = 1\n                            flat = [row]\n                        else:\n                            c = len(row)\n                            flat = [cls._sympify(i) for i in row]\n                    ncol.add(c)\n                    if len(ncol) > 1:\n                        raise ValueError('mismatched dimensions')\n                    flat_list.extend(flat)\n                    rows += r\n                cols = ncol.pop() if ncol else 0\n    elif len(args) == 3:\n        rows = as_int(args[0])\n        cols = as_int(args[1])\n        if rows < 0 or cols < 0:\n            raise ValueError('Cannot create a {} x {} matrix. Both dimensions must be positive'.format(rows, cols))\n        if len(args) == 3 and isinstance(args[2], Callable):\n            op = args[2]\n            flat_list = []\n            for i in range(rows):\n                flat_list.extend([cls._sympify(op(cls._sympify(i), cls._sympify(j))) for j in range(cols)])\n        elif len(args) == 3 and is_sequence(args[2]):\n            flat_list = args[2]\n            if len(flat_list) != rows * cols:\n                raise ValueError('List length should be equal to rows*columns')\n            flat_list = [cls._sympify(i) for i in flat_list]\n    elif len(args) == 0:\n        rows = cols = 0\n        flat_list = []\n    if flat_list is None:\n        raise TypeError(filldedent('\\n            Data type not understood; expecting list of lists\\n            or lists of values.'))\n    return (rows, cols, flat_list)",
    ".sympy.matrices.matrices.py@@MatrixBase.make_explicit_row": "def make_explicit_row(row):\n    if isinstance(row, (list, tuple)):\n        return [make_explicit(x) for x in row]\n    else:\n        return make_explicit(row)",
    ".sympy.matrices.matrices.py@@MatrixBase.make_explicit": "def make_explicit(x):\n    if isinstance(x, BlockMatrix):\n        return x.as_explicit()\n    elif isinstance(x, MatrixSymbol) and all((_.is_Integer for _ in x.shape)):\n        return x.as_explicit()\n    else:\n        return x",
    ".sympy.matrices.repmatrix.py@@RepMatrix._flat_list_to_DomainMatrix": "def _flat_list_to_DomainMatrix(cls, rows, cols, flat_list):\n    elements_dod = defaultdict(dict)\n    for n, element in enumerate(flat_list):\n        if element != 0:\n            i, j = divmod(n, cols)\n            elements_dod[i][j] = element\n    types = set(map(type, flat_list))\n    rep = cls._dod_to_DomainMatrix(rows, cols, elements_dod, types)\n    return rep",
    ".sympy.core.numbers.py@@Integer.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.matrices.repmatrix.py@@RepMatrix._dod_to_DomainMatrix": "def _dod_to_DomainMatrix(cls, rows, cols, dod, types):\n    if not all((issubclass(typ, Expr) for typ in types)):\n        sympy_deprecation_warning('\\n            non-Expr objects in a Matrix is deprecated. Matrix represents\\n            a mathematical matrix. To represent a container of non-numeric\\n            entities, Use a list of lists, TableForm, NumPy array, or some\\n            other data structure instead.\\n            ', deprecated_since_version='1.9', active_deprecations_target='deprecated-non-expr-in-matrix', stacklevel=6)\n    rep = DomainMatrix(dod, (rows, cols), EXRAW)\n    if all((issubclass(typ, Rational) for typ in types)):\n        if all((issubclass(typ, Integer) for typ in types)):\n            rep = rep.convert_to(ZZ)\n        else:\n            rep = rep.convert_to(QQ)\n    return rep",
    ".sympy.polys.matrices.domainmatrix.py@@DomainMatrix.__new__": "def __new__(cls, rows, shape, domain, *, fmt=None):\n    if isinstance(rows, (DDM, SDM)):\n        raise TypeError('Use from_rep to initialise from SDM/DDM')\n    elif isinstance(rows, list):\n        rep = DDM(rows, shape, domain)\n    elif isinstance(rows, dict):\n        rep = SDM(rows, shape, domain)\n    else:\n        msg = 'Input should be list-of-lists or dict-of-dicts'\n        raise TypeError(msg)\n    if fmt is not None:\n        if fmt == 'sparse':\n            rep = rep.to_sdm()\n        elif fmt == 'dense':\n            rep = rep.to_ddm()\n        else:\n            raise ValueError(\"fmt should be 'sparse' or 'dense'\")\n    return cls.from_rep(rep)",
    ".sympy.polys.matrices.sdm.py@@SDM.__init__": "def __init__(self, elemsdict, shape, domain):\n    super().__init__(elemsdict)\n    self.shape = self.rows, self.cols = m, n = shape\n    self.domain = domain\n    if not all((0 <= r < m for r in self)):\n        raise DMBadInputError('Row out of range')\n    if not all((0 <= c < n for row in self.values() for c in row)):\n        raise DMBadInputError('Column out of range')",
    ".sympy.polys.matrices.domainmatrix.py@@DomainMatrix.from_rep": "def from_rep(cls, rep):\n    if not isinstance(rep, (DDM, SDM)):\n        raise TypeError('rep should be of type DDM or SDM')\n    self = super().__new__(cls)\n    self.rep = rep\n    self.shape = rep.shape\n    self.domain = rep.domain\n    return self",
    ".sympy.polys.matrices.domainmatrix.py@@DomainMatrix.convert_to": "def convert_to(self, K):\n    if K is None:\n        return self.copy()\n    return self.from_rep(self.rep.convert_to(K))",
    ".sympy.polys.matrices.sdm.py@@SDM.convert_to": "def convert_to(A, K):\n    Kold = A.domain\n    if K == Kold:\n        return A.copy()\n    Ak = unop_dict(A, lambda e: K.convert_from(e, Kold))\n    return A.new(Ak, A.shape, K)",
    ".sympy.polys.domains.domain.py@@Domain.__eq__": "def __eq__(self, other):\n    return isinstance(other, Domain) and self.dtype == other.dtype",
    ".sympy.polys.matrices.sdm.py@@unop_dict": "def unop_dict(A, f):\n    B = {}\n    for i, Ai in A.items():\n        Bi = {}\n        for j, Aij in Ai.items():\n            Bij = f(Aij)\n            if Bij:\n                Bi[j] = Bij\n        if Bi:\n            B[i] = Bi\n    return B",
    ".sympy.polys.domains.domain.py@@Domain.convert_from": "def convert_from(self, element, base):\n    if base.alias is not None:\n        method = 'from_' + base.alias\n    else:\n        method = 'from_' + base.__class__.__name__\n    _convert = getattr(self, method)\n    if _convert is not None:\n        result = _convert(element, base)\n        if result is not None:\n            return result\n    raise CoercionFailed('Cannot convert %s of type %s from %s to %s' % (element, type(element), base, self))",
    ".sympy.polys.domains.domain.py@@Domain.from_ExpressionRawDomain": "def from_ExpressionRawDomain(K1, a, K0):\n    return K1.from_sympy(a)",
    ".sympy.polys.matrices.sdm.py@@SDM.new": "def new(cls, sdm, shape, domain):\n    return cls(sdm, shape, domain)",
    ".sympy.matrices.repmatrix.py@@MutableRepMatrix._fromrep": "def _fromrep(cls, rep):\n    obj = super().__new__(cls)\n    obj.rows, obj.cols = rep.shape\n    obj._rep = rep\n    return obj",
    ".sympy.matrices.matrices.py@@MatrixReductions.rank": "def rank(self, iszerofunc=_iszero, simplify=False):\n    return _rank(self, iszerofunc=iszerofunc, simplify=simplify)",
    ".sympy.matrices.reductions.py@@_rank": "def _rank(M, iszerofunc=_iszero, simplify=False):\n\n    def _permute_complexity_right(M, iszerofunc):\n\n        def complexity(i):\n            return sum((1 if iszerofunc(e) is None else 0 for e in M[:, i]))\n        complex = [(complexity(i), i) for i in range(M.cols)]\n        perm = [j for i, j in sorted(complex)]\n        return (M.permute(perm, orientation='cols'), perm)\n    simpfunc = simplify if isinstance(simplify, FunctionType) else _simplify\n    if M.rows <= 0 or M.cols <= 0:\n        return 0\n    if M.rows <= 1 or M.cols <= 1:\n        zeros = [iszerofunc(x) for x in M]\n        if False in zeros:\n            return 1\n    if M.rows == 2 and M.cols == 2:\n        zeros = [iszerofunc(x) for x in M]\n        if False not in zeros and None not in zeros:\n            return 0\n        d = M.det()\n        if iszerofunc(d) and False in zeros:\n            return 1\n        if iszerofunc(d) is False:\n            return 2\n    mat, _ = _permute_complexity_right(M, iszerofunc=iszerofunc)\n    _, pivots, _ = _row_reduce(mat, iszerofunc, simpfunc, normalize_last=True, normalize=False, zero_above=False)\n    return len(pivots)",
    ".sympy.matrices.repmatrix.py@@RepMatrix.__getitem__": "def __getitem__(self, key):\n    return _getitem_RepMatrix(self, key)",
    ".sympy.matrices.repmatrix.py@@_getitem_RepMatrix": "def _getitem_RepMatrix(self, key):\n    if isinstance(key, tuple):\n        i, j = key\n        try:\n            return self._rep.getitem_sympy(index_(i), index_(j))\n        except (TypeError, IndexError):\n            if isinstance(i, Expr) and (not i.is_number) or (isinstance(j, Expr) and (not j.is_number)):\n                if (j < 0) is True or (j >= self.shape[1]) is True or (i < 0) is True or ((i >= self.shape[0]) is True):\n                    raise ValueError('index out of boundary')\n                from sympy.matrices.expressions.matexpr import MatrixElement\n                return MatrixElement(self, i, j)\n            if isinstance(i, slice):\n                i = range(self.rows)[i]\n            elif is_sequence(i):\n                pass\n            else:\n                i = [i]\n            if isinstance(j, slice):\n                j = range(self.cols)[j]\n            elif is_sequence(j):\n                pass\n            else:\n                j = [j]\n            return self.extract(i, j)\n    else:\n        rows, cols = self.shape\n        if not rows * cols:\n            return [][key]\n        rep = self._rep.rep\n        domain = rep.domain\n        is_slice = isinstance(key, slice)\n        if is_slice:\n            values = [rep.getitem(*divmod(n, cols)) for n in range(rows * cols)[key]]\n        else:\n            values = [rep.getitem(*divmod(index_(key), cols))]\n        if domain != EXRAW:\n            to_sympy = domain.to_sympy\n            values = [to_sympy(val) for val in values]\n        if is_slice:\n            return values\n        else:\n            return values[0]",
    ".sympy.matrices.common.py@@MatrixShaping.shape": "def shape(self):\n    return (self.rows, self.cols)",
    ".sympy.polys.matrices.sdm.py@@SDM.getitem": "def getitem(self, i, j):\n    try:\n        return self[i][j]\n    except KeyError:\n        m, n = self.shape\n        if -m <= i < m and -n <= j < n:\n            try:\n                return self[i % m][j % n]\n            except KeyError:\n                return self.domain.zero\n        else:\n            raise IndexError('index out of range')",
    ".sympy.polys.domains.domain.py@@Domain.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.evalf.py@@EvalfMixin.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    from .numbers import Float, Number\n    n = n if n is not None else 15\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n    if n == 1 and isinstance(self, Number):\n        from .expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        if hasattr(self, 'subs') and subs is not None:\n            v = self.subs(subs)._eval_evalf(prec)\n        else:\n            v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        elif not v.is_number:\n            return v\n        try:\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            return v\n    if result is S.ComplexInfinity:\n        return result\n    re, im, re_acc, im_acc = result\n    if re is S.NaN or im is S.NaN:\n        return S.NaN\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im * S.ImaginaryUnit\n    else:\n        return re",
    ".sympy.core.evalf.py@@evalf": "def evalf(x: 'Expr', prec: int, options: OPT_DICT) -> TMP_RES:\n    from sympy.functions.elementary.complexes import re as re_, im as im_\n    try:\n        rf = evalf_table[type(x)]\n        r = rf(x, prec, options)\n    except KeyError:\n        if 'subs' in options:\n            x = x.subs(evalf_subs(prec, options['subs']))\n        xe = x._eval_evalf(prec)\n        if xe is None:\n            raise NotImplementedError\n        as_real_imag = getattr(xe, 'as_real_imag', None)\n        if as_real_imag is None:\n            raise NotImplementedError\n        re, im = as_real_imag()\n        if re.has(re_) or im.has(im_):\n            raise NotImplementedError\n        if re == 0:\n            re = None\n            reprec = None\n        elif re.is_number:\n            re = re._to_mpmath(prec, allow_ints=False)._mpf_\n            reprec = prec\n        else:\n            raise NotImplementedError\n        if im == 0:\n            im = None\n            imprec = None\n        elif im.is_number:\n            im = im._to_mpmath(prec, allow_ints=False)._mpf_\n            imprec = prec\n        else:\n            raise NotImplementedError\n        r = (re, im, reprec, imprec)\n    if options.get('verbose'):\n        print('### input', x)\n        print('### output', to_str(r[0] or fzero, 50) if isinstance(r, tuple) else r)\n        print('### raw', r)\n        print()\n    chop = options.get('chop', False)\n    if chop:\n        if chop is True:\n            chop_prec = prec\n        else:\n            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))\n            if chop_prec == 3:\n                chop_prec -= 1\n        r = chop_parts(r, chop_prec)\n    if options.get('strict'):\n        check_target(x, r, prec)\n    return r",
    ".sympy.core.numbers.py@@Zero.__abs__": "def __abs__():\n    return S.Zero",
    ".sympy.core.numbers.py@@Float.__new__": "def __new__(cls, num, dps=None, precision=None):\n    if dps is not None and precision is not None:\n        raise ValueError('Both decimal and binary precision supplied. Supply only one. ')\n    if isinstance(num, str):\n        num = num.replace(' ', '').lower()\n        if num.startswith('.') and len(num) > 1:\n            num = '0' + num\n        elif num.startswith('-.') and len(num) > 2:\n            num = '-0.' + num[2:]\n        elif num in ('inf', '+inf'):\n            return S.Infinity\n        elif num == '-inf':\n            return S.NegativeInfinity\n    elif isinstance(num, float) and num == 0:\n        num = '0'\n    elif isinstance(num, float) and num == float('inf'):\n        return S.Infinity\n    elif isinstance(num, float) and num == float('-inf'):\n        return S.NegativeInfinity\n    elif isinstance(num, float) and math.isnan(num):\n        return S.NaN\n    elif isinstance(num, (SYMPY_INTS, Integer)):\n        num = str(num)\n    elif num is S.Infinity:\n        return num\n    elif num is S.NegativeInfinity:\n        return num\n    elif num is S.NaN:\n        return num\n    elif _is_numpy_instance(num):\n        num = _convert_numpy_types(num)\n    elif isinstance(num, mpmath.mpf):\n        if precision is None:\n            if dps is None:\n                precision = num.context.prec\n        num = num._mpf_\n    if dps is None and precision is None:\n        dps = 15\n        if isinstance(num, Float):\n            return num\n        if isinstance(num, str) and _literal_float(num):\n            try:\n                Num = decimal.Decimal(num)\n            except decimal.InvalidOperation:\n                pass\n            else:\n                isint = '.' not in num\n                num, dps = _decimal_to_Rational_prec(Num)\n                if num.is_Integer and isint:\n                    dps = max(dps, len(str(num).lstrip('-')))\n                dps = max(15, dps)\n                precision = dps_to_prec(dps)\n    elif precision == '' and dps is None or (precision is None and dps == ''):\n        if not isinstance(num, str):\n            raise ValueError('The null string can only be used when the number to Float is passed as a string or an integer.')\n        ok = None\n        if _literal_float(num):\n            try:\n                Num = decimal.Decimal(num)\n            except decimal.InvalidOperation:\n                pass\n            else:\n                isint = '.' not in num\n                num, dps = _decimal_to_Rational_prec(Num)\n                if num.is_Integer and isint:\n                    dps = max(dps, len(str(num).lstrip('-')))\n                    precision = dps_to_prec(dps)\n                ok = True\n        if ok is None:\n            raise ValueError('string-float not recognized: %s' % num)\n    if precision is None or precision == '':\n        precision = dps_to_prec(dps)\n    precision = int(precision)\n    if isinstance(num, float):\n        _mpf_ = mlib.from_float(num, precision, rnd)\n    elif isinstance(num, str):\n        _mpf_ = mlib.from_str(num, precision, rnd)\n    elif isinstance(num, decimal.Decimal):\n        if num.is_finite():\n            _mpf_ = mlib.from_str(str(num), precision, rnd)\n        elif num.is_nan():\n            return S.NaN\n        elif num.is_infinite():\n            if num > 0:\n                return S.Infinity\n            return S.NegativeInfinity\n        else:\n            raise ValueError('unexpected decimal value %s' % str(num))\n    elif isinstance(num, tuple) and len(num) in (3, 4):\n        if isinstance(num[1], str):\n            num = list(num)\n            if num[1].endswith('L'):\n                num[1] = num[1][:-1]\n            if num[1].startswith('0x'):\n                num[1] = num[1][2:]\n            num[1] = MPZ(num[1], 16)\n            _mpf_ = tuple(num)\n        elif len(num) == 4:\n            return Float._new(num, precision)\n        else:\n            if not all((num[0] in (0, 1), num[1] >= 0, all((type(i) in (int, int) for i in num)))):\n                raise ValueError('malformed mpf: %s' % (num,))\n            return Float._new((num[0], num[1], num[2], bitcount(num[1])), precision)\n    else:\n        try:\n            _mpf_ = num._as_mpf_val(precision)\n        except (NotImplementedError, AttributeError):\n            _mpf_ = mpmath.mpf(num, prec=precision)._mpf_\n    return cls._new(_mpf_, precision, zero=False)",
    ".sympy.core.numbers.py@@Float._new": "def _new(cls, _mpf_, _prec, zero=True):\n    if zero and _mpf_ == fzero:\n        return S.Zero\n    elif _mpf_ == _mpf_nan:\n        return S.NaN\n    elif _mpf_ == _mpf_inf:\n        return S.Infinity\n    elif _mpf_ == _mpf_ninf:\n        return S.NegativeInfinity\n    obj = Expr.__new__(cls)\n    obj._mpf_ = mpf_norm(_mpf_, _prec)\n    obj._prec = _prec\n    return obj",
    ".sympy.core.numbers.py@@mpf_norm": "def mpf_norm(mpf, prec):\n    sign, man, expt, bc = mpf\n    if not man:\n        if not bc:\n            return fzero\n        else:\n            return mpf\n    from mpmath.libmp.backend import MPZ\n    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n    return rv",
    ".sympy.core.numbers.py@@Float.__gt__": "def __gt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__lt__(self)\n    rv = self._Frel(other, mlib.mpf_gt)\n    if rv is None:\n        return Expr.__gt__(self, other)\n    return rv",
    ".sympy.core.numbers.py@@Float._Frel": "def _Frel(self, other, op):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Rational:\n        '\\n        >>> f = Float(.1,2)\\n        >>> i = 1234567890\\n        >>> (f*i)._mpf_\\n        (0, 471, 18, 9)\\n        >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))\\n        (0, 505555550955, -12, 39)\\n        '\n        smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))\n        ompf = mlib.from_int(other.p)\n        return _sympify(bool(op(smpf, ompf)))\n    elif other.is_Float:\n        return _sympify(bool(op(self._mpf_, other._mpf_)))\n    elif other.is_comparable and other not in (S.Infinity, S.NegativeInfinity):\n        other = other.evalf(prec_to_dps(self._prec))\n        if other._prec > 1:\n            if other.is_Number:\n                return _sympify(bool(op(self._mpf_, other._as_mpf_val(self._prec))))",
    ".sympy.core.numbers.py@@Float.__abs__": "def __abs__(self):\n    return Float._new(mlib.mpf_abs(self._mpf_), self._prec)",
    ".sympy.core.numbers.py@@Float.__lt__": "def __lt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__gt__(self)\n    rv = self._Frel(other, mlib.mpf_lt)\n    if rv is None:\n        return Expr.__lt__(self, other)\n    return rv",
    ".sympy.logic.boolalg.py@@BooleanTrue.__eq__": "def __eq__(self, other):\n    if other is True:\n        return True\n    if other is False:\n        return False\n    return super().__eq__(other)",
    ".sympy.logic.boolalg.py@@BooleanFalse.__eq__": "def __eq__(self, other):\n    if other is True:\n        return False\n    if other is False:\n        return True\n    return super().__eq__(other)",
    ".sympy.matrices.matrices.py@@MatrixDeterminant.det": "def det(self, method='bareiss', iszerofunc=None):\n    return _det(self, method=method, iszerofunc=iszerofunc)",
    ".sympy.matrices.determinant.py@@_det": "def _det(M, method='bareiss', iszerofunc=None):\n    method = method.lower()\n    if method == 'bareis':\n        method = 'bareiss'\n    elif method == 'det_lu':\n        method = 'lu'\n    if method not in ('bareiss', 'berkowitz', 'lu', 'domain-ge'):\n        raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n    if iszerofunc is None:\n        if method == 'bareiss':\n            iszerofunc = _is_zero_after_expand_mul\n        elif method == 'lu':\n            iszerofunc = _iszero\n    elif not isinstance(iszerofunc, FunctionType):\n        raise ValueError(\"Zero testing method '%s' unrecognized\" % iszerofunc)\n    n = M.rows\n    if n == M.cols:\n        if n == 0:\n            return M.one\n        elif n == 1:\n            return M[0, 0]\n        elif n == 2:\n            m = M[0, 0] * M[1, 1] - M[0, 1] * M[1, 0]\n            return _get_intermediate_simp(_dotprodsimp)(m)\n        elif n == 3:\n            m = M[0, 0] * M[1, 1] * M[2, 2] + M[0, 1] * M[1, 2] * M[2, 0] + M[0, 2] * M[1, 0] * M[2, 1] - M[0, 2] * M[1, 1] * M[2, 0] - M[0, 0] * M[1, 2] * M[2, 1] - M[0, 1] * M[1, 0] * M[2, 2]\n            return _get_intermediate_simp(_dotprodsimp)(m)\n    dets = []\n    for b in M.strongly_connected_components():\n        if method == 'domain-ge':\n            det = _det_DOM(M[b, b])\n        elif method == 'bareiss':\n            det = M[b, b]._eval_det_bareiss(iszerofunc=iszerofunc)\n        elif method == 'berkowitz':\n            det = M[b, b]._eval_det_berkowitz()\n        elif method == 'lu':\n            det = M[b, b]._eval_det_lu(iszerofunc=iszerofunc)\n        dets.append(det)\n    return Mul(*dets)",
    ".sympy.polys.matrices.domainmatrix.py@@DomainMatrix.getitem_sympy": "def getitem_sympy(self, i, j):\n    return self.domain.to_sympy(self.rep.getitem(i, j))",
    ".sympy.matrices.utilities.py@@_get_intermediate_simp": "def _get_intermediate_simp(deffunc=lambda x: x, offfunc=lambda x: x, onfunc=_dotprodsimp, dotprodsimp=None):\n    if dotprodsimp is False or _dotprodsimp_state.state is False:\n        return offfunc\n    if dotprodsimp is True or _dotprodsimp_state.state is True:\n        return onfunc\n    return deffunc",
    ".sympy.matrices.utilities.py@@_dotprodsimp": "def _dotprodsimp(expr, withsimp=False):\n    from sympy.simplify.simplify import dotprodsimp as dps\n    return dps(expr, withsimp=withsimp)",
    ".sympy.simplify.simplify.py@@dotprodsimp": "def dotprodsimp(expr, withsimp=False):\n\n    def count_ops_alg(expr):\n        ops = 0\n        args = [expr]\n        ratfunc = False\n        while args:\n            a = args.pop()\n            if not isinstance(a, Basic):\n                continue\n            if a.is_Rational:\n                if a is not S.One:\n                    ops += bool(a.p < 0) + bool(a.q != 1)\n            elif a.is_Mul:\n                if a.could_extract_minus_sign():\n                    ops += 1\n                    if a.args[0] is S.NegativeOne:\n                        a = a.as_two_terms()[1]\n                    else:\n                        a = -a\n                n, d = fraction(a)\n                if n.is_Integer:\n                    ops += 1 + bool(n < 0)\n                    args.append(d)\n                elif d is not S.One:\n                    if not d.is_Integer:\n                        args.append(d)\n                        ratfunc = True\n                    ops += 1\n                    args.append(n)\n                else:\n                    ops += len(a.args) - 1\n                    args.extend(a.args)\n            elif a.is_Add:\n                laargs = len(a.args)\n                negs = 0\n                for ai in a.args:\n                    if ai.could_extract_minus_sign():\n                        negs += 1\n                        ai = -ai\n                    args.append(ai)\n                ops += laargs - (negs != laargs)\n            elif a.is_Pow:\n                ops += 1\n                args.append(a.base)\n                if not ratfunc:\n                    ratfunc = a.exp.is_negative is not False\n        return (ops, ratfunc)\n\n    def nonalg_subs_dummies(expr, dummies):\n        if not expr.args:\n            return expr\n        if expr.is_Add or expr.is_Mul or expr.is_Pow:\n            args = None\n            for i, a in enumerate(expr.args):\n                c = nonalg_subs_dummies(a, dummies)\n                if c is a:\n                    continue\n                if args is None:\n                    args = list(expr.args)\n                args[i] = c\n            if args is None:\n                return expr\n            return expr.func(*args)\n        return dummies.setdefault(expr, Dummy())\n    simplified = False\n    if isinstance(expr, Basic) and (expr.is_Add or expr.is_Mul or expr.is_Pow):\n        expr2 = expr.expand(deep=True, modulus=None, power_base=False, power_exp=False, mul=True, log=False, multinomial=True, basic=False)\n        if expr2 != expr:\n            expr = expr2\n            simplified = True\n        exprops, ratfunc = count_ops_alg(expr)\n        if exprops >= 6:\n            if ratfunc:\n                dummies = {}\n                expr2 = nonalg_subs_dummies(expr, dummies)\n                if expr2 is expr or count_ops_alg(expr2)[0] >= 6:\n                    expr3 = cancel(expr2)\n                    if expr3 != expr2:\n                        expr = expr3.subs([(d, e) for e, d in dummies.items()])\n                        simplified = True\n        elif exprops == 5 and expr.is_Add and expr.args[0].is_Mul and expr.args[1].is_Mul and expr.args[0].args[-1].is_Pow and expr.args[1].args[-1].is_Pow and (expr.args[0].args[-1].exp is S.NegativeOne) and (expr.args[1].args[-1].exp is S.NegativeOne):\n            expr2 = together(expr)\n            expr2ops = count_ops_alg(expr2)[0]\n            if expr2ops < exprops:\n                expr = expr2\n                simplified = True\n        else:\n            simplified = True\n    return (expr, simplified) if withsimp else expr",
    ".sympy.matrices.reductions.py@@_permute_complexity_right": "def _permute_complexity_right(M, iszerofunc):\n\n    def complexity(i):\n        return sum((1 if iszerofunc(e) is None else 0 for e in M[:, i]))\n    complex = [(complexity(i), i) for i in range(M.cols)]\n    perm = [j for i, j in sorted(complex)]\n    return (M.permute(perm, orientation='cols'), perm)",
    ".sympy.matrices.reductions.py@@complexity": "def complexity(i):\n    return sum((1 if iszerofunc(e) is None else 0 for e in M[:, i]))",
    ".sympy.matrices.common.py@@MatrixShaping.extract": "def extract(self, rowsList, colsList):\n    if not is_sequence(rowsList) or not is_sequence(colsList):\n        raise TypeError('rowsList and colsList must be iterable')\n    if rowsList and all((isinstance(i, bool) for i in rowsList)):\n        rowsList = [index for index, item in enumerate(rowsList) if item]\n    if colsList and all((isinstance(i, bool) for i in colsList)):\n        colsList = [index for index, item in enumerate(colsList) if item]\n    rowsList = [a2idx(k, self.rows) for k in rowsList]\n    colsList = [a2idx(k, self.cols) for k in colsList]\n    return self._eval_extract(rowsList, colsList)",
    ".sympy.matrices.common.py@@a2idx": "def a2idx(j, n=None):\n    if not isinstance(j, int):\n        jindex = getattr(j, '__index__', None)\n        if jindex is not None:\n            j = jindex()\n        else:\n            raise IndexError('Invalid index a[%r]' % (j,))\n    if n is not None:\n        if j < 0:\n            j += n\n        if not (j >= 0 and j < n):\n            raise IndexError('Index out of range: a[%s]' % (j,))\n    return int(j)",
    ".sympy.matrices.repmatrix.py@@RepMatrix._eval_extract": "def _eval_extract(self, rowsList, colsList):\n    return self._fromrep(self._rep.extract(rowsList, colsList))",
    ".sympy.polys.matrices.domainmatrix.py@@DomainMatrix.extract": "def extract(self, rowslist, colslist):\n    return self.from_rep(self.rep.extract(rowslist, colslist))",
    ".sympy.polys.matrices.sdm.py@@SDM.extract": "def extract(self, rows, cols):\n    if not (self and rows and cols):\n        return self.zeros((len(rows), len(cols)), self.domain)\n    m, n = self.shape\n    if not -m <= min(rows) <= max(rows) < m:\n        raise IndexError('Row index out of range')\n    if not -n <= min(cols) <= max(cols) < n:\n        raise IndexError('Column index out of range')\n    rowmap = defaultdict(list)\n    colmap = defaultdict(list)\n    for i2, i1 in enumerate(rows):\n        rowmap[i1 % m].append(i2)\n    for j2, j1 in enumerate(cols):\n        colmap[j1 % n].append(j2)\n    rowset = set(rowmap)\n    colset = set(colmap)\n    sdm1 = self\n    sdm2 = {}\n    for i1 in rowset & set(sdm1):\n        row1 = sdm1[i1]\n        row2 = {}\n        for j1 in colset & set(row1):\n            row1_j1 = row1[j1]\n            for j2 in colmap[j1]:\n                row2[j2] = row1_j1\n        if row2:\n            for i2 in rowmap[i1]:\n                sdm2[i2] = row2.copy()\n    return self.new(sdm2, (len(rows), len(cols)), self.domain)",
    ".sympy.matrices.common.py@@MatrixOperations.permute": "def permute(self, perm, orientation='rows', direction='forward'):\n    from sympy.combinatorics import Permutation\n    if direction == 'forwards':\n        direction = 'forward'\n    if direction == 'backwards':\n        direction = 'backward'\n    if orientation == 'columns':\n        orientation = 'cols'\n    if direction not in ('forward', 'backward'):\n        raise TypeError(\"direction='{}' is an invalid kwarg. Try 'forward' or 'backward'\".format(direction))\n    if orientation not in ('rows', 'cols'):\n        raise TypeError(\"orientation='{}' is an invalid kwarg. Try 'rows' or 'cols'\".format(orientation))\n    if not isinstance(perm, (Permutation, Iterable)):\n        raise ValueError('{} must be a list, a list of lists, or a SymPy permutation object.'.format(perm))\n    max_index = self.rows if orientation == 'rows' else self.cols\n    if not all((0 <= t <= max_index for t in flatten(list(perm)))):\n        raise IndexError('`swap` indices out of range.')\n    if perm and (not isinstance(perm, Permutation)) and isinstance(perm[0], Iterable):\n        if direction == 'forward':\n            perm = list(reversed(perm))\n        perm = Permutation(perm, size=max_index + 1)\n    else:\n        perm = Permutation(perm, size=max_index + 1)\n    if orientation == 'rows':\n        return self._eval_permute_rows(perm)\n    if orientation == 'cols':\n        return self._eval_permute_cols(perm)",
    ".sympy.utilities.iterables.py@@flatten": "def flatten(iterable, levels=None, cls=None):\n    from sympy.tensor.array import NDimArray\n    if levels is not None:\n        if not levels:\n            return iterable\n        elif levels > 0:\n            levels -= 1\n        else:\n            raise ValueError('expected non-negative number of levels, got %s' % levels)\n    if cls is None:\n        reducible = lambda x: is_sequence(x, set)\n    else:\n        reducible = lambda x: isinstance(x, cls)\n    result = []\n    for el in iterable:\n        if reducible(el):\n            if hasattr(el, 'args') and (not isinstance(el, NDimArray)):\n                el = el.args\n            result.extend(flatten(el, levels=levels, cls=cls))\n        else:\n            result.append(el)\n    return result",
    ".sympy.combinatorics.permutations.py@@Permutation.__new__": "def __new__(cls, *args, size=None, **kwargs):\n    if size is not None:\n        size = int(size)\n    ok = True\n    if not args:\n        return cls._af_new(list(range(size or 0)))\n    elif len(args) > 1:\n        return cls._af_new(Cycle(*args).list(size))\n    if len(args) == 1:\n        a = args[0]\n        if isinstance(a, cls):\n            if size is None or size == a.size:\n                return a\n            return cls(a.array_form, size=size)\n        if isinstance(a, Cycle):\n            return cls._af_new(a.list(size))\n        if not is_sequence(a):\n            if size is not None and a + 1 > size:\n                raise ValueError('size is too small when max is %s' % a)\n            return cls._af_new(list(range(a + 1)))\n        if has_variety((is_sequence(ai) for ai in a)):\n            ok = False\n    else:\n        ok = False\n    if not ok:\n        raise ValueError('Permutation argument must be a list of ints, a list of lists, Permutation or Cycle.')\n    args = list(args[0])\n    is_cycle = args and is_sequence(args[0])\n    if is_cycle:\n        args = [[int(i) for i in c] for c in args]\n    else:\n        args = [int(i) for i in args]\n    temp = flatten(args)\n    if has_dups(temp) and (not is_cycle):\n        raise ValueError('there were repeated elements.')\n    temp = set(temp)\n    if not is_cycle:\n        if temp != set(range(len(temp))):\n            raise ValueError('Integers 0 through %s must be present.' % max(temp))\n        if size is not None and temp and (max(temp) + 1 > size):\n            raise ValueError('max element should not exceed %s' % (size - 1))\n    if is_cycle:\n        c = Cycle()\n        for ci in args:\n            c = c(*ci)\n        aform = c.list()\n    else:\n        aform = list(args)\n    if size and size > len(aform):\n        aform.extend(list(range(len(aform), size)))\n    return cls._af_new(aform)",
    ".sympy.utilities.iterables.py@@has_variety": "def has_variety(seq):\n    for i, s in enumerate(seq):\n        if i == 0:\n            sentinel = s\n        elif s != sentinel:\n            return True\n    return False",
    ".sympy.utilities.iterables.py@@has_dups": "def has_dups(seq):\n    from sympy.core.containers import Dict\n    from sympy.sets.sets import Set\n    if isinstance(seq, (dict, set, Dict, Set)):\n        return False\n    unique = set()\n    try:\n        return any((True for s in seq if s in unique or unique.add(s)))\n    except TypeError:\n        return len(seq) != len(list(uniq(seq)))",
    ".sympy.combinatorics.permutations.py@@Permutation._af_new": "def _af_new(cls, perm):\n    p = super().__new__(cls)\n    p._array_form = perm\n    p._size = len(perm)\n    return p",
    ".sympy.matrices.common.py@@MatrixOperations._eval_permute_cols": "def _eval_permute_cols(self, perm):\n    mapping = list(perm)\n\n    def entry(i, j):\n        return self[i, mapping[j]]\n    return self._new(self.rows, self.cols, entry)",
    ".sympy.combinatorics.permutations.py@@Permutation.__iter__": "def __iter__(self):\n    yield from self.array_form",
    ".sympy.combinatorics.permutations.py@@Permutation.array_form": "def array_form(self):\n    return self._array_form[:]",
    ".sympy.matrices.common.py@@MatrixOperations.entry": "def entry(i, j):\n    return self[i, j] if i + k >= j else self.zero",
    ".sympy.core.numbers.py@@Integer.__index__": "def __index__(self):\n    return self.p",
    ".sympy.matrices.reductions.py@@_row_reduce": "def _row_reduce(M, iszerofunc, simpfunc, normalize_last=True, normalize=True, zero_above=True):\n    mat, pivot_cols, swaps = _row_reduce_list(list(M), M.rows, M.cols, M.one, iszerofunc, simpfunc, normalize_last=normalize_last, normalize=normalize, zero_above=zero_above)\n    return (M._new(M.rows, M.cols, mat), pivot_cols, swaps)",
    ".sympy.matrices.matrices.py@@MatrixBase.__len__": "def __len__(self):\n    return self.rows * self.cols",
    ".sympy.matrices.reductions.py@@_row_reduce_list": "def _row_reduce_list(mat, rows, cols, one, iszerofunc, simpfunc, normalize_last=True, normalize=True, zero_above=True):\n\n    def get_col(i):\n        return mat[i::cols]\n\n    def row_swap(i, j):\n        mat[i * cols:(i + 1) * cols], mat[j * cols:(j + 1) * cols] = (mat[j * cols:(j + 1) * cols], mat[i * cols:(i + 1) * cols])\n\n    def cross_cancel(a, i, b, j):\n        q = (j - i) * cols\n        for p in range(i * cols, (i + 1) * cols):\n            mat[p] = isimp(a * mat[p] - b * mat[p + q])\n    isimp = _get_intermediate_simp(_dotprodsimp)\n    piv_row, piv_col = (0, 0)\n    pivot_cols = []\n    swaps = []\n    while piv_col < cols and piv_row < rows:\n        pivot_offset, pivot_val, assumed_nonzero, newly_determined = _find_reasonable_pivot(get_col(piv_col)[piv_row:], iszerofunc, simpfunc)\n        for offset, val in newly_determined:\n            offset += piv_row\n            mat[offset * cols + piv_col] = val\n        if pivot_offset is None:\n            piv_col += 1\n            continue\n        pivot_cols.append(piv_col)\n        if pivot_offset != 0:\n            row_swap(piv_row, pivot_offset + piv_row)\n            swaps.append((piv_row, pivot_offset + piv_row))\n        if normalize_last is False:\n            i, j = (piv_row, piv_col)\n            mat[i * cols + j] = one\n            for p in range(i * cols + j + 1, (i + 1) * cols):\n                mat[p] = isimp(mat[p] / pivot_val)\n            pivot_val = one\n        for row in range(rows):\n            if row == piv_row:\n                continue\n            if zero_above is False and row < piv_row:\n                continue\n            val = mat[row * cols + piv_col]\n            if iszerofunc(val):\n                continue\n            cross_cancel(pivot_val, row, val, piv_row)\n        piv_row += 1\n    if normalize_last is True and normalize is True:\n        for piv_i, piv_j in enumerate(pivot_cols):\n            pivot_val = mat[piv_i * cols + piv_j]\n            mat[piv_i * cols + piv_j] = one\n            for p in range(piv_i * cols + piv_j + 1, (piv_i + 1) * cols):\n                mat[p] = isimp(mat[p] / pivot_val)\n    return (mat, tuple(pivot_cols), tuple(swaps))",
    ".sympy.matrices.reductions.py@@get_col": "def get_col(i):\n    return mat[i::cols]",
    ".sympy.matrices.determinant.py@@_find_reasonable_pivot": "def _find_reasonable_pivot(col, iszerofunc=_iszero, simpfunc=_simplify):\n    newly_determined = []\n    col = list(col)\n    if all((isinstance(x, (Float, Integer)) for x in col)) and any((isinstance(x, Float) for x in col)):\n        col_abs = [abs(x) for x in col]\n        max_value = max(col_abs)\n        if iszerofunc(max_value):\n            if max_value != 0:\n                newly_determined = [(i, 0) for i, x in enumerate(col) if x != 0]\n            return (None, None, False, newly_determined)\n        index = col_abs.index(max_value)\n        return (index, col[index], False, newly_determined)\n    possible_zeros = []\n    for i, x in enumerate(col):\n        is_zero = iszerofunc(x)\n        if is_zero == False:\n            return (i, x, False, newly_determined)\n        possible_zeros.append(is_zero)\n    if all(possible_zeros):\n        return (None, None, False, newly_determined)\n    for i, x in enumerate(col):\n        if possible_zeros[i] is not None:\n            continue\n        simped = simpfunc(x)\n        is_zero = iszerofunc(simped)\n        if is_zero in (True, False):\n            newly_determined.append((i, simped))\n        if is_zero == False:\n            return (i, simped, False, newly_determined)\n        possible_zeros[i] = is_zero\n    if all(possible_zeros):\n        return (None, None, False, newly_determined)\n    for i, x in enumerate(col):\n        if possible_zeros[i] is not None:\n            continue\n        if x.equals(S.Zero):\n            possible_zeros[i] = True\n            newly_determined.append((i, S.Zero))\n    if all(possible_zeros):\n        return (None, None, False, newly_determined)\n    i = possible_zeros.index(None)\n    return (i, col[i], True, newly_determined)",
    ".sympy.matrices.reductions.py@@row_swap": "def row_swap(i, j):\n    mat[i * cols:(i + 1) * cols], mat[j * cols:(j + 1) * cols] = (mat[j * cols:(j + 1) * cols], mat[i * cols:(i + 1) * cols])",
    ".sympy.core.numbers.py@@Zero.__neg__": "def __neg__():\n    return S.Zero",
    ".sympy.matrices.reductions.py@@cross_cancel": "def cross_cancel(a, i, b, j):\n    q = (j - i) * cols\n    for p in range(i * cols, (i + 1) * cols):\n        mat[p] = isimp(a * mat[p] - b * mat[p + q])",
    ".sympy.geometry.polygon.py@@Triangle.__new__": "def __new__(cls, *args, **kwargs):\n    if len(args) != 3:\n        if 'sss' in kwargs:\n            return _sss(*[simplify(a) for a in kwargs['sss']])\n        if 'asa' in kwargs:\n            return _asa(*[simplify(a) for a in kwargs['asa']])\n        if 'sas' in kwargs:\n            return _sas(*[simplify(a) for a in kwargs['sas']])\n        msg = 'Triangle instantiates with three points or a valid keyword.'\n        raise GeometryError(msg)\n    vertices = [Point(a, dim=2, **kwargs) for a in args]\n    nodup = []\n    for p in vertices:\n        if nodup and p == nodup[-1]:\n            continue\n        nodup.append(p)\n    if len(nodup) > 1 and nodup[-1] == nodup[0]:\n        nodup.pop()\n    i = -3\n    while i < len(nodup) - 3 and len(nodup) > 2:\n        a, b, c = sorted([nodup[i], nodup[i + 1], nodup[i + 2]], key=default_sort_key)\n        if Point.is_collinear(a, b, c):\n            nodup[i] = a\n            nodup[i + 1] = None\n            nodup.pop(i + 1)\n        i += 1\n    vertices = list(filter(lambda x: x is not None, nodup))\n    if len(vertices) == 3:\n        return GeometryEntity.__new__(cls, *vertices, **kwargs)\n    elif len(vertices) == 2:\n        return Segment(*vertices, **kwargs)\n    else:\n        return Point(*vertices, **kwargs)",
    ".sympy.core.sorting.py@@default_sort_key": "def default_sort_key(item, order=None):\n    from .basic import Basic\n    from .singleton import S\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n    if iterable(item, exclude=str):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            args = list(item)\n            unordered = False\n        args = [default_sort_key(arg, order=order) for arg in args]\n        if unordered:\n            args = sorted(args)\n        cls_index, args = (10, (len(args), tuple(args)))\n    else:\n        if not isinstance(item, str):\n            try:\n                item = sympify(item, strict=True)\n            except SympifyError:\n                pass\n            else:\n                if isinstance(item, Basic):\n                    return default_sort_key(item)\n        cls_index, args = (0, (1, (str(item),)))\n    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)",
    ".sympy.core.basic.py@@Basic.sort_key": "def sort_key(self, order=None):\n\n    def inner_key(arg):\n        if isinstance(arg, Basic):\n            return arg.sort_key(order)\n        else:\n            return arg\n    args = self._sorted_args\n    args = (len(args), tuple([inner_key(arg) for arg in args]))\n    return (self.class_key(), args, S.One.sort_key(), S.One)",
    ".sympy.core.basic.py@@Basic._sorted_args": "def _sorted_args(self):\n    return self.args",
    ".sympy.core.basic.py@@Basic.inner_key": "def inner_key(arg):\n    if isinstance(arg, Basic):\n        return arg.sort_key(order)\n    else:\n        return arg",
    ".sympy.core.numbers.py@@Number.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (0, ()), (), self)",
    ".sympy.core.numbers.py@@Number.class_key": "def class_key(cls):\n    return (1, 0, 'Number')",
    ".sympy.core.basic.py@@Basic.class_key": "def class_key(cls):\n    return (5, 0, cls.__name__)",
    ".sympy.geometry.polygon.py@@Polygon.vertices": "def vertices(self):\n    return list(self.args)",
    ".sympy.polys.domains.rationalfield.py@@RationalField.from_sympy": "def from_sympy(self, a):\n    if a.is_Rational:\n        return MPQ(a.p, a.q)\n    elif a.is_Float:\n        from sympy.polys.domains import RR\n        return MPQ(*map(int, RR.to_rational(a)))\n    else:\n        raise CoercionFailed('expected `Rational` object, got %s' % a)",
    ".sympy.external.pythonmpq.py@@PythonMPQ.__new__": "def __new__(cls, numerator, denominator=None):\n    if denominator is not None:\n        if isinstance(numerator, int) and isinstance(denominator, int):\n            divisor = gcd(numerator, denominator)\n            numerator //= divisor\n            denominator //= divisor\n            return cls._new_check(numerator, denominator)\n    else:\n        if isinstance(numerator, int):\n            return cls._new(numerator, 1)\n        elif isinstance(numerator, PythonMPQ):\n            return cls._new(numerator.numerator, numerator.denominator)\n        if isinstance(numerator, (Decimal, float, str)):\n            numerator = Fraction(numerator)\n        if isinstance(numerator, Fraction):\n            return cls._new(numerator.numerator, numerator.denominator)\n    raise TypeError('PythonMPQ() requires numeric or string argument')",
    ".sympy.external.pythonmpq.py@@PythonMPQ._new_check": "def _new_check(cls, numerator, denominator):\n    if not denominator:\n        raise ZeroDivisionError(f'Zero divisor {numerator}/{denominator}')\n    elif denominator < 0:\n        numerator = -numerator\n        denominator = -denominator\n    return cls._new(numerator, denominator)",
    ".sympy.external.pythonmpq.py@@PythonMPQ._new": "def _new(cls, numerator, denominator):\n    obj = super().__new__(cls)\n    obj.numerator = numerator\n    obj.denominator = denominator\n    return obj",
    ".sympy.polys.domains.field.py@@Field.gcd": "def gcd(self, a, b):\n    try:\n        ring = self.get_ring()\n    except DomainError:\n        return self.one\n    p = ring.gcd(self.numer(a), self.numer(b))\n    q = ring.lcm(self.denom(a), self.denom(b))\n    return self.convert(p, ring) / q",
    ".sympy.polys.domains.rationalfield.py@@RationalField.get_ring": "def get_ring(self):\n    from sympy.polys.domains import ZZ\n    return ZZ",
    ".sympy.polys.domains.rationalfield.py@@RationalField.numer": "def numer(self, a):\n    return a.numerator",
    ".sympy.polys.domains.rationalfield.py@@RationalField.denom": "def denom(self, a):\n    return a.denominator",
    ".sympy.polys.domains.integerring.py@@IntegerRing.lcm": "def lcm(self, a, b):\n    return lcm(a, b)",
    ".sympy.core.numbers.py@@ilcm": "def ilcm(*args):\n    if len(args) < 2:\n        raise TypeError('ilcm() takes at least 2 arguments (%s given)' % len(args))\n    if 0 in args:\n        return 0\n    a = args[0]\n    for b in args[1:]:\n        a = a // igcd(a, b) * b\n    return a",
    ".sympy.polys.domains.domain.py@@Domain.convert": "def convert(self, element, base=None):\n    if base is not None:\n        if _not_a_coeff(element):\n            raise CoercionFailed('%s is not in any domain' % element)\n        return self.convert_from(element, base)\n    if self.of_type(element):\n        return element\n    if _not_a_coeff(element):\n        raise CoercionFailed('%s is not in any domain' % element)\n    from sympy.polys.domains import ZZ, QQ, RealField, ComplexField\n    if ZZ.of_type(element):\n        return self.convert_from(element, ZZ)\n    if isinstance(element, int):\n        return self.convert_from(ZZ(element), ZZ)\n    if HAS_GMPY:\n        integers = ZZ\n        if isinstance(element, integers.tp):\n            return self.convert_from(element, integers)\n        rationals = QQ\n        if isinstance(element, rationals.tp):\n            return self.convert_from(element, rationals)\n    if isinstance(element, float):\n        parent = RealField(tol=False)\n        return self.convert_from(parent(element), parent)\n    if isinstance(element, complex):\n        parent = ComplexField(tol=False)\n        return self.convert_from(parent(element), parent)\n    if isinstance(element, DomainElement):\n        return self.convert_from(element, element.parent())\n    if self.is_Numerical and getattr(element, 'is_ground', False):\n        return self.convert(element.LC())\n    if isinstance(element, Basic):\n        try:\n            return self.from_sympy(element)\n        except (TypeError, ValueError):\n            pass\n    elif not is_sequence(element):\n        try:\n            element = sympify(element, strict=True)\n            if isinstance(element, Basic):\n                return self.from_sympy(element)\n        except (TypeError, ValueError):\n            pass\n    raise CoercionFailed('Cannot convert %s of type %s to %s' % (element, type(element), self))",
    ".sympy.polys.polyutils.py@@_not_a_coeff": "def _not_a_coeff(expr):\n    if type(expr) in illegal_types or expr in finf:\n        return True\n    if isinstance(expr, float) and float(expr) != expr:\n        return True\n    return",
    ".sympy.polys.domains.rationalfield.py@@RationalField.from_ZZ": "def from_ZZ(K1, a, K0):\n    return MPQ(a)",
    ".sympy.external.pythonmpq.py@@PythonMPQ.__truediv__": "def __truediv__(self, other):\n    if isinstance(other, PythonMPQ):\n        ap, aq = (self.numerator, self.denominator)\n        bp, bq = (other.numerator, other.denominator)\n        x1 = gcd(ap, bp)\n        x2 = gcd(bq, aq)\n        p, q = (ap // x1 * (bq // x2), aq // x2 * (bp // x1))\n    elif isinstance(other, int):\n        x = gcd(other, self.numerator)\n        p = self.numerator // x\n        q = self.denominator * (other // x)\n    else:\n        return NotImplemented\n    return self._new_check(p, q)",
    ".sympy.external.pythonmpq.py@@PythonMPQ.__eq__": "def __eq__(self, other):\n    if isinstance(other, PythonMPQ):\n        return self.numerator == other.numerator and self.denominator == other.denominator\n    elif isinstance(other, self._compatible_types):\n        return self.__eq__(PythonMPQ(other))\n    else:\n        return NotImplemented",
    ".sympy.polys.domains.rationalfield.py@@RationalField.to_sympy": "def to_sympy(self, a):\n    return SymPyRational(int(a.numerator), int(a.denominator))",
    ".sympy.integrals.intpoly.py@@decompose": "def decompose(expr, separate=False):\n    poly_dict = {}\n    if isinstance(expr, Expr) and (not expr.is_number):\n        if expr.is_Symbol:\n            poly_dict[1] = expr\n        elif expr.is_Add:\n            symbols = expr.atoms(Symbol)\n            degrees = [(sum(degree_list(monom, *symbols)), monom) for monom in expr.args]\n            if separate:\n                return {monom[1] for monom in degrees}\n            else:\n                for monom in degrees:\n                    degree, term = monom\n                    if poly_dict.get(degree):\n                        poly_dict[degree] += term\n                    else:\n                        poly_dict[degree] = term\n        elif expr.is_Pow:\n            _, degree = expr.args\n            poly_dict[degree] = expr\n        else:\n            degree = 0\n            for term in expr.args:\n                term_type = len(term.args)\n                if term_type == 0 and term.is_Symbol:\n                    degree += 1\n                elif term_type == 2:\n                    degree += term.args[1]\n            poly_dict[degree] = expr\n    else:\n        poly_dict[0] = expr\n    if separate:\n        return set(poly_dict.values())\n    return poly_dict",
    ".sympy.polys.polytools.py@@Poly.__new__": "def __new__(cls, rep, *gens, **args):\n    opt = options.build_options(gens, args)\n    if 'order' in opt:\n        raise NotImplementedError(\"'order' keyword is not implemented yet\")\n    if isinstance(rep, (DMP, DMF, ANP, DomainElement)):\n        return cls._from_domain_element(rep, opt)\n    elif iterable(rep, exclude=str):\n        if isinstance(rep, dict):\n            return cls._from_dict(rep, opt)\n        else:\n            return cls._from_list(list(rep), opt)\n    else:\n        rep = sympify(rep)\n        if rep.is_Poly:\n            return cls._from_poly(rep, opt)\n        else:\n            return cls._from_expr(rep, opt)",
    ".sympy.polys.polytools.py@@Poly._from_expr": "def _from_expr(cls, rep, opt):\n    rep, opt = _dict_from_expr(rep, opt)\n    return cls._from_dict(rep, opt)",
    ".sympy.polys.polyutils.py@@_dict_from_expr": "def _dict_from_expr(expr, opt):\n    if expr.is_commutative is False:\n        raise PolynomialError('non-commutative expressions are not supported')\n\n    def _is_expandable_pow(expr):\n        return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add\n    if opt.expand is not False:\n        if not isinstance(expr, (Expr, Eq)):\n            raise PolynomialError('expression must be of type Expr')\n        expr = expr.expand()\n        while any((_is_expandable_pow(i) or (i.is_Mul and any((_is_expandable_pow(j) for j in i.args))) for i in Add.make_args(expr))):\n            expr = expand_multinomial(expr)\n        while any((i.is_Mul and any((j.is_Add for j in i.args)) for i in Add.make_args(expr))):\n            expr = expand_mul(expr)\n    if opt.gens:\n        rep, gens = _dict_from_expr_if_gens(expr, opt)\n    else:\n        rep, gens = _dict_from_expr_no_gens(expr, opt)\n    return (rep, opt.clone({'gens': gens}))",
    ".sympy.polys.polyoptions.py@@Expand.default": "def default(cls):\n    return True",
    ".sympy.core.expr.py@@Expr.expand": "def expand(self, deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints):\n    from sympy.simplify.radsimp import fraction\n    hints.update(power_base=power_base, power_exp=power_exp, mul=mul, log=log, multinomial=multinomial, basic=basic)\n    expr = self\n    if hints.pop('frac', False):\n        n, d = [a.expand(deep=deep, modulus=modulus, **hints) for a in fraction(self)]\n        return n / d\n    elif hints.pop('denom', False):\n        n, d = fraction(self)\n        return n / d.expand(deep=deep, modulus=modulus, **hints)\n    elif hints.pop('numer', False):\n        n, d = fraction(self)\n        return n.expand(deep=deep, modulus=modulus, **hints) / d\n\n    def _expand_hint_key(hint):\n        if hint == 'mul':\n            return 'mulz'\n        return hint\n    for hint in sorted(hints.keys(), key=_expand_hint_key):\n        use_hint = hints[hint]\n        if use_hint:\n            hint = '_eval_expand_' + hint\n            expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)\n    while True:\n        was = expr\n        if hints.get('multinomial', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_multinomial', deep=deep, **hints)\n        if hints.get('mul', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_mul', deep=deep, **hints)\n        if hints.get('log', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_log', deep=deep, **hints)\n        if expr == was:\n            break\n    if modulus is not None:\n        modulus = sympify(modulus)\n        if not modulus.is_Integer or modulus <= 0:\n            raise ValueError('modulus must be a positive integer, got %s' % modulus)\n        terms = []\n        for term in Add.make_args(expr):\n            coeff, tail = term.as_coeff_Mul(rational=True)\n            coeff %= modulus\n            if coeff:\n                terms.append(coeff * tail)\n        expr = Add(*terms)\n    return expr",
    ".sympy.core.expr.py@@Expr._expand_hint_key": "def _expand_hint_key(hint):\n    if hint == 'mul':\n        return 'mulz'\n    return hint",
    ".sympy.core.expr.py@@Expr._expand_hint": "def _expand_hint(expr, hint, deep=True, **hints):\n    hit = False\n    if deep and getattr(expr, 'args', ()) and (not expr.is_Atom):\n        sargs = []\n        for arg in expr.args:\n            arg, arghit = Expr._expand_hint(arg, hint, **hints)\n            hit |= arghit\n            sargs.append(arg)\n        if hit:\n            expr = expr.func(*sargs)\n    if hasattr(expr, hint):\n        newexpr = getattr(expr, hint)(**hints)\n        if newexpr != expr:\n            return (newexpr, True)\n    return (expr, hit)",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n    if not (self.is_Number and other.is_Number) and type(self) != type(other):\n        return False\n    a, b = (self._hashable_content(), other._hashable_content())\n    if a != b:\n        return False\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    ".sympy.core.operations.py@@AssocOp.make_args": "def make_args(cls, expr):\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    ".sympy.polys.polyutils.py@@_is_expandable_pow": "def _is_expandable_pow(expr):\n    return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add",
    ".sympy.polys.polyoptions.py@@Gens.default": "def default(cls):\n    return ()",
    ".sympy.polys.polyutils.py@@_dict_from_expr_no_gens": "def _dict_from_expr_no_gens(expr, opt):\n    (poly,), gens = _parallel_dict_from_expr_no_gens((expr,), opt)\n    return (poly, gens)",
    ".sympy.polys.polyutils.py@@_parallel_dict_from_expr_no_gens": "def _parallel_dict_from_expr_no_gens(exprs, opt):\n    if opt.domain is not None:\n\n        def _is_coeff(factor):\n            return factor in opt.domain\n    elif opt.extension is True:\n\n        def _is_coeff(factor):\n            return factor.is_algebraic\n    elif opt.greedy is not False:\n\n        def _is_coeff(factor):\n            return factor is S.ImaginaryUnit\n    else:\n\n        def _is_coeff(factor):\n            return factor.is_number\n    gens, reprs = (set(), [])\n    for expr in exprs:\n        terms = []\n        if expr.is_Equality:\n            expr = expr.lhs - expr.rhs\n        for term in Add.make_args(expr):\n            coeff, elements = ([], {})\n            for factor in Mul.make_args(term):\n                if not _not_a_coeff(factor) and (factor.is_Number or _is_coeff(factor)):\n                    coeff.append(factor)\n                else:\n                    if opt.series is False:\n                        base, exp = decompose_power(factor)\n                        if exp < 0:\n                            exp, base = (-exp, Pow(base, -S.One))\n                    else:\n                        base, exp = decompose_power_rat(factor)\n                    elements[base] = elements.setdefault(base, 0) + exp\n                    gens.add(base)\n            terms.append((coeff, elements))\n        reprs.append(terms)\n    gens = _sort_gens(gens, opt=opt)\n    k, indices = (len(gens), {})\n    for i, g in enumerate(gens):\n        indices[g] = i\n    polys = []\n    for terms in reprs:\n        poly = {}\n        for coeff, term in terms:\n            monom = [0] * k\n            for base, exp in term.items():\n                monom[indices[base]] = exp\n            monom = tuple(monom)\n            if monom in poly:\n                poly[monom] += Mul(*coeff)\n            else:\n                poly[monom] = Mul(*coeff)\n        polys.append(poly)\n    return (polys, tuple(gens))",
    ".sympy.core.basic.py@@Basic._do_eq_sympify": "def _do_eq_sympify(self, other):\n    for superclass in type(other).__mro__:\n        conv = _external_converter.get(superclass)\n        if conv is not None:\n            return self == conv(other)\n    if hasattr(other, '_sympy_'):\n        return self == other._sympy_()\n    return NotImplemented",
    ".sympy.polys.polyutils.py@@_is_coeff": "def _is_coeff(factor):\n    return factor.is_number",
    ".sympy.polys.polyoptions.py@@Series.default": "def default(cls):\n    return False",
    ".sympy.core.exprtools.py@@decompose_power": "def decompose_power(expr: Expr) -> tTuple[Expr, int]:\n    base, exp = expr.as_base_exp()\n    if exp.is_Number:\n        if exp.is_Rational:\n            if not exp.is_Integer:\n                base = Pow(base, Rational(1, exp.q))\n            e = exp.p\n        else:\n            base, e = (expr, 1)\n    else:\n        exp, tail = exp.as_coeff_Mul(rational=True)\n        if exp is S.NegativeOne:\n            base, e = (Pow(base, tail), -1)\n        elif exp is not S.One:\n            tail = _keep_coeff(Rational(1, exp.q), tail)\n            base, e = (Pow(base, tail), exp.p)\n        else:\n            base, e = (expr, 1)\n    return (base, e)",
    ".sympy.core.expr.py@@Expr.as_base_exp": "def as_base_exp(self) -> tTuple['Expr', 'Expr']:\n    return (self, S.One)",
    ".sympy.polys.polyutils.py@@_sort_gens": "def _sort_gens(gens, **args):\n    opt = build_options(args)\n    gens_order, wrt = ({}, None)\n    if opt is not None:\n        gens_order, wrt = ({}, opt.wrt)\n        for i, gen in enumerate(opt.sort):\n            gens_order[gen] = i + 1\n\n    def order_key(gen):\n        gen = str(gen)\n        if wrt is not None:\n            try:\n                return (-len(wrt) + wrt.index(gen), gen, 0)\n            except ValueError:\n                pass\n        name, index = _re_gen.match(gen).groups()\n        if index:\n            index = int(index)\n        else:\n            index = 0\n        try:\n            return (gens_order[name], name, index)\n        except KeyError:\n            pass\n        try:\n            return (_gens_order[name], name, index)\n        except KeyError:\n            pass\n        return (_max_order, name, index)\n    try:\n        gens = sorted(gens, key=order_key)\n    except TypeError:\n        pass\n    return tuple(gens)",
    ".sympy.polys.polyoptions.py@@Sort.default": "def default(cls):\n    return []",
    ".sympy.polys.polyutils.py@@order_key": "def order_key(gen):\n    gen = str(gen)\n    if wrt is not None:\n        try:\n            return (-len(wrt) + wrt.index(gen), gen, 0)\n        except ValueError:\n            pass\n    name, index = _re_gen.match(gen).groups()\n    if index:\n        index = int(index)\n    else:\n        index = 0\n    try:\n        return (gens_order[name], name, index)\n    except KeyError:\n        pass\n    try:\n        return (_gens_order[name], name, index)\n    except KeyError:\n        pass\n    return (_max_order, name, index)",
    ".sympy.core._print_helpers.py@@Printable.__str__": "def __str__(self):\n    from sympy.printing.str import sstr\n    return sstr(self, order=None)",
    ".sympy.printing.printer.py@@_PrintFunction.__call__": "def __call__(self, *args, **kwargs):\n    return self.__wrapped__(*args, **kwargs)",
    ".sympy.printing.str.py@@sstr": "def sstr(expr, **settings):\n    p = StrPrinter(settings)\n    s = p.doprint(expr)\n    return s",
    ".sympy.printing.printer.py@@Printer.__init__": "def __init__(self, settings=None):\n    self._str = str\n    self._settings = self._get_initial_settings()\n    self._context = dict()\n    if settings is not None:\n        self._settings.update(settings)\n        if len(self._settings) > len(self._default_settings):\n            for key in self._settings:\n                if key not in self._default_settings:\n                    raise TypeError(\"Unknown setting '%s'.\" % key)\n    self._print_level = 0",
    ".sympy.printing.printer.py@@Printer._get_initial_settings": "def _get_initial_settings(cls):\n    settings = cls._default_settings.copy()\n    for key, val in cls._global_settings.items():\n        if key in cls._default_settings:\n            settings[key] = val\n    return settings",
    ".sympy.printing.printer.py@@Printer.doprint": "def doprint(self, expr):\n    return self._str(self._print(expr))",
    ".sympy.printing.printer.py@@Printer._print": "def _print(self, expr, **kwargs):\n    self._print_level += 1\n    try:\n        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):\n            return getattr(expr, self.printmethod)(self, **kwargs)\n        classes = type(expr).__mro__\n        if AppliedUndef in classes:\n            classes = classes[classes.index(AppliedUndef):]\n        if UndefinedFunction in classes:\n            classes = classes[classes.index(UndefinedFunction):]\n        if Function in classes:\n            i = classes.index(Function)\n            classes = tuple((c for c in classes[:i] if c.__name__ == classes[0].__name__ or c.__name__.endswith('Base'))) + classes[i:]\n        for cls in classes:\n            printmethodname = '_print_' + cls.__name__\n            printmethod = getattr(self, printmethodname, None)\n            if printmethod is not None:\n                return printmethod(expr, **kwargs)\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1",
    ".sympy.printing.str.py@@StrPrinter._print_Symbol": "def _print_Symbol(self, expr):\n    return expr.name",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, evaluate=None, _sympify=True):\n    if _sympify:\n        args = list(map(_sympify_, args))\n    typ = cls._args_type\n    if typ is not None:\n        from .relational import Relational\n        if any((isinstance(arg, Relational) for arg in args)):\n            raise TypeError('Relational cannot be used in %s' % cls.__name__)\n        for arg in args:\n            if not isinstance(arg, typ):\n                sympy_deprecation_warning(f'\\n\\nUsing non-Expr arguments in {cls.__name__} is deprecated (in this case, one of\\nthe arguments has type {type(arg).__name__!r}).\\n\\nIf you really did intend to use a multiplication or addition operation with\\nthis object, use the * or + operator instead.\\n\\n                        ', deprecated_since_version='1.7', active_deprecations_target='non-expr-args-deprecated', stacklevel=4)\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if not evaluate:\n        obj = cls._from_args(args)\n        obj = cls._exec_constructor_postprocessors(obj)\n        return obj\n    args = [a for a in args if a is not cls.identity]\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if order_symbols is not None:\n        from sympy.series.order import Order\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.polys.polyoptions.py@@Options.clone": "def clone(self, updates={}):\n    obj = dict.__new__(self.__class__)\n    for option, value in self.items():\n        obj[option] = value\n    for option, value in updates.items():\n        obj[option] = value\n    return obj",
    ".sympy.polys.polytools.py@@Poly._from_dict": "def _from_dict(cls, rep, opt):\n    gens = opt.gens\n    if not gens:\n        raise GeneratorsNeeded(\"Cannot initialize from 'dict' without generators\")\n    level = len(gens) - 1\n    domain = opt.domain\n    if domain is None:\n        domain, rep = construct_domain(rep, opt=opt)\n    else:\n        for monom, coeff in rep.items():\n            rep[monom] = domain.convert(coeff)\n    return cls.new(DMP.from_dict(rep, level, domain), *gens)",
    ".sympy.polys.polyclasses.py@@DMP.from_dict": "def from_dict(cls, rep, lev, dom):\n    return cls(dmp_from_dict(rep, lev, dom), dom, lev)",
    ".sympy.polys.densebasic.py@@dmp_from_dict": "def dmp_from_dict(f, u, K):\n    if not u:\n        return dup_from_dict(f, K)\n    if not f:\n        return dmp_zero(u)\n    coeffs = {}\n    for monom, coeff in f.items():\n        head, tail = (monom[0], monom[1:])\n        if head in coeffs:\n            coeffs[head][tail] = coeff\n        else:\n            coeffs[head] = {tail: coeff}\n    n, v, h = (max(coeffs.keys()), u - 1, [])\n    for k in range(n, -1, -1):\n        coeff = coeffs.get(k)\n        if coeff is not None:\n            h.append(dmp_from_dict(coeff, v, K))\n        else:\n            h.append(dmp_zero(v))\n    return dmp_strip(h, u)",
    ".sympy.polys.densebasic.py@@dup_from_dict": "def dup_from_dict(f, K):\n    if not f:\n        return []\n    n, h = (max(f.keys()), [])\n    if isinstance(n, int):\n        for k in range(n, -1, -1):\n            h.append(f.get(k, K.zero))\n    else:\n        n, = n\n        for k in range(n, -1, -1):\n            h.append(f.get((k,), K.zero))\n    return dup_strip(h)",
    ".sympy.polys.densebasic.py@@dup_strip": "def dup_strip(f):\n    if not f or f[0]:\n        return f\n    i = 0\n    for cf in f:\n        if cf:\n            break\n        else:\n            i += 1\n    return f[i:]",
    ".sympy.polys.polyclasses.py@@DMP.__init__": "def __init__(self, rep, dom, lev=None, ring=None):\n    if lev is not None:\n        if type(rep) is dict:\n            rep = dmp_from_dict(rep, lev, dom)\n        elif not isinstance(rep, list):\n            rep = dmp_ground(dom.convert(rep), lev)\n    else:\n        rep, lev = dmp_validate(rep)\n    self.rep = rep\n    self.lev = lev\n    self.dom = dom\n    self.ring = ring",
    ".sympy.polys.polytools.py@@Poly.new": "def new(cls, rep, *gens):\n    if not isinstance(rep, DMP):\n        raise PolynomialError('invalid polynomial representation: %s' % rep)\n    elif rep.lev != len(gens) - 1:\n        raise PolynomialError('invalid arguments: %s, %s' % (rep, gens))\n    obj = Basic.__new__(cls)\n    obj.rep = rep\n    obj.gens = gens\n    return obj",
    ".sympy.polys.polytools.py@@Poly.total_degree": "def total_degree(f):\n    if hasattr(f.rep, 'total_degree'):\n        return f.rep.total_degree()\n    else:\n        raise OperationNotSupported(f, 'total_degree')",
    ".sympy.polys.polyclasses.py@@DMP.total_degree": "def total_degree(f):\n    return max((sum(m) for m in f.monoms()))",
    ".sympy.polys.polyclasses.py@@DMP.monoms": "def monoms(f, order=None):\n    return [m for m, _ in dmp_list_terms(f.rep, f.lev, f.dom, order=order)]",
    ".sympy.polys.densebasic.py@@dmp_list_terms": "def dmp_list_terms(f, u, K, order=None):\n\n    def sort(terms, O):\n        return sorted(terms, key=lambda term: O(term[0]), reverse=True)\n    terms = _rec_list_terms(f, u, ())\n    if not terms:\n        return [((0,) * (u + 1), K.zero)]\n    if order is None:\n        return terms\n    else:\n        return sort(terms, monomial_key(order))",
    ".sympy.polys.densebasic.py@@_rec_list_terms": "def _rec_list_terms(g, v, monom):\n    d, terms = (dmp_degree(g, v), [])\n    if not v:\n        for i, c in enumerate(g):\n            if not c:\n                continue\n            terms.append((monom + (d - i,), c))\n    else:\n        w = v - 1\n        for i, c in enumerate(g):\n            terms.extend(_rec_list_terms(c, w, monom + (d - i,)))\n    return terms",
    ".sympy.polys.densebasic.py@@dmp_degree": "def dmp_degree(f, u):\n    if dmp_zero_p(f, u):\n        return -oo\n    else:\n        return len(f) - 1",
    ".sympy.polys.densebasic.py@@dmp_zero_p": "def dmp_zero_p(f, u):\n    while u:\n        if len(f) != 1:\n            return False\n        f = f[0]\n        u -= 1\n    return not f",
    ".sympy.core.expr.py@@Expr.is_number": "def is_number(self):\n    return all((obj.is_number for obj in self.args))",
    ".sympy.core.mul.py@@Mul._eval_expand_mul": "def _eval_expand_mul(self, **hints):\n    from sympy.simplify.radsimp import fraction\n    expr = self\n    n, d = fraction(expr)\n    if d.is_Mul:\n        n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i for i in (n, d)]\n    expr = n / d\n    if not expr.is_Mul:\n        return expr\n    plain, sums, rewrite = ([], [], False)\n    for factor in expr.args:\n        if factor.is_Add:\n            sums.append(factor)\n            rewrite = True\n        elif factor.is_commutative:\n            plain.append(factor)\n        else:\n            sums.append(Basic(factor))\n    if not rewrite:\n        return expr\n    else:\n        plain = self.func(*plain)\n        if sums:\n            deep = hints.get('deep', False)\n            terms = self.func._expandsums(sums)\n            args = []\n            for term in terms:\n                t = self.func(plain, term)\n                if t.is_Mul and any((a.is_Add for a in t.args)) and deep:\n                    t = t._eval_expand_mul()\n                args.append(t)\n            return Add(*args)\n        else:\n            return plain",
    ".sympy.simplify.radsimp.py@@fraction": "def fraction(expr, exact=False):\n    expr = sympify(expr)\n    numer, denom = ([], [])\n    for term in Mul.make_args(expr):\n        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):\n            b, ex = term.as_base_exp()\n            if ex.is_negative:\n                if ex is S.NegativeOne:\n                    denom.append(b)\n                elif exact:\n                    if ex.is_constant():\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n            elif ex.is_positive:\n                numer.append(term)\n            elif not exact and ex.is_Mul:\n                n, d = term.as_numer_denom()\n                if n != 1:\n                    numer.append(n)\n                denom.append(d)\n            else:\n                numer.append(term)\n        elif term.is_Rational and (not term.is_Integer):\n            if term.p != 1:\n                numer.append(term.p)\n            denom.append(term.q)\n        else:\n            numer.append(term)\n    return (Mul(*numer, evaluate=not exact), Mul(*denom, evaluate=not exact))",
    ".sympy.functions.elementary.exponential.py@@ExpMeta.__instancecheck__": "def __instancecheck__(cls, instance):\n    if exp in instance.__class__.__mro__:\n        return True\n    return isinstance(instance, Pow) and instance.base is S.Exp1",
    ".sympy.core.mul.py@@Mul.flatten": "def flatten(cls, seq):\n    from sympy.calculus.accumulationbounds import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n            seq = [a, b]\n        assert a is not S.One\n        if not a.is_zero and a.is_Rational:\n            r, b = b.as_coeff_Mul()\n            if b.is_Add:\n                if r is not S.One:\n                    ar = a * r\n                    if ar is S.One:\n                        arb = b\n                    else:\n                        arb = cls(a * r, b, evaluate=False)\n                    rv = ([arb], [], None)\n                elif global_parameters.distribute and b.is_commutative:\n                    newb = Add(*[_keep_coeff(a, bi) for bi in b.args])\n                    rv = ([newb], [], None)\n        if rv:\n            return rv\n    c_part = []\n    nc_part = []\n    nc_seq = []\n    coeff = S.One\n    c_powers = []\n    num_exp = []\n    neg1e = S.Zero\n    pnum_rat = {}\n    order_symbols = None\n    for o in seq:\n        if o.is_Order:\n            o, order_symbols = o.as_expr_variables(order_symbols)\n        if o.is_Mul:\n            if o.is_commutative:\n                seq.extend(o.args)\n            else:\n                for q in o.args:\n                    if q.is_commutative:\n                        seq.append(q)\n                    else:\n                        nc_seq.append(q)\n                seq.append(NC_Marker)\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_zero):\n                return ([S.NaN], [], None)\n            elif coeff.is_Number or isinstance(coeff, AccumBounds):\n                coeff *= o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__mul__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if not coeff:\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o is S.ImaginaryUnit:\n            neg1e += S.Half\n            continue\n        elif o.is_commutative:\n            b, e = o.as_base_exp()\n            if o.is_Pow:\n                if b.is_Number:\n                    if e.is_Rational:\n                        if e.is_Integer:\n                            coeff *= Pow(b, e)\n                            continue\n                        elif e.is_negative:\n                            seq.append(Pow(b, e))\n                            continue\n                        elif b.is_negative:\n                            neg1e += e\n                            b = -b\n                        if b is not S.One:\n                            pnum_rat.setdefault(b, []).append(e)\n                        continue\n                    elif b.is_positive or e.is_integer:\n                        num_exp.append((b, e))\n                        continue\n            c_powers.append((b, e))\n        else:\n            if o is not NC_Marker:\n                nc_seq.append(o)\n            while nc_seq:\n                o = nc_seq.pop(0)\n                if not nc_part:\n                    nc_part.append(o)\n                    continue\n                o1 = nc_part.pop()\n                b1, e1 = o1.as_base_exp()\n                b2, e2 = o.as_base_exp()\n                new_exp = e1 + e2\n                if b1 == b2 and (not new_exp.is_Add):\n                    o12 = b1 ** new_exp\n                    if o12.is_commutative:\n                        seq.append(o12)\n                        continue\n                    else:\n                        nc_seq.insert(0, o12)\n                else:\n                    nc_part.append(o1)\n                    nc_part.append(o)\n\n    def _gather(c_powers):\n        common_b = {}\n        for b, e in c_powers:\n            co = e.as_coeff_Mul()\n            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n        for b, d in common_b.items():\n            for di, li in d.items():\n                d[di] = Add(*li)\n        new_c_powers = []\n        for b, e in common_b.items():\n            new_c_powers.extend([(b, c * t) for t, c in e.items()])\n        return new_c_powers\n    c_powers = _gather(c_powers)\n    num_exp = _gather(num_exp)\n    for i in range(2):\n        new_c_powers = []\n        changed = False\n        for b, e in c_powers:\n            if e.is_zero:\n                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):\n                    return ([S.NaN], [], None)\n                continue\n            if e is S.One:\n                if b.is_Number:\n                    coeff *= b\n                    continue\n                p = b\n            if e is not S.One:\n                p = Pow(b, e)\n                if p.is_Pow and (not b.is_Pow):\n                    bi = b\n                    b, e = p.as_base_exp()\n                    if b != bi:\n                        changed = True\n            c_part.append(p)\n            new_c_powers.append((b, e))\n        if changed and len({b for b, e in new_c_powers}) != len(new_c_powers):\n            c_part = []\n            c_powers = _gather(new_c_powers)\n        else:\n            break\n    inv_exp_dict = {}\n    for b, e in num_exp:\n        inv_exp_dict.setdefault(e, []).append(b)\n    for e, b in inv_exp_dict.items():\n        inv_exp_dict[e] = cls(*b)\n    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n    comb_e = {}\n    for b, e in pnum_rat.items():\n        comb_e.setdefault(Add(*e), []).append(b)\n    del pnum_rat\n    num_rat = []\n    for e, b in comb_e.items():\n        b = cls(*b)\n        if e.q == 1:\n            coeff *= Pow(b, e)\n            continue\n        if e.p > e.q:\n            e_i, ep = divmod(e.p, e.q)\n            coeff *= Pow(b, e_i)\n            e = Rational(ep, e.q)\n        num_rat.append((b, e))\n    del comb_e\n    pnew = defaultdict(list)\n    i = 0\n    while i < len(num_rat):\n        bi, ei = num_rat[i]\n        grow = []\n        for j in range(i + 1, len(num_rat)):\n            bj, ej = num_rat[j]\n            g = bi.gcd(bj)\n            if g is not S.One:\n                e = ei + ej\n                if e.q == 1:\n                    coeff *= Pow(g, e)\n                else:\n                    if e.p > e.q:\n                        e_i, ep = divmod(e.p, e.q)\n                        coeff *= Pow(g, e_i)\n                        e = Rational(ep, e.q)\n                    grow.append((g, e))\n                num_rat[j] = (bj / g, ej)\n                bi = bi / g\n                if bi is S.One:\n                    break\n        if bi is not S.One:\n            obj = Pow(bi, ei)\n            if obj.is_Number:\n                coeff *= obj\n            else:\n                for obj in Mul.make_args(obj):\n                    if obj.is_Number:\n                        coeff *= obj\n                    else:\n                        assert obj.is_Pow\n                        bi, ei = obj.args\n                        pnew[ei].append(bi)\n        num_rat.extend(grow)\n        i += 1\n    for e, b in pnew.items():\n        pnew[e] = cls(*b)\n    if neg1e:\n        p, q = neg1e.as_numer_denom()\n        n, p = divmod(p, q)\n        if n % 2:\n            coeff = -coeff\n        if q == 2:\n            c_part.append(S.ImaginaryUnit)\n        elif p:\n            neg1e = Rational(p, q)\n            for e, b in pnew.items():\n                if e == neg1e and b.is_positive:\n                    pnew[e] = -b\n                    break\n            else:\n                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n    c_part.extend([Pow(b, e) for e, b in pnew.items()])\n    if coeff in (S.Infinity, S.NegativeInfinity):\n\n        def _handle_for_oo(c_part, coeff_sign):\n            new_c_part = []\n            for t in c_part:\n                if t.is_extended_positive:\n                    continue\n                if t.is_extended_negative:\n                    coeff_sign *= -1\n                    continue\n                new_c_part.append(t)\n            return (new_c_part, coeff_sign)\n        c_part, coeff_sign = _handle_for_oo(c_part, 1)\n        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n        coeff *= coeff_sign\n    if coeff is S.ComplexInfinity:\n        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]\n        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]\n    elif coeff.is_zero:\n        if any((isinstance(c, MatrixExpr) for c in nc_part)):\n            return ([coeff], nc_part, order_symbols)\n        if any((c.is_finite == False for c in c_part)):\n            return ([S.NaN], [], order_symbols)\n        return ([coeff], [], order_symbols)\n    _new = []\n    for i in c_part:\n        if i.is_Number:\n            coeff *= i\n        else:\n            _new.append(i)\n    c_part = _new\n    _mulsort(c_part)\n    if coeff is not S.One:\n        c_part.insert(0, coeff)\n    if global_parameters.distribute and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add:\n        coeff = c_part[0]\n        c_part = [Add(*[coeff * f for f in c_part[1].args])]\n    return (c_part, nc_part, order_symbols)",
    ".sympy.core.mul.py@@Mul._gather": "def _gather(c_powers):\n    common_b = {}\n    for b, e in c_powers:\n        co = e.as_coeff_Mul()\n        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n    for b, d in common_b.items():\n        for di, li in d.items():\n            d[di] = Add(*li)\n    new_c_powers = []\n    for b, e in common_b.items():\n        new_c_powers.extend([(b, c * t) for t, c in e.items()])\n    return new_c_powers",
    ".sympy.core.numbers.py@@Rational.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (self, S.One)",
    ".sympy.core.numbers.py@@Zero.__bool__": "def __bool__(self):\n    return False",
    ".sympy.core.numbers.py@@Infinity.__eq__": "def __eq__(self, other):\n    return other is S.Infinity or other == float('inf')",
    ".sympy.core.numbers.py@@NegativeInfinity.__eq__": "def __eq__(self, other):\n    return other is S.NegativeInfinity or other == float('-inf')",
    ".sympy.core.mul.py@@_mulsort": "def _mulsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.basic.py@@Basic.compare": "def compare(self, other):\n    if self is other:\n        return 0\n    n1 = self.__class__\n    n2 = other.__class__\n    c = (n1 > n2) - (n1 < n2)\n    if c:\n        return c\n    st = self._hashable_content()\n    ot = other._hashable_content()\n    c = (len(st) > len(ot)) - (len(st) < len(ot))\n    if c:\n        return c\n    for l, r in zip(st, ot):\n        l = Basic(*l) if isinstance(l, frozenset) else l\n        r = Basic(*r) if isinstance(r, frozenset) else r\n        if isinstance(l, Basic):\n            c = l.compare(r)\n        else:\n            c = (l > r) - (l < r)\n        if c:\n            return c\n    return 0",
    ".sympy.core.core.py@@BasicMeta.__gt__": "def __gt__(cls, other):\n    if cls.__cmp__(other) == 1:\n        return True\n    return False",
    ".sympy.core.core.py@@BasicMeta.__cmp__": "def __cmp__(cls, other):\n    if not isinstance(other, BasicMeta):\n        return -1\n    n1 = cls.__name__\n    n2 = other.__name__\n    if n1 == n2:\n        return 0\n    UNKNOWN = len(ordering_of_classes) + 1\n    try:\n        i1 = ordering_of_classes.index(n1)\n    except ValueError:\n        i1 = UNKNOWN\n    try:\n        i2 = ordering_of_classes.index(n2)\n    except ValueError:\n        i2 = UNKNOWN\n    if i1 == UNKNOWN and i2 == UNKNOWN:\n        return (n1 > n2) - (n1 < n2)\n    return (i1 > i2) - (i1 < i2)",
    ".sympy.core.core.py@@BasicMeta.__lt__": "def __lt__(cls, other):\n    if cls.__cmp__(other) == -1:\n        return True\n    return False",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return {key: value for key, value in self._assumptions.items() if value is not None}",
    ".sympy.core.operations.py@@AssocOp._from_args": "def _from_args(cls, args, is_commutative=None):\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n    obj = super().__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and((a.is_commutative for a in args))\n    obj.is_commutative = is_commutative\n    return obj",
    ".sympy.core.basic.py@@Basic._exec_constructor_postprocessors": "def _exec_constructor_postprocessors(cls, obj):\n    clsname = obj.__class__.__name__\n    postprocessors = defaultdict(list)\n    for i in obj.args:\n        try:\n            postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)\n            for k, v in chain.from_iterable(postprocessor_mappings):\n                postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n        except TypeError:\n            pass\n    for f in postprocessors.get(clsname, []):\n        obj = f(obj)\n    return obj",
    ".sympy.core.decorators.py@@_SympifyWrapper._func": "def _func(self, other):\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    ".sympy.core.decorators.py@@binary_op_wrapper": "def binary_op_wrapper(self, other):\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:\n            f = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    ".sympy.core.expr.py@@Expr.__truediv__": "def __truediv__(self, other):\n    denom = Pow(other, S.NegativeOne)\n    if self is S.One:\n        return denom\n    else:\n        return Mul(self, denom)",
    ".sympy.core.power.py@@Pow.__new__": "def __new__(cls, b, e, evaluate=None):\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    b = _sympify(b)\n    e = _sympify(e)\n    from .relational import Relational\n    if isinstance(b, Relational) or isinstance(e, Relational):\n        raise TypeError('Relational cannot be used in Pow')\n    for arg in [b, e]:\n        if not isinstance(arg, Expr):\n            sympy_deprecation_warning(f'\\nUsing non-Expr arguments in Pow is deprecated (in this case, one of the\\narguments is of type {type(arg).__name__!r}).\\n\\nIf you really did intend to construct a power with this base, use the **\\noperator instead.', deprecated_since_version='1.7', active_deprecations_target='non-expr-args-deprecated', stacklevel=4)\n    if evaluate:\n        if e is S.ComplexInfinity:\n            return S.NaN\n        if e is S.Infinity:\n            if is_gt(b, S.One):\n                return S.Infinity\n            if is_gt(b, S.NegativeOne) and is_lt(b, S.One):\n                return S.Zero\n            if is_lt(b, S.NegativeOne):\n                if b.is_finite:\n                    return S.ComplexInfinity\n                if b.is_finite is False:\n                    return S.NaN\n        if e is S.Zero:\n            return S.One\n        elif e is S.One:\n            return b\n        elif e == -1 and (not b):\n            return S.ComplexInfinity\n        elif e.__class__.__name__ == 'AccumulationBounds':\n            if b == S.Exp1:\n                from sympy.calculus.accumulationbounds import AccumBounds\n                return AccumBounds(Pow(b, e.min), Pow(b, e.max))\n        elif (e.is_Symbol and e.is_integer or e.is_Integer) and (b.is_number and b.is_Mul or b.is_Number) and b.could_extract_minus_sign():\n            if e.is_even:\n                b = -b\n            elif e.is_odd:\n                return -Pow(-b, e)\n        if S.NaN in (b, e):\n            return S.NaN\n        elif b is S.One:\n            if abs(e).is_infinite:\n                return S.NaN\n            return S.One\n        else:\n            from sympy.functions.elementary.exponential import exp_polar\n            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):\n                from .exprtools import factor_terms\n                from sympy.functions.elementary.exponential import log\n                from sympy.simplify.radsimp import fraction\n                c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n                num, den = fraction(ex)\n                if isinstance(den, log) and den.args[0] == b:\n                    return S.Exp1 ** (c * num)\n                elif den.is_Add:\n                    from sympy.functions.elementary.complexes import sign, im\n                    s = sign(im(b))\n                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):\n                        return S.Exp1 ** (c * num)\n            obj = b._eval_power(e)\n            if obj is not None:\n                return obj\n    obj = Expr.__new__(cls, b, e)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if not isinstance(obj, Pow):\n        return obj\n    obj.is_commutative = b.is_commutative and e.is_commutative\n    return obj",
    ".sympy.core.numbers.py@@Number.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    return bool(self.is_extended_negative)",
    ".sympy.core.numbers.py@@NegativeOne.__abs__": "def __abs__():\n    return S.One",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.expr.py@@Expr._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.polys.densebasic.py@@dmp_zero": "def dmp_zero(u):\n    r = []\n    for i in range(u):\n        r = [r]\n    return r",
    ".sympy.polys.densebasic.py@@dmp_strip": "def dmp_strip(f, u):\n    if not u:\n        return dup_strip(f)\n    if dmp_zero_p(f, u):\n        return f\n    i, v = (0, u - 1)\n    for c in f:\n        if not dmp_zero_p(c, v):\n            break\n        else:\n            i += 1\n    if i == len(f):\n        return dmp_zero(u)\n    else:\n        return f[i:]",
    ".sympy.core.numbers.py@@Infinity.__neg__": "def __neg__(self):\n    return S.NegativeInfinity",
    ".sympy.core.power.py@@Pow._eval_expand_multinomial": "def _eval_expand_multinomial(self, **hints):\n    base, exp = self.args\n    result = self\n    if exp.is_Rational and exp.p > 0 and base.is_Add:\n        if not exp.is_Integer:\n            n = Integer(exp.p // exp.q)\n            if not n:\n                return result\n            else:\n                radical, result = (self.func(base, exp - n), [])\n                expanded_base_n = self.func(base, n)\n                if expanded_base_n.is_Pow:\n                    expanded_base_n = expanded_base_n._eval_expand_multinomial()\n                for term in Add.make_args(expanded_base_n):\n                    result.append(term * radical)\n                return Add(*result)\n        n = int(exp)\n        if base.is_commutative:\n            order_terms, other_terms = ([], [])\n            for b in base.args:\n                if b.is_Order:\n                    order_terms.append(b)\n                else:\n                    other_terms.append(b)\n            if order_terms:\n                f = Add(*other_terms)\n                o = Add(*order_terms)\n                if n == 2:\n                    return expand_multinomial(f ** n, deep=False) + n * f * o\n                else:\n                    g = expand_multinomial(f ** (n - 1), deep=False)\n                    return expand_mul(f * g, deep=False) + n * g * o\n            if base.is_number:\n                a, b = base.as_real_imag()\n                if a.is_Rational and b.is_Rational:\n                    if not a.is_Integer:\n                        if not b.is_Integer:\n                            k = self.func(a.q * b.q, n)\n                            a, b = (a.p * b.q, a.q * b.p)\n                        else:\n                            k = self.func(a.q, n)\n                            a, b = (a.p, a.q * b)\n                    elif not b.is_Integer:\n                        k = self.func(b.q, n)\n                        a, b = (a * b.q, b.p)\n                    else:\n                        k = 1\n                    a, b, c, d = (int(a), int(b), 1, 0)\n                    while n:\n                        if n & 1:\n                            c, d = (a * c - b * d, b * c + a * d)\n                            n -= 1\n                        a, b = (a * a - b * b, 2 * a * b)\n                        n //= 2\n                    I = S.ImaginaryUnit\n                    if k == 1:\n                        return c + I * d\n                    else:\n                        return Integer(c) / k + I * d / k\n            p = other_terms\n            from sympy.ntheory.multinomial import multinomial_coefficients\n            from sympy.polys.polyutils import basic_from_dict\n            expansion_dict = multinomial_coefficients(len(p), n)\n            return basic_from_dict(expansion_dict, *p)\n        elif n == 2:\n            return Add(*[f * g for f in base.args for g in base.args])\n        else:\n            multi = (base ** (n - 1))._eval_expand_multinomial()\n            if multi.is_Add:\n                return Add(*[f * g for f in base.args for g in multi.args])\n            else:\n                return Add(*[f * multi for f in base.args])\n    elif exp.is_Rational and exp.p < 0 and base.is_Add and (abs(exp.p) > exp.q):\n        return 1 / self.func(base, -exp)._eval_expand_multinomial()\n    elif exp.is_Add and base.is_Number:\n        coeff, tail = (S.One, S.Zero)\n        for term in exp.args:\n            if term.is_Number:\n                coeff *= self.func(base, term)\n            else:\n                tail += term\n        return coeff * self.func(base, tail)\n    else:\n        return result",
    ".sympy.core.power.py@@Pow.as_base_exp": "def as_base_exp(self):\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and (b.q != 1):\n        return (Integer(b.q), -e)\n    return (b, e)",
    ".sympy.core.assumptions.py@@_ask": "def _ask(fact, obj):\n    assumptions = obj._assumptions\n    handler_map = obj._prop_handler\n    try:\n        assumptions._tell(fact, None)\n    except InconsistentAssumptions:\n        return assumptions[fact]\n    try:\n        evaluate = handler_map[fact]\n    except KeyError:\n        pass\n    else:\n        a = evaluate(obj)\n        if a is not None:\n            assumptions.deduce_all_facts(((fact, a),))\n            return a\n    prereq = list(_assume_rules.prereq[fact])\n    shuffle(prereq)\n    for pk in prereq:\n        if pk in assumptions:\n            continue\n        if pk in handler_map:\n            _ask(pk, obj)\n            ret_val = assumptions.get(fact)\n            if ret_val is not None:\n                return ret_val\n    return None",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.expr.py@@Expr._eval_is_negative": "def _eval_is_negative(self):\n    finite = self.is_finite\n    if finite is False:\n        return False\n    extended_negative = self.is_extended_negative\n    if finite is True:\n        return extended_negative\n    if extended_negative is False:\n        return False",
    ".sympy.core.expr.py@@Expr._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    return self._eval_is_extended_positive_negative(positive=False)",
    ".sympy.core.expr.py@@Expr._eval_is_extended_positive_negative": "def _eval_is_extended_positive_negative(self, positive):\n    from sympy.polys.numberfields import minimal_polynomial\n    from sympy.polys.polyerrors import NotAlgebraic\n    if self.is_number:\n        if self.is_extended_real is False:\n            return False\n        try:\n            n2 = self._eval_evalf(2)\n        except ValueError:\n            return None\n        if n2 is None:\n            return None\n        if getattr(n2, '_prec', 1) == 1:\n            return None\n        if n2 is S.NaN:\n            return None\n        f = self.evalf(2)\n        if f.is_Float:\n            match = (f, S.Zero)\n        else:\n            match = pure_complex(f)\n        if match is None:\n            return False\n        r, i = match\n        if not (i.is_Number and r.is_Number):\n            return False\n        if r._prec != 1 and i._prec != 1:\n            return bool(not i and (r > 0 if positive else r < 0))\n        elif r._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):\n            try:\n                if minimal_polynomial(self).is_Symbol:\n                    return False\n            except (NotAlgebraic, NotImplementedError):\n                pass",
    ".sympy.core.numbers.py@@Number._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Integer._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_int(self.p, prec, rnd)",
    ".sympy.core.evalf.py@@evalf_integer": "def evalf_integer(expr: 'Integer', prec: int, options: OPT_DICT) -> TMP_RES:\n    return (from_int(expr.p, prec), None, prec, None)",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.assumptions.py@@StdFactKB.copy": "def copy(self):\n    return self.__class__(self)",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    super().__init__(_assume_rules)\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.__init__": "def __init__(self, rules):\n    self.rules = rules",
    ".sympy.core.assumptions.py@@StdFactKB.generator": "def generator(self):\n    return self._generator.copy()",
    ".sympy.core.numbers.py@@Rational._eval_is_zero": "def _eval_is_zero(self):\n    return self.p == 0",
    ".sympy.core.expr.py@@Expr._eval_power": "def _eval_power(self, other):\n    return None",
    ".sympy.core.power.py@@Pow._eval_expand_power_base": "def _eval_expand_power_base(self, **hints):\n    force = hints.get('force', False)\n    b = self.base\n    e = self.exp\n    if not b.is_Mul:\n        return self\n    cargs, nc = b.args_cnc(split_1=False)\n    if nc:\n        nc = [i._eval_expand_power_base(**hints) if hasattr(i, '_eval_expand_power_base') else i for i in nc]\n        if e.is_Integer:\n            if e.is_positive:\n                rv = Mul(*nc * e)\n            else:\n                rv = Mul(*[i ** (-1) for i in nc[::-1]] * -e)\n            if cargs:\n                rv *= Mul(*cargs) ** e\n            return rv\n        if not cargs:\n            return self.func(Mul(*nc), e, evaluate=False)\n        nc = [Mul(*nc)]\n    other, maybe_real = sift(cargs, lambda x: x.is_extended_real is False, binary=True)\n\n    def pred(x):\n        if x is S.ImaginaryUnit:\n            return S.ImaginaryUnit\n        polar = x.is_polar\n        if polar:\n            return True\n        if polar is None:\n            return fuzzy_bool(x.is_extended_nonnegative)\n    sifted = sift(maybe_real, pred)\n    nonneg = sifted[True]\n    other += sifted[None]\n    neg = sifted[False]\n    imag = sifted[S.ImaginaryUnit]\n    if imag:\n        I = S.ImaginaryUnit\n        i = len(imag) % 4\n        if i == 0:\n            pass\n        elif i == 1:\n            other.append(I)\n        elif i == 2:\n            if neg:\n                nonn = -neg.pop()\n                if nonn is not S.One:\n                    nonneg.append(nonn)\n            else:\n                neg.append(S.NegativeOne)\n        else:\n            if neg:\n                nonn = -neg.pop()\n                if nonn is not S.One:\n                    nonneg.append(nonn)\n            else:\n                neg.append(S.NegativeOne)\n            other.append(I)\n        del imag\n    if force or e.is_integer:\n        cargs = nonneg + neg + other\n        other = nc\n    else:\n        assert not e.is_Integer\n        if len(neg) > 1:\n            o = S.One\n            if not other and neg[0].is_Number:\n                o *= neg.pop(0)\n            if len(neg) % 2:\n                o = -o\n            for n in neg:\n                nonneg.append(-n)\n            if o is not S.One:\n                other.append(o)\n        elif neg and other:\n            if neg[0].is_Number and neg[0] is not S.NegativeOne:\n                other.append(S.NegativeOne)\n                nonneg.append(-neg[0])\n            else:\n                other.extend(neg)\n        else:\n            other.extend(neg)\n        del neg\n        cargs = nonneg\n        other += nc\n    rv = S.One\n    if cargs:\n        if e.is_Rational:\n            npow, cargs = sift(cargs, lambda x: x.is_Pow and x.exp.is_Rational and x.base.is_number, binary=True)\n            rv = Mul(*[self.func(b.func(*b.args), e) for b in npow])\n        rv *= Mul(*[self.func(b, e, evaluate=False) for b in cargs])\n    if other:\n        rv *= self.func(Mul(*other), e, evaluate=False)\n    return rv",
    ".sympy.core.power.py@@Pow.base": "def base(self):\n    return self._args[0]",
    ".sympy.core.power.py@@Pow.exp": "def exp(self):\n    return self._args[1]",
    ".sympy.core.power.py@@Pow._eval_expand_power_exp": "def _eval_expand_power_exp(self, **hints):\n    b = self.base\n    e = self.exp\n    if b == S.Exp1:\n        from sympy.concrete.summations import Sum\n        if isinstance(e, Sum) and e.is_commutative:\n            from sympy.concrete.products import Product\n            return Product(self.func(b, e.function), *e.limits)\n    if e.is_Add and e.is_commutative:\n        expr = []\n        for x in e.args:\n            expr.append(self.func(b, x))\n        return Mul(*expr)\n    return self.func(b, e)",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.integrals.intpoly.py@@main_integrate": "def main_integrate(expr, facets, hp_params, max_degree=None):\n    dims = (x, y)\n    dim_length = len(dims)\n    result = {}\n    if max_degree:\n        grad_terms = [[0, 0, 0, 0]] + gradient_terms(max_degree)\n        for facet_count, hp in enumerate(hp_params):\n            a, b = (hp[0], hp[1])\n            x0 = facets[facet_count].points[0]\n            for i, monom in enumerate(grad_terms):\n                m, x_d, y_d, _ = monom\n                value = result.get(m, None)\n                degree = S.Zero\n                if b.is_zero:\n                    value_over_boundary = S.Zero\n                else:\n                    degree = x_d + y_d\n                    value_over_boundary = integration_reduction_dynamic(facets, facet_count, a, b, m, degree, dims, x_d, y_d, max_degree, x0, grad_terms, i)\n                monom[3] = value_over_boundary\n                if value is not None:\n                    result[m] += value_over_boundary * (b / norm(a)) / (dim_length + degree)\n                else:\n                    result[m] = value_over_boundary * (b / norm(a)) / (dim_length + degree)\n        return result\n    elif not isinstance(expr, list):\n        polynomials = decompose(expr)\n        return _polynomial_integrate(polynomials, facets, hp_params)\n    else:\n        return {e: _polynomial_integrate(decompose(e), facets, hp_params) for e in expr}",
    ".sympy.integrals.intpoly.py@@gradient_terms": "def gradient_terms(binomial_power=0, no_of_gens=2):\n    if no_of_gens == 2:\n        count = 0\n        terms = [None] * int((binomial_power ** 2 + 3 * binomial_power + 2) / 2)\n        for x_count in range(0, binomial_power + 1):\n            for y_count in range(0, binomial_power - x_count + 1):\n                terms[count] = [x ** x_count * y ** y_count, x_count, y_count, 0]\n                count += 1\n    else:\n        terms = [[[[x ** x_count * y ** y_count * z ** (z_count - y_count - x_count), x_count, y_count, z_count - y_count - x_count, z_count, x_count, z_count - y_count - x_count, 0] for y_count in range(z_count - x_count, -1, -1)] for x_count in range(0, z_count + 1)] for z_count in range(0, binomial_power + 1)]\n    return terms",
    ".sympy.core.expr.py@@Expr.__pow__": "def __pow__(self, other, mod=None):\n    if mod is None:\n        return self._pow(other)\n    try:\n        _self, other, mod = (as_int(self), as_int(other), as_int(mod))\n        if other >= 0:\n            return pow(_self, other, mod)\n        else:\n            from .numbers import mod_inverse\n            return mod_inverse(pow(_self, -other, mod), mod)\n    except ValueError:\n        power = self._pow(other)\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    ".sympy.core.expr.py@@Expr._pow": "def _pow(self, other):\n    return Pow(self, other)",
    ".sympy.core.numbers.py@@Number.__mul__": "def __mul__(self, other):\n    if isinstance(other, Number) and global_parameters.evaluate:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.Infinity\n            else:\n                return S.NegativeInfinity\n        elif other is S.NegativeInfinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.NegativeInfinity\n            else:\n                return S.Infinity\n    elif isinstance(other, Tuple):\n        return NotImplemented\n    return AtomicExpr.__mul__(self, other)",
    ".sympy.core.expr.py@@Expr.__mul__": "def __mul__(self, other):\n    return Mul(self, other)",
    ".sympy.core.power.py@@Pow._eval_is_zero": "def _eval_is_zero(self):\n    if self.base.is_zero:\n        if self.exp.is_extended_positive:\n            return True\n        elif self.exp.is_extended_nonpositive:\n            return False\n    elif self.base == S.Exp1:\n        return self.exp is S.NegativeInfinity\n    elif self.base.is_zero is False:\n        if self.base.is_finite and self.exp.is_finite:\n            return False\n        elif self.exp.is_negative:\n            return self.base.is_infinite\n        elif self.exp.is_nonnegative:\n            return False\n        elif self.exp.is_infinite and self.exp.is_extended_real:\n            if (1 - abs(self.base)).is_extended_positive:\n                return self.exp.is_extended_positive\n            elif (1 - abs(self.base)).is_extended_negative:\n                return self.exp.is_extended_negative\n    elif self.base.is_finite and self.exp.is_negative:\n        return False",
    ".sympy.core.power.py@@Pow._eval_is_rational": "def _eval_is_rational(self):\n    if self.exp.is_integer and self.base.is_rational and fuzzy_not(fuzzy_and([self.exp.is_negative, self.base.is_zero])):\n        return True\n    p = self.func(*self.as_base_exp())\n    if not p.is_Pow:\n        return p.is_rational\n    b, e = p.as_base_exp()\n    if e.is_Rational and b.is_Rational:\n        return False\n    if e.is_integer:\n        if b.is_rational:\n            if fuzzy_not(b.is_zero) or e.is_nonnegative:\n                return True\n            if b == e:\n                return True\n        elif b.is_irrational:\n            return e.is_zero\n    if b is S.Exp1:\n        if e.is_rational and e.is_nonzero:\n            return False",
    ".sympy.core.power.py@@Pow._eval_is_imaginary": "def _eval_is_imaginary(self):\n    if self.base.is_imaginary:\n        if self.exp.is_integer:\n            odd = self.exp.is_odd\n            if odd is not None:\n                return odd\n            return\n    if self.base == S.Exp1:\n        f = 2 * self.exp / (S.Pi * S.ImaginaryUnit)\n        if f.is_even:\n            return False\n        if f.is_odd:\n            return True\n        return None\n    if self.exp.is_imaginary:\n        from sympy.functions.elementary.exponential import log\n        imlog = log(self.base).is_imaginary\n        if imlog is not None:\n            return False\n    if self.base.is_extended_real and self.exp.is_extended_real:\n        if self.base.is_positive:\n            return False\n        else:\n            rat = self.exp.is_rational\n            if not rat:\n                return rat\n            if self.exp.is_integer:\n                return False\n            else:\n                half = (2 * self.exp).is_integer\n                if half:\n                    return self.base.is_negative\n                return half\n    if self.base.is_extended_real is False:\n        from sympy.functions.elementary.complexes import arg\n        i = arg(self.base) * self.exp / S.Pi\n        isodd = (2 * i).is_odd\n        if isodd is not None:\n            return isodd",
    ".sympy.core.power.py@@Pow._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    if self.base == self.exp:\n        if self.base.is_extended_nonnegative:\n            return True\n    elif self.base.is_positive:\n        if self.exp.is_real:\n            return True\n    elif self.base.is_extended_negative:\n        if self.exp.is_even:\n            return True\n        if self.exp.is_odd:\n            return False\n    elif self.base.is_zero:\n        if self.exp.is_extended_real:\n            return self.exp.is_zero\n    elif self.base.is_extended_nonpositive:\n        if self.exp.is_odd:\n            return False\n    elif self.base.is_imaginary:\n        if self.exp.is_integer:\n            m = self.exp % 4\n            if m.is_zero:\n                return True\n            if m.is_integer and m.is_zero is False:\n                return False\n        if self.exp.is_imaginary:\n            from sympy.functions.elementary.exponential import log\n            return log(self.base).is_imaginary",
    ".sympy.core.power.py@@Pow._eval_is_positive": "def _eval_is_positive(self):\n    ext_pos = Pow._eval_is_extended_positive(self)\n    if ext_pos is True:\n        return self.is_finite\n    return ext_pos",
    ".sympy.core.power.py@@Pow._eval_is_complex": "def _eval_is_complex(self):\n    if self.base == S.Exp1:\n        return fuzzy_or([self.exp.is_complex, self.exp.is_extended_negative])\n    if all((a.is_complex for a in self.args)) and self._eval_is_finite():\n        return True",
    ".sympy.core.power.py@@Pow._eval_is_integer": "def _eval_is_integer(self):\n    b, e = self.args\n    if b.is_rational:\n        if b.is_integer is False and e.is_positive:\n            return False\n    if b.is_integer and e.is_integer:\n        if b is S.NegativeOne:\n            return True\n        if e.is_nonnegative or e.is_positive:\n            return True\n    if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):\n        if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):\n            return False\n    if b.is_Number and e.is_Number:\n        check = self.func(*self.args)\n        return check.is_Integer\n    if e.is_negative and b.is_positive and (b - 1).is_positive:\n        return False\n    if e.is_negative and b.is_negative and (b + 1).is_negative:\n        return False",
    ".sympy.core.power.py@@Pow._eval_is_algebraic": "def _eval_is_algebraic(self):\n\n    def _is_one(expr):\n        try:\n            return (expr - 1).is_zero\n        except ValueError:\n            return False\n    if self.base.is_zero or _is_one(self.base):\n        return True\n    elif self.base is S.Exp1:\n        s = self.func(*self.args)\n        if s.func == self.func:\n            if self.exp.is_nonzero:\n                if self.exp.is_algebraic:\n                    return False\n                elif (self.exp / S.Pi).is_rational:\n                    return False\n                elif (self.exp / (S.ImaginaryUnit * S.Pi)).is_rational:\n                    return True\n        else:\n            return s.is_algebraic\n    elif self.exp.is_rational:\n        if self.base.is_algebraic is False:\n            return self.exp.is_zero\n        if self.base.is_zero is False:\n            if self.exp.is_nonzero:\n                return self.base.is_algebraic\n            elif self.base.is_algebraic:\n                return True\n        if self.exp.is_positive:\n            return self.base.is_algebraic\n    elif self.base.is_algebraic and self.exp.is_algebraic:\n        if fuzzy_not(self.base.is_zero) and fuzzy_not(_is_one(self.base)) or self.base.is_integer is False or self.base.is_irrational:\n            return self.exp.is_rational",
    ".sympy.core.power.py@@Pow._is_one": "def _is_one(expr):\n    try:\n        return (expr - 1).is_zero\n    except ValueError:\n        return False",
    ".sympy.core.expr.py@@Expr.__sub__": "def __sub__(self, other):\n    return Add(self, -other)",
    ".sympy.core.add.py@@Add.flatten": "def flatten(cls, seq):\n    from sympy.calculus.accumulationbounds import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    from sympy.tensor.tensor import TensExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        if a.is_Rational:\n            if b.is_Mul:\n                rv = ([a, b], [], None)\n        if rv:\n            if all((s.is_commutative for s in rv[0])):\n                return rv\n            return ([], rv[0], None)\n    terms = {}\n    coeff = S.Zero\n    order_factors = []\n    extra = []\n    for o in seq:\n        if o.is_Order:\n            if o.expr.is_zero:\n                continue\n            for o1 in order_factors:\n                if o1.contains(o):\n                    o = None\n                    break\n            if o is None:\n                continue\n            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]\n            continue\n        elif o.is_Number:\n            if (o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False)) and (not extra):\n                return ([S.NaN], [], None)\n            if coeff.is_Number or isinstance(coeff, AccumBounds):\n                coeff += o\n                if coeff is S.NaN and (not extra):\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__add__(coeff)\n            continue\n        elif isinstance(o, MatrixExpr):\n            extra.append(o)\n            continue\n        elif isinstance(o, TensExpr):\n            coeff = o.__add__(coeff) if coeff else o\n            continue\n        elif o is S.ComplexInfinity:\n            if coeff.is_finite is False and (not extra):\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o.is_Add:\n            seq.extend(o.args)\n            continue\n        elif o.is_Mul:\n            c, s = o.as_coeff_Mul()\n        elif o.is_Pow:\n            b, e = o.as_base_exp()\n            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):\n                seq.append(b ** e)\n                continue\n            c, s = (S.One, o)\n        else:\n            c = S.One\n            s = o\n        if s in terms:\n            terms[s] += c\n            if terms[s] is S.NaN and (not extra):\n                return ([S.NaN], [], None)\n        else:\n            terms[s] = c\n    newseq = []\n    noncommutative = False\n    for s, c in terms.items():\n        if c.is_zero:\n            continue\n        elif c is S.One:\n            newseq.append(s)\n        elif s.is_Mul:\n            cs = s._new_rawargs(*(c,) + s.args)\n            newseq.append(cs)\n        elif s.is_Add:\n            newseq.append(Mul(c, s, evaluate=False))\n        else:\n            newseq.append(Mul(c, s))\n        noncommutative = noncommutative or not s.is_commutative\n    if coeff is S.Infinity:\n        newseq = [f for f in newseq if not (f.is_extended_nonnegative or f.is_real)]\n    elif coeff is S.NegativeInfinity:\n        newseq = [f for f in newseq if not (f.is_extended_nonpositive or f.is_real)]\n    if coeff is S.ComplexInfinity:\n        newseq = [c for c in newseq if not (c.is_finite and c.is_extended_real is not None)]\n    if order_factors:\n        newseq2 = []\n        for t in newseq:\n            for o in order_factors:\n                if o.contains(t):\n                    t = None\n                    break\n            if t is not None:\n                newseq2.append(t)\n        newseq = newseq2 + order_factors\n        for o in order_factors:\n            if o.contains(coeff):\n                coeff = S.Zero\n                break\n    _addsort(newseq)\n    if coeff is not S.Zero:\n        newseq.insert(0, coeff)\n    if extra:\n        newseq += extra\n        noncommutative = True\n    if noncommutative:\n        return ([], newseq, None)\n    else:\n        return (newseq, [], None)",
    ".sympy.core.add.py@@_addsort": "def _addsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.add.py@@Add._eval_is_zero": "def _eval_is_zero(self):\n    if self.is_commutative is False:\n        return\n    nz = []\n    z = 0\n    im_or_z = False\n    im = 0\n    for a in self.args:\n        if a.is_extended_real:\n            if a.is_zero:\n                z += 1\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im += 1\n        elif (S.ImaginaryUnit * a).is_extended_real:\n            im_or_z = True\n        else:\n            return\n    if z == len(self.args):\n        return True\n    if len(nz) in [0, len(self.args)]:\n        return None\n    b = self.func(*nz)\n    if b.is_zero:\n        if not im_or_z:\n            if im == 0:\n                return True\n            elif im == 1:\n                return False\n    if b.is_zero is False:\n        return False",
    ".sympy.core.numbers.py@@Rational.as_numer_denom": "def as_numer_denom(self):\n    return (Integer(self.p), Integer(self.q))",
    ".sympy.core.numbers.py@@Integer.__divmod__": "def __divmod__(self, other):\n    if isinstance(other, Integer) and global_parameters.evaluate:\n        return Tuple(*divmod(self.p, other.p))\n    else:\n        return Number.__divmod__(self, other)",
    ".sympy.core.numbers.py@@Integer.__mod__": "def __mod__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p % other)\n        elif isinstance(other, Integer):\n            return Integer(self.p % other.p)\n        return Rational.__mod__(self, other)\n    return Rational.__mod__(self, other)",
    ".sympy.core.mul.py@@Mul._eval_is_extended_real": "def _eval_is_extended_real(self):\n    return self._eval_real_imag(True)",
    ".sympy.core.mul.py@@Mul._eval_real_imag": "def _eval_real_imag(self, real):\n    zero = False\n    t_not_re_im = None\n    for t in self.args:\n        if (t.is_complex or t.is_infinite) is False and t.is_extended_real is False:\n            return False\n        elif t.is_imaginary:\n            real = not real\n        elif t.is_extended_real:\n            if not zero:\n                z = t.is_zero\n                if not z and zero is False:\n                    zero = z\n                elif z:\n                    if all((a.is_finite for a in self.args)):\n                        return True\n                    return\n        elif t.is_extended_real is False:\n            if t_not_re_im:\n                return\n            t_not_re_im = t\n        elif t.is_imaginary is False:\n            if t_not_re_im:\n                return\n            t_not_re_im = t\n        else:\n            return\n    if t_not_re_im:\n        if t_not_re_im.is_extended_real is False:\n            if real:\n                return zero\n        if t_not_re_im.is_imaginary is False:\n            if not real:\n                return zero\n    elif zero is False:\n        return real\n    elif real:\n        return real",
    ".sympy.core.mul.py@@Mul._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all(((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others)):\n                return True\n            return\n        if a is None:\n            return\n    if all((x.is_real for x in self.args)):\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_imaginary": "def _eval_is_imaginary(self):\n    z = self.is_zero\n    if z:\n        return False\n    if self.is_finite is False:\n        return False\n    elif z is False and self.is_finite is True:\n        return self._eval_real_imag(False)",
    ".sympy.core.mul.py@@Mul._eval_is_zero": "def _eval_is_zero(self):\n    zero = infinite = False\n    for a in self.args:\n        z = a.is_zero\n        if z:\n            if infinite:\n                return\n            zero = True\n        else:\n            if not a.is_finite:\n                if zero:\n                    return\n                infinite = True\n            if zero is False and z is None:\n                zero = None\n    return zero",
    ".sympy.core.mul.py@@Mul._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    return self._eval_pos_neg(1)",
    ".sympy.core.mul.py@@Mul._eval_pos_neg": "def _eval_pos_neg(self, sign):\n    saw_NON = saw_NOT = False\n    for t in self.args:\n        if t.is_extended_positive:\n            continue\n        elif t.is_extended_negative:\n            sign = -sign\n        elif t.is_zero:\n            if all((a.is_finite for a in self.args)):\n                return False\n            return\n        elif t.is_extended_nonpositive:\n            sign = -sign\n            saw_NON = True\n        elif t.is_extended_nonnegative:\n            saw_NON = True\n        elif t.is_positive is False:\n            sign = -sign\n            if saw_NOT:\n                return\n            saw_NOT = True\n        elif t.is_negative is False:\n            if saw_NOT:\n                return\n            saw_NOT = True\n        else:\n            return\n    if sign == 1 and saw_NON is False and (saw_NOT is False):\n        return True\n    if sign < 0:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_composite": "def _eval_is_composite(self):\n    number_of_args = 0\n    for arg in self.args:\n        if not (arg.is_integer and arg.is_positive):\n            return None\n        if (arg - 1).is_positive:\n            number_of_args += 1\n    if number_of_args > 1:\n        return True",
    ".sympy.core.mul.py@@Mul._eval_is_integer": "def _eval_is_integer(self):\n    from sympy.ntheory.factor_ import trailing\n    is_rational = self._eval_is_rational()\n    if is_rational is False:\n        return False\n    numerators = []\n    denominators = []\n    unknown = False\n    for a in self.args:\n        hit = False\n        if a.is_integer:\n            if abs(a) is not S.One:\n                numerators.append(a)\n        elif a.is_Rational:\n            n, d = a.as_numer_denom()\n            if abs(n) is not S.One:\n                numerators.append(n)\n            if d is not S.One:\n                denominators.append(d)\n        elif a.is_Pow:\n            b, e = a.as_base_exp()\n            if not b.is_integer or not e.is_integer:\n                hit = unknown = True\n            if e.is_negative:\n                denominators.append(2 if a is S.Half else Pow(a, S.NegativeOne))\n            elif not hit:\n                assert not e.is_positive\n                assert not e.is_zero\n                return\n        else:\n            return\n    if not denominators and (not unknown):\n        return True\n    allodd = lambda x: all((i.is_odd for i in x))\n    alleven = lambda x: all((i.is_even for i in x))\n    anyeven = lambda x: any((i.is_even for i in x))\n    from .relational import is_gt\n    if not numerators and denominators and all((is_gt(_, S.One) for _ in denominators)):\n        return False\n    elif unknown:\n        return\n    elif allodd(numerators) and anyeven(denominators):\n        return False\n    elif anyeven(numerators) and denominators == [2]:\n        return True\n    elif alleven(numerators) and allodd(denominators) and (Mul(*denominators, evaluate=False) - 1).is_positive:\n        return False\n    if len(denominators) == 1:\n        d = denominators[0]\n        if d.is_Integer and d.is_even:\n            if (Add(*[i.as_base_exp()[1] for i in numerators if i.is_even]) - trailing(d.p)).is_nonnegative:\n                return True\n    if len(numerators) == 1:\n        n = numerators[0]\n        if n.is_Integer and n.is_even:\n            if (Add(*[i.as_base_exp()[1] for i in denominators if i.is_even]) - trailing(n.p)).is_positive:\n                return False",
    ".sympy.core.mul.py@@Mul._eval_is_rational": "def _eval_is_rational(self):\n    r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        return self.is_zero",
    ".sympy.core.logic.py@@_fuzzy_group": "def _fuzzy_group(args, quick_exit=False):\n    saw_other = False\n    for a in args:\n        if a is True:\n            continue\n        if a is None:\n            return\n        if quick_exit and saw_other:\n            return\n        saw_other = True\n    return not saw_other",
    ".sympy.core.mul.py@@Mul._eval_is_finite": "def _eval_is_finite(self):\n    if all((a.is_finite for a in self.args)):\n        return True\n    if any((a.is_infinite for a in self.args)):\n        if all((a.is_zero is False for a in self.args)):\n            return False",
    ".sympy.core.mul.py@@Mul._eval_is_complex": "def _eval_is_complex(self):\n    comp = _fuzzy_group((a.is_complex for a in self.args))\n    if comp is False:\n        if any((a.is_infinite for a in self.args)):\n            if any((a.is_zero is not False for a in self.args)):\n                return None\n            return False\n    return comp",
    ".sympy.core.mul.py@@Mul._eval_is_odd": "def _eval_is_odd(self):\n    is_integer = self.is_integer\n    if is_integer:\n        if self.is_zero:\n            return False\n        from sympy.simplify.radsimp import fraction\n        n, d = fraction(self)\n        if d.is_Integer and d.is_even:\n            from sympy.ntheory.factor_ import trailing\n            if (Add(*[i.as_base_exp()[1] for i in Mul.make_args(n) if i.is_even]) - trailing(d.p)).is_positive:\n                return False\n            return\n        r, acc = (True, 1)\n        for t in self.args:\n            if abs(t) is S.One:\n                continue\n            assert t.is_integer\n            if t.is_even:\n                return False\n            if r is False:\n                pass\n            elif acc != 1 and (acc + t).is_odd:\n                r = False\n            elif t.is_even is None:\n                r = None\n            acc = t\n        return r\n    return is_integer",
    ".sympy.core.mul.py@@Mul._eval_is_even": "def _eval_is_even(self):\n    is_integer = self.is_integer\n    if is_integer:\n        return fuzzy_not(self.is_odd)\n    from sympy.simplify.radsimp import fraction\n    n, d = fraction(self)\n    if n.is_Integer and n.is_even:\n        from sympy.ntheory.factor_ import trailing\n        if (Add(*[i.as_base_exp()[1] for i in Mul.make_args(d) if i.is_even]) - trailing(n.p)).is_nonnegative:\n            return False\n    return is_integer",
    ".sympy.core.mul.py@@Mul._eval_is_algebraic": "def _eval_is_algebraic(self):\n    r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        return self.is_zero",
    ".sympy.core.mul.py@@Mul._eval_is_infinite": "def _eval_is_infinite(self):\n    if any((a.is_infinite for a in self.args)):\n        if any((a.is_zero for a in self.args)):\n            return S.NaN.is_infinite\n        if any((a.is_zero is None for a in self.args)):\n            return None\n        return True",
    ".sympy.core.mul.py@@Mul._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    return self._eval_pos_neg(-1)",
    ".sympy.core.expr.py@@Expr._eval_is_positive": "def _eval_is_positive(self):\n    finite = self.is_finite\n    if finite is False:\n        return False\n    extended_positive = self.is_extended_positive\n    if finite is True:\n        return extended_positive\n    if extended_positive is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_hermitian": "def _eval_is_hermitian(self):\n    return self._eval_herm_antiherm(True)",
    ".sympy.core.mul.py@@Mul._eval_herm_antiherm": "def _eval_herm_antiherm(self, real):\n    one_nc = zero = one_neither = False\n    for t in self.args:\n        if not t.is_commutative:\n            if one_nc:\n                return\n            one_nc = True\n        if t.is_antihermitian:\n            real = not real\n        elif t.is_hermitian:\n            if not zero:\n                z = t.is_zero\n                if not z and zero is False:\n                    zero = z\n                elif z:\n                    if all((a.is_finite for a in self.args)):\n                        return True\n                    return\n        elif t.is_hermitian is False:\n            if one_neither:\n                return\n            one_neither = True\n        else:\n            return\n    if one_neither:\n        if real:\n            return zero\n    elif zero is False or real:\n        return real",
    ".sympy.core.mul.py@@Mul._eval_is_antihermitian": "def _eval_is_antihermitian(self):\n    z = self.is_zero\n    if z:\n        return False\n    elif z is False:\n        return self._eval_herm_antiherm(False)",
    ".sympy.core.add.py@@Add._eval_is_infinite": "def _eval_is_infinite(self):\n    sawinf = False\n    for a in self.args:\n        ainf = a.is_infinite\n        if ainf is None:\n            return None\n        elif ainf is True:\n            if sawinf is True:\n                return None\n            sawinf = True\n    return sawinf",
    ".sympy.core.add.py@@Add._eval_is_odd": "def _eval_is_odd(self):\n    l = [f for f in self.args if not f.is_even is True]\n    if not l:\n        return False\n    if l[0].is_odd:\n        return self._new_rawargs(*l[1:]).is_even",
    ".sympy.core.operations.py@@AssocOp._new_rawargs": "def _new_rawargs(self, *args, reeval=True, **kwargs):\n    if reeval and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)",
    ".sympy.core.add.py@@Add._eval_is_imaginary": "def _eval_is_imaginary(self):\n    nz = []\n    im_I = []\n    for a in self.args:\n        if a.is_extended_real:\n            if a.is_zero:\n                pass\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im_I.append(a * S.ImaginaryUnit)\n        elif (S.ImaginaryUnit * a).is_extended_real:\n            im_I.append(a * S.ImaginaryUnit)\n        else:\n            return\n    b = self.func(*nz)\n    if b.is_zero:\n        return fuzzy_not(self.func(*im_I).is_zero)\n    elif b.is_zero is False:\n        return False",
    ".sympy.core.add.py@@Add._eval_is_extended_nonnegative": "def _eval_is_extended_nonnegative(self):\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_extended_nonnegative:\n            from .exprtools import _monotonic_sign\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s != self and s.is_extended_nonnegative:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v != self and v.is_extended_nonnegative:\n                        return True",
    ".sympy.core.add.py@@Add.as_coeff_Add": "def as_coeff_Add(self, rational=False, deps=None):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number and (not rational) or coeff.is_Rational:\n        return (coeff, self._new_rawargs(*args))\n    return (S.Zero, self)",
    ".sympy.core.add.py@@Add._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    if self.is_number:\n        return super()._eval_is_extended_positive()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        from .exprtools import _monotonic_sign\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s != self and s.is_extended_positive and a.is_extended_nonnegative:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v != self and v.is_extended_positive:\n                    return True\n    pos = nonneg = nonpos = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        ispos = a.is_extended_positive\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((ispos, a.is_extended_nonnegative)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if ispos:\n            pos = True\n            continue\n        elif a.is_extended_nonnegative:\n            nonneg = True\n            continue\n        elif a.is_extended_nonpositive:\n            nonpos = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonpos and (not nonneg) and pos:\n        return True\n    elif not nonpos and pos:\n        return True\n    elif not pos and (not nonneg):\n        return False",
    ".sympy.core.exprtools.py@@_monotonic_sign": "def _monotonic_sign(self):\n    if not self.is_extended_real:\n        return\n    if (-self).is_Symbol:\n        rv = _monotonic_sign(-self)\n        return rv if rv is None else -rv\n    if not self.is_Add and self.as_numer_denom()[1].is_number:\n        s = self\n        if s.is_prime:\n            if s.is_odd:\n                return Integer(3)\n            else:\n                return Integer(2)\n        elif s.is_composite:\n            if s.is_odd:\n                return Integer(9)\n            else:\n                return Integer(4)\n        elif s.is_positive:\n            if s.is_even:\n                if s.is_prime is False:\n                    return Integer(4)\n                else:\n                    return Integer(2)\n            elif s.is_integer:\n                return S.One\n            else:\n                return _eps\n        elif s.is_extended_negative:\n            if s.is_even:\n                return Integer(-2)\n            elif s.is_integer:\n                return S.NegativeOne\n            else:\n                return -_eps\n        if s.is_zero or s.is_extended_nonpositive or s.is_extended_nonnegative:\n            return S.Zero\n        return None\n    free = self.free_symbols\n    if len(free) == 1:\n        if self.is_polynomial():\n            from sympy.polys.polytools import real_roots\n            from sympy.polys.polyroots import roots\n            from sympy.polys.polyerrors import PolynomialError\n            x = free.pop()\n            x0 = _monotonic_sign(x)\n            if x0 in (_eps, -_eps):\n                x0 = S.Zero\n            if x0 is not None:\n                d = self.diff(x)\n                if d.is_number:\n                    currentroots = []\n                else:\n                    try:\n                        currentroots = real_roots(d)\n                    except (PolynomialError, NotImplementedError):\n                        currentroots = [r for r in roots(d, x) if r.is_extended_real]\n                y = self.subs(x, x0)\n                if x.is_nonnegative and all(((r - x0).is_nonpositive for r in currentroots)):\n                    if y.is_nonnegative and d.is_positive:\n                        if y:\n                            return y if y.is_positive else Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_negative:\n                        if y:\n                            return y if y.is_negative else Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n                elif x.is_nonpositive and all(((r - x0).is_nonnegative for r in currentroots)):\n                    if y.is_nonnegative and d.is_negative:\n                        if y:\n                            return Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_positive:\n                        if y:\n                            return Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n        else:\n            n, d = self.as_numer_denom()\n            den = None\n            if n.is_number:\n                den = _monotonic_sign(d)\n            elif not d.is_number:\n                if _monotonic_sign(n) is not None:\n                    den = _monotonic_sign(d)\n            if den is not None and (den.is_positive or den.is_negative):\n                v = n * den\n                if v.is_positive:\n                    return Dummy('pos', positive=True)\n                elif v.is_nonnegative:\n                    return Dummy('nneg', nonnegative=True)\n                elif v.is_negative:\n                    return Dummy('neg', negative=True)\n                elif v.is_nonpositive:\n                    return Dummy('npos', nonpositive=True)\n        return None\n    c, a = self.as_coeff_Add()\n    v = None\n    if not a.is_polynomial():\n        n, d = a.as_numer_denom()\n        if not (n.is_number or d.is_number):\n            return\n        if (a.is_Mul or a.is_Pow) and a.is_rational and all((p.exp.is_Integer for p in a.atoms(Pow) if p.is_Pow)) and (a.is_positive or a.is_negative):\n            v = S.One\n            for ai in Mul.make_args(a):\n                if ai.is_number:\n                    v *= ai\n                    continue\n                reps = {}\n                for x in ai.free_symbols:\n                    reps[x] = _monotonic_sign(x)\n                    if reps[x] is None:\n                        return\n                v *= ai.subs(reps)\n    elif c:\n        if not any((p for p in a.atoms(Pow) if not p.is_number)) and (a.is_nonpositive or a.is_nonnegative):\n            free = list(a.free_symbols)\n            p = {}\n            for i in free:\n                v = _monotonic_sign(i)\n                if v is None:\n                    return\n                p[i] = v or (_eps if i.is_nonnegative else -_eps)\n            v = a.xreplace(p)\n    if v is not None:\n        rv = v + c\n        if v.is_nonnegative and rv.is_positive:\n            return rv.subs(_eps, 0)\n        if v.is_nonpositive and rv.is_negative:\n            return rv.subs(_eps, 0)",
    ".sympy.core.add.py@@Add._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    if self.is_number:\n        return super()._eval_is_extended_negative()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        from .exprtools import _monotonic_sign\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s != self and s.is_extended_negative and a.is_extended_nonpositive:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v != self and v.is_extended_negative:\n                    return True\n    neg = nonpos = nonneg = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        isneg = a.is_extended_negative\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((isneg, a.is_extended_nonpositive)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if isneg:\n            neg = True\n            continue\n        elif a.is_extended_nonpositive:\n            nonpos = True\n            continue\n        elif a.is_extended_nonnegative:\n            nonneg = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonneg and (not nonpos) and neg:\n        return True\n    elif not nonneg and neg:\n        return True\n    elif not neg and (not nonpos):\n        return False",
    ".sympy.core.add.py@@Add._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all((x.is_rational is True for x in others)):\n                return True\n            return None\n        if a is None:\n            return\n    return False",
    ".sympy.core.add.py@@Add._eval_is_extended_nonpositive": "def _eval_is_extended_nonpositive(self):\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_extended_nonpositive:\n            from .exprtools import _monotonic_sign\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s != self and s.is_extended_nonpositive:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v != self and v.is_extended_nonpositive:\n                        return True",
    ".sympy.core.numbers.py@@Rational._eval_is_positive": "def _eval_is_positive(self):\n    return self.p > 0",
    ".sympy.core.power.py@@Pow._eval_is_finite": "def _eval_is_finite(self):\n    if self.exp.is_negative:\n        if self.base.is_zero:\n            return False\n        if self.base.is_infinite or self.base.is_nonzero:\n            return True\n    c1 = self.base.is_finite\n    if c1 is None:\n        return\n    c2 = self.exp.is_finite\n    if c2 is None:\n        return\n    if c1 and c2:\n        if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):\n            return True",
    ".sympy.core.power.py@@Pow._eval_is_even": "def _eval_is_even(self):\n    if self.exp.is_integer and self.exp.is_positive:\n        return self.base.is_even",
    ".sympy.core.power.py@@Pow._eval_is_extended_real": "def _eval_is_extended_real(self):\n    if self.base is S.Exp1:\n        if self.exp.is_extended_real:\n            return True\n        elif self.exp.is_imaginary:\n            return (2 * S.ImaginaryUnit * self.exp / S.Pi).is_even\n    from sympy.functions.elementary.exponential import log, exp\n    real_b = self.base.is_extended_real\n    if real_b is None:\n        if self.base.func == exp and self.base.exp.is_imaginary:\n            return self.exp.is_imaginary\n        if self.base.func == Pow and self.base.base is S.Exp1 and self.base.exp.is_imaginary:\n            return self.exp.is_imaginary\n        return\n    real_e = self.exp.is_extended_real\n    if real_e is None:\n        return\n    if real_b and real_e:\n        if self.base.is_extended_positive:\n            return True\n        elif self.base.is_extended_nonnegative and self.exp.is_extended_nonnegative:\n            return True\n        elif self.exp.is_integer and self.base.is_extended_nonzero:\n            return True\n        elif self.exp.is_integer and self.exp.is_nonnegative:\n            return True\n        elif self.base.is_extended_negative:\n            if self.exp.is_Rational:\n                return False\n    if real_e and self.exp.is_extended_negative and (self.base.is_zero is False):\n        return Pow(self.base, -self.exp).is_extended_real\n    im_b = self.base.is_imaginary\n    im_e = self.exp.is_imaginary\n    if im_b:\n        if self.exp.is_integer:\n            if self.exp.is_even:\n                return True\n            elif self.exp.is_odd:\n                return False\n        elif im_e and log(self.base).is_imaginary:\n            return True\n        elif self.exp.is_Add:\n            c, a = self.exp.as_coeff_Add()\n            if c and c.is_Integer:\n                return Mul(self.base ** c, self.base ** a, evaluate=False).is_extended_real\n        elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):\n            if (self.exp / 2).is_integer is False:\n                return False\n    if real_b and im_e:\n        if self.base is S.NegativeOne:\n            return True\n        c = self.exp.coeff(S.ImaginaryUnit)\n        if c:\n            if self.base.is_rational and c.is_rational:\n                if self.base.is_nonzero and (self.base - 1).is_nonzero and c.is_nonzero:\n                    return False\n            ok = (c * log(self.base) / S.Pi).is_integer\n            if ok is not None:\n                return ok\n    if real_b is False:\n        from sympy.functions.elementary.complexes import arg\n        i = arg(self.base) * self.exp / S.Pi\n        if i.is_complex:\n            return i.is_integer",
    ".sympy.core.power.py@@Pow._eval_is_negative": "def _eval_is_negative(self):\n    ext_neg = Pow._eval_is_extended_negative(self)\n    if ext_neg is True:\n        return self.is_finite\n    return ext_neg",
    ".sympy.core.power.py@@Pow._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    if self.exp is S.Half:\n        if self.base.is_complex or self.base.is_extended_real:\n            return False\n    if self.base.is_extended_negative:\n        if self.exp.is_odd and self.base.is_finite:\n            return True\n        if self.exp.is_even:\n            return False\n    elif self.base.is_extended_positive:\n        if self.exp.is_extended_real:\n            return False\n    elif self.base.is_zero:\n        if self.exp.is_extended_real:\n            return False\n    elif self.base.is_extended_nonnegative:\n        if self.exp.is_extended_nonnegative:\n            return False\n    elif self.base.is_extended_nonpositive:\n        if self.exp.is_even:\n            return False\n    elif self.base.is_extended_real:\n        if self.exp.is_even:\n            return False",
    ".sympy.core.power.py@@Pow._eval_is_composite": "def _eval_is_composite(self):\n    if self.base.is_integer and self.exp.is_integer and ((self.base - 1).is_positive and (self.exp - 1).is_positive or ((self.base + 1).is_negative and self.exp.is_positive and self.exp.is_even)):\n        return True",
    ".sympy.core.power.py@@Pow._eval_is_prime": "def _eval_is_prime(self):\n    if self.base.is_integer and self.exp.is_integer and (self.exp - 1).is_positive:\n        return False",
    ".sympy.core.power.py@@Pow._eval_is_odd": "def _eval_is_odd(self):\n    if self.exp.is_integer:\n        if self.exp.is_positive:\n            return self.base.is_odd\n        elif self.exp.is_nonnegative and self.base.is_odd:\n            return True\n        elif self.base is S.NegativeOne:\n            return True",
    ".sympy.geometry.line.py@@LinearEntity.points": "def points(self):\n    return (self.p1, self.p2)",
    ".sympy.geometry.line.py@@LinearEntity.p1": "def p1(self):\n    return self.args[0]",
    ".sympy.geometry.line.py@@LinearEntity.p2": "def p2(self):\n    return self.args[1]",
    ".sympy.integrals.intpoly.py@@norm": "def norm(point):\n    half = S.Half\n    if isinstance(point, (list, tuple)):\n        return sum([coord ** 2 for coord in point]) ** half\n    elif isinstance(point, Point):\n        if isinstance(point, Point2D):\n            return (point.x ** 2 + point.y ** 2) ** half\n        else:\n            return (point.x ** 2 + point.y ** 2 + point.z) ** half\n    elif isinstance(point, dict):\n        return sum((i ** 2 for i in point.values())) ** half",
    ".sympy.core.numbers.py@@Integer._eval_is_odd": "def _eval_is_odd(self):\n    return bool(self.p % 2)",
    ".sympy.core.numbers.py@@NegativeOne.__neg__": "def __neg__():\n    return S.One",
    ".sympy.core.numbers.py@@Integer.__abs__": "def __abs__(self):\n    if self.p >= 0:\n        return self\n    else:\n        return Integer(-self.p)",
    ".sympy.core.numbers.py@@Zero._eval_power": "def _eval_power(self, expt):\n    if expt.is_extended_positive:\n        return self\n    if expt.is_extended_negative:\n        return S.ComplexInfinity\n    if expt.is_extended_real is False:\n        return S.NaN\n    coeff, terms = expt.as_coeff_Mul()\n    if coeff.is_negative:\n        return S.ComplexInfinity ** terms\n    if coeff is not S.One:\n        return self ** terms",
    ".sympy.core.expr.py@@Expr._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    return self._eval_is_extended_positive_negative(positive=True)",
    ".sympy.core.numbers.py@@Half.__abs__": "def __abs__():\n    return S.Half",
    ".sympy.integrals.intpoly.py@@integration_reduction_dynamic": "def integration_reduction_dynamic(facets, index, a, b, expr, degree, dims, x_index, y_index, max_index, x0, monomial_values, monom_index, vertices=None, hp_param=None):\n    value = S.Zero\n    m = len(facets)\n    if expr == S.Zero:\n        return expr\n    if len(dims) == 2:\n        if not expr.is_number:\n            _, x_degree, y_degree, _ = monomial_values[monom_index]\n            x_index = monom_index - max_index + x_index - 2 if x_degree > 0 else 0\n            y_index = monom_index - 1 if y_degree > 0 else 0\n            x_value, y_value = (monomial_values[x_index][3], monomial_values[y_index][3])\n            value += x_degree * x_value * x0[0] + y_degree * y_value * x0[1]\n        value += left_integral2D(m, index, facets, x0, expr, dims)\n    else:\n        z_index = max_index\n        if not expr.is_number:\n            x_degree, y_degree, z_degree = (y_index, z_index - x_index - y_index, x_index)\n            x_value = monomial_values[z_index - 1][y_index - 1][x_index][7] if x_degree > 0 else 0\n            y_value = monomial_values[z_index - 1][y_index][x_index][7] if y_degree > 0 else 0\n            z_value = monomial_values[z_index - 1][y_index][x_index - 1][7] if z_degree > 0 else 0\n            value += x_degree * x_value * x0[0] + y_degree * y_value * x0[1] + z_degree * z_value * x0[2]\n        value += left_integral3D(facets, index, expr, vertices, hp_param, degree)\n    return value / (len(dims) + degree - 1)",
    ".sympy.core.numbers.py@@Integer.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other * self.p)\n        elif isinstance(other, Rational):\n            return Rational(other.p * self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    ".sympy.integrals.intpoly.py@@left_integral2D": "def left_integral2D(m, index, facets, x0, expr, gens):\n    value = S.Zero\n    for j in range(0, m):\n        intersect = ()\n        if j in ((index - 1) % m, (index + 1) % m):\n            intersect = intersection(facets[index], facets[j], 'segment2D')\n        if intersect:\n            distance_origin = norm(tuple(map(lambda x, y: x - y, intersect, x0)))\n            if is_vertex(intersect):\n                if isinstance(expr, Expr):\n                    if len(gens) == 3:\n                        expr_dict = {gens[0]: intersect[0], gens[1]: intersect[1], gens[2]: intersect[2]}\n                    else:\n                        expr_dict = {gens[0]: intersect[0], gens[1]: intersect[1]}\n                    value += distance_origin * expr.subs(expr_dict)\n                else:\n                    value += distance_origin * expr\n    return value",
    ".sympy.integrals.intpoly.py@@intersection": "def intersection(geom_1, geom_2, intersection_type):\n    if intersection_type[:-2] == 'segment':\n        if intersection_type == 'segment2D':\n            x1, y1 = geom_1.points[0]\n            x2, y2 = geom_1.points[1]\n            x3, y3 = geom_2.points[0]\n            x4, y4 = geom_2.points[1]\n        elif intersection_type == 'segment3D':\n            x1, y1, z1 = geom_1.points[0]\n            x2, y2, z2 = geom_1.points[1]\n            x3, y3, z3 = geom_2.points[0]\n            x4, y4, z4 = geom_2.points[1]\n        denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if denom:\n            t1 = x1 * y2 - y1 * x2\n            t2 = x3 * y4 - x4 * y3\n            return (S(t1 * (x3 - x4) - t2 * (x1 - x2)) / denom, S(t1 * (y3 - y4) - t2 * (y1 - y2)) / denom)\n    if intersection_type[:-2] == 'plane':\n        if intersection_type == 'plane2D':\n            a1x, a1y = geom_1[0]\n            a2x, a2y = geom_2[0]\n            b1, b2 = (geom_1[1], geom_2[1])\n            denom = a1x * a2y - a2x * a1y\n            if denom:\n                return (S(b1 * a2y - b2 * a1y) / denom, S(b2 * a1x - b1 * a2x) / denom)",
    ".sympy.integrals.intpoly.py@@is_vertex": "def is_vertex(ent):\n    if isinstance(ent, tuple):\n        if len(ent) in [2, 3]:\n            return True\n    elif isinstance(ent, Point):\n        return True\n    return False",
    ".sympy.core.basic.py@@Basic.subs": "def subs(self, *args, **kwargs):\n    from .containers import Dict\n    from .symbol import Dummy, Symbol\n    from .numbers import _illegal\n    unordered = False\n    if len(args) == 1:\n        sequence = args[0]\n        if isinstance(sequence, set):\n            unordered = True\n        elif isinstance(sequence, (Dict, Mapping)):\n            unordered = True\n            sequence = sequence.items()\n        elif not iterable(sequence):\n            raise ValueError(filldedent('\\n               When a single argument is passed to subs\\n               it should be a dictionary of old: new pairs or an iterable\\n               of (old, new) tuples.'))\n    elif len(args) == 2:\n        sequence = [args]\n    else:\n        raise ValueError('subs accepts either 1 or 2 arguments')\n    sequence = list(sequence)\n    for i, s in enumerate(sequence):\n        if isinstance(s[0], str):\n            s = (Symbol(s[0]), s[1])\n        try:\n            s = [sympify(_, strict=not isinstance(_, (str, type))) for _ in s]\n        except SympifyError:\n            sequence[i] = None\n            continue\n        sequence[i] = None if _aresame(*s) else tuple(s)\n    sequence = list(filter(None, sequence))\n    simultaneous = kwargs.pop('simultaneous', False)\n    if unordered:\n        from .sorting import _nodes, default_sort_key\n        sequence = dict(sequence)\n        k = list(ordered(sequence, default=False, keys=(lambda x: -_nodes(x), default_sort_key)))\n        sequence = [(k, sequence[k]) for k in k]\n        if not simultaneous:\n            redo = []\n            for i in range(len(sequence)):\n                if sequence[i][1] in _illegal:\n                    redo.append(i)\n            for i in reversed(redo):\n                sequence.insert(0, sequence.pop(i))\n    if simultaneous:\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy('subs_m')\n        for old, new in sequence:\n            com = new.is_commutative\n            if com is None:\n                com = True\n            d = Dummy('subs_d', commutative=com)\n            rv = rv._subs(old, d * m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    ".sympy.core.basic.py@@_aresame": "def _aresame(a, b):\n    from .numbers import Number\n    from .function import AppliedUndef, UndefinedFunction as UndefFunc\n    if isinstance(a, Number) and isinstance(b, Number):\n        return a == b and a.__class__ == b.__class__\n    for i, j in zip_longest(_preorder_traversal(a), _preorder_traversal(b)):\n        if i != j or type(i) != type(j):\n            if isinstance(i, UndefFunc) and isinstance(j, UndefFunc) or (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef)):\n                if i.class_key() != j.class_key():\n                    return False\n            else:\n                return False\n    return True",
    ".sympy.core.sorting.py@@_nodes": "def _nodes(e):\n    from .basic import Basic\n    from .function import Derivative\n    if isinstance(e, Basic):\n        if isinstance(e, Derivative):\n            return _nodes(e.expr) + sum((i[1] if i[1].is_Number else _nodes(i[1]) for i in e.variable_count))\n        return _node_count(e)\n    elif iterable(e):\n        return 1 + sum((_nodes(ei) for ei in e))\n    elif isinstance(e, dict):\n        return 1 + sum((_nodes(k) + _nodes(v) for k, v in e.items()))\n    else:\n        return 1",
    ".sympy.core.sorting.py@@_node_count": "def _node_count(e):\n    if e.is_Float:\n        return 0.5\n    return 1 + sum(map(_node_count, e.args))",
    ".sympy.core.symbol.py@@Symbol.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (1, (self.name,)), S.One.sort_key(), S.One)",
    ".sympy.core.basic.py@@Atom.class_key": "def class_key(cls):\n    return (2, 0, cls.__name__)",
    ".sympy.core.numbers.py@@NaN.__eq__": "def __eq__(self, other):\n    return other is S.NaN",
    ".sympy.core.basic.py@@Basic._subs": "def _subs(self, old, new, **hints):\n\n    def fallback(self, old, new):\n        hit = False\n        args = list(self.args)\n        for i, arg in enumerate(args):\n            if not hasattr(arg, '_eval_subs'):\n                continue\n            arg = arg._subs(old, new, **hints)\n            if not _aresame(arg, args[i]):\n                hit = True\n                args[i] = arg\n        if hit:\n            rv = self.func(*args)\n            hack2 = hints.get('hack2', False)\n            if hack2 and self.is_Mul and (not rv.is_Mul):\n                coeff = S.One\n                nonnumber = []\n                for i in args:\n                    if i.is_Number:\n                        coeff *= i\n                    else:\n                        nonnumber.append(i)\n                nonnumber = self.func(*nonnumber)\n                if coeff is S.One:\n                    return nonnumber\n                else:\n                    return self.func(coeff, nonnumber, evaluate=False)\n            return rv\n        return self\n    if _aresame(self, old):\n        return new\n    rv = self._eval_subs(old, new)\n    if rv is None:\n        rv = fallback(self, old, new)\n    return rv",
    ".sympy.core.numbers.py@@Number._eval_subs": "def _eval_subs(self, old, new):\n    if old == -self:\n        return -new\n    return self",
    ".sympy.core.symbol.py@@Symbol._eval_subs": "def _eval_subs(self, old, new):\n    if old.is_Pow:\n        from sympy.core.power import Pow\n        return Pow(self, S.One, evaluate=False)._eval_subs(old, new)",
    ".sympy.core.basic.py@@Basic.fallback": "def fallback(self, old, new):\n    hit = False\n    args = list(self.args)\n    for i, arg in enumerate(args):\n        if not hasattr(arg, '_eval_subs'):\n            continue\n        arg = arg._subs(old, new, **hints)\n        if not _aresame(arg, args[i]):\n            hit = True\n            args[i] = arg\n    if hit:\n        rv = self.func(*args)\n        hack2 = hints.get('hack2', False)\n        if hack2 and self.is_Mul and (not rv.is_Mul):\n            coeff = S.One\n            nonnumber = []\n            for i in args:\n                if i.is_Number:\n                    coeff *= i\n                else:\n                    nonnumber.append(i)\n            nonnumber = self.func(*nonnumber)\n            if coeff is S.One:\n                return nonnumber\n            else:\n                return self.func(coeff, nonnumber, evaluate=False)\n        return rv\n    return self",
    ".sympy.core.power.py@@Pow._eval_subs": "def _eval_subs(self, old, new):\n    from sympy.calculus.accumulationbounds import AccumBounds\n    if isinstance(self.exp, AccumBounds):\n        b = self.base.subs(old, new)\n        e = self.exp.subs(old, new)\n        if isinstance(e, AccumBounds):\n            return e.__rpow__(b)\n        return self.func(b, e)\n    from sympy.functions.elementary.exponential import exp, log\n\n    def _check(ct1, ct2, old):\n        coeff1, terms1 = ct1\n        coeff2, terms2 = ct2\n        if terms1 == terms2:\n            if old.is_commutative:\n                pow = coeff1 / coeff2\n                try:\n                    as_int(pow, strict=False)\n                    combines = True\n                except ValueError:\n                    b, e = old.as_base_exp()\n                    combines = b.is_positive and e.is_real or (b.is_nonnegative and e.is_nonnegative)\n                return (combines, pow, None)\n            else:\n                if not isinstance(terms1, tuple):\n                    terms1 = (terms1,)\n                if not all((term.is_integer for term in terms1)):\n                    return (False, None, None)\n                try:\n                    pow, remainder = divmod(as_int(coeff1), as_int(coeff2))\n                    if pow < 0 and remainder != 0:\n                        pow += 1\n                        remainder -= as_int(coeff2)\n                    if remainder == 0:\n                        remainder_pow = None\n                    else:\n                        remainder_pow = Mul(remainder, *terms1)\n                    return (True, pow, remainder_pow)\n                except ValueError:\n                    pass\n        return (False, None, None)\n    if old == self.base or (old == exp and self.base == S.Exp1):\n        if new.is_Function and isinstance(new, Callable):\n            return new(self.exp._subs(old, new))\n        else:\n            return new ** self.exp._subs(old, new)\n    if isinstance(old, self.func) and self.exp == old.exp:\n        l = log(self.base, old.base)\n        if l.is_Number:\n            return Pow(new, l)\n    if isinstance(old, self.func) and self.base == old.base:\n        if self.exp.is_Add is False:\n            ct1 = self.exp.as_independent(Symbol, as_Add=False)\n            ct2 = old.exp.as_independent(Symbol, as_Add=False)\n            ok, pow, remainder_pow = _check(ct1, ct2, old)\n            if ok:\n                result = self.func(new, pow)\n                if remainder_pow is not None:\n                    result = Mul(result, Pow(old.base, remainder_pow))\n                return result\n        else:\n            oarg = old.exp\n            new_l = []\n            o_al = []\n            ct2 = oarg.as_coeff_mul()\n            for a in self.exp.args:\n                newa = a._subs(old, new)\n                ct1 = newa.as_coeff_mul()\n                ok, pow, remainder_pow = _check(ct1, ct2, old)\n                if ok:\n                    new_l.append(new ** pow)\n                    if remainder_pow is not None:\n                        o_al.append(remainder_pow)\n                    continue\n                elif not old.is_commutative and (not newa.is_integer):\n                    return\n                o_al.append(newa)\n            if new_l:\n                expo = Add(*o_al)\n                new_l.append(Pow(self.base, expo, evaluate=False) if expo != 1 else self.base)\n                return Mul(*new_l)\n    if (isinstance(old, exp) or (old.is_Pow and old.base is S.Exp1)) and self.exp.is_extended_real and self.base.is_positive:\n        ct1 = old.exp.as_independent(Symbol, as_Add=False)\n        ct2 = (self.exp * log(self.base)).as_independent(Symbol, as_Add=False)\n        ok, pow, remainder_pow = _check(ct1, ct2, old)\n        if ok:\n            result = self.func(new, pow)\n            if remainder_pow is not None:\n                result = Mul(result, Pow(old.base, remainder_pow))\n            return result",
    ".sympy.core.numbers.py@@Integer.__neg__": "def __neg__(self):\n    return Integer(-self.p)",
    ".sympy.core.mul.py@@Mul._eval_subs": "def _eval_subs(self, old, new):\n    from sympy.functions.elementary.complexes import sign\n    from sympy.ntheory.factor_ import multiplicity\n    from sympy.simplify.powsimp import powdenest\n    from sympy.simplify.radsimp import fraction\n    if not old.is_Mul:\n        return None\n    if old.args[0].is_Number and old.args[0] < 0:\n        if self.args[0].is_Number:\n            if self.args[0] < 0:\n                return self._subs(-old, -new)\n            return None\n\n    def base_exp(a):\n        from sympy.functions.elementary.exponential import exp\n        if a.is_Pow or isinstance(a, exp):\n            return a.as_base_exp()\n        return (a, S.One)\n\n    def breakup(eq):\n        c, nc = (defaultdict(int), list())\n        for a in Mul.make_args(eq):\n            a = powdenest(a)\n            b, e = base_exp(a)\n            if e is not S.One:\n                co, _ = e.as_coeff_mul()\n                b = Pow(b, e / co)\n                e = co\n            if a.is_commutative:\n                c[b] += e\n            else:\n                nc.append([b, e])\n        return (c, nc)\n\n    def rejoin(b, co):\n        b, e = base_exp(b)\n        return Pow(b, e * co)\n\n    def ndiv(a, b):\n        if not b.q % a.q or not a.q % b.q:\n            return int(a / b)\n        return 0\n    rv = None\n    n, d = fraction(self)\n    self2 = self\n    if d is not S.One:\n        self2 = n._subs(old, new) / d._subs(old, new)\n        if not self2.is_Mul:\n            return self2._subs(old, new)\n        if self2 != self:\n            rv = self2\n    co_self = self2.args[0]\n    co_old = old.args[0]\n    co_xmul = None\n    if co_old.is_Rational and co_self.is_Rational:\n        if co_old != co_self:\n            co_xmul = co_self.extract_multiplicatively(co_old)\n    elif co_old.is_Rational:\n        return rv\n    c, nc = breakup(self2)\n    old_c, old_nc = breakup(old)\n    if co_xmul and co_xmul.is_Rational and (abs(co_old) != 1):\n        mult = S(multiplicity(abs(co_old), co_self))\n        c.pop(co_self)\n        if co_old in c:\n            c[co_old] += mult\n        else:\n            c[co_old] = mult\n        co_residual = co_self / co_old ** mult\n    else:\n        co_residual = 1\n    ok = True\n    if len(old_nc) > len(nc):\n        ok = False\n    elif len(old_c) > len(c):\n        ok = False\n    elif {i[0] for i in old_nc}.difference({i[0] for i in nc}):\n        ok = False\n    elif set(old_c).difference(set(c)):\n        ok = False\n    elif any((sign(c[b]) != sign(old_c[b]) for b in old_c)):\n        ok = False\n    if not ok:\n        return rv\n    if not old_c:\n        cdid = None\n    else:\n        rat = []\n        for b, old_e in old_c.items():\n            c_e = c[b]\n            rat.append(ndiv(c_e, old_e))\n            if not rat[-1]:\n                return rv\n        cdid = min(rat)\n    if not old_nc:\n        ncdid = None\n        for i in range(len(nc)):\n            nc[i] = rejoin(*nc[i])\n    else:\n        ncdid = 0\n        take = len(old_nc)\n        limit = cdid or S.Infinity\n        failed = []\n        i = 0\n        while limit and i + take <= len(nc):\n            hit = False\n            rat = []\n            for j in range(take):\n                if nc[i + j][0] != old_nc[j][0]:\n                    break\n                elif j == 0:\n                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n                elif j == take - 1:\n                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n                elif nc[i + j][1] != old_nc[j][1]:\n                    break\n                else:\n                    rat.append(1)\n                j += 1\n            else:\n                ndo = min(rat)\n                if ndo:\n                    if take == 1:\n                        if cdid:\n                            ndo = min(cdid, ndo)\n                        nc[i] = Pow(new, ndo) * rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])\n                    else:\n                        ndo = 1\n                        l = rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])\n                        mid = new\n                        ir = i + take - 1\n                        r = (nc[ir][0], nc[ir][1] - ndo * old_nc[-1][1])\n                        if r[1]:\n                            if i + take < len(nc):\n                                nc[i:i + take] = [l * mid, r]\n                            else:\n                                r = rejoin(*r)\n                                nc[i:i + take] = [l * mid * r]\n                        else:\n                            nc[i:i + take] = [l * mid]\n                    limit -= ndo\n                    ncdid += ndo\n                    hit = True\n            if not hit:\n                failed.append(i)\n            i += 1\n        else:\n            if not ncdid:\n                return rv\n            failed.extend(range(i, len(nc)))\n            for i in failed:\n                nc[i] = rejoin(*nc[i]).subs(old, new)\n    if cdid is None:\n        do = ncdid\n    elif ncdid is None:\n        do = cdid\n    else:\n        do = min(ncdid, cdid)\n    margs = []\n    for b in c:\n        if b in old_c:\n            e = c[b] - old_c[b] * do\n            margs.append(rejoin(b, e))\n        else:\n            margs.append(rejoin(b.subs(old, new), c[b]))\n    if cdid and (not ncdid):\n        margs = [Pow(new, cdid)] + margs\n    return co_residual * self2.func(*margs) * self2.func(*nc)",
    ".sympy.core.numbers.py@@Rational.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(self.p + self.q * other.p, self.q, 1)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + self.q * other.p, self.q * other.q)\n        elif isinstance(other, Float):\n            return other + self\n        else:\n            return Number.__add__(self, other)\n    return Number.__add__(self, other)",
    ".sympy.simplify.simplify.py@@nsimplify": "def nsimplify(expr, constants=(), tolerance=None, full=False, rational=None, rational_conversion='base10'):\n    try:\n        return sympify(as_int(expr))\n    except (TypeError, ValueError):\n        pass\n    expr = sympify(expr).xreplace({Float('inf'): S.Infinity, Float('-inf'): S.NegativeInfinity})\n    if expr is S.Infinity or expr is S.NegativeInfinity:\n        return expr\n    if rational or expr.free_symbols:\n        return _real_to_rational(expr, tolerance, rational_conversion)\n    if tolerance is None:\n        tolerance = 10 ** (-min([15] + [mpmath.libmp.libmpf.prec_to_dps(n._prec) for n in expr.atoms(Float)]))\n    prec = 30\n    bprec = int(prec * 3.33)\n    constants_dict = {}\n    for constant in constants:\n        constant = sympify(constant)\n        v = constant.evalf(prec)\n        if not v.is_Float:\n            raise ValueError('constants must be real-valued')\n        constants_dict[str(constant)] = v._to_mpmath(bprec)\n    exprval = expr.evalf(prec, chop=True)\n    re, im = exprval.as_real_imag()\n    if not (re.is_Number and im.is_Number):\n        return expr\n\n    def nsimplify_real(x):\n        orig = mpmath.mp.dps\n        xv = x._to_mpmath(bprec)\n        try:\n            if not (tolerance or full):\n                mpmath.mp.dps = 15\n                rat = mpmath.pslq([xv, 1])\n                if rat is not None:\n                    return Rational(-int(rat[1]), int(rat[0]))\n            mpmath.mp.dps = prec\n            newexpr = mpmath.identify(xv, constants=constants_dict, tol=tolerance, full=full)\n            if not newexpr:\n                raise ValueError\n            if full:\n                newexpr = newexpr[0]\n            expr = sympify(newexpr)\n            if x and (not expr):\n                raise ValueError\n            if expr.is_finite is False and xv not in [mpmath.inf, mpmath.ninf]:\n                raise ValueError\n            return expr\n        finally:\n            mpmath.mp.dps = orig\n    try:\n        if re:\n            re = nsimplify_real(re)\n        if im:\n            im = nsimplify_real(im)\n    except ValueError:\n        if rational is None:\n            return _real_to_rational(expr, rational_conversion=rational_conversion)\n        return expr\n    rv = re + im * S.ImaginaryUnit\n    if rv != expr or rational is False:\n        return rv\n    return _real_to_rational(expr, rational_conversion=rational_conversion)",
    ".sympy.integrals.intpoly.py@@strip": "def strip(monom):\n    if monom.is_zero:\n        return (S.Zero, S.Zero)\n    elif monom.is_number:\n        return (monom, S.One)\n    else:\n        coeff = LC(monom)\n        return (coeff, monom / coeff)",
    ".sympy.core.numbers.py@@NegativeInfinity.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.basic.py@@Atom.xreplace": "def xreplace(self, rule, hack2=False):\n    return rule.get(self, self)",
    ".sympy.core.symbol.py@@Symbol.free_symbols": "def free_symbols(self):\n    return {self}",
    ".sympy.simplify.simplify.py@@_real_to_rational": "def _real_to_rational(expr, tolerance=None, rational_conversion='base10'):\n    expr = _sympify(expr)\n    inf = Float('inf')\n    p = expr\n    reps = {}\n    reduce_num = None\n    if tolerance is not None and tolerance < 1:\n        reduce_num = ceiling(1 / tolerance)\n    for fl in p.atoms(Float):\n        key = fl\n        if reduce_num is not None:\n            r = Rational(fl).limit_denominator(reduce_num)\n        elif tolerance is not None and tolerance >= 1 and (fl.is_Integer is False):\n            r = Rational(tolerance * round(fl / tolerance)).limit_denominator(int(tolerance))\n        else:\n            if rational_conversion == 'exact':\n                r = Rational(fl)\n                reps[key] = r\n                continue\n            elif rational_conversion != 'base10':\n                raise ValueError(\"rational_conversion must be 'base10' or 'exact'\")\n            r = nsimplify(fl, rational=False)\n            if fl and (not r):\n                r = Rational(fl)\n            elif not r.is_Rational:\n                if fl in (inf, -inf):\n                    r = S.ComplexInfinity\n                elif fl < 0:\n                    fl = -fl\n                    d = Pow(10, int(mpmath.log(fl) / mpmath.log(10)))\n                    r = -Rational(str(fl / d)) * d\n                elif fl > 0:\n                    d = Pow(10, int(mpmath.log(fl) / mpmath.log(10)))\n                    r = Rational(str(fl / d)) * d\n                else:\n                    r = S.Zero\n        reps[key] = r\n    return p.subs(reps, simultaneous=True)",
    ".sympy.core.symbol.py@@Dummy.__new__": "def __new__(cls, name=None, dummy_index=None, **assumptions):\n    if dummy_index is not None:\n        assert name is not None, 'If you specify a dummy_index, you must also provide a name'\n    if name is None:\n        name = 'Dummy_' + str(Dummy._count)\n    if dummy_index is None:\n        dummy_index = Dummy._base_dummy_index + Dummy._count\n        Dummy._count += 1\n    cls._sanitize(assumptions, cls)\n    obj = Symbol.__xnew__(cls, name, **assumptions)\n    obj.dummy_index = dummy_index\n    return obj",
    ".sympy.core.symbol.py@@Symbol._sanitize": "def _sanitize(assumptions, obj=None):\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    if is_commutative is None:\n        whose = '%s ' % obj.__name__ if obj else ''\n        raise ValueError('%scommutativity must be True or False.' % whose)\n    for key in list(assumptions.keys()):\n        v = assumptions[key]\n        if v is None:\n            assumptions.pop(key)\n            continue\n        assumptions[key] = bool(v)",
    ".sympy.core.logic.py@@fuzzy_bool": "def fuzzy_bool(x):\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    ".sympy.core.symbol.py@@Symbol.__new_stage2__": "def __new_stage2__(cls, name, **assumptions):\n    if not isinstance(name, str):\n        raise TypeError('name should be a string, not %s' % repr(type(name)))\n    obj = Expr.__new__(cls)\n    obj.name = name\n    tmp_asm_copy = assumptions.copy()\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    assumptions['commutative'] = is_commutative\n    obj._assumptions = StdFactKB(assumptions)\n    obj._assumptions._generator = tmp_asm_copy\n    return obj",
    ".sympy.core.symbol.py@@Dummy._hashable_content": "def _hashable_content(self):\n    return Symbol._hashable_content(self) + (self.dummy_index,)",
    ".sympy.polys.polytools.py@@LC": "def LC(f, *gens, **args):\n    options.allowed_flags(args, ['polys'])\n    try:\n        F, opt = poly_from_expr(f, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('LC', 1, exc)\n    return F.LC(order=opt.order)",
    ".sympy.polys.polyoptions.py@@allowed_flags": "def allowed_flags(args, flags):\n    flags = set(flags)\n    for arg in args.keys():\n        try:\n            if Options.__options__[arg].is_Flag and arg not in flags:\n                raise FlagError(\"'%s' flag is not allowed in this context\" % arg)\n        except KeyError:\n            raise OptionError(\"'%s' is not a valid option\" % arg)",
    ".sympy.polys.polytools.py@@poly_from_expr": "def poly_from_expr(expr, *gens, **args):\n    opt = options.build_options(gens, args)\n    return _poly_from_expr(expr, opt)",
    ".sympy.polys.polytools.py@@_poly_from_expr": "def _poly_from_expr(expr, opt):\n    orig, expr = (expr, sympify(expr))\n    if not isinstance(expr, Basic):\n        raise PolificationFailed(opt, orig, expr)\n    elif expr.is_Poly:\n        poly = expr.__class__._from_poly(expr, opt)\n        opt.gens = poly.gens\n        opt.domain = poly.domain\n        if opt.polys is None:\n            opt.polys = True\n        return (poly, opt)\n    elif opt.expand:\n        expr = expr.expand()\n    rep, opt = _dict_from_expr(expr, opt)\n    if not opt.gens:\n        raise PolificationFailed(opt, orig, expr)\n    monoms, coeffs = list(zip(*list(rep.items())))\n    domain = opt.domain\n    if domain is None:\n        opt.domain, coeffs = construct_domain(coeffs, opt=opt)\n    else:\n        coeffs = list(map(domain.from_sympy, coeffs))\n    rep = dict(list(zip(monoms, coeffs)))\n    poly = Poly._from_dict(rep, opt)\n    if opt.polys is None:\n        opt.polys = False\n    return (poly, opt)",
    ".sympy.polys.polyoptions.py@@Options.__setattr__": "def __setattr__(self, attr, value):\n    if attr in self.__options__:\n        self[attr] = value\n    else:\n        super().__setattr__(attr, value)",
    ".sympy.polys.domains.domain.py@@Domain.of_type": "def of_type(self, element):\n    return isinstance(element, self.tp)",
    ".sympy.polys.polyoptions.py@@Order.default": "def default(cls):\n    return sympy.polys.orderings.lex",
    ".sympy.polys.polytools.py@@Poly.LC": "def LC(f, order=None):\n    if order is not None:\n        return f.coeffs(order)[0]\n    if hasattr(f.rep, 'LC'):\n        result = f.rep.LC()\n    else:\n        raise OperationNotSupported(f, 'LC')\n    return f.rep.dom.to_sympy(result)",
    ".sympy.polys.polytools.py@@Poly.coeffs": "def coeffs(f, order=None):\n    return [f.rep.dom.to_sympy(c) for c in f.rep.coeffs(order=order)]",
    ".sympy.polys.polyclasses.py@@DMP.coeffs": "def coeffs(f, order=None):\n    return [c for _, c in dmp_list_terms(f.rep, f.lev, f.dom, order=order)]",
    ".sympy.polys.orderings.py@@monomial_key": "def monomial_key(order=None, gens=None):\n    if order is None:\n        order = lex\n    if isinstance(order, Symbol):\n        order = str(order)\n    if isinstance(order, str):\n        try:\n            order = _monomial_key[order]\n        except KeyError:\n            raise ValueError(\"supported monomial orderings are 'lex', 'grlex' and 'grevlex', got %r\" % order)\n    if hasattr(order, '__call__'):\n        if gens is not None:\n\n            def _order(expr):\n                return order(expr.as_poly(*gens).degree_list())\n            return _order\n        return order\n    else:\n        raise ValueError('monomial ordering specification must be a string or a callable, got %s' % order)",
    ".sympy.polys.densebasic.py@@sort": "def sort(terms, O):\n    return sorted(terms, key=lambda term: O(term[0]), reverse=True)",
    ".sympy.polys.orderings.py@@LexOrder.__call__": "def __call__(self, monomial):\n    return monomial",
    ".sympy.printing.str.py@@StrPrinter._print_Mul": "def _print_Mul(self, expr):\n    prec = precedence(expr)\n    args = expr.args\n    if args[0] is S.One or any((isinstance(a, Number) or (a.is_Pow and all((ai.is_Integer for ai in a.args))) for a in args[1:])):\n        d, n = sift(args, lambda x: isinstance(x, Pow) and bool(x.exp.as_coeff_Mul()[0] < 0), binary=True)\n        for i, di in enumerate(d):\n            if di.exp.is_Number:\n                e = -di.exp\n            else:\n                dargs = list(di.exp.args)\n                dargs[0] = -dargs[0]\n                e = Mul._from_args(dargs)\n            d[i] = Pow(di.base, e, evaluate=False) if e - 1 else di.base\n        pre = []\n        if n and n[0].could_extract_minus_sign():\n            pre = [str(n.pop(0))]\n        nfactors = pre + [self.parenthesize(a, prec, strict=False) for a in n]\n        if not nfactors:\n            nfactors = ['1']\n        if len(d) > 1 and d[0].could_extract_minus_sign():\n            pre = [str(d.pop(0))]\n        else:\n            pre = []\n        dfactors = pre + [self.parenthesize(a, prec, strict=False) for a in d]\n        n = '*'.join(nfactors)\n        d = '*'.join(dfactors)\n        if len(dfactors) > 1:\n            return '%s/(%s)' % (n, d)\n        elif dfactors:\n            return '%s/%s' % (n, d)\n        return n\n    c, e = expr.as_coeff_Mul()\n    if c < 0:\n        expr = _keep_coeff(-c, e)\n        sign = '-'\n    else:\n        sign = ''\n    a = []\n    b = []\n    pow_paren = []\n    if self.order not in ('old', 'none'):\n        args = expr.as_ordered_factors()\n    else:\n        args = Mul.make_args(expr)\n\n    def apow(i):\n        b, e = i.as_base_exp()\n        eargs = list(Mul.make_args(e))\n        if eargs[0] is S.NegativeOne:\n            eargs = eargs[1:]\n        else:\n            eargs[0] = -eargs[0]\n        e = Mul._from_args(eargs)\n        if isinstance(i, Pow):\n            return i.func(b, e, evaluate=False)\n        return i.func(e, evaluate=False)\n    for item in args:\n        if item.is_commutative and isinstance(item, Pow) and bool(item.exp.as_coeff_Mul()[0] < 0):\n            if item.exp is not S.NegativeOne:\n                b.append(apow(item))\n            else:\n                if len(item.args[0].args) != 1 and isinstance(item.base, (Mul, Pow)):\n                    pow_paren.append(item)\n                b.append(item.base)\n        elif item.is_Rational and item is not S.Infinity:\n            if item.p != 1:\n                a.append(Rational(item.p))\n            if item.q != 1:\n                b.append(Rational(item.q))\n        else:\n            a.append(item)\n    a = a or [S.One]\n    a_str = [self.parenthesize(x, prec, strict=False) for x in a]\n    b_str = [self.parenthesize(x, prec, strict=False) for x in b]\n    for item in pow_paren:\n        if item.base in b:\n            b_str[b.index(item.base)] = '(%s)' % b_str[b.index(item.base)]\n    if not b:\n        return sign + '*'.join(a_str)\n    elif len(b) == 1:\n        return sign + '*'.join(a_str) + '/' + b_str[0]\n    else:\n        return sign + '*'.join(a_str) + '/(%s)' % '*'.join(b_str)",
    ".sympy.printing.precedence.py@@precedence": "def precedence(item):\n    if hasattr(item, 'precedence'):\n        return item.precedence\n    try:\n        mro = item.__class__.__mro__\n    except AttributeError:\n        return PRECEDENCE['Atom']\n    for i in mro:\n        n = i.__name__\n        if n in PRECEDENCE_FUNCTIONS:\n            return PRECEDENCE_FUNCTIONS[n](item)\n        elif n in PRECEDENCE_VALUES:\n            return PRECEDENCE_VALUES[n]\n    return PRECEDENCE['Atom']",
    ".sympy.printing.precedence.py@@precedence_Mul": "def precedence_Mul(item):\n    if item.could_extract_minus_sign():\n        return PRECEDENCE['Add']\n    return PRECEDENCE['Mul']",
    ".sympy.core.mul.py@@Mul.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    if self == -self:\n        return False\n    c = self.args[0]\n    return c.is_Number and c.is_extended_negative",
    ".sympy.core.mul.py@@Mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    ".sympy.core.mul.py@@Mul.as_coeff_mul": "def as_coeff_mul(self, *deps, rational=True, **kwargs):\n    if deps:\n        l1, l2 = sift(self.args, lambda x: x.has(*deps), binary=True)\n        return (self._new_rawargs(*l2), tuple(l1))\n    args = self.args\n    if args[0].is_Number:\n        if not rational or args[0].is_Rational:\n            return (args[0], args[1:])\n        elif args[0].is_extended_negative:\n            return (S.NegativeOne, (-args[0],) + args[1:])\n    return (S.One, args)",
    ".sympy.core.mul.py@@Mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return (coeff, args[0])\n            else:\n                return (coeff, self._new_rawargs(*args))\n        elif coeff.is_extended_negative:\n            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))\n    return (S.One, self)",
    ".sympy.printing.printer.py@@Printer.order": "def order(self):\n    if 'order' in self._settings:\n        return self._settings['order']\n    else:\n        raise AttributeError('No order defined.')",
    ".sympy.core.mul.py@@Mul.as_ordered_factors": "def as_ordered_factors(self, order=None):\n    cpart, ncpart = self.args_cnc()\n    cpart.sort(key=lambda expr: expr.sort_key(order=order))\n    return cpart + ncpart",
    ".sympy.core.expr.py@@Expr.args_cnc": "def args_cnc(self, cset=False, warn=True, split_1=True):\n    if self.is_Mul:\n        args = list(self.args)\n    else:\n        args = [self]\n    for i, mi in enumerate(args):\n        if not mi.is_commutative:\n            c = args[:i]\n            nc = args[i:]\n            break\n    else:\n        c = args\n        nc = []\n    if c and split_1 and (c[0].is_Number and c[0].is_extended_negative and (c[0] is not S.NegativeOne)):\n        c[:1] = [S.NegativeOne, -c[0]]\n    if cset:\n        clen = len(c)\n        c = set(c)\n        if clen and warn and (len(c) != clen):\n            raise ValueError('repeated commutative arguments: %s' % [ci for ci in c if list(self.args).count(ci) > 1])\n    return [c, nc]",
    ".sympy.printing.str.py@@StrPrinter.parenthesize": "def parenthesize(self, item, level, strict=False):\n    if precedence(item) < level or (not strict and precedence(item) <= level):\n        return '(%s)' % self._print(item)\n    else:\n        return self._print(item)",
    ".sympy.core.basic.py@@Basic.free_symbols": "def free_symbols(self) -> 'Set[Basic]':\n    empty: 'Set[Basic]' = set()\n    return empty.union(*(a.free_symbols for a in self.args))",
    ".sympy.core.expr.py@@Expr.sort_key": "def sort_key(self, order=None):\n    coeff, expr = self.as_coeff_Mul()\n    if expr.is_Pow:\n        if expr.base is S.Exp1:\n            expr, exp = (Function('exp')(expr.exp), S.One)\n        else:\n            expr, exp = expr.args\n    else:\n        exp = S.One\n    if expr.is_Dummy:\n        args = (expr.sort_key(),)\n    elif expr.is_Atom:\n        args = (str(expr),)\n    else:\n        if expr.is_Add:\n            args = expr.as_ordered_terms(order=order)\n        elif expr.is_Mul:\n            args = expr.as_ordered_factors(order=order)\n        else:\n            args = expr.args\n        args = tuple([default_sort_key(arg, order=order) for arg in args])\n    args = (len(args), tuple(args))\n    exp = exp.sort_key(order=order)\n    return (expr.class_key(), args, exp, coeff)",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational: bool=False) -> tTuple['Number', 'Expr']:\n    return (S.One, self)",
    ".sympy.printing.str.py@@StrPrinter._print_Pow": "def _print_Pow(self, expr, rational=False):\n    PREC = precedence(expr)\n    if expr.exp is S.Half and (not rational):\n        return 'sqrt(%s)' % self._print(expr.base)\n    if expr.is_commutative:\n        if -expr.exp is S.Half and (not rational):\n            return '%s/sqrt(%s)' % tuple(map(lambda arg: self._print(arg), (S.One, expr.base)))\n        if expr.exp is -S.One:\n            return '%s/%s' % (self._print(S.One), self.parenthesize(expr.base, PREC, strict=False))\n    e = self.parenthesize(expr.exp, PREC, strict=False)\n    if self.printmethod == '_sympyrepr' and expr.exp.is_Rational and (expr.exp.q != 1):\n        if e.startswith('(Rational'):\n            return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e[1:-1])\n    return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e)",
    ".sympy.printing.precedence.py@@precedence_Integer": "def precedence_Integer(item):\n    if item.p < 0:\n        return PRECEDENCE['Add']\n    return PRECEDENCE['Atom']",
    ".sympy.printing.str.py@@StrPrinter._print_Integer": "def _print_Integer(self, expr):\n    if self._settings.get('sympy_integers', False):\n        return 'S(%s)' % expr\n    return str(expr.p)"
}