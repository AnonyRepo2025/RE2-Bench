{
    ".sympy.matrices.sparse.py@@SparseMatrix.copy": "def copy(self):\n    return self._new(self.rows, self.cols, self._smat)",
    ".sympy.matrices.sparse.py@@SparseMatrix.__new__": "def __new__(cls, *args, **kwargs):\n    self = object.__new__(cls)\n    if len(args) == 1 and isinstance(args[0], SparseMatrix):\n        self.rows = args[0].rows\n        self.cols = args[0].cols\n        self._smat = dict(args[0]._smat)\n        return self\n    self._smat = {}\n    if len(args) == 3:\n        self.rows = as_int(args[0])\n        self.cols = as_int(args[1])\n        if isinstance(args[2], collections.Callable):\n            op = args[2]\n            for i in range(self.rows):\n                for j in range(self.cols):\n                    value = self._sympify(op(self._sympify(i), self._sympify(j)))\n                    if value:\n                        self._smat[i, j] = value\n        elif isinstance(args[2], (dict, Dict)):\n            for key in args[2].keys():\n                v = args[2][key]\n                if v:\n                    self._smat[key] = self._sympify(v)\n        elif is_sequence(args[2]):\n            if len(args[2]) != self.rows * self.cols:\n                raise ValueError('List length (%s) != rows*columns (%s)' % (len(args[2]), self.rows * self.cols))\n            flat_list = args[2]\n            for i in range(self.rows):\n                for j in range(self.cols):\n                    value = self._sympify(flat_list[i * self.cols + j])\n                    if value:\n                        self._smat[i, j] = value\n    else:\n        r, c, _list = Matrix._handle_creation_inputs(*args)\n        self.rows = r\n        self.cols = c\n        for i in range(self.rows):\n            for j in range(self.cols):\n                value = _list[self.cols * i + j]\n                if value:\n                    self._smat[i, j] = value\n    return self",
    ".sympy.core.compatibility.py@@as_int": "def as_int(n):\n    try:\n        result = int(n)\n        if result != n:\n            raise TypeError\n    except TypeError:\n        raise ValueError('%s is not an integer' % (n,))\n    return result",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    if evaluate is None:\n        if global_evaluate[0] is False:\n            evaluate = global_evaluate[0]\n        else:\n            evaluate = True\n    try:\n        if a in sympy_classes:\n            return a\n    except TypeError:\n        pass\n    try:\n        cls = a.__class__\n    except AttributeError:\n        cls = type(a)\n    if cls in sympy_classes:\n        return a\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if type(a).__module__ == 'numpy':\n        import numpy as np\n        if np.isscalar(a):\n            if not isinstance(a, np.floating):\n                func = converter[complex] if np.iscomplex(a) else sympify\n                return func(np.asscalar(a))\n            else:\n                try:\n                    from sympy.core.numbers import Float\n                    prec = np.finfo(a).nmant\n                    a = str(list(np.reshape(np.asarray(a), (1, np.size(a)))[0]))[1:-1]\n                    return Float(a, precision=prec)\n                except NotImplementedError:\n                    raise SympifyError('Translation for numpy float : %s is not implemented' % a)\n    try:\n        return converter[cls](a)\n    except KeyError:\n        for superclass in getmro(cls):\n            try:\n                return converter[superclass](a)\n            except KeyError:\n                continue\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    try:\n        return a._sympy_()\n    except AttributeError:\n        pass\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                return sympify(coerce(a))\n            except (TypeError, ValueError, AttributeError, SympifyError):\n                continue\n    if strict:\n        raise SympifyError(a)\n    try:\n        from ..tensor.array import Array\n        return Array(a.flat, a.shape)\n    except AttributeError:\n        pass\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h"
}