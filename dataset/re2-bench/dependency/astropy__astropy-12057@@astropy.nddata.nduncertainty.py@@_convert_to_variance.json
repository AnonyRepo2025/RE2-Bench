{
    ".astropy.nddata.nduncertainty.py@@NDUncertainty.array": "def array(self):\n    return self._array",
    ".astropy.nddata.nduncertainty.py@@NDUncertainty.unit": "def unit(self):\n    return self._unit",
    ".astropy.units.core.py@@UnitBase.__rtruediv__": "def __rtruediv__(self, m):\n    if isinstance(m, (bytes, str)):\n        return Unit(m) / self\n    try:\n        from .quantity import Quantity\n        if hasattr(m, 'unit'):\n            result = Quantity(m)\n            result /= self\n            return result\n        else:\n            return Quantity(m, self ** (-1))\n    except TypeError:\n        return NotImplemented",
    ".astropy.units.core.py@@UnitBase.__pow__": "def __pow__(self, p):\n    p = validate_power(p)\n    return CompositeUnit(1, [self], [p], _error_check=False)",
    ".astropy.units.utils.py@@validate_power": "def validate_power(p):\n    denom = getattr(p, 'denominator', None)\n    if denom is None:\n        try:\n            p = float(p)\n        except Exception:\n            if not np.isscalar(p):\n                raise ValueError('Quantities and Units may only be raised to a scalar power')\n            else:\n                raise\n        p = maybe_simple_fraction(p)\n        if isinstance(p, float):\n            return p\n        denom = p.denominator\n    if denom == 1:\n        p = p.numerator\n    elif denom & denom - 1 == 0:\n        p = float(p)\n    return p",
    ".astropy.units.core.py@@CompositeUnit.__init__": "def __init__(self, scale, bases, powers, decompose=False, decompose_bases=set(), _error_check=True):\n    if _error_check:\n        for base in bases:\n            if not isinstance(base, UnitBase):\n                raise TypeError('bases must be sequence of UnitBase instances')\n        powers = [validate_power(p) for p in powers]\n    if not decompose and len(bases) == 1 and (powers[0] >= 0):\n        unit = bases[0]\n        power = powers[0]\n        if power == 1:\n            scale *= unit.scale\n            self._bases = unit.bases\n            self._powers = unit.powers\n        elif power == 0:\n            self._bases = []\n            self._powers = []\n        else:\n            scale *= unit.scale ** power\n            self._bases = unit.bases\n            self._powers = [operator.mul(*resolve_fractions(p, power)) for p in unit.powers]\n        self._scale = sanitize_scale(scale)\n    else:\n        self._scale = scale\n        self._bases = bases\n        self._powers = powers\n        self._expand_and_gather(decompose=decompose, bases=decompose_bases)",
    ".astropy.units.core.py@@CompositeUnit._expand_and_gather": "def _expand_and_gather(self, decompose=False, bases=set()):\n\n    def add_unit(unit, power, scale):\n        if bases and unit not in bases:\n            for base in bases:\n                try:\n                    scale *= unit._to(base) ** power\n                except UnitsError:\n                    pass\n                else:\n                    unit = base\n                    break\n        if unit in new_parts:\n            a, b = resolve_fractions(new_parts[unit], power)\n            new_parts[unit] = a + b\n        else:\n            new_parts[unit] = power\n        return scale\n    new_parts = {}\n    scale = self._scale\n    for b, p in zip(self._bases, self._powers):\n        if decompose and b not in bases:\n            b = b.decompose(bases=bases)\n        if isinstance(b, CompositeUnit):\n            scale *= b._scale ** p\n            for b_sub, p_sub in zip(b._bases, b._powers):\n                a, b = resolve_fractions(p_sub, p)\n                scale = add_unit(b_sub, a * b, scale)\n        else:\n            scale = add_unit(b, p, scale)\n    new_parts = [x for x in new_parts.items() if x[1] != 0]\n    new_parts.sort(key=lambda x: (-x[1], getattr(x[0], 'name', '')))\n    self._bases = [x[0] for x in new_parts]\n    self._powers = [x[1] for x in new_parts]\n    self._scale = sanitize_scale(scale)",
    ".astropy.units.core.py@@CompositeUnit.add_unit": "def add_unit(unit, power, scale):\n    if bases and unit not in bases:\n        for base in bases:\n            try:\n                scale *= unit._to(base) ** power\n            except UnitsError:\n                pass\n            else:\n                unit = base\n                break\n    if unit in new_parts:\n        a, b = resolve_fractions(new_parts[unit], power)\n        new_parts[unit] = a + b\n    else:\n        new_parts[unit] = power\n    return scale",
    ".astropy.units.core.py@@UnitBase.__hash__": "def __hash__(self):\n    if self._hash is None:\n        parts = [str(self.scale)] + [x.name for x in self.bases] + [str(x) for x in self.powers]\n        self._hash = hash(tuple(parts))\n    return self._hash",
    ".astropy.units.core.py@@NamedUnit.name": "def name(self):\n    return self._names[0]",
    ".astropy.units.utils.py@@sanitize_scale": "def sanitize_scale(scale):\n    if is_effectively_unity(scale):\n        return 1.0\n    if scale.__class__ is float:\n        return scale\n    if hasattr(scale, 'dtype'):\n        scale = scale.item()\n    if scale.imag:\n        if abs(scale.real) > abs(scale.imag):\n            if is_effectively_unity(scale.imag / scale.real + 1):\n                return scale.real\n        elif is_effectively_unity(scale.real / scale.imag + 1):\n            return complex(0.0, scale.imag)\n        return scale\n    else:\n        return scale.real",
    ".astropy.units.utils.py@@is_effectively_unity": "def is_effectively_unity(value):\n    try:\n        return _JUST_BELOW_UNITY <= value <= _JUST_ABOVE_UNITY\n    except TypeError:\n        return _JUST_BELOW_UNITY <= value.real <= _JUST_ABOVE_UNITY and _JUST_BELOW_UNITY <= value.imag + 1 <= _JUST_ABOVE_UNITY",
    ".astropy.units.quantity.py@@Quantity.__new__": "def __new__(cls, value, unit=None, dtype=None, copy=True, order=None, subok=False, ndmin=0):\n    if unit is not None:\n        unit = Unit(unit)\n    if isinstance(value, Quantity):\n        if unit is not None and unit is not value.unit:\n            value = value.to(unit)\n            copy = False\n        if type(value) is not cls and (not (subok and isinstance(value, cls))):\n            value = value.view(cls)\n        if dtype is None and value.dtype.kind in 'iu':\n            dtype = float\n        return np.array(value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin)\n    value_unit = None\n    if not isinstance(value, np.ndarray):\n        if isinstance(value, str):\n            pattern = '\\\\s*[+-]?((\\\\d+\\\\.?\\\\d*)|(\\\\.\\\\d+)|([nN][aA][nN])|([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))([eE][+-]?\\\\d+)?[.+-]?'\n            v = re.match(pattern, value)\n            unit_string = None\n            try:\n                value = float(v.group())\n            except Exception:\n                raise TypeError('Cannot parse \"{}\" as a {}. It does not start with a number.'.format(value, cls.__name__))\n            unit_string = v.string[v.end():].strip()\n            if unit_string:\n                value_unit = Unit(unit_string)\n                if unit is None:\n                    unit = value_unit\n        elif isiterable(value) and len(value) > 0:\n            if all((isinstance(v, Quantity) for v in value)):\n                if unit is None:\n                    unit = value[0].unit\n                value = [q.to_value(unit) for q in value]\n                value_unit = unit\n            elif dtype is None and (not hasattr(value, 'dtype')) and isinstance(unit, StructuredUnit):\n                dtype = unit._recursively_get_dtype(value)\n    if value_unit is None:\n        value_unit = getattr(value, 'unit', None)\n        if value_unit is None:\n            if unit is None:\n                unit = cls._default_unit\n            value_unit = unit\n        else:\n            try:\n                value_unit = Unit(value_unit)\n            except Exception as exc:\n                raise TypeError('The unit attribute {!r} of the input could not be parsed as an astropy Unit, raising the following exception:\\n{}'.format(value.unit, exc))\n            if unit is None:\n                unit = value_unit\n            elif unit is not value_unit:\n                copy = False\n    value = np.array(value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin)\n    if value.dtype.kind in 'OSU' and (not (value.dtype.kind == 'O' and isinstance(value.item(0), numbers.Number))):\n        raise TypeError('The value must be a valid Python or Numpy numeric type.')\n    if dtype is None and value.dtype.kind in 'iuO':\n        value = value.astype(float)\n    if subok:\n        qcls = getattr(unit, '_quantity_class', cls)\n        if issubclass(qcls, cls):\n            cls = qcls\n    value = value.view(cls)\n    value._set_unit(value_unit)\n    if unit is value_unit:\n        return value\n    else:\n        return value.to(unit)",
    ".astropy.units.core.py@@_UnitMetaClass.__call__": "def __call__(self, s='', represents=None, format=None, namespace=None, doc=None, parse_strict='raise'):\n    if hasattr(s, '_get_physical_type_id'):\n        return s\n    from .quantity import Quantity\n    if isinstance(represents, Quantity):\n        if is_effectively_unity(represents.value):\n            represents = represents.unit\n        else:\n            represents = CompositeUnit(represents.value * represents.unit.scale, bases=represents.unit.bases, powers=represents.unit.powers, _error_check=False)\n    if isinstance(s, Quantity):\n        if is_effectively_unity(s.value):\n            s = s.unit\n        else:\n            s = CompositeUnit(s.value * s.unit.scale, bases=s.unit.bases, powers=s.unit.powers, _error_check=False)\n    if isinstance(represents, UnitBase):\n        return super().__call__(s, represents, format=format, namespace=namespace, doc=doc)\n    if isinstance(s, UnitBase):\n        return s\n    elif isinstance(s, (bytes, str)):\n        if len(s.strip()) == 0:\n            return dimensionless_unscaled\n        if format is None:\n            format = unit_format.Generic\n        f = unit_format.get_format(format)\n        if isinstance(s, bytes):\n            s = s.decode('ascii')\n        try:\n            return f.parse(s)\n        except NotImplementedError:\n            raise\n        except Exception as e:\n            if parse_strict == 'silent':\n                pass\n            else:\n                if f is not unit_format.Generic:\n                    format_clause = f.name + ' '\n                else:\n                    format_clause = ''\n                msg = \"'{}' did not parse as {}unit: {} If this is meant to be a custom unit, define it with 'u.def_unit'. To have it recognized inside a file reader or other code, enable it with 'u.add_enabled_units'. For details, see https://docs.astropy.org/en/latest/units/combining_and_defining.html\".format(s, format_clause, str(e))\n                if parse_strict == 'raise':\n                    raise ValueError(msg)\n                elif parse_strict == 'warn':\n                    warnings.warn(msg, UnitsWarning)\n                else:\n                    raise ValueError(\"'parse_strict' must be 'warn', 'raise' or 'silent'\")\n            return UnrecognizedUnit(s)\n    elif isinstance(s, (int, float, np.floating, np.integer)):\n        return CompositeUnit(s, [], [], _error_check=False)\n    elif isinstance(s, tuple):\n        from .structured import StructuredUnit\n        return StructuredUnit(s)\n    elif s is None:\n        raise TypeError('None is not a valid Unit')\n    else:\n        raise TypeError(f'{s} can not be converted to a Unit')",
    ".astropy.utils.misc.py@@isiterable": "def isiterable(obj):\n    try:\n        iter(obj)\n        return True\n    except TypeError:\n        return False",
    ".astropy.units.quantity.py@@Quantity.__array_finalize__": "def __array_finalize__(self, obj):\n    super_array_finalize = super().__array_finalize__\n    if super_array_finalize is not None:\n        super_array_finalize(obj)\n    if obj is None or obj.__class__ is np.ndarray:\n        return\n    if self._unit is None:\n        unit = getattr(obj, '_unit', None)\n        if unit is not None:\n            self._set_unit(unit)\n    if 'info' in obj.__dict__:\n        self.info = obj.info",
    ".astropy.units.quantity.py@@Quantity._set_unit": "def _set_unit(self, unit):\n    if not isinstance(unit, UnitBase):\n        if isinstance(self._unit, StructuredUnit) or isinstance(unit, StructuredUnit):\n            unit = StructuredUnit(unit, self.dtype)\n        else:\n            unit = Unit(str(unit), parse_strict='silent')\n            if not isinstance(unit, (UnitBase, StructuredUnit)):\n                raise UnitTypeError('{} instances require normal units, not {} instances.'.format(type(self).__name__, type(unit)))\n    self._unit = unit"
}