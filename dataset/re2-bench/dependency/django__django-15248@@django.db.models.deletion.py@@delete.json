{
    ".django.db.models.base.py@@Model._get_pk_val": "def _get_pk_val(self, meta=None):\n    meta = meta or self._meta\n    return getattr(self, meta.pk.attname)",
    ".django.dispatch.dispatcher.py@@Signal.has_listeners": "def has_listeners(self, sender=None):\n    return bool(self._live_receivers(sender))",
    ".django.dispatch.dispatcher.py@@Signal._live_receivers": "def _live_receivers(self, sender):\n    receivers = None\n    if self.use_caching and (not self._dead_receivers):\n        receivers = self.sender_receivers_cache.get(sender)\n        if receivers is NO_RECEIVERS:\n            return []\n    if receivers is None:\n        with self.lock:\n            self._clear_dead_receivers()\n            senderkey = _make_id(sender)\n            receivers = []\n            for (receiverkey, r_senderkey), receiver in self.receivers:\n                if r_senderkey == NONE_ID or r_senderkey == senderkey:\n                    receivers.append(receiver)\n            if self.use_caching:\n                if not receivers:\n                    self.sender_receivers_cache[sender] = NO_RECEIVERS\n                else:\n                    self.sender_receivers_cache[sender] = receivers\n    non_weak_receivers = []\n    for receiver in receivers:\n        if isinstance(receiver, weakref.ReferenceType):\n            receiver = receiver()\n            if receiver is not None:\n                non_weak_receivers.append(receiver)\n        else:\n            non_weak_receivers.append(receiver)\n    return non_weak_receivers",
    ".django.dispatch.dispatcher.py@@Signal._clear_dead_receivers": "def _clear_dead_receivers(self):\n    if self._dead_receivers:\n        self._dead_receivers = False\n        self.receivers = [r for r in self.receivers if not (isinstance(r[1], weakref.ReferenceType) and r[1]() is None)]",
    ".django.dispatch.dispatcher.py@@_make_id": "def _make_id(target):\n    if hasattr(target, '__func__'):\n        return (id(target.__self__), id(target.__func__))\n    return id(target)",
    ".django.db.transaction.py@@atomic": "def atomic(using=None, savepoint=True, durable=False):\n    if callable(using):\n        return Atomic(DEFAULT_DB_ALIAS, savepoint, durable)(using)\n    else:\n        return Atomic(using, savepoint, durable)",
    ".django.db.transaction.py@@Atomic.__init__": "def __init__(self, using, savepoint, durable):\n    self.using = using\n    self.savepoint = savepoint\n    self.durable = durable\n    self._from_testcase = False",
    ".django.db.transaction.py@@Atomic.__enter__": "def __enter__(self):\n    connection = get_connection(self.using)\n    if self.durable and connection.atomic_blocks and (not connection.atomic_blocks[-1]._from_testcase):\n        raise RuntimeError('A durable atomic block cannot be nested within another atomic block.')\n    if not connection.in_atomic_block:\n        connection.commit_on_exit = True\n        connection.needs_rollback = False\n        if not connection.get_autocommit():\n            connection.in_atomic_block = True\n            connection.commit_on_exit = False\n    if connection.in_atomic_block:\n        if self.savepoint and (not connection.needs_rollback):\n            sid = connection.savepoint()\n            connection.savepoint_ids.append(sid)\n        else:\n            connection.savepoint_ids.append(None)\n    else:\n        connection.set_autocommit(False, force_begin_transaction_with_broken_autocommit=True)\n        connection.in_atomic_block = True\n    if connection.in_atomic_block:\n        connection.atomic_blocks.append(self)",
    ".django.db.transaction.py@@get_connection": "def get_connection(using=None):\n    if using is None:\n        using = DEFAULT_DB_ALIAS\n    return connections[using]",
    ".django.utils.connection.py@@BaseConnectionHandler.__getitem__": "def __getitem__(self, alias):\n    try:\n        return getattr(self._connections, alias)\n    except AttributeError:\n        if alias not in self.settings:\n            raise self.exception_class(f\"The connection '{alias}' doesn't exist.\")\n    conn = self.create_connection(alias)\n    setattr(self._connections, alias, conn)\n    return conn",
    ".django.dispatch.dispatcher.py@@Signal.send": "def send(self, sender, **named):\n    if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS:\n        return []\n    return [(receiver, receiver(signal=self, sender=sender, **named)) for receiver in self._live_receivers(sender)]",
    ".django.db.models.sql.query.py@@Query.__init__": "def __init__(self, model, alias_cols=True):\n    self.model = model\n    self.alias_refcount = {}\n    self.alias_map = {}\n    self.alias_cols = alias_cols\n    self.external_aliases = {}\n    self.table_map = {}\n    self.default_cols = True\n    self.default_ordering = True\n    self.standard_ordering = True\n    self.used_aliases = set()\n    self.filter_is_sticky = False\n    self.subquery = False\n    self.select = ()\n    self.where = WhereNode()\n    self.group_by = None\n    self.order_by = ()\n    self.low_mark, self.high_mark = (0, None)\n    self.distinct = False\n    self.distinct_fields = ()\n    self.select_for_update = False\n    self.select_for_update_nowait = False\n    self.select_for_update_skip_locked = False\n    self.select_for_update_of = ()\n    self.select_for_no_key_update = False\n    self.select_related = False\n    self.max_depth = 5\n    self.values_select = ()\n    self.annotations = {}\n    self.annotation_select_mask = None\n    self._annotation_select_cache = None\n    self.combinator = None\n    self.combinator_all = False\n    self.combined_queries = ()\n    self.extra = {}\n    self.extra_select_mask = None\n    self._extra_select_cache = None\n    self.extra_tables = ()\n    self.extra_order_by = ()\n    self.deferred_loading = (frozenset(), True)\n    self._filtered_relations = {}\n    self.explain_info = None",
    ".django.utils.tree.py@@Node.__init__": "def __init__(self, children=None, connector=None, negated=False):\n    self.children = children[:] if children else []\n    self.connector = connector or self.default\n    self.negated = negated",
    ".django.db.models.sql.subqueries.py@@DeleteQuery.delete_batch": "def delete_batch(self, pk_list, using):\n    num_deleted = 0\n    field = self.get_meta().pk\n    for offset in range(0, len(pk_list), GET_ITERATOR_CHUNK_SIZE):\n        self.clear_where()\n        self.add_filter(f'{field.attname}__in', pk_list[offset:offset + GET_ITERATOR_CHUNK_SIZE])\n        num_deleted += self.do_query(self.get_meta().db_table, self.where, using=using)\n    return num_deleted",
    ".django.db.models.sql.query.py@@Query.get_meta": "def get_meta(self):\n    return self.model._meta",
    ".django.db.models.sql.query.py@@Query.clear_where": "def clear_where(self):\n    self.where = WhereNode()",
    ".django.db.models.sql.query.py@@Query.add_filter": "def add_filter(self, filter_lhs, filter_rhs):\n    self.add_q(Q((filter_lhs, filter_rhs)))",
    ".django.db.models.query_utils.py@@Q.__init__": "def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n    super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)",
    ".django.db.models.sql.query.py@@Query.add_q": "def add_q(self, q_object):\n    existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}\n    clause, _ = self._add_q(q_object, self.used_aliases)\n    if clause:\n        self.where.add(clause, AND)\n    self.demote_joins(existing_inner)",
    ".django.db.models.sql.query.py@@Query._add_q": "def _add_q(self, q_object, used_aliases, branch_negated=False, current_negated=False, allow_joins=True, split_subq=True, check_filterable=True):\n    connector = q_object.connector\n    current_negated = current_negated ^ q_object.negated\n    branch_negated = branch_negated or q_object.negated\n    target_clause = WhereNode(connector=connector, negated=q_object.negated)\n    joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)\n    for child in q_object.children:\n        child_clause, needed_inner = self.build_filter(child, can_reuse=used_aliases, branch_negated=branch_negated, current_negated=current_negated, allow_joins=allow_joins, split_subq=split_subq, check_filterable=check_filterable)\n        joinpromoter.add_votes(needed_inner)\n        if child_clause:\n            target_clause.add(child_clause, connector)\n    needed_inner = joinpromoter.update_join_types(self)\n    return (target_clause, needed_inner)",
    ".django.db.models.sql.query.py@@JoinPromoter.__init__": "def __init__(self, connector, num_children, negated):\n    self.connector = connector\n    self.negated = negated\n    if self.negated:\n        if connector == AND:\n            self.effective_connector = OR\n        else:\n            self.effective_connector = AND\n    else:\n        self.effective_connector = self.connector\n    self.num_children = num_children\n    self.votes = Counter()",
    ".django.db.models.sql.query.py@@Query.build_filter": "def build_filter(self, filter_expr, branch_negated=False, current_negated=False, can_reuse=None, allow_joins=True, split_subq=True, check_filterable=True):\n    if isinstance(filter_expr, dict):\n        raise FieldError('Cannot parse keyword query as dict')\n    if isinstance(filter_expr, Q):\n        return self._add_q(filter_expr, branch_negated=branch_negated, current_negated=current_negated, used_aliases=can_reuse, allow_joins=allow_joins, split_subq=split_subq, check_filterable=check_filterable)\n    if hasattr(filter_expr, 'resolve_expression'):\n        if not getattr(filter_expr, 'conditional', False):\n            raise TypeError('Cannot filter against a non-conditional expression.')\n        condition = filter_expr.resolve_expression(self, allow_joins=allow_joins)\n        if not isinstance(condition, Lookup):\n            condition = self.build_lookup(['exact'], condition, True)\n        return (WhereNode([condition], connector=AND), [])\n    arg, value = filter_expr\n    if not arg:\n        raise FieldError('Cannot parse keyword query %r' % arg)\n    lookups, parts, reffed_expression = self.solve_lookup_type(arg)\n    if check_filterable:\n        self.check_filterable(reffed_expression)\n    if not allow_joins and len(parts) > 1:\n        raise FieldError('Joined field references are not permitted in this query')\n    pre_joins = self.alias_refcount.copy()\n    value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n    used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n    if check_filterable:\n        self.check_filterable(value)\n    if reffed_expression:\n        condition = self.build_lookup(lookups, reffed_expression, value)\n        return (WhereNode([condition], connector=AND), [])\n    opts = self.get_meta()\n    alias = self.get_initial_alias()\n    allow_many = not branch_negated or not split_subq\n    try:\n        join_info = self.setup_joins(parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many)\n        if isinstance(value, Iterator):\n            value = list(value)\n        self.check_related_objects(join_info.final_field, value, join_info.opts)\n        self._lookup_joins = join_info.joins\n    except MultiJoin as e:\n        return self.split_exclude(filter_expr, can_reuse, e.names_with_path)\n    used_joins.update(join_info.joins)\n    targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)\n    if can_reuse is not None:\n        can_reuse.update(join_list)\n    if join_info.final_field.is_relation:\n        num_lookups = len(lookups)\n        if num_lookups > 1:\n            raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))\n        if len(targets) == 1:\n            col = self._get_col(targets[0], join_info.final_field, alias)\n        else:\n            col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)\n    else:\n        col = self._get_col(targets[0], join_info.final_field, alias)\n    condition = self.build_lookup(lookups, col, value)\n    lookup_type = condition.lookup_name\n    clause = WhereNode([condition], connector=AND)\n    require_outer = lookup_type == 'isnull' and condition.rhs is True and (not current_negated)\n    if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and (condition.rhs is not None):\n        require_outer = True\n        if lookup_type != 'isnull':\n            if self.is_nullable(targets[0]) or self.alias_map[join_list[-1]].join_type == LOUTER:\n                lookup_class = targets[0].get_lookup('isnull')\n                col = self._get_col(targets[0], join_info.targets[0], alias)\n                clause.add(lookup_class(col, False), AND)\n            if isinstance(value, Col) and self.is_nullable(value.target):\n                lookup_class = value.target.get_lookup('isnull')\n                clause.add(lookup_class(value, False), AND)\n    return (clause, used_joins if not require_outer else ())",
    ".django.db.models.sql.query.py@@Query.solve_lookup_type": "def solve_lookup_type(self, lookup):\n    lookup_splitted = lookup.split(LOOKUP_SEP)\n    if self.annotations:\n        expression, expression_lookups = refs_expression(lookup_splitted, self.annotations)\n        if expression:\n            return (expression_lookups, (), expression)\n    _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())\n    field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]\n    if len(lookup_parts) > 1 and (not field_parts):\n        raise FieldError('Invalid lookup \"%s\" for model %s\".' % (lookup, self.get_meta().model.__name__))\n    return (lookup_parts, field_parts, False)",
    ".django.db.models.sql.query.py@@Query.names_to_path": "def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n    path, names_with_path = ([], [])\n    for pos, name in enumerate(names):\n        cur_names_with_path = (name, [])\n        if name == 'pk':\n            name = opts.pk.name\n        field = None\n        filtered_relation = None\n        try:\n            field = opts.get_field(name)\n        except FieldDoesNotExist:\n            if name in self.annotation_select:\n                field = self.annotation_select[name].output_field\n            elif name in self._filtered_relations and pos == 0:\n                filtered_relation = self._filtered_relations[name]\n                if LOOKUP_SEP in filtered_relation.relation_name:\n                    parts = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    filtered_relation_path, field, _, _ = self.names_to_path(parts, opts, allow_many, fail_on_missing)\n                    path.extend(filtered_relation_path[:-1])\n                else:\n                    field = opts.get_field(filtered_relation.relation_name)\n        if field is not None:\n            if field.is_relation and (not field.related_model):\n                raise FieldError('Field %r does not generate an automatic reverse relation and therefore cannot be used for reverse querying. If it is a GenericForeignKey, consider adding a GenericRelation.' % name)\n            try:\n                model = field.model._meta.concrete_model\n            except AttributeError:\n                model = None\n        else:\n            pos -= 1\n            if pos == -1 or fail_on_missing:\n                available = sorted([*get_field_names_from_opts(opts), *self.annotation_select, *self._filtered_relations])\n                raise FieldError(\"Cannot resolve keyword '%s' into field. Choices are: %s\" % (name, ', '.join(available)))\n            break\n        if model is not opts.model:\n            path_to_parent = opts.get_path_to_parent(model)\n            if path_to_parent:\n                path.extend(path_to_parent)\n                cur_names_with_path[1].extend(path_to_parent)\n                opts = path_to_parent[-1].to_opts\n        if hasattr(field, 'path_infos'):\n            if filtered_relation:\n                pathinfos = field.get_path_info(filtered_relation)\n            else:\n                pathinfos = field.path_infos\n            if not allow_many:\n                for inner_pos, p in enumerate(pathinfos):\n                    if p.m2m:\n                        cur_names_with_path[1].extend(pathinfos[0:inner_pos + 1])\n                        names_with_path.append(cur_names_with_path)\n                        raise MultiJoin(pos + 1, names_with_path)\n            last = pathinfos[-1]\n            path.extend(pathinfos)\n            final_field = last.join_field\n            opts = last.to_opts\n            targets = last.target_fields\n            cur_names_with_path[1].extend(pathinfos)\n            names_with_path.append(cur_names_with_path)\n        else:\n            final_field = field\n            targets = (field,)\n            if fail_on_missing and pos + 1 != len(names):\n                raise FieldError(\"Cannot resolve keyword %r into field. Join on '%s' not permitted.\" % (names[pos + 1], name))\n            break\n    return (path, final_field, targets, names[pos + 1:])",
    ".django.db.models.options.py@@Options.get_field": "def get_field(self, field_name):\n    try:\n        return self._forward_fields_map[field_name]\n    except KeyError:\n        if not self.apps.models_ready:\n            raise FieldDoesNotExist(\"%s has no field named '%s'. The app cache isn't ready yet, so if this is an auto-created related field, it won't be available yet.\" % (self.object_name, field_name))\n    try:\n        return self.fields_map[field_name]\n    except KeyError:\n        raise FieldDoesNotExist(\"%s has no field named '%s'\" % (self.object_name, field_name))",
    ".django.utils.functional.py@@cached_property.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    res = instance.__dict__[self.name] = self.func(instance)\n    return res",
    ".django.db.models.options.py@@Options._forward_fields_map": "def _forward_fields_map(self):\n    res = {}\n    fields = self._get_fields(reverse=False)\n    for field in fields:\n        res[field.name] = field\n        try:\n            res[field.attname] = field\n        except AttributeError:\n            pass\n    return res",
    ".django.db.models.options.py@@Options._get_fields": "def _get_fields(self, forward=True, reverse=True, include_parents=True, include_hidden=False, seen_models=None):\n    if include_parents not in (True, False, PROXY_PARENTS):\n        raise TypeError('Invalid argument for include_parents: %s' % (include_parents,))\n    topmost_call = seen_models is None\n    if topmost_call:\n        seen_models = set()\n    seen_models.add(self.model)\n    cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)\n    try:\n        return self._get_fields_cache[cache_key]\n    except KeyError:\n        pass\n    fields = []\n    if include_parents is not False:\n        for parent in self.parents:\n            if parent in seen_models:\n                continue\n            if parent._meta.concrete_model != self.concrete_model and include_parents == PROXY_PARENTS:\n                continue\n            for obj in parent._meta._get_fields(forward=forward, reverse=reverse, include_parents=include_parents, include_hidden=include_hidden, seen_models=seen_models):\n                if not getattr(obj, 'parent_link', False) or obj.model == self.concrete_model:\n                    fields.append(obj)\n    if reverse and (not self.proxy):\n        all_fields = self._relation_tree\n        for field in all_fields:\n            if include_hidden or not field.remote_field.hidden:\n                fields.append(field.remote_field)\n    if forward:\n        fields += self.local_fields\n        fields += self.local_many_to_many\n        if topmost_call:\n            fields += self.private_fields\n    fields = make_immutable_fields_list('get_fields()', fields)\n    self._get_fields_cache[cache_key] = fields\n    return fields",
    ".django.db.models.sql.query.py@@Query.check_filterable": "def check_filterable(self, expression):\n    if hasattr(expression, 'resolve_expression') and (not getattr(expression, 'filterable', True)):\n        raise NotSupportedError(expression.__class__.__name__ + ' is disallowed in the filter clause.')\n    if hasattr(expression, 'get_source_expressions'):\n        for expr in expression.get_source_expressions():\n            self.check_filterable(expr)",
    ".django.db.models.sql.query.py@@Query.resolve_lookup_value": "def resolve_lookup_value(self, value, can_reuse, allow_joins):\n    if hasattr(value, 'resolve_expression'):\n        value = value.resolve_expression(self, reuse=can_reuse, allow_joins=allow_joins)\n    elif isinstance(value, (list, tuple)):\n        values = (self.resolve_lookup_value(sub_value, can_reuse, allow_joins) for sub_value in value)\n        type_ = type(value)\n        if hasattr(type_, '_make'):\n            return type_(*values)\n        return type_(values)\n    return value",
    ".django.db.models.sql.query.py@@Query.get_initial_alias": "def get_initial_alias(self):\n    if self.alias_map:\n        alias = self.base_table\n        self.ref_alias(alias)\n    else:\n        alias = self.join(self.base_table_class(self.get_meta().db_table, None))\n    return alias",
    ".django.db.models.sql.datastructures.py@@BaseTable.__init__": "def __init__(self, table_name, alias):\n    self.table_name = table_name\n    self.table_alias = alias",
    ".django.db.models.sql.query.py@@Query.join": "def join(self, join, reuse=None):\n    reuse_aliases = [a for a, j in self.alias_map.items() if (reuse is None or a in reuse) and j.equals(join)]\n    if reuse_aliases:\n        if join.table_alias in reuse_aliases:\n            reuse_alias = join.table_alias\n        else:\n            reuse_alias = reuse_aliases[-1]\n        self.ref_alias(reuse_alias)\n        return reuse_alias\n    alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)\n    if join.join_type:\n        if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n            join_type = LOUTER\n        else:\n            join_type = INNER\n        join.join_type = join_type\n    join.table_alias = alias\n    self.alias_map[alias] = join\n    return alias",
    ".django.db.models.sql.query.py@@Query.table_alias": "def table_alias(self, table_name, create=False, filtered_relation=None):\n    alias_list = self.table_map.get(table_name)\n    if not create and alias_list:\n        alias = alias_list[0]\n        self.alias_refcount[alias] += 1\n        return (alias, False)\n    if alias_list:\n        alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)\n        alias_list.append(alias)\n    else:\n        alias = filtered_relation.alias if filtered_relation is not None else table_name\n        self.table_map[table_name] = [alias]\n    self.alias_refcount[alias] = 1\n    return (alias, True)",
    ".django.db.models.sql.query.py@@Query.setup_joins": "def setup_joins(self, names, opts, alias, can_reuse=None, allow_many=True):\n    joins = [alias]\n\n    def final_transformer(field, alias):\n        if not self.alias_cols:\n            alias = None\n        return field.get_col(alias)\n    last_field_exception = None\n    for pivot in range(len(names), 0, -1):\n        try:\n            path, final_field, targets, rest = self.names_to_path(names[:pivot], opts, allow_many, fail_on_missing=True)\n        except FieldError as exc:\n            if pivot == 1:\n                raise\n            else:\n                last_field_exception = exc\n        else:\n            transforms = names[pivot:]\n            break\n    for name in transforms:\n\n        def transform(field, alias, *, name, previous):\n            try:\n                wrapped = previous(field, alias)\n                return self.try_transform(wrapped, name)\n            except FieldError:\n                if isinstance(final_field, Field) and last_field_exception:\n                    raise last_field_exception\n                else:\n                    raise\n        final_transformer = functools.partial(transform, name=name, previous=final_transformer)\n    for join in path:\n        if join.filtered_relation:\n            filtered_relation = join.filtered_relation.clone()\n            table_alias = filtered_relation.alias\n        else:\n            filtered_relation = None\n            table_alias = None\n        opts = join.to_opts\n        if join.direct:\n            nullable = self.is_nullable(join.join_field)\n        else:\n            nullable = True\n        connection = self.join_class(opts.db_table, alias, table_alias, INNER, join.join_field, nullable, filtered_relation=filtered_relation)\n        reuse = can_reuse if join.m2m else None\n        alias = self.join(connection, reuse=reuse)\n        joins.append(alias)\n        if filtered_relation:\n            filtered_relation.path = joins[:]\n    return JoinInfo(final_field, targets, opts, joins, path, final_transformer)",
    ".django.db.models.sql.query.py@@Query.check_related_objects": "def check_related_objects(self, field, value, opts):\n    if field.is_relation:\n        if isinstance(value, Query) and (not value.has_select_fields) and (not check_rel_lookup_compatibility(value.model, opts, field)):\n            raise ValueError('Cannot use QuerySet for \"%s\": Use a QuerySet for \"%s\".' % (value.model._meta.object_name, opts.object_name))\n        elif hasattr(value, '_meta'):\n            self.check_query_object_type(value, opts, field)\n        elif hasattr(value, '__iter__'):\n            for v in value:\n                self.check_query_object_type(v, opts, field)",
    ".django.db.models.sql.query.py@@Query.trim_joins": "def trim_joins(self, targets, joins, path):\n    joins = joins[:]\n    for pos, info in enumerate(reversed(path)):\n        if len(joins) == 1 or not info.direct:\n            break\n        if info.filtered_relation:\n            break\n        join_targets = {t.column for t in info.join_field.foreign_related_fields}\n        cur_targets = {t.column for t in targets}\n        if not cur_targets.issubset(join_targets):\n            break\n        targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}\n        targets = tuple((targets_dict[t.column] for t in targets))\n        self.unref_alias(joins.pop())\n    return (targets, joins[-1], joins)",
    ".django.db.models.sql.query.py@@Query._get_col": "def _get_col(self, target, field, alias):\n    if not self.alias_cols:\n        alias = None\n    return target.get_col(alias, field)",
    ".django.db.models.fields.__init__.py@@Field.get_col": "def get_col(self, alias, output_field=None):\n    if alias == self.model._meta.db_table and (output_field is None or output_field == self):\n        return self.cached_col\n    from django.db.models.expressions import Col\n    return Col(alias, self, output_field)",
    ".django.db.models.fields.__init__.py@@Field.__eq__": "def __eq__(self, other):\n    if isinstance(other, Field):\n        return self.creation_counter == other.creation_counter and getattr(self, 'model', None) == getattr(other, 'model', None)\n    return NotImplemented",
    ".django.db.models.sql.query.py@@Query.build_lookup": "def build_lookup(self, lookups, lhs, rhs):\n    *transforms, lookup_name = lookups or ['exact']\n    for name in transforms:\n        lhs = self.try_transform(lhs, name)\n    lookup_class = lhs.get_lookup(lookup_name)\n    if not lookup_class:\n        if lhs.field.is_relation:\n            raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))\n        lhs = self.try_transform(lhs, lookup_name)\n        lookup_name = 'exact'\n        lookup_class = lhs.get_lookup(lookup_name)\n        if not lookup_class:\n            return\n    lookup = lookup_class(lhs, rhs)\n    if lookup.rhs is None and (not lookup.can_use_none_as_rhs):\n        if lookup_name not in ('exact', 'iexact'):\n            raise ValueError('Cannot use None as a query value')\n        return lhs.get_lookup('isnull')(lhs, True)\n    if lookup_name == 'exact' and lookup.rhs == '' and connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls:\n        return lhs.get_lookup('isnull')(lhs, True)\n    return lookup",
    ".django.db.models.expressions.py@@BaseExpression.get_lookup": "def get_lookup(self, lookup):\n    return self.output_field.get_lookup(lookup)",
    ".django.db.models.query_utils.py@@RegisterLookupMixin.get_lookup": "def get_lookup(self, lookup_name):\n    from django.db.models.lookups import Lookup\n    found = self._get_lookup(lookup_name)\n    if found is None and hasattr(self, 'output_field'):\n        return self.output_field.get_lookup(lookup_name)\n    if found is not None and (not issubclass(found, Lookup)):\n        return None\n    return found",
    ".django.db.models.query_utils.py@@RegisterLookupMixin._get_lookup": "def _get_lookup(cls, lookup_name):\n    return cls.get_lookups().get(lookup_name, None)",
    ".django.utils.deconstruct.py@@__new__": "def __new__(cls, *args, **kwargs):\n    obj = super(klass, cls).__new__(cls)\n    obj._constructor_args = (args, kwargs)\n    return obj",
    ".django.db.models.lookups.py@@Lookup.__init__": "def __init__(self, lhs, rhs):\n    self.lhs, self.rhs = (lhs, rhs)\n    self.rhs = self.get_prep_lookup()\n    self.lhs = self.get_prep_lhs()\n    if hasattr(self.lhs, 'get_bilateral_transforms'):\n        bilateral_transforms = self.lhs.get_bilateral_transforms()\n    else:\n        bilateral_transforms = []\n    if bilateral_transforms:\n        from django.db.models.sql.query import Query\n        if isinstance(rhs, Query):\n            raise NotImplementedError('Bilateral transformations on nested querysets are not implemented.')\n    self.bilateral_transforms = bilateral_transforms",
    ".django.db.models.lookups.py@@In.get_prep_lookup": "def get_prep_lookup(self):\n    from django.db.models.sql.query import Query\n    if isinstance(self.rhs, Query):\n        self.rhs.clear_ordering(clear_default=True)\n        if not self.rhs.has_select_fields:\n            self.rhs.clear_select_clause()\n            self.rhs.add_fields(['pk'])\n    return super().get_prep_lookup()",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueIterableMixin.get_prep_lookup": "def get_prep_lookup(self):\n    if hasattr(self.rhs, 'resolve_expression'):\n        return self.rhs\n    prepared_values = []\n    for rhs_value in self.rhs:\n        if hasattr(rhs_value, 'resolve_expression'):\n            pass\n        elif self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):\n            rhs_value = self.lhs.output_field.get_prep_value(rhs_value)\n        prepared_values.append(rhs_value)\n    return prepared_values",
    ".django.db.models.fields.__init__.py@@IntegerField.get_prep_value": "def get_prep_value(self, value):\n    value = super().get_prep_value(value)\n    if value is None:\n        return None\n    try:\n        return int(value)\n    except (TypeError, ValueError) as e:\n        raise e.__class__(\"Field '%s' expected a number but got %r.\" % (self.name, value)) from e",
    ".django.db.models.fields.__init__.py@@Field.get_prep_value": "def get_prep_value(self, value):\n    if isinstance(value, Promise):\n        value = value._proxy____cast()\n    return value",
    ".django.db.models.lookups.py@@Lookup.get_prep_lhs": "def get_prep_lhs(self):\n    if hasattr(self.lhs, 'resolve_expression'):\n        return self.lhs\n    return Value(self.lhs)",
    ".django.db.models.sql.query.py@@JoinPromoter.add_votes": "def add_votes(self, votes):\n    self.votes.update(votes)",
    ".django.utils.tree.py@@Node.__bool__": "def __bool__(self):\n    return bool(self.children)",
    ".django.utils.tree.py@@Node.add": "def add(self, data, conn_type):\n    if self.connector != conn_type:\n        obj = self._new_instance(self.children, self.connector, self.negated)\n        self.connector = conn_type\n        self.children = [obj, data]\n        return data\n    elif isinstance(data, Node) and (not data.negated) and (data.connector == conn_type or len(data) == 1):\n        self.children.extend(data.children)\n        return self\n    else:\n        self.children.append(data)\n        return data",
    ".django.db.models.sql.query.py@@JoinPromoter.update_join_types": "def update_join_types(self, query):\n    to_promote = set()\n    to_demote = set()\n    for table, votes in self.votes.items():\n        if self.effective_connector == 'OR' and votes < self.num_children:\n            to_promote.add(table)\n        if self.effective_connector == 'AND' or (self.effective_connector == 'OR' and votes == self.num_children):\n            to_demote.add(table)\n    query.promote_joins(to_promote)\n    query.demote_joins(to_demote)\n    return to_demote",
    ".django.db.models.sql.query.py@@Query.promote_joins": "def promote_joins(self, aliases):\n    aliases = list(aliases)\n    while aliases:\n        alias = aliases.pop(0)\n        if self.alias_map[alias].join_type is None:\n            continue\n        assert self.alias_map[alias].join_type is not None\n        parent_alias = self.alias_map[alias].parent_alias\n        parent_louter = parent_alias and self.alias_map[parent_alias].join_type == LOUTER\n        already_louter = self.alias_map[alias].join_type == LOUTER\n        if (self.alias_map[alias].nullable or parent_louter) and (not already_louter):\n            self.alias_map[alias] = self.alias_map[alias].promote()\n            aliases.extend((join for join in self.alias_map if self.alias_map[join].parent_alias == alias and join not in aliases))",
    ".django.db.models.sql.query.py@@Query.demote_joins": "def demote_joins(self, aliases):\n    aliases = list(aliases)\n    while aliases:\n        alias = aliases.pop(0)\n        if self.alias_map[alias].join_type == LOUTER:\n            self.alias_map[alias] = self.alias_map[alias].demote()\n            parent_alias = self.alias_map[alias].parent_alias\n            if self.alias_map[parent_alias].join_type == INNER:\n                aliases.append(parent_alias)",
    ".django.db.models.sql.subqueries.py@@DeleteQuery.do_query": "def do_query(self, table, where, using):\n    self.alias_map = {table: self.alias_map[table]}\n    self.where = where\n    cursor = self.get_compiler(using).execute_sql(CURSOR)\n    if cursor:\n        with cursor:\n            return cursor.rowcount\n    return 0",
    ".django.db.models.sql.query.py@@Query.get_compiler": "def get_compiler(self, using=None, connection=None, elide_empty=True):\n    if using is None and connection is None:\n        raise ValueError('Need either using or connection')\n    if using:\n        connection = connections[using]\n    return connection.ops.compiler(self.compiler)(self, connection, using, elide_empty)",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.compiler": "def compiler(self, compiler_name):\n    if self._cache is None:\n        self._cache = import_module(self.compiler_module)\n    return getattr(self._cache, compiler_name)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.__init__": "def __init__(self, query, connection, using, elide_empty=True):\n    self.query = query\n    self.connection = connection\n    self.using = using\n    self.elide_empty = elide_empty\n    self.quote_cache = {'*': '*'}\n    self.select = None\n    self.annotation_col_map = None\n    self.klass_info = None\n    self._meta_ordering = None",
    ".django.db.models.sql.compiler.py@@SQLCompiler.execute_sql": "def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n    result_type = result_type or NO_RESULTS\n    try:\n        sql, params = self.as_sql()\n        if not sql:\n            raise EmptyResultSet\n    except EmptyResultSet:\n        if result_type == MULTI:\n            return iter([])\n        else:\n            return\n    if chunked_fetch:\n        cursor = self.connection.chunked_cursor()\n    else:\n        cursor = self.connection.cursor()\n    try:\n        cursor.execute(sql, params)\n    except Exception:\n        cursor.close()\n        raise\n    if result_type == CURSOR:\n        return cursor\n    if result_type == SINGLE:\n        try:\n            val = cursor.fetchone()\n            if val:\n                return val[0:self.col_count]\n            return val\n        finally:\n            cursor.close()\n    if result_type == NO_RESULTS:\n        cursor.close()\n        return\n    result = cursor_iter(cursor, self.connection.features.empty_fetchmany_value, self.col_count if self.has_extra_select else None, chunk_size)\n    if not chunked_fetch or not self.connection.features.can_use_chunked_reads:\n        return list(result)\n    return result",
    ".django.db.models.sql.compiler.py@@SQLDeleteCompiler.as_sql": "def as_sql(self):\n    if self.single_alias and (not self.contains_self_reference_subquery):\n        return self._as_sql(self.query)\n    innerq = self.query.clone()\n    innerq.__class__ = Query\n    innerq.clear_select_clause()\n    pk = self.query.model._meta.pk\n    innerq.select = [pk.get_col(self.query.get_initial_alias())]\n    outerq = Query(self.query.model)\n    if not self.connection.features.update_can_self_select:\n        sql, params = innerq.get_compiler(connection=self.connection).as_sql()\n        innerq = RawSQL('SELECT * FROM (%s) subquery' % sql, params)\n    outerq.add_filter('pk__in', innerq)\n    return self._as_sql(outerq)",
    ".django.db.models.sql.compiler.py@@SQLDeleteCompiler.single_alias": "def single_alias(self):\n    self.query.get_initial_alias()\n    return sum((self.query.alias_refcount[t] > 0 for t in self.query.alias_map)) == 1",
    ".django.db.models.sql.query.py@@Query.base_table": "def base_table(self):\n    for alias in self.alias_map:\n        return alias",
    ".django.db.models.sql.query.py@@Query.ref_alias": "def ref_alias(self, alias):\n    self.alias_refcount[alias] += 1",
    ".django.db.models.sql.compiler.py@@SQLDeleteCompiler.contains_self_reference_subquery": "def contains_self_reference_subquery(self):\n    return any((self._expr_refs_base_model(expr, self.query.model) for expr in chain(self.query.annotations.values(), self.query.where.children)))",
    ".django.db.models.sql.compiler.py@@SQLDeleteCompiler._expr_refs_base_model": "def _expr_refs_base_model(cls, expr, base_model):\n    if isinstance(expr, Query):\n        return expr.model == base_model\n    if not hasattr(expr, 'get_source_expressions'):\n        return False\n    return any((cls._expr_refs_base_model(source_expr, base_model) for source_expr in expr.get_source_expressions()))",
    ".django.db.models.lookups.py@@Lookup.get_source_expressions": "def get_source_expressions(self):\n    if self.rhs_is_direct_value():\n        return [self.lhs]\n    return [self.lhs, self.rhs]",
    ".django.db.models.lookups.py@@Lookup.rhs_is_direct_value": "def rhs_is_direct_value(self):\n    return not hasattr(self.rhs, 'as_sql')",
    ".django.db.models.expressions.py@@BaseExpression.get_source_expressions": "def get_source_expressions(self):\n    return []",
    ".django.db.models.sql.compiler.py@@SQLDeleteCompiler._as_sql": "def _as_sql(self, query):\n    result = ['DELETE FROM %s' % self.quote_name_unless_alias(query.base_table)]\n    where, params = self.compile(query.where)\n    if where:\n        result.append('WHERE %s' % where)\n    return (' '.join(result), tuple(params))",
    ".django.db.models.sql.compiler.py@@SQLCompiler.quote_name_unless_alias": "def quote_name_unless_alias(self, name):\n    if name in self.quote_cache:\n        return self.quote_cache[name]\n    if name in self.query.alias_map and name not in self.query.table_map or name in self.query.extra_select or (self.query.external_aliases.get(name) and name not in self.query.table_map):\n        self.quote_cache[name] = name\n        return name\n    r = self.connection.ops.quote_name(name)\n    self.quote_cache[name] = r\n    return r",
    ".django.db.models.sql.query.py@@Query.extra_select": "def extra_select(self):\n    if self._extra_select_cache is not None:\n        return self._extra_select_cache\n    if not self.extra:\n        return {}\n    elif self.extra_select_mask is not None:\n        self._extra_select_cache = {k: v for k, v in self.extra.items() if k in self.extra_select_mask}\n        return self._extra_select_cache\n    else:\n        return self.extra",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.quote_name": "def quote_name(self, name):\n    if name.startswith('\"') and name.endswith('\"'):\n        return name\n    return '\"%s\"' % name",
    ".django.db.models.sql.compiler.py@@SQLCompiler.compile": "def compile(self, node):\n    vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)\n    if vendor_impl:\n        sql, params = vendor_impl(self, self.connection)\n    else:\n        sql, params = node.as_sql(self, self.connection)\n    return (sql, params)",
    ".django.db.models.sql.where.py@@WhereNode.as_sql": "def as_sql(self, compiler, connection):\n    result = []\n    result_params = []\n    if self.connector == AND:\n        full_needed, empty_needed = (len(self.children), 1)\n    else:\n        full_needed, empty_needed = (1, len(self.children))\n    for child in self.children:\n        try:\n            sql, params = compiler.compile(child)\n        except EmptyResultSet:\n            empty_needed -= 1\n        else:\n            if sql:\n                result.append(sql)\n                result_params.extend(params)\n            else:\n                full_needed -= 1\n        if empty_needed == 0:\n            if self.negated:\n                return ('', [])\n            else:\n                raise EmptyResultSet\n        if full_needed == 0:\n            if self.negated:\n                raise EmptyResultSet\n            else:\n                return ('', [])\n    conn = ' %s ' % self.connector\n    sql_string = conn.join(result)\n    if sql_string:\n        if self.negated:\n            sql_string = 'NOT (%s)' % sql_string\n        elif len(result) > 1 or self.resolved:\n            sql_string = '(%s)' % sql_string\n    return (sql_string, result_params)",
    ".django.db.models.lookups.py@@In.as_sql": "def as_sql(self, compiler, connection):\n    max_in_list_size = connection.ops.max_in_list_size()\n    if self.rhs_is_direct_value() and max_in_list_size and (len(self.rhs) > max_in_list_size):\n        return self.split_parameter_list_as_sql(compiler, connection)\n    return super().as_sql(compiler, connection)",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.max_in_list_size": "def max_in_list_size(self):\n    return None",
    ".django.db.models.lookups.py@@BuiltinLookup.as_sql": "def as_sql(self, compiler, connection):\n    lhs_sql, params = self.process_lhs(compiler, connection)\n    rhs_sql, rhs_params = self.process_rhs(compiler, connection)\n    params.extend(rhs_params)\n    rhs_sql = self.get_rhs_op(connection, rhs_sql)\n    return ('%s %s' % (lhs_sql, rhs_sql), params)",
    ".django.db.models.lookups.py@@BuiltinLookup.process_lhs": "def process_lhs(self, compiler, connection, lhs=None):\n    lhs_sql, params = super().process_lhs(compiler, connection, lhs)\n    field_internal_type = self.lhs.output_field.get_internal_type()\n    db_type = self.lhs.output_field.db_type(connection=connection)\n    lhs_sql = connection.ops.field_cast_sql(db_type, field_internal_type) % lhs_sql\n    lhs_sql = connection.ops.lookup_cast(self.lookup_name, field_internal_type) % lhs_sql\n    return (lhs_sql, list(params))",
    ".django.db.models.lookups.py@@Lookup.process_lhs": "def process_lhs(self, compiler, connection, lhs=None):\n    lhs = lhs or self.lhs\n    if hasattr(lhs, 'resolve_expression'):\n        lhs = lhs.resolve_expression(compiler.query)\n    sql, params = compiler.compile(lhs)\n    if isinstance(lhs, Lookup):\n        sql = f'({sql})'\n    return (sql, params)",
    ".django.db.models.expressions.py@@BaseExpression.resolve_expression": "def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n    c = self.copy()\n    c.is_summary = summarize\n    c.set_source_expressions([expr.resolve_expression(query, allow_joins, reuse, summarize) if expr else None for expr in c.get_source_expressions()])\n    return c",
    ".django.db.models.expressions.py@@BaseExpression.copy": "def copy(self):\n    return copy.copy(self)",
    ".django.db.models.expressions.py@@BaseExpression.__getstate__": "def __getstate__(self):\n    state = self.__dict__.copy()\n    state.pop('convert_value', None)\n    return state",
    ".django.db.models.expressions.py@@BaseExpression.set_source_expressions": "def set_source_expressions(self, exprs):\n    assert not exprs",
    ".django.db.models.expressions.py@@Col.as_sql": "def as_sql(self, compiler, connection):\n    alias, column = (self.alias, self.target.column)\n    identifiers = (alias, column) if alias else (column,)\n    sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))\n    return (sql, [])",
    ".django.db.models.fields.__init__.py@@AutoField.get_internal_type": "def get_internal_type(self):\n    return 'AutoField'",
    ".django.db.models.fields.__init__.py@@Field.db_type": "def db_type(self, connection):\n    data = self.db_type_parameters(connection)\n    try:\n        return connection.data_types[self.get_internal_type()] % data\n    except KeyError:\n        return None",
    ".django.db.models.fields.__init__.py@@Field.db_type_parameters": "def db_type_parameters(self, connection):\n    return DictWrapper(self.__dict__, connection.ops.quote_name, 'qn_')",
    ".django.utils.datastructures.py@@DictWrapper.__init__": "def __init__(self, data, func, prefix):\n    super().__init__(data)\n    self.func = func\n    self.prefix = prefix",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.field_cast_sql": "def field_cast_sql(self, db_type, internal_type):\n    return '%s'",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.lookup_cast": "def lookup_cast(self, lookup_type, internal_type=None):\n    return '%s'",
    ".django.db.models.lookups.py@@In.process_rhs": "def process_rhs(self, compiler, connection):\n    db_rhs = getattr(self.rhs, '_db', None)\n    if db_rhs is not None and db_rhs != connection.alias:\n        raise ValueError(\"Subqueries aren't allowed across different databases. Force the inner query to be evaluated using `list(inner_query)`.\")\n    if self.rhs_is_direct_value():\n        try:\n            rhs = OrderedSet(self.rhs)\n            rhs.discard(None)\n        except TypeError:\n            rhs = [r for r in self.rhs if r is not None]\n        if not rhs:\n            raise EmptyResultSet\n        sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\n        placeholder = '(' + ', '.join(sqls) + ')'\n        return (placeholder, sqls_params)\n    return super().process_rhs(compiler, connection)",
    ".django.utils.datastructures.py@@OrderedSet.__init__": "def __init__(self, iterable=None):\n    self.dict = dict.fromkeys(iterable or ())",
    ".django.utils.datastructures.py@@OrderedSet.discard": "def discard(self, item):\n    try:\n        self.remove(item)\n    except KeyError:\n        pass",
    ".django.utils.datastructures.py@@OrderedSet.remove": "def remove(self, item):\n    del self.dict[item]",
    ".django.utils.datastructures.py@@OrderedSet.__bool__": "def __bool__(self):\n    return bool(self.dict)",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueIterableMixin.batch_process_rhs": "def batch_process_rhs(self, compiler, connection, rhs=None):\n    pre_processed = super().batch_process_rhs(compiler, connection, rhs)\n    sql, params = zip(*(self.resolve_expression_parameter(compiler, connection, sql, param) for sql, param in zip(*pre_processed)))\n    params = itertools.chain.from_iterable(params)\n    return (sql, tuple(params))",
    ".django.db.models.lookups.py@@Lookup.batch_process_rhs": "def batch_process_rhs(self, compiler, connection, rhs=None):\n    if rhs is None:\n        rhs = self.rhs\n    if self.bilateral_transforms:\n        sqls, sqls_params = ([], [])\n        for p in rhs:\n            value = Value(p, output_field=self.lhs.output_field)\n            value = self.apply_bilateral_transforms(value)\n            value = value.resolve_expression(compiler.query)\n            sql, sql_params = compiler.compile(value)\n            sqls.append(sql)\n            sqls_params.extend(sql_params)\n    else:\n        _, params = self.get_db_prep_lookup(rhs, connection)\n        sqls, sqls_params = (['%s'] * len(params), params)\n    return (sqls, sqls_params)",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueMixin.get_db_prep_lookup": "def get_db_prep_lookup(self, value, connection):\n    field = getattr(self.lhs.output_field, 'target_field', None)\n    get_db_prep_value = getattr(field, 'get_db_prep_value', None) or self.lhs.output_field.get_db_prep_value\n    return ('%s', [get_db_prep_value(v, connection, prepared=True) for v in value] if self.get_db_prep_lookup_value_is_iterable else [get_db_prep_value(value, connection, prepared=True)])",
    ".django.utils.datastructures.py@@OrderedSet.__iter__": "def __iter__(self):\n    return iter(self.dict)",
    ".django.db.models.fields.__init__.py@@AutoFieldMixin.get_db_prep_value": "def get_db_prep_value(self, value, connection, prepared=False):\n    if not prepared:\n        value = self.get_prep_value(value)\n        value = connection.ops.validate_autopk_value(value)\n    return value",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueIterableMixin.resolve_expression_parameter": "def resolve_expression_parameter(self, compiler, connection, sql, param):\n    params = [param]\n    if hasattr(param, 'resolve_expression'):\n        param = param.resolve_expression(compiler.query)\n    if hasattr(param, 'as_sql'):\n        sql, params = compiler.compile(param)\n    return (sql, params)",
    ".django.db.models.lookups.py@@In.get_rhs_op": "def get_rhs_op(self, connection, rhs):\n    return 'IN %s' % rhs",
    ".django.utils.asyncio.py@@inner": "def inner(*args, **kwargs):\n    try:\n        get_running_loop()\n    except RuntimeError:\n        pass\n    else:\n        if not os.environ.get('DJANGO_ALLOW_ASYNC_UNSAFE'):\n            raise SynchronousOnlyOperation(message)\n    return func(*args, **kwargs)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.cursor": "def cursor(self):\n    return self._cursor()",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper._cursor": "def _cursor(self, name=None):\n    self.close_if_health_check_failed()\n    self.ensure_connection()\n    with self.wrap_database_errors:\n        return self._prepare_cursor(self.create_cursor(name))",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.close_if_health_check_failed": "def close_if_health_check_failed(self):\n    if self.connection is None or not self.health_check_enabled or self.health_check_done:\n        return\n    if not self.is_usable():\n        self.close()\n    self.health_check_done = True",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.ensure_connection": "def ensure_connection(self):\n    if self.connection is None:\n        with self.wrap_database_errors:\n            self.connect()",
    ".django.db.utils.py@@DatabaseErrorWrapper.__enter__": "def __enter__(self):\n    pass",
    ".django.db.backends.sqlite3.base.py@@DatabaseWrapper.create_cursor": "def create_cursor(self, name=None):\n    return self.connection.cursor(factory=SQLiteCursorWrapper)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper._prepare_cursor": "def _prepare_cursor(self, cursor):\n    self.validate_thread_sharing()\n    if self.queries_logged:\n        wrapped_cursor = self.make_debug_cursor(cursor)\n    else:\n        wrapped_cursor = self.make_cursor(cursor)\n    return wrapped_cursor",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.validate_thread_sharing": "def validate_thread_sharing(self):\n    if not (self.allow_thread_sharing or self._thread_ident == _thread.get_ident()):\n        raise DatabaseError(\"DatabaseWrapper objects created in a thread can only be used in that same thread. The object with alias '%s' was created in thread id %s and this is thread id %s.\" % (self.alias, self._thread_ident, _thread.get_ident()))",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.allow_thread_sharing": "def allow_thread_sharing(self):\n    with self._thread_sharing_lock:\n        return self._thread_sharing_count > 0",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.queries_logged": "def queries_logged(self):\n    return self.force_debug_cursor or settings.DEBUG",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.make_cursor": "def make_cursor(self, cursor):\n    return utils.CursorWrapper(cursor, self)",
    ".django.db.backends.utils.py@@CursorWrapper.__init__": "def __init__(self, cursor, db):\n    self.cursor = cursor\n    self.db = db",
    ".django.db.utils.py@@DatabaseErrorWrapper.__exit__": "def __exit__(self, exc_type, exc_value, traceback):\n    if exc_type is None:\n        return\n    for dj_exc_type in (DataError, OperationalError, IntegrityError, InternalError, ProgrammingError, NotSupportedError, DatabaseError, InterfaceError, Error):\n        db_exc_type = getattr(self.wrapper.Database, dj_exc_type.__name__)\n        if issubclass(exc_type, db_exc_type):\n            dj_exc_value = dj_exc_type(*exc_value.args)\n            if dj_exc_type not in (DataError, IntegrityError):\n                self.wrapper.errors_occurred = True\n            raise dj_exc_value.with_traceback(traceback) from exc_value",
    ".django.db.backends.utils.py@@CursorWrapper.execute": "def execute(self, sql, params=None):\n    return self._execute_with_wrappers(sql, params, many=False, executor=self._execute)",
    ".django.db.backends.utils.py@@CursorWrapper._execute_with_wrappers": "def _execute_with_wrappers(self, sql, params, many, executor):\n    context = {'connection': self.db, 'cursor': self}\n    for wrapper in reversed(self.db.execute_wrappers):\n        executor = functools.partial(wrapper, executor)\n    return executor(sql, params, many, context)",
    ".django.db.backends.utils.py@@CursorWrapper._execute": "def _execute(self, sql, params, *ignored_wrapper_args):\n    self.db.validate_no_broken_transaction()\n    with self.db.wrap_database_errors:\n        if params is None:\n            return self.cursor.execute(sql)\n        else:\n            return self.cursor.execute(sql, params)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.validate_no_broken_transaction": "def validate_no_broken_transaction(self):\n    if self.needs_rollback:\n        raise TransactionManagementError(\"An error occurred in the current transaction. You can't execute queries until the end of the 'atomic' block.\")",
    ".django.db.backends.sqlite3.base.py@@SQLiteCursorWrapper.execute": "def execute(self, query, params=None):\n    if params is None:\n        return Database.Cursor.execute(self, query)\n    query = self.convert_query(query)\n    return Database.Cursor.execute(self, query, params)",
    ".django.db.backends.sqlite3.base.py@@SQLiteCursorWrapper.convert_query": "def convert_query(self, query):\n    return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')",
    ".django.utils.functional.py@@inner": "def inner(self, *args):\n    if self._wrapped is empty:\n        self._setup()\n    return func(self._wrapped, *args)",
    ".django.db.backends.utils.py@@CursorWrapper.__enter__": "def __enter__(self):\n    return self",
    ".django.db.backends.utils.py@@CursorWrapper.__getattr__": "def __getattr__(self, attr):\n    cursor_attr = getattr(self.cursor, attr)\n    if attr in CursorWrapper.WRAP_ERROR_ATTRS:\n        return self.db.wrap_database_errors(cursor_attr)\n    else:\n        return cursor_attr",
    ".django.db.backends.utils.py@@CursorWrapper.__exit__": "def __exit__(self, type, value, traceback):\n    try:\n        self.close()\n    except self.db.Database.Error:\n        pass",
    ".django.db.models.options.py@@Options.label": "def label(self):\n    return '%s.%s' % (self.app_label, self.object_name)",
    ".django.db.transaction.py@@Atomic.__exit__": "def __exit__(self, exc_type, exc_value, traceback):\n    connection = get_connection(self.using)\n    if connection.in_atomic_block:\n        connection.atomic_blocks.pop()\n    if connection.savepoint_ids:\n        sid = connection.savepoint_ids.pop()\n    else:\n        connection.in_atomic_block = False\n    try:\n        if connection.closed_in_transaction:\n            pass\n        elif exc_type is None and (not connection.needs_rollback):\n            if connection.in_atomic_block:\n                if sid is not None:\n                    try:\n                        connection.savepoint_commit(sid)\n                    except DatabaseError:\n                        try:\n                            connection.savepoint_rollback(sid)\n                            connection.savepoint_commit(sid)\n                        except Error:\n                            connection.needs_rollback = True\n                        raise\n            else:\n                try:\n                    connection.commit()\n                except DatabaseError:\n                    try:\n                        connection.rollback()\n                    except Error:\n                        connection.close()\n                    raise\n        else:\n            connection.needs_rollback = False\n            if connection.in_atomic_block:\n                if sid is None:\n                    connection.needs_rollback = True\n                else:\n                    try:\n                        connection.savepoint_rollback(sid)\n                        connection.savepoint_commit(sid)\n                    except Error:\n                        connection.needs_rollback = True\n            else:\n                try:\n                    connection.rollback()\n                except Error:\n                    connection.close()\n    finally:\n        if not connection.in_atomic_block:\n            if connection.closed_in_transaction:\n                connection.connection = None\n            else:\n                connection.set_autocommit(True)\n        elif not connection.savepoint_ids and (not connection.commit_on_exit):\n            if connection.closed_in_transaction:\n                connection.connection = None\n            else:\n                connection.in_atomic_block = False"
}