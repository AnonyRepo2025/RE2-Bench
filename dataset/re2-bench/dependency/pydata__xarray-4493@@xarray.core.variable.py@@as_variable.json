{
    ".xarray.core.variable.py@@Variable.__init__": "def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):\n    self._data = as_compatible_data(data, fastpath=fastpath)\n    self._dims = self._parse_dimensions(dims)\n    self._attrs = None\n    self._encoding = None\n    if attrs is not None:\n        self.attrs = attrs\n    if encoding is not None:\n        self.encoding = encoding",
    ".xarray.core.variable.py@@as_compatible_data": "def as_compatible_data(data, fastpath=False):\n    if fastpath and getattr(data, 'ndim', 0) > 0:\n        return _maybe_wrap_data(data)\n    if isinstance(data, Variable):\n        return data.data\n    if isinstance(data, NON_NUMPY_SUPPORTED_ARRAY_TYPES):\n        return _maybe_wrap_data(data)\n    if isinstance(data, tuple):\n        data = utils.to_0d_object_array(data)\n    if isinstance(data, pd.Timestamp):\n        data = np.datetime64(data.value, 'ns')\n    if isinstance(data, timedelta):\n        data = np.timedelta64(getattr(data, 'value', data), 'ns')\n    data = getattr(data, 'values', data)\n    if isinstance(data, np.ma.MaskedArray):\n        mask = np.ma.getmaskarray(data)\n        if mask.any():\n            dtype, fill_value = dtypes.maybe_promote(data.dtype)\n            data = np.asarray(data, dtype=dtype)\n            data[mask] = fill_value\n        else:\n            data = np.asarray(data)\n    if not isinstance(data, np.ndarray):\n        if hasattr(data, '__array_function__'):\n            if IS_NEP18_ACTIVE:\n                return data\n            else:\n                raise TypeError('Got an NumPy-like array type providing the __array_function__ protocol but NEP18 is not enabled. Check that numpy >= v1.16 and that the environment variable \"NUMPY_EXPERIMENTAL_ARRAY_FUNCTION\" is set to \"1\"')\n    data = np.asarray(data)\n    if isinstance(data, np.ndarray):\n        if data.dtype.kind == 'O':\n            data = _possibly_convert_objects(data)\n        elif data.dtype.kind == 'M':\n            data = _possibly_convert_objects(data)\n        elif data.dtype.kind == 'm':\n            data = _possibly_convert_objects(data)\n    return _maybe_wrap_data(data)",
    ".xarray.core.variable.py@@_maybe_wrap_data": "def _maybe_wrap_data(data):\n    if isinstance(data, pd.Index):\n        return PandasIndexAdapter(data)\n    return data",
    ".xarray.core.variable.py@@Variable._parse_dimensions": "def _parse_dimensions(self, dims):\n    if isinstance(dims, str):\n        dims = (dims,)\n    dims = tuple(dims)\n    if len(dims) != self.ndim:\n        raise ValueError('dimensions %s must have the same length as the number of data dimensions, ndim=%s' % (dims, self.ndim))\n    return dims",
    ".xarray.core.utils.py@@NdimSizeLenMixin.ndim": "def ndim(self: Any) -> int:\n    return len(self.shape)",
    ".xarray.core.variable.py@@Variable.shape": "def shape(self):\n    return self._data.shape",
    ".xarray.core.variable.py@@Variable.dims": "def dims(self):\n    return self._dims",
    ".xarray.core.utils.py@@is_scalar": "def is_scalar(value: Any, include_0d: bool=True) -> bool:\n    from .variable import NON_NUMPY_SUPPORTED_ARRAY_TYPES\n    if include_0d:\n        include_0d = getattr(value, 'ndim', None) == 0\n    return include_0d or isinstance(value, (str, bytes)) or (not (isinstance(value, (Iterable,) + NON_NUMPY_SUPPORTED_ARRAY_TYPES) or hasattr(value, '__array_function__')))",
    ".xarray.core.variable.py@@Variable.to_index_variable": "def to_index_variable(self):\n    return IndexVariable(self.dims, self._data, self._attrs, encoding=self._encoding, fastpath=True)",
    ".xarray.core.variable.py@@IndexVariable.__init__": "def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):\n    super().__init__(dims, data, attrs, encoding, fastpath)\n    if self.ndim != 1:\n        raise ValueError('%s objects must be 1-dimensional' % type(self).__name__)\n    if not isinstance(self._data, PandasIndexAdapter):\n        self._data = PandasIndexAdapter(self._data)",
    ".xarray.core.indexing.py@@PandasIndexAdapter.__init__": "def __init__(self, array: Any, dtype: DTypeLike=None):\n    self.array = utils.safe_cast_to_index(array)\n    if dtype is None:\n        if isinstance(array, pd.PeriodIndex):\n            dtype = np.dtype('O')\n        elif hasattr(array, 'categories'):\n            dtype = array.categories.dtype\n        elif not utils.is_valid_numpy_dtype(array.dtype):\n            dtype = np.dtype('O')\n        else:\n            dtype = array.dtype\n    else:\n        dtype = np.dtype(dtype)\n    self._dtype = dtype",
    ".xarray.core.utils.py@@safe_cast_to_index": "def safe_cast_to_index(array: Any) -> pd.Index:\n    if isinstance(array, pd.Index):\n        index = array\n    elif hasattr(array, 'to_index'):\n        index = array.to_index()\n    else:\n        kwargs = {}\n        if hasattr(array, 'dtype') and array.dtype.kind == 'O':\n            kwargs['dtype'] = object\n        index = pd.Index(np.asarray(array), **kwargs)\n    return _maybe_cast_to_cftimeindex(index)",
    ".xarray.core.utils.py@@_maybe_cast_to_cftimeindex": "def _maybe_cast_to_cftimeindex(index: pd.Index) -> pd.Index:\n    from ..coding.cftimeindex import CFTimeIndex\n    if len(index) > 0 and index.dtype == 'O':\n        try:\n            return CFTimeIndex(index)\n        except (ImportError, TypeError):\n            return index\n    else:\n        return index",
    ".xarray.core.utils.py@@is_valid_numpy_dtype": "def is_valid_numpy_dtype(dtype: Any) -> bool:\n    try:\n        np.dtype(dtype)\n    except (TypeError, ValueError):\n        return False\n    else:\n        return True",
    ".xarray.core.variable.py@@IndexVariable.copy": "def copy(self, deep=True, data=None):\n    if data is None:\n        data = self._data.copy(deep=deep)\n    else:\n        data = as_compatible_data(data)\n        if self.shape != data.shape:\n            raise ValueError('Data shape {} must match shape of object {}'.format(data.shape, self.shape))\n    return type(self)(self.dims, data, self._attrs, self._encoding, fastpath=True)",
    ".xarray.core.indexing.py@@PandasIndexAdapter.copy": "def copy(self, deep: bool=True) -> 'PandasIndexAdapter':\n    array = self.array.copy(deep=True) if deep else self.array\n    return PandasIndexAdapter(array, self._dtype)",
    ".xarray.core.indexing.py@@PandasIndexAdapter.shape": "def shape(self) -> Tuple[int]:\n    return (len(self.array),)",
    ".xarray.core.variable.py@@IndexVariable.to_index_variable": "def to_index_variable(self):\n    return self",
    ".xarray.core.variable.py@@Variable.attrs": "def attrs(self) -> Dict[Hashable, Any]:\n    if self._attrs is None:\n        self._attrs = {}\n    return self._attrs",
    ".xarray.core.variable.py@@Variable.copy": "def copy(self, deep=True, data=None):\n    if data is None:\n        data = self._data\n        if isinstance(data, indexing.MemoryCachedArray):\n            data = indexing.MemoryCachedArray(data.array)\n        if deep:\n            data = copy.deepcopy(data)\n    else:\n        data = as_compatible_data(data)\n        if self.shape != data.shape:\n            raise ValueError('Data shape {} must match shape of object {}'.format(data.shape, self.shape))\n    return self._replace(data=data)",
    ".xarray.core.variable.py@@Variable._replace": "def _replace(self, dims=_default, data=_default, attrs=_default, encoding=_default) -> 'Variable':\n    if dims is _default:\n        dims = copy.copy(self._dims)\n    if data is _default:\n        data = copy.copy(self.data)\n    if attrs is _default:\n        attrs = copy.copy(self._attrs)\n    if encoding is _default:\n        encoding = copy.copy(self._encoding)\n    return type(self)(dims, data, attrs, encoding, fastpath=True)",
    ".xarray.core.dataarray.py@@DataArray.variable": "def variable(self) -> Variable:\n    return self._variable",
    ".xarray.core.variable.py@@Variable.encoding": "def encoding(self):\n    if self._encoding is None:\n        self._encoding = {}\n    return self._encoding",
    ".xarray.core.utils.py@@ReprObject.__eq__": "def __eq__(self, other) -> bool:\n    if isinstance(other, ReprObject):\n        return self._value == other._value\n    return False",
    ".xarray.coding.cftimeindex.py@@CFTimeIndex.__new__": "def __new__(cls, data, name=None):\n    assert_all_valid_date_type(data)\n    if name is None and hasattr(data, 'name'):\n        name = data.name\n    result = object.__new__(cls)\n    result._data = np.array(data, dtype='O')\n    result.name = name\n    result._cache = {}\n    return result",
    ".xarray.coding.cftimeindex.py@@assert_all_valid_date_type": "def assert_all_valid_date_type(data):\n    import cftime\n    if len(data) > 0:\n        sample = data[0]\n        date_type = type(sample)\n        if not isinstance(sample, cftime.datetime):\n            raise TypeError('CFTimeIndex requires cftime.datetime objects. Got object of {}.'.format(date_type))\n        if not all((isinstance(value, date_type) for value in data)):\n            raise TypeError('CFTimeIndex requires using datetime objects of all the same type.  Got\\n{}.'.format(data))",
    ".xarray.core.indexing.py@@LazilyOuterIndexedArray.shape": "def shape(self):\n    shape = []\n    for size, k in zip(self.array.shape, self.key.tuple):\n        if isinstance(k, slice):\n            shape.append(len(range(*k.indices(size))))\n        elif isinstance(k, np.ndarray):\n            shape.append(k.size)\n    return tuple(shape)",
    ".xarray.core.indexing.py@@ExplicitIndexer.tuple": "def tuple(self):\n    return self._key",
    ".xarray.core.utils.py@@NDArrayMixin.dtype": "def dtype(self: Any) -> np.dtype:\n    return self.array.dtype",
    ".xarray.core.indexing.py@@LazilyOuterIndexedArray.__array__": "def __array__(self, dtype=None):\n    array = as_indexable(self.array)\n    return np.asarray(array[self.key], dtype=None)",
    ".xarray.core.indexing.py@@as_indexable": "def as_indexable(array):\n    if isinstance(array, ExplicitlyIndexed):\n        return array\n    if isinstance(array, np.ndarray):\n        return NumpyIndexingAdapter(array)\n    if isinstance(array, pd.Index):\n        return PandasIndexAdapter(array)\n    if isinstance(array, dask_array_type):\n        return DaskIndexingAdapter(array)\n    if hasattr(array, '__array_function__'):\n        return NdArrayLikeIndexingAdapter(array)\n    raise TypeError('Invalid array type: {}'.format(type(array)))",
    ".xarray.backends.netCDF4_.py@@NetCDF4ArrayWrapper.__getitem__": "def __getitem__(self, key):\n    return indexing.explicit_indexing_adapter(key, self.shape, indexing.IndexingSupport.OUTER, self._getitem)",
    ".xarray.core.indexing.py@@explicit_indexing_adapter": "def explicit_indexing_adapter(key: ExplicitIndexer, shape: Tuple[int, ...], indexing_support: IndexingSupport, raw_indexing_method: Callable) -> Any:\n    raw_key, numpy_indices = decompose_indexer(key, shape, indexing_support)\n    result = raw_indexing_method(raw_key.tuple)\n    if numpy_indices.tuple:\n        result = NumpyIndexingAdapter(np.asarray(result))[numpy_indices]\n    return result",
    ".xarray.core.indexing.py@@decompose_indexer": "def decompose_indexer(indexer: ExplicitIndexer, shape: Tuple[int, ...], indexing_support: IndexingSupport) -> Tuple[ExplicitIndexer, ExplicitIndexer]:\n    if isinstance(indexer, VectorizedIndexer):\n        return _decompose_vectorized_indexer(indexer, shape, indexing_support)\n    if isinstance(indexer, (BasicIndexer, OuterIndexer)):\n        return _decompose_outer_indexer(indexer, shape, indexing_support)\n    raise TypeError(f'unexpected key type: {indexer}')",
    ".xarray.core.indexing.py@@_decompose_outer_indexer": "def _decompose_outer_indexer(indexer: Union[BasicIndexer, OuterIndexer], shape: Tuple[int, ...], indexing_support: IndexingSupport) -> Tuple[ExplicitIndexer, ExplicitIndexer]:\n    if indexing_support == IndexingSupport.VECTORIZED:\n        return (indexer, BasicIndexer(()))\n    assert isinstance(indexer, (OuterIndexer, BasicIndexer))\n    backend_indexer = []\n    np_indexer = []\n    pos_indexer = []\n    for k, s in zip(indexer.tuple, shape):\n        if isinstance(k, np.ndarray):\n            pos_indexer.append(np.where(k < 0, k + s, k))\n        elif isinstance(k, integer_types) and k < 0:\n            pos_indexer.append(k + s)\n        else:\n            pos_indexer.append(k)\n    indexer_elems = pos_indexer\n    if indexing_support is IndexingSupport.OUTER_1VECTOR:\n        gains = [(np.max(k) - np.min(k) + 1.0) / len(np.unique(k)) if isinstance(k, np.ndarray) else 0 for k in indexer_elems]\n        array_index = np.argmax(np.array(gains)) if len(gains) > 0 else None\n        for i, (k, s) in enumerate(zip(indexer_elems, shape)):\n            if isinstance(k, np.ndarray) and i != array_index:\n                backend_indexer.append(slice(np.min(k), np.max(k) + 1))\n                np_indexer.append(k - np.min(k))\n            elif isinstance(k, np.ndarray):\n                pkey, ekey = np.unique(k, return_inverse=True)\n                backend_indexer.append(pkey)\n                np_indexer.append(ekey)\n            elif isinstance(k, integer_types):\n                backend_indexer.append(k)\n            else:\n                bk_slice, np_slice = _decompose_slice(k, s)\n                backend_indexer.append(bk_slice)\n                np_indexer.append(np_slice)\n        return (OuterIndexer(tuple(backend_indexer)), OuterIndexer(tuple(np_indexer)))\n    if indexing_support == IndexingSupport.OUTER:\n        for k, s in zip(indexer_elems, shape):\n            if isinstance(k, slice):\n                bk_slice, np_slice = _decompose_slice(k, s)\n                backend_indexer.append(bk_slice)\n                np_indexer.append(np_slice)\n            elif isinstance(k, integer_types):\n                backend_indexer.append(k)\n            elif isinstance(k, np.ndarray) and (np.diff(k) >= 0).all():\n                backend_indexer.append(k)\n                np_indexer.append(slice(None))\n            else:\n                oind, vind = np.unique(k, return_inverse=True)\n                backend_indexer.append(oind)\n                np_indexer.append(vind.reshape(*k.shape))\n        return (OuterIndexer(tuple(backend_indexer)), OuterIndexer(tuple(np_indexer)))\n    assert indexing_support == IndexingSupport.BASIC\n    for k, s in zip(indexer_elems, shape):\n        if isinstance(k, np.ndarray):\n            backend_indexer.append(slice(np.min(k), np.max(k) + 1))\n            np_indexer.append(k - np.min(k))\n        elif isinstance(k, integer_types):\n            backend_indexer.append(k)\n        else:\n            bk_slice, np_slice = _decompose_slice(k, s)\n            backend_indexer.append(bk_slice)\n            np_indexer.append(np_slice)\n    return (BasicIndexer(tuple(backend_indexer)), OuterIndexer(tuple(np_indexer)))",
    ".xarray.core.indexing.py@@_decompose_slice": "def _decompose_slice(key, size):\n    start, stop, step = key.indices(size)\n    if step > 0:\n        return (key, slice(None))\n    else:\n        stop = start + int((stop - start - 1) / step) * step + 1\n        start, stop = (stop + 1, start + 1)\n        return (slice(start, stop, -step), slice(None, None, -1))",
    ".xarray.core.indexing.py@@OuterIndexer.__init__": "def __init__(self, key):\n    if not isinstance(key, tuple):\n        raise TypeError(f'key must be a tuple: {key!r}')\n    new_key = []\n    for k in key:\n        if isinstance(k, integer_types):\n            k = int(k)\n        elif isinstance(k, slice):\n            k = as_integer_slice(k)\n        elif isinstance(k, np.ndarray):\n            if not np.issubdtype(k.dtype, np.integer):\n                raise TypeError(f'invalid indexer array, does not have integer dtype: {k!r}')\n            if k.ndim != 1:\n                raise TypeError(f'invalid indexer array for {type(self).__name__}; must have exactly 1 dimension: {k!r}')\n            k = np.asarray(k, dtype=np.int64)\n        else:\n            raise TypeError(f'unexpected indexer type for {type(self).__name__}: {k!r}')\n        new_key.append(k)\n    super().__init__(new_key)",
    ".xarray.core.indexing.py@@as_integer_slice": "def as_integer_slice(value):\n    start = as_integer_or_none(value.start)\n    stop = as_integer_or_none(value.stop)\n    step = as_integer_or_none(value.step)\n    return slice(start, stop, step)",
    ".xarray.core.indexing.py@@as_integer_or_none": "def as_integer_or_none(value):\n    return None if value is None else operator.index(value)",
    ".xarray.core.indexing.py@@ExplicitIndexer.__init__": "def __init__(self, key):\n    if type(self) is ExplicitIndexer:\n        raise TypeError('cannot instantiate base ExplicitIndexer objects')\n    self._key = tuple(key)",
    ".xarray.backends.netCDF4_.py@@NetCDF4ArrayWrapper._getitem": "def _getitem(self, key):\n    if self.datastore.is_remote:\n        getitem = functools.partial(robust_getitem, catch=RuntimeError)\n    else:\n        getitem = operator.getitem\n    try:\n        with self.datastore.lock:\n            original_array = self.get_array(needs_lock=False)\n            array = getitem(original_array, key)\n    except IndexError:\n        msg = 'The indexing operation you are attempting to perform is not valid on netCDF4.Variable object. Try loading your data into memory first by calling .load().'\n        raise IndexError(msg)\n    return array",
    ".xarray.backends.locks.py@@CombinedLock.__enter__": "def __enter__(self):\n    for lock in self.locks:\n        lock.__enter__()",
    ".xarray.backends.netCDF4_.py@@NetCDF4ArrayWrapper.get_array": "def get_array(self, needs_lock=True):\n    ds = self.datastore._acquire(needs_lock)\n    variable = ds.variables[self.variable_name]\n    variable.set_auto_maskandscale(False)\n    with suppress(AttributeError):\n        variable.set_auto_chartostring(False)\n    return variable",
    ".xarray.backends.netCDF4_.py@@NetCDF4DataStore._acquire": "def _acquire(self, needs_lock=True):\n    with self._manager.acquire_context(needs_lock) as root:\n        ds = _nc4_require_group(root, self._group, self._mode)\n    return ds",
    ".xarray.backends.file_manager.py@@CachingFileManager.acquire_context": "def acquire_context(self, needs_lock=True):\n    file, cached = self._acquire_with_cache_info(needs_lock)\n    try:\n        yield file\n    except Exception:\n        if not cached:\n            self.close(needs_lock)\n        raise",
    ".xarray.backends.file_manager.py@@CachingFileManager._acquire_with_cache_info": "def _acquire_with_cache_info(self, needs_lock=True):\n    with self._optional_lock(needs_lock):\n        try:\n            file = self._cache[self._key]\n        except KeyError:\n            kwargs = self._kwargs\n            if self._mode is not _DEFAULT_MODE:\n                kwargs = kwargs.copy()\n                kwargs['mode'] = self._mode\n            file = self._opener(*self._args, **kwargs)\n            if self._mode == 'w':\n                self._mode = 'a'\n            self._cache[self._key] = file\n            return (file, False)\n        else:\n            return (file, True)",
    ".xarray.backends.file_manager.py@@CachingFileManager._optional_lock": "def _optional_lock(self, needs_lock):\n    if needs_lock:\n        with self._lock:\n            yield\n    else:\n        yield",
    ".xarray.backends.lru_cache.py@@LRUCache.__getitem__": "def __getitem__(self, key: K) -> V:\n    with self._lock:\n        value = self._cache[key]\n        self._cache.move_to_end(key)\n        return value",
    ".xarray.backends.file_manager.py@@_HashedSequence.__hash__": "def __hash__(self):\n    return self.hashvalue",
    ".xarray.backends.netCDF4_.py@@_nc4_require_group": "def _nc4_require_group(ds, group, mode, create_group=_netcdf4_create_group):\n    if group in {None, '', '/'}:\n        return ds\n    else:\n        if not isinstance(group, str):\n            raise ValueError('group must be a string or None')\n        path = group.strip('/').split('/')\n        for key in path:\n            try:\n                ds = ds.groups[key]\n            except KeyError as e:\n                if mode != 'r':\n                    ds = create_group(ds, key)\n                else:\n                    raise OSError('group not found: %s' % key, e)\n        return ds",
    ".xarray.backends.locks.py@@CombinedLock.__exit__": "def __exit__(self, *args):\n    for lock in self.locks:\n        lock.__exit__(*args)",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.__init__": "def __init__(self, array):\n    if not isinstance(array, np.ndarray):\n        raise TypeError('NumpyIndexingAdapter only wraps np.ndarray. Trying to wrap {}'.format(type(array)))\n    self.array = array",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.__getitem__": "def __getitem__(self, key):\n    array, key = self._indexing_array_and_key(key)\n    return array[key]",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter._indexing_array_and_key": "def _indexing_array_and_key(self, key):\n    if isinstance(key, OuterIndexer):\n        array = self.array\n        key = _outer_to_numpy_indexer(key, self.array.shape)\n    elif isinstance(key, VectorizedIndexer):\n        array = nputils.NumpyVIndexAdapter(self.array)\n        key = key.tuple\n    elif isinstance(key, BasicIndexer):\n        array = self.array\n        key = key.tuple + (Ellipsis,)\n    else:\n        raise TypeError('unexpected key type: {}'.format(type(key)))\n    return (array, key)",
    ".xarray.core.indexing.py@@_outer_to_numpy_indexer": "def _outer_to_numpy_indexer(key, shape):\n    if len([k for k in key.tuple if not isinstance(k, slice)]) <= 1:\n        return key.tuple\n    else:\n        return _outer_to_vectorized_indexer(key, shape).tuple",
    ".xarray.core.variable.py@@_possibly_convert_objects": "def _possibly_convert_objects(values):\n    return np.asarray(pd.Series(values.ravel())).reshape(values.shape)",
    ".xarray.core.utils.py@@NDArrayMixin.shape": "def shape(self: Any) -> Tuple[int]:\n    return self.array.shape"
}