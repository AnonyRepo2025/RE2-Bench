{
    ".lib.matplotlib._api.deprecation.py@@warn_deprecated": "def warn_deprecated(since, *, message='', name='', alternative='', pending=False, obj_type='', addendum='', removal=''):\n    warning = _generate_deprecation_warning(since, message, name, alternative, pending, obj_type, addendum, removal=removal)\n    from . import warn_external\n    warn_external(warning, category=MatplotlibDeprecationWarning)",
    ".lib.matplotlib._api.deprecation.py@@_generate_deprecation_warning": "def _generate_deprecation_warning(since, message='', name='', alternative='', pending=False, obj_type='', addendum='', *, removal=''):\n    if pending:\n        if removal:\n            raise ValueError('A pending deprecation cannot have a scheduled removal')\n    else:\n        removal = f'in {removal}' if removal else 'two minor releases later'\n    if not message:\n        message = ('The %(name)s %(obj_type)s' if obj_type else '%(name)s') + (' will be deprecated in a future version' if pending else ' was deprecated in Matplotlib %(since)s' + (' and will be removed %(removal)s' if removal else '')) + '.' + (' Use %(alternative)s instead.' if alternative else '') + (' %(addendum)s' if addendum else '')\n    warning_cls = PendingDeprecationWarning if pending else MatplotlibDeprecationWarning\n    return warning_cls(message % dict(func=name, name=name, obj_type=obj_type, since=since, removal=removal, alternative=alternative, addendum=addendum))",
    ".lib.matplotlib._api.__init__.py@@warn_external": "def warn_external(message, category=None):\n    frame = sys._getframe()\n    for stacklevel in itertools.count(1):\n        if frame is None:\n            break\n        if not re.match('\\\\A(matplotlib|mpl_toolkits)(\\\\Z|\\\\.(?!tests\\\\.))', frame.f_globals.get('__name__', '')):\n            break\n        frame = frame.f_back\n    warnings.warn(message, category, stacklevel)"
}