{
    ".django.dispatch.dispatcher.py@@Signal.disconnect": "def disconnect(self, receiver=None, sender=None, dispatch_uid=None):\n    if dispatch_uid:\n        lookup_key = (dispatch_uid, _make_id(sender))\n    else:\n        lookup_key = (_make_id(receiver), _make_id(sender))\n    disconnected = False\n    with self.lock:\n        self._clear_dead_receivers()\n        for index in range(len(self.receivers)):\n            r_key, _ = self.receivers[index]\n            if r_key == lookup_key:\n                disconnected = True\n                del self.receivers[index]\n                break\n        self.sender_receivers_cache.clear()\n    return disconnected",
    ".django.dispatch.dispatcher.py@@_make_id": "def _make_id(target):\n    if hasattr(target, '__func__'):\n        return (id(target.__self__), id(target.__func__))\n    return id(target)",
    ".django.dispatch.dispatcher.py@@Signal._clear_dead_receivers": "def _clear_dead_receivers(self):\n    if self._dead_receivers:\n        self._dead_receivers = False\n        self.receivers = [r for r in self.receivers if not (isinstance(r[1], weakref.ReferenceType) and r[1]() is None)]",
    ".django.test.testcases.py@@SimpleTestCase._post_teardown": "def _post_teardown(self):\n    pass",
    ".django.dispatch.dispatcher.py@@Signal._remove_receiver": "def _remove_receiver(self, receiver=None):\n    self._dead_receivers = True",
    ".django.test.testcases.py@@SimpleTestCase.__call__": "def __call__(self, result=None):\n    testMethod = getattr(self, self._testMethodName)\n    skipped = getattr(self.__class__, '__unittest_skip__', False) or getattr(testMethod, '__unittest_skip__', False)\n    if not skipped:\n        try:\n            self._pre_setup()\n        except Exception:\n            result.addError(self, sys.exc_info())\n            return\n    super().__call__(result)\n    if not skipped:\n        try:\n            self._post_teardown()\n        except Exception:\n            result.addError(self, sys.exc_info())\n            return",
    ".django.test.testcases.py@@SimpleTestCase._pre_setup": "def _pre_setup(self):\n    self.client = self.client_class()\n    mail.outbox = []",
    ".django.test.client.py@@Client.__init__": "def __init__(self, enforce_csrf_checks=False, raise_request_exception=True, **defaults):\n    super().__init__(**defaults)\n    self.handler = ClientHandler(enforce_csrf_checks)\n    self.raise_request_exception = raise_request_exception\n    self.exc_info = None",
    ".django.test.client.py@@RequestFactory.__init__": "def __init__(self, *, json_encoder=DjangoJSONEncoder, **defaults):\n    self.json_encoder = json_encoder\n    self.defaults = defaults\n    self.cookies = SimpleCookie()\n    self.errors = BytesIO()",
    ".django.test.client.py@@ClientHandler.__init__": "def __init__(self, enforce_csrf_checks=True, *args, **kwargs):\n    self.enforce_csrf_checks = enforce_csrf_checks\n    super().__init__(*args, **kwargs)",
    ".django.dispatch.dispatcher.py@@Signal.connect": "def connect(self, receiver, sender=None, weak=True, dispatch_uid=None):\n    from django.conf import settings\n    if settings.configured and settings.DEBUG:\n        assert callable(receiver), 'Signal receivers must be callable.'\n        if not func_accepts_kwargs(receiver):\n            raise ValueError('Signal receivers must accept keyword arguments (**kwargs).')\n    if dispatch_uid:\n        lookup_key = (dispatch_uid, _make_id(sender))\n    else:\n        lookup_key = (_make_id(receiver), _make_id(sender))\n    if weak:\n        ref = weakref.ref\n        receiver_object = receiver\n        if hasattr(receiver, '__self__') and hasattr(receiver, '__func__'):\n            ref = weakref.WeakMethod\n            receiver_object = receiver.__self__\n        receiver = ref(receiver)\n        weakref.finalize(receiver_object, self._remove_receiver)\n    with self.lock:\n        self._clear_dead_receivers()\n        if not any((r_key == lookup_key for r_key, _ in self.receivers)):\n            self.receivers.append((lookup_key, receiver))\n        self.sender_receivers_cache.clear()",
    ".django.conf.__init__.py@@LazySettings.configured": "def configured(self):\n    return self._wrapped is not empty",
    ".django.utils.functional.py@@LazyObject.__init__": "def __init__(self):\n    self._wrapped = empty",
    ".django.conf.__init__.py@@LazySettings.__setattr__": "def __setattr__(self, name, value):\n    if name == '_wrapped':\n        self.__dict__.clear()\n    else:\n        self.__dict__.pop(name, None)\n    super().__setattr__(name, value)",
    ".django.utils.functional.py@@LazyObject.__setattr__": "def __setattr__(self, name, value):\n    if name == '_wrapped':\n        self.__dict__['_wrapped'] = value\n    else:\n        if self._wrapped is empty:\n            self._setup()\n        setattr(self._wrapped, name, value)",
    ".django.test.testcases.py@@SimpleTestCase.assertRaisesMessage": "def assertRaisesMessage(self, expected_exception, expected_message, *args, **kwargs):\n    return self._assertFooMessage(self.assertRaises, 'exception', expected_exception, expected_message, *args, **kwargs)",
    ".django.test.testcases.py@@SimpleTestCase._assertFooMessage": "def _assertFooMessage(self, func, cm_attr, expected_exception, expected_message, *args, **kwargs):\n    callable_obj = None\n    if args:\n        callable_obj, *args = args\n    cm = self._assert_raises_or_warns_cm(func, cm_attr, expected_exception, expected_message)\n    if callable_obj is None:\n        return cm\n    with cm:\n        callable_obj(*args, **kwargs)",
    ".django.test.testcases.py@@SimpleTestCase._assert_raises_or_warns_cm": "def _assert_raises_or_warns_cm(self, func, cm_attr, expected_exception, expected_message):\n    with func(expected_exception) as cm:\n        yield cm\n    self.assertIn(expected_message, str(getattr(cm, cm_attr)))",
    ".django.conf.__init__.py@@LazySettings.configure": "def configure(self, default_settings=global_settings, **options):\n    if self._wrapped is not empty:\n        raise RuntimeError('Settings already configured.')\n    holder = UserSettingsHolder(default_settings)\n    for name, value in options.items():\n        if not name.isupper():\n            raise TypeError('Setting %r must be uppercase.' % name)\n        setattr(holder, name, value)\n    self._wrapped = holder",
    ".django.conf.__init__.py@@LazySettings.__getattr__": "def __getattr__(self, name):\n    if self._wrapped is empty:\n        self._setup(name)\n    val = getattr(self._wrapped, name)\n    self.__dict__[name] = val\n    return val",
    ".django.utils.functional.py@@inner": "def inner(self, *args):\n    if self._wrapped is empty:\n        self._setup()\n    return func(self._wrapped, *args)",
    ".django.test.utils.py@@TestContextDecorator.__exit__": "def __exit__(self, exc_type, exc_value, traceback):\n    self.disable()",
    ".django.test.utils.py@@override_settings.disable": "def disable(self):\n    if 'INSTALLED_APPS' in self.options:\n        apps.unset_installed_apps()\n    settings._wrapped = self.wrapped\n    del self.wrapped\n    responses = []\n    for key in self.options:\n        new_value = getattr(settings, key, None)\n        responses_for_setting = setting_changed.send_robust(sender=settings._wrapped.__class__, setting=key, value=new_value, enter=False)\n        responses.extend(responses_for_setting)\n    if self.enable_exception is not None:\n        exc = self.enable_exception\n        self.enable_exception = None\n        raise exc\n    for _, response in responses:\n        if isinstance(response, Exception):\n            raise response"
}