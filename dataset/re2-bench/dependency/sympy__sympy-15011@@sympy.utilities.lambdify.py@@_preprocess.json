{
    ".sympy.utilities.iterables.py@@flatten": "def flatten(iterable, levels=None, cls=None):\n    if levels is not None:\n        if not levels:\n            return iterable\n        elif levels > 0:\n            levels -= 1\n        else:\n            raise ValueError('expected non-negative number of levels, got %s' % levels)\n    if cls is None:\n        reducible = lambda x: is_sequence(x, set)\n    else:\n        reducible = lambda x: isinstance(x, cls)\n    result = []\n    for el in iterable:\n        if reducible(el):\n            if hasattr(el, 'args'):\n                el = el.args\n            result.extend(flatten(el, levels=levels, cls=cls))\n        else:\n            result.append(el)\n    return result",
    ".sympy.core.compatibility.py@@is_sequence": "def is_sequence(i, include=None):\n    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))",
    ".sympy.core.compatibility.py@@iterable": "def iterable(i, exclude=(string_types, dict, NotIterable)):\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    ".sympy.printing.codeprinter.py@@CodePrinter.doprint": "def doprint(self, expr, assign_to=None):\n    from sympy.matrices.expressions.matexpr import MatrixSymbol\n    if isinstance(assign_to, string_types):\n        if expr.is_Matrix:\n            assign_to = MatrixSymbol(assign_to, *expr.shape)\n        else:\n            assign_to = Symbol(assign_to)\n    elif not isinstance(assign_to, (Basic, type(None))):\n        raise TypeError('{0} cannot assign to object of type {1}'.format(type(self).__name__, type(assign_to)))\n    if assign_to:\n        expr = Assignment(assign_to, expr)\n    else:\n        expr = sympify(expr)\n    self._not_supported = set()\n    self._number_symbols = set()\n    lines = self._print(expr).splitlines()\n    if self._settings['human']:\n        frontlines = []\n        if len(self._not_supported) > 0:\n            frontlines.append(self._get_comment('Not supported in {0}:'.format(self.language)))\n            for expr in sorted(self._not_supported, key=str):\n                frontlines.append(self._get_comment(type(expr).__name__))\n        for name, value in sorted(self._number_symbols, key=str):\n            frontlines.append(self._declare_number_const(name, value))\n        lines = frontlines + lines\n        lines = self._format_code(lines)\n        result = '\\n'.join(lines)\n    else:\n        lines = self._format_code(lines)\n        num_syms = set([(k, self._print(v)) for k, v in self._number_symbols])\n        result = (num_syms, self._not_supported, '\\n'.join(lines))\n    del self._not_supported\n    del self._number_symbols\n    return result",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    if evaluate is None:\n        if global_evaluate[0] is False:\n            evaluate = global_evaluate[0]\n        else:\n            evaluate = True\n    try:\n        if a in sympy_classes:\n            return a\n    except TypeError:\n        pass\n    try:\n        cls = a.__class__\n    except AttributeError:\n        cls = type(a)\n    if cls in sympy_classes:\n        return a\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if type(a).__module__ == 'numpy':\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a)\n    try:\n        return converter[cls](a)\n    except KeyError:\n        for superclass in getmro(cls):\n            try:\n                return converter[superclass](a)\n            except KeyError:\n                continue\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    try:\n        return a._sympy_()\n    except AttributeError:\n        pass\n    if not strict:\n        try:\n            from ..tensor.array import Array\n            return Array(a.flat, a.shape)\n        except AttributeError:\n            pass\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                return sympify(coerce(a))\n            except (TypeError, ValueError, AttributeError, SympifyError):\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.printing.printer.py@@Printer._print": "def _print(self, expr, **kwargs):\n    self._print_level += 1\n    try:\n        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):\n            return getattr(expr, self.printmethod)(self, **kwargs)\n        classes = type(expr).__mro__\n        if AppliedUndef in classes:\n            classes = classes[classes.index(AppliedUndef):]\n        if UndefinedFunction in classes:\n            classes = classes[classes.index(UndefinedFunction):]\n        if Function in classes:\n            i = classes.index(Function)\n            classes = tuple((c for c in classes[:i] if c.__name__ == classes[0].__name__ or c.__name__.endswith('Base'))) + classes[i:]\n        for cls in classes:\n            printmethod = '_print_' + cls.__name__\n            if hasattr(self, printmethod):\n                return getattr(self, printmethod)(expr, **kwargs)\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1",
    ".sympy.printing.codeprinter.py@@CodePrinter._print_Symbol": "def _print_Symbol(self, expr):\n    name = super(CodePrinter, self)._print_Symbol(expr)\n    if name in self.reserved_words:\n        if self._settings['error_on_reserved']:\n            msg = 'This expression includes the symbol \"{}\" which is a reserved keyword in this language.'\n            raise ValueError(msg.format(name))\n        return name + self._settings['reserved_word_suffix']\n    else:\n        return name",
    ".sympy.printing.str.py@@StrPrinter._print_Symbol": "def _print_Symbol(self, expr):\n    return expr.name",
    ".sympy.printing.pycode.py@@PythonCodePrinter._format_code": "def _format_code(self, lines):\n    return lines",
    ".sympy.utilities.lambdify.py@@_EvaluatorPrinter._is_safe_ident": "def _is_safe_ident(cls, ident):\n    return isinstance(ident, str) and cls._safe_ident_re.match(ident) and (not (keyword.iskeyword(ident) or ident == 'None'))",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return dict(((key, value) for key, value in self._assumptions.items() if value is not None))",
    ".sympy.parsing.sympy_parser.py@@split_symbols_custom": "def split_symbols_custom(predicate):\n\n    def _split_symbols(tokens, local_dict, global_dict):\n        result = []\n        split = False\n        split_previous = False\n        for tok in tokens:\n            if split_previous:\n                split_previous = False\n                continue\n            split_previous = False\n            if tok[0] == NAME and tok[1] == 'Symbol':\n                split = True\n            elif split and tok[0] == NAME:\n                symbol = tok[1][1:-1]\n                if predicate(symbol):\n                    for char in symbol:\n                        if char in local_dict or char in global_dict:\n                            del result[-2:]\n                            result.extend([(NAME, '%s' % char), (NAME, 'Symbol'), (OP, '(')])\n                        else:\n                            result.extend([(NAME, \"'%s'\" % char), (OP, ')'), (NAME, 'Symbol'), (OP, '(')])\n                    del result[-2:]\n                    split = False\n                    split_previous = True\n                    continue\n                else:\n                    split = False\n            result.append(tok)\n        return result\n    return _split_symbols",
    ".sympy.parsing.sympy_parser.py@@parse_expr": "def parse_expr(s, local_dict=None, transformations=standard_transformations, global_dict=None, evaluate=True):\n    if local_dict is None:\n        local_dict = {}\n    if global_dict is None:\n        global_dict = {}\n        exec_('from sympy import *', global_dict)\n    code = stringify_expr(s, local_dict, global_dict, transformations)\n    if not evaluate:\n        code = compile(evaluateFalse(code), '<string>', 'eval')\n    return eval_expr(code, local_dict, global_dict)",
    ".sympy.parsing.sympy_parser.py@@stringify_expr": "def stringify_expr(s, local_dict, global_dict, transformations):\n    tokens = []\n    input_code = StringIO(s.strip())\n    for toknum, tokval, _, _, _ in generate_tokens(input_code.readline):\n        tokens.append((toknum, tokval))\n    for transform in transformations:\n        tokens = transform(tokens, local_dict, global_dict)\n    return untokenize(tokens)",
    ".sympy.parsing.sympy_parser.py@@lambda_notation": "def lambda_notation(tokens, local_dict, global_dict):\n    result = []\n    flag = False\n    toknum, tokval = tokens[0]\n    tokLen = len(tokens)\n    if toknum == NAME and tokval == 'lambda':\n        if tokLen == 2:\n            result.extend(tokens)\n        elif tokLen > 2:\n            result.extend([(NAME, 'Lambda'), (OP, '('), (OP, '('), (OP, ')'), (OP, ')')])\n            for tokNum, tokVal in tokens[1:]:\n                if tokNum == OP and tokVal == ':':\n                    tokVal = ','\n                    flag = True\n                if not flag and tokNum == OP and (tokVal in ['*', '**']):\n                    raise TokenError('Starred arguments in lambda not supported')\n                if flag:\n                    result.insert(-1, (tokNum, tokVal))\n                else:\n                    result.insert(-2, (tokNum, tokVal))\n    else:\n        result.extend(tokens)\n    return result",
    ".sympy.parsing.sympy_parser.py@@auto_symbol": "def auto_symbol(tokens, local_dict, global_dict):\n    result = []\n    prevTok = (None, None)\n    tokens.append((None, None))\n    for tok, nextTok in zip(tokens, tokens[1:]):\n        tokNum, tokVal = tok\n        nextTokNum, nextTokVal = nextTok\n        if tokNum == NAME:\n            name = tokVal\n            if name in ['True', 'False', 'None'] or iskeyword(name) or name in local_dict or (prevTok[0] == OP and prevTok[1] == '.') or (prevTok[0] == OP and prevTok[1] in ('(', ',') and (nextTokNum == OP) and (nextTokVal == '=')):\n                result.append((NAME, name))\n                continue\n            elif name in global_dict:\n                obj = global_dict[name]\n                if isinstance(obj, (Basic, type)) or callable(obj):\n                    result.append((NAME, name))\n                    continue\n            result.extend([(NAME, 'Symbol'), (OP, '('), (NAME, repr(str(name))), (OP, ')')])\n        else:\n            result.append((tokNum, tokVal))\n        prevTok = (tokNum, tokVal)\n    return result",
    ".sympy.parsing.sympy_parser.py@@repeated_decimals": "def repeated_decimals(tokens, local_dict, global_dict):\n    result = []\n\n    def is_digit(s):\n        return all((i in '0123456789_' for i in s))\n    num = []\n    for toknum, tokval in tokens:\n        if toknum == NUMBER:\n            if not num and '.' in tokval and ('e' not in tokval.lower()) and ('j' not in tokval.lower()):\n                num.append((toknum, tokval))\n            elif is_digit(tokval) and len(num) == 2:\n                num.append((toknum, tokval))\n            elif is_digit(tokval) and len(num) == 3 and is_digit(num[-1][1]):\n                num.append((toknum, tokval))\n            else:\n                num = []\n        elif toknum == OP:\n            if tokval == '[' and len(num) == 1:\n                num.append((OP, tokval))\n            elif tokval == ']' and len(num) >= 3:\n                num.append((OP, tokval))\n            elif tokval == '.' and (not num):\n                num.append((NUMBER, '0.'))\n            else:\n                num = []\n        else:\n            num = []\n        result.append((toknum, tokval))\n        if num and num[-1][1] == ']':\n            result = result[:-len(num)]\n            pre, post = num[0][1].split('.')\n            repetend = num[2][1]\n            if len(num) == 5:\n                repetend += num[3][1]\n            pre = pre.replace('_', '')\n            post = post.replace('_', '')\n            repetend = repetend.replace('_', '')\n            zeros = '0' * len(post)\n            post, repetends = [w.lstrip('0') for w in [post, repetend]]\n            a = pre or '0'\n            b, c = (post or '0', '1' + zeros)\n            d, e = (repetends, '9' * len(repetend) + zeros)\n            seq = [(OP, '('), (NAME, 'Integer'), (OP, '('), (NUMBER, a), (OP, ')'), (OP, '+'), (NAME, 'Rational'), (OP, '('), (NUMBER, b), (OP, ','), (NUMBER, c), (OP, ')'), (OP, '+'), (NAME, 'Rational'), (OP, '('), (NUMBER, d), (OP, ','), (NUMBER, e), (OP, ')'), (OP, ')')]\n            result.extend(seq)\n            num = []\n    return result",
    ".sympy.parsing.sympy_parser.py@@auto_number": "def auto_number(tokens, local_dict, global_dict):\n    result = []\n    for toknum, tokval in tokens:\n        if toknum == NUMBER:\n            number = tokval\n            postfix = []\n            if number.endswith('j') or number.endswith('J'):\n                number = number[:-1]\n                postfix = [(OP, '*'), (NAME, 'I')]\n            if '.' in number or (('e' in number or 'E' in number) and (not (number.startswith('0x') or number.startswith('0X')))):\n                seq = [(NAME, 'Float'), (OP, '('), (NUMBER, repr(str(number))), (OP, ')')]\n            else:\n                seq = [(NAME, 'Integer'), (OP, '('), (NUMBER, number), (OP, ')')]\n            result.extend(seq + postfix)\n        else:\n            result.append((toknum, tokval))\n    return result",
    ".sympy.parsing.sympy_parser.py@@factorial_notation": "def factorial_notation(tokens, local_dict, global_dict):\n    result = []\n    nfactorial = 0\n    for toknum, tokval in tokens:\n        if toknum == ERRORTOKEN:\n            op = tokval\n            if op == '!':\n                nfactorial += 1\n            else:\n                nfactorial = 0\n                result.append((OP, op))\n        else:\n            if nfactorial == 1:\n                result = _add_factorial_tokens('factorial', result)\n            elif nfactorial == 2:\n                result = _add_factorial_tokens('factorial2', result)\n            elif nfactorial > 2:\n                raise TokenError\n            nfactorial = 0\n            result.append((toknum, tokval))\n    return result",
    ".sympy.parsing.sympy_parser.py@@convert_xor": "def convert_xor(tokens, local_dict, global_dict):\n    result = []\n    for toknum, tokval in tokens:\n        if toknum == OP:\n            if tokval == '^':\n                result.append((OP, '**'))\n            else:\n                result.append((toknum, tokval))\n        else:\n            result.append((toknum, tokval))\n    return result",
    ".sympy.parsing.sympy_parser.py@@eval_expr": "def eval_expr(code, local_dict, global_dict):\n    expr = eval(code, global_dict, local_dict)\n    return expr",
    ".sympy.core.symbol.py@@Symbol.__new__": "def __new__(cls, name, **assumptions):\n    cls._sanitize(assumptions, cls)\n    return Symbol.__xnew_cached_(cls, name, **assumptions)",
    ".sympy.core.symbol.py@@Symbol._sanitize": "def _sanitize(assumptions, obj=None):\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    if is_commutative is None:\n        whose = '%s ' % obj.__name__ if obj else ''\n        raise ValueError('%scommutativity must be True or False.' % whose)\n    for key in list(assumptions.keys()):\n        from collections import defaultdict\n        from sympy.utilities.exceptions import SymPyDeprecationWarning\n        keymap = defaultdict(lambda: None)\n        keymap.update({'bounded': 'finite', 'unbounded': 'infinite', 'infinitesimal': 'zero'})\n        if keymap[key]:\n            SymPyDeprecationWarning(feature='%s assumption' % key, useinstead='%s' % keymap[key], issue=8071, deprecated_since_version='0.7.6').warn()\n            assumptions[keymap[key]] = assumptions[key]\n            assumptions.pop(key)\n            key = keymap[key]\n        v = assumptions[key]\n        if v is None:\n            assumptions.pop(key)\n            continue\n        assumptions[key] = bool(v)",
    ".sympy.core.logic.py@@fuzzy_bool": "def fuzzy_bool(x):\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    ".sympy.core.symbol.py@@Symbol.__new_stage2__": "def __new_stage2__(cls, name, **assumptions):\n    if not isinstance(name, string_types):\n        raise TypeError('name should be a string, not %s' % repr(type(name)))\n    obj = Expr.__new__(cls)\n    obj.name = name\n    tmp_asm_copy = assumptions.copy()\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    assumptions['commutative'] = is_commutative\n    obj._assumptions = StdFactKB(assumptions)\n    obj._assumptions._generator = tmp_asm_copy\n    return obj",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.printing.str.py@@StrPrinter._print_tuple": "def _print_tuple(self, expr):\n    if len(expr) == 1:\n        return '(%s,)' % self._print(expr[0])\n    else:\n        return '(%s)' % self.stringify(expr, ', ')",
    ".sympy.printing.str.py@@StrPrinter.stringify": "def stringify(self, args, sep, level=0):\n    return sep.join([self.parenthesize(item, level) for item in args])",
    ".sympy.printing.str.py@@StrPrinter.parenthesize": "def parenthesize(self, item, level, strict=False):\n    if precedence(item) < level or (not strict and precedence(item) <= level):\n        return '(%s)' % self._print(item)\n    else:\n        return self._print(item)",
    ".sympy.printing.precedence.py@@precedence": "def precedence(item):\n    if hasattr(item, 'precedence'):\n        return item.precedence\n    try:\n        mro = item.__class__.__mro__\n    except AttributeError:\n        return PRECEDENCE['Atom']\n    for i in mro:\n        n = i.__name__\n        if n in PRECEDENCE_FUNCTIONS:\n            return PRECEDENCE_FUNCTIONS[n](item)\n        elif n in PRECEDENCE_VALUES:\n            return PRECEDENCE_VALUES[n]\n    return PRECEDENCE['Atom']",
    ".sympy.matrices.dense.py@@DenseMatrix.__getitem__": "def __getitem__(self, key):\n    if isinstance(key, tuple):\n        i, j = key\n        try:\n            i, j = self.key2ij(key)\n            return self._mat[i * self.cols + j]\n        except (TypeError, IndexError):\n            if isinstance(i, Expr) and (not i.is_number) or (isinstance(j, Expr) and (not j.is_number)):\n                if (j < 0) is True or (j >= self.shape[1]) is True or (i < 0) is True or ((i >= self.shape[0]) is True):\n                    raise ValueError('index out of boundary')\n                from sympy.matrices.expressions.matexpr import MatrixElement\n                return MatrixElement(self, i, j)\n            if isinstance(i, slice):\n                i = list(range(self.rows))[i]\n            elif is_sequence(i):\n                pass\n            else:\n                i = [i]\n            if isinstance(j, slice):\n                j = list(range(self.cols))[j]\n            elif is_sequence(j):\n                pass\n            else:\n                j = [j]\n            return self.extract(i, j)\n    else:\n        if isinstance(key, slice):\n            return self._mat[key]\n        return self._mat[a2idx(key)]",
    ".sympy.matrices.matrices.py@@a2idx": "def a2idx(j, n=None):\n    if type(j) is not int:\n        try:\n            j = j.__index__()\n        except AttributeError:\n            raise IndexError('Invalid index a[%r]' % (j,))\n    if n is not None:\n        if j < 0:\n            j += n\n        if not (j >= 0 and j < n):\n            raise IndexError('Index out of range: a[%s]' % j)\n    return int(j)",
    ".sympy.core.symbol.py@@Dummy.__new__": "def __new__(cls, name=None, dummy_index=None, **assumptions):\n    if dummy_index is not None:\n        assert name is not None, 'If you specify a dummy_index, you must also provide a name'\n    if name is None:\n        name = 'Dummy_' + str(Dummy._count)\n    if dummy_index is None:\n        dummy_index = Dummy._base_dummy_index + Dummy._count\n        Dummy._count += 1\n    cls._sanitize(assumptions, cls)\n    obj = Symbol.__xnew__(cls, name, **assumptions)\n    obj.dummy_index = dummy_index\n    return obj",
    ".sympy.core.symbol.py@@Dummy._hashable_content": "def _hashable_content(self):\n    return Symbol._hashable_content(self) + (self.dummy_index,)",
    ".sympy.printing.codeprinter.py@@CodePrinter._print_Dummy": "def _print_Dummy(self, expr):\n    if expr.name.startswith('Dummy_'):\n        return '_' + expr.name\n    else:\n        return '%s_%d' % (expr.name, expr.dummy_index)",
    ".sympy.core.basic.py@@Basic._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.basic.py@@Basic.xreplace": "def xreplace(self, rule):\n    value, _ = self._xreplace(rule)\n    return value",
    ".sympy.core.basic.py@@Basic._xreplace": "def _xreplace(self, rule):\n    if self in rule:\n        return (rule[self], True)\n    elif rule:\n        args = []\n        changed = False\n        for a in self.args:\n            try:\n                a_xr = a._xreplace(rule)\n                args.append(a_xr[0])\n                changed |= a_xr[1]\n            except AttributeError:\n                args.append(a)\n        args = tuple(args)\n        if changed:\n            return (self.func(*args), True)\n    return (self, False)",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    tself = type(self)\n    tother = type(other)\n    if type(self) is not type(other):\n        try:\n            other = _sympify(other)\n            tother = type(other)\n        except SympifyError:\n            return NotImplemented\n        if PY3 or type(tself).__ne__ is not type.__ne__:\n            if tself != tother:\n                return False\n        elif tself is not tother:\n            return False\n    return self._hashable_content() == other._hashable_content()",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.core.power.py@@Pow.__new__": "def __new__(cls, b, e, evaluate=None):\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    from sympy.functions.elementary.exponential import exp_polar\n    b = _sympify(b)\n    e = _sympify(e)\n    if evaluate:\n        if e is S.ComplexInfinity:\n            return S.NaN\n        if e is S.Zero:\n            return S.One\n        elif e is S.One:\n            return b\n        elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and e.is_integer and _coeff_isneg(b):\n            if e.is_even:\n                b = -b\n            elif e.is_odd:\n                return -Pow(-b, e)\n        if S.NaN in (b, e):\n            return S.NaN\n        elif b is S.One:\n            if abs(e).is_infinite:\n                return S.NaN\n            return S.One\n        else:\n            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):\n                from sympy import numer, denom, log, sign, im, factor_terms\n                c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n                den = denom(ex)\n                if isinstance(den, log) and den.args[0] == b:\n                    return S.Exp1 ** (c * numer(ex))\n                elif den.is_Add:\n                    s = sign(im(b))\n                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):\n                        return S.Exp1 ** (c * numer(ex))\n            obj = b._eval_power(e)\n            if obj is not None:\n                return obj\n    obj = Expr.__new__(cls, b, e)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if not isinstance(obj, Pow):\n        return obj\n    obj.is_commutative = b.is_commutative and e.is_commutative\n    return obj",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.function.py@@_coeff_isneg": "def _coeff_isneg(a):\n    if a.is_Mul:\n        a = a.args[0]\n    return a.is_Number and a.is_negative",
    ".sympy.core.numbers.py@@NaN.__hash__": "def __hash__(self):\n    return super(NaN, self).__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super(Number, self).__hash__()",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, integer_types):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Number:\n        if other.is_Rational:\n            return self.p == other.p and self.q == other.q\n        if other.is_Float:\n            return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)\n    return False",
    ".sympy.core.expr.py@@Expr._eval_power": "def _eval_power(self, other):\n    return None",
    ".sympy.core.basic.py@@Basic._exec_constructor_postprocessors": "def _exec_constructor_postprocessors(cls, obj):\n    clsname = obj.__class__.__name__\n    postprocessors = defaultdict(list)\n    for i in obj.args:\n        try:\n            if i in Basic._constructor_postprocessor_mapping:\n                for k, v in Basic._constructor_postprocessor_mapping[i].items():\n                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n            else:\n                postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)\n                for k, v in chain.from_iterable(postprocessor_mappings):\n                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n        except TypeError:\n            pass\n    for f in postprocessors.get(clsname, []):\n        obj = f(obj)\n    if len(postprocessors) > 0 and obj not in Basic._constructor_postprocessor_mapping:\n        Basic._constructor_postprocessor_mapping[obj] = postprocessors\n    return obj",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, **options):\n    from sympy import Order\n    args = list(map(_sympify, args))\n    args = [a for a in args if a is not cls.identity]\n    evaluate = options.get('evaluate')\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    if not evaluate:\n        return cls._from_args(args)\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if order_symbols is not None:\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.core.mul.py@@Mul.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n            seq = [a, b]\n        assert not a is S.One\n        if not a.is_zero and a.is_Rational:\n            r, b = b.as_coeff_Mul()\n            if b.is_Add:\n                if r is not S.One:\n                    rv = ([cls(a * r, b, evaluate=False)], [], None)\n                elif global_distribute[0] and b.is_commutative:\n                    r, b = b.as_coeff_Add()\n                    bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n                    _addsort(bargs)\n                    ar = a * r\n                    if ar:\n                        bargs.insert(0, ar)\n                    bargs = [Add._from_args(bargs)]\n                    rv = (bargs, [], None)\n        if rv:\n            return rv\n    c_part = []\n    nc_part = []\n    nc_seq = []\n    coeff = S.One\n    c_powers = []\n    num_exp = []\n    neg1e = S.Zero\n    pnum_rat = {}\n    order_symbols = None\n    for o in seq:\n        if o.is_Order:\n            o, order_symbols = o.as_expr_variables(order_symbols)\n        if o.is_Mul:\n            if o.is_commutative:\n                seq.extend(o.args)\n            else:\n                for q in o.args:\n                    if q.is_commutative:\n                        seq.append(q)\n                    else:\n                        nc_seq.append(q)\n                seq.append(NC_Marker)\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o is S.Zero):\n                return ([S.NaN], [], None)\n            elif coeff.is_Number or isinstance(coeff, AccumBounds):\n                coeff *= o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__mul__(coeff)\n            continue\n        elif isinstance(o, MatrixExpr):\n            coeff = o.__mul__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if not coeff:\n                return ([S.NaN], [], None)\n            if coeff is S.ComplexInfinity:\n                return ([S.ComplexInfinity], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o is S.ImaginaryUnit:\n            neg1e += S.Half\n            continue\n        elif o.is_commutative:\n            b, e = o.as_base_exp()\n            if o.is_Pow:\n                if b.is_Number:\n                    if e.is_Rational:\n                        if e.is_Integer:\n                            coeff *= Pow(b, e)\n                            continue\n                        elif e.is_negative:\n                            seq.append(Pow(b, e))\n                            continue\n                        elif b.is_negative:\n                            neg1e += e\n                            b = -b\n                        if b is not S.One:\n                            pnum_rat.setdefault(b, []).append(e)\n                        continue\n                    elif b.is_positive or e.is_integer:\n                        num_exp.append((b, e))\n                        continue\n                elif b is S.ImaginaryUnit and e.is_Rational:\n                    neg1e += e / 2\n                    continue\n            c_powers.append((b, e))\n        else:\n            if o is not NC_Marker:\n                nc_seq.append(o)\n            while nc_seq:\n                o = nc_seq.pop(0)\n                if not nc_part:\n                    nc_part.append(o)\n                    continue\n                o1 = nc_part.pop()\n                b1, e1 = o1.as_base_exp()\n                b2, e2 = o.as_base_exp()\n                new_exp = e1 + e2\n                if b1 == b2 and (not new_exp.is_Add):\n                    o12 = b1 ** new_exp\n                    if o12.is_commutative:\n                        seq.append(o12)\n                        continue\n                    else:\n                        nc_seq.insert(0, o12)\n                else:\n                    nc_part.append(o1)\n                    nc_part.append(o)\n\n    def _gather(c_powers):\n        common_b = {}\n        for b, e in c_powers:\n            co = e.as_coeff_Mul()\n            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n        for b, d in common_b.items():\n            for di, li in d.items():\n                d[di] = Add(*li)\n        new_c_powers = []\n        for b, e in common_b.items():\n            new_c_powers.extend([(b, c * t) for t, c in e.items()])\n        return new_c_powers\n    c_powers = _gather(c_powers)\n    num_exp = _gather(num_exp)\n    for i in range(2):\n        new_c_powers = []\n        changed = False\n        for b, e in c_powers:\n            if e.is_zero:\n                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):\n                    return ([S.NaN], [], None)\n                continue\n            if e is S.One:\n                if b.is_Number:\n                    coeff *= b\n                    continue\n                p = b\n            if e is not S.One:\n                p = Pow(b, e)\n                if p.is_Pow and (not b.is_Pow):\n                    bi = b\n                    b, e = p.as_base_exp()\n                    if b != bi:\n                        changed = True\n            c_part.append(p)\n            new_c_powers.append((b, e))\n        if changed and len(set((b for b, e in new_c_powers))) != len(new_c_powers):\n            c_part = []\n            c_powers = _gather(new_c_powers)\n        else:\n            break\n    inv_exp_dict = {}\n    for b, e in num_exp:\n        inv_exp_dict.setdefault(e, []).append(b)\n    for e, b in inv_exp_dict.items():\n        inv_exp_dict[e] = cls(*b)\n    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n    comb_e = {}\n    for b, e in pnum_rat.items():\n        comb_e.setdefault(Add(*e), []).append(b)\n    del pnum_rat\n    num_rat = []\n    for e, b in comb_e.items():\n        b = cls(*b)\n        if e.q == 1:\n            coeff *= Pow(b, e)\n            continue\n        if e.p > e.q:\n            e_i, ep = divmod(e.p, e.q)\n            coeff *= Pow(b, e_i)\n            e = Rational(ep, e.q)\n        num_rat.append((b, e))\n    del comb_e\n    pnew = defaultdict(list)\n    i = 0\n    while i < len(num_rat):\n        bi, ei = num_rat[i]\n        grow = []\n        for j in range(i + 1, len(num_rat)):\n            bj, ej = num_rat[j]\n            g = bi.gcd(bj)\n            if g is not S.One:\n                e = ei + ej\n                if e.q == 1:\n                    coeff *= Pow(g, e)\n                else:\n                    if e.p > e.q:\n                        e_i, ep = divmod(e.p, e.q)\n                        coeff *= Pow(g, e_i)\n                        e = Rational(ep, e.q)\n                    grow.append((g, e))\n                num_rat[j] = (bj / g, ej)\n                bi = bi / g\n                if bi is S.One:\n                    break\n        if bi is not S.One:\n            obj = Pow(bi, ei)\n            if obj.is_Number:\n                coeff *= obj\n            else:\n                for obj in Mul.make_args(obj):\n                    if obj.is_Number:\n                        coeff *= obj\n                    else:\n                        assert obj.is_Pow\n                        bi, ei = obj.args\n                        pnew[ei].append(bi)\n        num_rat.extend(grow)\n        i += 1\n    for e, b in pnew.items():\n        pnew[e] = cls(*b)\n    if neg1e:\n        p, q = neg1e.as_numer_denom()\n        n, p = divmod(p, q)\n        if n % 2:\n            coeff = -coeff\n        if q == 2:\n            c_part.append(S.ImaginaryUnit)\n        elif p:\n            neg1e = Rational(p, q)\n            for e, b in pnew.items():\n                if e == neg1e and b.is_positive:\n                    pnew[e] = -b\n                    break\n            else:\n                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n    c_part.extend([Pow(b, e) for e, b in pnew.items()])\n    if coeff is S.Infinity or coeff is S.NegativeInfinity:\n\n        def _handle_for_oo(c_part, coeff_sign):\n            new_c_part = []\n            for t in c_part:\n                if t.is_positive:\n                    continue\n                if t.is_negative:\n                    coeff_sign *= -1\n                    continue\n                new_c_part.append(t)\n            return (new_c_part, coeff_sign)\n        c_part, coeff_sign = _handle_for_oo(c_part, 1)\n        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n        coeff *= coeff_sign\n    if coeff is S.ComplexInfinity:\n        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n    elif coeff is S.Zero:\n        if any((c.is_finite == False for c in c_part)):\n            return ([S.NaN], [], order_symbols)\n        return ([coeff], [], order_symbols)\n    _new = []\n    for i in c_part:\n        if i.is_Number:\n            coeff *= i\n        else:\n            _new.append(i)\n    c_part = _new\n    _mulsort(c_part)\n    if coeff is not S.One:\n        c_part.insert(0, coeff)\n    if global_distribute[0] and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add:\n        coeff = c_part[0]\n        c_part = [Add(*[coeff * f for f in c_part[1].args])]\n    return (c_part, nc_part, order_symbols)",
    ".sympy.core.numbers.py@@Integer.__mul__": "def __mul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p * other)\n        elif isinstance(other, Integer):\n            return Integer(self.p * other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, string_types):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    try:\n        return _intcache[ival]\n    except KeyError:\n        obj = Expr.__new__(cls)\n        obj.p = ival\n        _intcache[ival] = obj\n        return obj",
    ".sympy.core.power.py@@Pow.as_base_exp": "def as_base_exp(self):\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and (b.q != 1):\n        return (Integer(b.q), -e)\n    return (b, e)",
    ".sympy.core.mul.py@@Mul._gather": "def _gather(c_powers):\n    common_b = {}\n    for b, e in c_powers:\n        co = e.as_coeff_Mul()\n        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n    for b, d in common_b.items():\n        for di, li in d.items():\n            d[di] = Add(*li)\n    new_c_powers = []\n    for b, e in common_b.items():\n        new_c_powers.extend([(b, c * t) for t, c in e.items()])\n    return new_c_powers",
    ".sympy.core.numbers.py@@Rational.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (self, S.One)",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.function.py@@UndefinedFunction.__hash__": "def __hash__(self):\n    return hash((self.class_key(), frozenset(self._extra_kwargs.items())))",
    ".sympy.core.function.py@@Function.class_key": "def class_key(cls):\n    from sympy.sets.fancysets import Naturals0\n    funcs = {'exp': 10, 'log': 11, 'sin': 20, 'cos': 21, 'tan': 22, 'cot': 23, 'sinh': 30, 'cosh': 31, 'tanh': 32, 'coth': 33, 'conjugate': 40, 're': 41, 'im': 42, 'arg': 43}\n    name = cls.__name__\n    try:\n        i = funcs[name]\n    except KeyError:\n        i = 0 if isinstance(cls.nargs, Naturals0) else 10000\n    return (4, i, name)",
    ".sympy.core.function.py@@FunctionClass.nargs": "def nargs(self):\n    from sympy.sets.sets import FiniteSet\n    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0",
    ".sympy.core.function.py@@UndefinedFunction.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.function.py@@UndefinedFunction.__eq__": "def __eq__(self, other):\n    return isinstance(other, self.__class__) and self.class_key() == other.class_key() and (self._extra_kwargs == other._extra_kwargs)",
    ".sympy.core.function.py@@Function.is_commutative": "def is_commutative(self):\n    if all((getattr(t, 'is_commutative') for t in self.args)):\n        return True\n    else:\n        return False",
    ".sympy.core.numbers.py@@Zero.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.core.mul.py@@_mulsort": "def _mulsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.basic.py@@Basic.compare": "def compare(self, other):\n    if self is other:\n        return 0\n    n1 = self.__class__\n    n2 = other.__class__\n    c = (n1 > n2) - (n1 < n2)\n    if c:\n        return c\n    st = self._hashable_content()\n    ot = other._hashable_content()\n    c = (len(st) > len(ot)) - (len(st) < len(ot))\n    if c:\n        return c\n    for l, r in zip(st, ot):\n        l = Basic(*l) if isinstance(l, frozenset) else l\n        r = Basic(*r) if isinstance(r, frozenset) else r\n        if isinstance(l, Basic):\n            c = l.compare(r)\n        else:\n            c = (l > r) - (l < r)\n        if c:\n            return c\n    return 0",
    ".sympy.core.core.py@@BasicMeta.__gt__": "def __gt__(cls, other):\n    if cls.__cmp__(other) == 1:\n        return True\n    return False",
    ".sympy.core.core.py@@BasicMeta.__cmp__": "def __cmp__(cls, other):\n    if not isinstance(other, BasicMeta):\n        return -1\n    n1 = cls.__name__\n    n2 = other.__name__\n    if n1 == n2:\n        return 0\n    UNKNOWN = len(ordering_of_classes) + 1\n    try:\n        i1 = ordering_of_classes.index(n1)\n    except ValueError:\n        i1 = UNKNOWN\n    try:\n        i2 = ordering_of_classes.index(n2)\n    except ValueError:\n        i2 = UNKNOWN\n    if i1 == UNKNOWN and i2 == UNKNOWN:\n        return (n1 > n2) - (n1 < n2)\n    return (i1 > i2) - (i1 < i2)",
    ".sympy.core.core.py@@BasicMeta.__lt__": "def __lt__(cls, other):\n    if cls.__cmp__(other) == -1:\n        return True\n    return False",
    ".sympy.core.operations.py@@AssocOp._from_args": "def _from_args(cls, args, is_commutative=None):\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n    obj = super(AssocOp, cls).__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and((a.is_commutative for a in args))\n    obj.is_commutative = is_commutative\n    return obj",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (S.One, self)",
    ".sympy.core.expr.py@@Expr.as_base_exp": "def as_base_exp(self):\n    return (self, S.One)",
    ".sympy.core.add.py@@Add.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        if a.is_Rational:\n            if b.is_Mul:\n                rv = ([a, b], [], None)\n        if rv:\n            if all((s.is_commutative for s in rv[0])):\n                return rv\n            return ([], rv[0], None)\n    terms = {}\n    coeff = S.Zero\n    order_factors = []\n    for o in seq:\n        if o.is_Order:\n            for o1 in order_factors:\n                if o1.contains(o):\n                    o = None\n                    break\n            if o is None:\n                continue\n            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False):\n                return ([S.NaN], [], None)\n            if coeff.is_Number:\n                coeff += o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__add__(coeff)\n            continue\n        elif isinstance(o, MatrixExpr):\n            coeff = o.__add__(coeff) if coeff else o\n            continue\n        elif o is S.ComplexInfinity:\n            if coeff.is_finite is False:\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o.is_Add:\n            seq.extend(o.args)\n            continue\n        elif o.is_Mul:\n            c, s = o.as_coeff_Mul()\n        elif o.is_Pow:\n            b, e = o.as_base_exp()\n            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):\n                seq.append(b ** e)\n                continue\n            c, s = (S.One, o)\n        else:\n            c = S.One\n            s = o\n        if s in terms:\n            terms[s] += c\n            if terms[s] is S.NaN:\n                return ([S.NaN], [], None)\n        else:\n            terms[s] = c\n    newseq = []\n    noncommutative = False\n    for s, c in terms.items():\n        if c is S.Zero:\n            continue\n        elif c is S.One:\n            newseq.append(s)\n        elif s.is_Mul:\n            cs = s._new_rawargs(*(c,) + s.args)\n            newseq.append(cs)\n        elif s.is_Add:\n            newseq.append(Mul(c, s, evaluate=False))\n        else:\n            newseq.append(Mul(c, s))\n        noncommutative = noncommutative or not s.is_commutative\n    if coeff is S.Infinity:\n        newseq = [f for f in newseq if not (f.is_nonnegative or (f.is_real and f.is_finite))]\n    elif coeff is S.NegativeInfinity:\n        newseq = [f for f in newseq if not (f.is_nonpositive or (f.is_real and f.is_finite))]\n    if coeff is S.ComplexInfinity:\n        newseq = [c for c in newseq if not (c.is_finite and c.is_real is not None)]\n    if order_factors:\n        newseq2 = []\n        for t in newseq:\n            for o in order_factors:\n                if o.contains(t):\n                    t = None\n                    break\n            if t is not None:\n                newseq2.append(t)\n        newseq = newseq2 + order_factors\n        for o in order_factors:\n            if o.contains(coeff):\n                coeff = S.Zero\n                break\n    _addsort(newseq)\n    if coeff is not S.Zero:\n        newseq.insert(0, coeff)\n    if noncommutative:\n        return ([], newseq, None)\n    else:\n        return (newseq, [], None)",
    ".sympy.core.mul.py@@Mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return (coeff, args[0])\n            else:\n                return (coeff, self._new_rawargs(*args))\n        elif coeff.is_negative:\n            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))\n    return (S.One, self)",
    ".sympy.core.add.py@@_addsort": "def _addsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.printing.codeprinter.py@@CodePrinter._print_Mul": "def _print_Mul(self, expr):\n    prec = precedence(expr)\n    c, e = expr.as_coeff_Mul()\n    if c < 0:\n        expr = _keep_coeff(-c, e)\n        sign = '-'\n    else:\n        sign = ''\n    a = []\n    b = []\n    pow_paren = []\n    if self.order not in ('old', 'none'):\n        args = expr.as_ordered_factors()\n    else:\n        args = Mul.make_args(expr)\n    for item in args:\n        if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n            if item.exp != -1:\n                b.append(Pow(item.base, -item.exp, evaluate=False))\n            else:\n                if len(item.args[0].args) != 1 and isinstance(item.base, Mul):\n                    pow_paren.append(item)\n                b.append(Pow(item.base, -item.exp))\n        else:\n            a.append(item)\n    a = a or [S.One]\n    a_str = [self.parenthesize(x, prec) for x in a]\n    b_str = [self.parenthesize(x, prec) for x in b]\n    for item in pow_paren:\n        if item.base in b:\n            b_str[b.index(item.base)] = '(%s)' % b_str[b.index(item.base)]\n    if len(b) == 0:\n        return sign + '*'.join(a_str)\n    elif len(b) == 1:\n        return sign + '*'.join(a_str) + '/' + b_str[0]\n    else:\n        return sign + '*'.join(a_str) + '/(%s)' % '*'.join(b_str)",
    ".sympy.printing.precedence.py@@precedence_Mul": "def precedence_Mul(item):\n    if _coeff_isneg(item):\n        return PRECEDENCE['Add']\n    return PRECEDENCE['Mul']",
    ".sympy.core.numbers.py@@Integer.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    ".sympy.logic.boolalg.py@@BooleanFalse.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.printing.printer.py@@Printer.order": "def order(self):\n    if 'order' in self._settings:\n        return self._settings['order']\n    else:\n        raise AttributeError('No order defined.')",
    ".sympy.core.mul.py@@Mul.as_ordered_factors": "def as_ordered_factors(self, order=None):\n    cpart, ncpart = self.args_cnc()\n    cpart.sort(key=lambda expr: expr.sort_key(order=order))\n    return cpart + ncpart",
    ".sympy.core.expr.py@@Expr.args_cnc": "def args_cnc(self, cset=False, warn=True, split_1=True):\n    if self.is_Mul:\n        args = list(self.args)\n    else:\n        args = [self]\n    for i, mi in enumerate(args):\n        if not mi.is_commutative:\n            c = args[:i]\n            nc = args[i:]\n            break\n    else:\n        c = args\n        nc = []\n    if c and split_1 and (c[0].is_Number and c[0].is_negative and (c[0] is not S.NegativeOne)):\n        c[:1] = [S.NegativeOne, -c[0]]\n    if cset:\n        clen = len(c)\n        c = set(c)\n        if clen and warn and (len(c) != clen):\n            raise ValueError('repeated commutative arguments: %s' % [ci for ci in c if list(self.args).count(ci) > 1])\n    return [c, nc]",
    ".sympy.core.expr.py@@Expr.sort_key": "def sort_key(self, order=None):\n    coeff, expr = self.as_coeff_Mul()\n    if expr.is_Pow:\n        expr, exp = expr.args\n    else:\n        expr, exp = (expr, S.One)\n    if expr.is_Dummy:\n        args = (expr.sort_key(),)\n    elif expr.is_Atom:\n        args = (str(expr),)\n    else:\n        if expr.is_Add:\n            args = expr.as_ordered_terms(order=order)\n        elif expr.is_Mul:\n            args = expr.as_ordered_factors(order=order)\n        else:\n            args = expr.args\n        args = tuple([default_sort_key(arg, order=order) for arg in args])\n    args = (len(args), tuple(args))\n    exp = exp.sort_key(order=order)\n    return (expr.class_key(), args, exp, coeff)",
    ".sympy.core.compatibility.py@@default_sort_key": "def default_sort_key(item, order=None):\n    from .singleton import S\n    from .basic import Basic\n    from .sympify import sympify, SympifyError\n    from .compatibility import iterable\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n    if iterable(item, exclude=string_types):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            args = list(item)\n            unordered = False\n        args = [default_sort_key(arg, order=order) for arg in args]\n        if unordered:\n            args = sorted(args)\n        cls_index, args = (10, (len(args), tuple(args)))\n    else:\n        if not isinstance(item, string_types):\n            try:\n                item = sympify(item)\n            except SympifyError:\n                pass\n            else:\n                if isinstance(item, Basic):\n                    return default_sort_key(item)\n        cls_index, args = (0, (1, (str(item),)))\n    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)",
    ".sympy.core.symbol.py@@Symbol.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One)",
    ".sympy.core.basic.py@@Atom.class_key": "def class_key(cls):\n    return (2, 0, cls.__name__)",
    ".sympy.core.basic.py@@Basic.__str__": "def __str__(self):\n    from sympy.printing import sstr\n    return sstr(self, order=None)",
    ".sympy.printing.str.py@@sstr": "def sstr(expr, **settings):\n    p = StrPrinter(settings)\n    s = p.doprint(expr)\n    return s",
    ".sympy.printing.printer.py@@Printer.__init__": "def __init__(self, settings=None):\n    self._str = str\n    self._settings = self._default_settings.copy()\n    self._context = dict()\n    for key, val in self._global_settings.items():\n        if key in self._default_settings:\n            self._settings[key] = val\n    if settings is not None:\n        self._settings.update(settings)\n        if len(self._settings) > len(self._default_settings):\n            for key in self._settings:\n                if key not in self._default_settings:\n                    raise TypeError(\"Unknown setting '%s'.\" % key)\n    self._print_level = 0",
    ".sympy.printing.printer.py@@Printer.doprint": "def doprint(self, expr):\n    return self._str(self._print(expr))",
    ".sympy.core.numbers.py@@Number.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (0, ()), (), self)",
    ".sympy.core.numbers.py@@Number.class_key": "def class_key(cls):\n    return (1, 0, 'Number')",
    ".sympy.printing.codeprinter.py@@CodePrinter._print_Function": "def _print_Function(self, expr):\n    if expr.func.__name__ in self.known_functions:\n        cond_func = self.known_functions[expr.func.__name__]\n        func = None\n        if isinstance(cond_func, str):\n            func = cond_func\n        else:\n            for cond, func in cond_func:\n                if cond(*expr.args):\n                    break\n        if func is not None:\n            try:\n                return func(self, *[self.parenthesize(item, 0) for item in expr.args])\n            except TypeError:\n                try:\n                    return func(*[self.parenthesize(item, 0) for item in expr.args])\n                except TypeError:\n                    return '%s(%s)' % (func, self.stringify(expr.args, ', '))\n    elif hasattr(expr, '_imp_') and isinstance(expr._imp_, Lambda):\n        return self._print(expr._imp_(*expr.args))\n    else:\n        return self._print_not_supported(expr)",
    ".sympy.core.function.py@@Application.func": "def func(self):\n    return self.__class__",
    ".sympy.printing.codeprinter.py@@CodePrinter._print_not_supported": "def _print_not_supported(self, expr):\n    self._not_supported.add(expr)\n    return self.emptyPrinter(expr)",
    ".sympy.printing.str.py@@StrPrinter.emptyPrinter": "def emptyPrinter(self, expr):\n    if isinstance(expr, str):\n        return expr\n    elif isinstance(expr, Basic):\n        if hasattr(expr, 'args'):\n            return repr(expr)\n        else:\n            raise\n    else:\n        return str(expr)",
    ".sympy.core.basic.py@@Basic.__repr__": "def __repr__(self):\n    from sympy.printing import sstr\n    return sstr(self, order=None)",
    ".sympy.printing.str.py@@StrPrinter._print_Function": "def _print_Function(self, expr):\n    return expr.func.__name__ + '(%s)' % self.stringify(expr.args, ', ')",
    ".sympy.printing.pycode.py@@PythonCodePrinter._get_comment": "def _get_comment(self, text):\n    return '  # {0}'.format(text)",
    ".sympy.printing.str.py@@StrPrinter._print_Mul": "def _print_Mul(self, expr):\n    prec = precedence(expr)\n    c, e = expr.as_coeff_Mul()\n    if c < 0:\n        expr = _keep_coeff(-c, e)\n        sign = '-'\n    else:\n        sign = ''\n    a = []\n    b = []\n    pow_paren = []\n    if self.order not in ('old', 'none'):\n        args = expr.as_ordered_factors()\n    else:\n        args = Mul.make_args(expr)\n    for item in args:\n        if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n            if item.exp != -1:\n                b.append(Pow(item.base, -item.exp, evaluate=False))\n            else:\n                if len(item.args[0].args) != 1 and isinstance(item.base, Mul):\n                    pow_paren.append(item)\n                b.append(Pow(item.base, -item.exp))\n        elif item.is_Rational and item is not S.Infinity:\n            if item.p != 1:\n                a.append(Rational(item.p))\n            if item.q != 1:\n                b.append(Rational(item.q))\n        else:\n            a.append(item)\n    a = a or [S.One]\n    a_str = [self.parenthesize(x, prec, strict=False) for x in a]\n    b_str = [self.parenthesize(x, prec, strict=False) for x in b]\n    for item in pow_paren:\n        if item.base in b:\n            b_str[b.index(item.base)] = '(%s)' % b_str[b.index(item.base)]\n    if len(b) == 0:\n        return sign + '*'.join(a_str)\n    elif len(b) == 1:\n        return sign + '*'.join(a_str) + '/' + b_str[0]\n    else:\n        return sign + '*'.join(a_str) + '/(%s)' % '*'.join(b_str)",
    ".sympy.printing.precedence.py@@precedence_Integer": "def precedence_Integer(item):\n    if item.p < 0:\n        return PRECEDENCE['Add']\n    return PRECEDENCE['Atom']",
    ".sympy.printing.str.py@@StrPrinter._print_Integer": "def _print_Integer(self, expr):\n    if self._settings.get('sympy_integers', False):\n        return 'S(%s)' % expr\n    return str(expr.p)",
    ".sympy.core.numbers.py@@Rational.__new__": "def __new__(cls, p, q=None, gcd=None):\n    if q is None:\n        if isinstance(p, Rational):\n            return p\n        if isinstance(p, SYMPY_INTS):\n            pass\n        else:\n            if isinstance(p, (float, Float)):\n                return Rational(*_as_integer_ratio(p))\n            if not isinstance(p, string_types):\n                try:\n                    p = sympify(p)\n                except (SympifyError, SyntaxError):\n                    pass\n            else:\n                if p.count('/') > 1:\n                    raise TypeError('invalid input: %s' % p)\n                p = p.replace(' ', '')\n                pq = p.rsplit('/', 1)\n                if len(pq) == 2:\n                    p, q = pq\n                    fp = fractions.Fraction(p)\n                    fq = fractions.Fraction(q)\n                    p = fp / fq\n                try:\n                    p = fractions.Fraction(p)\n                except ValueError:\n                    pass\n                else:\n                    return Rational(p.numerator, p.denominator, 1)\n            if not isinstance(p, Rational):\n                raise TypeError('invalid input: %s' % p)\n        q = 1\n        gcd = 1\n    else:\n        p = Rational(p)\n        q = Rational(q)\n    if isinstance(q, Rational):\n        p *= q.q\n        q = q.p\n    if isinstance(p, Rational):\n        q *= p.q\n        p = p.p\n    if q == 0:\n        if p == 0:\n            if _errdict['divide']:\n                raise ValueError('Indeterminate 0/0')\n            else:\n                return S.NaN\n        return S.ComplexInfinity\n    if q < 0:\n        q = -q\n        p = -p\n    if not gcd:\n        gcd = igcd(abs(p), q)\n    if gcd > 1:\n        p //= gcd\n        q //= gcd\n    if q == 1:\n        return Integer(p)\n    if p == 1 and q == 2:\n        return S.Half\n    obj = Expr.__new__(cls)\n    obj.p = p\n    obj.q = q\n    return obj",
    ".sympy.matrices.expressions.matexpr.py@@MatrixSymbol._hashable_content": "def _hashable_content(self):\n    return (self.name, self.shape)",
    ".sympy.matrices.expressions.matexpr.py@@MatrixSymbol.name": "def name(self):\n    return self.args[0]",
    ".sympy.matrices.expressions.matexpr.py@@MatrixSymbol.shape": "def shape(self):\n    return self.args[1:3]",
    ".sympy.core.numbers.py@@Integer.__add__": "def __add__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    ".sympy.core.containers.py@@Tuple.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.basic.py@@Atom.xreplace": "def xreplace(self, rule, hack2=False):\n    return rule.get(self, self)",
    ".sympy.core.containers.py@@Tuple.__hash__": "def __hash__(self):\n    return hash(self.args)"
}