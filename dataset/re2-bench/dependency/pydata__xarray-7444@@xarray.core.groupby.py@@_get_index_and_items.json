{
    ".xarray.core.groupby.py@@TimeResampleGrouper.first_items": "def first_items(self, index):\n    from xarray import CFTimeIndex\n    from xarray.core.resample_cftime import CFTimeGrouper\n    if isinstance(index, CFTimeIndex):\n        grouper = CFTimeGrouper(freq=self.freq, closed=self.closed, label=self.label, origin=self.origin, offset=self.offset, loffset=self.loffset)\n        return grouper.first_items(index)\n    else:\n        s = pd.Series(np.arange(index.size), index)\n        grouper = pd.Grouper(freq=self.freq, closed=self.closed, label=self.label, origin=self.origin, offset=self.offset)\n        first_items = s.groupby(grouper).first()\n        if self.loffset is not None:\n            _apply_loffset(self.loffset, first_items)\n    return first_items",
    ".xarray.core.groupby.py@@_apply_loffset": "def _apply_loffset(loffset: str | pd.DateOffset | datetime.timedelta | pd.Timedelta, result: pd.Series | pd.DataFrame):\n    if not isinstance(loffset, (str, pd.DateOffset, datetime.timedelta)):\n        raise ValueError(f'`loffset` must be a str, pd.DateOffset, datetime.timedelta, or pandas.Timedelta object. Got {loffset}.')\n    if isinstance(loffset, str):\n        loffset = pd.tseries.frequencies.to_offset(loffset)\n    needs_offset = isinstance(loffset, (pd.DateOffset, datetime.timedelta)) and isinstance(result.index, pd.DatetimeIndex) and (len(result.index) > 0)\n    if needs_offset:\n        result.index = result.index + loffset",
    ".xarray.core.resample_cftime.py@@CFTimeGrouper.__init__": "def __init__(self, freq: str | BaseCFTimeOffset, closed: SideOptions | None=None, label: SideOptions | None=None, loffset: str | datetime.timedelta | BaseCFTimeOffset | None=None, origin: str | CFTimeDatetime='start_day', offset: str | datetime.timedelta | None=None):\n    self.offset: datetime.timedelta | None\n    self.closed: SideOptions\n    self.label: SideOptions\n    self.freq = to_offset(freq)\n    self.loffset = loffset\n    self.origin = origin\n    if isinstance(self.freq, (MonthEnd, QuarterEnd, YearEnd)):\n        if closed is None:\n            self.closed = 'right'\n        else:\n            self.closed = closed\n        if label is None:\n            self.label = 'right'\n        else:\n            self.label = label\n    elif self.origin in ['end', 'end_day']:\n        if closed is None:\n            self.closed = 'right'\n        else:\n            self.closed = closed\n        if label is None:\n            self.label = 'right'\n        else:\n            self.label = label\n    else:\n        if closed is None:\n            self.closed = 'left'\n        else:\n            self.closed = closed\n        if label is None:\n            self.label = 'left'\n        else:\n            self.label = label\n    if offset is not None:\n        try:\n            self.offset = _convert_offset_to_timedelta(offset)\n        except (ValueError, AttributeError) as error:\n            raise ValueError(f'offset must be a datetime.timedelta object or an offset string that can be converted to a timedelta.  Got {offset} instead.') from error\n    else:\n        self.offset = None",
    ".xarray.coding.cftime_offsets.py@@to_offset": "def to_offset(freq):\n    if isinstance(freq, BaseCFTimeOffset):\n        return freq\n    else:\n        try:\n            freq_data = re.match(_PATTERN, freq).groupdict()\n        except AttributeError:\n            raise ValueError('Invalid frequency string provided')\n    freq = freq_data['freq']\n    multiples = freq_data['multiple']\n    multiples = 1 if multiples is None else int(multiples)\n    return _FREQUENCIES[freq](n=multiples)",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.__init__": "def __init__(self, n: int=1):\n    if not isinstance(n, int):\n        raise TypeError(\"The provided multiple 'n' must be an integer. Instead a value of type {!r} was provided.\".format(type(n)))\n    self.n = n",
    ".xarray.core.resample_cftime.py@@_convert_offset_to_timedelta": "def _convert_offset_to_timedelta(offset: datetime.timedelta | str | BaseCFTimeOffset) -> datetime.timedelta:\n    if isinstance(offset, datetime.timedelta):\n        return offset\n    elif isinstance(offset, (str, Tick)):\n        return to_offset(offset).as_timedelta()\n    else:\n        raise ValueError",
    ".xarray.core.resample_cftime.py@@CFTimeGrouper.first_items": "def first_items(self, index: CFTimeIndex):\n    datetime_bins, labels = _get_time_bins(index, self.freq, self.closed, self.label, self.origin, self.offset)\n    if self.loffset is not None:\n        if not isinstance(self.loffset, (str, datetime.timedelta, BaseCFTimeOffset)):\n            raise ValueError(f'`loffset` must be a str or datetime.timedelta object. Got {self.loffset}.')\n        if isinstance(self.loffset, datetime.timedelta):\n            labels = labels + self.loffset\n        else:\n            labels = labels + to_offset(self.loffset)\n    if index[0] < datetime_bins[0]:\n        raise ValueError('Value falls before first bin')\n    if index[-1] > datetime_bins[-1]:\n        raise ValueError('Value falls after last bin')\n    integer_bins = np.searchsorted(index, datetime_bins, side=self.closed)[:-1]\n    first_items = pd.Series(integer_bins, labels)\n    non_duplicate = ~first_items.duplicated('last')\n    return first_items.where(non_duplicate)",
    ".xarray.core.resample_cftime.py@@_get_time_bins": "def _get_time_bins(index: CFTimeIndex, freq: BaseCFTimeOffset, closed: SideOptions, label: SideOptions, origin: str | CFTimeDatetime, offset: datetime.timedelta | None):\n    if not isinstance(index, CFTimeIndex):\n        raise TypeError(f'index must be a CFTimeIndex, but got an instance of {type(index).__name__!r}')\n    if len(index) == 0:\n        datetime_bins = labels = CFTimeIndex(data=[], name=index.name)\n        return (datetime_bins, labels)\n    first, last = _get_range_edges(index.min(), index.max(), freq, closed=closed, origin=origin, offset=offset)\n    datetime_bins = labels = cftime_range(freq=freq, start=first, end=last, name=index.name)\n    datetime_bins, labels = _adjust_bin_edges(datetime_bins, freq, closed, index, labels)\n    labels = labels[1:] if label == 'right' else labels[:-1]\n    return (datetime_bins, labels)",
    ".xarray.core.resample_cftime.py@@_get_range_edges": "def _get_range_edges(first: CFTimeDatetime, last: CFTimeDatetime, freq: BaseCFTimeOffset, closed: SideOptions='left', origin: str | CFTimeDatetime='start_day', offset: datetime.timedelta | None=None):\n    if isinstance(freq, Tick):\n        first, last = _adjust_dates_anchored(first, last, freq, closed=closed, origin=origin, offset=offset)\n        return (first, last)\n    else:\n        first = normalize_date(first)\n        last = normalize_date(last)\n    first = freq.rollback(first) if closed == 'left' else first - freq\n    last = last + freq\n    return (first, last)",
    ".xarray.core.resample_cftime.py@@_adjust_dates_anchored": "def _adjust_dates_anchored(first: CFTimeDatetime, last: CFTimeDatetime, freq: Tick, closed: SideOptions='right', origin: str | CFTimeDatetime='start_day', offset: datetime.timedelta | None=None):\n    import cftime\n    if origin == 'start_day':\n        origin_date = normalize_date(first)\n    elif origin == 'start':\n        origin_date = first\n    elif origin == 'epoch':\n        origin_date = type(first)(1970, 1, 1)\n    elif origin in ['end', 'end_day']:\n        origin_last = last if origin == 'end' else _ceil_via_cftimeindex(last, 'D')\n        sub_freq_times = (origin_last - first) // freq.as_timedelta()\n        if closed == 'left':\n            sub_freq_times += 1\n        first = origin_last - sub_freq_times * freq\n        origin_date = first\n    elif isinstance(origin, cftime.datetime):\n        origin_date = origin\n    else:\n        raise ValueError(f\"origin must be one of {{'epoch', 'start_day', 'start', 'end', 'end_day'}} or a cftime.datetime object.  Got {origin}.\")\n    if offset is not None:\n        origin_date = origin_date + offset\n    foffset = (first - origin_date) % freq.as_timedelta()\n    loffset = (last - origin_date) % freq.as_timedelta()\n    if closed == 'right':\n        if foffset.total_seconds() > 0:\n            fresult = first - foffset\n        else:\n            fresult = first - freq.as_timedelta()\n        if loffset.total_seconds() > 0:\n            lresult = last + (freq.as_timedelta() - loffset)\n        else:\n            lresult = last\n    else:\n        if foffset.total_seconds() > 0:\n            fresult = first - foffset\n        else:\n            fresult = first\n        if loffset.total_seconds() > 0:\n            lresult = last + (freq.as_timedelta() - loffset)\n        else:\n            lresult = last + freq\n    return (fresult, lresult)",
    ".xarray.coding.cftime_offsets.py@@Day.as_timedelta": "def as_timedelta(self):\n    return timedelta(days=self.n)",
    ".xarray.coding.cftime_offsets.py@@cftime_range": "def cftime_range(start=None, end=None, periods=None, freq='D', normalize=False, name=None, closed: NoDefault | SideOptions=no_default, inclusive: None | InclusiveOptions=None, calendar='standard'):\n    if count_not_none(start, end, periods, freq) != 3:\n        raise ValueError(\"Of the arguments 'start', 'end', 'periods', and 'freq', three must be specified at a time.\")\n    if start is not None:\n        start = to_cftime_datetime(start, calendar)\n        start = _maybe_normalize_date(start, normalize)\n    if end is not None:\n        end = to_cftime_datetime(end, calendar)\n        end = _maybe_normalize_date(end, normalize)\n    if freq is None:\n        dates = _generate_linear_range(start, end, periods)\n    else:\n        offset = to_offset(freq)\n        dates = np.array(list(_generate_range(start, end, periods, offset)))\n    inclusive = _infer_inclusive(closed, inclusive)\n    if inclusive == 'neither':\n        left_closed = False\n        right_closed = False\n    elif inclusive == 'left':\n        left_closed = True\n        right_closed = False\n    elif inclusive == 'right':\n        left_closed = False\n        right_closed = True\n    elif inclusive == 'both':\n        left_closed = True\n        right_closed = True\n    else:\n        raise ValueError(f\"Argument `inclusive` must be either 'both', 'neither', 'left', 'right', or None.  Got {inclusive}.\")\n    if not left_closed and len(dates) and (start is not None) and (dates[0] == start):\n        dates = dates[1:]\n    if not right_closed and len(dates) and (end is not None) and (dates[-1] == end):\n        dates = dates[:-1]\n    return CFTimeIndex(dates, name=name)",
    ".xarray.core.pdcompat.py@@count_not_none": "def count_not_none(*args) -> int:\n    return sum((arg is not None for arg in args))",
    ".xarray.coding.cftime_offsets.py@@to_cftime_datetime": "def to_cftime_datetime(date_str_or_date, calendar=None):\n    if cftime is None:\n        raise ModuleNotFoundError(\"No module named 'cftime'\")\n    if isinstance(date_str_or_date, str):\n        if calendar is None:\n            raise ValueError('If converting a string to a cftime.datetime object, a calendar type must be provided')\n        date, _ = _parse_iso8601_with_reso(get_date_type(calendar), date_str_or_date)\n        return date\n    elif isinstance(date_str_or_date, cftime.datetime):\n        return date_str_or_date\n    elif isinstance(date_str_or_date, (datetime, pd.Timestamp)):\n        return cftime.DatetimeProlepticGregorian(*date_str_or_date.timetuple())\n    else:\n        raise TypeError('date_str_or_date must be a string or a subclass of cftime.datetime. Instead got {!r}.'.format(date_str_or_date))",
    ".xarray.coding.cftime_offsets.py@@_maybe_normalize_date": "def _maybe_normalize_date(date, normalize):\n    if normalize:\n        return normalize_date(date)\n    else:\n        return date",
    ".xarray.coding.cftime_offsets.py@@_generate_range": "def _generate_range(start, end, periods, offset):\n    if start:\n        start = offset.rollforward(start)\n    if end:\n        end = offset.rollback(end)\n    if periods is None and end < start:\n        end = None\n        periods = 0\n    if end is None:\n        end = start + (periods - 1) * offset\n    if start is None:\n        start = end - (periods - 1) * offset\n    current = start\n    if offset.n >= 0:\n        while current <= end:\n            yield current\n            next_date = current + offset\n            if next_date <= current:\n                raise ValueError(f'Offset {offset} did not increment date')\n            current = next_date\n    else:\n        while current >= end:\n            yield current\n            next_date = current + offset\n            if next_date >= current:\n                raise ValueError(f'Offset {offset} did not decrement date')\n            current = next_date",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.rollforward": "def rollforward(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date + type(self)()",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.onOffset": "def onOffset(self, date):\n    test_date = self + date - self\n    return date == test_date",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.__add__": "def __add__(self, other):\n    return self.__apply__(other)",
    ".xarray.coding.cftime_offsets.py@@Day.__apply__": "def __apply__(self, other):\n    return other + self.as_timedelta()",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.__rsub__": "def __rsub__(self, other):\n    if isinstance(other, BaseCFTimeOffset) and type(self) != type(other):\n        raise TypeError('Cannot subtract cftime offsets of differing types')\n    return -self + other",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.__neg__": "def __neg__(self):\n    return self * -1",
    ".xarray.coding.cftime_offsets.py@@Tick.__mul__": "def __mul__(self, other):\n    if not isinstance(other, (int, float)):\n        return NotImplemented\n    if isinstance(other, float):\n        n = other * self.n\n        if np.isclose(n % 1, 0):\n            return type(self)(int(n))\n        new_self = self._next_higher_resolution()\n        return new_self * other\n    return type(self)(n=other * self.n)",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.rollback": "def rollback(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date - type(self)()",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.__radd__": "def __radd__(self, other):\n    return self.__add__(other)",
    ".xarray.coding.cftime_offsets.py@@_infer_inclusive": "def _infer_inclusive(closed, inclusive):\n    if closed is not no_default and inclusive is not None:\n        raise ValueError('Following pandas, deprecated argument `closed` cannot be passed if argument `inclusive` is not None.')\n    if closed is not no_default:\n        inclusive = _translate_closed_to_inclusive(closed)\n    elif inclusive is None:\n        inclusive = 'both'\n    return inclusive",
    ".xarray.coding.cftimeindex.py@@CFTimeIndex.__new__": "def __new__(cls, data, name=None, **kwargs):\n    assert_all_valid_date_type(data)\n    if name is None and hasattr(data, 'name'):\n        name = data.name\n    result = object.__new__(cls)\n    result._data = np.array(data, dtype='O')\n    result.name = name\n    result._cache = {}\n    return result",
    ".xarray.coding.cftimeindex.py@@assert_all_valid_date_type": "def assert_all_valid_date_type(data):\n    if cftime is None:\n        raise ModuleNotFoundError(\"No module named 'cftime'\")\n    if len(data) > 0:\n        sample = data[0]\n        date_type = type(sample)\n        if not isinstance(sample, cftime.datetime):\n            raise TypeError('CFTimeIndex requires cftime.datetime objects. Got object of {}.'.format(date_type))\n        if not all((isinstance(value, date_type) for value in data)):\n            raise TypeError('CFTimeIndex requires using datetime objects of all the same type.  Got\\n{}.'.format(data))",
    ".xarray.core.resample_cftime.py@@_adjust_bin_edges": "def _adjust_bin_edges(datetime_bins: np.ndarray, freq: BaseCFTimeOffset, closed: SideOptions, index: CFTimeIndex, labels: np.ndarray):\n    is_super_daily = isinstance(freq, (MonthEnd, QuarterEnd, YearEnd)) or (isinstance(freq, Day) and freq.n > 1)\n    if is_super_daily:\n        if closed == 'right':\n            datetime_bins = datetime_bins + datetime.timedelta(days=1, microseconds=-1)\n        if datetime_bins[-2] > index.max():\n            datetime_bins = datetime_bins[:-1]\n            labels = labels[:-1]\n    return (datetime_bins, labels)",
    ".xarray.coding.cftimeindex.py@@CFTimeIndex.__add__": "def __add__(self, other):\n    if isinstance(other, pd.TimedeltaIndex):\n        other = other.to_pytimedelta()\n    return CFTimeIndex(np.array(self) + other)",
    ".xarray.coding.cftime_offsets.py@@Hour.__apply__": "def __apply__(self, other):\n    return other + self.as_timedelta()",
    ".xarray.coding.cftime_offsets.py@@Hour.as_timedelta": "def as_timedelta(self):\n    return timedelta(hours=self.n)",
    ".xarray.coding.cftime_offsets.py@@YearOffset.__init__": "def __init__(self, n=1, month=None):\n    BaseCFTimeOffset.__init__(self, n)\n    self.month = _validate_month(month, self._default_month)",
    ".xarray.coding.cftime_offsets.py@@_validate_month": "def _validate_month(month, default_month):\n    result_month = default_month if month is None else month\n    if not isinstance(result_month, int):\n        raise TypeError(\"'self.month' must be an integer value between 1 and 12.  Instead, it was set to a value of {!r}\".format(result_month))\n    elif not 1 <= result_month <= 12:\n        raise ValueError(\"'self.month' must be an integer value between 1 and 12.  Instead, it was set to a value of {!r}\".format(result_month))\n    return result_month",
    ".xarray.coding.cftime_offsets.py@@normalize_date": "def normalize_date(date):\n    return date.replace(hour=0, minute=0, second=0, microsecond=0)",
    ".xarray.coding.cftime_offsets.py@@YearBegin.rollback": "def rollback(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date - YearBegin(month=self.month)",
    ".xarray.coding.cftime_offsets.py@@YearBegin.onOffset": "def onOffset(self, date):\n    return date.day == 1 and date.month == self.month",
    ".xarray.coding.cftime_offsets.py@@YearOffset.__apply__": "def __apply__(self, other):\n    reference_day = _get_day_of_month(other, self._day_option)\n    years = _adjust_n_years(other, self.n, self.month, reference_day)\n    months = years * 12 + (self.month - other.month)\n    return _shift_month(other, months, self._day_option)",
    ".xarray.coding.cftime_offsets.py@@_get_day_of_month": "def _get_day_of_month(other, day_option):\n    if day_option == 'start':\n        return 1\n    elif day_option == 'end':\n        return _days_in_month(other)\n    elif day_option is None:\n        raise NotImplementedError()\n    else:\n        raise ValueError(day_option)",
    ".xarray.coding.cftime_offsets.py@@_adjust_n_years": "def _adjust_n_years(other, n, month, reference_day):\n    if n > 0:\n        if other.month < month or (other.month == month and other.day < reference_day):\n            n -= 1\n    elif other.month > month or (other.month == month and other.day > reference_day):\n        n += 1\n    return n",
    ".xarray.coding.cftime_offsets.py@@_shift_month": "def _shift_month(date, months, day_option='start'):\n    if cftime is None:\n        raise ModuleNotFoundError(\"No module named 'cftime'\")\n    delta_year = (date.month + months) // 12\n    month = (date.month + months) % 12\n    if month == 0:\n        month = 12\n        delta_year = delta_year - 1\n    year = date.year + delta_year\n    if day_option == 'start':\n        day = 1\n    elif day_option == 'end':\n        reference = type(date)(year, month, 1)\n        day = _days_in_month(reference)\n    else:\n        raise ValueError(day_option)\n    return date.replace(year=year, month=month, day=day)",
    ".xarray.coding.cftime_offsets.py@@YearBegin.rollforward": "def rollforward(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date + YearBegin(month=self.month)",
    ".xarray.coding.cftime_offsets.py@@Minute.as_timedelta": "def as_timedelta(self):\n    return timedelta(minutes=self.n)",
    ".xarray.coding.cftime_offsets.py@@Minute.__apply__": "def __apply__(self, other):\n    return other + self.as_timedelta()",
    ".xarray.coding.cftime_offsets.py@@MonthBegin.onOffset": "def onOffset(self, date):\n    return date.day == 1",
    ".xarray.coding.cftime_offsets.py@@MonthBegin.__apply__": "def __apply__(self, other):\n    n = _adjust_n_months(other.day, self.n, 1)\n    return _shift_month(other, n, 'start')",
    ".xarray.coding.cftime_offsets.py@@_adjust_n_months": "def _adjust_n_months(other_day, n, reference_day):\n    if n > 0 and other_day < reference_day:\n        n = n - 1\n    elif n <= 0 and other_day > reference_day:\n        n = n + 1\n    return n",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.__mul__": "def __mul__(self, other):\n    if not isinstance(other, int):\n        return NotImplemented\n    return type(self)(n=other * self.n)",
    ".xarray.coding.cftime_offsets.py@@MonthEnd.__apply__": "def __apply__(self, other):\n    n = _adjust_n_months(other.day, self.n, _days_in_month(other))\n    return _shift_month(other, n, 'end')",
    ".xarray.coding.cftime_offsets.py@@_days_in_month": "def _days_in_month(date):\n    if date.month == 12:\n        reference = type(date)(date.year + 1, 1, 1)\n    else:\n        reference = type(date)(date.year, date.month + 1, 1)\n    return (reference - timedelta(days=1)).day",
    ".xarray.coding.cftime_offsets.py@@MonthEnd.onOffset": "def onOffset(self, date):\n    return date.day == _days_in_month(date)",
    ".xarray.coding.cftime_offsets.py@@QuarterOffset.__init__": "def __init__(self, n=1, month=None):\n    BaseCFTimeOffset.__init__(self, n)\n    self.month = _validate_month(month, self._default_month)",
    ".xarray.coding.cftime_offsets.py@@QuarterBegin.rollback": "def rollback(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date - QuarterBegin(month=self.month)",
    ".xarray.coding.cftime_offsets.py@@QuarterOffset.onOffset": "def onOffset(self, date):\n    mod_month = (date.month - self.month) % 3\n    return mod_month == 0 and date.day == self._get_offset_day(date)",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset._get_offset_day": "def _get_offset_day(self, other):\n    return _get_day_of_month(other, self._day_option)",
    ".xarray.coding.cftime_offsets.py@@QuarterOffset.__mul__": "def __mul__(self, other):\n    if isinstance(other, float):\n        return NotImplemented\n    return type(self)(n=other * self.n, month=self.month)",
    ".xarray.coding.cftime_offsets.py@@QuarterOffset.__apply__": "def __apply__(self, other):\n    months_since = other.month % 3 - self.month % 3\n    qtrs = roll_qtrday(other, self.n, self.month, day_option=self._day_option, modby=3)\n    months = qtrs * 3 - months_since\n    return _shift_month(other, months, self._day_option)",
    ".xarray.coding.cftime_offsets.py@@roll_qtrday": "def roll_qtrday(other, n, month, day_option, modby=3):\n    months_since = other.month % modby - month % modby\n    if n > 0:\n        if months_since < 0 or (months_since == 0 and other.day < _get_day_of_month(other, day_option)):\n            n -= 1\n    elif months_since > 0 or (months_since == 0 and other.day > _get_day_of_month(other, day_option)):\n        n += 1\n    return n",
    ".xarray.coding.cftime_offsets.py@@QuarterBegin.rollforward": "def rollforward(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date + QuarterBegin(month=self.month)",
    ".xarray.coding.cftime_offsets.py@@YearOffset.__mul__": "def __mul__(self, other):\n    if isinstance(other, float):\n        return NotImplemented\n    return type(self)(n=other * self.n, month=self.month)",
    ".xarray.coding.cftime_offsets.py@@YearEnd.rollforward": "def rollforward(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date + YearEnd(month=self.month)",
    ".xarray.coding.cftime_offsets.py@@YearEnd.onOffset": "def onOffset(self, date):\n    return date.day == _days_in_month(date) and date.month == self.month",
    ".xarray.coding.cftime_offsets.py@@YearEnd.rollback": "def rollback(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date - YearEnd(month=self.month)",
    ".xarray.coding.cftime_offsets.py@@QuarterEnd.rollforward": "def rollforward(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date + QuarterEnd(month=self.month)",
    ".xarray.coding.cftime_offsets.py@@QuarterEnd.rollback": "def rollback(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date - QuarterEnd(month=self.month)",
    ".xarray.coding.cftime_offsets.py@@Second.as_timedelta": "def as_timedelta(self):\n    return timedelta(seconds=self.n)"
}