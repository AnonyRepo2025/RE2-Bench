{
    ".sympy.core.function.py@@Application.func": "def func(self):\n    return self.__class__",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.evalf.py@@EvalfMixin._to_mpmath": "def _to_mpmath(self, prec, allow_ints=True):\n    errmsg = 'cannot convert to mpmath number'\n    if allow_ints and self.is_Integer:\n        return self.p\n    if hasattr(self, '_as_mpf_val'):\n        return make_mpf(self._as_mpf_val(prec))\n    try:\n        re, im, _, _ = evalf(self, prec, {})\n        if im:\n            if not re:\n                re = fzero\n            return make_mpc((re, im))\n        elif re:\n            return make_mpf(re)\n        else:\n            return make_mpf(fzero)\n    except NotImplementedError:\n        v = self._eval_evalf(prec)\n        if v is None:\n            raise ValueError(errmsg)\n        if v.is_Float:\n            return make_mpf(v._mpf_)\n        re, im = v.as_real_imag()\n        if allow_ints and re.is_Integer:\n            re = from_int(re.p)\n        elif re.is_Float:\n            re = re._mpf_\n        else:\n            raise ValueError(errmsg)\n        if allow_ints and im.is_Integer:\n            im = from_int(im.p)\n        elif im.is_Float:\n            im = im._mpf_\n        else:\n            raise ValueError(errmsg)\n        return make_mpc((re, im))",
    ".sympy.core.evalf.py@@evalf": "def evalf(x, prec, options):\n    from sympy import re as re_, im as im_\n    try:\n        rf = evalf_table[x.func]\n        r = rf(x, prec, options)\n    except KeyError:\n        try:\n            if 'subs' in options:\n                x = x.subs(evalf_subs(prec, options['subs']))\n            xe = x._eval_evalf(prec)\n            re, im = xe.as_real_imag()\n            if re.has(re_) or im.has(im_):\n                raise NotImplementedError\n            if re == 0:\n                re = None\n                reprec = None\n            elif re.is_number:\n                re = re._to_mpmath(prec, allow_ints=False)._mpf_\n                reprec = prec\n            else:\n                raise NotImplementedError\n            if im == 0:\n                im = None\n                imprec = None\n            elif im.is_number:\n                im = im._to_mpmath(prec, allow_ints=False)._mpf_\n                imprec = prec\n            else:\n                raise NotImplementedError\n            r = (re, im, reprec, imprec)\n        except AttributeError:\n            raise NotImplementedError\n    if options.get('verbose'):\n        print('### input', x)\n        print('### output', to_str(r[0] or fzero, 50))\n        print('### raw', r)\n        print()\n    chop = options.get('chop', False)\n    if chop:\n        if chop is True:\n            chop_prec = prec\n        else:\n            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))\n            if chop_prec == 3:\n                chop_prec -= 1\n        r = chop_parts(r, chop_prec)\n    if options.get('strict'):\n        check_target(x, r, prec)\n    return r",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.core.evalf.py@@evalf_add": "def evalf_add(v, prec, options):\n    res = pure_complex(v)\n    if res:\n        h, c = res\n        re, _, re_acc, _ = evalf(h, prec, options)\n        im, _, im_acc, _ = evalf(c, prec, options)\n        return (re, im, re_acc, im_acc)\n    oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)\n    i = 0\n    target_prec = prec\n    while 1:\n        options['maxprec'] = min(oldmaxprec, 2 * prec)\n        terms = [evalf(arg, prec + 10, options) for arg in v.args]\n        re, re_acc = add_terms([a[0::2] for a in terms if a[0]], prec, target_prec)\n        im, im_acc = add_terms([a[1::2] for a in terms if a[1]], prec, target_prec)\n        acc = complex_accuracy((re, im, re_acc, im_acc))\n        if acc >= target_prec:\n            if options.get('verbose'):\n                print('ADD: wanted', target_prec, 'accurate bits, got', re_acc, im_acc)\n            break\n        else:\n            if prec - target_prec > options['maxprec']:\n                break\n            prec = prec + max(10 + 2 ** i, target_prec - acc)\n            i += 1\n            if options.get('verbose'):\n                print('ADD: restarting with prec', prec)\n    options['maxprec'] = oldmaxprec\n    if iszero(re, scaled=True):\n        re = scaled_zero(re)\n    if iszero(im, scaled=True):\n        im = scaled_zero(im)\n    return (re, im, re_acc, im_acc)",
    ".sympy.core.evalf.py@@pure_complex": "def pure_complex(v, or_real=False):\n    h, t = v.as_coeff_Add()\n    if not t:\n        if or_real:\n            return (h, t)\n        return\n    c, i = t.as_coeff_Mul()\n    if i is S.ImaginaryUnit:\n        return (h, c)",
    ".sympy.core.add.py@@Add.as_coeff_Add": "def as_coeff_Add(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number and (not rational) or coeff.is_Rational:\n        return (coeff, self._new_rawargs(*args))\n    return (S.Zero, self)",
    ".sympy.core.operations.py@@AssocOp._new_rawargs": "def _new_rawargs(self, *args, **kwargs):\n    if kwargs.pop('reeval', True) and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)",
    ".sympy.core.operations.py@@AssocOp._from_args": "def _from_args(cls, args, is_commutative=None):\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n    obj = super(AssocOp, cls).__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and((a.is_commutative for a in args))\n    obj.is_commutative = is_commutative\n    return obj",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (S.One, self)"
}