{
    ".lib.matplotlib.pyplot.py@@gca": "def gca():\n    return gcf().gca()",
    ".lib.matplotlib.pyplot.py@@gcf": "def gcf():\n    manager = _pylab_helpers.Gcf.get_active()\n    if manager is not None:\n        return manager.canvas.figure\n    else:\n        return figure()",
    ".lib.matplotlib._pylab_helpers.py@@Gcf.get_active": "def get_active(cls):\n    return next(reversed(cls.figs.values())) if cls.figs else None",
    ".lib.matplotlib.figure.py@@FigureBase.gca": "def gca(self):\n    ax = self._axstack.current()\n    return ax if ax is not None else self.add_subplot()",
    ".lib.matplotlib.figure.py@@_AxesStack.current": "def current(self):\n    return max(self._axes, key=self._axes.__getitem__, default=None)",
    ".lib.matplotlib.axes._base.py@@_axis_method_wrapper.wrapper": "def wrapper(self, *args, **kwargs):\n    return get_method(self)(*args, **kwargs)",
    ".lib.matplotlib.axis.py@@Axis.get_ticklocs": "def get_ticklocs(self, *, minor=False):\n    return self.get_minorticklocs() if minor else self.get_majorticklocs()",
    ".lib.matplotlib.axis.py@@Axis.get_minorticklocs": "def get_minorticklocs(self):\n    minor_locs = np.asarray(self.minor.locator())\n    if self.remove_overlapping_locs:\n        major_locs = self.major.locator()\n        transform = self._scale.get_transform()\n        tr_minor_locs = transform.transform(minor_locs)\n        tr_major_locs = transform.transform(major_locs)\n        lo, hi = sorted(transform.transform(self.get_view_interval()))\n        tol = (hi - lo) * 1e-05\n        mask = np.isclose(tr_minor_locs[:, None], tr_major_locs[None, :], atol=tol, rtol=0).any(axis=1)\n        minor_locs = minor_locs[~mask]\n    return minor_locs",
    ".lib.matplotlib.axis.py@@Ticker.locator": "def locator(self):\n    return self._locator",
    ".lib.matplotlib.ticker.py@@NullLocator.__call__": "def __call__(self):\n    return self.tick_values(None, None)",
    ".lib.matplotlib.ticker.py@@NullLocator.tick_values": "def tick_values(self, vmin, vmax):\n    return []",
    ".lib.matplotlib.axis.py@@Axis.get_remove_overlapping_locs": "def get_remove_overlapping_locs(self):\n    return self._remove_overlapping_locs",
    ".lib.matplotlib.ticker.py@@MaxNLocator.__call__": "def __call__(self):\n    vmin, vmax = self.axis.get_view_interval()\n    return self.tick_values(vmin, vmax)",
    ".lib.matplotlib.axis.py@@getter": "def getter(self):\n    return getattr(getattr(self.axes, lim_name), attr_name)",
    ".lib.matplotlib.artist.py@@Artist.axes": "def axes(self):\n    return self._axes",
    ".lib.matplotlib.axes._base.py@@_AxesBase.viewLim": "def viewLim(self):\n    self._unstale_viewLim()\n    return self._viewLim",
    ".lib.matplotlib.axes._base.py@@_AxesBase._unstale_viewLim": "def _unstale_viewLim(self):\n    need_scale = {name: any((ax._stale_viewlims[name] for ax in self._shared_axes[name].get_siblings(self))) for name in self._axis_names}\n    if any(need_scale.values()):\n        for name in need_scale:\n            for ax in self._shared_axes[name].get_siblings(self):\n                ax._stale_viewlims[name] = False\n        self.autoscale_view(**{f'scale{name}': scale for name, scale in need_scale.items()})",
    ".lib.matplotlib.cbook.__init__.py@@Grouper.get_siblings": "def get_siblings(self, a):\n    self.clean()\n    siblings = self._mapping.get(weakref.ref(a), [weakref.ref(a)])\n    return [x() for x in siblings]",
    ".lib.matplotlib.cbook.__init__.py@@Grouper.clean": "def clean(self):\n    mapping = self._mapping\n    to_drop = [key for key in mapping if key() is None]\n    for key in to_drop:\n        val = mapping.pop(key)\n        val.remove(key)",
    ".lib.matplotlib.axes._base.py@@_AxesBase.autoscale_view": "def autoscale_view(self, tight=None, scalex=True, scaley=True):\n    if tight is not None:\n        self._tight = bool(tight)\n    x_stickies = y_stickies = np.array([])\n    if self.use_sticky_edges:\n        if self._xmargin and scalex and self.get_autoscalex_on():\n            x_stickies = np.sort(np.concatenate([artist.sticky_edges.x for ax in self._shared_axes['x'].get_siblings(self) if hasattr(ax, '_children') for artist in ax.get_children()]))\n        if self._ymargin and scaley and self.get_autoscaley_on():\n            y_stickies = np.sort(np.concatenate([artist.sticky_edges.y for ax in self._shared_axes['y'].get_siblings(self) if hasattr(ax, '_children') for artist in ax.get_children()]))\n    if self.get_xscale() == 'log':\n        x_stickies = x_stickies[x_stickies > 0]\n    if self.get_yscale() == 'log':\n        y_stickies = y_stickies[y_stickies > 0]\n\n    def handle_single_axis(scale, shared_axes, name, axis, margin, stickies, set_bound):\n        if not (scale and axis._get_autoscale_on()):\n            return\n        shared = shared_axes.get_siblings(self)\n        values = [val for ax in shared for val in getattr(ax.dataLim, f'interval{name}') if np.isfinite(val)]\n        if values:\n            x0, x1 = (min(values), max(values))\n        elif getattr(self._viewLim, f'mutated{name}')():\n            return\n        else:\n            x0, x1 = (-np.inf, np.inf)\n        locator = axis.get_major_locator()\n        x0, x1 = locator.nonsingular(x0, x1)\n        minimum_minpos = min((getattr(ax.dataLim, f'minpos{name}') for ax in shared))\n        tol = 1e-05 * max(abs(x0), abs(x1), abs(x1 - x0))\n        i0 = stickies.searchsorted(x0 + tol) - 1\n        x0bound = stickies[i0] if i0 != -1 else None\n        i1 = stickies.searchsorted(x1 - tol)\n        x1bound = stickies[i1] if i1 != len(stickies) else None\n        transform = axis.get_transform()\n        inverse_trans = transform.inverted()\n        x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minimum_minpos)\n        x0t, x1t = transform.transform([x0, x1])\n        delta = (x1t - x0t) * margin\n        if not np.isfinite(delta):\n            delta = 0\n        x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])\n        if x0bound is not None:\n            x0 = max(x0, x0bound)\n        if x1bound is not None:\n            x1 = min(x1, x1bound)\n        if not self._tight:\n            x0, x1 = locator.view_limits(x0, x1)\n        set_bound(x0, x1)\n    handle_single_axis(scalex, self._shared_axes['x'], 'x', self.xaxis, self._xmargin, x_stickies, self.set_xbound)\n    handle_single_axis(scaley, self._shared_axes['y'], 'y', self.yaxis, self._ymargin, y_stickies, self.set_ybound)",
    ".lib.matplotlib.axes._base.py@@_AxesBase.use_sticky_edges": "def use_sticky_edges(self):\n    return self._use_sticky_edges",
    ".lib.matplotlib.axis.py@@Axis.get_scale": "def get_scale(self):\n    return self._scale.name",
    ".lib.matplotlib.axes._base.py@@_AxesBase.handle_single_axis": "def handle_single_axis(scale, shared_axes, name, axis, margin, stickies, set_bound):\n    if not (scale and axis._get_autoscale_on()):\n        return\n    shared = shared_axes.get_siblings(self)\n    values = [val for ax in shared for val in getattr(ax.dataLim, f'interval{name}') if np.isfinite(val)]\n    if values:\n        x0, x1 = (min(values), max(values))\n    elif getattr(self._viewLim, f'mutated{name}')():\n        return\n    else:\n        x0, x1 = (-np.inf, np.inf)\n    locator = axis.get_major_locator()\n    x0, x1 = locator.nonsingular(x0, x1)\n    minimum_minpos = min((getattr(ax.dataLim, f'minpos{name}') for ax in shared))\n    tol = 1e-05 * max(abs(x0), abs(x1), abs(x1 - x0))\n    i0 = stickies.searchsorted(x0 + tol) - 1\n    x0bound = stickies[i0] if i0 != -1 else None\n    i1 = stickies.searchsorted(x1 - tol)\n    x1bound = stickies[i1] if i1 != len(stickies) else None\n    transform = axis.get_transform()\n    inverse_trans = transform.inverted()\n    x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minimum_minpos)\n    x0t, x1t = transform.transform([x0, x1])\n    delta = (x1t - x0t) * margin\n    if not np.isfinite(delta):\n        delta = 0\n    x0, x1 = inverse_trans.transform([x0t - delta, x1t + delta])\n    if x0bound is not None:\n        x0 = max(x0, x0bound)\n    if x1bound is not None:\n        x1 = min(x1, x1bound)\n    if not self._tight:\n        x0, x1 = locator.view_limits(x0, x1)\n    set_bound(x0, x1)",
    ".lib.matplotlib.axis.py@@Axis._get_autoscale_on": "def _get_autoscale_on(self):\n    return self._autoscale_on",
    ".lib.matplotlib.transforms.py@@BboxBase.intervalx": "def intervalx(self):\n    return self.get_points()[:, 0]",
    ".lib.matplotlib.transforms.py@@Bbox.get_points": "def get_points(self):\n    self._invalid = 0\n    return self._points",
    ".lib.matplotlib.axis.py@@Axis.get_major_locator": "def get_major_locator(self):\n    return self.major.locator",
    ".lib.matplotlib.ticker.py@@Locator.nonsingular": "def nonsingular(self, v0, v1):\n    return mtransforms.nonsingular(v0, v1, expander=0.05)",
    ".lib.matplotlib.transforms.py@@nonsingular": "def nonsingular(vmin, vmax, expander=0.001, tiny=1e-15, increasing=True):\n    if not np.isfinite(vmin) or not np.isfinite(vmax):\n        return (-expander, expander)\n    swapped = False\n    if vmax < vmin:\n        vmin, vmax = (vmax, vmin)\n        swapped = True\n    vmin, vmax = map(float, [vmin, vmax])\n    maxabsvalue = max(abs(vmin), abs(vmax))\n    if maxabsvalue < 1000000.0 / tiny * np.finfo(float).tiny:\n        vmin = -expander\n        vmax = expander\n    elif vmax - vmin <= maxabsvalue * tiny:\n        if vmax == 0 and vmin == 0:\n            vmin = -expander\n            vmax = expander\n        else:\n            vmin -= expander * abs(vmin)\n            vmax += expander * abs(vmax)\n    if swapped and (not increasing):\n        vmin, vmax = (vmax, vmin)\n    return (vmin, vmax)",
    ".lib.matplotlib.transforms.py@@Bbox.minposx": "def minposx(self):\n    return self._minpos[0]",
    ".lib.matplotlib.axis.py@@Axis.get_transform": "def get_transform(self):\n    return self._scale.get_transform()",
    ".lib.matplotlib.scale.py@@LinearScale.get_transform": "def get_transform(self):\n    return IdentityTransform()",
    ".lib.matplotlib.transforms.py@@AffineBase.__init__": "def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self._inverted = None",
    ".lib.matplotlib.transforms.py@@TransformNode.__init__": "def __init__(self, shorthand_name=None):\n    self._parents = {}\n    self._invalid = 1\n    self._shorthand_name = shorthand_name or ''",
    ".lib.matplotlib.transforms.py@@IdentityTransform.inverted": "def inverted(self):\n    return self",
    ".lib.matplotlib.scale.py@@ScaleBase.limit_range_for_scale": "def limit_range_for_scale(self, vmin, vmax, minpos):\n    return (vmin, vmax)",
    ".lib.matplotlib.transforms.py@@IdentityTransform.transform": "def transform(self, points):\n    return np.asanyarray(points)",
    ".lib.matplotlib.ticker.py@@MaxNLocator.view_limits": "def view_limits(self, dmin, dmax):\n    if self._symmetric:\n        dmax = max(abs(dmin), abs(dmax))\n        dmin = -dmax\n    dmin, dmax = mtransforms.nonsingular(dmin, dmax, expander=1e-12, tiny=1e-13)\n    if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n        return self._raw_ticks(dmin, dmax)[[0, -1]]\n    else:\n        return (dmin, dmax)",
    ".lib.matplotlib.__init__.py@@RcParams.__getitem__": "def __getitem__(self, key):\n    if key in _deprecated_map:\n        version, alt_key, alt_val, inverse_alt = _deprecated_map[key]\n        _api.warn_deprecated(version, name=key, obj_type='rcparam', alternative=alt_key)\n        return inverse_alt(dict.__getitem__(self, alt_key))\n    elif key in _deprecated_ignore_map:\n        version, alt_key = _deprecated_ignore_map[key]\n        _api.warn_deprecated(version, name=key, obj_type='rcparam', alternative=alt_key)\n        return dict.__getitem__(self, alt_key) if alt_key else None\n    elif key == 'backend' and self is globals().get('rcParams'):\n        val = dict.__getitem__(self, key)\n        if val is rcsetup._auto_backend_sentinel:\n            from matplotlib import pyplot as plt\n            plt.switch_backend(rcsetup._auto_backend_sentinel)\n    return dict.__getitem__(self, key)",
    ".lib.matplotlib.ticker.py@@MaxNLocator._raw_ticks": "def _raw_ticks(self, vmin, vmax):\n    if self._nbins == 'auto':\n        if self.axis is not None:\n            nbins = np.clip(self.axis.get_tick_space(), max(1, self._min_n_ticks - 1), 9)\n        else:\n            nbins = 9\n    else:\n        nbins = self._nbins\n    scale, offset = scale_range(vmin, vmax, nbins)\n    _vmin = vmin - offset\n    _vmax = vmax - offset\n    raw_step = (_vmax - _vmin) / nbins\n    steps = self._extended_steps * scale\n    if self._integer:\n        igood = (steps < 1) | (np.abs(steps - np.round(steps)) < 0.001)\n        steps = steps[igood]\n    istep = np.nonzero(steps >= raw_step)[0][0]\n    if mpl.rcParams['axes.autolimit_mode'] == 'round_numbers':\n        for istep in range(istep, len(steps)):\n            step = steps[istep]\n            best_vmin = _vmin // step * step\n            best_vmax = best_vmin + step * nbins\n            if best_vmax >= _vmax:\n                break\n    for istep in reversed(range(istep + 1)):\n        step = steps[istep]\n        if self._integer and np.floor(_vmax) - np.ceil(_vmin) >= self._min_n_ticks - 1:\n            step = max(1, step)\n        best_vmin = _vmin // step * step\n        edge = _Edge_integer(step, offset)\n        low = edge.le(_vmin - best_vmin)\n        high = edge.ge(_vmax - best_vmin)\n        ticks = np.arange(low, high + 1) * step + best_vmin\n        nticks = ((ticks <= _vmax) & (ticks >= _vmin)).sum()\n        if nticks >= self._min_n_ticks:\n            break\n    return ticks + offset",
    ".lib.matplotlib.ticker.py@@scale_range": "def scale_range(vmin, vmax, n=1, threshold=100):\n    dv = abs(vmax - vmin)\n    meanv = (vmax + vmin) / 2\n    if abs(meanv) / dv < threshold:\n        offset = 0\n    else:\n        offset = math.copysign(10 ** (math.log10(abs(meanv)) // 1), meanv)\n    scale = 10 ** (math.log10(dv / n) // 1)\n    return (scale, offset)",
    ".lib.matplotlib.ticker.py@@_Edge_integer.__init__": "def __init__(self, step, offset):\n    if step <= 0:\n        raise ValueError(\"'step' must be positive\")\n    self.step = step\n    self._offset = abs(offset)",
    ".lib.matplotlib.ticker.py@@_Edge_integer.le": "def le(self, x):\n    d, m = divmod(x, self.step)\n    if self.closeto(m / self.step, 1):\n        return d + 1\n    return d",
    ".lib.matplotlib.ticker.py@@_Edge_integer.closeto": "def closeto(self, ms, edge):\n    if self._offset > 0:\n        digits = np.log10(self._offset / self.step)\n        tol = max(1e-10, 10 ** (digits - 12))\n        tol = min(0.4999, tol)\n    else:\n        tol = 1e-10\n    return abs(ms - edge) < tol",
    ".lib.matplotlib.ticker.py@@_Edge_integer.ge": "def ge(self, x):\n    d, m = divmod(x, self.step)\n    if self.closeto(m / self.step, 0):\n        return d\n    return d + 1",
    ".lib.matplotlib.axes._base.py@@_AxesBase.set_xbound": "def set_xbound(self, lower=None, upper=None):\n    if upper is None and np.iterable(lower):\n        lower, upper = lower\n    old_lower, old_upper = self.get_xbound()\n    if lower is None:\n        lower = old_lower\n    if upper is None:\n        upper = old_upper\n    self.set_xlim(sorted((lower, upper), reverse=bool(self.xaxis_inverted())), auto=None)",
    ".lib.matplotlib.axes._base.py@@_AxesBase.get_xbound": "def get_xbound(self):\n    left, right = self.get_xlim()\n    if left < right:\n        return (left, right)\n    else:\n        return (right, left)",
    ".lib.matplotlib.axes._base.py@@_AxesBase.get_xlim": "def get_xlim(self):\n    return tuple(self.viewLim.intervalx)",
    ".lib.matplotlib.axis.py@@Axis.get_inverted": "def get_inverted(self):\n    low, high = self.get_view_interval()\n    return high < low",
    ".lib.matplotlib._api.deprecation.py@@wrapper": "def wrapper(*args, **kwargs):\n    if len(args) > name_idx:\n        warn_deprecated(since, message='Passing the %(name)s %(obj_type)s positionally is deprecated since Matplotlib %(since)s; the parameter will become keyword-only %(removal)s.', name=name, obj_type=f'parameter of {func.__name__}()')\n    return func(*args, **kwargs)",
    ".lib.matplotlib.axes._base.py@@_AxesBase.set_xlim": "def set_xlim(self, left=None, right=None, emit=True, auto=False, *, xmin=None, xmax=None):\n    if right is None and np.iterable(left):\n        left, right = left\n    if xmin is not None:\n        if left is not None:\n            raise TypeError(\"Cannot pass both 'left' and 'xmin'\")\n        left = xmin\n    if xmax is not None:\n        if right is not None:\n            raise TypeError(\"Cannot pass both 'right' and 'xmax'\")\n        right = xmax\n    return self.xaxis._set_lim(left, right, emit=emit, auto=auto)",
    ".lib.matplotlib.axis.py@@Axis._set_lim": "def _set_lim(self, v0, v1, *, emit=True, auto):\n    name, = [name for name, axis in self.axes._axis_map.items() if axis is self]\n    self.axes._process_unit_info([(name, (v0, v1))], convert=False)\n    v0 = self.axes._validate_converted_limits(v0, self.convert_units)\n    v1 = self.axes._validate_converted_limits(v1, self.convert_units)\n    if v0 is None or v1 is None:\n        old0, old1 = self.get_view_interval()\n        if v0 is None:\n            v0 = old0\n        if v1 is None:\n            v1 = old1\n    if self.get_scale() == 'log' and (v0 <= 0 or v1 <= 0):\n        old0, old1 = self.get_view_interval()\n        if v0 <= 0:\n            _api.warn_external(f'Attempt to set non-positive {name}lim on a log-scaled axis will be ignored.')\n            v0 = old0\n        if v1 <= 0:\n            _api.warn_external(f'Attempt to set non-positive {name}lim on a log-scaled axis will be ignored.')\n            v1 = old1\n    if v0 == v1:\n        _api.warn_external(f'Attempting to set identical low and high {name}lims makes transformation singular; automatically expanding.')\n    reverse = bool(v0 > v1)\n    v0, v1 = self.get_major_locator().nonsingular(v0, v1)\n    v0, v1 = self.limit_range_for_scale(v0, v1)\n    v0, v1 = sorted([v0, v1], reverse=bool(reverse))\n    self.set_view_interval(v0, v1, ignore=True)\n    for ax in self.axes._shared_axes[name].get_siblings(self.axes):\n        ax._stale_viewlims[name] = False\n    if auto is not None:\n        self._set_autoscale_on(bool(auto))\n    if emit:\n        self.axes.callbacks.process(f'{name}lim_changed', self.axes)\n        for other in self.axes._shared_axes[name].get_siblings(self.axes):\n            if other is not self.axes:\n                other._axis_map[name]._set_lim(v0, v1, emit=False, auto=auto)\n                if other.figure != self.figure:\n                    other.figure.canvas.draw_idle()\n    self.stale = True\n    return (v0, v1)",
    ".lib.matplotlib.axes._base.py@@_AxesBase._axis_map": "def _axis_map(self):\n    return {name: getattr(self, f'{name}axis') for name in self._axis_names}",
    ".lib.matplotlib.axes._base.py@@_AxesBase._process_unit_info": "def _process_unit_info(self, datasets=None, kwargs=None, *, convert=True):\n    datasets = datasets or []\n    kwargs = kwargs or {}\n    axis_map = self._axis_map\n    for axis_name, data in datasets:\n        try:\n            axis = axis_map[axis_name]\n        except KeyError:\n            raise ValueError(f'Invalid axis name: {axis_name!r}') from None\n        if axis is not None and data is not None and (not axis.have_units()):\n            axis.update_units(data)\n    for axis_name, axis in axis_map.items():\n        if axis is None:\n            continue\n        units = kwargs.pop(f'{axis_name}units', axis.units)\n        if self.name == 'polar':\n            polar_units = {'x': 'thetaunits', 'y': 'runits'}\n            units = kwargs.pop(polar_units[axis_name], units)\n        if units != axis.units and units is not None:\n            axis.set_units(units)\n            for dataset_axis_name, data in datasets:\n                if dataset_axis_name == axis_name and data is not None:\n                    axis.update_units(data)\n    return [axis_map[axis_name].convert_units(data) if convert and data is not None else data for axis_name, data in datasets]",
    ".lib.matplotlib.axis.py@@Axis.have_units": "def have_units(self):\n    return self.converter is not None or self.units is not None",
    ".lib.matplotlib.axis.py@@Axis.update_units": "def update_units(self, data):\n    converter = munits.registry.get_converter(data)\n    if converter is None:\n        return False\n    neednew = self.converter != converter\n    self.converter = converter\n    default = self.converter.default_units(data, self)\n    if default is not None and self.units is None:\n        self.set_units(default)\n    elif neednew:\n        self._update_axisinfo()\n    self.stale = True\n    return True",
    ".lib.matplotlib.units.py@@Registry.get_converter": "def get_converter(self, x):\n    x = cbook._unpack_to_numpy(x)\n    if isinstance(x, np.ndarray):\n        x = np.ma.getdata(x).ravel()\n        if not x.size:\n            return self.get_converter(np.array([0], dtype=x.dtype))\n    for cls in type(x).__mro__:\n        try:\n            return self[cls]\n        except KeyError:\n            pass\n    try:\n        first = cbook._safe_first_non_none(x)\n    except (TypeError, StopIteration):\n        pass\n    else:\n        if type(first) is not type(x):\n            return self.get_converter(first)\n    return None",
    ".lib.matplotlib.cbook.__init__.py@@_unpack_to_numpy": "def _unpack_to_numpy(x):\n    if isinstance(x, np.ndarray):\n        return x\n    if hasattr(x, 'to_numpy'):\n        return x.to_numpy()\n    if hasattr(x, 'values'):\n        xtmp = x.values\n        if isinstance(xtmp, np.ndarray):\n            return xtmp\n    return x",
    ".lib.matplotlib.cbook.__init__.py@@_safe_first_non_none": "def _safe_first_non_none(obj, skip_none=True):\n    if skip_none is False:\n        if isinstance(obj, collections.abc.Iterator):\n            try:\n                return obj[0]\n            except TypeError:\n                pass\n            raise RuntimeError('matplotlib does not support generators as input')\n        return next(iter(obj))\n    elif isinstance(obj, np.flatiter):\n        return obj[0]\n    elif isinstance(obj, collections.abc.Iterator):\n        raise RuntimeError('matplotlib does not support generators as input')\n    else:\n        return next((val for val in obj if val is not None))",
    ".lib.matplotlib.axes._base.py@@_AxesBase._validate_converted_limits": "def _validate_converted_limits(self, limit, convert):\n    if limit is not None:\n        converted_limit = convert(limit)\n        if isinstance(converted_limit, Real) and (not np.isfinite(converted_limit)):\n            raise ValueError('Axis limits cannot be NaN or Inf')\n        return converted_limit",
    ".lib.matplotlib.axis.py@@Axis.convert_units": "def convert_units(self, x):\n    if munits._is_natively_supported(x):\n        return x\n    if self.converter is None:\n        self.converter = munits.registry.get_converter(x)\n    if self.converter is None:\n        return x\n    try:\n        ret = self.converter.convert(x, self.units, self)\n    except Exception as e:\n        raise munits.ConversionError(f'Failed to convert value(s) to axis units: {x!r}') from e\n    return ret",
    ".lib.matplotlib.units.py@@_is_natively_supported": "def _is_natively_supported(x):\n    if np.iterable(x):\n        for thisx in x:\n            if thisx is ma.masked:\n                continue\n            return isinstance(thisx, Number) and (not isinstance(thisx, Decimal))\n    else:\n        return isinstance(x, Number) and (not isinstance(x, Decimal))",
    ".lib.matplotlib.axis.py@@Axis.limit_range_for_scale": "def limit_range_for_scale(self, vmin, vmax):\n    return self._scale.limit_range_for_scale(vmin, vmax, self.get_minpos())",
    ".lib.matplotlib.axis.py@@XAxis.get_minpos": "def get_minpos(self):\n    return self.axes.dataLim.minposx",
    ".lib.matplotlib.axis.py@@setter": "def setter(self, vmin, vmax, ignore=False):\n    if ignore:\n        setattr(getattr(self.axes, lim_name), attr_name, (vmin, vmax))\n    else:\n        oldmin, oldmax = getter(self)\n        if oldmin < oldmax:\n            setter(self, min(vmin, vmax, oldmin), max(vmin, vmax, oldmax), ignore=True)\n        else:\n            setter(self, max(vmin, vmax, oldmin), min(vmin, vmax, oldmax), ignore=True)\n    self.stale = True",
    ".lib.matplotlib.transforms.py@@Bbox.intervalx": "def intervalx(self, interval):\n    self._points[:, 0] = interval\n    self.invalidate()",
    ".lib.matplotlib.transforms.py@@TransformNode.invalidate": "def invalidate(self):\n    value = self.INVALID\n    if self.is_affine:\n        value = self.INVALID_AFFINE\n    return self._invalidate_internal(value, invalidating_node=self)",
    ".lib.matplotlib.transforms.py@@TransformNode._invalidate_internal": "def _invalidate_internal(self, value, invalidating_node):\n    status_changed = self._invalid < value\n    if self.pass_through or status_changed:\n        self._invalid = value\n        for parent in list(self._parents.values()):\n            parent = parent()\n            if parent is not None:\n                parent._invalidate_internal(value=value, invalidating_node=self)",
    ".lib.matplotlib.artist.py@@Artist.stale": "def stale(self):\n    return self._stale",
    ".lib.matplotlib.artist.py@@Artist.get_animated": "def get_animated(self):\n    return self._animated",
    ".lib.matplotlib.artist.py@@_stale_axes_callback": "def _stale_axes_callback(self, val):\n    if self.axes:\n        self.axes.stale = val",
    ".lib.matplotlib.figure.py@@_stale_figure_callback": "def _stale_figure_callback(self, val):\n    if self.figure:\n        self.figure.stale = val",
    ".lib.matplotlib.cbook.__init__.py@@CallbackRegistry.process": "def process(self, s, *args, **kwargs):\n    if self._signals is not None:\n        _api.check_in_list(self._signals, signal=s)\n    for cid, ref in list(self.callbacks.get(s, {}).items()):\n        func = ref()\n        if func is not None:\n            try:\n                func(*args, **kwargs)\n            except Exception as exc:\n                if self.exception_handler is not None:\n                    self.exception_handler(exc)\n                else:\n                    raise",
    ".lib.matplotlib._api.__init__.py@@check_in_list": "def check_in_list(_values, *, _print_supported_values=True, **kwargs):\n    if not kwargs:\n        raise TypeError('No argument to check!')\n    values = _values\n    for key, val in kwargs.items():\n        if val not in values:\n            msg = f'{val!r} is not a valid value for {key}'\n            if _print_supported_values:\n                msg += f'; supported values are {', '.join(map(repr, values))}'\n            raise ValueError(msg)",
    ".lib.matplotlib.transforms.py@@BboxBase.intervaly": "def intervaly(self):\n    return self.get_points()[:, 1]",
    ".lib.matplotlib.transforms.py@@Bbox.minposy": "def minposy(self):\n    return self._minpos[1]",
    ".lib.matplotlib.axes._base.py@@_AxesBase.set_ybound": "def set_ybound(self, lower=None, upper=None):\n    if upper is None and np.iterable(lower):\n        lower, upper = lower\n    old_lower, old_upper = self.get_ybound()\n    if lower is None:\n        lower = old_lower\n    if upper is None:\n        upper = old_upper\n    self.set_ylim(sorted((lower, upper), reverse=bool(self.yaxis_inverted())), auto=None)",
    ".lib.matplotlib.axes._base.py@@_AxesBase.get_ybound": "def get_ybound(self):\n    bottom, top = self.get_ylim()\n    if bottom < top:\n        return (bottom, top)\n    else:\n        return (top, bottom)",
    ".lib.matplotlib.axes._base.py@@_AxesBase.get_ylim": "def get_ylim(self):\n    return tuple(self.viewLim.intervaly)",
    ".lib.matplotlib.axes._base.py@@_AxesBase.set_ylim": "def set_ylim(self, bottom=None, top=None, emit=True, auto=False, *, ymin=None, ymax=None):\n    if top is None and np.iterable(bottom):\n        bottom, top = bottom\n    if ymin is not None:\n        if bottom is not None:\n            raise TypeError(\"Cannot pass both 'bottom' and 'ymin'\")\n        bottom = ymin\n    if ymax is not None:\n        if top is not None:\n            raise TypeError(\"Cannot pass both 'top' and 'ymax'\")\n        top = ymax\n    return self.yaxis._set_lim(bottom, top, emit=emit, auto=auto)",
    ".lib.matplotlib.axis.py@@YAxis.get_minpos": "def get_minpos(self):\n    return self.axes.dataLim.minposy",
    ".lib.matplotlib.transforms.py@@Bbox.intervaly": "def intervaly(self, interval):\n    self._points[:, 1] = interval\n    self.invalidate()",
    ".lib.matplotlib.ticker.py@@MaxNLocator.tick_values": "def tick_values(self, vmin, vmax):\n    if self._symmetric:\n        vmax = max(abs(vmin), abs(vmax))\n        vmin = -vmax\n    vmin, vmax = mtransforms.nonsingular(vmin, vmax, expander=1e-13, tiny=1e-14)\n    locs = self._raw_ticks(vmin, vmax)\n    prune = self._prune\n    if prune == 'lower':\n        locs = locs[1:]\n    elif prune == 'upper':\n        locs = locs[:-1]\n    elif prune == 'both':\n        locs = locs[1:-1]\n    return self.raise_if_exceeds(locs)",
    ".lib.matplotlib.ticker.py@@Locator.raise_if_exceeds": "def raise_if_exceeds(self, locs):\n    if len(locs) >= self.MAXTICKS:\n        _log.warning('Locator attempting to generate %s ticks ([%s, ..., %s]), which exceeds Locator.MAXTICKS (%s).', len(locs), locs[0], locs[-1], self.MAXTICKS)\n    return locs",
    ".lib.matplotlib.axis.py@@Axis.get_ticklabels": "def get_ticklabels(self, minor=False, which=None):\n    if which is not None:\n        if which == 'minor':\n            return self.get_minorticklabels()\n        elif which == 'major':\n            return self.get_majorticklabels()\n        elif which == 'both':\n            return self.get_majorticklabels() + self.get_minorticklabels()\n        else:\n            _api.check_in_list(['major', 'minor', 'both'], which=which)\n    if minor:\n        return self.get_minorticklabels()\n    return self.get_majorticklabels()",
    ".lib.matplotlib.axis.py@@Axis.get_minorticklabels": "def get_minorticklabels(self):\n    self._update_ticks()\n    ticks = self.get_minor_ticks()\n    labels1 = [tick.label1 for tick in ticks if tick.label1.get_visible()]\n    labels2 = [tick.label2 for tick in ticks if tick.label2.get_visible()]\n    return labels1 + labels2",
    ".lib.matplotlib.axis.py@@Axis._update_ticks": "def _update_ticks(self):\n    major_locs = self.get_majorticklocs()\n    major_labels = self.major.formatter.format_ticks(major_locs)\n    major_ticks = self.get_major_ticks(len(major_locs))\n    self.major.formatter.set_locs(major_locs)\n    for tick, loc, label in zip(major_ticks, major_locs, major_labels):\n        tick.update_position(loc)\n        tick.set_label1(label)\n        tick.set_label2(label)\n    minor_locs = self.get_minorticklocs()\n    minor_labels = self.minor.formatter.format_ticks(minor_locs)\n    minor_ticks = self.get_minor_ticks(len(minor_locs))\n    self.minor.formatter.set_locs(minor_locs)\n    for tick, loc, label in zip(minor_ticks, minor_locs, minor_labels):\n        tick.update_position(loc)\n        tick.set_label1(label)\n        tick.set_label2(label)\n    ticks = [*major_ticks, *minor_ticks]\n    view_low, view_high = self.get_view_interval()\n    if view_low > view_high:\n        view_low, view_high = (view_high, view_low)\n    interval_t = self.get_transform().transform([view_low, view_high])\n    ticks_to_draw = []\n    for tick in ticks:\n        try:\n            loc_t = self.get_transform().transform(tick.get_loc())\n        except AssertionError:\n            pass\n        else:\n            if mtransforms._interval_contains_close(interval_t, loc_t):\n                ticks_to_draw.append(tick)\n    return ticks_to_draw",
    ".lib.matplotlib.axis.py@@Axis.get_majorticklocs": "def get_majorticklocs(self):\n    return self.major.locator()",
    ".lib.matplotlib.axis.py@@Ticker.formatter": "def formatter(self):\n    return self._formatter",
    ".lib.matplotlib.ticker.py@@Formatter.format_ticks": "def format_ticks(self, values):\n    self.set_locs(values)\n    return [self(value, i) for i, value in enumerate(values)]",
    ".lib.matplotlib.ticker.py@@ScalarFormatter.set_locs": "def set_locs(self, locs):\n    self.locs = locs\n    if len(self.locs) > 0:\n        if self._useOffset:\n            self._compute_offset()\n        self._set_order_of_magnitude()\n        self._set_format()",
    ".lib.matplotlib.ticker.py@@ScalarFormatter._compute_offset": "def _compute_offset(self):\n    locs = self.locs\n    vmin, vmax = sorted(self.axis.get_view_interval())\n    locs = np.asarray(locs)\n    locs = locs[(vmin <= locs) & (locs <= vmax)]\n    if not len(locs):\n        self.offset = 0\n        return\n    lmin, lmax = (locs.min(), locs.max())\n    if lmin == lmax or lmin <= 0 <= lmax:\n        self.offset = 0\n        return\n    abs_min, abs_max = sorted([abs(float(lmin)), abs(float(lmax))])\n    sign = math.copysign(1, lmin)\n    oom_max = np.ceil(math.log10(abs_max))\n    oom = 1 + next((oom for oom in itertools.count(oom_max, -1) if abs_min // 10 ** oom != abs_max // 10 ** oom))\n    if (abs_max - abs_min) / 10 ** oom <= 0.01:\n        oom = 1 + next((oom for oom in itertools.count(oom_max, -1) if abs_max // 10 ** oom - abs_min // 10 ** oom > 1))\n    n = self._offset_threshold - 1\n    self.offset = sign * (abs_max // 10 ** oom) * 10 ** oom if abs_max // 10 ** oom >= 10 ** n else 0",
    ".lib.matplotlib.ticker.py@@ScalarFormatter._set_order_of_magnitude": "def _set_order_of_magnitude(self):\n    if not self._scientific:\n        self.orderOfMagnitude = 0\n        return\n    if self._powerlimits[0] == self._powerlimits[1] != 0:\n        self.orderOfMagnitude = self._powerlimits[0]\n        return\n    vmin, vmax = sorted(self.axis.get_view_interval())\n    locs = np.asarray(self.locs)\n    locs = locs[(vmin <= locs) & (locs <= vmax)]\n    locs = np.abs(locs)\n    if not len(locs):\n        self.orderOfMagnitude = 0\n        return\n    if self.offset:\n        oom = math.floor(math.log10(vmax - vmin))\n    else:\n        val = locs.max()\n        if val == 0:\n            oom = 0\n        else:\n            oom = math.floor(math.log10(val))\n    if oom <= self._powerlimits[0]:\n        self.orderOfMagnitude = oom\n    elif oom >= self._powerlimits[1]:\n        self.orderOfMagnitude = oom\n    else:\n        self.orderOfMagnitude = 0",
    ".lib.matplotlib.ticker.py@@ScalarFormatter._set_format": "def _set_format(self):\n    if len(self.locs) < 2:\n        _locs = [*self.locs, *self.axis.get_view_interval()]\n    else:\n        _locs = self.locs\n    locs = (np.asarray(_locs) - self.offset) / 10.0 ** self.orderOfMagnitude\n    loc_range = np.ptp(locs)\n    if loc_range == 0:\n        loc_range = np.max(np.abs(locs))\n    if loc_range == 0:\n        loc_range = 1\n    if len(self.locs) < 2:\n        locs = locs[:-2]\n    loc_range_oom = int(math.floor(math.log10(loc_range)))\n    sigfigs = max(0, 3 - loc_range_oom)\n    thresh = 0.001 * 10 ** loc_range_oom\n    while sigfigs >= 0:\n        if np.abs(locs - np.round(locs, decimals=sigfigs)).max() < thresh:\n            sigfigs -= 1\n        else:\n            break\n    sigfigs += 1\n    self.format = '%1.' + str(sigfigs) + 'f'\n    if self._usetex or self._useMathText:\n        self.format = '$\\\\mathdefault{%s}$' % self.format",
    ".lib.matplotlib.ticker.py@@ScalarFormatter.__call__": "def __call__(self, x, pos=None):\n    if len(self.locs) == 0:\n        return ''\n    else:\n        xp = (x - self.offset) / 10.0 ** self.orderOfMagnitude\n        if abs(xp) < 1e-08:\n            xp = 0\n        return self._format_maybe_minus_and_locale(self.format, xp)",
    ".lib.matplotlib.ticker.py@@ScalarFormatter._format_maybe_minus_and_locale": "def _format_maybe_minus_and_locale(self, fmt, arg):\n    return self.fix_minus(locale.format_string(fmt, (arg,), True) if self._useLocale else fmt % arg)",
    ".lib.matplotlib.ticker.py@@Formatter.fix_minus": "def fix_minus(s):\n    return s.replace('-', '\u2212') if mpl.rcParams['axes.unicode_minus'] else s",
    ".lib.matplotlib.axis.py@@Axis.get_major_ticks": "def get_major_ticks(self, numticks=None):\n    if numticks is None:\n        numticks = len(self.get_majorticklocs())\n    while len(self.majorTicks) < numticks:\n        tick = self._get_tick(major=True)\n        self.majorTicks.append(tick)\n        self._copy_tick_props(self.majorTicks[0], tick)\n    return self.majorTicks[:numticks]",
    ".lib.matplotlib.axis.py@@Axis._get_tick": "def _get_tick(self, major):\n    if self._tick_class is None:\n        raise NotImplementedError(f'The Axis subclass {self.__class__.__name__} must define _tick_class or reimplement _get_tick()')\n    tick_kw = self._major_tick_kw if major else self._minor_tick_kw\n    return self._tick_class(self.axes, 0, major=major, **tick_kw)",
    ".lib.matplotlib.axis.py@@XTick.__init__": "def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    ax = self.axes\n    self.tick1line.set(data=([0], [0]), transform=ax.get_xaxis_transform('tick1'))\n    self.tick2line.set(data=([0], [1]), transform=ax.get_xaxis_transform('tick2'))\n    self.gridline.set(data=([0, 0], [0, 1]), transform=ax.get_xaxis_transform('grid'))\n    trans, va, ha = self._get_text1_transform()\n    self.label1.set(x=0, y=0, verticalalignment=va, horizontalalignment=ha, transform=trans)\n    trans, va, ha = self._get_text2_transform()\n    self.label2.set(x=0, y=1, verticalalignment=va, horizontalalignment=ha, transform=trans)",
    ".lib.matplotlib.axis.py@@Tick.__init__": "def __init__(self, axes, loc, *, size=None, width=None, color=None, tickdir=None, pad=None, labelsize=None, labelcolor=None, zorder=None, gridOn=None, tick1On=True, tick2On=True, label1On=True, label2On=False, major=True, labelrotation=0, grid_color=None, grid_linestyle=None, grid_linewidth=None, grid_alpha=None, **kwargs):\n    super().__init__()\n    if gridOn is None:\n        if major and mpl.rcParams['axes.grid.which'] in ('both', 'major'):\n            gridOn = mpl.rcParams['axes.grid']\n        elif not major and mpl.rcParams['axes.grid.which'] in ('both', 'minor'):\n            gridOn = mpl.rcParams['axes.grid']\n        else:\n            gridOn = False\n    self.set_figure(axes.figure)\n    self.axes = axes\n    self._loc = loc\n    self._major = major\n    name = self.__name__\n    major_minor = 'major' if major else 'minor'\n    if size is None:\n        size = mpl.rcParams[f'{name}.{major_minor}.size']\n    self._size = size\n    if width is None:\n        width = mpl.rcParams[f'{name}.{major_minor}.width']\n    self._width = width\n    if color is None:\n        color = mpl.rcParams[f'{name}.color']\n    if pad is None:\n        pad = mpl.rcParams[f'{name}.{major_minor}.pad']\n    self._base_pad = pad\n    if labelcolor is None:\n        labelcolor = mpl.rcParams[f'{name}.labelcolor']\n    if labelcolor == 'inherit':\n        labelcolor = mpl.rcParams[f'{name}.color']\n    if labelsize is None:\n        labelsize = mpl.rcParams[f'{name}.labelsize']\n    self._set_labelrotation(labelrotation)\n    if zorder is None:\n        if major:\n            zorder = mlines.Line2D.zorder + 0.01\n        else:\n            zorder = mlines.Line2D.zorder\n    self._zorder = zorder\n    if grid_color is None:\n        grid_color = mpl.rcParams['grid.color']\n    if grid_linestyle is None:\n        grid_linestyle = mpl.rcParams['grid.linestyle']\n    if grid_linewidth is None:\n        grid_linewidth = mpl.rcParams['grid.linewidth']\n    if grid_alpha is None and (not mcolors._has_alpha_channel(grid_color)):\n        grid_alpha = mpl.rcParams['grid.alpha']\n    grid_kw = {k[5:]: v for k, v in kwargs.items()}\n    self.tick1line = mlines.Line2D([], [], color=color, linestyle='none', zorder=zorder, visible=tick1On, markeredgecolor=color, markersize=size, markeredgewidth=width)\n    self.tick2line = mlines.Line2D([], [], color=color, linestyle='none', zorder=zorder, visible=tick2On, markeredgecolor=color, markersize=size, markeredgewidth=width)\n    self.gridline = mlines.Line2D([], [], color=grid_color, alpha=grid_alpha, visible=gridOn, linestyle=grid_linestyle, linewidth=grid_linewidth, marker='', **grid_kw)\n    self.gridline.get_path()._interpolation_steps = GRIDLINE_INTERPOLATION_STEPS\n    self.label1 = mtext.Text(np.nan, np.nan, fontsize=labelsize, color=labelcolor, visible=label1On, rotation=self._labelrotation[1])\n    self.label2 = mtext.Text(np.nan, np.nan, fontsize=labelsize, color=labelcolor, visible=label2On, rotation=self._labelrotation[1])\n    self._apply_tickdir(tickdir)\n    for artist in [self.tick1line, self.tick2line, self.gridline, self.label1, self.label2]:\n        self._set_artist_props(artist)\n    self.update_position(loc)",
    ".lib.matplotlib.artist.py@@Artist.__init__": "def __init__(self):\n    self._stale = True\n    self.stale_callback = None\n    self._axes = None\n    self.figure = None\n    self._transform = None\n    self._transformSet = False\n    self._visible = True\n    self._animated = False\n    self._alpha = None\n    self.clipbox = None\n    self._clippath = None\n    self._clipon = True\n    self._label = ''\n    self._picker = None\n    self._rasterized = False\n    self._agg_filter = None\n    self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n    self._callbacks = cbook.CallbackRegistry(signals=['pchanged'])\n    try:\n        self.axes = None\n    except AttributeError:\n        pass\n    self._remove_method = None\n    self._url = None\n    self._gid = None\n    self._snap = None\n    self._sketch = mpl.rcParams['path.sketch']\n    self._path_effects = mpl.rcParams['path.effects']\n    self._sticky_edges = _XYPair([], [])\n    self._in_layout = True",
    ".lib.matplotlib.cbook.__init__.py@@CallbackRegistry.__init__": "def __init__(self, exception_handler=_exception_printer, *, signals=None):\n    self._signals = None if signals is None else list(signals)\n    self.exception_handler = exception_handler\n    self.callbacks = {}\n    self._cid_gen = itertools.count()\n    self._func_cid_map = {}\n    self._pickled_cids = set()",
    ".lib.matplotlib.artist.py@@Artist.set_figure": "def set_figure(self, fig):\n    if self.figure is fig:\n        return\n    if self.figure is not None:\n        raise RuntimeError('Can not put single artist in more than one figure')\n    self.figure = fig\n    if self.figure and self.figure is not self:\n        self.pchanged()\n    self.stale = True",
    ".lib.matplotlib.artist.py@@Artist.pchanged": "def pchanged(self):\n    self._callbacks.process('pchanged')",
    ".lib.matplotlib.axis.py@@Tick._set_labelrotation": "def _set_labelrotation(self, labelrotation):\n    if isinstance(labelrotation, str):\n        mode = labelrotation\n        angle = 0\n    elif isinstance(labelrotation, (tuple, list)):\n        mode, angle = labelrotation\n    else:\n        mode = 'default'\n        angle = labelrotation\n    _api.check_in_list(['auto', 'default'], labelrotation=mode)\n    self._labelrotation = (mode, angle)",
    ".lib.matplotlib.colors.py@@_has_alpha_channel": "def _has_alpha_channel(c):\n    return not isinstance(c, str) and len(c) == 4",
    ".lib.matplotlib.lines.py@@Line2D.__init__": "def __init__(self, xdata, ydata, linewidth=None, linestyle=None, color=None, gapcolor=None, marker=None, markersize=None, markeredgewidth=None, markeredgecolor=None, markerfacecolor=None, markerfacecoloralt='none', fillstyle=None, antialiased=None, dash_capstyle=None, solid_capstyle=None, dash_joinstyle=None, solid_joinstyle=None, pickradius=5, drawstyle=None, markevery=None, **kwargs):\n    super().__init__()\n    if not np.iterable(xdata):\n        raise RuntimeError('xdata must be a sequence')\n    if not np.iterable(ydata):\n        raise RuntimeError('ydata must be a sequence')\n    if linewidth is None:\n        linewidth = rcParams['lines.linewidth']\n    if linestyle is None:\n        linestyle = rcParams['lines.linestyle']\n    if marker is None:\n        marker = rcParams['lines.marker']\n    if color is None:\n        color = rcParams['lines.color']\n    if markersize is None:\n        markersize = rcParams['lines.markersize']\n    if antialiased is None:\n        antialiased = rcParams['lines.antialiased']\n    if dash_capstyle is None:\n        dash_capstyle = rcParams['lines.dash_capstyle']\n    if dash_joinstyle is None:\n        dash_joinstyle = rcParams['lines.dash_joinstyle']\n    if solid_capstyle is None:\n        solid_capstyle = rcParams['lines.solid_capstyle']\n    if solid_joinstyle is None:\n        solid_joinstyle = rcParams['lines.solid_joinstyle']\n    if drawstyle is None:\n        drawstyle = 'default'\n    self._dashcapstyle = None\n    self._dashjoinstyle = None\n    self._solidjoinstyle = None\n    self._solidcapstyle = None\n    self.set_dash_capstyle(dash_capstyle)\n    self.set_dash_joinstyle(dash_joinstyle)\n    self.set_solid_capstyle(solid_capstyle)\n    self.set_solid_joinstyle(solid_joinstyle)\n    self._linestyles = None\n    self._drawstyle = None\n    self._linewidth = linewidth\n    self._unscaled_dash_pattern = (0, None)\n    self._dash_pattern = (0, None)\n    self.set_linewidth(linewidth)\n    self.set_linestyle(linestyle)\n    self.set_drawstyle(drawstyle)\n    self._color = None\n    self.set_color(color)\n    if marker is None:\n        marker = 'none'\n    if not isinstance(marker, MarkerStyle):\n        self._marker = MarkerStyle(marker, fillstyle)\n    else:\n        self._marker = marker\n    self._gapcolor = None\n    self.set_gapcolor(gapcolor)\n    self._markevery = None\n    self._markersize = None\n    self._antialiased = None\n    self.set_markevery(markevery)\n    self.set_antialiased(antialiased)\n    self.set_markersize(markersize)\n    self._markeredgecolor = None\n    self._markeredgewidth = None\n    self._markerfacecolor = None\n    self._markerfacecoloralt = None\n    self.set_markerfacecolor(markerfacecolor)\n    self.set_markerfacecoloralt(markerfacecoloralt)\n    self.set_markeredgecolor(markeredgecolor)\n    self.set_markeredgewidth(markeredgewidth)\n    self._internal_update(kwargs)\n    self._pickradius = pickradius\n    self.ind_offset = 0\n    if isinstance(self._picker, Number) and (not isinstance(self._picker, bool)):\n        self._pickradius = self._picker\n    self._xorig = np.asarray([])\n    self._yorig = np.asarray([])\n    self._invalidx = True\n    self._invalidy = True\n    self._x = None\n    self._y = None\n    self._xy = None\n    self._path = None\n    self._transformed_path = None\n    self._subslice = False\n    self._x_filled = None\n    self.set_data(xdata, ydata)",
    ".lib.matplotlib.lines.py@@Line2D.set_dash_capstyle": "def set_dash_capstyle(self, s):\n    cs = CapStyle(s)\n    if self._dashcapstyle != cs:\n        self.stale = True\n    self._dashcapstyle = cs",
    ".lib.matplotlib.lines.py@@Line2D.set_dash_joinstyle": "def set_dash_joinstyle(self, s):\n    js = JoinStyle(s)\n    if self._dashjoinstyle != js:\n        self.stale = True\n    self._dashjoinstyle = js",
    ".lib.matplotlib.lines.py@@Line2D.set_solid_capstyle": "def set_solid_capstyle(self, s):\n    cs = CapStyle(s)\n    if self._solidcapstyle != cs:\n        self.stale = True\n    self._solidcapstyle = cs",
    ".lib.matplotlib.lines.py@@Line2D.set_solid_joinstyle": "def set_solid_joinstyle(self, s):\n    js = JoinStyle(s)\n    if self._solidjoinstyle != js:\n        self.stale = True\n    self._solidjoinstyle = js",
    ".lib.matplotlib.lines.py@@Line2D.set_linewidth": "def set_linewidth(self, w):\n    w = float(w)\n    if self._linewidth != w:\n        self.stale = True\n    self._linewidth = w\n    self._dash_pattern = _scale_dashes(*self._unscaled_dash_pattern, w)",
    ".lib.matplotlib.lines.py@@_scale_dashes": "def _scale_dashes(offset, dashes, lw):\n    if not rcParams['lines.scale_dashes']:\n        return (offset, dashes)\n    scaled_offset = offset * lw\n    scaled_dashes = [x * lw if x is not None else None for x in dashes] if dashes is not None else None\n    return (scaled_offset, scaled_dashes)",
    ".lib.matplotlib.lines.py@@Line2D.set_linestyle": "def set_linestyle(self, ls):\n    if isinstance(ls, str):\n        if ls in [' ', '', 'none']:\n            ls = 'None'\n        _api.check_in_list([*self._lineStyles, *ls_mapper_r], ls=ls)\n        if ls not in self._lineStyles:\n            ls = ls_mapper_r[ls]\n        self._linestyle = ls\n    else:\n        self._linestyle = '--'\n    self._unscaled_dash_pattern = _get_dash_pattern(ls)\n    self._dash_pattern = _scale_dashes(*self._unscaled_dash_pattern, self._linewidth)\n    self.stale = True",
    ".lib.matplotlib.lines.py@@_get_dash_pattern": "def _get_dash_pattern(style):\n    if isinstance(style, str):\n        style = ls_mapper.get(style, style)\n    if style in ['solid', 'None']:\n        offset = 0\n        dashes = None\n    elif style in ['dashed', 'dashdot', 'dotted']:\n        offset = 0\n        dashes = tuple(rcParams['lines.{}_pattern'.format(style)])\n    elif isinstance(style, tuple):\n        offset, dashes = style\n        if offset is None:\n            raise ValueError(f'Unrecognized linestyle: {style!r}')\n    else:\n        raise ValueError(f'Unrecognized linestyle: {style!r}')\n    if dashes is not None:\n        dsum = sum(dashes)\n        if dsum:\n            offset %= dsum\n    return (offset, dashes)",
    ".lib.matplotlib.lines.py@@Line2D.set_drawstyle": "def set_drawstyle(self, drawstyle):\n    if drawstyle is None:\n        drawstyle = 'default'\n    _api.check_in_list(self.drawStyles, drawstyle=drawstyle)\n    if self._drawstyle != drawstyle:\n        self.stale = True\n        self._invalidx = True\n    self._drawstyle = drawstyle",
    ".lib.matplotlib.lines.py@@Line2D.set_color": "def set_color(self, color):\n    mcolors._check_color_like(color=color)\n    self._color = color\n    self.stale = True",
    ".lib.matplotlib.colors.py@@_check_color_like": "def _check_color_like(**kwargs):\n    for k, v in kwargs.items():\n        if not is_color_like(v):\n            raise ValueError(f'{v!r} is not a valid value for {k}')",
    ".lib.matplotlib.colors.py@@is_color_like": "def is_color_like(c):\n    if _is_nth_color(c):\n        return True\n    try:\n        to_rgba(c)\n    except ValueError:\n        return False\n    else:\n        return True",
    ".lib.matplotlib.colors.py@@_is_nth_color": "def _is_nth_color(c):\n    return isinstance(c, str) and re.match('\\\\AC[0-9]+\\\\Z', c)",
    ".lib.matplotlib.colors.py@@to_rgba": "def to_rgba(c, alpha=None):\n    if _is_nth_color(c):\n        from matplotlib import rcParams\n        prop_cycler = rcParams['axes.prop_cycle']\n        colors = prop_cycler.by_key().get('color', ['k'])\n        c = colors[int(c[1:]) % len(colors)]\n    try:\n        rgba = _colors_full_map.cache[c, alpha]\n    except (KeyError, TypeError):\n        rgba = None\n    if rgba is None:\n        rgba = _to_rgba_no_colorcycle(c, alpha)\n        try:\n            _colors_full_map.cache[c, alpha] = rgba\n        except TypeError:\n            pass\n    return rgba",
    ".lib.matplotlib.markers.py@@MarkerStyle.__init__": "def __init__(self, marker=_unset, fillstyle=None, transform=None, capstyle=None, joinstyle=None):\n    self._marker_function = None\n    self._user_transform = transform\n    self._user_capstyle = capstyle\n    self._user_joinstyle = joinstyle\n    self._set_fillstyle(fillstyle)\n    if marker is self._unset:\n        marker = ''\n        _api.warn_deprecated('3.6', message=\"Calling MarkerStyle() with no parameters is deprecated since %(since)s; support will be removed %(removal)s.  Use MarkerStyle('') to construct an empty MarkerStyle.\")\n    if marker is None:\n        marker = ''\n        _api.warn_deprecated('3.6', message=\"MarkerStyle(None) is deprecated since %(since)s; support will be removed %(removal)s.  Use MarkerStyle('') to construct an empty MarkerStyle.\")\n    self._set_marker(marker)",
    ".lib.matplotlib.markers.py@@MarkerStyle._set_fillstyle": "def _set_fillstyle(self, fillstyle):\n    if fillstyle is None:\n        fillstyle = rcParams['markers.fillstyle']\n    _api.check_in_list(self.fillstyles, fillstyle=fillstyle)\n    self._fillstyle = fillstyle\n    self._recache()",
    ".lib.matplotlib.markers.py@@MarkerStyle._recache": "def _recache(self):\n    if self._marker_function is None:\n        return\n    self._path = _empty_path\n    self._transform = IdentityTransform()\n    self._alt_path = None\n    self._alt_transform = None\n    self._snap_threshold = None\n    self._joinstyle = JoinStyle.round\n    self._capstyle = self._user_capstyle or CapStyle.butt\n    self._filled = self._fillstyle != 'none'\n    self._marker_function()",
    ".lib.matplotlib.markers.py@@MarkerStyle._set_marker": "def _set_marker(self, marker):\n    if isinstance(marker, np.ndarray) and marker.ndim == 2 and (marker.shape[1] == 2):\n        self._marker_function = self._set_vertices\n    elif isinstance(marker, str) and cbook.is_math_text(marker):\n        self._marker_function = self._set_mathtext_path\n    elif isinstance(marker, Path):\n        self._marker_function = self._set_path_marker\n    elif isinstance(marker, Sized) and len(marker) in (2, 3) and (marker[1] in (0, 1, 2)):\n        self._marker_function = self._set_tuple_marker\n    elif not isinstance(marker, (np.ndarray, list)) and marker in self.markers:\n        self._marker_function = getattr(self, '_set_' + self.markers[marker])\n    elif isinstance(marker, MarkerStyle):\n        self.__dict__ = copy.deepcopy(marker.__dict__)\n    else:\n        try:\n            Path(marker)\n            self._marker_function = self._set_vertices\n        except ValueError as err:\n            raise ValueError('Unrecognized marker style {!r}'.format(marker)) from err\n    if not isinstance(marker, MarkerStyle):\n        self._marker = marker\n        self._recache()",
    ".lib.matplotlib.cbook.__init__.py@@is_math_text": "def is_math_text(s):\n    s = str(s)\n    dollar_count = s.count('$') - s.count('\\\\$')\n    even_dollars = dollar_count > 0 and dollar_count % 2 == 0\n    return even_dollars",
    ".lib.matplotlib.markers.py@@MarkerStyle._set_nothing": "def _set_nothing(self):\n    self._filled = False",
    ".lib.matplotlib.lines.py@@Line2D.set_gapcolor": "def set_gapcolor(self, gapcolor):\n    if gapcolor is not None:\n        mcolors._check_color_like(color=gapcolor)\n    self._gapcolor = gapcolor\n    self.stale = True",
    ".lib.matplotlib.lines.py@@Line2D.set_markevery": "def set_markevery(self, every):\n    self._markevery = every\n    self.stale = True",
    ".lib.matplotlib.lines.py@@Line2D.set_antialiased": "def set_antialiased(self, b):\n    if self._antialiased != b:\n        self.stale = True\n    self._antialiased = b",
    ".lib.matplotlib.lines.py@@Line2D.set_markersize": "def set_markersize(self, sz):\n    sz = float(sz)\n    if self._markersize != sz:\n        self.stale = True\n    self._markersize = sz",
    ".lib.matplotlib.lines.py@@Line2D.set_markerfacecolor": "def set_markerfacecolor(self, fc):\n    self._set_markercolor('markerfacecolor', True, fc)",
    ".lib.matplotlib.lines.py@@Line2D._set_markercolor": "def _set_markercolor(self, name, has_rcdefault, val):\n    if val is None:\n        val = rcParams[f'lines.{name}'] if has_rcdefault else 'auto'\n    attr = f'_{name}'\n    current = getattr(self, attr)\n    if current is None:\n        self.stale = True\n    else:\n        neq = current != val\n        if neq.any() if isinstance(neq, np.ndarray) else neq:\n            self.stale = True\n    setattr(self, attr, val)",
    ".lib.matplotlib.lines.py@@Line2D.set_markerfacecoloralt": "def set_markerfacecoloralt(self, fc):\n    self._set_markercolor('markerfacecoloralt', False, fc)",
    ".lib.matplotlib.lines.py@@Line2D.set_markeredgecolor": "def set_markeredgecolor(self, ec):\n    self._set_markercolor('markeredgecolor', True, ec)",
    ".lib.matplotlib.lines.py@@Line2D.set_markeredgewidth": "def set_markeredgewidth(self, ew):\n    if ew is None:\n        ew = rcParams['lines.markeredgewidth']\n    if self._markeredgewidth != ew:\n        self.stale = True\n    self._markeredgewidth = ew",
    ".lib.matplotlib.artist.py@@Artist._internal_update": "def _internal_update(self, kwargs):\n    return self._update_props(kwargs, '{cls.__name__}.set() got an unexpected keyword argument {prop_name!r}')",
    ".lib.matplotlib.artist.py@@Artist._update_props": "def _update_props(self, props, errfmt):\n    ret = []\n    with cbook._setattr_cm(self, eventson=False):\n        for k, v in props.items():\n            if k == 'axes':\n                ret.append(setattr(self, k, v))\n            else:\n                func = getattr(self, f'set_{k}', None)\n                if not callable(func):\n                    raise AttributeError(errfmt.format(cls=type(self), prop_name=k))\n                ret.append(func(v))\n    if ret:\n        self.pchanged()\n        self.stale = True\n    return ret",
    ".lib.matplotlib.cbook.__init__.py@@_setattr_cm": "def _setattr_cm(obj, **kwargs):\n    sentinel = object()\n    origs = {}\n    for attr in kwargs:\n        orig = getattr(obj, attr, sentinel)\n        if attr in obj.__dict__ or orig is sentinel:\n            origs[attr] = orig\n        else:\n            cls_orig = getattr(type(obj), attr)\n            if isinstance(cls_orig, property):\n                origs[attr] = orig\n            else:\n                origs[attr] = sentinel\n    try:\n        for attr, val in kwargs.items():\n            setattr(obj, attr, val)\n        yield\n    finally:\n        for attr, orig in origs.items():\n            if orig is sentinel:\n                delattr(obj, attr)\n            else:\n                setattr(obj, attr, orig)",
    ".lib.matplotlib.artist.py@@Artist.set_zorder": "def set_zorder(self, level):\n    if level is None:\n        level = self.__class__.zorder\n    self.zorder = level\n    self.pchanged()\n    self.stale = True",
    ".lib.matplotlib.artist.py@@Artist.set_visible": "def set_visible(self, b):\n    self._visible = b\n    self.pchanged()\n    self.stale = True",
    ".lib.matplotlib.lines.py@@Line2D.set_data": "def set_data(self, *args):\n    if len(args) == 1:\n        (x, y), = args\n    else:\n        x, y = args\n    self.set_xdata(x)\n    self.set_ydata(y)",
    ".lib.matplotlib.lines.py@@Line2D.set_xdata": "def set_xdata(self, x):\n    self._xorig = copy.copy(x)\n    self._invalidx = True\n    self.stale = True",
    ".lib.matplotlib.lines.py@@Line2D.set_ydata": "def set_ydata(self, y):\n    self._yorig = copy.copy(y)\n    self._invalidy = True\n    self.stale = True",
    ".lib.matplotlib.artist.py@@Artist.set_alpha": "def set_alpha(self, alpha):\n    if alpha is not None and (not isinstance(alpha, Number)):\n        raise TypeError(f'alpha must be numeric or None, not {type(alpha)}')\n    if alpha is not None and (not 0 <= alpha <= 1):\n        raise ValueError(f'alpha ({alpha}) is outside 0-1 range')\n    self._alpha = alpha\n    self.pchanged()\n    self.stale = True",
    ".lib.matplotlib.lines.py@@Line2D.get_path": "def get_path(self):\n    if self._invalidy or self._invalidx:\n        self.recache()\n    return self._path",
    ".lib.matplotlib.lines.py@@Line2D.recache": "def recache(self, always=False):\n    if always or self._invalidx:\n        xconv = self.convert_xunits(self._xorig)\n        x = _to_unmasked_float_array(xconv).ravel()\n    else:\n        x = self._x\n    if always or self._invalidy:\n        yconv = self.convert_yunits(self._yorig)\n        y = _to_unmasked_float_array(yconv).ravel()\n    else:\n        y = self._y\n    self._xy = np.column_stack(np.broadcast_arrays(x, y)).astype(float)\n    self._x, self._y = self._xy.T\n    self._subslice = False\n    if self.axes and len(x) > 1000 and self._is_sorted(x) and (self.axes.name == 'rectilinear') and (self.axes.get_xscale() == 'linear') and (self._markevery is None) and self.get_clip_on() and (self.get_transform() == self.axes.transData):\n        self._subslice = True\n        nanmask = np.isnan(x)\n        if nanmask.any():\n            self._x_filled = self._x.copy()\n            indices = np.arange(len(x))\n            self._x_filled[nanmask] = np.interp(indices[nanmask], indices[~nanmask], self._x[~nanmask])\n        else:\n            self._x_filled = self._x\n    if self._path is not None:\n        interpolation_steps = self._path._interpolation_steps\n    else:\n        interpolation_steps = 1\n    xy = STEP_LOOKUP_MAP[self._drawstyle](*self._xy.T)\n    self._path = Path(np.asarray(xy).T, _interpolation_steps=interpolation_steps)\n    self._transformed_path = None\n    self._invalidx = False\n    self._invalidy = False",
    ".lib.matplotlib.artist.py@@Artist.convert_xunits": "def convert_xunits(self, x):\n    ax = getattr(self, 'axes', None)\n    if ax is None or ax.xaxis is None:\n        return x\n    return ax.xaxis.convert_units(x)",
    ".lib.matplotlib.cbook.__init__.py@@_to_unmasked_float_array": "def _to_unmasked_float_array(x):\n    if hasattr(x, 'mask'):\n        return np.ma.asarray(x, float).filled(np.nan)\n    else:\n        return np.asarray(x, float)",
    ".lib.matplotlib.artist.py@@Artist.convert_yunits": "def convert_yunits(self, y):\n    ax = getattr(self, 'axes', None)\n    if ax is None or ax.yaxis is None:\n        return y\n    return ax.yaxis.convert_units(y)",
    ".lib.matplotlib.path.py@@Path.__init__": "def __init__(self, vertices, codes=None, _interpolation_steps=1, closed=False, readonly=False):\n    vertices = _to_unmasked_float_array(vertices)\n    _api.check_shape((None, 2), vertices=vertices)\n    if codes is not None:\n        codes = np.asarray(codes, self.code_type)\n        if codes.ndim != 1 or len(codes) != len(vertices):\n            raise ValueError(f\"'codes' must be a 1D list or array with the same length of 'vertices'. Your vertices have shape {vertices.shape} but your codes have shape {codes.shape}\")\n        if len(codes) and codes[0] != self.MOVETO:\n            raise ValueError(f\"The first element of 'code' must be equal to 'MOVETO' ({self.MOVETO}).  Your first code is {codes[0]}\")\n    elif closed and len(vertices):\n        codes = np.empty(len(vertices), dtype=self.code_type)\n        codes[0] = self.MOVETO\n        codes[1:-1] = self.LINETO\n        codes[-1] = self.CLOSEPOLY\n    self._vertices = vertices\n    self._codes = codes\n    self._interpolation_steps = _interpolation_steps\n    self._update_values()\n    if readonly:\n        self._vertices.flags.writeable = False\n        if self._codes is not None:\n            self._codes.flags.writeable = False\n        self._readonly = True\n    else:\n        self._readonly = False",
    ".lib.matplotlib._api.__init__.py@@check_shape": "def check_shape(_shape, **kwargs):\n    target_shape = _shape\n    for k, v in kwargs.items():\n        data_shape = v.shape\n        if len(target_shape) != len(data_shape) or any((t not in [s, None] for t, s in zip(target_shape, data_shape))):\n            dim_labels = iter(itertools.chain('MNLIJKLH', (f'D{i}' for i in itertools.count())))\n            text_shape = ', '.join((str(n) if n is not None else next(dim_labels) for n in target_shape))\n            raise ValueError(f'{k!r} must be {len(target_shape)}D with shape ({text_shape}). Your input has shape {v.shape}.')",
    ".lib.matplotlib.path.py@@Path._update_values": "def _update_values(self):\n    self._simplify_threshold = mpl.rcParams['path.simplify_threshold']\n    self._should_simplify = self._simplify_threshold > 0 and mpl.rcParams['path.simplify'] and (len(self._vertices) >= 128) and (self._codes is None or np.all(self._codes <= Path.LINETO))",
    ".lib.matplotlib.text.py@@Text.__init__": "def __init__(self, x=0, y=0, text='', color=None, verticalalignment='baseline', horizontalalignment='left', multialignment=None, fontproperties=None, rotation=None, linespacing=None, rotation_mode=None, usetex=None, wrap=False, transform_rotates_text=False, *, parse_math=None, **kwargs):\n    super().__init__()\n    self._x, self._y = (x, y)\n    self._text = ''\n    self.set_text(text)\n    self.set_color(color if color is not None else mpl.rcParams['text.color'])\n    self.set_fontproperties(fontproperties)\n    self.set_usetex(usetex)\n    self.set_parse_math(parse_math if parse_math is not None else mpl.rcParams['text.parse_math'])\n    self.set_wrap(wrap)\n    self.set_verticalalignment(verticalalignment)\n    self.set_horizontalalignment(horizontalalignment)\n    self._multialignment = multialignment\n    self.set_rotation(rotation)\n    self._transform_rotates_text = transform_rotates_text\n    self._bbox_patch = None\n    self._renderer = None\n    if linespacing is None:\n        linespacing = 1.2\n    self.set_linespacing(linespacing)\n    self.set_rotation_mode(rotation_mode)\n    self.update(kwargs)",
    ".lib.matplotlib.text.py@@Text.set_text": "def set_text(self, s):\n    if s is None:\n        s = ''\n    if s != self._text:\n        self._text = str(s)\n        self.stale = True",
    ".lib.matplotlib.text.py@@Text.set_color": "def set_color(self, color):\n    if not cbook._str_equal(color, 'auto'):\n        mpl.colors._check_color_like(color=color)\n    try:\n        hash(color)\n    except TypeError:\n        color = tuple(color)\n    self._color = color\n    self.stale = True",
    ".lib.matplotlib.cbook.__init__.py@@_str_equal": "def _str_equal(obj, s):\n    return isinstance(obj, str) and obj == s",
    ".lib.matplotlib.text.py@@Text.set_fontproperties": "def set_fontproperties(self, fp):\n    self._fontproperties = FontProperties._from_any(fp).copy()\n    self.stale = True",
    ".lib.matplotlib.font_manager.py@@FontProperties._from_any": "def _from_any(cls, arg):\n    if isinstance(arg, cls):\n        return arg\n    elif arg is None:\n        return cls()\n    elif isinstance(arg, os.PathLike):\n        return cls(fname=arg)\n    elif isinstance(arg, str):\n        return cls(arg)\n    else:\n        return cls(**arg)",
    ".lib.matplotlib.font_manager.py@@FontProperties.__init__": "def __init__(self, family=None, style=None, variant=None, weight=None, stretch=None, size=None, fname=None, math_fontfamily=None):\n    self.set_family(family)\n    self.set_style(style)\n    self.set_variant(variant)\n    self.set_weight(weight)\n    self.set_stretch(stretch)\n    self.set_file(fname)\n    self.set_size(size)\n    self.set_math_fontfamily(math_fontfamily)\n    if isinstance(family, str) and style is None and (variant is None) and (weight is None) and (stretch is None) and (size is None) and (fname is None):\n        self.set_fontconfig_pattern(family)",
    ".lib.matplotlib.font_manager.py@@FontProperties.set_family": "def set_family(self, family):\n    if family is None:\n        family = rcParams['font.family']\n    if isinstance(family, str):\n        family = [family]\n    self._family = family",
    ".lib.matplotlib.font_manager.py@@FontProperties.set_style": "def set_style(self, style):\n    if style is None:\n        style = rcParams['font.style']\n    _api.check_in_list(['normal', 'italic', 'oblique'], style=style)\n    self._slant = style",
    ".lib.matplotlib.font_manager.py@@FontProperties.set_variant": "def set_variant(self, variant):\n    if variant is None:\n        variant = rcParams['font.variant']\n    _api.check_in_list(['normal', 'small-caps'], variant=variant)\n    self._variant = variant",
    ".lib.matplotlib.font_manager.py@@FontProperties.set_weight": "def set_weight(self, weight):\n    if weight is None:\n        weight = rcParams['font.weight']\n    if weight in weight_dict:\n        self._weight = weight\n        return\n    try:\n        weight = int(weight)\n    except ValueError:\n        pass\n    else:\n        if 0 <= weight <= 1000:\n            self._weight = weight\n            return\n    raise ValueError(f'weight={weight!r} is invalid')",
    ".lib.matplotlib.font_manager.py@@FontProperties.set_stretch": "def set_stretch(self, stretch):\n    if stretch is None:\n        stretch = rcParams['font.stretch']\n    if stretch in stretch_dict:\n        self._stretch = stretch\n        return\n    try:\n        stretch = int(stretch)\n    except ValueError:\n        pass\n    else:\n        if 0 <= stretch <= 1000:\n            self._stretch = stretch\n            return\n    raise ValueError(f'stretch={stretch!r} is invalid')",
    ".lib.matplotlib.font_manager.py@@FontProperties.set_file": "def set_file(self, file):\n    self._file = os.fspath(file) if file is not None else None",
    ".lib.matplotlib.font_manager.py@@FontProperties.set_size": "def set_size(self, size):\n    if size is None:\n        size = rcParams['font.size']\n    try:\n        size = float(size)\n    except ValueError:\n        try:\n            scale = font_scalings[size]\n        except KeyError as err:\n            raise ValueError('Size is invalid. Valid font size are ' + ', '.join(map(str, font_scalings))) from err\n        else:\n            size = scale * FontManager.get_default_size()\n    if size < 1.0:\n        _log.info('Fontsize %1.2f < 1.0 pt not allowed by FreeType. Setting fontsize = 1 pt', size)\n        size = 1.0\n    self._size = size",
    ".lib.matplotlib.font_manager.py@@FontProperties.set_math_fontfamily": "def set_math_fontfamily(self, fontfamily):\n    if fontfamily is None:\n        fontfamily = rcParams['mathtext.fontset']\n    else:\n        valid_fonts = _validators['mathtext.fontset'].valid.values()\n        _api.check_in_list(valid_fonts, math_fontfamily=fontfamily)\n    self._math_fontfamily = fontfamily",
    ".lib.matplotlib.font_manager.py@@FontProperties.copy": "def copy(self):\n    return copy.copy(self)",
    ".lib.matplotlib.text.py@@Text.set_usetex": "def set_usetex(self, usetex):\n    if usetex is None:\n        self._usetex = mpl.rcParams['text.usetex']\n    else:\n        self._usetex = bool(usetex)\n    self.stale = True",
    ".lib.matplotlib.text.py@@Text.set_parse_math": "def set_parse_math(self, parse_math):\n    self._parse_math = bool(parse_math)",
    ".lib.matplotlib.text.py@@Text.set_wrap": "def set_wrap(self, wrap):\n    self._wrap = wrap",
    ".lib.matplotlib.text.py@@Text.set_verticalalignment": "def set_verticalalignment(self, align):\n    _api.check_in_list(['top', 'bottom', 'center', 'baseline', 'center_baseline'], align=align)\n    self._verticalalignment = align\n    self.stale = True",
    ".lib.matplotlib.text.py@@Text.set_horizontalalignment": "def set_horizontalalignment(self, align):\n    _api.check_in_list(['center', 'right', 'left'], align=align)\n    self._horizontalalignment = align\n    self.stale = True",
    ".lib.matplotlib.text.py@@Text.set_rotation": "def set_rotation(self, s):\n    if isinstance(s, Real):\n        self._rotation = float(s) % 360\n    elif cbook._str_equal(s, 'horizontal') or s is None:\n        self._rotation = 0.0\n    elif cbook._str_equal(s, 'vertical'):\n        self._rotation = 90.0\n    else:\n        raise ValueError(f\"rotation must be 'vertical', 'horizontal' or a number, not {s}\")\n    self.stale = True",
    ".lib.matplotlib.text.py@@Text.set_linespacing": "def set_linespacing(self, spacing):\n    _api.check_isinstance(Real, spacing=spacing)\n    self._linespacing = spacing\n    self.stale = True",
    ".lib.matplotlib._api.__init__.py@@check_isinstance": "def check_isinstance(_types, **kwargs):\n    types = _types\n    none_type = type(None)\n    types = (types,) if isinstance(types, type) else (none_type,) if types is None else tuple((none_type if tp is None else tp for tp in types))\n\n    def type_name(tp):\n        return 'None' if tp is none_type else tp.__qualname__ if tp.__module__ == 'builtins' else f'{tp.__module__}.{tp.__qualname__}'\n    for k, v in kwargs.items():\n        if not isinstance(v, types):\n            names = [*map(type_name, types)]\n            if 'None' in names:\n                names.remove('None')\n                names.append('None')\n            raise TypeError('{!r} must be an instance of {}, not a {}'.format(k, ', '.join(names[:-1]) + ' or ' + names[-1] if len(names) > 1 else names[0], type_name(type(v))))",
    ".lib.matplotlib.text.py@@Text.set_rotation_mode": "def set_rotation_mode(self, m):\n    _api.check_in_list(['anchor', 'default', None], rotation_mode=m)\n    self._rotation_mode = m\n    self.stale = True",
    ".lib.matplotlib.text.py@@Text.update": "def update(self, kwargs):\n    kwargs = cbook.normalize_kwargs(kwargs, Text)\n    sentinel = object()\n    fontproperties = kwargs.pop('fontproperties', sentinel)\n    if fontproperties is not sentinel:\n        self.set_fontproperties(fontproperties)\n    bbox = kwargs.pop('bbox', sentinel)\n    super().update(kwargs)\n    if bbox is not sentinel:\n        self.set_bbox(bbox)",
    ".lib.matplotlib.cbook.__init__.py@@normalize_kwargs": "def normalize_kwargs(kw, alias_mapping=None):\n    from matplotlib.artist import Artist\n    if kw is None:\n        return {}\n    if alias_mapping is None:\n        alias_mapping = dict()\n    elif isinstance(alias_mapping, type) and issubclass(alias_mapping, Artist) or isinstance(alias_mapping, Artist):\n        alias_mapping = getattr(alias_mapping, '_alias_map', {})\n    to_canonical = {alias: canonical for canonical, alias_list in alias_mapping.items() for alias in alias_list}\n    canonical_to_seen = {}\n    ret = {}\n    for k, v in kw.items():\n        canonical = to_canonical.get(k, k)\n        if canonical in canonical_to_seen:\n            raise TypeError(f'Got both {canonical_to_seen[canonical]!r} and {k!r}, which are aliases of one another')\n        canonical_to_seen[canonical] = k\n        ret[canonical] = v\n    return ret",
    ".lib.matplotlib.artist.py@@Artist.update": "def update(self, props):\n    return self._update_props(props, '{cls.__name__!r} object has no property {prop_name!r}')",
    ".lib.matplotlib.text.py@@Text.set_fontsize": "def set_fontsize(self, fontsize):\n    self._fontproperties.set_size(fontsize)\n    self.stale = True",
    ".lib.matplotlib.font_manager.py@@FontManager.get_default_size": "def get_default_size():\n    return rcParams['font.size']",
    ".lib.matplotlib.axis.py@@XTick._apply_tickdir": "def _apply_tickdir(self, tickdir):\n    super()._apply_tickdir(tickdir)\n    mark1, mark2 = {'out': (mlines.TICKDOWN, mlines.TICKUP), 'in': (mlines.TICKUP, mlines.TICKDOWN), 'inout': ('|', '|')}[self._tickdir]\n    self.tick1line.set_marker(mark1)\n    self.tick2line.set_marker(mark2)",
    ".lib.matplotlib.axis.py@@Tick._apply_tickdir": "def _apply_tickdir(self, tickdir):\n    if tickdir is None:\n        tickdir = mpl.rcParams[f'{self.__name__}.direction']\n    _api.check_in_list(['in', 'out', 'inout'], tickdir=tickdir)\n    self._tickdir = tickdir\n    self._pad = self._base_pad + self.get_tick_padding()",
    ".lib.matplotlib.axis.py@@Tick.get_tick_padding": "def get_tick_padding(self):\n    padding = {'in': 0.0, 'inout': 0.5, 'out': 1.0}\n    return self._size * padding[self._tickdir]",
    ".lib.matplotlib.lines.py@@Line2D.set_marker": "def set_marker(self, marker):\n    self._marker = MarkerStyle(marker, self._marker.get_fillstyle())\n    self.stale = True",
    ".lib.matplotlib.markers.py@@MarkerStyle.get_fillstyle": "def get_fillstyle(self):\n    return self._fillstyle",
    ".lib.matplotlib.markers.py@@MarkerStyle._set_tickup": "def _set_tickup(self):\n    self._transform = Affine2D().scale(1.0, 1.0)\n    self._snap_threshold = 1.0\n    self._filled = False\n    self._path = self._tickvert_path",
    ".lib.matplotlib.transforms.py@@Affine2D.__init__": "def __init__(self, matrix=None, **kwargs):\n    super().__init__(**kwargs)\n    if matrix is None:\n        matrix = IdentityTransform._mtx.copy()\n    self._mtx = matrix.copy()\n    self._invalid = 0",
    ".lib.matplotlib.transforms.py@@Affine2D.scale": "def scale(self, sx, sy=None):\n    if sy is None:\n        sy = sx\n    self._mtx[0, 0] *= sx\n    self._mtx[0, 1] *= sx\n    self._mtx[0, 2] *= sx\n    self._mtx[1, 0] *= sy\n    self._mtx[1, 1] *= sy\n    self._mtx[1, 2] *= sy\n    self.invalidate()\n    return self",
    ".lib.matplotlib.markers.py@@MarkerStyle._set_tickdown": "def _set_tickdown(self):\n    self._transform = Affine2D().scale(1.0, -1.0)\n    self._snap_threshold = 1.0\n    self._filled = False\n    self._path = self._tickvert_path",
    ".lib.matplotlib.axis.py@@Tick._set_artist_props": "def _set_artist_props(self, a):\n    a.set_figure(self.figure)",
    ".lib.matplotlib.axis.py@@XTick.update_position": "def update_position(self, loc):\n    self.tick1line.set_xdata((loc,))\n    self.tick2line.set_xdata((loc,))\n    self.gridline.set_xdata((loc,))\n    self.label1.set_x(loc)\n    self.label2.set_x(loc)\n    self._loc = loc\n    self.stale = True",
    ".lib.matplotlib.text.py@@Text.set_x": "def set_x(self, x):\n    self._x = x\n    self.stale = True",
    ".lib.matplotlib.axes._base.py@@_AxesBase.get_xaxis_transform": "def get_xaxis_transform(self, which='grid'):\n    if which == 'grid':\n        return self._xaxis_transform\n    elif which == 'tick1':\n        return self.spines.bottom.get_spine_transform()\n    elif which == 'tick2':\n        return self.spines.top.get_spine_transform()\n    else:\n        raise ValueError(f'unknown value for which: {which!r}')",
    ".lib.matplotlib.spines.py@@Spines.__getattr__": "def __getattr__(self, name):\n    try:\n        return self._dict[name]\n    except KeyError:\n        raise AttributeError(f\"'Spines' object does not contain a '{name}' spine\")",
    ".lib.matplotlib.spines.py@@Spine.get_spine_transform": "def get_spine_transform(self):\n    self._ensure_position_is_set()\n    position = self._position\n    if isinstance(position, str):\n        if position == 'center':\n            position = ('axes', 0.5)\n        elif position == 'zero':\n            position = ('data', 0)\n    assert len(position) == 2, 'position should be 2-tuple'\n    position_type, amount = position\n    _api.check_in_list(['axes', 'outward', 'data'], position_type=position_type)\n    if self.spine_type in ['left', 'right']:\n        base_transform = self.axes.get_yaxis_transform(which='grid')\n    elif self.spine_type in ['top', 'bottom']:\n        base_transform = self.axes.get_xaxis_transform(which='grid')\n    else:\n        raise ValueError(f'unknown spine spine_type: {self.spine_type!r}')\n    if position_type == 'outward':\n        if amount == 0:\n            return base_transform\n        else:\n            offset_vec = {'left': (-1, 0), 'right': (1, 0), 'bottom': (0, -1), 'top': (0, 1)}[self.spine_type]\n            offset_dots = amount * np.array(offset_vec) / 72\n            return base_transform + mtransforms.ScaledTranslation(*offset_dots, self.figure.dpi_scale_trans)\n    elif position_type == 'axes':\n        if self.spine_type in ['left', 'right']:\n            return mtransforms.Affine2D.from_values(0, 0, 0, 1, amount, 0) + base_transform\n        elif self.spine_type in ['bottom', 'top']:\n            return mtransforms.Affine2D.from_values(1, 0, 0, 0, 0, amount) + base_transform\n    elif position_type == 'data':\n        if self.spine_type in ('right', 'top'):\n            amount -= 1\n        if self.spine_type in ('left', 'right'):\n            return mtransforms.blended_transform_factory(mtransforms.Affine2D().translate(amount, 0) + self.axes.transData, self.axes.transData)\n        elif self.spine_type in ('bottom', 'top'):\n            return mtransforms.blended_transform_factory(self.axes.transData, mtransforms.Affine2D().translate(0, amount) + self.axes.transData)",
    ".lib.matplotlib.spines.py@@Spine._ensure_position_is_set": "def _ensure_position_is_set(self):\n    if self._position is None:\n        self._position = ('outward', 0.0)\n        self.set_position(self._position)",
    ".lib.matplotlib.artist.py@@Artist.set": "def set(self, **kwargs):\n    return self._internal_update(cbook.normalize_kwargs(kwargs, self))",
    ".lib.matplotlib.lines.py@@Line2D.set_transform": "def set_transform(self, t):\n    self._invalidx = True\n    self._invalidy = True\n    super().set_transform(t)",
    ".lib.matplotlib.artist.py@@Artist.set_transform": "def set_transform(self, t):\n    self._transform = t\n    self._transformSet = True\n    self.pchanged()\n    self.stale = True",
    ".lib.matplotlib.axis.py@@XTick._get_text1_transform": "def _get_text1_transform(self):\n    return self.axes.get_xaxis_text1_transform(self._pad)",
    ".lib.matplotlib.axes._base.py@@_AxesBase.get_xaxis_text1_transform": "def get_xaxis_text1_transform(self, pad_points):\n    labels_align = mpl.rcParams['xtick.alignment']\n    return (self.get_xaxis_transform(which='tick1') + mtransforms.ScaledTranslation(0, -1 * pad_points / 72, self.figure.dpi_scale_trans), 'top', labels_align)",
    ".lib.matplotlib.transforms.py@@ScaledTranslation.__init__": "def __init__(self, xt, yt, scale_trans, **kwargs):\n    super().__init__(**kwargs)\n    self._t = (xt, yt)\n    self._scale_trans = scale_trans\n    self.set_children(scale_trans)\n    self._mtx = None\n    self._inverted = None",
    ".lib.matplotlib.transforms.py@@TransformNode.set_children": "def set_children(self, *children):\n    for child in children:\n        ref = weakref.ref(self, lambda _, pop=child._parents.pop, k=id(self): pop(k))\n        child._parents[id(self)] = ref",
    ".lib.matplotlib.transforms.py@@Transform.__add__": "def __add__(self, other):\n    return composite_transform_factory(self, other) if isinstance(other, Transform) else NotImplemented",
    ".lib.matplotlib.transforms.py@@composite_transform_factory": "def composite_transform_factory(a, b):\n    if isinstance(a, IdentityTransform):\n        return b\n    elif isinstance(b, IdentityTransform):\n        return a\n    elif isinstance(a, Affine2D) and isinstance(b, Affine2D):\n        return CompositeAffine2D(a, b)\n    return CompositeGenericTransform(a, b)",
    ".lib.matplotlib.transforms.py@@CompositeGenericTransform.__init__": "def __init__(self, a, b, **kwargs):\n    if a.output_dims != b.input_dims:\n        raise ValueError(\"The output dimension of 'a' must be equal to the input dimensions of 'b'\")\n    self.input_dims = a.input_dims\n    self.output_dims = b.output_dims\n    super().__init__(**kwargs)\n    self._a = a\n    self._b = b\n    self.set_children(a, b)",
    ".lib.matplotlib.text.py@@Text.set_y": "def set_y(self, y):\n    self._y = y\n    self.stale = True",
    ".lib.matplotlib.axis.py@@XTick._get_text2_transform": "def _get_text2_transform(self):\n    return self.axes.get_xaxis_text2_transform(self._pad)",
    ".lib.matplotlib.axes._base.py@@_AxesBase.get_xaxis_text2_transform": "def get_xaxis_text2_transform(self, pad_points):\n    labels_align = mpl.rcParams['xtick.alignment']\n    return (self.get_xaxis_transform(which='tick2') + mtransforms.ScaledTranslation(0, pad_points / 72, self.figure.dpi_scale_trans), 'bottom', labels_align)",
    ".lib.matplotlib.axis.py@@Axis._copy_tick_props": "def _copy_tick_props(self, src, dest):\n    if src is None or dest is None:\n        return\n    dest.label1.update_from(src.label1)\n    dest.label2.update_from(src.label2)\n    dest.tick1line.update_from(src.tick1line)\n    dest.tick2line.update_from(src.tick2line)\n    dest.gridline.update_from(src.gridline)",
    ".lib.matplotlib.text.py@@Text.update_from": "def update_from(self, other):\n    super().update_from(other)\n    self._color = other._color\n    self._multialignment = other._multialignment\n    self._verticalalignment = other._verticalalignment\n    self._horizontalalignment = other._horizontalalignment\n    self._fontproperties = other._fontproperties.copy()\n    self._usetex = other._usetex\n    self._rotation = other._rotation\n    self._transform_rotates_text = other._transform_rotates_text\n    self._picker = other._picker\n    self._linespacing = other._linespacing\n    self.stale = True",
    ".lib.matplotlib.artist.py@@Artist.update_from": "def update_from(self, other):\n    self._transform = other._transform\n    self._transformSet = other._transformSet\n    self._visible = other._visible\n    self._alpha = other._alpha\n    self.clipbox = other.clipbox\n    self._clipon = other._clipon\n    self._clippath = other._clippath\n    self._label = other._label\n    self._sketch = other._sketch\n    self._path_effects = other._path_effects\n    self.sticky_edges.x[:] = other.sticky_edges.x.copy()\n    self.sticky_edges.y[:] = other.sticky_edges.y.copy()\n    self.pchanged()\n    self.stale = True",
    ".lib.matplotlib.artist.py@@Artist.sticky_edges": "def sticky_edges(self):\n    return self._sticky_edges",
    ".lib.matplotlib.lines.py@@Line2D.update_from": "def update_from(self, other):\n    super().update_from(other)\n    self._linestyle = other._linestyle\n    self._linewidth = other._linewidth\n    self._color = other._color\n    self._gapcolor = other._gapcolor\n    self._markersize = other._markersize\n    self._markerfacecolor = other._markerfacecolor\n    self._markerfacecoloralt = other._markerfacecoloralt\n    self._markeredgecolor = other._markeredgecolor\n    self._markeredgewidth = other._markeredgewidth\n    self._unscaled_dash_pattern = other._unscaled_dash_pattern\n    self._dash_pattern = other._dash_pattern\n    self._dashcapstyle = other._dashcapstyle\n    self._dashjoinstyle = other._dashjoinstyle\n    self._solidcapstyle = other._solidcapstyle\n    self._solidjoinstyle = other._solidjoinstyle\n    self._linestyle = other._linestyle\n    self._marker = MarkerStyle(marker=other._marker)\n    self._drawstyle = other._drawstyle",
    ".lib.matplotlib.path.py@@Path.__deepcopy__": "def __deepcopy__(self, memo=None):\n    p = copy.deepcopy(super(), memo)\n    p._readonly = False\n    return p",
    ".lib.matplotlib.transforms.py@@TransformNode.__getstate__": "def __getstate__(self):\n    return {**self.__dict__, '_parents': {k: v() for k, v in self._parents.items()}}",
    ".lib.matplotlib.transforms.py@@TransformNode.__setstate__": "def __setstate__(self, data_dict):\n    self.__dict__ = data_dict\n    self._parents = {k: weakref.ref(v, lambda _, pop=self._parents.pop, k=k: pop(k)) for k, v in self._parents.items() if v is not None}",
    ".lib.matplotlib.axis.py@@Tick.set_label1": "def set_label1(self, s):\n    self.label1.set_text(s)\n    self.stale = True",
    ".lib.matplotlib.axis.py@@Tick.set_label2": "def set_label2(self, s):\n    self.label2.set_text(s)\n    self.stale = True",
    ".lib.matplotlib.ticker.py@@Formatter.set_locs": "def set_locs(self, locs):\n    self.locs = locs",
    ".lib.matplotlib.axis.py@@Axis.get_minor_ticks": "def get_minor_ticks(self, numticks=None):\n    if numticks is None:\n        numticks = len(self.get_minorticklocs())\n    while len(self.minorTicks) < numticks:\n        tick = self._get_tick(major=False)\n        self.minorTicks.append(tick)\n        self._copy_tick_props(self.minorTicks[0], tick)\n    return self.minorTicks[:numticks]",
    ".lib.matplotlib.axis.py@@Tick.get_loc": "def get_loc(self):\n    return self._loc",
    ".lib.matplotlib.transforms.py@@_interval_contains_close": "def _interval_contains_close(interval, val, rtol=1e-10):\n    a, b = interval\n    if a > b:\n        a, b = (b, a)\n    rtol = (b - a) * rtol\n    return a - rtol <= val <= b + rtol"
}