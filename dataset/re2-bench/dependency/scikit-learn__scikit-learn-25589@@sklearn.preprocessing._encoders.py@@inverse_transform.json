{
    ".sklearn.utils.validation.py@@check_is_fitted": "def check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):\n    if isclass(estimator):\n        raise TypeError('{} is a class, not an instance.'.format(estimator))\n    if msg is None:\n        msg = \"This %(name)s instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.\"\n    if not hasattr(estimator, 'fit'):\n        raise TypeError('%s is not an estimator instance.' % estimator)\n    if attributes is not None:\n        if not isinstance(attributes, (list, tuple)):\n            attributes = [attributes]\n        fitted = all_or_any([hasattr(estimator, attr) for attr in attributes])\n    elif hasattr(estimator, '__sklearn_is_fitted__'):\n        fitted = estimator.__sklearn_is_fitted__()\n    else:\n        fitted = [v for v in vars(estimator) if v.endswith('_') and (not v.startswith('__'))]\n    if not fitted:\n        raise NotFittedError(msg % {'name': type(estimator).__name__})",
    ".sklearn.utils.validation.py@@check_array": "def check_array(array, accept_sparse=False, *, accept_large_sparse=True, dtype='numeric', order=None, copy=False, force_all_finite=True, ensure_2d=True, allow_nd=False, ensure_min_samples=1, ensure_min_features=1, estimator=None, input_name=''):\n    if isinstance(array, np.matrix):\n        raise TypeError('np.matrix is not supported. Please convert to a numpy array with np.asarray. For more information see: https://numpy.org/doc/stable/reference/generated/numpy.matrix.html')\n    xp, is_array_api = get_namespace(array)\n    array_orig = array\n    dtype_numeric = isinstance(dtype, str) and dtype == 'numeric'\n    dtype_orig = getattr(array, 'dtype', None)\n    if not hasattr(dtype_orig, 'kind'):\n        dtype_orig = None\n    dtypes_orig = None\n    pandas_requires_conversion = False\n    if hasattr(array, 'dtypes') and hasattr(array.dtypes, '__array__'):\n        with suppress(ImportError):\n            from pandas.api.types import is_sparse\n            if not hasattr(array, 'sparse') and array.dtypes.apply(is_sparse).any():\n                warnings.warn('pandas.DataFrame with sparse columns found.It will be converted to a dense numpy array.')\n        dtypes_orig = list(array.dtypes)\n        pandas_requires_conversion = any((_pandas_dtype_needs_early_conversion(i) for i in dtypes_orig))\n        if all((isinstance(dtype_iter, np.dtype) for dtype_iter in dtypes_orig)):\n            dtype_orig = np.result_type(*dtypes_orig)\n    elif hasattr(array, 'iloc') and hasattr(array, 'dtype'):\n        pandas_requires_conversion = _pandas_dtype_needs_early_conversion(array.dtype)\n        if isinstance(array.dtype, np.dtype):\n            dtype_orig = array.dtype\n        else:\n            dtype_orig = None\n    if dtype_numeric:\n        if dtype_orig is not None and dtype_orig.kind == 'O':\n            dtype = xp.float64\n        else:\n            dtype = None\n    if isinstance(dtype, (list, tuple)):\n        if dtype_orig is not None and dtype_orig in dtype:\n            dtype = None\n        else:\n            dtype = dtype[0]\n    if pandas_requires_conversion:\n        new_dtype = dtype_orig if dtype is None else dtype\n        array = array.astype(new_dtype)\n        dtype = None\n    if force_all_finite not in (True, False, 'allow-nan'):\n        raise ValueError('force_all_finite should be a bool or \"allow-nan\". Got {!r} instead'.format(force_all_finite))\n    estimator_name = _check_estimator_name(estimator)\n    context = ' by %s' % estimator_name if estimator is not None else ''\n    if hasattr(array, 'sparse') and array.ndim > 1:\n        with suppress(ImportError):\n            from pandas.api.types import is_sparse\n            if array.dtypes.apply(is_sparse).all():\n                array = array.sparse.to_coo()\n                if array.dtype == np.dtype('object'):\n                    unique_dtypes = set([dt.subtype.name for dt in array_orig.dtypes])\n                    if len(unique_dtypes) > 1:\n                        raise ValueError('Pandas DataFrame with mixed sparse extension arrays generated a sparse matrix with object dtype which can not be converted to a scipy sparse matrix.Sparse extension arrays should all have the same numeric type.')\n    if sp.issparse(array):\n        _ensure_no_complex_data(array)\n        array = _ensure_sparse_format(array, accept_sparse=accept_sparse, dtype=dtype, copy=copy, force_all_finite=force_all_finite, accept_large_sparse=accept_large_sparse, estimator_name=estimator_name, input_name=input_name)\n    else:\n        with warnings.catch_warnings():\n            try:\n                warnings.simplefilter('error', ComplexWarning)\n                if dtype is not None and np.dtype(dtype).kind in 'iu':\n                    array = _asarray_with_order(array, order=order, xp=xp)\n                    if array.dtype.kind == 'f':\n                        _assert_all_finite(array, allow_nan=False, msg_dtype=dtype, estimator_name=estimator_name, input_name=input_name)\n                    array = xp.astype(array, dtype, copy=False)\n                else:\n                    array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)\n            except ComplexWarning as complex_warning:\n                raise ValueError('Complex data not supported\\n{}\\n'.format(array)) from complex_warning\n        _ensure_no_complex_data(array)\n        if ensure_2d:\n            if array.ndim == 0:\n                raise ValueError('Expected 2D array, got scalar array instead:\\narray={}.\\nReshape your data either using array.reshape(-1, 1) if your data has a single feature or array.reshape(1, -1) if it contains a single sample.'.format(array))\n            if array.ndim == 1:\n                raise ValueError('Expected 2D array, got 1D array instead:\\narray={}.\\nReshape your data either using array.reshape(-1, 1) if your data has a single feature or array.reshape(1, -1) if it contains a single sample.'.format(array))\n        if dtype_numeric and array.dtype.kind in 'USV':\n            raise ValueError(\"dtype='numeric' is not compatible with arrays of bytes/strings.Convert your data to numeric values explicitly instead.\")\n        if not allow_nd and array.ndim >= 3:\n            raise ValueError('Found array with dim %d. %s expected <= 2.' % (array.ndim, estimator_name))\n        if force_all_finite:\n            _assert_all_finite(array, input_name=input_name, estimator_name=estimator_name, allow_nan=force_all_finite == 'allow-nan')\n    if ensure_min_samples > 0:\n        n_samples = _num_samples(array)\n        if n_samples < ensure_min_samples:\n            raise ValueError('Found array with %d sample(s) (shape=%s) while a minimum of %d is required%s.' % (n_samples, array.shape, ensure_min_samples, context))\n    if ensure_min_features > 0 and array.ndim == 2:\n        n_features = array.shape[1]\n        if n_features < ensure_min_features:\n            raise ValueError('Found array with %d feature(s) (shape=%s) while a minimum of %d is required%s.' % (n_features, array.shape, ensure_min_features, context))\n    if copy:\n        if xp.__name__ in {'numpy', 'numpy.array_api'}:\n            if np.may_share_memory(array, array_orig):\n                array = _asarray_with_order(array, dtype=dtype, order=order, copy=True, xp=xp)\n        else:\n            array = _asarray_with_order(array, dtype=dtype, order=order, copy=True, xp=xp)\n    return array",
    ".sklearn.utils._array_api.py@@get_namespace": "def get_namespace(*arrays):\n    if not get_config()['array_api_dispatch']:\n        return (_NumPyApiWrapper(), False)\n    namespaces = {x.__array_namespace__() if hasattr(x, '__array_namespace__') else None for x in arrays if not isinstance(x, (bool, int, float, complex))}\n    if not namespaces:\n        raise ValueError('Unrecognized array input')\n    if len(namespaces) != 1:\n        raise ValueError(f'Multiple namespaces for array inputs: {namespaces}')\n    xp, = namespaces\n    if xp is None:\n        return (_NumPyApiWrapper(), False)\n    return (_ArrayAPIWrapper(xp), True)",
    ".sklearn._config.py@@get_config": "def get_config():\n    return _get_threadlocal_config().copy()",
    ".sklearn._config.py@@_get_threadlocal_config": "def _get_threadlocal_config():\n    if not hasattr(_threadlocal, 'global_config'):\n        _threadlocal.global_config = _global_config.copy()\n    return _threadlocal.global_config",
    ".sklearn.utils.validation.py@@_check_estimator_name": "def _check_estimator_name(estimator):\n    if estimator is not None:\n        if isinstance(estimator, str):\n            return estimator\n        else:\n            return estimator.__class__.__name__\n    return None",
    ".sklearn.utils._array_api.py@@_asarray_with_order": "def _asarray_with_order(array, dtype=None, order=None, copy=None, xp=None):\n    if xp is None:\n        xp, _ = get_namespace(array)\n    if xp.__name__ in {'numpy', 'numpy.array_api'}:\n        array = numpy.asarray(array, order=order, dtype=dtype)\n        return xp.asarray(array, copy=copy)\n    else:\n        return xp.asarray(array, dtype=dtype, copy=copy)",
    ".sklearn.utils._array_api.py@@_NumPyApiWrapper.__getattr__": "def __getattr__(self, name):\n    return getattr(numpy, name)",
    ".sklearn.utils._array_api.py@@_NumPyApiWrapper.asarray": "def asarray(self, x, *, dtype=None, device=None, copy=None):\n    if copy is True:\n        return numpy.array(x, copy=True, dtype=dtype)\n    else:\n        return numpy.asarray(x, dtype=dtype)",
    ".sklearn.utils.validation.py@@_ensure_no_complex_data": "def _ensure_no_complex_data(array):\n    if hasattr(array, 'dtype') and array.dtype is not None and hasattr(array.dtype, 'kind') and (array.dtype.kind == 'c'):\n        raise ValueError('Complex data not supported\\n{}\\n'.format(array))",
    ".sklearn.utils.validation.py@@_assert_all_finite": "def _assert_all_finite(X, allow_nan=False, msg_dtype=None, estimator_name=None, input_name=''):\n    xp, _ = get_namespace(X)\n    if _get_config()['assume_finite']:\n        return\n    X = xp.asarray(X)\n    if X.dtype == np.dtype('object') and (not allow_nan):\n        if _object_dtype_isnan(X).any():\n            raise ValueError('Input contains NaN')\n    if X.dtype.kind not in 'fc':\n        return\n    with np.errstate(over='ignore'):\n        first_pass_isfinite = xp.isfinite(xp.sum(X))\n    if first_pass_isfinite:\n        return\n    use_cython = xp is np and X.data.contiguous and (X.dtype.type in {np.float32, np.float64})\n    if use_cython:\n        out = cy_isfinite(X.reshape(-1), allow_nan=allow_nan)\n        has_nan_error = False if allow_nan else out == FiniteStatus.has_nan\n        has_inf = out == FiniteStatus.has_infinite\n    else:\n        has_inf = xp.any(xp.isinf(X))\n        has_nan_error = False if allow_nan else xp.any(xp.isnan(X))\n    if has_inf or has_nan_error:\n        if has_nan_error:\n            type_err = 'NaN'\n        else:\n            msg_dtype = msg_dtype if msg_dtype is not None else X.dtype\n            type_err = f'infinity or a value too large for {msg_dtype!r}'\n        padded_input_name = input_name + ' ' if input_name else ''\n        msg_err = f'Input {padded_input_name}contains {type_err}.'\n        if estimator_name and input_name == 'X' and has_nan_error:\n            msg_err += f'\\n{estimator_name} does not accept missing values encoded as NaN natively. For supervised learning, you might want to consider sklearn.ensemble.HistGradientBoostingClassifier and Regressor which accept missing values encoded as NaNs natively. Alternatively, it is possible to preprocess the data, for instance by using an imputer transformer in a pipeline or drop samples with missing values. See https://scikit-learn.org/stable/modules/impute.html You can find a list of all estimators that handle NaN values at the following page: https://scikit-learn.org/stable/modules/impute.html#estimators-that-handle-nan-values'\n        raise ValueError(msg_err)",
    ".sklearn.utils.validation.py@@_num_samples": "def _num_samples(x):\n    message = 'Expected sequence or array-like, got %s' % type(x)\n    if hasattr(x, 'fit') and callable(x.fit):\n        raise TypeError(message)\n    if not hasattr(x, '__len__') and (not hasattr(x, 'shape')):\n        if hasattr(x, '__array__'):\n            x = np.asarray(x)\n        else:\n            raise TypeError(message)\n    if hasattr(x, 'shape') and x.shape is not None:\n        if len(x.shape) == 0:\n            raise TypeError('Singleton array %r cannot be considered a valid collection.' % x)\n        if isinstance(x.shape[0], numbers.Integral):\n            return x.shape[0]\n    try:\n        return len(x)\n    except TypeError as type_error:\n        raise TypeError(message) from type_error",
    ".sklearn.utils._mask.py@@_get_mask": "def _get_mask(X, value_to_mask):\n    if not sp.issparse(X):\n        return _get_dense_mask(X, value_to_mask)\n    Xt = _get_dense_mask(X.data, value_to_mask)\n    sparse_constructor = sp.csr_matrix if X.format == 'csr' else sp.csc_matrix\n    Xt_sparse = sparse_constructor((Xt, X.indices.copy(), X.indptr.copy()), shape=X.shape, dtype=bool)\n    return Xt_sparse",
    ".sklearn.utils._mask.py@@_get_dense_mask": "def _get_dense_mask(X, value_to_mask):\n    with suppress(ImportError, AttributeError):\n        import pandas\n        if value_to_mask is pandas.NA:\n            return pandas.isna(X)\n    if is_scalar_nan(value_to_mask):\n        if X.dtype.kind == 'f':\n            Xt = np.isnan(X)\n        elif X.dtype.kind in ('i', 'u'):\n            Xt = np.zeros(X.shape, dtype=bool)\n        else:\n            Xt = _object_dtype_isnan(X)\n    else:\n        Xt = X == value_to_mask\n    return Xt",
    ".sklearn.utils.__init__.py@@is_scalar_nan": "def is_scalar_nan(x):\n    return isinstance(x, numbers.Real) and math.isnan(x)"
}