{
    ".lib.matplotlib.backend_bases.py@@GraphicsContextBase.get_clip_rectangle": "def get_clip_rectangle(self):\n    return self._cliprect",
    ".lib.matplotlib.backend_bases.py@@GraphicsContextBase.get_clip_path": "def get_clip_path(self):\n    if self._clippath is not None:\n        tpath, tr = self._clippath.get_transformed_path_and_affine()\n        if np.all(np.isfinite(tpath.vertices)):\n            return (tpath, tr)\n        else:\n            _log.warning('Ill-defined clip_path detected. Returning None.')\n            return (None, None)\n    return (None, None)",
    ".lib.matplotlib.transforms.py@@BboxBase.size": "def size(self):\n    points = self.get_points()\n    return points[1] - points[0]",
    ".lib.matplotlib.transforms.py@@TransformedBbox.get_points": "def get_points(self):\n    if self._invalid:\n        p = self._bbox.get_points()\n        points = self._transform.transform([[p[0, 0], p[0, 1]], [p[1, 0], p[0, 1]], [p[0, 0], p[1, 1]], [p[1, 0], p[1, 1]]])\n        points = np.ma.filled(points, 0.0)\n        xs = (min(points[:, 0]), max(points[:, 0]))\n        if p[0, 0] > p[1, 0]:\n            xs = xs[::-1]\n        ys = (min(points[:, 1]), max(points[:, 1]))\n        if p[0, 1] > p[1, 1]:\n            ys = ys[::-1]\n        self._points = np.array([[xs[0], ys[0]], [xs[1], ys[1]]])\n        self._invalid = 0\n    return self._points",
    ".lib.matplotlib.transforms.py@@Bbox.get_points": "def get_points(self):\n    self._invalid = 0\n    return self._points",
    ".lib.matplotlib.transforms.py@@Transform.transform": "def transform(self, values):\n    values = np.asanyarray(values)\n    ndim = values.ndim\n    values = values.reshape((-1, self.input_dims))\n    res = self.transform_affine(self.transform_non_affine(values))\n    if ndim == 0:\n        assert not np.ma.is_masked(res)\n        return res[0, 0]\n    if ndim == 1:\n        return res.reshape(-1)\n    elif ndim == 2:\n        return res\n    raise ValueError('Input values must have shape (N x {dims}) or ({dims}).'.format(dims=self.input_dims))",
    ".lib.matplotlib.transforms.py@@CompositeGenericTransform.transform_non_affine": "def transform_non_affine(self, points):\n    if self._a.is_affine and self._b.is_affine:\n        return points\n    elif not self._a.is_affine and self._b.is_affine:\n        return self._a.transform_non_affine(points)\n    else:\n        return self._b.transform_non_affine(self._a.transform(points))",
    ".lib.matplotlib.transforms.py@@CompositeGenericTransform.transform_affine": "def transform_affine(self, points):\n    return self.get_affine().transform(points)",
    ".lib.matplotlib.transforms.py@@CompositeGenericTransform.get_affine": "def get_affine(self):\n    if not self._b.is_affine:\n        return self._b.get_affine()\n    else:\n        return Affine2D(np.dot(self._b.get_affine().get_matrix(), self._a.get_affine().get_matrix()))",
    ".lib.matplotlib.transforms.py@@AffineBase.get_affine": "def get_affine(self):\n    return self",
    ".lib.matplotlib.transforms.py@@BboxTransformTo.get_matrix": "def get_matrix(self):\n    if self._invalid:\n        outl, outb, outw, outh = self._boxout.bounds\n        if DEBUG and (outw == 0 or outh == 0):\n            raise ValueError('Transforming to a singular bounding box.')\n        self._mtx = np.array([[outw, 0.0, outl], [0.0, outh, outb], [0.0, 0.0, 1.0]], float)\n        self._inverted = None\n        self._invalid = 0\n    return self._mtx",
    ".lib.matplotlib.transforms.py@@Affine2D.get_matrix": "def get_matrix(self):\n    if self._invalid:\n        self._inverted = None\n        self._invalid = 0\n    return self._mtx",
    ".lib.matplotlib.transforms.py@@BboxBase.bounds": "def bounds(self):\n    (x0, y0), (x1, y1) = self.get_points()\n    return (x0, y0, x1 - x0, y1 - y0)",
    ".lib.matplotlib.transforms.py@@Affine2D.__init__": "def __init__(self, matrix=None, **kwargs):\n    super().__init__(**kwargs)\n    if matrix is None:\n        matrix = IdentityTransform._mtx.copy()\n    self._mtx = matrix.copy()\n    self._invalid = 0",
    ".lib.matplotlib.transforms.py@@AffineBase.__init__": "def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self._inverted = None",
    ".lib.matplotlib.transforms.py@@TransformNode.__init__": "def __init__(self, shorthand_name=None):\n    self._parents = {}\n    self._invalid = 1\n    self._shorthand_name = shorthand_name or ''",
    ".lib.matplotlib.transforms.py@@AffineBase.transform": "def transform(self, values):\n    return self.transform_affine(values)",
    ".lib.matplotlib.transforms.py@@Affine2DBase.transform_affine": "def transform_affine(self, points):\n    mtx = self.get_matrix()\n    if isinstance(points, np.ma.MaskedArray):\n        tpoints = affine_transform(points.data, mtx)\n        return np.ma.MaskedArray(tpoints, mask=np.ma.getmask(points))\n    return affine_transform(points, mtx)",
    ".lib.matplotlib.transforms.py@@BboxBase.p0": "def p0(self):\n    return self.get_points()[0]",
    ".lib.matplotlib.backends.backend_ps.py@@_nums_to_str": "def _nums_to_str(*args):\n    return ' '.join((f'{arg:1.3f}'.rstrip('0').rstrip('.') for arg in args))",
    ".lib.matplotlib.transforms.py@@TransformedPath.get_transformed_path_and_affine": "def get_transformed_path_and_affine(self):\n    self._revalidate()\n    return (self._transformed_path, self.get_affine())",
    ".lib.matplotlib.transforms.py@@TransformedPatchPath._revalidate": "def _revalidate(self):\n    patch_path = self._patch.get_path()\n    if self._transformed_path is None or self._path != patch_path or self._invalid & self.INVALID_NON_AFFINE == self.INVALID_NON_AFFINE:\n        self._path = patch_path\n        self._transformed_path = self._transform.transform_path_non_affine(patch_path)\n        self._transformed_points = Path._fast_from_codes_and_verts(self._transform.transform_non_affine(patch_path.vertices), None, patch_path)\n    self._invalid = 0",
    ".lib.matplotlib.patches.py@@Wedge.get_path": "def get_path(self):\n    if self._path is None:\n        self._recompute_path()\n    return self._path",
    ".lib.matplotlib.transforms.py@@AffineBase.transform_path_non_affine": "def transform_path_non_affine(self, path):\n    return path",
    ".lib.matplotlib.path.py@@Path.vertices": "def vertices(self):\n    return self._vertices",
    ".lib.matplotlib.transforms.py@@AffineBase.transform_non_affine": "def transform_non_affine(self, points):\n    return points",
    ".lib.matplotlib.path.py@@Path._fast_from_codes_and_verts": "def _fast_from_codes_and_verts(cls, verts, codes, internals_from=None):\n    pth = cls.__new__(cls)\n    pth._vertices = _to_unmasked_float_array(verts)\n    pth._codes = codes\n    pth._readonly = False\n    if internals_from is not None:\n        pth._should_simplify = internals_from._should_simplify\n        pth._simplify_threshold = internals_from._simplify_threshold\n        pth._interpolation_steps = internals_from._interpolation_steps\n    else:\n        pth._should_simplify = True\n        pth._simplify_threshold = mpl.rcParams['path.simplify_threshold']\n        pth._interpolation_steps = 1\n    return pth",
    ".lib.matplotlib.cbook.__init__.py@@_to_unmasked_float_array": "def _to_unmasked_float_array(x):\n    if hasattr(x, 'mask'):\n        return np.ma.asarray(x, float).filled(np.nan)\n    else:\n        return np.asarray(x, float)",
    ".lib.matplotlib.transforms.py@@TransformedPath.get_affine": "def get_affine(self):\n    return self._transform.get_affine()",
    ".lib.matplotlib.path.py@@Path.codes": "def codes(self):\n    return self._codes",
    ".lib.matplotlib.path.py@@Path.should_simplify": "def should_simplify(self):\n    return self._should_simplify",
    ".lib.matplotlib.path.py@@Path.simplify_threshold": "def simplify_threshold(self):\n    return self._simplify_threshold",
    ".lib.matplotlib.transforms.py@@AffineBase.__array__": "def __array__(self, *args, **kwargs):\n    return self.get_matrix()"
}