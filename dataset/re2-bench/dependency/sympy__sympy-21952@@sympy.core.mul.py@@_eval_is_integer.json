{
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.logic.py@@_fuzzy_group": "def _fuzzy_group(args, quick_exit=False):\n    saw_other = False\n    for a in args:\n        if a is True:\n            continue\n        if a is None:\n            return\n        if quick_exit and saw_other:\n            return\n        saw_other = True\n    return not saw_other",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.assumptions.py@@_ask": "def _ask(fact, obj):\n    assumptions = obj._assumptions\n    handler_map = obj._prop_handler\n    assumptions._tell(fact, None)\n    try:\n        evaluate = handler_map[fact]\n    except KeyError:\n        pass\n    else:\n        a = evaluate(obj)\n        if a is not None:\n            assumptions.deduce_all_facts(((fact, a),))\n            return a\n    prereq = list(_assume_rules.prereq[fact])\n    shuffle(prereq)\n    for pk in prereq:\n        if pk in assumptions:\n            continue\n        if pk in handler_map:\n            _ask(pk, obj)\n            ret_val = assumptions.get(fact)\n            if ret_val is not None:\n                return ret_val\n    return None",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.numbers.py@@Integer.__abs__": "def __abs__(self):\n    if self.p >= 0:\n        return self\n    else:\n        return Integer(-self.p)",
    ".sympy.core.numbers.py@@NegativeOne.__abs__": "def __abs__():\n    return S.One",
    ".sympy.core.power.py@@Pow.as_base_exp": "def as_base_exp(self):\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and (b.q != 1):\n        return (Integer(b.q), -e)\n    return (b, e)",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, str):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    if ival == 1:\n        return S.One\n    if ival == -1:\n        return S.NegativeOne\n    if ival == 0:\n        return S.Zero\n    obj = Expr.__new__(cls)\n    obj.p = ival\n    return obj",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.numbers.py@@Rational.as_numer_denom": "def as_numer_denom(self):\n    return (Integer(self.p), Integer(self.q))",
    ".sympy.core.numbers.py@@One.__abs__": "def __abs__():\n    return S.One",
    ".sympy.core.power.py@@Pow._eval_is_rational": "def _eval_is_rational(self):\n    if self.exp.is_integer and self.base.is_rational and fuzzy_not(fuzzy_and([self.exp.is_negative, self.base.is_zero])):\n        return True\n    p = self.func(*self.as_base_exp())\n    if not p.is_Pow:\n        return p.is_rational\n    b, e = p.as_base_exp()\n    if e.is_Rational and b.is_Rational:\n        return False\n    if e.is_integer:\n        if b.is_rational:\n            if fuzzy_not(b.is_zero) or e.is_nonnegative:\n                return True\n            if b == e:\n                return True\n        elif b.is_irrational:\n            return e.is_zero\n    if b is S.Exp1:\n        if e.is_rational and e.is_nonzero:\n            return False",
    ".sympy.core.power.py@@Pow.exp": "def exp(self):\n    return self._args[1]",
    ".sympy.core.power.py@@Pow.base": "def base(self):\n    return self._args[0]",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.core.power.py@@Pow.__new__": "def __new__(cls, b, e, evaluate=None):\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    from sympy.functions.elementary.exponential import exp_polar\n    b = _sympify(b)\n    e = _sympify(e)\n    from sympy.core.relational import Relational\n    if isinstance(b, Relational) or isinstance(e, Relational):\n        raise TypeError('Relational can not be used in Pow')\n    if not (isinstance(b, Expr) and isinstance(e, Expr)):\n        SymPyDeprecationWarning(feature='Pow with non-Expr args', useinstead='Expr args', issue=19445, deprecated_since_version='1.7').warn()\n    if evaluate:\n        if b is S.Zero and e is S.NegativeInfinity:\n            return S.ComplexInfinity\n        if e is S.ComplexInfinity:\n            return S.NaN\n        if e is S.Zero:\n            return S.One\n        elif e is S.One:\n            return b\n        elif e == -1 and (not b):\n            return S.ComplexInfinity\n        elif e.__class__.__name__ == 'AccumulationBounds':\n            if b == S.Exp1:\n                from sympy import AccumBounds\n                return AccumBounds(Pow(b, e.min), Pow(b, e.max))\n        elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and e.is_integer and _coeff_isneg(b):\n            if e.is_even:\n                b = -b\n            elif e.is_odd:\n                return -Pow(-b, e)\n        if S.NaN in (b, e):\n            return S.NaN\n        elif b is S.One:\n            if abs(e).is_infinite:\n                return S.NaN\n            return S.One\n        else:\n            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):\n                from sympy import numer, denom, log, sign, im, factor_terms\n                c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n                den = denom(ex)\n                if isinstance(den, log) and den.args[0] == b:\n                    return S.Exp1 ** (c * numer(ex))\n                elif den.is_Add:\n                    s = sign(im(b))\n                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):\n                        return S.Exp1 ** (c * numer(ex))\n            obj = b._eval_power(e)\n            if obj is not None:\n                return obj\n    obj = Expr.__new__(cls, b, e)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if not isinstance(obj, Pow):\n        return obj\n    obj.is_commutative = b.is_commutative and e.is_commutative\n    return obj",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    cls = getattr(a, '__class__', None)\n    if cls is None:\n        cls = type(a)\n    conv = converter.get(cls, None)\n    if conv is not None:\n        return conv(a)\n    for superclass in getmro(cls):\n        try:\n            return converter[superclass](a)\n        except KeyError:\n            continue\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from ..tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(), locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        else:\n            for coerce in (float, int):\n                try:\n                    return sympify(coerce(a))\n                except (TypeError, ValueError, AttributeError, SympifyError):\n                    continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational, evaluate=evaluate) for x in a])\n        except TypeError:\n            pass\n    if not isinstance(a, str):\n        try:\n            a = str(a)\n        except Exception as exc:\n            raise SympifyError(a, exc)\n        from sympy.utilities.exceptions import SymPyDeprecationWarning\n        SymPyDeprecationWarning(feature='String fallback in sympify', useinstead='sympify(str(obj)) or ' + 'sympy.core.sympify.converter or obj._sympy_', issue=18066, deprecated_since_version='1.6').warn()\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.function.py@@_coeff_isneg": "def _coeff_isneg(a):\n    if a.is_MatMul:\n        a = a.args[0]\n    if a.is_Mul:\n        a = a.args[0]\n    return a.is_Number and a.is_extended_negative",
    ".sympy.core.numbers.py@@NumberSymbol.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if self is other:\n        return True\n    if other.is_Number and self.is_irrational:\n        return False\n    return False",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    from sympy.core.power import integer_log\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if not isinstance(other, Number):\n        return False\n    if not self:\n        return not other\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Rational:\n        return self.p == other.p and self.q == other.q\n    if other.is_Float:\n        if self.q & self.q - 1:\n            return False\n        s, m, t = other._mpf_[:3]\n        if s:\n            m = -m\n        if not t:\n            if not self.is_Integer or self.is_even:\n                return False\n            return m == self.p\n        if t > 0:\n            if not self.is_Integer:\n                return False\n            return self.p and (not self.p % m) and (integer_log(self.p // m, 2) == (t, True))\n        if self.is_Integer:\n            return False\n        return m == self.p and integer_log(self.q, 2) == (-t, True)\n    return False",
    ".sympy.core.expr.py@@Expr._eval_power": "def _eval_power(self, other):\n    return None",
    ".sympy.core.basic.py@@Basic._exec_constructor_postprocessors": "def _exec_constructor_postprocessors(cls, obj):\n    clsname = obj.__class__.__name__\n    postprocessors = defaultdict(list)\n    for i in obj.args:\n        try:\n            postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)\n            for k, v in chain.from_iterable(postprocessor_mappings):\n                postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n        except TypeError:\n            pass\n    for f in postprocessors.get(clsname, []):\n        obj = f(obj)\n    return obj",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.assumptions.py@@StdFactKB.copy": "def copy(self):\n    return self.__class__(self)",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    super().__init__(_assume_rules)\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.__init__": "def __init__(self, rules):\n    self.rules = rules",
    ".sympy.core.numbers.py@@Integer._eval_power": "def _eval_power(self, expt):\n    from sympy.ntheory.factor_ import perfect_power\n    if expt is S.Infinity:\n        if self.p > S.One:\n            return S.Infinity\n        return S.Infinity + S.ImaginaryUnit * S.Infinity\n    if expt is S.NegativeInfinity:\n        return Rational(1, self, 1) ** S.Infinity\n    if not isinstance(expt, Number):\n        if self.is_negative and expt.is_even:\n            return (-self) ** expt\n    if isinstance(expt, Float):\n        return super()._eval_power(expt)\n    if not isinstance(expt, Rational):\n        return\n    if expt is S.Half and self.is_negative:\n        return S.ImaginaryUnit * Pow(-self, expt)\n    if expt.is_negative:\n        ne = -expt\n        if self.is_negative:\n            return S.NegativeOne ** expt * Rational(1, -self, 1) ** ne\n        else:\n            return Rational(1, self.p, 1) ** ne\n    x, xexact = integer_nthroot(abs(self.p), expt.q)\n    if xexact:\n        result = Integer(x ** abs(expt.p))\n        if self.is_negative:\n            result *= S.NegativeOne ** expt\n        return result\n    b_pos = int(abs(self.p))\n    p = perfect_power(b_pos)\n    if p is not False:\n        dict = {p[0]: p[1]}\n    else:\n        dict = Integer(b_pos).factors(limit=2 ** 15)\n    out_int = 1\n    out_rad = 1\n    sqr_int = 1\n    sqr_gcd = 0\n    sqr_dict = {}\n    for prime, exponent in dict.items():\n        exponent *= expt.p\n        div_e, div_m = divmod(exponent, expt.q)\n        if div_e > 0:\n            out_int *= prime ** div_e\n        if div_m > 0:\n            g = igcd(div_m, expt.q)\n            if g != 1:\n                out_rad *= Pow(prime, Rational(div_m // g, expt.q // g, 1))\n            else:\n                sqr_dict[prime] = div_m\n    for p, ex in sqr_dict.items():\n        if sqr_gcd == 0:\n            sqr_gcd = ex\n        else:\n            sqr_gcd = igcd(sqr_gcd, ex)\n            if sqr_gcd == 1:\n                break\n    for k, v in sqr_dict.items():\n        sqr_int *= k ** (v // sqr_gcd)\n    if sqr_int == b_pos and out_int == 1 and (out_rad == 1):\n        result = None\n    else:\n        result = out_int * out_rad * Pow(sqr_int, Rational(sqr_gcd, expt.q))\n        if self.is_negative:\n            result *= Pow(S.NegativeOne, expt)\n    return result",
    ".sympy.core.power.py@@integer_nthroot": "def integer_nthroot(y, n):\n    y, n = (as_int(y), as_int(n))\n    if y < 0:\n        raise ValueError('y must be nonnegative')\n    if n < 1:\n        raise ValueError('n must be positive')\n    if HAS_GMPY and n < 2 ** 63:\n        if HAS_GMPY >= 2:\n            x, t = gmpy.iroot(y, n)\n        else:\n            x, t = gmpy.root(y, n)\n        return (as_int(x), bool(t))\n    return _integer_nthroot_python(y, n)",
    ".sympy.core.compatibility.py@@as_int": "def as_int(n, strict=True):\n    if strict:\n        try:\n            if type(n) is bool:\n                raise TypeError\n            return operator.index(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n != result:\n            raise ValueError('%s is not an integer' % (n,))\n        return result",
    ".sympy.core.power.py@@_integer_nthroot_python": "def _integer_nthroot_python(y, n):\n    if y in (0, 1):\n        return (y, True)\n    if n == 1:\n        return (y, True)\n    if n == 2:\n        x, rem = mpmath_sqrtrem(y)\n        return (int(x), not rem)\n    if n > y:\n        return (1, False)\n    try:\n        guess = int(y ** (1.0 / n) + 0.5)\n    except OverflowError:\n        exp = _log(y, 2) / n\n        if exp > 53:\n            shift = int(exp - 53)\n            guess = int(2.0 ** (exp - shift) + 1) << shift\n        else:\n            guess = int(2.0 ** exp)\n    if guess > 2 ** 50:\n        xprev, x = (-1, guess)\n        while 1:\n            t = x ** (n - 1)\n            xprev, x = (x, ((n - 1) * x + y // t) // n)\n            if abs(x - xprev) < 2:\n                break\n    else:\n        x = guess\n    t = x ** n\n    while t < y:\n        x += 1\n        t = x ** n\n    while t > y:\n        x -= 1\n        t = x ** n\n    return (int(x), t == y)",
    ".sympy.ntheory.factor_.py@@perfect_power": "def perfect_power(n, candidates=None, big=True, factor=True):\n    from sympy.core.power import integer_nthroot\n    n = as_int(n)\n    if n < 3:\n        if n < 1:\n            raise ValueError('expecting positive n')\n        return False\n    logn = math.log(n, 2)\n    max_possible = int(logn) + 2\n    not_square = n % 10 in [2, 3, 7, 8]\n    min_possible = 2 + not_square\n    if not candidates:\n        candidates = primerange(min_possible, max_possible)\n    else:\n        candidates = sorted([i for i in candidates if min_possible <= i < max_possible])\n        if n % 2 == 0:\n            e = trailing(n)\n            candidates = [i for i in candidates if e % i == 0]\n        if big:\n            candidates = reversed(candidates)\n        for e in candidates:\n            r, ok = integer_nthroot(n, e)\n            if ok:\n                return (r, e)\n        return False\n\n    def _factors():\n        rv = 2 + n % 2\n        while True:\n            yield rv\n            rv = nextprime(rv)\n    for fac, e in zip(_factors(), candidates):\n        if factor and n % fac == 0:\n            if fac == 2:\n                e = trailing(n)\n            else:\n                e = multiplicity(fac, n)\n            if e == 1:\n                return False\n            r, exact = integer_nthroot(n, e)\n            if not exact:\n                m = n // fac ** e\n                rE = perfect_power(m, candidates=divisors(e, generator=True))\n                if not rE:\n                    return False\n                else:\n                    r, E = rE\n                    r, e = (fac ** (e // E) * r, E)\n            if not big:\n                e0 = primefactors(e)\n                if e0[0] != e:\n                    r, e = (r ** (e // e0[0]), e0[0])\n            return (r, e)\n        if logn / e < 40:\n            b = 2.0 ** (logn / e)\n            if abs(int(b + 0.5) - b) > 0.01:\n                continue\n        r, exact = integer_nthroot(n, e)\n        if exact:\n            if big:\n                m = perfect_power(r, big=big, factor=factor)\n                if m:\n                    r, e = (m[0], e * m[1])\n            return (int(r), e)\n    return False",
    ".sympy.ntheory.factor_.py@@_factors": "def _factors():\n    rv = 2 + n % 2\n    while True:\n        yield rv\n        rv = nextprime(rv)",
    ".sympy.ntheory.generate.py@@primerange": "def primerange(a, b=None):\n    from sympy.functions.elementary.integers import ceiling\n    if b is None:\n        a, b = (2, a)\n    if a >= b:\n        return\n    if b <= sieve._list[-1]:\n        yield from sieve.primerange(a, b)\n        return\n    a = as_int(ceiling(a)) - 1\n    b = as_int(ceiling(b))\n    while 1:\n        a = nextprime(a)\n        if a < b:\n            yield a\n        else:\n            return",
    ".sympy.ntheory.generate.py@@Sieve.primerange": "def primerange(self, a, b=None):\n    from sympy.functions.elementary.integers import ceiling\n    if b is None:\n        b = as_int(ceiling(a))\n        a = 2\n    else:\n        a = max(2, as_int(ceiling(a)))\n        b = as_int(ceiling(b))\n    if a >= b:\n        return\n    self.extend(b)\n    i = self.search(a)[1]\n    maxi = len(self._list) + 1\n    while i < maxi:\n        p = self._list[i - 1]\n        if p < b:\n            yield p\n            i += 1\n        else:\n            return",
    ".sympy.core.function.py@@Function.__new__": "def __new__(cls, *args, **options):\n    if cls is Function:\n        return UndefinedFunction(*args, **options)\n    n = len(args)\n    if n not in cls.nargs:\n        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'\n        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})\n    evaluate = options.get('evaluate', global_parameters.evaluate)\n    result = super().__new__(cls, *args, **options)\n    if evaluate and isinstance(result, cls) and result.args:\n        pr2 = min((cls._should_evalf(a) for a in result.args))\n        if pr2 > 0:\n            pr = max((cls._should_evalf(a) for a in result.args))\n            result = result.evalf(mlib.libmpf.prec_to_dps(pr))\n    return result",
    ".sympy.core.function.py@@FunctionClass.nargs": "def nargs(self):\n    from sympy.sets.sets import FiniteSet\n    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0",
    ".sympy.sets.sets.py@@FiniteSet.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n    if evaluate:\n        args = list(map(sympify, args))\n        if len(args) == 0:\n            return S.EmptySet\n    else:\n        args = list(map(sympify, args))\n    dargs = {}\n    for i in reversed(list(ordered(args))):\n        if i.is_Symbol:\n            dargs[i] = i\n        else:\n            try:\n                dargs[i.as_dummy()] = i\n            except TypeError:\n                dargs[i] = i\n    _args_set = set(dargs.values())\n    args = list(ordered(_args_set, Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._args_set = _args_set\n    return obj",
    ".sympy.core.compatibility.py@@ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    d = defaultdict(list)\n    if keys:\n        if not isinstance(keys, (list, tuple)):\n            keys = [keys]\n        keys = list(keys)\n        f = keys.pop(0)\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n    for k in sorted(d.keys()):\n        if len(d[k]) > 1:\n            if keys:\n                d[k] = ordered(d[k], keys, default, warn)\n            elif default:\n                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)\n            elif warn:\n                from sympy.utilities.iterables import uniq\n                u = list(uniq(d[k]))\n                if len(u) > 1:\n                    raise ValueError('not enough keys to break ties: %s' % u)\n        yield from d[k]\n        d.pop(k)",
    ".sympy.core.basic.py@@Basic.as_dummy": "def as_dummy(self):\n    from sympy.core.symbol import Dummy, Symbol\n\n    def can(x):\n        free = x.free_symbols\n        bound = set(x.bound_symbols)\n        d = {i: Dummy() for i in bound & free}\n        x = x.subs(d)\n        x = x.xreplace(x.canonical_variables)\n        return x.xreplace({v: k for k, v in d.items()})\n    if not self.has(Symbol):\n        return self\n    return self.replace(lambda x: hasattr(x, 'bound_symbols'), lambda x: can(x), simultaneous=False)",
    ".sympy.core.basic.py@@Basic.has": "def has(self, *patterns):\n    return any((self._has(pattern) for pattern in patterns))",
    ".sympy.core.basic.py@@Basic._has": "def _has(self, pattern):\n    from sympy.core.function import UndefinedFunction, Function\n    if isinstance(pattern, UndefinedFunction):\n        return any((f.func == pattern or f == pattern for f in self.atoms(Function, UndefinedFunction)))\n    if isinstance(pattern, BasicMeta):\n        subtrees = preorder_traversal(self)\n        return any((isinstance(arg, pattern) for arg in subtrees))\n    pattern = _sympify(pattern)\n    _has_matcher = getattr(pattern, '_has_matcher', None)\n    if _has_matcher is not None:\n        match = _has_matcher()\n        return any((match(arg) for arg in preorder_traversal(self)))\n    else:\n        return any((arg == pattern for arg in preorder_traversal(self)))",
    ".sympy.core.basic.py@@preorder_traversal.__init__": "def __init__(self, node, keys=None):\n    self._skip_flag = False\n    self._pt = self._preorder_traversal(node, keys)",
    ".sympy.core.basic.py@@preorder_traversal.__iter__": "def __iter__(self):\n    return self",
    ".sympy.core.basic.py@@preorder_traversal.__next__": "def __next__(self):\n    return next(self._pt)",
    ".sympy.core.basic.py@@preorder_traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.sets.sets.py@@Set._infimum_key": "def _infimum_key(expr):\n    try:\n        infimum = expr.inf\n        assert infimum.is_comparable\n        infimum = infimum.evalf()\n    except (NotImplementedError, AttributeError, AssertionError, ValueError):\n        infimum = S.Infinity\n    return infimum",
    ".sympy.core.numbers.py@@Infinity.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.expr.py@@Expr.__hash__": "def __hash__(self) -> int:\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.sets.sets.py@@Set.__contains__": "def __contains__(self, other):\n    other = _sympify(other)\n    c = self._contains(other)\n    b = tfn[c]\n    if b is None:\n        raise TypeError('did not evaluate to a bool: %r' % c)\n    return b",
    ".sympy.sets.sets.py@@FiniteSet._contains": "def _contains(self, other):\n    if other in self._args_set:\n        return True\n    else:\n        return fuzzy_or((fuzzy_bool(Eq(e, other, evaluate=True)) for e in self.args))",
    ".sympy.logic.boolalg.py@@BooleanTrue.__bool__": "def __bool__(self):\n    return True",
    ".sympy.core.function.py@@Application.__new__": "def __new__(cls, *args, **options):\n    from sympy.sets.fancysets import Naturals0\n    from sympy.sets.sets import FiniteSet\n    args = list(map(sympify, args))\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    options.pop('nargs', None)\n    if options:\n        raise ValueError('Unknown options: %s' % options)\n    if evaluate:\n        evaluated = cls.eval(*args)\n        if evaluated is not None:\n            return evaluated\n    obj = super().__new__(cls, *args, **options)\n    sentinel = object()\n    objnargs = getattr(obj, 'nargs', sentinel)\n    if objnargs is not sentinel:\n        if is_sequence(objnargs):\n            nargs = tuple(ordered(set(objnargs)))\n        elif objnargs is not None:\n            nargs = (as_int(objnargs),)\n        else:\n            nargs = None\n    else:\n        nargs = obj._nargs\n    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()\n    return obj",
    ".sympy.functions.elementary.integers.py@@RoundFunction.eval": "def eval(cls, arg):\n    from sympy import im\n    v = cls._eval_number(arg)\n    if v is not None:\n        return v\n    if arg.is_integer or arg.is_finite is False:\n        return arg\n    if arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        i = im(arg)\n        if not i.has(S.ImaginaryUnit):\n            return cls(i) * S.ImaginaryUnit\n        return cls(arg, evaluate=False)\n    ipart = npart = spart = S.Zero\n    terms = Add.make_args(arg)\n    for t in terms:\n        if t.is_integer or (t.is_imaginary and im(t).is_integer):\n            ipart += t\n        elif t.has(Symbol):\n            spart += t\n        else:\n            npart += t\n    if not (npart or spart):\n        return ipart\n    if npart and (not spart or (npart.is_real and (spart.is_imaginary or (S.ImaginaryUnit * spart).is_real)) or (npart.is_imaginary and spart.is_real)):\n        try:\n            r, i = get_integer_part(npart, cls._dir, {}, return_ints=True)\n            ipart += Integer(r) + Integer(i) * S.ImaginaryUnit\n            npart = S.Zero\n        except (PrecisionExhausted, NotImplementedError):\n            pass\n    spart += npart\n    if not spart:\n        return ipart\n    elif spart.is_imaginary or (S.ImaginaryUnit * spart).is_real:\n        return ipart + cls(im(spart), evaluate=False) * S.ImaginaryUnit\n    elif isinstance(spart, (floor, ceiling)):\n        return ipart + spart\n    else:\n        return ipart + cls(spart, evaluate=False)",
    ".sympy.functions.elementary.integers.py@@ceiling._eval_number": "def _eval_number(cls, arg):\n    if arg.is_Number:\n        return arg.ceiling()\n    elif any((isinstance(i, j) for i in (arg, -arg) for j in (floor, ceiling))):\n        return arg\n    if arg.is_NumberSymbol:\n        return arg.approximation_interval(Integer)[1]",
    ".sympy.core.numbers.py@@Integer.ceiling": "def ceiling(self):\n    return Integer(self.p)",
    ".sympy.core.numbers.py@@Integer.__index__": "def __index__(self):\n    return self.p",
    ".sympy.ntheory.generate.py@@Sieve.extend": "def extend(self, n):\n    n = int(n)\n    if n <= self._list[-1]:\n        return\n    maxbase = int(n ** 0.5) + 1\n    self.extend(maxbase)\n    begin = self._list[-1] + 1\n    newsieve = _arange(begin, n + 1)\n    for p in self.primerange(maxbase):\n        startindex = -begin % p\n        for i in range(startindex, len(newsieve), p):\n            newsieve[i] = 0\n    self._list += _array('l', [x for x in newsieve if x])",
    ".sympy.ntheory.generate.py@@Sieve.search": "def search(self, n):\n    from sympy.functions.elementary.integers import ceiling\n    test = as_int(ceiling(n))\n    n = as_int(n)\n    if n < 2:\n        raise ValueError('n should be >= 2 but got: %s' % n)\n    if n > self._list[-1]:\n        self.extend(n)\n    b = bisect(self._list, n)\n    if self._list[b - 1] == test:\n        return (b, b)\n    else:\n        return (b, b + 1)",
    ".sympy.ntheory.generate.py@@nextprime": "def nextprime(n, ith=1):\n    n = int(n)\n    i = as_int(ith)\n    if i > 1:\n        pr = n\n        j = 1\n        while 1:\n            pr = nextprime(pr)\n            j += 1\n            if j > i:\n                break\n        return pr\n    if n < 2:\n        return 2\n    if n < 7:\n        return {2: 3, 3: 5, 4: 5, 5: 7, 6: 7}[n]\n    if n <= sieve._list[-2]:\n        l, u = sieve.search(n)\n        if l == u:\n            return sieve[u + 1]\n        else:\n            return sieve[u]\n    nn = 6 * (n // 6)\n    if nn == n:\n        n += 1\n        if isprime(n):\n            return n\n        n += 4\n    elif n - nn == 5:\n        n += 2\n        if isprime(n):\n            return n\n        n += 4\n    else:\n        n = nn + 5\n    while 1:\n        if isprime(n):\n            return n\n        n += 2\n        if isprime(n):\n            return n\n        n += 4",
    ".sympy.ntheory.factor_.py@@multiplicity": "def multiplicity(p, n):\n    from sympy.functions.combinatorial.factorials import factorial\n    try:\n        p, n = (as_int(p), as_int(n))\n    except ValueError:\n        if all((isinstance(i, (SYMPY_INTS, Rational)) for i in (p, n))):\n            p = Rational(p)\n            n = Rational(n)\n            if p.q == 1:\n                if n.p == 1:\n                    return -multiplicity(p.p, n.q)\n                return multiplicity(p.p, n.p) - multiplicity(p.p, n.q)\n            elif p.p == 1:\n                return multiplicity(p.q, n.q)\n            else:\n                like = min(multiplicity(p.p, n.p), multiplicity(p.q, n.q))\n                cross = min(multiplicity(p.q, n.p), multiplicity(p.p, n.q))\n                return like - cross\n        elif isinstance(p, (SYMPY_INTS, Integer)) and isinstance(n, factorial) and isinstance(n.args[0], Integer) and (n.args[0] >= 0):\n            return multiplicity_in_factorial(p, n.args[0])\n        raise ValueError('expecting ints or fractions, got %s and %s' % (p, n))\n    if n == 0:\n        raise ValueError('no such integer exists: multiplicity of %s is not-defined' % n)\n    if p == 2:\n        return trailing(n)\n    if p < 2:\n        raise ValueError('p must be an integer, 2 or larger, but got %s' % p)\n    if p == n:\n        return 1\n    m = 0\n    n, rem = divmod(n, p)\n    while not rem:\n        m += 1\n        if m > 5:\n            e = 2\n            while 1:\n                ppow = p ** e\n                if ppow < n:\n                    nnew, rem = divmod(n, ppow)\n                    if not rem:\n                        m += e\n                        e *= 2\n                        n = nnew\n                        continue\n                return m + multiplicity(p, n)\n        n, rem = divmod(n, p)\n    return m",
    ".sympy.core.numbers.py@@Rational.factors": "def factors(self, limit=None, use_trial=True, use_rho=False, use_pm1=False, verbose=False, visual=False):\n    from sympy.ntheory import factorrat\n    return factorrat(self, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()",
    ".sympy.ntheory.factor_.py@@factorrat": "def factorrat(rat, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False):\n    from collections import defaultdict\n    if multiple:\n        fac = factorrat(rat, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)\n        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S.One / p] * -fac[p] for p, _ in sorted(fac.items(), key=lambda elem: elem[0] if elem[1] > 0 else 1 / elem[0])), [])\n        return factorlist\n    f = factorint(rat.p, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()\n    f = defaultdict(int, f)\n    for p, e in factorint(rat.q, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).items():\n        f[p] += -e\n    if len(f) > 1 and 1 in f:\n        del f[1]\n    if not visual:\n        return dict(f)\n    else:\n        if -1 in f:\n            f.pop(-1)\n            args = [S.NegativeOne]\n        else:\n            args = []\n        args.extend([Pow(*i, evaluate=False) for i in sorted(f.items())])\n        return Mul(*args, evaluate=False)",
    ".sympy.ntheory.factor_.py@@factorint": "def factorint(n, limit=None, use_trial=True, use_rho=True, use_pm1=True, use_ecm=True, verbose=False, visual=None, multiple=False):\n    if isinstance(n, Dict):\n        n = dict(n)\n    if multiple:\n        fac = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)\n        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S.One / p] * -fac[p] for p in sorted(fac)), [])\n        return factorlist\n    factordict = {}\n    if visual and (not isinstance(n, Mul)) and (not isinstance(n, dict)):\n        factordict = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n    elif isinstance(n, Mul):\n        factordict = {int(k): int(v) for k, v in n.as_powers_dict().items()}\n    elif isinstance(n, dict):\n        factordict = n\n    if factordict and (isinstance(n, Mul) or isinstance(n, dict)):\n        for key in list(factordict.keys()):\n            if isprime(key):\n                continue\n            e = factordict.pop(key)\n            d = factorint(key, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n            for k, v in d.items():\n                if k in factordict:\n                    factordict[k] += v * e\n                else:\n                    factordict[k] = v * e\n    if visual or (type(n) is dict and visual is not True and (visual is not False)):\n        if factordict == {}:\n            return S.One\n        if -1 in factordict:\n            factordict.pop(-1)\n            args = [S.NegativeOne]\n        else:\n            args = []\n        args.extend([Pow(*i, evaluate=False) for i in sorted(factordict.items())])\n        return Mul(*args, evaluate=False)\n    elif isinstance(n, dict) or isinstance(n, Mul):\n        return factordict\n    assert use_trial or use_rho or use_pm1 or use_ecm\n    from sympy.functions.combinatorial.factorials import factorial\n    if isinstance(n, factorial):\n        x = as_int(n.args[0])\n        if x >= 20:\n            factors = {}\n            m = 2\n            for p in sieve.primerange(2, x + 1):\n                if m > 1:\n                    m, q = (0, x // p)\n                    while q != 0:\n                        m += q\n                        q //= p\n                factors[p] = m\n            if factors and verbose:\n                for k in sorted(factors):\n                    print(factor_msg % (k, factors[k]))\n            if verbose:\n                print(complete_msg)\n            return factors\n        else:\n            n = n.func(x)\n    n = as_int(n)\n    if limit:\n        limit = int(limit)\n        use_ecm = False\n    if n < 0:\n        factors = factorint(-n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n        factors[-1] = 1\n        return factors\n    if limit and limit < 2:\n        if n == 1:\n            return {}\n        return {n: 1}\n    elif n < 10:\n        return [{0: 1}, {}, {2: 1}, {3: 1}, {2: 2}, {5: 1}, {2: 1, 3: 1}, {7: 1}, {2: 3}, {3: 2}][n]\n    factors = {}\n    if verbose:\n        sn = str(n)\n        if len(sn) > 50:\n            print('Factoring %s' % sn[:5] + '..(%i other digits)..' % (len(sn) - 10) + sn[-5:])\n        else:\n            print('Factoring', n)\n    if use_trial:\n        small = 2 ** 15\n        fail_max = 600\n        small = min(small, limit or small)\n        if verbose:\n            print(trial_int_msg % (2, small, fail_max))\n        n, next_p = _factorint_small(factors, n, small, fail_max)\n    else:\n        next_p = 2\n    if factors and verbose:\n        for k in sorted(factors):\n            print(factor_msg % (k, factors[k]))\n    if next_p == 0:\n        if n > 1:\n            factors[int(n)] = 1\n        if verbose:\n            print(complete_msg)\n        return factors\n    try:\n        if limit and next_p > limit:\n            if verbose:\n                print('Exceeded limit:', limit)\n            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n            if n > 1:\n                factors[int(n)] = 1\n            return factors\n        else:\n            sqrt_n = integer_nthroot(n, 2)[0]\n            a = sqrt_n + 1\n            a2 = a ** 2\n            b2 = a2 - n\n            for i in range(3):\n                b, fermat = integer_nthroot(b2, 2)\n                if fermat:\n                    break\n                b2 += 2 * a + 1\n                a += 1\n            if fermat:\n                if verbose:\n                    print(fermat_msg)\n                if limit:\n                    limit -= 1\n                for r in [a - b, a + b]:\n                    facs = factorint(r, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)\n                    for k, v in facs.items():\n                        factors[k] = factors.get(k, 0) + v\n                raise StopIteration\n            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n    except StopIteration:\n        if verbose:\n            print(complete_msg)\n        return factors\n    low, high = (next_p, 2 * next_p)\n    limit = limit or sqrt_n\n    limit += 1\n    iteration = 0\n    while 1:\n        try:\n            high_ = high\n            if limit < high_:\n                high_ = limit\n            if use_trial:\n                if verbose:\n                    print(trial_msg % (low, high_))\n                ps = sieve.primerange(low, high_)\n                n, found_trial = _trial(factors, n, ps, verbose)\n                if found_trial:\n                    _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n            else:\n                found_trial = False\n            if high > limit:\n                if verbose:\n                    print('Exceeded limit:', limit)\n                if n > 1:\n                    factors[int(n)] = 1\n                raise StopIteration\n            if not found_trial:\n                if use_pm1 or use_rho:\n                    high_root = max(int(math.log(high_ ** 0.7)), low, 3)\n                    if use_pm1:\n                        if verbose:\n                            print(pm1_msg % (high_root, high_))\n                        c = pollard_pm1(n, B=high_root, seed=high_)\n                        if c:\n                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, use_ecm=use_ecm, verbose=verbose)\n                            n, _ = _trial(factors, n, ps, verbose=False)\n                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n                    if use_rho:\n                        max_steps = high_root\n                        if verbose:\n                            print(rho_msg % (1, max_steps, high_))\n                        c = pollard_rho(n, retries=1, max_steps=max_steps, seed=high_)\n                        if c:\n                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, use_ecm=use_ecm, verbose=verbose)\n                            n, _ = _trial(factors, n, ps, verbose=False)\n                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n        except StopIteration:\n            if verbose:\n                print(complete_msg)\n            return factors\n        iteration += 1\n        if use_ecm and iteration >= 3 and (len(str(n)) >= 25):\n            break\n        low, high = (high, high * 2)\n    B1 = 10000\n    B2 = 100 * B1\n    num_curves = 50\n    while 1:\n        if verbose:\n            print(ecm_msg % (B1, B2, num_curves))\n        while 1:\n            try:\n                factor = _ecm_one_factor(n, B1, B2, num_curves)\n                ps = factorint(factor, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, use_ecm=use_ecm, verbose=verbose)\n                n, _ = _trial(factors, n, ps, verbose=False)\n                _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n            except ValueError:\n                break\n            except StopIteration:\n                if verbose:\n                    print(complete_msg)\n                return factors\n        B1 *= 5\n        B2 = 100 * B1\n        num_curves *= 4",
    ".sympy.core.expr.py@@Expr.is_number": "def is_number(self):\n    return all((obj.is_number for obj in self.args))",
    ".sympy.core.expr.py@@Expr.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n        if not isinstance(other, Expr):\n            return False\n    except (SympifyError, SyntaxError):\n        return False\n    if not (self.is_Number and other.is_Number) and type(self) != type(other):\n        return False\n    a, b = (self._hashable_content(), other._hashable_content())\n    if a != b:\n        return False\n    for a, b in zip(a, b):\n        if not isinstance(a, Expr):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    ".sympy.core.mul.py@@Mul._eval_is_zero": "def _eval_is_zero(self):\n    zero = infinite = False\n    for a in self.args:\n        z = a.is_zero\n        if z:\n            if infinite:\n                return\n            zero = True\n        else:\n            if not a.is_finite:\n                if zero:\n                    return\n                infinite = True\n            if zero is False and z is None:\n                zero = None\n    return zero",
    ".sympy.core.assumptions.py@@StdFactKB.generator": "def generator(self):\n    return self._generator.copy()",
    ".sympy.core.numbers.py@@Float._eval_is_integer": "def _eval_is_integer(self):\n    return self._mpf_ == fzero"
}