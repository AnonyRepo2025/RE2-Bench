{
    ".django.db.utils.py@@ConnectionRouter._route_db": "def _route_db(self, model, **hints):\n    chosen_db = None\n    for router in self.routers:\n        try:\n            method = getattr(router, action)\n        except AttributeError:\n            pass\n        else:\n            chosen_db = method(model, **hints)\n            if chosen_db:\n                return chosen_db\n    instance = hints.get('instance')\n    if instance is not None and instance._state.db:\n        return instance._state.db\n    return DEFAULT_DB_ALIAS",
    ".django.db.models.deletion.py@@Collector.__init__": "def __init__(self, using, origin=None):\n    self.using = using\n    self.origin = origin\n    self.data = defaultdict(set)\n    self.field_updates = defaultdict(partial(defaultdict, set))\n    self.restricted_objects = defaultdict(partial(defaultdict, set))\n    self.fast_deletes = []\n    self.dependencies = defaultdict(set)",
    ".django.db.models.deletion.py@@Collector.collect": "def collect(self, objs, source=None, nullable=False, collect_related=True, source_attr=None, reverse_dependency=False, keep_parents=False, fail_on_restricted=True):\n    if self.can_fast_delete(objs):\n        self.fast_deletes.append(objs)\n        return\n    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)\n    if not new_objs:\n        return\n    model = new_objs[0].__class__\n    if not keep_parents:\n        concrete_model = model._meta.concrete_model\n        for ptr in concrete_model._meta.parents.values():\n            if ptr:\n                parent_objs = [getattr(obj, ptr.name) for obj in new_objs]\n                self.collect(parent_objs, source=model, source_attr=ptr.remote_field.related_name, collect_related=False, reverse_dependency=True, fail_on_restricted=False)\n    if not collect_related:\n        return\n    if keep_parents:\n        parents = set(model._meta.get_parent_list())\n    model_fast_deletes = defaultdict(list)\n    protected_objects = defaultdict(list)\n    for related in get_candidate_relations_to_delete(model._meta):\n        if keep_parents and related.model in parents:\n            continue\n        field = related.field\n        if field.remote_field.on_delete == DO_NOTHING:\n            continue\n        related_model = related.related_model\n        if self.can_fast_delete(related_model, from_field=field):\n            model_fast_deletes[related_model].append(field)\n            continue\n        batches = self.get_del_batches(new_objs, [field])\n        for batch in batches:\n            sub_objs = self.related_objects(related_model, [field], batch)\n            if not (sub_objs.query.select_related or self._has_signal_listeners(related_model)):\n                referenced_fields = set(chain.from_iterable(((rf.attname for rf in rel.field.foreign_related_fields) for rel in get_candidate_relations_to_delete(related_model._meta))))\n                sub_objs = sub_objs.only(*tuple(referenced_fields))\n            if sub_objs:\n                try:\n                    field.remote_field.on_delete(self, field, sub_objs, self.using)\n                except ProtectedError as error:\n                    key = \"'%s.%s'\" % (field.model.__name__, field.name)\n                    protected_objects[key] += error.protected_objects\n    if protected_objects:\n        raise ProtectedError('Cannot delete some instances of model %r because they are referenced through protected foreign keys: %s.' % (model.__name__, ', '.join(protected_objects)), set(chain.from_iterable(protected_objects.values())))\n    for related_model, related_fields in model_fast_deletes.items():\n        batches = self.get_del_batches(new_objs, related_fields)\n        for batch in batches:\n            sub_objs = self.related_objects(related_model, related_fields, batch)\n            self.fast_deletes.append(sub_objs)\n    for field in model._meta.private_fields:\n        if hasattr(field, 'bulk_related_objects'):\n            sub_objs = field.bulk_related_objects(new_objs, self.using)\n            self.collect(sub_objs, source=model, nullable=True, fail_on_restricted=False)\n    if fail_on_restricted:\n        for related_model, instances in self.data.items():\n            self.clear_restricted_objects_from_set(related_model, instances)\n        for qs in self.fast_deletes:\n            self.clear_restricted_objects_from_queryset(qs.model, qs)\n        if self.restricted_objects.values():\n            restricted_objects = defaultdict(list)\n            for related_model, fields in self.restricted_objects.items():\n                for field, objs in fields.items():\n                    if objs:\n                        key = \"'%s.%s'\" % (related_model.__name__, field.name)\n                        restricted_objects[key] += objs\n            if restricted_objects:\n                raise RestrictedError('Cannot delete some instances of model %r because they are referenced through restricted foreign keys: %s.' % (model.__name__, ', '.join(restricted_objects)), set(chain.from_iterable(restricted_objects.values())))",
    ".django.db.models.deletion.py@@Collector.can_fast_delete": "def can_fast_delete(self, objs, from_field=None):\n    if from_field and from_field.remote_field.on_delete is not CASCADE:\n        return False\n    if hasattr(objs, '_meta'):\n        model = objs._meta.model\n    elif hasattr(objs, 'model') and hasattr(objs, '_raw_delete'):\n        model = objs.model\n    else:\n        return False\n    if self._has_signal_listeners(model):\n        return False\n    opts = model._meta\n    return all((link == from_field for link in opts.concrete_model._meta.parents.values())) and all((related.field.remote_field.on_delete is DO_NOTHING for related in get_candidate_relations_to_delete(opts))) and (not any((hasattr(field, 'bulk_related_objects') for field in opts.private_fields)))",
    ".django.db.models.deletion.py@@Collector.add": "def add(self, objs, source=None, nullable=False, reverse_dependency=False):\n    if not objs:\n        return []\n    new_objs = []\n    model = objs[0].__class__\n    instances = self.data[model]\n    for obj in objs:\n        if obj not in instances:\n            new_objs.append(obj)\n    instances.update(new_objs)\n    if source is not None and (not nullable):\n        self.add_dependency(source, model, reverse_dependency=reverse_dependency)\n    return new_objs",
    ".django.db.models.deletion.py@@get_candidate_relations_to_delete": "def get_candidate_relations_to_delete(opts):\n    return (f for f in opts.get_fields(include_hidden=True) if f.auto_created and (not f.concrete) and (f.one_to_one or f.one_to_many))",
    ".django.db.models.options.py@@Options.get_fields": "def get_fields(self, include_parents=True, include_hidden=False):\n    if include_parents is False:\n        include_parents = PROXY_PARENTS\n    return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)",
    ".django.db.models.options.py@@Options._get_fields": "def _get_fields(self, forward=True, reverse=True, include_parents=True, include_hidden=False, seen_models=None):\n    if include_parents not in (True, False, PROXY_PARENTS):\n        raise TypeError('Invalid argument for include_parents: %s' % (include_parents,))\n    topmost_call = seen_models is None\n    if topmost_call:\n        seen_models = set()\n    seen_models.add(self.model)\n    cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)\n    try:\n        return self._get_fields_cache[cache_key]\n    except KeyError:\n        pass\n    fields = []\n    if include_parents is not False:\n        for parent in self.parents:\n            if parent in seen_models:\n                continue\n            if parent._meta.concrete_model != self.concrete_model and include_parents == PROXY_PARENTS:\n                continue\n            for obj in parent._meta._get_fields(forward=forward, reverse=reverse, include_parents=include_parents, include_hidden=include_hidden, seen_models=seen_models):\n                if not getattr(obj, 'parent_link', False) or obj.model == self.concrete_model:\n                    fields.append(obj)\n    if reverse and (not self.proxy):\n        all_fields = self._relation_tree\n        for field in all_fields:\n            if include_hidden or not field.remote_field.hidden:\n                fields.append(field.remote_field)\n    if forward:\n        fields += self.local_fields\n        fields += self.local_many_to_many\n        if topmost_call:\n            fields += self.private_fields\n    fields = make_immutable_fields_list('get_fields()', fields)\n    self._get_fields_cache[cache_key] = fields\n    return fields",
    ".django.db.models.options.py@@make_immutable_fields_list": "def make_immutable_fields_list(name, data):\n    return ImmutableList(data, warning=IMMUTABLE_WARNING % name)",
    ".django.utils.datastructures.py@@ImmutableList.__new__": "def __new__(cls, *args, warning='ImmutableList object is immutable.', **kwargs):\n    self = tuple.__new__(cls, *args, **kwargs)\n    self.warning = warning\n    return self",
    ".django.db.models.deletion.py@@Collector.clear_restricted_objects_from_set": "def clear_restricted_objects_from_set(self, model, objs):\n    if model in self.restricted_objects:\n        self.restricted_objects[model] = {field: items - objs for field, items in self.restricted_objects[model].items()}",
    ".django.utils.functional.py@@cached_property.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    res = instance.__dict__[self.name] = self.func(instance)\n    return res",
    ".django.db.models.fields.reverse_related.py@@ForeignObjectRel.one_to_one": "def one_to_one(self):\n    return self.field.one_to_one",
    ".django.db.models.fields.reverse_related.py@@ForeignObjectRel.one_to_many": "def one_to_many(self):\n    return self.field.many_to_one",
    ".django.db.models.fields.reverse_related.py@@ForeignObjectRel.related_model": "def related_model(self):\n    if not self.field.model:\n        raise AttributeError(\"This property can't be accessed before self.field.contribute_to_class has been called.\")\n    return self.field.model",
    ".django.db.models.deletion.py@@Collector._has_signal_listeners": "def _has_signal_listeners(self, model):\n    return signals.pre_delete.has_listeners(model) or signals.post_delete.has_listeners(model)",
    ".django.dispatch.dispatcher.py@@Signal.has_listeners": "def has_listeners(self, sender=None):\n    return bool(self._live_receivers(sender))",
    ".django.dispatch.dispatcher.py@@Signal._live_receivers": "def _live_receivers(self, sender):\n    receivers = None\n    if self.use_caching and (not self._dead_receivers):\n        receivers = self.sender_receivers_cache.get(sender)\n        if receivers is NO_RECEIVERS:\n            return []\n    if receivers is None:\n        with self.lock:\n            self._clear_dead_receivers()\n            senderkey = _make_id(sender)\n            receivers = []\n            for (receiverkey, r_senderkey), receiver in self.receivers:\n                if r_senderkey == NONE_ID or r_senderkey == senderkey:\n                    receivers.append(receiver)\n            if self.use_caching:\n                if not receivers:\n                    self.sender_receivers_cache[sender] = NO_RECEIVERS\n                else:\n                    self.sender_receivers_cache[sender] = receivers\n    non_weak_receivers = []\n    for receiver in receivers:\n        if isinstance(receiver, weakref.ReferenceType):\n            receiver = receiver()\n            if receiver is not None:\n                non_weak_receivers.append(receiver)\n        else:\n            non_weak_receivers.append(receiver)\n    return non_weak_receivers",
    ".django.dispatch.dispatcher.py@@Signal._clear_dead_receivers": "def _clear_dead_receivers(self):\n    if self._dead_receivers:\n        self._dead_receivers = False\n        self.receivers = [r for r in self.receivers if not (isinstance(r[1], weakref.ReferenceType) and r[1]() is None)]",
    ".django.dispatch.dispatcher.py@@_make_id": "def _make_id(target):\n    if hasattr(target, '__func__'):\n        return (id(target.__self__), id(target.__func__))\n    return id(target)",
    ".django.db.models.deletion.py@@Collector.get_del_batches": "def get_del_batches(self, objs, fields):\n    field_names = [field.name for field in fields]\n    conn_batch_size = max(connections[self.using].ops.bulk_batch_size(field_names, objs), 1)\n    if len(objs) > conn_batch_size:\n        return [objs[i:i + conn_batch_size] for i in range(0, len(objs), conn_batch_size)]\n    else:\n        return [objs]",
    ".django.utils.connection.py@@BaseConnectionHandler.__getitem__": "def __getitem__(self, alias):\n    try:\n        return getattr(self._connections, alias)\n    except AttributeError:\n        if alias not in self.settings:\n            raise self.exception_class(f\"The connection '{alias}' doesn't exist.\")\n    conn = self.create_connection(alias)\n    setattr(self._connections, alias, conn)\n    return conn",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.bulk_batch_size": "def bulk_batch_size(self, fields, objs):\n    if len(fields) == 1:\n        return 500\n    elif len(fields) > 1:\n        return self.connection.features.max_query_params // len(fields)\n    else:\n        return len(objs)",
    ".django.db.models.deletion.py@@Collector.related_objects": "def related_objects(self, related_model, related_fields, objs):\n    predicate = query_utils.Q(*((f'{related_field.name}__in', objs) for related_field in related_fields), _connector=query_utils.Q.OR)\n    return related_model._base_manager.using(self.using).filter(predicate)",
    ".django.db.models.query_utils.py@@Q.__init__": "def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n    super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)",
    ".django.utils.tree.py@@Node.__init__": "def __init__(self, children=None, connector=None, negated=False):\n    self.children = children[:] if children else []\n    self.connector = connector or self.default\n    self.negated = negated",
    ".django.db.models.base.py@@ModelBase._base_manager": "def _base_manager(cls):\n    return cls._meta.base_manager",
    ".django.db.models.options.py@@Options.base_manager": "def base_manager(self):\n    base_manager_name = self.base_manager_name\n    if not base_manager_name:\n        for parent in self.model.mro()[1:]:\n            if hasattr(parent, '_meta'):\n                if parent._base_manager.name != '_base_manager':\n                    base_manager_name = parent._base_manager.name\n                break\n    if base_manager_name:\n        try:\n            return self.managers_map[base_manager_name]\n        except KeyError:\n            raise ValueError('%s has no manager named %r' % (self.object_name, base_manager_name))\n    manager = Manager()\n    manager.name = '_base_manager'\n    manager.model = self.model\n    manager.auto_created = True\n    return manager",
    ".django.db.models.manager.py@@BaseManager.__new__": "def __new__(cls, *args, **kwargs):\n    obj = super().__new__(cls)\n    obj._constructor_args = (args, kwargs)\n    return obj",
    ".django.db.models.manager.py@@BaseManager.__init__": "def __init__(self):\n    super().__init__()\n    self._set_creation_counter()\n    self.model = None\n    self.name = None\n    self._db = None\n    self._hints = {}",
    ".django.db.models.manager.py@@BaseManager._set_creation_counter": "def _set_creation_counter(self):\n    self.creation_counter = BaseManager.creation_counter\n    BaseManager.creation_counter += 1",
    ".django.db.models.manager.py@@BaseManager.manager_method": "def manager_method(self, *args, **kwargs):\n    return getattr(self.get_queryset(), name)(*args, **kwargs)",
    ".django.db.models.manager.py@@BaseManager.get_queryset": "def get_queryset(self):\n    return self._queryset_class(model=self.model, using=self._db, hints=self._hints)",
    ".django.db.models.query.py@@QuerySet.__init__": "def __init__(self, model=None, query=None, using=None, hints=None):\n    self.model = model\n    self._db = using\n    self._hints = hints or {}\n    self._query = query or sql.Query(self.model)\n    self._result_cache = None\n    self._sticky_filter = False\n    self._for_write = False\n    self._prefetch_related_lookups = ()\n    self._prefetch_done = False\n    self._known_related_objects = {}\n    self._iterable_class = ModelIterable\n    self._fields = None\n    self._defer_next_filter = False\n    self._deferred_filter = None",
    ".django.db.models.sql.query.py@@Query.__init__": "def __init__(self, model, alias_cols=True):\n    self.model = model\n    self.alias_refcount = {}\n    self.alias_map = {}\n    self.alias_cols = alias_cols\n    self.external_aliases = {}\n    self.table_map = {}\n    self.default_cols = True\n    self.default_ordering = True\n    self.standard_ordering = True\n    self.used_aliases = set()\n    self.filter_is_sticky = False\n    self.subquery = False\n    self.select = ()\n    self.where = WhereNode()\n    self.group_by = None\n    self.order_by = ()\n    self.low_mark, self.high_mark = (0, None)\n    self.distinct = False\n    self.distinct_fields = ()\n    self.select_for_update = False\n    self.select_for_update_nowait = False\n    self.select_for_update_skip_locked = False\n    self.select_for_update_of = ()\n    self.select_for_no_key_update = False\n    self.select_related = False\n    self.max_depth = 5\n    self.values_select = ()\n    self.annotations = {}\n    self.annotation_select_mask = None\n    self._annotation_select_cache = None\n    self.combinator = None\n    self.combinator_all = False\n    self.combined_queries = ()\n    self.extra = {}\n    self.extra_select_mask = None\n    self._extra_select_cache = None\n    self.extra_tables = ()\n    self.extra_order_by = ()\n    self.deferred_loading = (frozenset(), True)\n    self._filtered_relations = {}\n    self.explain_info = None",
    ".django.db.models.query.py@@QuerySet.using": "def using(self, alias):\n    clone = self._chain()\n    clone._db = alias\n    return clone",
    ".django.db.models.query.py@@QuerySet._chain": "def _chain(self):\n    obj = self._clone()\n    if obj._sticky_filter:\n        obj.query.filter_is_sticky = True\n        obj._sticky_filter = False\n    return obj",
    ".django.db.models.query.py@@QuerySet._clone": "def _clone(self):\n    c = self.__class__(model=self.model, query=self.query.chain(), using=self._db, hints=self._hints)\n    c._sticky_filter = self._sticky_filter\n    c._for_write = self._for_write\n    c._prefetch_related_lookups = self._prefetch_related_lookups[:]\n    c._known_related_objects = self._known_related_objects\n    c._iterable_class = self._iterable_class\n    c._fields = self._fields\n    return c",
    ".django.db.models.query.py@@QuerySet.query": "def query(self):\n    if self._deferred_filter:\n        negate, args, kwargs = self._deferred_filter\n        self._filter_or_exclude_inplace(negate, args, kwargs)\n        self._deferred_filter = None\n    return self._query",
    ".django.db.models.sql.query.py@@Query.chain": "def chain(self, klass=None):\n    obj = self.clone()\n    if klass and obj.__class__ != klass:\n        obj.__class__ = klass\n    if not obj.filter_is_sticky:\n        obj.used_aliases = set()\n    obj.filter_is_sticky = False\n    if hasattr(obj, '_setup_query'):\n        obj._setup_query()\n    return obj",
    ".django.db.models.sql.query.py@@Query.clone": "def clone(self):\n    obj = Empty()\n    obj.__class__ = self.__class__\n    obj.__dict__ = self.__dict__.copy()\n    obj.alias_refcount = self.alias_refcount.copy()\n    obj.alias_map = self.alias_map.copy()\n    obj.external_aliases = self.external_aliases.copy()\n    obj.table_map = self.table_map.copy()\n    obj.where = self.where.clone()\n    obj.annotations = self.annotations.copy()\n    if self.annotation_select_mask is not None:\n        obj.annotation_select_mask = self.annotation_select_mask.copy()\n    if self.combined_queries:\n        obj.combined_queries = tuple([query.clone() for query in self.combined_queries])\n    obj._annotation_select_cache = None\n    obj.extra = self.extra.copy()\n    if self.extra_select_mask is not None:\n        obj.extra_select_mask = self.extra_select_mask.copy()\n    if self._extra_select_cache is not None:\n        obj._extra_select_cache = self._extra_select_cache.copy()\n    if self.select_related is not False:\n        obj.select_related = copy.deepcopy(obj.select_related)\n    if 'subq_aliases' in self.__dict__:\n        obj.subq_aliases = self.subq_aliases.copy()\n    obj.used_aliases = self.used_aliases.copy()\n    obj._filtered_relations = self._filtered_relations.copy()\n    try:\n        del obj.base_table\n    except AttributeError:\n        pass\n    return obj",
    ".django.db.models.sql.where.py@@WhereNode.clone": "def clone(self):\n    clone = self.__class__._new_instance(children=None, connector=self.connector, negated=self.negated)\n    for child in self.children:\n        if hasattr(child, 'clone'):\n            clone.children.append(child.clone())\n        else:\n            clone.children.append(child)\n    return clone",
    ".django.utils.tree.py@@Node._new_instance": "def _new_instance(cls, children=None, connector=None, negated=False):\n    obj = Node(children, connector, negated)\n    obj.__class__ = cls\n    return obj",
    ".django.db.models.query.py@@QuerySet.filter": "def filter(self, *args, **kwargs):\n    self._not_support_combined_queries('filter')\n    return self._filter_or_exclude(False, args, kwargs)",
    ".django.db.models.query.py@@QuerySet._not_support_combined_queries": "def _not_support_combined_queries(self, operation_name):\n    if self.query.combinator:\n        raise NotSupportedError('Calling QuerySet.%s() after %s() is not supported.' % (operation_name, self.query.combinator))",
    ".django.db.models.query.py@@QuerySet._filter_or_exclude": "def _filter_or_exclude(self, negate, args, kwargs):\n    if (args or kwargs) and self.query.is_sliced:\n        raise TypeError('Cannot filter a query once a slice has been taken.')\n    clone = self._chain()\n    if self._defer_next_filter:\n        self._defer_next_filter = False\n        clone._deferred_filter = (negate, args, kwargs)\n    else:\n        clone._filter_or_exclude_inplace(negate, args, kwargs)\n    return clone",
    ".django.db.models.sql.query.py@@Query.is_sliced": "def is_sliced(self):\n    return self.low_mark != 0 or self.high_mark is not None",
    ".django.db.models.query.py@@QuerySet._filter_or_exclude_inplace": "def _filter_or_exclude_inplace(self, negate, args, kwargs):\n    if negate:\n        self._query.add_q(~Q(*args, **kwargs))\n    else:\n        self._query.add_q(Q(*args, **kwargs))",
    ".django.db.models.sql.query.py@@Query.add_q": "def add_q(self, q_object):\n    existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}\n    clause, _ = self._add_q(q_object, self.used_aliases)\n    if clause:\n        self.where.add(clause, AND)\n    self.demote_joins(existing_inner)",
    ".django.db.models.sql.query.py@@Query._add_q": "def _add_q(self, q_object, used_aliases, branch_negated=False, current_negated=False, allow_joins=True, split_subq=True, check_filterable=True):\n    connector = q_object.connector\n    current_negated = current_negated ^ q_object.negated\n    branch_negated = branch_negated or q_object.negated\n    target_clause = WhereNode(connector=connector, negated=q_object.negated)\n    joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)\n    for child in q_object.children:\n        child_clause, needed_inner = self.build_filter(child, can_reuse=used_aliases, branch_negated=branch_negated, current_negated=current_negated, allow_joins=allow_joins, split_subq=split_subq, check_filterable=check_filterable)\n        joinpromoter.add_votes(needed_inner)\n        if child_clause:\n            target_clause.add(child_clause, connector)\n    needed_inner = joinpromoter.update_join_types(self)\n    return (target_clause, needed_inner)",
    ".django.db.models.sql.query.py@@JoinPromoter.__init__": "def __init__(self, connector, num_children, negated):\n    self.connector = connector\n    self.negated = negated\n    if self.negated:\n        if connector == AND:\n            self.effective_connector = OR\n        else:\n            self.effective_connector = AND\n    else:\n        self.effective_connector = self.connector\n    self.num_children = num_children\n    self.votes = Counter()",
    ".django.db.models.sql.query.py@@Query.build_filter": "def build_filter(self, filter_expr, branch_negated=False, current_negated=False, can_reuse=None, allow_joins=True, split_subq=True, check_filterable=True):\n    if isinstance(filter_expr, dict):\n        raise FieldError('Cannot parse keyword query as dict')\n    if isinstance(filter_expr, Q):\n        return self._add_q(filter_expr, branch_negated=branch_negated, current_negated=current_negated, used_aliases=can_reuse, allow_joins=allow_joins, split_subq=split_subq, check_filterable=check_filterable)\n    if hasattr(filter_expr, 'resolve_expression'):\n        if not getattr(filter_expr, 'conditional', False):\n            raise TypeError('Cannot filter against a non-conditional expression.')\n        condition = filter_expr.resolve_expression(self, allow_joins=allow_joins)\n        if not isinstance(condition, Lookup):\n            condition = self.build_lookup(['exact'], condition, True)\n        return (WhereNode([condition], connector=AND), [])\n    arg, value = filter_expr\n    if not arg:\n        raise FieldError('Cannot parse keyword query %r' % arg)\n    lookups, parts, reffed_expression = self.solve_lookup_type(arg)\n    if check_filterable:\n        self.check_filterable(reffed_expression)\n    if not allow_joins and len(parts) > 1:\n        raise FieldError('Joined field references are not permitted in this query')\n    pre_joins = self.alias_refcount.copy()\n    value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n    used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n    if check_filterable:\n        self.check_filterable(value)\n    if reffed_expression:\n        condition = self.build_lookup(lookups, reffed_expression, value)\n        return (WhereNode([condition], connector=AND), [])\n    opts = self.get_meta()\n    alias = self.get_initial_alias()\n    allow_many = not branch_negated or not split_subq\n    try:\n        join_info = self.setup_joins(parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many)\n        if isinstance(value, Iterator):\n            value = list(value)\n        self.check_related_objects(join_info.final_field, value, join_info.opts)\n        self._lookup_joins = join_info.joins\n    except MultiJoin as e:\n        return self.split_exclude(filter_expr, can_reuse, e.names_with_path)\n    used_joins.update(join_info.joins)\n    targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)\n    if can_reuse is not None:\n        can_reuse.update(join_list)\n    if join_info.final_field.is_relation:\n        num_lookups = len(lookups)\n        if num_lookups > 1:\n            raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))\n        if len(targets) == 1:\n            col = self._get_col(targets[0], join_info.final_field, alias)\n        else:\n            col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)\n    else:\n        col = self._get_col(targets[0], join_info.final_field, alias)\n    condition = self.build_lookup(lookups, col, value)\n    lookup_type = condition.lookup_name\n    clause = WhereNode([condition], connector=AND)\n    require_outer = lookup_type == 'isnull' and condition.rhs is True and (not current_negated)\n    if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and (condition.rhs is not None):\n        require_outer = True\n        if lookup_type != 'isnull':\n            if self.is_nullable(targets[0]) or self.alias_map[join_list[-1]].join_type == LOUTER:\n                lookup_class = targets[0].get_lookup('isnull')\n                col = self._get_col(targets[0], join_info.targets[0], alias)\n                clause.add(lookup_class(col, False), AND)\n            if isinstance(value, Col) and self.is_nullable(value.target):\n                lookup_class = value.target.get_lookup('isnull')\n                clause.add(lookup_class(value, False), AND)\n    return (clause, used_joins if not require_outer else ())",
    ".django.db.models.sql.query.py@@Query.solve_lookup_type": "def solve_lookup_type(self, lookup):\n    lookup_splitted = lookup.split(LOOKUP_SEP)\n    if self.annotations:\n        expression, expression_lookups = refs_expression(lookup_splitted, self.annotations)\n        if expression:\n            return (expression_lookups, (), expression)\n    _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())\n    field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]\n    if len(lookup_parts) > 1 and (not field_parts):\n        raise FieldError('Invalid lookup \"%s\" for model %s\".' % (lookup, self.get_meta().model.__name__))\n    return (lookup_parts, field_parts, False)",
    ".django.db.models.sql.query.py@@Query.get_meta": "def get_meta(self):\n    return self.model._meta",
    ".django.db.models.sql.query.py@@Query.names_to_path": "def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n    path, names_with_path = ([], [])\n    for pos, name in enumerate(names):\n        cur_names_with_path = (name, [])\n        if name == 'pk':\n            name = opts.pk.name\n        field = None\n        filtered_relation = None\n        try:\n            field = opts.get_field(name)\n        except FieldDoesNotExist:\n            if name in self.annotation_select:\n                field = self.annotation_select[name].output_field\n            elif name in self._filtered_relations and pos == 0:\n                filtered_relation = self._filtered_relations[name]\n                if LOOKUP_SEP in filtered_relation.relation_name:\n                    parts = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    filtered_relation_path, field, _, _ = self.names_to_path(parts, opts, allow_many, fail_on_missing)\n                    path.extend(filtered_relation_path[:-1])\n                else:\n                    field = opts.get_field(filtered_relation.relation_name)\n        if field is not None:\n            if field.is_relation and (not field.related_model):\n                raise FieldError('Field %r does not generate an automatic reverse relation and therefore cannot be used for reverse querying. If it is a GenericForeignKey, consider adding a GenericRelation.' % name)\n            try:\n                model = field.model._meta.concrete_model\n            except AttributeError:\n                model = None\n        else:\n            pos -= 1\n            if pos == -1 or fail_on_missing:\n                available = sorted([*get_field_names_from_opts(opts), *self.annotation_select, *self._filtered_relations])\n                raise FieldError(\"Cannot resolve keyword '%s' into field. Choices are: %s\" % (name, ', '.join(available)))\n            break\n        if model is not opts.model:\n            path_to_parent = opts.get_path_to_parent(model)\n            if path_to_parent:\n                path.extend(path_to_parent)\n                cur_names_with_path[1].extend(path_to_parent)\n                opts = path_to_parent[-1].to_opts\n        if hasattr(field, 'path_infos'):\n            if filtered_relation:\n                pathinfos = field.get_path_info(filtered_relation)\n            else:\n                pathinfos = field.path_infos\n            if not allow_many:\n                for inner_pos, p in enumerate(pathinfos):\n                    if p.m2m:\n                        cur_names_with_path[1].extend(pathinfos[0:inner_pos + 1])\n                        names_with_path.append(cur_names_with_path)\n                        raise MultiJoin(pos + 1, names_with_path)\n            last = pathinfos[-1]\n            path.extend(pathinfos)\n            final_field = last.join_field\n            opts = last.to_opts\n            targets = last.target_fields\n            cur_names_with_path[1].extend(pathinfos)\n            names_with_path.append(cur_names_with_path)\n        else:\n            final_field = field\n            targets = (field,)\n            if fail_on_missing and pos + 1 != len(names):\n                raise FieldError(\"Cannot resolve keyword %r into field. Join on '%s' not permitted.\" % (names[pos + 1], name))\n            break\n    return (path, final_field, targets, names[pos + 1:])",
    ".django.db.models.options.py@@Options.get_field": "def get_field(self, field_name):\n    try:\n        return self._forward_fields_map[field_name]\n    except KeyError:\n        if not self.apps.models_ready:\n            raise FieldDoesNotExist(\"%s has no field named '%s'. The app cache isn't ready yet, so if this is an auto-created related field, it won't be available yet.\" % (self.object_name, field_name))\n    try:\n        return self.fields_map[field_name]\n    except KeyError:\n        raise FieldDoesNotExist(\"%s has no field named '%s'\" % (self.object_name, field_name))",
    ".django.db.models.fields.related.py@@ForeignObject.path_infos": "def path_infos(self):\n    return self.get_path_info()",
    ".django.db.models.fields.related.py@@ForeignObject.get_path_info": "def get_path_info(self, filtered_relation=None):\n    opts = self.remote_field.model._meta\n    from_opts = self.model._meta\n    return [PathInfo(from_opts=from_opts, to_opts=opts, target_fields=self.foreign_related_fields, join_field=self, m2m=False, direct=True, filtered_relation=filtered_relation)]",
    ".django.db.models.options.py@@Options.fields_map": "def fields_map(self):\n    res = {}\n    fields = self._get_fields(forward=False, include_hidden=True)\n    for field in fields:\n        res[field.name] = field\n        try:\n            res[field.attname] = field\n        except AttributeError:\n            pass\n    return res",
    ".django.db.models.fields.reverse_related.py@@ForeignObjectRel.name": "def name(self):\n    return self.field.related_query_name()",
    ".django.db.models.fields.related.py@@RelatedField.related_query_name": "def related_query_name(self):\n    return self.remote_field.related_query_name or self.remote_field.related_name or self.opts.model_name",
    ".django.db.models.sql.query.py@@Query.annotation_select": "def annotation_select(self):\n    if self._annotation_select_cache is not None:\n        return self._annotation_select_cache\n    elif not self.annotations:\n        return {}\n    elif self.annotation_select_mask is not None:\n        self._annotation_select_cache = {k: v for k, v in self.annotations.items() if k in self.annotation_select_mask}\n        return self._annotation_select_cache\n    else:\n        return self.annotations",
    ".django.db.models.sql.query.py@@Query.check_filterable": "def check_filterable(self, expression):\n    if hasattr(expression, 'resolve_expression') and (not getattr(expression, 'filterable', True)):\n        raise NotSupportedError(expression.__class__.__name__ + ' is disallowed in the filter clause.')\n    if hasattr(expression, 'get_source_expressions'):\n        for expr in expression.get_source_expressions():\n            self.check_filterable(expr)",
    ".django.db.models.sql.query.py@@Query.resolve_lookup_value": "def resolve_lookup_value(self, value, can_reuse, allow_joins):\n    if hasattr(value, 'resolve_expression'):\n        value = value.resolve_expression(self, reuse=can_reuse, allow_joins=allow_joins)\n    elif isinstance(value, (list, tuple)):\n        values = (self.resolve_lookup_value(sub_value, can_reuse, allow_joins) for sub_value in value)\n        type_ = type(value)\n        if hasattr(type_, '_make'):\n            return type_(*values)\n        return type_(values)\n    return value",
    ".django.db.models.sql.query.py@@Query.get_initial_alias": "def get_initial_alias(self):\n    if self.alias_map:\n        alias = self.base_table\n        self.ref_alias(alias)\n    else:\n        alias = self.join(self.base_table_class(self.get_meta().db_table, None))\n    return alias",
    ".django.db.models.sql.datastructures.py@@BaseTable.__init__": "def __init__(self, table_name, alias):\n    self.table_name = table_name\n    self.table_alias = alias",
    ".django.db.models.sql.query.py@@Query.join": "def join(self, join, reuse=None):\n    reuse_aliases = [a for a, j in self.alias_map.items() if (reuse is None or a in reuse) and j.equals(join)]\n    if reuse_aliases:\n        if join.table_alias in reuse_aliases:\n            reuse_alias = join.table_alias\n        else:\n            reuse_alias = reuse_aliases[-1]\n        self.ref_alias(reuse_alias)\n        return reuse_alias\n    alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)\n    if join.join_type:\n        if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n            join_type = LOUTER\n        else:\n            join_type = INNER\n        join.join_type = join_type\n    join.table_alias = alias\n    self.alias_map[alias] = join\n    return alias",
    ".django.db.models.sql.query.py@@Query.table_alias": "def table_alias(self, table_name, create=False, filtered_relation=None):\n    alias_list = self.table_map.get(table_name)\n    if not create and alias_list:\n        alias = alias_list[0]\n        self.alias_refcount[alias] += 1\n        return (alias, False)\n    if alias_list:\n        alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)\n        alias_list.append(alias)\n    else:\n        alias = filtered_relation.alias if filtered_relation is not None else table_name\n        self.table_map[table_name] = [alias]\n    self.alias_refcount[alias] = 1\n    return (alias, True)",
    ".django.db.models.sql.query.py@@Query.setup_joins": "def setup_joins(self, names, opts, alias, can_reuse=None, allow_many=True):\n    joins = [alias]\n\n    def final_transformer(field, alias):\n        if not self.alias_cols:\n            alias = None\n        return field.get_col(alias)\n    last_field_exception = None\n    for pivot in range(len(names), 0, -1):\n        try:\n            path, final_field, targets, rest = self.names_to_path(names[:pivot], opts, allow_many, fail_on_missing=True)\n        except FieldError as exc:\n            if pivot == 1:\n                raise\n            else:\n                last_field_exception = exc\n        else:\n            transforms = names[pivot:]\n            break\n    for name in transforms:\n\n        def transform(field, alias, *, name, previous):\n            try:\n                wrapped = previous(field, alias)\n                return self.try_transform(wrapped, name)\n            except FieldError:\n                if isinstance(final_field, Field) and last_field_exception:\n                    raise last_field_exception\n                else:\n                    raise\n        final_transformer = functools.partial(transform, name=name, previous=final_transformer)\n    for join in path:\n        if join.filtered_relation:\n            filtered_relation = join.filtered_relation.clone()\n            table_alias = filtered_relation.alias\n        else:\n            filtered_relation = None\n            table_alias = None\n        opts = join.to_opts\n        if join.direct:\n            nullable = self.is_nullable(join.join_field)\n        else:\n            nullable = True\n        connection = self.join_class(opts.db_table, alias, table_alias, INNER, join.join_field, nullable, filtered_relation=filtered_relation)\n        reuse = can_reuse if join.m2m else None\n        alias = self.join(connection, reuse=reuse)\n        joins.append(alias)\n        if filtered_relation:\n            filtered_relation.path = joins[:]\n    return JoinInfo(final_field, targets, opts, joins, path, final_transformer)",
    ".django.db.models.sql.query.py@@Query.is_nullable": "def is_nullable(self, field):\n    return field.null or (field.empty_strings_allowed and connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls)",
    ".django.db.models.sql.datastructures.py@@Join.__init__": "def __init__(self, table_name, parent_alias, table_alias, join_type, join_field, nullable, filtered_relation=None):\n    self.table_name = table_name\n    self.parent_alias = parent_alias\n    self.table_alias = table_alias\n    self.join_type = join_type\n    self.join_cols = join_field.get_joining_columns()\n    self.join_field = join_field\n    self.nullable = nullable\n    self.filtered_relation = filtered_relation",
    ".django.db.models.fields.related.py@@ForeignObject.get_joining_columns": "def get_joining_columns(self, reverse_join=False):\n    source = self.reverse_related_fields if reverse_join else self.related_fields\n    return tuple(((lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source))",
    ".django.db.models.sql.datastructures.py@@BaseTable.equals": "def equals(self, other):\n    return self.identity == other.identity",
    ".django.db.models.sql.datastructures.py@@BaseTable.identity": "def identity(self):\n    return (self.__class__, self.table_name, self.table_alias)",
    ".django.db.models.sql.datastructures.py@@Join.identity": "def identity(self):\n    return (self.__class__, self.table_name, self.parent_alias, self.join_field, self.filtered_relation)",
    ".django.db.models.sql.query.py@@Query.check_related_objects": "def check_related_objects(self, field, value, opts):\n    if field.is_relation:\n        if isinstance(value, Query) and (not value.has_select_fields) and (not check_rel_lookup_compatibility(value.model, opts, field)):\n            raise ValueError('Cannot use QuerySet for \"%s\": Use a QuerySet for \"%s\".' % (value.model._meta.object_name, opts.object_name))\n        elif hasattr(value, '_meta'):\n            self.check_query_object_type(value, opts, field)\n        elif hasattr(value, '__iter__'):\n            for v in value:\n                self.check_query_object_type(v, opts, field)",
    ".django.db.models.sql.query.py@@Query.check_query_object_type": "def check_query_object_type(self, value, opts, field):\n    if hasattr(value, '_meta'):\n        if not check_rel_lookup_compatibility(value._meta.model, opts, field):\n            raise ValueError('Cannot query \"%s\": Must be \"%s\" instance.' % (value, opts.object_name))",
    ".django.db.models.query_utils.py@@check_rel_lookup_compatibility": "def check_rel_lookup_compatibility(model, target_opts, field):\n\n    def check(opts):\n        return model._meta.concrete_model == opts.concrete_model or opts.concrete_model in model._meta.get_parent_list() or model in opts.get_parent_list()\n    return check(target_opts) or (getattr(field, 'primary_key', False) and check(field.model._meta))",
    ".django.db.models.query_utils.py@@check": "def check(opts):\n    return model._meta.concrete_model == opts.concrete_model or opts.concrete_model in model._meta.get_parent_list() or model in opts.get_parent_list()",
    ".django.db.models.sql.query.py@@Query.trim_joins": "def trim_joins(self, targets, joins, path):\n    joins = joins[:]\n    for pos, info in enumerate(reversed(path)):\n        if len(joins) == 1 or not info.direct:\n            break\n        if info.filtered_relation:\n            break\n        join_targets = {t.column for t in info.join_field.foreign_related_fields}\n        cur_targets = {t.column for t in targets}\n        if not cur_targets.issubset(join_targets):\n            break\n        targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}\n        targets = tuple((targets_dict[t.column] for t in targets))\n        self.unref_alias(joins.pop())\n    return (targets, joins[-1], joins)",
    ".django.db.models.sql.query.py@@Query.unref_alias": "def unref_alias(self, alias, amount=1):\n    self.alias_refcount[alias] -= amount",
    ".django.db.models.sql.query.py@@Query._get_col": "def _get_col(self, target, field, alias):\n    if not self.alias_cols:\n        alias = None\n    return target.get_col(alias, field)",
    ".django.db.models.fields.related.py@@ForeignKey.get_col": "def get_col(self, alias, output_field=None):\n    if output_field is None:\n        output_field = self.target_field\n        while isinstance(output_field, ForeignKey):\n            output_field = output_field.target_field\n            if output_field is self:\n                raise ValueError('Cannot resolve output_field.')\n    return super().get_col(alias, output_field)",
    ".django.db.models.fields.__init__.py@@Field.get_col": "def get_col(self, alias, output_field=None):\n    if alias == self.model._meta.db_table and (output_field is None or output_field == self):\n        return self.cached_col\n    from django.db.models.expressions import Col\n    return Col(alias, self, output_field)",
    ".django.db.models.fields.__init__.py@@Field.__eq__": "def __eq__(self, other):\n    if isinstance(other, Field):\n        return self.creation_counter == other.creation_counter and getattr(self, 'model', None) == getattr(other, 'model', None)\n    return NotImplemented",
    ".django.db.models.fields.__init__.py@@Field.cached_col": "def cached_col(self):\n    from django.db.models.expressions import Col\n    return Col(self.model._meta.db_table, self)",
    ".django.utils.deconstruct.py@@__new__": "def __new__(cls, *args, **kwargs):\n    obj = super(klass, cls).__new__(cls)\n    obj._constructor_args = (args, kwargs)\n    return obj",
    ".django.db.models.expressions.py@@Col.__init__": "def __init__(self, alias, target, output_field=None):\n    if output_field is None:\n        output_field = target\n    super().__init__(output_field=output_field)\n    self.alias, self.target = (alias, target)",
    ".django.db.models.expressions.py@@BaseExpression.__init__": "def __init__(self, output_field=None):\n    if output_field is not None:\n        self.output_field = output_field",
    ".django.db.models.sql.query.py@@Query.build_lookup": "def build_lookup(self, lookups, lhs, rhs):\n    *transforms, lookup_name = lookups or ['exact']\n    for name in transforms:\n        lhs = self.try_transform(lhs, name)\n    lookup_class = lhs.get_lookup(lookup_name)\n    if not lookup_class:\n        if lhs.field.is_relation:\n            raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))\n        lhs = self.try_transform(lhs, lookup_name)\n        lookup_name = 'exact'\n        lookup_class = lhs.get_lookup(lookup_name)\n        if not lookup_class:\n            return\n    lookup = lookup_class(lhs, rhs)\n    if lookup.rhs is None and (not lookup.can_use_none_as_rhs):\n        if lookup_name not in ('exact', 'iexact'):\n            raise ValueError('Cannot use None as a query value')\n        return lhs.get_lookup('isnull')(lhs, True)\n    if lookup_name == 'exact' and lookup.rhs == '' and connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls:\n        return lhs.get_lookup('isnull')(lhs, True)\n    return lookup",
    ".django.db.models.expressions.py@@BaseExpression.get_lookup": "def get_lookup(self, lookup):\n    return self.output_field.get_lookup(lookup)",
    ".django.db.models.query_utils.py@@RegisterLookupMixin.get_lookup": "def get_lookup(self, lookup_name):\n    from django.db.models.lookups import Lookup\n    found = self._get_lookup(lookup_name)\n    if found is None and hasattr(self, 'output_field'):\n        return self.output_field.get_lookup(lookup_name)\n    if found is not None and (not issubclass(found, Lookup)):\n        return None\n    return found",
    ".django.db.models.query_utils.py@@RegisterLookupMixin._get_lookup": "def _get_lookup(cls, lookup_name):\n    return cls.get_lookups().get(lookup_name, None)",
    ".django.db.models.lookups.py@@Lookup.__init__": "def __init__(self, lhs, rhs):\n    self.lhs, self.rhs = (lhs, rhs)\n    self.rhs = self.get_prep_lookup()\n    self.lhs = self.get_prep_lhs()\n    if hasattr(self.lhs, 'get_bilateral_transforms'):\n        bilateral_transforms = self.lhs.get_bilateral_transforms()\n    else:\n        bilateral_transforms = []\n    if bilateral_transforms:\n        from django.db.models.sql.query import Query\n        if isinstance(rhs, Query):\n            raise NotImplementedError('Bilateral transformations on nested querysets are not implemented.')\n    self.bilateral_transforms = bilateral_transforms",
    ".django.db.models.fields.related_lookups.py@@RelatedIn.get_prep_lookup": "def get_prep_lookup(self):\n    if not isinstance(self.lhs, MultiColSource):\n        if self.rhs_is_direct_value():\n            self.rhs = [get_normalized_value(val, self.lhs)[0] for val in self.rhs]\n            if hasattr(self.lhs.output_field, 'path_infos'):\n                target_field = self.lhs.output_field.path_infos[-1].target_fields[-1]\n                self.rhs = [target_field.get_prep_value(v) for v in self.rhs]\n        elif not getattr(self.rhs, 'has_select_fields', True) and (not getattr(self.lhs.field.target_field, 'primary_key', False)):\n            self.rhs.clear_select_clause()\n            if getattr(self.lhs.output_field, 'primary_key', False) and self.lhs.output_field.model == self.rhs.model:\n                target_field = self.lhs.field.name\n            else:\n                target_field = self.lhs.field.target_field.name\n            self.rhs.add_fields([target_field], True)\n    return super().get_prep_lookup()",
    ".django.db.models.lookups.py@@Lookup.rhs_is_direct_value": "def rhs_is_direct_value(self):\n    return not hasattr(self.rhs, 'as_sql')",
    ".django.db.models.fields.related_lookups.py@@get_normalized_value": "def get_normalized_value(value, lhs):\n    from django.db.models import Model\n    if isinstance(value, Model):\n        value_list = []\n        sources = lhs.output_field.path_infos[-1].target_fields\n        for source in sources:\n            while not isinstance(value, source.model) and source.remote_field:\n                source = source.remote_field.model._meta.get_field(source.remote_field.field_name)\n            try:\n                value_list.append(getattr(value, source.attname))\n            except AttributeError:\n                return (value.pk,)\n        return tuple(value_list)\n    if not isinstance(value, tuple):\n        return (value,)\n    return value",
    ".django.db.models.fields.__init__.py@@IntegerField.get_prep_value": "def get_prep_value(self, value):\n    value = super().get_prep_value(value)\n    if value is None:\n        return None\n    try:\n        return int(value)\n    except (TypeError, ValueError) as e:\n        raise e.__class__(\"Field '%s' expected a number but got %r.\" % (self.name, value)) from e",
    ".django.db.models.fields.__init__.py@@Field.get_prep_value": "def get_prep_value(self, value):\n    if isinstance(value, Promise):\n        value = value._proxy____cast()\n    return value",
    ".django.db.models.lookups.py@@In.get_prep_lookup": "def get_prep_lookup(self):\n    from django.db.models.sql.query import Query\n    if isinstance(self.rhs, Query):\n        self.rhs.clear_ordering(clear_default=True)\n        if not self.rhs.has_select_fields:\n            self.rhs.clear_select_clause()\n            self.rhs.add_fields(['pk'])\n    return super().get_prep_lookup()",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueIterableMixin.get_prep_lookup": "def get_prep_lookup(self):\n    if hasattr(self.rhs, 'resolve_expression'):\n        return self.rhs\n    prepared_values = []\n    for rhs_value in self.rhs:\n        if hasattr(rhs_value, 'resolve_expression'):\n            pass\n        elif self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):\n            rhs_value = self.lhs.output_field.get_prep_value(rhs_value)\n        prepared_values.append(rhs_value)\n    return prepared_values",
    ".django.db.models.fields.related.py@@ForeignKey.get_prep_value": "def get_prep_value(self, value):\n    return self.target_field.get_prep_value(value)",
    ".django.db.models.fields.related.py@@ForeignKey.target_field": "def target_field(self):\n    return self.foreign_related_fields[0]",
    ".django.db.models.lookups.py@@Lookup.get_prep_lhs": "def get_prep_lhs(self):\n    if hasattr(self.lhs, 'resolve_expression'):\n        return self.lhs\n    return Value(self.lhs)",
    ".django.db.models.sql.query.py@@JoinPromoter.add_votes": "def add_votes(self, votes):\n    self.votes.update(votes)",
    ".django.utils.tree.py@@Node.__bool__": "def __bool__(self):\n    return bool(self.children)",
    ".django.utils.tree.py@@Node.add": "def add(self, data, conn_type):\n    if self.connector != conn_type:\n        obj = self._new_instance(self.children, self.connector, self.negated)\n        self.connector = conn_type\n        self.children = [obj, data]\n        return data\n    elif isinstance(data, Node) and (not data.negated) and (data.connector == conn_type or len(data) == 1):\n        self.children.extend(data.children)\n        return self\n    else:\n        self.children.append(data)\n        return data",
    ".django.utils.tree.py@@Node.__len__": "def __len__(self):\n    return len(self.children)",
    ".django.db.models.sql.query.py@@JoinPromoter.update_join_types": "def update_join_types(self, query):\n    to_promote = set()\n    to_demote = set()\n    for table, votes in self.votes.items():\n        if self.effective_connector == 'OR' and votes < self.num_children:\n            to_promote.add(table)\n        if self.effective_connector == 'AND' or (self.effective_connector == 'OR' and votes == self.num_children):\n            to_demote.add(table)\n    query.promote_joins(to_promote)\n    query.demote_joins(to_demote)\n    return to_demote",
    ".django.db.models.sql.query.py@@Query.promote_joins": "def promote_joins(self, aliases):\n    aliases = list(aliases)\n    while aliases:\n        alias = aliases.pop(0)\n        if self.alias_map[alias].join_type is None:\n            continue\n        assert self.alias_map[alias].join_type is not None\n        parent_alias = self.alias_map[alias].parent_alias\n        parent_louter = parent_alias and self.alias_map[parent_alias].join_type == LOUTER\n        already_louter = self.alias_map[alias].join_type == LOUTER\n        if (self.alias_map[alias].nullable or parent_louter) and (not already_louter):\n            self.alias_map[alias] = self.alias_map[alias].promote()\n            aliases.extend((join for join in self.alias_map if self.alias_map[join].parent_alias == alias and join not in aliases))",
    ".django.db.models.sql.query.py@@Query.demote_joins": "def demote_joins(self, aliases):\n    aliases = list(aliases)\n    while aliases:\n        alias = aliases.pop(0)\n        if self.alias_map[alias].join_type == LOUTER:\n            self.alias_map[alias] = self.alias_map[alias].demote()\n            parent_alias = self.alias_map[alias].parent_alias\n            if self.alias_map[parent_alias].join_type == INNER:\n                aliases.append(parent_alias)",
    ".django.db.models.query.py@@QuerySet.__bool__": "def __bool__(self):\n    self._fetch_all()\n    return bool(self._result_cache)",
    ".django.db.models.query.py@@QuerySet._fetch_all": "def _fetch_all(self):\n    if self._result_cache is None:\n        self._result_cache = list(self._iterable_class(self))\n    if self._prefetch_related_lookups and (not self._prefetch_done):\n        self._prefetch_related_objects()",
    ".django.db.models.query.py@@BaseIterable.__init__": "def __init__(self, queryset, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n    self.queryset = queryset\n    self.chunked_fetch = chunked_fetch\n    self.chunk_size = chunk_size",
    ".django.db.models.query.py@@ModelIterable.__iter__": "def __iter__(self):\n    queryset = self.queryset\n    db = queryset.db\n    compiler = queryset.query.get_compiler(using=db)\n    results = compiler.execute_sql(chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size)\n    select, klass_info, annotation_col_map = (compiler.select, compiler.klass_info, compiler.annotation_col_map)\n    model_cls = klass_info['model']\n    select_fields = klass_info['select_fields']\n    model_fields_start, model_fields_end = (select_fields[0], select_fields[-1] + 1)\n    init_list = [f[0].target.attname for f in select[model_fields_start:model_fields_end]]\n    related_populators = get_related_populators(klass_info, select, db)\n    known_related_objects = [(field, related_objs, operator.attrgetter(*[field.attname if from_field == 'self' else queryset.model._meta.get_field(from_field).attname for from_field in field.from_fields])) for field, related_objs in queryset._known_related_objects.items()]\n    for row in compiler.results_iter(results):\n        obj = model_cls.from_db(db, init_list, row[model_fields_start:model_fields_end])\n        for rel_populator in related_populators:\n            rel_populator.populate(row, obj)\n        if annotation_col_map:\n            for attr_name, col_pos in annotation_col_map.items():\n                setattr(obj, attr_name, row[col_pos])\n        for field, rel_objs, rel_getter in known_related_objects:\n            if field.is_cached(obj):\n                continue\n            rel_obj_id = rel_getter(obj)\n            try:\n                rel_obj = rel_objs[rel_obj_id]\n            except KeyError:\n                pass\n            else:\n                setattr(obj, field.name, rel_obj)\n        yield obj",
    ".django.db.models.query.py@@QuerySet.db": "def db(self):\n    if self._for_write:\n        return self._db or router.db_for_write(self.model, **self._hints)\n    return self._db or router.db_for_read(self.model, **self._hints)",
    ".django.db.models.sql.query.py@@Query.get_compiler": "def get_compiler(self, using=None, connection=None, elide_empty=True):\n    if using is None and connection is None:\n        raise ValueError('Need either using or connection')\n    if using:\n        connection = connections[using]\n    return connection.ops.compiler(self.compiler)(self, connection, using, elide_empty)",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.compiler": "def compiler(self, compiler_name):\n    if self._cache is None:\n        self._cache = import_module(self.compiler_module)\n    return getattr(self._cache, compiler_name)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.__init__": "def __init__(self, query, connection, using, elide_empty=True):\n    self.query = query\n    self.connection = connection\n    self.using = using\n    self.elide_empty = elide_empty\n    self.quote_cache = {'*': '*'}\n    self.select = None\n    self.annotation_col_map = None\n    self.klass_info = None\n    self._meta_ordering = None",
    ".django.db.models.sql.compiler.py@@SQLCompiler.execute_sql": "def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n    result_type = result_type or NO_RESULTS\n    try:\n        sql, params = self.as_sql()\n        if not sql:\n            raise EmptyResultSet\n    except EmptyResultSet:\n        if result_type == MULTI:\n            return iter([])\n        else:\n            return\n    if chunked_fetch:\n        cursor = self.connection.chunked_cursor()\n    else:\n        cursor = self.connection.cursor()\n    try:\n        cursor.execute(sql, params)\n    except Exception:\n        cursor.close()\n        raise\n    if result_type == CURSOR:\n        return cursor\n    if result_type == SINGLE:\n        try:\n            val = cursor.fetchone()\n            if val:\n                return val[0:self.col_count]\n            return val\n        finally:\n            cursor.close()\n    if result_type == NO_RESULTS:\n        cursor.close()\n        return\n    result = cursor_iter(cursor, self.connection.features.empty_fetchmany_value, self.col_count if self.has_extra_select else None, chunk_size)\n    if not chunked_fetch or not self.connection.features.can_use_chunked_reads:\n        return list(result)\n    return result",
    ".django.db.models.sql.compiler.py@@SQLCompiler.as_sql": "def as_sql(self, with_limits=True, with_col_aliases=False):\n    refcounts_before = self.query.alias_refcount.copy()\n    try:\n        extra_select, order_by, group_by = self.pre_sql_setup()\n        for_update_part = None\n        with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n        combinator = self.query.combinator\n        features = self.connection.features\n        if combinator:\n            if not getattr(features, 'supports_select_{}'.format(combinator)):\n                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n        else:\n            distinct_fields, distinct_params = self.get_distinct()\n            from_, f_params = self.get_from_clause()\n            try:\n                where, w_params = self.compile(self.where) if self.where is not None else ('', [])\n            except EmptyResultSet:\n                if self.elide_empty:\n                    raise\n                where, w_params = ('0 = 1', [])\n            having, h_params = self.compile(self.having) if self.having is not None else ('', [])\n            result = ['SELECT']\n            params = []\n            if self.query.distinct:\n                distinct_result, distinct_params = self.connection.ops.distinct_sql(distinct_fields, distinct_params)\n                result += distinct_result\n                params += distinct_params\n            out_cols = []\n            col_idx = 1\n            for _, (s_sql, s_params), alias in self.select + extra_select:\n                if alias:\n                    s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n                elif with_col_aliases:\n                    s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name('col%d' % col_idx))\n                    col_idx += 1\n                params.extend(s_params)\n                out_cols.append(s_sql)\n            result += [', '.join(out_cols), 'FROM', *from_]\n            params.extend(f_params)\n            if self.query.select_for_update and self.connection.features.has_select_for_update:\n                if self.connection.get_autocommit():\n                    raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')\n                if with_limit_offset and (not self.connection.features.supports_select_for_update_with_limit):\n                    raise NotSupportedError('LIMIT/OFFSET is not supported with select_for_update on this database backend.')\n                nowait = self.query.select_for_update_nowait\n                skip_locked = self.query.select_for_update_skip_locked\n                of = self.query.select_for_update_of\n                no_key = self.query.select_for_no_key_update\n                if nowait and (not self.connection.features.has_select_for_update_nowait):\n                    raise NotSupportedError('NOWAIT is not supported on this database backend.')\n                elif skip_locked and (not self.connection.features.has_select_for_update_skip_locked):\n                    raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')\n                elif of and (not self.connection.features.has_select_for_update_of):\n                    raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')\n                elif no_key and (not self.connection.features.has_select_for_no_key_update):\n                    raise NotSupportedError('FOR NO KEY UPDATE is not supported on this database backend.')\n                for_update_part = self.connection.ops.for_update_sql(nowait=nowait, skip_locked=skip_locked, of=self.get_select_for_update_of_arguments(), no_key=no_key)\n            if for_update_part and self.connection.features.for_update_after_from:\n                result.append(for_update_part)\n            if where:\n                result.append('WHERE %s' % where)\n                params.extend(w_params)\n            grouping = []\n            for g_sql, g_params in group_by:\n                grouping.append(g_sql)\n                params.extend(g_params)\n            if grouping:\n                if distinct_fields:\n                    raise NotImplementedError('annotate() + distinct(fields) is not implemented.')\n                order_by = order_by or self.connection.ops.force_no_ordering()\n                result.append('GROUP BY %s' % ', '.join(grouping))\n                if self._meta_ordering:\n                    order_by = None\n            if having:\n                result.append('HAVING %s' % having)\n                params.extend(h_params)\n        if self.query.explain_info:\n            result.insert(0, self.connection.ops.explain_query_prefix(self.query.explain_info.format, **self.query.explain_info.options))\n        if order_by:\n            ordering = []\n            for _, (o_sql, o_params, _) in order_by:\n                ordering.append(o_sql)\n                params.extend(o_params)\n            result.append('ORDER BY %s' % ', '.join(ordering))\n        if with_limit_offset:\n            result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))\n        if for_update_part and (not self.connection.features.for_update_after_from):\n            result.append(for_update_part)\n        if self.query.subquery and extra_select:\n            sub_selects = []\n            sub_params = []\n            for index, (select, _, alias) in enumerate(self.select, start=1):\n                if not alias and with_col_aliases:\n                    alias = 'col%d' % index\n                if alias:\n                    sub_selects.append('%s.%s' % (self.connection.ops.quote_name('subquery'), self.connection.ops.quote_name(alias)))\n                else:\n                    select_clone = select.relabeled_clone({select.alias: 'subquery'})\n                    subselect, subparams = select_clone.as_sql(self, self.connection)\n                    sub_selects.append(subselect)\n                    sub_params.extend(subparams)\n            return ('SELECT %s FROM (%s) subquery' % (', '.join(sub_selects), ' '.join(result)), tuple(sub_params + params))\n        return (' '.join(result), tuple(params))\n    finally:\n        self.query.reset_refcounts(refcounts_before)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.pre_sql_setup": "def pre_sql_setup(self):\n    self.setup_query()\n    order_by = self.get_order_by()\n    self.where, self.having = self.query.where.split_having()\n    extra_select = self.get_extra_select(order_by, self.select)\n    self.has_extra_select = bool(extra_select)\n    group_by = self.get_group_by(self.select + extra_select, order_by)\n    return (extra_select, order_by, group_by)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.setup_query": "def setup_query(self):\n    if all((self.query.alias_refcount[a] == 0 for a in self.query.alias_map)):\n        self.query.get_initial_alias()\n    self.select, self.klass_info, self.annotation_col_map = self.get_select()\n    self.col_count = len(self.select)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_select": "def get_select(self):\n    select = []\n    klass_info = None\n    annotations = {}\n    select_idx = 0\n    for alias, (sql, params) in self.query.extra_select.items():\n        annotations[alias] = select_idx\n        select.append((RawSQL(sql, params), alias))\n        select_idx += 1\n    assert not (self.query.select and self.query.default_cols)\n    if self.query.default_cols:\n        cols = self.get_default_columns()\n    else:\n        cols = self.query.select\n    if cols:\n        select_list = []\n        for col in cols:\n            select_list.append(select_idx)\n            select.append((col, None))\n            select_idx += 1\n        klass_info = {'model': self.query.model, 'select_fields': select_list}\n    for alias, annotation in self.query.annotation_select.items():\n        annotations[alias] = select_idx\n        select.append((annotation, alias))\n        select_idx += 1\n    if self.query.select_related:\n        related_klass_infos = self.get_related_selections(select)\n        klass_info['related_klass_infos'] = related_klass_infos\n\n        def get_select_from_parent(klass_info):\n            for ki in klass_info['related_klass_infos']:\n                if ki['from_parent']:\n                    ki['select_fields'] = klass_info['select_fields'] + ki['select_fields']\n                get_select_from_parent(ki)\n        get_select_from_parent(klass_info)\n    ret = []\n    for col, alias in select:\n        try:\n            sql, params = self.compile(col)\n        except EmptyResultSet:\n            empty_result_set_value = getattr(col, 'empty_result_set_value', NotImplemented)\n            if empty_result_set_value is NotImplemented:\n                sql, params = ('0', ())\n            else:\n                sql, params = self.compile(Value(empty_result_set_value))\n        else:\n            sql, params = col.select_format(self, sql, params)\n        ret.append((col, (sql, params), alias))\n    return (ret, klass_info, annotations)",
    ".django.db.models.sql.query.py@@Query.extra_select": "def extra_select(self):\n    if self._extra_select_cache is not None:\n        return self._extra_select_cache\n    if not self.extra:\n        return {}\n    elif self.extra_select_mask is not None:\n        self._extra_select_cache = {k: v for k, v in self.extra.items() if k in self.extra_select_mask}\n        return self._extra_select_cache\n    else:\n        return self.extra",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_default_columns": "def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n    result = []\n    if opts is None:\n        opts = self.query.get_meta()\n    only_load = self.deferred_to_columns()\n    start_alias = start_alias or self.query.get_initial_alias()\n    seen_models = {None: start_alias}\n    for field in opts.concrete_fields:\n        model = field.model._meta.concrete_model\n        if model == opts.model:\n            model = None\n        if from_parent and model is not None and issubclass(from_parent._meta.concrete_model, model._meta.concrete_model):\n            continue\n        if field.model in only_load and field.attname not in only_load[field.model]:\n            continue\n        alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n        column = field.get_col(alias)\n        result.append(column)\n    return result",
    ".django.db.models.sql.compiler.py@@SQLCompiler.deferred_to_columns": "def deferred_to_columns(self):\n    columns = {}\n    self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)\n    return columns",
    ".django.db.models.sql.query.py@@Query.deferred_to_data": "def deferred_to_data(self, target, callback):\n    field_names, defer = self.deferred_loading\n    if not field_names:\n        return\n    orig_opts = self.get_meta()\n    seen = {}\n    must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n    for field_name in field_names:\n        parts = field_name.split(LOOKUP_SEP)\n        cur_model = self.model._meta.concrete_model\n        opts = orig_opts\n        for name in parts[:-1]:\n            old_model = cur_model\n            if name in self._filtered_relations:\n                name = self._filtered_relations[name].relation_name\n            source = opts.get_field(name)\n            if is_reverse_o2o(source):\n                cur_model = source.related_model\n            else:\n                cur_model = source.remote_field.model\n            opts = cur_model._meta\n            if not is_reverse_o2o(source):\n                must_include[old_model].add(source)\n            add_to_dict(must_include, cur_model, opts.pk)\n        field = opts.get_field(parts[-1])\n        is_reverse_object = field.auto_created and (not field.concrete)\n        model = field.related_model if is_reverse_object else field.model\n        model = model._meta.concrete_model\n        if model == opts.model:\n            model = cur_model\n        if not is_reverse_o2o(field):\n            add_to_dict(seen, model, field)\n    if defer:\n        workset = {}\n        for model, values in seen.items():\n            for field in model._meta.local_fields:\n                if field not in values:\n                    m = field.model._meta.concrete_model\n                    add_to_dict(workset, m, field)\n        for model, values in must_include.items():\n            if model in workset:\n                workset[model].update(values)\n        for model, values in workset.items():\n            callback(target, model, values)\n    else:\n        for model, values in must_include.items():\n            if model in seen:\n                seen[model].update(values)\n            else:\n                seen[model] = values\n        for model in orig_opts.get_parent_list():\n            seen.setdefault(model, set())\n        for model, values in seen.items():\n            callback(target, model, values)",
    ".django.db.models.sql.query.py@@Query.base_table": "def base_table(self):\n    for alias in self.alias_map:\n        return alias",
    ".django.db.models.sql.query.py@@Query.ref_alias": "def ref_alias(self, alias):\n    self.alias_refcount[alias] += 1",
    ".django.db.models.options.py@@Options.concrete_fields": "def concrete_fields(self):\n    return make_immutable_fields_list('concrete_fields', (f for f in self.fields if f.concrete))",
    ".django.db.models.sql.query.py@@Query.join_parent_model": "def join_parent_model(self, opts, model, alias, seen):\n    if model in seen:\n        return seen[model]\n    chain = opts.get_base_chain(model)\n    if not chain:\n        return alias\n    curr_opts = opts\n    for int_model in chain:\n        if int_model in seen:\n            curr_opts = int_model._meta\n            alias = seen[int_model]\n            continue\n        if not curr_opts.parents[int_model]:\n            curr_opts = int_model._meta\n            continue\n        link_field = curr_opts.get_ancestor_link(int_model)\n        join_info = self.setup_joins([link_field.name], curr_opts, alias)\n        curr_opts = int_model._meta\n        alias = seen[int_model] = join_info.joins[-1]\n    return alias or seen[None]",
    ".django.db.models.sql.compiler.py@@SQLCompiler.compile": "def compile(self, node):\n    vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)\n    if vendor_impl:\n        sql, params = vendor_impl(self, self.connection)\n    else:\n        sql, params = node.as_sql(self, self.connection)\n    return (sql, params)",
    ".django.db.models.expressions.py@@Col.as_sql": "def as_sql(self, compiler, connection):\n    alias, column = (self.alias, self.target.column)\n    identifiers = (alias, column) if alias else (column,)\n    sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))\n    return (sql, [])",
    ".django.db.models.sql.compiler.py@@SQLCompiler.quote_name_unless_alias": "def quote_name_unless_alias(self, name):\n    if name in self.quote_cache:\n        return self.quote_cache[name]\n    if name in self.query.alias_map and name not in self.query.table_map or name in self.query.extra_select or (self.query.external_aliases.get(name) and name not in self.query.table_map):\n        self.quote_cache[name] = name\n        return name\n    r = self.connection.ops.quote_name(name)\n    self.quote_cache[name] = r\n    return r",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.quote_name": "def quote_name(self, name):\n    if name.startswith('\"') and name.endswith('\"'):\n        return name\n    return '\"%s\"' % name",
    ".django.db.models.expressions.py@@BaseExpression.select_format": "def select_format(self, compiler, sql, params):\n    if hasattr(self.output_field, 'select_format'):\n        return self.output_field.select_format(compiler, sql, params)\n    return (sql, params)",
    ".django.db.models.fields.__init__.py@@Field.select_format": "def select_format(self, compiler, sql, params):\n    return (sql, params)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_order_by": "def get_order_by(self):\n    result = []\n    seen = set()\n    for expr, is_ref in self._order_by_pairs():\n        resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n        if self.query.combinator and self.select:\n            src = resolved.get_source_expressions()[0]\n            expr_src = expr.get_source_expressions()[0]\n            for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n                if is_ref and col_alias == src.refs:\n                    src = src.source\n                elif col_alias and (not (isinstance(expr_src, F) and col_alias == expr_src.name)):\n                    continue\n                if src == sel_expr:\n                    resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n                    break\n            else:\n                if col_alias:\n                    raise DatabaseError('ORDER BY term does not match any column in the result set.')\n                order_by_idx = len(self.query.select) + 1\n                col_name = f'__orderbycol{order_by_idx}'\n                for q in self.query.combined_queries:\n                    q.add_annotation(expr_src, col_name)\n                self.query.add_select_col(resolved, col_name)\n                resolved.set_source_expressions([RawSQL(f'{order_by_idx}', ())])\n        sql, params = self.compile(resolved)\n        without_ordering = self.ordering_parts.search(sql)[1]\n        params_hash = make_hashable(params)\n        if (without_ordering, params_hash) in seen:\n            continue\n        seen.add((without_ordering, params_hash))\n        result.append((resolved, (sql, params, is_ref)))\n    return result",
    ".django.db.models.sql.compiler.py@@SQLCompiler._order_by_pairs": "def _order_by_pairs(self):\n    if self.query.extra_order_by:\n        ordering = self.query.extra_order_by\n    elif not self.query.default_ordering:\n        ordering = self.query.order_by\n    elif self.query.order_by:\n        ordering = self.query.order_by\n    elif self.query.get_meta().ordering:\n        ordering = self.query.get_meta().ordering\n        self._meta_ordering = ordering\n    else:\n        ordering = []\n    if self.query.standard_ordering:\n        default_order, _ = ORDER_DIR['ASC']\n    else:\n        default_order, _ = ORDER_DIR['DESC']\n    for field in ordering:\n        if hasattr(field, 'resolve_expression'):\n            if isinstance(field, Value):\n                field = Cast(field, field.output_field)\n            if not isinstance(field, OrderBy):\n                field = field.asc()\n            if not self.query.standard_ordering:\n                field = field.copy()\n                field.reverse_ordering()\n            yield (field, False)\n            continue\n        if field == '?':\n            yield (OrderBy(Random()), False)\n            continue\n        col, order = get_order_dir(field, default_order)\n        descending = order == 'DESC'\n        if col in self.query.annotation_select:\n            yield (OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending), True)\n            continue\n        if col in self.query.annotations:\n            if self.query.combinator and self.select:\n                expr = F(col)\n            else:\n                expr = self.query.annotations[col]\n                if isinstance(expr, Value):\n                    expr = Cast(expr, expr.output_field)\n            yield (OrderBy(expr, descending=descending), False)\n            continue\n        if '.' in field:\n            table, col = col.split('.', 1)\n            yield (OrderBy(RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []), descending=descending), False)\n            continue\n        if self.query.extra and col in self.query.extra:\n            if col in self.query.extra_select:\n                yield (OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending), True)\n            else:\n                yield (OrderBy(RawSQL(*self.query.extra[col]), descending=descending), False)\n        elif self.query.combinator and self.select:\n            yield (OrderBy(F(col), descending=descending), False)\n        else:\n            yield from self.find_ordering_name(field, self.query.get_meta(), default_order=default_order)",
    ".django.db.models.sql.where.py@@WhereNode.split_having": "def split_having(self, negated=False):\n    if not self.contains_aggregate:\n        return (self, None)\n    in_negated = negated ^ self.negated\n    may_need_split = in_negated and self.connector == AND or (not in_negated and self.connector == OR)\n    if may_need_split and self.contains_aggregate:\n        return (None, self)\n    where_parts = []\n    having_parts = []\n    for c in self.children:\n        if hasattr(c, 'split_having'):\n            where_part, having_part = c.split_having(in_negated)\n            if where_part is not None:\n                where_parts.append(where_part)\n            if having_part is not None:\n                having_parts.append(having_part)\n        elif c.contains_aggregate:\n            having_parts.append(c)\n        else:\n            where_parts.append(c)\n    having_node = self.__class__(having_parts, self.connector, self.negated) if having_parts else None\n    where_node = self.__class__(where_parts, self.connector, self.negated) if where_parts else None\n    return (where_node, having_node)",
    ".django.db.models.sql.where.py@@WhereNode.contains_aggregate": "def contains_aggregate(self):\n    return self._contains_aggregate(self)",
    ".django.db.models.sql.where.py@@WhereNode._contains_aggregate": "def _contains_aggregate(cls, obj):\n    if isinstance(obj, tree.Node):\n        return any((cls._contains_aggregate(c) for c in obj.children))\n    return obj.contains_aggregate",
    ".django.db.models.expressions.py@@BaseExpression.contains_aggregate": "def contains_aggregate(self):\n    return any((expr and expr.contains_aggregate for expr in self.get_source_expressions()))",
    ".django.db.models.lookups.py@@Lookup.get_source_expressions": "def get_source_expressions(self):\n    if self.rhs_is_direct_value():\n        return [self.lhs]\n    return [self.lhs, self.rhs]",
    ".django.db.models.expressions.py@@BaseExpression.get_source_expressions": "def get_source_expressions(self):\n    return []",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_extra_select": "def get_extra_select(self, order_by, select):\n    extra_select = []\n    if self.query.distinct and (not self.query.distinct_fields):\n        select_sql = [t[1] for t in select]\n        for expr, (sql, params, is_ref) in order_by:\n            without_ordering = self.ordering_parts.search(sql)[1]\n            if not is_ref and (without_ordering, params) not in select_sql:\n                extra_select.append((expr, (without_ordering, params), None))\n    return extra_select",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_group_by": "def get_group_by(self, select, order_by):\n    if self.query.group_by is None:\n        return []\n    expressions = []\n    if self.query.group_by is not True:\n        for expr in self.query.group_by:\n            if not hasattr(expr, 'as_sql'):\n                expressions.append(self.query.resolve_ref(expr))\n            else:\n                expressions.append(expr)\n    ref_sources = {expr.source for expr in expressions if isinstance(expr, Ref)}\n    for expr, _, _ in select:\n        if expr in ref_sources:\n            continue\n        cols = expr.get_group_by_cols()\n        for col in cols:\n            expressions.append(col)\n    if not self._meta_ordering:\n        for expr, (sql, params, is_ref) in order_by:\n            if not is_ref:\n                expressions.extend(expr.get_group_by_cols())\n    having_group_by = self.having.get_group_by_cols() if self.having else ()\n    for expr in having_group_by:\n        expressions.append(expr)\n    result = []\n    seen = set()\n    expressions = self.collapse_group_by(expressions, having_group_by)\n    for expr in expressions:\n        sql, params = self.compile(expr)\n        sql, params = expr.select_format(self, sql, params)\n        params_hash = make_hashable(params)\n        if (sql, params_hash) not in seen:\n            result.append((sql, params))\n            seen.add((sql, params_hash))\n    return result",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_distinct": "def get_distinct(self):\n    result = []\n    params = []\n    opts = self.query.get_meta()\n    for name in self.query.distinct_fields:\n        parts = name.split(LOOKUP_SEP)\n        _, targets, alias, joins, path, _, transform_function = self._setup_joins(parts, opts, None)\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        for target in targets:\n            if name in self.query.annotation_select:\n                result.append(self.connection.ops.quote_name(name))\n            else:\n                r, p = self.compile(transform_function(target, alias))\n                result.append(r)\n                params.append(p)\n    return (result, params)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_from_clause": "def get_from_clause(self):\n    result = []\n    params = []\n    for alias in tuple(self.query.alias_map):\n        if not self.query.alias_refcount[alias]:\n            continue\n        try:\n            from_clause = self.query.alias_map[alias]\n        except KeyError:\n            continue\n        clause_sql, clause_params = self.compile(from_clause)\n        result.append(clause_sql)\n        params.extend(clause_params)\n    for t in self.query.extra_tables:\n        alias, _ = self.query.table_alias(t)\n        if alias not in self.query.alias_map or self.query.alias_refcount[alias] == 1:\n            result.append(', %s' % self.quote_name_unless_alias(alias))\n    return (result, params)",
    ".django.db.models.sql.datastructures.py@@BaseTable.as_sql": "def as_sql(self, compiler, connection):\n    alias_str = '' if self.table_alias == self.table_name else ' %s' % self.table_alias\n    base_sql = compiler.quote_name_unless_alias(self.table_name)\n    return (base_sql + alias_str, [])",
    ".django.db.models.sql.where.py@@WhereNode.as_sql": "def as_sql(self, compiler, connection):\n    result = []\n    result_params = []\n    if self.connector == AND:\n        full_needed, empty_needed = (len(self.children), 1)\n    else:\n        full_needed, empty_needed = (1, len(self.children))\n    for child in self.children:\n        try:\n            sql, params = compiler.compile(child)\n        except EmptyResultSet:\n            empty_needed -= 1\n        else:\n            if sql:\n                result.append(sql)\n                result_params.extend(params)\n            else:\n                full_needed -= 1\n        if empty_needed == 0:\n            if self.negated:\n                return ('', [])\n            else:\n                raise EmptyResultSet\n        if full_needed == 0:\n            if self.negated:\n                raise EmptyResultSet\n            else:\n                return ('', [])\n    conn = ' %s ' % self.connector\n    sql_string = conn.join(result)\n    if sql_string:\n        if self.negated:\n            sql_string = 'NOT (%s)' % sql_string\n        elif len(result) > 1 or self.resolved:\n            sql_string = '(%s)' % sql_string\n    return (sql_string, result_params)",
    ".django.db.models.fields.related_lookups.py@@RelatedIn.as_sql": "def as_sql(self, compiler, connection):\n    if isinstance(self.lhs, MultiColSource):\n        from django.db.models.sql.where import AND, OR, SubqueryConstraint, WhereNode\n        root_constraint = WhereNode(connector=OR)\n        if self.rhs_is_direct_value():\n            values = [get_normalized_value(value, self.lhs) for value in self.rhs]\n            for value in values:\n                value_constraint = WhereNode()\n                for source, target, val in zip(self.lhs.sources, self.lhs.targets, value):\n                    lookup_class = target.get_lookup('exact')\n                    lookup = lookup_class(target.get_col(self.lhs.alias, source), val)\n                    value_constraint.add(lookup, AND)\n                root_constraint.add(value_constraint, OR)\n        else:\n            root_constraint.add(SubqueryConstraint(self.lhs.alias, [target.column for target in self.lhs.targets], [source.name for source in self.lhs.sources], self.rhs), AND)\n        return root_constraint.as_sql(compiler, connection)\n    return super().as_sql(compiler, connection)",
    ".django.db.models.lookups.py@@In.as_sql": "def as_sql(self, compiler, connection):\n    max_in_list_size = connection.ops.max_in_list_size()\n    if self.rhs_is_direct_value() and max_in_list_size and (len(self.rhs) > max_in_list_size):\n        return self.split_parameter_list_as_sql(compiler, connection)\n    return super().as_sql(compiler, connection)",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.max_in_list_size": "def max_in_list_size(self):\n    return None",
    ".django.db.models.lookups.py@@BuiltinLookup.as_sql": "def as_sql(self, compiler, connection):\n    lhs_sql, params = self.process_lhs(compiler, connection)\n    rhs_sql, rhs_params = self.process_rhs(compiler, connection)\n    params.extend(rhs_params)\n    rhs_sql = self.get_rhs_op(connection, rhs_sql)\n    return ('%s %s' % (lhs_sql, rhs_sql), params)",
    ".django.db.models.lookups.py@@BuiltinLookup.process_lhs": "def process_lhs(self, compiler, connection, lhs=None):\n    lhs_sql, params = super().process_lhs(compiler, connection, lhs)\n    field_internal_type = self.lhs.output_field.get_internal_type()\n    db_type = self.lhs.output_field.db_type(connection=connection)\n    lhs_sql = connection.ops.field_cast_sql(db_type, field_internal_type) % lhs_sql\n    lhs_sql = connection.ops.lookup_cast(self.lookup_name, field_internal_type) % lhs_sql\n    return (lhs_sql, list(params))",
    ".django.db.models.lookups.py@@Lookup.process_lhs": "def process_lhs(self, compiler, connection, lhs=None):\n    lhs = lhs or self.lhs\n    if hasattr(lhs, 'resolve_expression'):\n        lhs = lhs.resolve_expression(compiler.query)\n    sql, params = compiler.compile(lhs)\n    if isinstance(lhs, Lookup):\n        sql = f'({sql})'\n    return (sql, params)",
    ".django.db.models.expressions.py@@BaseExpression.resolve_expression": "def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n    c = self.copy()\n    c.is_summary = summarize\n    c.set_source_expressions([expr.resolve_expression(query, allow_joins, reuse, summarize) if expr else None for expr in c.get_source_expressions()])\n    return c",
    ".django.db.models.expressions.py@@BaseExpression.copy": "def copy(self):\n    return copy.copy(self)",
    ".django.db.models.expressions.py@@BaseExpression.__getstate__": "def __getstate__(self):\n    state = self.__dict__.copy()\n    state.pop('convert_value', None)\n    return state",
    ".django.db.models.expressions.py@@BaseExpression.set_source_expressions": "def set_source_expressions(self, exprs):\n    assert not exprs",
    ".django.db.models.fields.__init__.py@@Field.get_internal_type": "def get_internal_type(self):\n    return self.__class__.__name__",
    ".django.db.models.fields.related.py@@ForeignKey.db_type": "def db_type(self, connection):\n    return self.target_field.rel_db_type(connection=connection)",
    ".django.db.models.fields.__init__.py@@AutoField.rel_db_type": "def rel_db_type(self, connection):\n    return IntegerField().db_type(connection=connection)",
    ".django.db.models.fields.__init__.py@@Field.__init__": "def __init__(self, verbose_name=None, name=None, primary_key=False, max_length=None, unique=False, blank=False, null=False, db_index=False, rel=None, default=NOT_PROVIDED, editable=True, serialize=True, unique_for_date=None, unique_for_month=None, unique_for_year=None, choices=None, help_text='', db_column=None, db_tablespace=None, auto_created=False, validators=(), error_messages=None):\n    self.name = name\n    self.verbose_name = verbose_name\n    self._verbose_name = verbose_name\n    self.primary_key = primary_key\n    self.max_length, self._unique = (max_length, unique)\n    self.blank, self.null = (blank, null)\n    self.remote_field = rel\n    self.is_relation = self.remote_field is not None\n    self.default = default\n    self.editable = editable\n    self.serialize = serialize\n    self.unique_for_date = unique_for_date\n    self.unique_for_month = unique_for_month\n    self.unique_for_year = unique_for_year\n    if isinstance(choices, collections.abc.Iterator):\n        choices = list(choices)\n    self.choices = choices\n    self.help_text = help_text\n    self.db_index = db_index\n    self.db_column = db_column\n    self._db_tablespace = db_tablespace\n    self.auto_created = auto_created\n    if auto_created:\n        self.creation_counter = Field.auto_creation_counter\n        Field.auto_creation_counter -= 1\n    else:\n        self.creation_counter = Field.creation_counter\n        Field.creation_counter += 1\n    self._validators = list(validators)\n    messages = {}\n    for c in reversed(self.__class__.__mro__):\n        messages.update(getattr(c, 'default_error_messages', {}))\n    messages.update(error_messages or {})\n    self._error_messages = error_messages\n    self.error_messages = messages",
    ".django.db.models.fields.__init__.py@@Field.db_type": "def db_type(self, connection):\n    data = self.db_type_parameters(connection)\n    try:\n        return connection.data_types[self.get_internal_type()] % data\n    except KeyError:\n        return None",
    ".django.db.models.fields.__init__.py@@Field.db_type_parameters": "def db_type_parameters(self, connection):\n    return DictWrapper(self.__dict__, connection.ops.quote_name, 'qn_')",
    ".django.utils.datastructures.py@@DictWrapper.__init__": "def __init__(self, data, func, prefix):\n    super().__init__(data)\n    self.func = func\n    self.prefix = prefix",
    ".django.db.models.fields.__init__.py@@IntegerField.get_internal_type": "def get_internal_type(self):\n    return 'IntegerField'",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.field_cast_sql": "def field_cast_sql(self, db_type, internal_type):\n    return '%s'",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.lookup_cast": "def lookup_cast(self, lookup_type, internal_type=None):\n    return '%s'",
    ".django.db.models.lookups.py@@In.process_rhs": "def process_rhs(self, compiler, connection):\n    db_rhs = getattr(self.rhs, '_db', None)\n    if db_rhs is not None and db_rhs != connection.alias:\n        raise ValueError(\"Subqueries aren't allowed across different databases. Force the inner query to be evaluated using `list(inner_query)`.\")\n    if self.rhs_is_direct_value():\n        try:\n            rhs = OrderedSet(self.rhs)\n            rhs.discard(None)\n        except TypeError:\n            rhs = [r for r in self.rhs if r is not None]\n        if not rhs:\n            raise EmptyResultSet\n        sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\n        placeholder = '(' + ', '.join(sqls) + ')'\n        return (placeholder, sqls_params)\n    return super().process_rhs(compiler, connection)",
    ".django.utils.datastructures.py@@OrderedSet.__init__": "def __init__(self, iterable=None):\n    self.dict = dict.fromkeys(iterable or ())",
    ".django.utils.datastructures.py@@OrderedSet.discard": "def discard(self, item):\n    try:\n        self.remove(item)\n    except KeyError:\n        pass",
    ".django.utils.datastructures.py@@OrderedSet.remove": "def remove(self, item):\n    del self.dict[item]",
    ".django.utils.datastructures.py@@OrderedSet.__bool__": "def __bool__(self):\n    return bool(self.dict)",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueIterableMixin.batch_process_rhs": "def batch_process_rhs(self, compiler, connection, rhs=None):\n    pre_processed = super().batch_process_rhs(compiler, connection, rhs)\n    sql, params = zip(*(self.resolve_expression_parameter(compiler, connection, sql, param) for sql, param in zip(*pre_processed)))\n    params = itertools.chain.from_iterable(params)\n    return (sql, tuple(params))",
    ".django.db.models.lookups.py@@Lookup.batch_process_rhs": "def batch_process_rhs(self, compiler, connection, rhs=None):\n    if rhs is None:\n        rhs = self.rhs\n    if self.bilateral_transforms:\n        sqls, sqls_params = ([], [])\n        for p in rhs:\n            value = Value(p, output_field=self.lhs.output_field)\n            value = self.apply_bilateral_transforms(value)\n            value = value.resolve_expression(compiler.query)\n            sql, sql_params = compiler.compile(value)\n            sqls.append(sql)\n            sqls_params.extend(sql_params)\n    else:\n        _, params = self.get_db_prep_lookup(rhs, connection)\n        sqls, sqls_params = (['%s'] * len(params), params)\n    return (sqls, sqls_params)",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueMixin.get_db_prep_lookup": "def get_db_prep_lookup(self, value, connection):\n    field = getattr(self.lhs.output_field, 'target_field', None)\n    get_db_prep_value = getattr(field, 'get_db_prep_value', None) or self.lhs.output_field.get_db_prep_value\n    return ('%s', [get_db_prep_value(v, connection, prepared=True) for v in value] if self.get_db_prep_lookup_value_is_iterable else [get_db_prep_value(value, connection, prepared=True)])",
    ".django.utils.datastructures.py@@OrderedSet.__iter__": "def __iter__(self):\n    return iter(self.dict)",
    ".django.db.models.fields.__init__.py@@AutoFieldMixin.get_db_prep_value": "def get_db_prep_value(self, value, connection, prepared=False):\n    if not prepared:\n        value = self.get_prep_value(value)\n        value = connection.ops.validate_autopk_value(value)\n    return value",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueIterableMixin.resolve_expression_parameter": "def resolve_expression_parameter(self, compiler, connection, sql, param):\n    params = [param]\n    if hasattr(param, 'resolve_expression'):\n        param = param.resolve_expression(compiler.query)\n    if hasattr(param, 'as_sql'):\n        sql, params = compiler.compile(param)\n    return (sql, params)",
    ".django.db.models.lookups.py@@In.get_rhs_op": "def get_rhs_op(self, connection, rhs):\n    return 'IN %s' % rhs",
    ".django.db.models.sql.query.py@@Query.reset_refcounts": "def reset_refcounts(self, to_counts):\n    for alias, cur_refcount in self.alias_refcount.copy().items():\n        unref_amount = cur_refcount - to_counts.get(alias, 0)\n        self.unref_alias(alias, unref_amount)",
    ".django.utils.asyncio.py@@inner": "def inner(*args, **kwargs):\n    try:\n        get_running_loop()\n    except RuntimeError:\n        pass\n    else:\n        if not os.environ.get('DJANGO_ALLOW_ASYNC_UNSAFE'):\n            raise SynchronousOnlyOperation(message)\n    return func(*args, **kwargs)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.cursor": "def cursor(self):\n    return self._cursor()",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper._cursor": "def _cursor(self, name=None):\n    self.close_if_health_check_failed()\n    self.ensure_connection()\n    with self.wrap_database_errors:\n        return self._prepare_cursor(self.create_cursor(name))",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.close_if_health_check_failed": "def close_if_health_check_failed(self):\n    if self.connection is None or not self.health_check_enabled or self.health_check_done:\n        return\n    if not self.is_usable():\n        self.close()\n    self.health_check_done = True",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.ensure_connection": "def ensure_connection(self):\n    if self.connection is None:\n        with self.wrap_database_errors:\n            self.connect()",
    ".django.db.utils.py@@DatabaseErrorWrapper.__enter__": "def __enter__(self):\n    pass",
    ".django.db.backends.sqlite3.base.py@@DatabaseWrapper.create_cursor": "def create_cursor(self, name=None):\n    return self.connection.cursor(factory=SQLiteCursorWrapper)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper._prepare_cursor": "def _prepare_cursor(self, cursor):\n    self.validate_thread_sharing()\n    if self.queries_logged:\n        wrapped_cursor = self.make_debug_cursor(cursor)\n    else:\n        wrapped_cursor = self.make_cursor(cursor)\n    return wrapped_cursor",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.validate_thread_sharing": "def validate_thread_sharing(self):\n    if not (self.allow_thread_sharing or self._thread_ident == _thread.get_ident()):\n        raise DatabaseError(\"DatabaseWrapper objects created in a thread can only be used in that same thread. The object with alias '%s' was created in thread id %s and this is thread id %s.\" % (self.alias, self._thread_ident, _thread.get_ident()))",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.allow_thread_sharing": "def allow_thread_sharing(self):\n    with self._thread_sharing_lock:\n        return self._thread_sharing_count > 0",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.queries_logged": "def queries_logged(self):\n    return self.force_debug_cursor or settings.DEBUG",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.make_cursor": "def make_cursor(self, cursor):\n    return utils.CursorWrapper(cursor, self)",
    ".django.db.backends.utils.py@@CursorWrapper.__init__": "def __init__(self, cursor, db):\n    self.cursor = cursor\n    self.db = db",
    ".django.db.utils.py@@DatabaseErrorWrapper.__exit__": "def __exit__(self, exc_type, exc_value, traceback):\n    if exc_type is None:\n        return\n    for dj_exc_type in (DataError, OperationalError, IntegrityError, InternalError, ProgrammingError, NotSupportedError, DatabaseError, InterfaceError, Error):\n        db_exc_type = getattr(self.wrapper.Database, dj_exc_type.__name__)\n        if issubclass(exc_type, db_exc_type):\n            dj_exc_value = dj_exc_type(*exc_value.args)\n            if dj_exc_type not in (DataError, IntegrityError):\n                self.wrapper.errors_occurred = True\n            raise dj_exc_value.with_traceback(traceback) from exc_value",
    ".django.db.backends.utils.py@@CursorWrapper.execute": "def execute(self, sql, params=None):\n    return self._execute_with_wrappers(sql, params, many=False, executor=self._execute)",
    ".django.db.backends.utils.py@@CursorWrapper._execute_with_wrappers": "def _execute_with_wrappers(self, sql, params, many, executor):\n    context = {'connection': self.db, 'cursor': self}\n    for wrapper in reversed(self.db.execute_wrappers):\n        executor = functools.partial(wrapper, executor)\n    return executor(sql, params, many, context)",
    ".django.db.backends.utils.py@@CursorWrapper._execute": "def _execute(self, sql, params, *ignored_wrapper_args):\n    self.db.validate_no_broken_transaction()\n    with self.db.wrap_database_errors:\n        if params is None:\n            return self.cursor.execute(sql)\n        else:\n            return self.cursor.execute(sql, params)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.validate_no_broken_transaction": "def validate_no_broken_transaction(self):\n    if self.needs_rollback:\n        raise TransactionManagementError(\"An error occurred in the current transaction. You can't execute queries until the end of the 'atomic' block.\")",
    ".django.db.backends.sqlite3.base.py@@SQLiteCursorWrapper.execute": "def execute(self, query, params=None):\n    if params is None:\n        return Database.Cursor.execute(self, query)\n    query = self.convert_query(query)\n    return Database.Cursor.execute(self, query, params)",
    ".django.db.backends.sqlite3.base.py@@SQLiteCursorWrapper.convert_query": "def convert_query(self, query):\n    return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')",
    ".django.utils.functional.py@@inner": "def inner(self, *args):\n    if self._wrapped is empty:\n        self._setup()\n    return func(self._wrapped, *args)",
    ".django.db.models.sql.compiler.py@@cursor_iter": "def cursor_iter(cursor, sentinel, col_count, itersize):\n    try:\n        for rows in iter(lambda: cursor.fetchmany(itersize), sentinel):\n            yield (rows if col_count is None else [r[:col_count] for r in rows])\n    finally:\n        cursor.close()",
    ".django.db.backends.utils.py@@CursorWrapper.__getattr__": "def __getattr__(self, attr):\n    cursor_attr = getattr(self.cursor, attr)\n    if attr in CursorWrapper.WRAP_ERROR_ATTRS:\n        return self.db.wrap_database_errors(cursor_attr)\n    else:\n        return cursor_attr",
    ".django.db.utils.py@@DatabaseErrorWrapper.__call__": "def __call__(self, func):\n\n    def inner(*args, **kwargs):\n        with self:\n            return func(*args, **kwargs)\n    return inner",
    ".django.db.utils.py@@DatabaseErrorWrapper.inner": "def inner(*args, **kwargs):\n    with self:\n        return func(*args, **kwargs)",
    ".django.db.models.query.py@@get_related_populators": "def get_related_populators(klass_info, select, db):\n    iterators = []\n    related_klass_infos = klass_info.get('related_klass_infos', [])\n    for rel_klass_info in related_klass_infos:\n        rel_cls = RelatedPopulator(rel_klass_info, select, db)\n        iterators.append(rel_cls)\n    return iterators",
    ".django.db.models.sql.compiler.py@@SQLCompiler.results_iter": "def results_iter(self, results=None, tuple_expected=False, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n    if results is None:\n        results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)\n    fields = [s[0] for s in self.select[0:self.col_count]]\n    converters = self.get_converters(fields)\n    rows = chain.from_iterable(results)\n    if converters:\n        rows = self.apply_converters(rows, converters)\n        if tuple_expected:\n            rows = map(tuple, rows)\n    return rows",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_converters": "def get_converters(self, expressions):\n    converters = {}\n    for i, expression in enumerate(expressions):\n        if expression:\n            backend_converters = self.connection.ops.get_db_converters(expression)\n            field_converters = expression.get_db_converters(self.connection)\n            if backend_converters or field_converters:\n                converters[i] = (backend_converters + field_converters, expression)\n    return converters",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.get_db_converters": "def get_db_converters(self, expression):\n    converters = super().get_db_converters(expression)\n    internal_type = expression.output_field.get_internal_type()\n    if internal_type == 'DateTimeField':\n        converters.append(self.convert_datetimefield_value)\n    elif internal_type == 'DateField':\n        converters.append(self.convert_datefield_value)\n    elif internal_type == 'TimeField':\n        converters.append(self.convert_timefield_value)\n    elif internal_type == 'DecimalField':\n        converters.append(self.get_decimalfield_converter(expression))\n    elif internal_type == 'UUIDField':\n        converters.append(self.convert_uuidfield_value)\n    elif internal_type == 'BooleanField':\n        converters.append(self.convert_booleanfield_value)\n    return converters",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.get_db_converters": "def get_db_converters(self, expression):\n    return []",
    ".django.db.models.fields.__init__.py@@AutoField.get_internal_type": "def get_internal_type(self):\n    return 'AutoField'",
    ".django.db.models.expressions.py@@Col.get_db_converters": "def get_db_converters(self, connection):\n    if self.target == self.output_field:\n        return self.output_field.get_db_converters(connection)\n    return self.output_field.get_db_converters(connection) + self.target.get_db_converters(connection)",
    ".django.db.models.fields.__init__.py@@Field.get_db_converters": "def get_db_converters(self, connection):\n    if hasattr(self, 'from_db_value'):\n        return [self.from_db_value]\n    return []",
    ".django.db.models.fields.related.py@@ForeignKey.get_db_converters": "def get_db_converters(self, connection):\n    converters = super().get_db_converters(connection)\n    if connection.features.interprets_empty_strings_as_nulls:\n        converters += [self.convert_empty_strings]\n    return converters",
    ".django.db.models.options.py@@Options._forward_fields_map": "def _forward_fields_map(self):\n    res = {}\n    fields = self._get_fields(reverse=False)\n    for field in fields:\n        res[field.name] = field\n        try:\n            res[field.attname] = field\n        except AttributeError:\n            pass\n    return res",
    ".django.db.models.fields.__init__.py@@TextField.get_internal_type": "def get_internal_type(self):\n    return 'TextField'",
    ".django.dispatch.dispatcher.py@@Signal.send": "def send(self, sender, **named):\n    if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS:\n        return []\n    return [(receiver, receiver(signal=self, sender=sender, **named)) for receiver in self._live_receivers(sender)]",
    ".django.db.models.fields.related_descriptors.py@@ForeignKeyDeferredAttribute.__set__": "def __set__(self, instance, value):\n    if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n        self.field.delete_cached_value(instance)\n    instance.__dict__[self.field.attname] = value",
    ".django.db.models.fields.mixins.py@@FieldCacheMixin.is_cached": "def is_cached(self, instance):\n    return self.get_cache_name() in instance._state.fields_cache",
    ".django.db.models.fields.related.py@@RelatedField.get_cache_name": "def get_cache_name(self):\n    return self.name",
    ".django.db.models.base.py@@ModelStateCacheDescriptor.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    res = instance.__dict__[self.attribute_name] = {}\n    return res",
    ".django.db.models.deletion.py@@CASCADE": "def CASCADE(collector, field, sub_objs, using):\n    collector.collect(sub_objs, source=field.remote_field.model, source_attr=field.name, nullable=field.null, fail_on_restricted=False)\n    if field.null and (not connections[using].features.can_defer_constraint_checks):\n        collector.add_field_update(field, None, sub_objs)",
    ".django.db.models.query.py@@QuerySet.__getitem__": "def __getitem__(self, k):\n    if not isinstance(k, (int, slice)):\n        raise TypeError('QuerySet indices must be integers or slices, not %s.' % type(k).__name__)\n    if isinstance(k, int) and k < 0 or (isinstance(k, slice) and (k.start is not None and k.start < 0 or (k.stop is not None and k.stop < 0))):\n        raise ValueError('Negative indexing is not supported.')\n    if self._result_cache is not None:\n        return self._result_cache[k]\n    if isinstance(k, slice):\n        qs = self._chain()\n        if k.start is not None:\n            start = int(k.start)\n        else:\n            start = None\n        if k.stop is not None:\n            stop = int(k.stop)\n        else:\n            stop = None\n        qs.query.set_limits(start, stop)\n        return list(qs)[::k.step] if k.step else qs\n    qs = self._chain()\n    qs.query.set_limits(k, k + 1)\n    qs._fetch_all()\n    return qs._result_cache[0]",
    ".django.db.models.query.py@@QuerySet.__iter__": "def __iter__(self):\n    self._fetch_all()\n    return iter(self._result_cache)",
    ".django.db.models.deletion.py@@Collector.add_dependency": "def add_dependency(self, model, dependency, reverse_dependency=False):\n    if reverse_dependency:\n        model, dependency = (dependency, model)\n    self.dependencies[model._meta.concrete_model].add(dependency._meta.concrete_model)\n    self.data.setdefault(dependency, self.data.default_factory())"
}