{
    ".sklearn.utils.validation.py@@check_random_state": "def check_random_state(seed):\n    print('[CALL]/home/changshu/CODEMIND/scripts/swebench/swebench_playground/dep/scikit-learn__scikit-learn-10577/sklearn/utils/validation.py@@check_random_state[/CALL]')\n    'Turn seed into a np.random.RandomState instance\\n\\n    Parameters\\n    ----------\\n    seed : None | int | instance of RandomState\\n        If seed is None, return the RandomState singleton used by np.random.\\n        If seed is an int, return a new RandomState instance seeded with seed.\\n        If seed is already a RandomState instance, return it.\\n        Otherwise raise ValueError.\\n    '\n    if seed is None or seed is np.random:\n        return np.random.mtrand._rand\n    if isinstance(seed, (numbers.Integral, np.integer)):\n        return np.random.RandomState(seed)\n    if isinstance(seed, np.random.RandomState):\n        return seed\n    raise ValueError('%r cannot be used to seed a numpy.random.RandomState instance' % seed)",
    ".sklearn.utils.validation.py@@check_array": "def check_array(array, accept_sparse=False, dtype='numeric', order=None, copy=False, force_all_finite=True, ensure_2d=True, allow_nd=False, ensure_min_samples=1, ensure_min_features=1, warn_on_dtype=False, estimator=None):\n    print('[CALL]/home/changshu/CODEMIND/scripts/swebench/swebench_playground/dep/scikit-learn__scikit-learn-10577/sklearn/utils/validation.py@@check_array[/CALL]')\n    'Input validation on an array, list, sparse matrix or similar.\\n\\n    By default, the input is converted to an at least 2D numpy array.\\n    If the dtype of the array is object, attempt converting to float,\\n    raising on failure.\\n\\n    Parameters\\n    ----------\\n    array : object\\n        Input object to check / convert.\\n\\n    accept_sparse : string, boolean or list/tuple of strings (default=False)\\n        String[s] representing allowed sparse matrix formats, such as \\'csc\\',\\n        \\'csr\\', etc. If the input is sparse but not in the allowed format,\\n        it will be converted to the first listed format. True allows the input\\n        to be any format. False means that a sparse matrix input will\\n        raise an error.\\n\\n        .. deprecated:: 0.19\\n           Passing \\'None\\' to parameter ``accept_sparse`` in methods is\\n           deprecated in version 0.19 \"and will be removed in 0.21. Use\\n           ``accept_sparse=False`` instead.\\n\\n    dtype : string, type, list of types or None (default=\"numeric\")\\n        Data type of result. If None, the dtype of the input is preserved.\\n        If \"numeric\", dtype is preserved unless array.dtype is object.\\n        If dtype is a list of types, conversion on the first type is only\\n        performed if the dtype of the input is not in the list.\\n\\n    order : \\'F\\', \\'C\\' or None (default=None)\\n        Whether an array will be forced to be fortran or c-style.\\n        When order is None (default), then if copy=False, nothing is ensured\\n        about the memory layout of the output array; otherwise (copy=True)\\n        the memory layout of the returned array is kept as close as possible\\n        to the original array.\\n\\n    copy : boolean (default=False)\\n        Whether a forced copy will be triggered. If copy=False, a copy might\\n        be triggered by a conversion.\\n\\n    force_all_finite : boolean or \\'allow-nan\\', (default=True)\\n        Whether to raise an error on np.inf and np.nan in X. The possibilities\\n        are:\\n\\n        - True: Force all values of X to be finite.\\n        - False: accept both np.inf and np.nan in X.\\n        - \\'allow-nan\\':  accept  only  np.nan  values in  X.  Values  cannot  be\\n          infinite.\\n\\n        .. versionadded:: 0.20\\n           ``force_all_finite`` accepts the string ``\\'allow-nan\\'``.\\n\\n    ensure_2d : boolean (default=True)\\n        Whether to raise a value error if X is not 2d.\\n\\n    allow_nd : boolean (default=False)\\n        Whether to allow X.ndim > 2.\\n\\n    ensure_min_samples : int (default=1)\\n        Make sure that the array has a minimum number of samples in its first\\n        axis (rows for a 2D array). Setting to 0 disables this check.\\n\\n    ensure_min_features : int (default=1)\\n        Make sure that the 2D array has some minimum number of features\\n        (columns). The default value of 1 rejects empty datasets.\\n        This check is only enforced when the input data has effectively 2\\n        dimensions or is originally 1D and ``ensure_2d`` is True. Setting to 0\\n        disables this check.\\n\\n    warn_on_dtype : boolean (default=False)\\n        Raise DataConversionWarning if the dtype of the input data structure\\n        does not match the requested dtype, causing a memory copy.\\n\\n    estimator : str or estimator instance (default=None)\\n        If passed, include the name of the estimator in warning messages.\\n\\n    Returns\\n    -------\\n    X_converted : object\\n        The converted and validated X.\\n\\n    '\n    if accept_sparse is None:\n        warnings.warn(\"Passing 'None' to parameter 'accept_sparse' in methods check_array and check_X_y is deprecated in version 0.19 and will be removed in 0.21. Use 'accept_sparse=False'  instead.\", DeprecationWarning)\n        accept_sparse = False\n    dtype_numeric = isinstance(dtype, six.string_types) and dtype == 'numeric'\n    dtype_orig = getattr(array, 'dtype', None)\n    if not hasattr(dtype_orig, 'kind'):\n        dtype_orig = None\n    if dtype_numeric:\n        if dtype_orig is not None and dtype_orig.kind == 'O':\n            dtype = np.float64\n        else:\n            dtype = None\n    if isinstance(dtype, (list, tuple)):\n        if dtype_orig is not None and dtype_orig in dtype:\n            dtype = None\n        else:\n            dtype = dtype[0]\n    if force_all_finite not in (True, False, 'allow-nan'):\n        raise ValueError('force_all_finite should be a bool or \"allow-nan\". Got {!r} instead'.format(force_all_finite))\n    if estimator is not None:\n        if isinstance(estimator, six.string_types):\n            estimator_name = estimator\n        else:\n            estimator_name = estimator.__class__.__name__\n    else:\n        estimator_name = 'Estimator'\n    context = ' by %s' % estimator_name if estimator is not None else ''\n    if sp.issparse(array):\n        _ensure_no_complex_data(array)\n        array = _ensure_sparse_format(array, accept_sparse, dtype, copy, force_all_finite)\n    else:\n        with warnings.catch_warnings():\n            try:\n                warnings.simplefilter('error', ComplexWarning)\n                array = np.array(array, dtype=dtype, order=order, copy=copy)\n            except ComplexWarning:\n                raise ValueError('Complex data not supported\\n{}\\n'.format(array))\n        _ensure_no_complex_data(array)\n        if ensure_2d:\n            if array.ndim == 0:\n                raise ValueError('Expected 2D array, got scalar array instead:\\narray={}.\\nReshape your data either using array.reshape(-1, 1) if your data has a single feature or array.reshape(1, -1) if it contains a single sample.'.format(array))\n            if array.ndim == 1:\n                raise ValueError('Expected 2D array, got 1D array instead:\\narray={}.\\nReshape your data either using array.reshape(-1, 1) if your data has a single feature or array.reshape(1, -1) if it contains a single sample.'.format(array))\n            array = np.array(array, dtype=dtype, order=order, copy=copy)\n        if dtype_numeric and array.dtype.kind == 'O':\n            array = array.astype(np.float64)\n        if not allow_nd and array.ndim >= 3:\n            raise ValueError('Found array with dim %d. %s expected <= 2.' % (array.ndim, estimator_name))\n        if force_all_finite:\n            _assert_all_finite(array, allow_nan=force_all_finite == 'allow-nan')\n    shape_repr = _shape_repr(array.shape)\n    if ensure_min_samples > 0:\n        n_samples = _num_samples(array)\n        if n_samples < ensure_min_samples:\n            raise ValueError('Found array with %d sample(s) (shape=%s) while a minimum of %d is required%s.' % (n_samples, shape_repr, ensure_min_samples, context))\n    if ensure_min_features > 0 and array.ndim == 2:\n        n_features = array.shape[1]\n        if n_features < ensure_min_features:\n            raise ValueError('Found array with %d feature(s) (shape=%s) while a minimum of %d is required%s.' % (n_features, shape_repr, ensure_min_features, context))\n    if warn_on_dtype and dtype_orig is not None and (array.dtype != dtype_orig):\n        msg = 'Data with input dtype %s was converted to %s%s.' % (dtype_orig, array.dtype, context)\n        warnings.warn(msg, DataConversionWarning)\n    return array",
    ".sklearn.utils.validation.py@@_ensure_no_complex_data": "def _ensure_no_complex_data(array):\n    print('[CALL]/home/changshu/CODEMIND/scripts/swebench/swebench_playground/dep/scikit-learn__scikit-learn-10577/sklearn/utils/validation.py@@_ensure_no_complex_data[/CALL]')\n    if hasattr(array, 'dtype') and array.dtype is not None and hasattr(array.dtype, 'kind') and (array.dtype.kind == 'c'):\n        raise ValueError('Complex data not supported\\n{}\\n'.format(array))",
    ".sklearn.utils.validation.py@@_assert_all_finite": "def _assert_all_finite(X, allow_nan=False):\n    print('[CALL]/home/changshu/CODEMIND/scripts/swebench/swebench_playground/dep/scikit-learn__scikit-learn-10577/sklearn/utils/validation.py@@_assert_all_finite[/CALL]')\n    'Like assert_all_finite, but only for ndarray.'\n    if _get_config()['assume_finite']:\n        return\n    X = np.asanyarray(X)\n    is_float = X.dtype.kind in 'fc'\n    if is_float and np.isfinite(X.sum()):\n        pass\n    elif is_float:\n        msg_err = 'Input contains {} or a value too large for {!r}.'\n        if allow_nan and np.isinf(X).any() or (not allow_nan and (not np.isfinite(X).all())):\n            type_err = 'infinity' if allow_nan else 'NaN, infinity'\n            raise ValueError(msg_err.format(type_err, X.dtype))",
    ".sklearn.__init__.py@@get_config": "def get_config():\n    print('[CALL]/home/changshu/CODEMIND/scripts/swebench/swebench_playground/dep/scikit-learn__scikit-learn-10577/sklearn/__init__.py@@get_config[/CALL]')\n    'Retrieve current values for configuration set by :func:`set_config`\\n\\n    Returns\\n    -------\\n    config : dict\\n        Keys are parameter names that can be passed to :func:`set_config`.\\n    '\n    return {'assume_finite': _ASSUME_FINITE}",
    ".sklearn.utils.validation.py@@_shape_repr": "def _shape_repr(shape):\n    print('[CALL]/home/changshu/CODEMIND/scripts/swebench/swebench_playground/dep/scikit-learn__scikit-learn-10577/sklearn/utils/validation.py@@_shape_repr[/CALL]')\n    \"Return a platform independent representation of an array shape\\n\\n    Under Python 2, the `long` type introduces an 'L' suffix when using the\\n    default %r format for tuples of integers (typically used to store the shape\\n    of an array).\\n\\n    Under Windows 64 bit (and Python 2), the `long` type is used by default\\n    in numpy shapes even when the integer dimensions are well below 32 bit.\\n    The platform specific type causes string messages or doctests to change\\n    from one platform to another which is not desirable.\\n\\n    Under Python 3, there is no more `long` type so the `L` suffix is never\\n    introduced in string representation.\\n\\n    >>> _shape_repr((1, 2))\\n    '(1, 2)'\\n    >>> one = 2 ** 64 / 2 ** 64  # force an upcast to `long` under Python 2\\n    >>> _shape_repr((one, 2 * one))\\n    '(1, 2)'\\n    >>> _shape_repr((1,))\\n    '(1,)'\\n    >>> _shape_repr(())\\n    '()'\\n    \"\n    if len(shape) == 0:\n        return '()'\n    joined = ', '.join(('%d' % e for e in shape))\n    if len(shape) == 1:\n        joined += ','\n    return '(%s)' % joined",
    ".sklearn.utils.validation.py@@_num_samples": "def _num_samples(x):\n    print('[CALL]/home/changshu/CODEMIND/scripts/swebench/swebench_playground/dep/scikit-learn__scikit-learn-10577/sklearn/utils/validation.py@@_num_samples[/CALL]')\n    'Return number of samples in array-like x.'\n    if hasattr(x, 'fit') and callable(x.fit):\n        raise TypeError('Expected sequence or array-like, got estimator %s' % x)\n    if not hasattr(x, '__len__') and (not hasattr(x, 'shape')):\n        if hasattr(x, '__array__'):\n            x = np.asarray(x)\n        else:\n            raise TypeError('Expected sequence or array-like, got %s' % type(x))\n    if hasattr(x, 'shape'):\n        if len(x.shape) == 0:\n            raise TypeError('Singleton array %r cannot be considered a valid collection.' % x)\n        return x.shape[0]\n    else:\n        return len(x)"
}