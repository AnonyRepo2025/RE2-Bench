{
    ".xarray.coding.times.py@@_is_standard_calendar": "def _is_standard_calendar(calendar):\n    return calendar.lower() in _STANDARD_CALENDARS",
    ".xarray.coding.times.py@@_unpack_netcdf_time_units": "def _unpack_netcdf_time_units(units):\n    matches = re.match('(.+) since (.+)', units)\n    if not matches:\n        raise ValueError(f'invalid time units: {units}')\n    delta_units, ref_date = [s.strip() for s in matches.groups()]\n    ref_date = _ensure_padded_year(ref_date)\n    return (delta_units, ref_date)",
    ".xarray.coding.times.py@@_ensure_padded_year": "def _ensure_padded_year(ref_date):\n    matches_year = re.match('.*\\\\d{4}.*', ref_date)\n    if matches_year:\n        return ref_date\n    matches_start_digits = re.match('(\\\\d+)(.*)', ref_date)\n    ref_year, everything_else = [s for s in matches_start_digits.groups()]\n    ref_date_padded = '{:04d}{}'.format(int(ref_year), everything_else)\n    warning_msg = f'Ambiguous reference date string: {ref_date}. The first value is assumed to be the year hence will be padded with zeros to remove the ambiguity (the padded reference date string is: {ref_date_padded}). To remove this message, remove the ambiguity by padding your reference date strings with zeros.'\n    warnings.warn(warning_msg, SerializationWarning)\n    return ref_date_padded",
    ".xarray.coding.times.py@@_netcdf_to_numpy_timeunit": "def _netcdf_to_numpy_timeunit(units):\n    units = units.lower()\n    if not units.endswith('s'):\n        units = '%ss' % units\n    return {'nanoseconds': 'ns', 'microseconds': 'us', 'milliseconds': 'ms', 'seconds': 's', 'minutes': 'm', 'hours': 'h', 'days': 'D'}[units]"
}