{
    ".django.core.management.__init__.py@@get_commands": "def get_commands():\n    commands = {name: 'django.core' for name in find_commands(__path__[0])}\n    if not settings.configured:\n        return commands\n    for app_config in reversed(list(apps.get_app_configs())):\n        path = os.path.join(app_config.path, 'management')\n        commands.update({name: app_config.name for name in find_commands(path)})\n    return commands",
    ".django.core.management.__init__.py@@find_commands": "def find_commands(management_dir):\n    command_dir = os.path.join(management_dir, 'commands')\n    return [name for _, name, is_pkg in pkgutil.iter_modules([command_dir]) if not is_pkg and (not name.startswith('_'))]",
    ".django.conf.__init__.py@@LazySettings.configured": "def configured(self):\n    return self._wrapped is not empty",
    ".django.apps.registry.py@@Apps.get_app_configs": "def get_app_configs(self):\n    self.check_apps_ready()\n    return self.app_configs.values()",
    ".django.apps.registry.py@@Apps.check_apps_ready": "def check_apps_ready(self):\n    if not self.apps_ready:\n        from django.conf import settings\n        settings.INSTALLED_APPS\n        raise AppRegistryNotReady(\"Apps aren't loaded yet.\")",
    ".django.core.management.__init__.py@@load_command_class": "def load_command_class(app_name, name):\n    module = import_module('%s.management.commands.%s' % (app_name, name))\n    return module.Command()",
    ".django.core.management.base.py@@BaseCommand.__init__": "def __init__(self, stdout=None, stderr=None, no_color=False, force_color=False):\n    self.stdout = OutputWrapper(stdout or sys.stdout)\n    self.stderr = OutputWrapper(stderr or sys.stderr)\n    if no_color and force_color:\n        raise CommandError(\"'no_color' and 'force_color' can't be used together.\")\n    if no_color:\n        self.style = no_style()\n    else:\n        self.style = color_style(force_color)\n        self.stderr.style_func = self.style.ERROR\n    if not isinstance(self.requires_system_checks, (list, tuple)) and self.requires_system_checks != ALL_CHECKS:\n        raise TypeError('requires_system_checks must be a list or tuple.')",
    ".django.core.management.base.py@@OutputWrapper.__init__": "def __init__(self, out, ending='\\n'):\n    self._out = out\n    self.style_func = None\n    self.ending = ending",
    ".django.core.management.base.py@@OutputWrapper.style_func": "def style_func(self):\n    return self._style_func",
    ".django.core.management.color.py@@color_style": "def color_style(force_color=False):\n    if not force_color and (not supports_color()):\n        return no_style()\n    return make_style(os.environ.get('DJANGO_COLORS', ''))",
    ".django.core.management.color.py@@supports_color": "def supports_color():\n\n    def vt_codes_enabled_in_windows_registry():\n        try:\n            import winreg\n        except ImportError:\n            return False\n        else:\n            reg_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, 'Console')\n            try:\n                reg_key_value, _ = winreg.QueryValueEx(reg_key, 'VirtualTerminalLevel')\n            except FileNotFoundError:\n                return False\n            else:\n                return reg_key_value == 1\n    is_a_tty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()\n    return is_a_tty and (sys.platform != 'win32' or HAS_COLORAMA or 'ANSICON' in os.environ or ('WT_SESSION' in os.environ) or (os.environ.get('TERM_PROGRAM') == 'vscode') or vt_codes_enabled_in_windows_registry())",
    ".django.core.management.base.py@@OutputWrapper.isatty": "def isatty(self):\n    return hasattr(self._out, 'isatty') and self._out.isatty()",
    ".django.core.management.base.py@@BaseCommand.create_parser": "def create_parser(self, prog_name, subcommand, **kwargs):\n    parser = CommandParser(prog='%s %s' % (os.path.basename(prog_name), subcommand), description=self.help or None, formatter_class=DjangoHelpFormatter, missing_args_message=getattr(self, 'missing_args_message', None), called_from_command_line=getattr(self, '_called_from_command_line', None), **kwargs)\n    self.add_base_argument(parser, '--version', action='version', version=self.get_version(), help=\"Show program's version number and exit.\")\n    self.add_base_argument(parser, '-v', '--verbosity', default=1, type=int, choices=[0, 1, 2, 3], help='Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output')\n    self.add_base_argument(parser, '--settings', help='The Python path to a settings module, e.g. \"myproject.settings.main\". If this isn\\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.')\n    self.add_base_argument(parser, '--pythonpath', help='A directory to add to the Python path, e.g. \"/home/djangoprojects/myproject\".')\n    self.add_base_argument(parser, '--traceback', action='store_true', help='Raise on CommandError exceptions.')\n    self.add_base_argument(parser, '--no-color', action='store_true', help=\"Don't colorize the command output.\")\n    self.add_base_argument(parser, '--force-color', action='store_true', help='Force colorization of the command output.')\n    if self.requires_system_checks:\n        parser.add_argument('--skip-checks', action='store_true', help='Skip system checks.')\n    self.add_arguments(parser)\n    return parser",
    ".django.core.management.base.py@@CommandParser.__init__": "def __init__(self, *, missing_args_message=None, called_from_command_line=None, **kwargs):\n    self.missing_args_message = missing_args_message\n    self.called_from_command_line = called_from_command_line\n    super().__init__(**kwargs)",
    ".django.core.management.base.py@@BaseCommand.get_version": "def get_version(self):\n    return django.get_version()",
    ".django.utils.version.py@@get_version": "def get_version(version=None):\n    version = get_complete_version(version)\n    main = get_main_version(version)\n    sub = ''\n    if version[3] == 'alpha' and version[4] == 0:\n        git_changeset = get_git_changeset()\n        if git_changeset:\n            sub = '.dev%s' % git_changeset\n    elif version[3] != 'final':\n        mapping = {'alpha': 'a', 'beta': 'b', 'rc': 'rc'}\n        sub = mapping[version[3]] + str(version[4])\n    return main + sub",
    ".django.utils.version.py@@get_complete_version": "def get_complete_version(version=None):\n    if version is None:\n        from django import VERSION as version\n    else:\n        assert len(version) == 5\n        assert version[3] in ('alpha', 'beta', 'rc', 'final')\n    return version",
    ".django.utils.version.py@@get_main_version": "def get_main_version(version=None):\n    version = get_complete_version(version)\n    parts = 2 if version[2] == 0 else 3\n    return '.'.join((str(x) for x in version[:parts]))",
    ".django.core.management.base.py@@BaseCommand.add_base_argument": "def add_base_argument(self, parser, *args, **kwargs):\n    for arg in args:\n        if arg in self.suppressed_base_arguments:\n            kwargs['help'] = argparse.SUPPRESS\n            break\n    parser.add_argument(*args, **kwargs)",
    ".django.core.management.commands.check.py@@Command.add_arguments": "def add_arguments(self, parser):\n    parser.add_argument('args', metavar='app_label', nargs='*')\n    parser.add_argument('--tag', '-t', action='append', dest='tags', help='Run only checks labeled with given tag.')\n    parser.add_argument('--list-tags', action='store_true', help='List available tags.')\n    parser.add_argument('--deploy', action='store_true', help='Check deployment settings.')\n    parser.add_argument('--fail-level', default='ERROR', choices=['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG'], help='Message level that will cause the command to exit with a non-zero status. Default is ERROR.')\n    parser.add_argument('--database', action='append', dest='databases', help='Run database related checks against these aliases.')",
    ".django.core.management.base.py@@CommandParser.parse_args": "def parse_args(self, args=None, namespace=None):\n    if self.missing_args_message and (not (args or any((not arg.startswith('-') for arg in args)))):\n        self.error(self.missing_args_message)\n    return super().parse_args(args, namespace)",
    ".django.core.management.base.py@@no_translations": "def no_translations(handle_func):\n\n    def wrapped(*args, **kwargs):\n        from django.utils import translation\n        saved_locale = translation.get_language()\n        translation.deactivate_all()\n        try:\n            res = handle_func(*args, **kwargs)\n        finally:\n            if saved_locale is not None:\n                translation.activate(saved_locale)\n        return res\n    return wrapped",
    ".django.core.management.base.py@@BaseCommand.add_arguments": "def add_arguments(self, parser):\n    pass",
    ".django.core.management.base.py@@DjangoHelpFormatter.add_usage": "def add_usage(self, usage, actions, *args, **kwargs):\n    super().add_usage(usage, self._reordered_actions(actions), *args, **kwargs)",
    ".django.core.management.base.py@@DjangoHelpFormatter._reordered_actions": "def _reordered_actions(self, actions):\n    return sorted(actions, key=lambda a: set(a.option_strings) & self.show_last != set())"
}