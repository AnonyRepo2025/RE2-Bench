{
    ".astropy.utils.data_info.py@@DataInfo.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        self._parent_cls = owner_cls\n        return self\n    info = instance.__dict__.get('info')\n    if info is None:\n        info = instance.__dict__['info'] = self.__class__(bound=True)\n    info._parent_ref = weakref.ref(instance)\n    return info",
    ".astropy.utils.data_info.py@@ParentAttribute.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        return self\n    return getattr(instance._parent, self.attr)",
    ".astropy.utils.data_info.py@@DataInfo._parent": "def _parent(self):\n    try:\n        parent = self._parent_ref()\n    except AttributeError:\n        return None\n    if parent is None:\n        raise AttributeError('failed to access \"info\" attribute on a temporary object.\\n\\nIt looks like you have done something like ``col[3:5].info`` or\\n``col.quantity.info``, i.e.  you accessed ``info`` from a temporary slice\\nobject that only exists momentarily.  This has failed because the reference to\\nthat temporary object is now lost.  Instead force a permanent reference (e.g.\\n``c = col[3:5]`` followed by ``c.info``).')\n    return parent",
    ".astropy.table.column.py@@BaseColumn.name": "def name(self):\n    return self._name",
    ".astropy.utils.data_info.py@@dtype_info_name": "def dtype_info_name(dtype):\n    dtype = np.dtype(dtype)\n    if dtype.names is not None:\n        return '({})'.format(', '.join((dtype_info_name(dt[0]) for dt in dtype.fields.values())))\n    if dtype.subdtype is not None:\n        dtype, shape = dtype.subdtype\n    else:\n        shape = ()\n    if dtype.kind in ('S', 'U'):\n        type_name = 'bytes' if dtype.kind == 'S' else 'str'\n        length = re.search('(\\\\d+)', dtype.str).group(1)\n        out = type_name + length\n    else:\n        out = dtype.name\n    if shape:\n        out += f'[{','.join((str(n) for n in shape))}]'\n    return out",
    ".astropy.table.column.py@@BaseColumn.format": "def format(self):\n    return self._format",
    ".astropy.table.pprint.py@@get_auto_format_func": "def get_auto_format_func(col=None, possible_string_format_functions=_possible_string_format_functions):\n\n    def _auto_format_func(format_, val):\n        if format_ is None:\n            return default_format_func(format_, val)\n        if format_ in col.info._format_funcs:\n            return col.info._format_funcs[format_](format_, val)\n        if callable(format_):\n            format_func = lambda format_, val: format_(val)\n            try:\n                out = format_func(format_, val)\n                if not isinstance(out, str):\n                    raise ValueError('Format function for value {} returned {} instead of string type'.format(val, type(val)))\n            except Exception as err:\n                if val is np.ma.masked:\n                    return str(val)\n                raise ValueError(f'Format function for value {val} failed.') from err\n            try:\n                format_func(format_, np.ma.masked)\n            except Exception:\n                format_func = _use_str_for_masked_values(format_func)\n        else:\n            if val is np.ma.masked:\n                return str(val)\n            for format_func in possible_string_format_functions(format_):\n                try:\n                    out = format_func(format_, val)\n                    if out == format_:\n                        raise ValueError('the format passed in did nothing.')\n                except Exception:\n                    continue\n                else:\n                    break\n            else:\n                raise ValueError('unable to parse format string {} for its column.'.format(format_))\n            format_func = _use_str_for_masked_values(format_func)\n        col.info._format_funcs[format_] = format_func\n        return out\n    return _auto_format_func",
    ".astropy.table.pprint.py@@_auto_format_func": "def _auto_format_func(format_, val):\n    if format_ is None:\n        return default_format_func(format_, val)\n    if format_ in col.info._format_funcs:\n        return col.info._format_funcs[format_](format_, val)\n    if callable(format_):\n        format_func = lambda format_, val: format_(val)\n        try:\n            out = format_func(format_, val)\n            if not isinstance(out, str):\n                raise ValueError('Format function for value {} returned {} instead of string type'.format(val, type(val)))\n        except Exception as err:\n            if val is np.ma.masked:\n                return str(val)\n            raise ValueError(f'Format function for value {val} failed.') from err\n        try:\n            format_func(format_, np.ma.masked)\n        except Exception:\n            format_func = _use_str_for_masked_values(format_func)\n    else:\n        if val is np.ma.masked:\n            return str(val)\n        for format_func in possible_string_format_functions(format_):\n            try:\n                out = format_func(format_, val)\n                if out == format_:\n                    raise ValueError('the format passed in did nothing.')\n            except Exception:\n                continue\n            else:\n                break\n        else:\n            raise ValueError('unable to parse format string {} for its column.'.format(format_))\n        format_func = _use_str_for_masked_values(format_func)\n    col.info._format_funcs[format_] = format_func\n    return out",
    ".astropy.table.pprint.py@@default_format_func": "def default_format_func(format_, val):\n    if isinstance(val, bytes):\n        return val.decode('utf-8', errors='replace')\n    else:\n        return str(val)",
    ".astropy.table.column.py@@MaskedColumn.data": "def data(self):\n    out = self.view(np.ma.MaskedArray)\n    out._baseclass = np.ndarray\n    return out",
    ".astropy.table.column.py@@MaskedColumn._copy_attrs_slice": "def _copy_attrs_slice(self, out):\n    if out.__class__ is self.__class__:\n        if 'info' in self.__dict__:\n            out.info = self.info\n        out.parent_table = None\n        if out.indices is self.indices:\n            out.indices = []\n        out._copy_attrs(self)\n    return out",
    ".astropy.table.column.py@@BaseColumn.unit": "def unit(self):\n    return self._unit",
    ".astropy.units.core.py@@UnitBase.__str__": "def __str__(self):\n    return unit_format.Generic.to_string(self)",
    ".astropy.units.format.generic.py@@Generic.to_string": "def to_string(cls, unit):\n    return _to_string(cls, unit)",
    ".astropy.units.format.generic.py@@_to_string": "def _to_string(cls, unit):\n    if isinstance(unit, core.CompositeUnit):\n        parts = []\n        if cls._show_scale and unit.scale != 1:\n            parts.append(f'{unit.scale:g}')\n        if len(unit.bases):\n            positives, negatives = utils.get_grouped_by_powers(unit.bases, unit.powers)\n            if len(positives):\n                parts.append(cls._format_unit_list(positives))\n            elif len(parts) == 0:\n                parts.append('1')\n            if len(negatives):\n                parts.append('/')\n                unit_list = cls._format_unit_list(negatives)\n                if len(negatives) == 1:\n                    parts.append(f'{unit_list}')\n                else:\n                    parts.append(f'({unit_list})')\n        return ' '.join(parts)\n    elif isinstance(unit, core.NamedUnit):\n        return cls._get_unit_name(unit)",
    ".astropy.units.core.py@@CompositeUnit.scale": "def scale(self):\n    return self._scale",
    ".astropy.units.core.py@@CompositeUnit.bases": "def bases(self):\n    return self._bases",
    ".astropy.units.core.py@@CompositeUnit.powers": "def powers(self):\n    return self._powers",
    ".astropy.units.format.utils.py@@get_grouped_by_powers": "def get_grouped_by_powers(bases, powers):\n    positive = []\n    negative = []\n    for base, power in zip(bases, powers):\n        if power < 0:\n            negative.append((base, -power))\n        elif power > 0:\n            positive.append((base, power))\n        else:\n            raise ValueError('Unit with 0 power')\n    return (positive, negative)",
    ".astropy.units.format.generic.py@@Generic._format_unit_list": "def _format_unit_list(cls, units):\n    out = []\n    units.sort(key=lambda x: cls._get_unit_name(x[0]).lower())\n    for base, power in units:\n        if power == 1:\n            out.append(cls._get_unit_name(base))\n        else:\n            power = utils.format_power(power)\n            if '/' in power or '.' in power:\n                out.append(f'{cls._get_unit_name(base)}({power})')\n            else:\n                out.append(f'{cls._get_unit_name(base)}{power}')\n    return ' '.join(out)",
    ".astropy.units.format.generic.py@@Generic._get_unit_name": "def _get_unit_name(cls, unit):\n    return unit.get_format_name('generic')",
    ".astropy.units.core.py@@NamedUnit.get_format_name": "def get_format_name(self, format):\n    return self._format.get(format, self.name)",
    ".astropy.units.core.py@@NamedUnit.name": "def name(self):\n    return self._names[0]",
    ".astropy.units.format.utils.py@@format_power": "def format_power(power):\n    if not hasattr(power, 'denominator'):\n        power = maybe_simple_fraction(power)\n        if getattr(power, 'denonimator', None) == 1:\n            power = power.nominator\n    return str(power)",
    ".astropy.config.configuration.py@@ConfigItem.__get__": "def __get__(self, obj, objtype=None):\n    if obj is None:\n        return self\n    return self()",
    ".astropy.config.configuration.py@@ConfigItem.__call__": "def __call__(self):\n\n    def section_name(section):\n        if section == '':\n            return 'at the top-level'\n        else:\n            return f'in section [{section}]'\n    options = []\n    sec = get_config(self.module, rootname=self.rootname)\n    if self.name in sec:\n        options.append((sec[self.name], self.module, self.name))\n    for alias in self.aliases:\n        module, name = alias.rsplit('.', 1)\n        sec = get_config(module, rootname=self.rootname)\n        if '.' in module:\n            filename, module = module.split('.', 1)\n        else:\n            filename = module\n            module = ''\n        if name in sec:\n            if '.' in self.module:\n                new_module = self.module.split('.', 1)[1]\n            else:\n                new_module = ''\n            warn(\"Config parameter '{}' {} of the file '{}' is deprecated. Use '{}' {} instead.\".format(name, section_name(module), get_config_filename(filename, rootname=self.rootname), self.name, section_name(new_module)), AstropyDeprecationWarning)\n            options.append((sec[name], module, name))\n    if len(options) == 0:\n        self.set(self.defaultvalue)\n        options.append((self.defaultvalue, None, None))\n    if len(options) > 1:\n        filename, sec = self.module.split('.', 1)\n        warn(\"Config parameter '{}' {} of the file '{}' is given by more than one alias ({}). Using the first.\".format(self.name, section_name(sec), get_config_filename(filename, rootname=self.rootname), ', '.join(['.'.join(x[1:3]) for x in options if x[1] is not None])), AstropyDeprecationWarning)\n    val = options[0][0]\n    try:\n        return self._validate_val(val)\n    except validate.ValidateError as e:\n        raise TypeError('Configuration value not valid:' + e.args[0])",
    ".astropy.config.configuration.py@@get_config": "def get_config(packageormod=None, reload=False, rootname=None):\n    if packageormod is None:\n        packageormod = find_current_module(2)\n        if packageormod is None:\n            msg1 = 'Cannot automatically determine get_config module, '\n            msg2 = 'because it is not called from inside a valid module'\n            raise RuntimeError(msg1 + msg2)\n        else:\n            packageormod = packageormod.__name__\n        _autopkg = True\n    else:\n        _autopkg = False\n    packageormodspl = packageormod.split('.')\n    pkgname = packageormodspl[0]\n    secname = '.'.join(packageormodspl[1:])\n    if rootname is None:\n        if _autopkg:\n            rootname = pkgname\n        else:\n            rootname = 'astropy'\n    cobj = _cfgobjs.get(pkgname, None)\n    if cobj is None or reload:\n        cfgfn = None\n        try:\n            if _override_config_file is not None:\n                cfgfn = _override_config_file\n            else:\n                cfgfn = path.join(get_config_dir(rootname=rootname), pkgname + '.cfg')\n            cobj = configobj.ConfigObj(cfgfn, interpolation=False)\n        except OSError:\n            cobj = configobj.ConfigObj(interpolation=False)\n        _cfgobjs[pkgname] = cobj\n    if secname:\n        if secname not in cobj:\n            cobj[secname] = {}\n        return cobj[secname]\n    else:\n        return cobj",
    ".astropy.extern.configobj.configobj.py@@Section.__getitem__": "def __getitem__(self, key):\n    val = dict.__getitem__(self, key)\n    if self.main.interpolation:\n        if isinstance(val, str):\n            return self._interpolate(key, val)\n        if isinstance(val, list):\n\n            def _check(entry):\n                if isinstance(entry, str):\n                    return self._interpolate(key, entry)\n                return entry\n            new = [_check(entry) for entry in val]\n            if new != val:\n                return new\n    return val",
    ".astropy.config.configuration.py@@ConfigItem._validate_val": "def _validate_val(self, val):\n    return self._validator.check(self.cfgtype, val)",
    ".astropy.extern.configobj.validate.py@@Validator.check": "def check(self, check, value, missing=False):\n    fun_name, fun_args, fun_kwargs, default = self._parse_with_caching(check)\n    if missing:\n        if default is None:\n            raise VdtMissingValue()\n        value = self._handle_none(default)\n    if value is None:\n        return None\n    return self._check_value(value, fun_name, fun_args, fun_kwargs)",
    ".astropy.extern.configobj.validate.py@@Validator._parse_with_caching": "def _parse_with_caching(self, check):\n    if check in self._cache:\n        fun_name, fun_args, fun_kwargs, default = self._cache[check]\n        fun_args = list(fun_args)\n        fun_kwargs = dict(fun_kwargs)\n    else:\n        fun_name, fun_args, fun_kwargs, default = self._parse_check(check)\n        fun_kwargs = dict([(str(key), value) for key, value in list(fun_kwargs.items())])\n        self._cache[check] = (fun_name, list(fun_args), dict(fun_kwargs), default)\n    return (fun_name, fun_args, fun_kwargs, default)",
    ".astropy.utils.console.py@@terminal_size": "def terminal_size(file=None):\n    if file is None:\n        file = _get_stdout()\n    try:\n        s = struct.pack('HHHH', 0, 0, 0, 0)\n        x = fcntl.ioctl(file, termios.TIOCGWINSZ, s)\n        lines, width, xpixels, ypixels = struct.unpack('HHHH', x)\n        if lines > 12:\n            lines -= 6\n        if width > 10:\n            width -= 1\n        if lines <= 0 or width <= 0:\n            raise Exception('unable to get terminal size')\n        return (lines, width)\n    except Exception:\n        try:\n            return (int(os.environ.get('LINES')), int(os.environ.get('COLUMNS')))\n        except TypeError:\n            lines = conf.max_lines\n            width = conf.max_width\n            if lines is None:\n                lines = 25\n            if width is None:\n                width = 80\n            return (lines, width)",
    ".astropy.utils.console.py@@_get_stdout": "def _get_stdout(stderr=False):\n    if stderr:\n        stream = 'stderr'\n    else:\n        stream = 'stdout'\n    sys_stream = getattr(sys, stream)\n    return sys_stream",
    ".astropy.extern.configobj.validate.py@@Validator._check_value": "def _check_value(self, value, fun_name, fun_args, fun_kwargs):\n    try:\n        fun = self.functions[fun_name]\n    except KeyError:\n        raise VdtUnknownCheckError(fun_name)\n    else:\n        return fun(value, *fun_args, **fun_kwargs)",
    ".astropy.extern.configobj.validate.py@@is_integer": "def is_integer(value, min=None, max=None):\n    min_val, max_val = _is_num_param(('min', 'max'), (min, max))\n    if not isinstance(value, (int, long, string_type)):\n        raise VdtTypeError(value)\n    if isinstance(value, string_type):\n        try:\n            value = int(value)\n        except ValueError:\n            raise VdtTypeError(value)\n    if min_val is not None and value < min_val:\n        raise VdtValueTooSmallError(value)\n    if max_val is not None and value > max_val:\n        raise VdtValueTooBigError(value)\n    return value",
    ".astropy.extern.configobj.validate.py@@_is_num_param": "def _is_num_param(names, values, to_float=False):\n    fun = to_float and float or int\n    out_params = []\n    for name, val in zip(names, values):\n        if val is None:\n            out_params.append(val)\n        elif isinstance(val, (int, long, float, string_type)):\n            try:\n                out_params.append(fun(val))\n            except ValueError as e:\n                raise VdtParamError(name, val)\n        else:\n            raise VdtParamError(name, val)\n    return out_params",
    ".astropy.utils.data_info.py@@BaseColumnInfo.__init__": "def __init__(self, bound=False):\n    super().__init__(bound=bound)\n    if bound:\n        self._format_funcs = {}",
    ".astropy.utils.data_info.py@@DataInfo.__init__": "def __init__(self, bound=False):\n    if bound:\n        self._attrs = {}",
    ".astropy.utils.data_info.py@@MixinInfo.name": "def name(self):\n    return self._attrs.get('name')",
    ".astropy.units.quantity.py@@Quantity.unit": "def unit(self):\n    return self._unit",
    ".astropy.units.quantity.py@@Quantity.__len__": "def __len__(self):\n    if self.isscalar:\n        raise TypeError(\"'{cls}' object with a scalar value has no len()\".format(cls=self.__class__.__name__))\n    else:\n        return len(self.value)",
    ".astropy.units.quantity.py@@Quantity.isscalar": "def isscalar(self):\n    return not self.shape",
    ".astropy.units.quantity.py@@Quantity.to_value": "def to_value(self, unit=None, equivalencies=[]):\n    if unit is None or unit is self.unit:\n        value = self.view(np.ndarray)\n    elif not self.dtype.names:\n        unit = Unit(unit)\n        try:\n            scale = self.unit._to(unit)\n        except Exception:\n            value = self._to_value(unit, equivalencies)\n        else:\n            value = self.view(np.ndarray)\n            if not is_effectively_unity(scale):\n                value = value * scale\n    else:\n        value = self._to_value(unit, equivalencies)\n    return value if value.shape else value[()]",
    ".astropy.utils.data_info.py@@InfoAttribute.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        return self\n    return instance._attrs.get(self.attr, self.default)"
}