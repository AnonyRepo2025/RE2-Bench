{
    ".django.template.utils.py@@EngineHandler.all": "def all(self):\n    return [self[alias] for alias in self]",
    ".django.template.utils.py@@EngineHandler.__iter__": "def __iter__(self):\n    return iter(self.templates)",
    ".django.utils.functional.py@@cached_property.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    res = instance.__dict__[self.name] = self.func(instance)\n    return res",
    ".django.template.utils.py@@EngineHandler.templates": "def templates(self):\n    if self._templates is None:\n        self._templates = settings.TEMPLATES\n    templates = {}\n    backend_names = []\n    for tpl in self._templates:\n        try:\n            default_name = tpl['BACKEND'].rsplit('.', 2)[-2]\n        except Exception:\n            invalid_backend = tpl.get('BACKEND', '<not defined>')\n            raise ImproperlyConfigured('Invalid BACKEND for a template engine: {}. Check your TEMPLATES setting.'.format(invalid_backend))\n        tpl = {'NAME': default_name, 'DIRS': [], 'APP_DIRS': False, 'OPTIONS': {}, **tpl}\n        templates[tpl['NAME']] = tpl\n        backend_names.append(tpl['NAME'])\n    counts = Counter(backend_names)\n    duplicates = [alias for alias, count in counts.most_common() if count > 1]\n    if duplicates:\n        raise ImproperlyConfigured(\"Template engine aliases aren't unique, duplicates: {}. Set a unique NAME for each engine in settings.TEMPLATES.\".format(', '.join(duplicates)))\n    return templates",
    ".django.utils.functional.py@@LazyObject.__getattribute__": "def __getattribute__(self, name):\n    if name == '_wrapped':\n        return super().__getattribute__(name)\n    value = super().__getattribute__(name)\n    if not getattr(value, '_mask_wrapped', True):\n        raise AttributeError\n    return value",
    ".django.conf.__init__.py@@LazySettings.__getattr__": "def __getattr__(self, name):\n    if (_wrapped := self._wrapped) is empty:\n        self._setup(name)\n        _wrapped = self._wrapped\n    val = getattr(_wrapped, name)\n    if name in {'MEDIA_URL', 'STATIC_URL'} and val is not None:\n        val = self._add_script_prefix(val)\n    elif name == 'SECRET_KEY' and (not val):\n        raise ImproperlyConfigured('The SECRET_KEY setting must not be empty.')\n    self.__dict__[name] = val\n    return val",
    ".django.template.utils.py@@EngineHandler.__getitem__": "def __getitem__(self, alias):\n    try:\n        return self._engines[alias]\n    except KeyError:\n        try:\n            params = self.templates[alias]\n        except KeyError:\n            raise InvalidTemplateEngineError(\"Could not find config for '{}' in settings.TEMPLATES\".format(alias))\n        params = params.copy()\n        backend = params.pop('BACKEND')\n        engine_cls = import_string(backend)\n        engine = engine_cls(params)\n        self._engines[alias] = engine\n        return engine",
    ".django.utils.module_loading.py@@import_string": "def import_string(dotted_path):\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n    except ValueError as err:\n        raise ImportError(\"%s doesn't look like a module path\" % dotted_path) from err\n    try:\n        return cached_import(module_path, class_name)\n    except AttributeError as err:\n        raise ImportError('Module \"%s\" does not define a \"%s\" attribute/class' % (module_path, class_name)) from err",
    ".django.utils.module_loading.py@@cached_import": "def cached_import(module_path, class_name):\n    if not ((module := sys.modules.get(module_path)) and (spec := getattr(module, '__spec__', None)) and (getattr(spec, '_initializing', False) is False)):\n        module = import_module(module_path)\n    return getattr(module, class_name)",
    ".django.template.backends.django.py@@DjangoTemplates.__init__": "def __init__(self, params):\n    params = params.copy()\n    options = params.pop('OPTIONS').copy()\n    options.setdefault('autoescape', True)\n    options.setdefault('debug', settings.DEBUG)\n    options.setdefault('file_charset', 'utf-8')\n    libraries = options.get('libraries', {})\n    options['libraries'] = self.get_templatetag_libraries(libraries)\n    super().__init__(params)\n    self.engine = Engine(self.dirs, self.app_dirs, **options)",
    ".django.conf.__init__.py@@UserSettingsHolder.__getattr__": "def __getattr__(self, name):\n    if not name.isupper() or name in self._deleted:\n        raise AttributeError\n    return getattr(self.default_settings, name)",
    ".django.template.backends.django.py@@DjangoTemplates.get_templatetag_libraries": "def get_templatetag_libraries(self, custom_libraries):\n    libraries = get_installed_libraries()\n    libraries.update(custom_libraries)\n    return libraries",
    ".django.template.backends.django.py@@get_installed_libraries": "def get_installed_libraries():\n    return {module_name: full_name for module_name, full_name in get_template_tag_modules()}",
    ".django.template.backends.django.py@@get_template_tag_modules": "def get_template_tag_modules():\n    candidates = ['django.templatetags']\n    candidates.extend((f'{app_config.name}.templatetags' for app_config in apps.get_app_configs()))\n    for candidate in candidates:\n        try:\n            pkg = import_module(candidate)\n        except ImportError:\n            continue\n        if hasattr(pkg, '__path__'):\n            for name in get_package_libraries(pkg):\n                yield (name[len(candidate) + 1:], name)",
    ".django.apps.registry.py@@Apps.get_app_configs": "def get_app_configs(self):\n    self.check_apps_ready()\n    return self.app_configs.values()",
    ".django.apps.registry.py@@Apps.check_apps_ready": "def check_apps_ready(self):\n    if not self.apps_ready:\n        from django.conf import settings\n        settings.INSTALLED_APPS\n        raise AppRegistryNotReady(\"Apps aren't loaded yet.\")",
    ".django.template.backends.django.py@@get_package_libraries": "def get_package_libraries(pkg):\n    for entry in walk_packages(pkg.__path__, pkg.__name__ + '.'):\n        try:\n            module = import_module(entry[1])\n        except ImportError as e:\n            raise InvalidTemplateLibrary(\"Invalid template library specified. ImportError raised when trying to load '%s': %s\" % (entry[1], e)) from e\n        if hasattr(module, 'register'):\n            yield entry[1]",
    ".django.template.backends.base.py@@BaseEngine.__init__": "def __init__(self, params):\n    params = params.copy()\n    self.name = params.pop('NAME')\n    self.dirs = list(params.pop('DIRS'))\n    self.app_dirs = params.pop('APP_DIRS')\n    if params:\n        raise ImproperlyConfigured('Unknown parameters: {}'.format(', '.join(params)))",
    ".django.template.engine.py@@Engine.__init__": "def __init__(self, dirs=None, app_dirs=False, context_processors=None, debug=False, loaders=None, string_if_invalid='', file_charset='utf-8', libraries=None, builtins=None, autoescape=True):\n    if dirs is None:\n        dirs = []\n    if context_processors is None:\n        context_processors = []\n    if loaders is None:\n        loaders = ['django.template.loaders.filesystem.Loader']\n        if app_dirs:\n            loaders += ['django.template.loaders.app_directories.Loader']\n        if not debug:\n            loaders = [('django.template.loaders.cached.Loader', loaders)]\n    elif app_dirs:\n        raise ImproperlyConfigured('app_dirs must not be set when loaders is defined.')\n    if libraries is None:\n        libraries = {}\n    if builtins is None:\n        builtins = []\n    self.dirs = dirs\n    self.app_dirs = app_dirs\n    self.autoescape = autoescape\n    self.context_processors = context_processors\n    self.debug = debug\n    self.loaders = loaders\n    self.string_if_invalid = string_if_invalid\n    self.file_charset = file_charset\n    self.libraries = libraries\n    self.template_libraries = self.get_template_libraries(libraries)\n    self.builtins = self.default_builtins + builtins\n    self.template_builtins = self.get_template_builtins(self.builtins)",
    ".django.template.engine.py@@Engine.get_template_libraries": "def get_template_libraries(self, libraries):\n    loaded = {}\n    for name, path in libraries.items():\n        loaded[name] = import_library(path)\n    return loaded",
    ".django.template.library.py@@import_library": "def import_library(name):\n    try:\n        module = import_module(name)\n    except ImportError as e:\n        raise InvalidTemplateLibrary(\"Invalid template library specified. ImportError raised when trying to load '%s': %s\" % (name, e))\n    try:\n        return module.register\n    except AttributeError:\n        raise InvalidTemplateLibrary(\"Module  %s does not have a variable named 'register'\" % name)",
    ".django.template.engine.py@@Engine.get_template_builtins": "def get_template_builtins(self, builtins):\n    return [import_library(x) for x in builtins]",
    ".django.utils.functional.py@@cached_property.__init__": "def __init__(self, func, name=None):\n    from django.utils.deprecation import RemovedInDjango50Warning\n    if name is not None:\n        warnings.warn(\"The name argument is deprecated as it's unnecessary as of Python 3.6.\", RemovedInDjango50Warning, stacklevel=2)\n    self.real_func = func\n    self.__doc__ = getattr(func, '__doc__')",
    ".django.utils.functional.py@@cached_property.__set_name__": "def __set_name__(self, owner, name):\n    if self.name is None:\n        self.name = name\n        self.func = self.real_func\n    elif name != self.name:\n        raise TypeError('Cannot assign the same cached_property to two different names (%r and %r).' % (self.name, name))",
    ".django.template.backends.jinja2.py@@Jinja2.__init__": "def __init__(self, params):\n    params = params.copy()\n    options = params.pop('OPTIONS').copy()\n    super().__init__(params)\n    self.context_processors = options.pop('context_processors', [])\n    environment = options.pop('environment', 'jinja2.Environment')\n    environment_cls = import_string(environment)\n    if 'loader' not in options:\n        options['loader'] = jinja2.FileSystemLoader(self.template_dirs)\n    options.setdefault('autoescape', True)\n    options.setdefault('auto_reload', settings.DEBUG)\n    options.setdefault('undefined', jinja2.DebugUndefined if settings.DEBUG else jinja2.Undefined)\n    self.env = environment_cls(**options)",
    ".django.template.backends.base.py@@BaseEngine.template_dirs": "def template_dirs(self):\n    template_dirs = tuple(self.dirs)\n    if self.app_dirs:\n        template_dirs += get_app_template_dirs(self.app_dirname)\n    return template_dirs",
    ".django.template.utils.py@@get_app_template_dirs": "def get_app_template_dirs(dirname):\n    template_dirs = [Path(app_config.path) / dirname for app_config in apps.get_app_configs() if app_config.path and (Path(app_config.path) / dirname).is_dir()]\n    return tuple(template_dirs)",
    ".django.template.engine.py@@Engine.template_loaders": "def template_loaders(self):\n    return self.get_template_loaders(self.loaders)",
    ".django.template.engine.py@@Engine.get_template_loaders": "def get_template_loaders(self, template_loaders):\n    loaders = []\n    for template_loader in template_loaders:\n        loader = self.find_template_loader(template_loader)\n        if loader is not None:\n            loaders.append(loader)\n    return loaders",
    ".django.template.engine.py@@Engine.find_template_loader": "def find_template_loader(self, loader):\n    if isinstance(loader, (tuple, list)):\n        loader, *args = loader\n    else:\n        args = []\n    if isinstance(loader, str):\n        loader_class = import_string(loader)\n        return loader_class(self, *args)\n    else:\n        raise ImproperlyConfigured('Invalid value in template loaders configuration: %r' % loader)",
    ".django.template.loaders.cached.py@@Loader.__init__": "def __init__(self, engine, loaders):\n    self.get_template_cache = {}\n    self.loaders = engine.get_template_loaders(loaders)\n    super().__init__(engine)",
    ".django.template.loaders.filesystem.py@@Loader.__init__": "def __init__(self, engine, dirs=None):\n    super().__init__(engine)\n    self.dirs = dirs",
    ".django.template.loaders.base.py@@Loader.__init__": "def __init__(self, engine):\n    self.engine = engine",
    ".django.template.loaders.cached.py@@Loader.get_dirs": "def get_dirs(self):\n    for loader in self.loaders:\n        if hasattr(loader, 'get_dirs'):\n            yield from loader.get_dirs()",
    ".django.template.loaders.filesystem.py@@Loader.get_dirs": "def get_dirs(self):\n    return self.dirs if self.dirs is not None else self.engine.dirs",
    ".django.template.loaders.app_directories.py@@Loader.get_dirs": "def get_dirs(self):\n    return get_app_template_dirs('templates')",
    ".django.utils.autoreload.py@@is_django_path": "def is_django_path(path):\n    return Path(django.__file__).parent in Path(path).parents",
    ".django.utils._os.py@@to_path": "def to_path(value):\n    if isinstance(value, Path):\n        return value\n    elif not isinstance(value, str):\n        raise TypeError('Invalid path type: %s' % type(value).__name__)\n    return Path(value)",
    ".django.utils.functional.py@@lazy": "def lazy(func, *resultclasses):\n\n    @total_ordering\n    class __proxy__(Promise):\n        __prepared = False\n\n        def __init__(self, args, kw):\n            self.__args = args\n            self.__kw = kw\n            if not self.__prepared:\n                self.__prepare_class__()\n            self.__class__.__prepared = True\n\n        def __reduce__(self):\n            return (_lazy_proxy_unpickle, (func, self.__args, self.__kw) + resultclasses)\n\n        def __repr__(self):\n            return repr(self.__cast())\n\n        @classmethod\n        def __prepare_class__(cls):\n            for resultclass in resultclasses:\n                for type_ in resultclass.mro():\n                    for method_name in type_.__dict__:\n                        if hasattr(cls, method_name):\n                            continue\n                        meth = cls.__promise__(method_name)\n                        setattr(cls, method_name, meth)\n            cls._delegate_bytes = bytes in resultclasses\n            cls._delegate_text = str in resultclasses\n            if cls._delegate_bytes and cls._delegate_text:\n                raise ValueError('Cannot call lazy() with both bytes and text return types.')\n            if cls._delegate_text:\n                cls.__str__ = cls.__text_cast\n            elif cls._delegate_bytes:\n                cls.__bytes__ = cls.__bytes_cast\n\n        @classmethod\n        def __promise__(cls, method_name):\n\n            def __wrapper__(self, *args, **kw):\n                res = func(*self.__args, **self.__kw)\n                return getattr(res, method_name)(*args, **kw)\n            return __wrapper__\n\n        def __text_cast(self):\n            return func(*self.__args, **self.__kw)\n\n        def __bytes_cast(self):\n            return bytes(func(*self.__args, **self.__kw))\n\n        def __bytes_cast_encoded(self):\n            return func(*self.__args, **self.__kw).encode()\n\n        def __cast(self):\n            if self._delegate_bytes:\n                return self.__bytes_cast()\n            elif self._delegate_text:\n                return self.__text_cast()\n            else:\n                return func(*self.__args, **self.__kw)\n\n        def __str__(self):\n            return str(self.__cast())\n\n        def __eq__(self, other):\n            if isinstance(other, Promise):\n                other = other.__cast()\n            return self.__cast() == other\n\n        def __lt__(self, other):\n            if isinstance(other, Promise):\n                other = other.__cast()\n            return self.__cast() < other\n\n        def __hash__(self):\n            return hash(self.__cast())\n\n        def __mod__(self, rhs):\n            if self._delegate_text:\n                return str(self) % rhs\n            return self.__cast() % rhs\n\n        def __add__(self, other):\n            return self.__cast() + other\n\n        def __radd__(self, other):\n            return other + self.__cast()\n\n        def __deepcopy__(self, memo):\n            memo[id(self)] = self\n            return self\n\n    @wraps(func)\n    def __wrapper__(*args, **kw):\n        return __proxy__(args, kw)\n    return __wrapper__",
    ".django.template.backends.dummy.py@@TemplateStrings.__init__": "def __init__(self, params):\n    params = params.copy()\n    options = params.pop('OPTIONS').copy()\n    if options:\n        raise ImproperlyConfigured('Unknown options: {}'.format(', '.join(options)))\n    super().__init__(params)"
}