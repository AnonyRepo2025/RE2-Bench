{
    ".django.core.cache.backends.base.py@@BaseCache.make_and_validate_key": "def make_and_validate_key(self, key, version=None):\n    key = self.make_key(key, version=version)\n    self.validate_key(key)\n    return key",
    ".django.core.cache.backends.base.py@@BaseCache.make_key": "def make_key(self, key, version=None):\n    if version is None:\n        version = self.version\n    return self.key_func(key, self.key_prefix, version)",
    ".django.core.cache.backends.base.py@@default_key_func": "def default_key_func(key, key_prefix, version):\n    return '%s:%s:%s' % (key_prefix, version, key)",
    ".django.core.cache.backends.base.py@@BaseCache.validate_key": "def validate_key(self, key):\n    for warning in memcache_key_warnings(key):\n        warnings.warn(warning, CacheKeyWarning)",
    ".django.core.cache.backends.base.py@@memcache_key_warnings": "def memcache_key_warnings(key):\n    if len(key) > MEMCACHE_MAX_KEY_LENGTH:\n        yield ('Cache key will cause errors if used with memcached: %r (longer than %s)' % (key, MEMCACHE_MAX_KEY_LENGTH))\n    for char in key:\n        if ord(char) < 33 or ord(char) == 127:\n            yield ('Cache key contains characters that will cause errors if used with memcached: %r' % key)\n            break",
    ".django.core.cache.backends.base.py@@BaseCache.get_backend_timeout": "def get_backend_timeout(self, timeout=DEFAULT_TIMEOUT):\n    if timeout == DEFAULT_TIMEOUT:\n        timeout = self.default_timeout\n    elif timeout == 0:\n        timeout = -1\n    return None if timeout is None else time.time() + timeout",
    ".django.utils.connection.py@@ConnectionProxy.__getattr__": "def __getattr__(self, item):\n    return getattr(self._connections[self._alias], item)",
    ".django.utils.connection.py@@BaseConnectionHandler.__getitem__": "def __getitem__(self, alias):\n    try:\n        return getattr(self._connections, alias)\n    except AttributeError:\n        if alias not in self.settings:\n            raise self.exception_class(f\"The connection '{alias}' doesn't exist.\")\n    conn = self.create_connection(alias)\n    setattr(self._connections, alias, conn)\n    return conn"
}