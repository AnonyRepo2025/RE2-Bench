{
    ".xarray.core.utils.py@@compat_dict_union": "def compat_dict_union(first_dict: Mapping[K, V], second_dict: Mapping[K, V], compat: Callable[[V, V], bool]=equivalent) -> MutableMapping[K, V]:\n    new_dict = dict(first_dict)\n    update_safety_check(first_dict, second_dict, compat)\n    new_dict.update(second_dict)\n    return new_dict",
    ".xarray.core.utils.py@@update_safety_check": "def update_safety_check(first_dict: Mapping[K, V], second_dict: Mapping[K, V], compat: Callable[[V, V], bool]=equivalent) -> None:\n    for k, v in second_dict.items():\n        if k in first_dict and (not compat(v, first_dict[k])):\n            raise ValueError('unsafe to merge dictionaries without overriding values; conflicting key %r' % k)",
    ".xarray.core.utils.py@@equivalent": "def equivalent(first: T, second: T) -> bool:\n    from . import duck_array_ops\n    if isinstance(first, np.ndarray) or isinstance(second, np.ndarray):\n        return duck_array_ops.array_equiv(first, second)\n    elif isinstance(first, list) or isinstance(second, list):\n        return list_equiv(first, second)\n    else:\n        return first is second or first == second or (pd.isnull(first) and pd.isnull(second))",
    ".xarray.core.utils.py@@dict_equiv": "def dict_equiv(first: Mapping[K, V], second: Mapping[K, V], compat: Callable[[V, V], bool]=equivalent) -> bool:\n    for k in first:\n        if k not in second or not compat(first[k], second[k]):\n            return False\n    for k in second:\n        if k not in first:\n            return False\n    return True"
}