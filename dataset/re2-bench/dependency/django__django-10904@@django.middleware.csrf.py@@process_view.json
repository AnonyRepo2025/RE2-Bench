{
    ".django.http.request.py@@HttpRequest.is_secure": "def is_secure(self):\n    return self.scheme == 'https'",
    ".django.http.request.py@@HttpRequest.scheme": "def scheme(self):\n    if settings.SECURE_PROXY_SSL_HEADER:\n        try:\n            header, value = settings.SECURE_PROXY_SSL_HEADER\n        except ValueError:\n            raise ImproperlyConfigured('The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.')\n        if self.META.get(header) == value:\n            return 'https'\n    return self._get_scheme()",
    ".django.core.handlers.wsgi.py@@WSGIRequest._get_scheme": "def _get_scheme(self):\n    return self.environ.get('wsgi.url_scheme')",
    ".django.utils.datastructures.py@@MultiValueDict.get": "def get(self, key, default=None):\n    try:\n        val = self[key]\n    except KeyError:\n        return default\n    if val == []:\n        return default\n    return val",
    ".django.utils.datastructures.py@@MultiValueDict.__getitem__": "def __getitem__(self, key):\n    try:\n        list_ = super().__getitem__(key)\n    except KeyError:\n        raise MultiValueDictKeyError(key)\n    try:\n        return list_[-1]\n    except IndexError:\n        return []",
    ".django.middleware.csrf.py@@_sanitize_token": "def _sanitize_token(token):\n    if re.search('[^a-zA-Z0-9]', token):\n        return _get_new_csrf_token()\n    elif len(token) == CSRF_TOKEN_LENGTH:\n        return token\n    elif len(token) == CSRF_SECRET_LENGTH:\n        return _salt_cipher_secret(token)\n    return _get_new_csrf_token()",
    ".django.middleware.csrf.py@@_salt_cipher_secret": "def _salt_cipher_secret(secret):\n    salt = _get_new_csrf_string()\n    chars = CSRF_ALLOWED_CHARS\n    pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in salt))\n    cipher = ''.join((chars[(x + y) % len(chars)] for x, y in pairs))\n    return salt + cipher",
    ".django.middleware.csrf.py@@_get_new_csrf_string": "def _get_new_csrf_string():\n    return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)",
    ".django.utils.crypto.py@@get_random_string": "def get_random_string(length=12, allowed_chars='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'):\n    if not using_sysrandom:\n        random.seed(hashlib.sha256(('%s%s%s' % (random.getstate(), time.time(), settings.SECRET_KEY)).encode()).digest())\n    return ''.join((random.choice(allowed_chars) for i in range(length)))",
    ".django.middleware.csrf.py@@_compare_salted_tokens": "def _compare_salted_tokens(request_csrf_token, csrf_token):\n    return constant_time_compare(_unsalt_cipher_token(request_csrf_token), _unsalt_cipher_token(csrf_token))",
    ".django.middleware.csrf.py@@_unsalt_cipher_token": "def _unsalt_cipher_token(token):\n    salt = token[:CSRF_SECRET_LENGTH]\n    token = token[CSRF_SECRET_LENGTH:]\n    chars = CSRF_ALLOWED_CHARS\n    pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in salt))\n    secret = ''.join((chars[x - y] for x, y in pairs))\n    return secret",
    ".django.utils.crypto.py@@constant_time_compare": "def constant_time_compare(val1, val2):\n    return hmac.compare_digest(force_bytes(val1), force_bytes(val2))",
    ".django.utils.encoding.py@@force_bytes": "def force_bytes(s, encoding='utf-8', strings_only=False, errors='strict'):\n    if isinstance(s, bytes):\n        if encoding == 'utf-8':\n            return s\n        else:\n            return s.decode('utf-8', errors).encode(encoding, errors)\n    if strings_only and is_protected_type(s):\n        return s\n    if isinstance(s, memoryview):\n        return bytes(s)\n    return str(s).encode(encoding, errors)",
    ".django.conf.__init__.py@@LazySettings.__getattr__": "def __getattr__(self, name):\n    if self._wrapped is empty:\n        self._setup(name)\n    val = getattr(self._wrapped, name)\n    self.__dict__[name] = val\n    return val",
    ".django.middleware.csrf.py@@_get_new_csrf_token": "def _get_new_csrf_token():\n    return _salt_cipher_secret(_get_new_csrf_string())",
    ".django.conf.__init__.py@@UserSettingsHolder.__getattr__": "def __getattr__(self, name):\n    if name in self._deleted:\n        raise AttributeError\n    return getattr(self.default_settings, name)",
    ".django.http.request.py@@HttpRequest.get_host": "def get_host(self):\n    host = self._get_raw_host()\n    allowed_hosts = settings.ALLOWED_HOSTS\n    if settings.DEBUG and (not allowed_hosts):\n        allowed_hosts = ['localhost', '127.0.0.1', '[::1]']\n    domain, port = split_domain_port(host)\n    if domain and validate_host(domain, allowed_hosts):\n        return host\n    else:\n        msg = 'Invalid HTTP_HOST header: %r.' % host\n        if domain:\n            msg += ' You may need to add %r to ALLOWED_HOSTS.' % domain\n        else:\n            msg += ' The domain name provided is not valid according to RFC 1034/1035.'\n        raise DisallowedHost(msg)",
    ".django.http.request.py@@HttpRequest._get_raw_host": "def _get_raw_host(self):\n    if settings.USE_X_FORWARDED_HOST and 'HTTP_X_FORWARDED_HOST' in self.META:\n        host = self.META['HTTP_X_FORWARDED_HOST']\n    elif 'HTTP_HOST' in self.META:\n        host = self.META['HTTP_HOST']\n    else:\n        host = self.META['SERVER_NAME']\n        server_port = self.get_port()\n        if server_port != ('443' if self.is_secure() else '80'):\n            host = '%s:%s' % (host, server_port)\n    return host",
    ".django.http.request.py@@split_domain_port": "def split_domain_port(host):\n    host = host.lower()\n    if not host_validation_re.match(host):\n        return ('', '')\n    if host[-1] == ']':\n        return (host, '')\n    bits = host.rsplit(':', 1)\n    domain, port = bits if len(bits) == 2 else (bits[0], '')\n    domain = domain[:-1] if domain.endswith('.') else domain\n    return (domain, port)",
    ".django.http.request.py@@validate_host": "def validate_host(host, allowed_hosts):\n    return any((pattern == '*' or is_same_domain(host, pattern) for pattern in allowed_hosts))",
    ".django.utils.http.py@@is_same_domain": "def is_same_domain(host, pattern):\n    if not pattern:\n        return False\n    pattern = pattern.lower()\n    return pattern[0] == '.' and (host.endswith(pattern) or host == pattern[1:]) or pattern == host",
    ".django.http.request.py@@HttpRequest.get_port": "def get_port(self):\n    if settings.USE_X_FORWARDED_PORT and 'HTTP_X_FORWARDED_PORT' in self.META:\n        port = self.META['HTTP_X_FORWARDED_PORT']\n    else:\n        port = self.META['SERVER_PORT']\n    return str(port)",
    ".django.http.request.py@@HttpRequest._get_scheme": "def _get_scheme(self):\n    return 'http'"
}