{
    ".xarray.coding.times.py@@_cleanup_netcdf_time_units": "def _cleanup_netcdf_time_units(units):\n    delta, ref_date = _unpack_netcdf_time_units(units)\n    try:\n        units = '{} since {}'.format(delta, format_timestamp(ref_date))\n    except OutOfBoundsDatetime:\n        pass\n    return units",
    ".xarray.coding.times.py@@_unpack_netcdf_time_units": "def _unpack_netcdf_time_units(units):\n    matches = re.match('(.+) since (.+)', units)\n    if not matches:\n        raise ValueError(f'invalid time units: {units}')\n    delta_units, ref_date = [s.strip() for s in matches.groups()]\n    ref_date = _ensure_padded_year(ref_date)\n    return (delta_units, ref_date)",
    ".xarray.coding.times.py@@_ensure_padded_year": "def _ensure_padded_year(ref_date):\n    matches_year = re.match('.*\\\\d{4}.*', ref_date)\n    if matches_year:\n        return ref_date\n    matches_start_digits = re.match('(\\\\d+)(.*)', ref_date)\n    ref_year, everything_else = [s for s in matches_start_digits.groups()]\n    ref_date_padded = '{:04d}{}'.format(int(ref_year), everything_else)\n    warning_msg = f'Ambiguous reference date string: {ref_date}. The first value is assumed to be the year hence will be padded with zeros to remove the ambiguity (the padded reference date string is: {ref_date_padded}). To remove this message, remove the ambiguity by padding your reference date strings with zeros.'\n    warnings.warn(warning_msg, SerializationWarning)\n    return ref_date_padded",
    ".xarray.core.formatting.py@@format_timestamp": "def format_timestamp(t):\n    try:\n        datetime_str = str(pd.Timestamp(t))\n    except OutOfBoundsDatetime:\n        datetime_str = str(t)\n    try:\n        date_str, time_str = datetime_str.split()\n    except ValueError:\n        return datetime_str\n    else:\n        if time_str == '00:00:00':\n            return date_str\n        else:\n            return f'{date_str}T{time_str}'",
    ".xarray.coding.times.py@@_netcdf_to_numpy_timeunit": "def _netcdf_to_numpy_timeunit(units):\n    units = units.lower()\n    if not units.endswith('s'):\n        units = '%ss' % units\n    return {'nanoseconds': 'ns', 'microseconds': 'us', 'milliseconds': 'ms', 'seconds': 's', 'minutes': 'm', 'hours': 'h', 'days': 'D'}[units]",
    ".xarray.coding.times.py@@cast_to_int_if_safe": "def cast_to_int_if_safe(num):\n    int_num = np.array(num, dtype=np.int64)\n    if (num == int_num).all():\n        num = int_num\n    return num",
    ".xarray.coding.times.py@@_encode_datetime_with_cftime": "def _encode_datetime_with_cftime(dates, units, calendar):\n    import cftime\n    if np.issubdtype(dates.dtype, np.datetime64):\n        dates = dates.astype('M8[us]').astype(datetime)\n\n    def encode_datetime(d):\n        return np.nan if d is None else cftime.date2num(d, units, calendar)\n    return np.vectorize(encode_datetime)(dates)",
    ".xarray.coding.times.py@@encode_datetime": "def encode_datetime(d):\n    return np.nan if d is None else cftime.date2num(d, units, calendar)",
    ".xarray.coding.times.py@@infer_datetime_units": "def infer_datetime_units(dates):\n    dates = np.asarray(dates).ravel()\n    if np.asarray(dates).dtype == 'datetime64[ns]':\n        dates = to_datetime_unboxed(dates)\n        dates = dates[pd.notnull(dates)]\n        reference_date = dates[0] if len(dates) > 0 else '1970-01-01'\n        reference_date = pd.Timestamp(reference_date)\n    else:\n        reference_date = dates[0] if len(dates) > 0 else '1970-01-01'\n        reference_date = format_cftime_datetime(reference_date)\n    unique_timedeltas = np.unique(np.diff(dates))\n    if unique_timedeltas.dtype == np.dtype('O'):\n        unique_timedeltas = to_timedelta_unboxed(unique_timedeltas)\n    units = _infer_time_units_from_diff(unique_timedeltas)\n    return f'{units} since {reference_date}'",
    ".xarray.coding.times.py@@to_datetime_unboxed": "def to_datetime_unboxed(value, **kwargs):\n    if LooseVersion(pd.__version__) < '0.25.0':\n        result = pd.to_datetime(value, **kwargs, box=False)\n    else:\n        result = pd.to_datetime(value, **kwargs).to_numpy()\n    assert result.dtype == 'datetime64[ns]'\n    return result",
    ".xarray.coding.times.py@@_infer_time_units_from_diff": "def _infer_time_units_from_diff(unique_timedeltas):\n    unique_deltas_as_index = pd.TimedeltaIndex(unique_timedeltas)\n    for time_unit in ['days', 'hours', 'minutes', 'seconds', 'milliseconds', 'microseconds', 'nanoseconds']:\n        delta_ns = _NS_PER_TIME_DELTA[_netcdf_to_numpy_timeunit(time_unit)]\n        unit_delta = np.timedelta64(delta_ns, 'ns')\n        if np.all(unique_deltas_as_index % unit_delta == np.timedelta64(0, 'ns')):\n            return time_unit\n    return 'seconds'",
    ".xarray.coding.times.py@@infer_calendar_name": "def infer_calendar_name(dates):\n    if np.asarray(dates).dtype == 'datetime64[ns]':\n        return 'proleptic_gregorian'\n    else:\n        return np.asarray(dates).ravel()[0].calendar"
}