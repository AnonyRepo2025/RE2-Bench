{
    ".sphinx.util.logging.py@@InfoFilter.filter": "def filter(self, record: logging.LogRecord) -> bool:\n    return record.levelno < logging.WARNING",
    ".sphinx.util.logging.py@@SphinxLogRecord.getMessage": "def getMessage(self) -> str:\n    message = super().getMessage()\n    location = getattr(self, 'location', None)\n    if location:\n        message = f'{location}: {self.prefix}{message}'\n    elif self.prefix not in message:\n        message = self.prefix + message\n    return message",
    ".sphinx.util.logging.py@@LastMessagesWriter.write": "def write(self, data: str) -> None:\n    self.app.messagelog.append(data)",
    ".sphinx.util.console.py@@inner": "def inner(text: str) -> str:\n    return colorize(name, text)",
    ".sphinx.util.console.py@@colorize": "def colorize(name: str, text: str, input_mode: bool=False) -> str:\n\n    def escseq(name: str) -> str:\n        escape = codes.get(name, '')\n        if input_mode and escape and (sys.platform != 'win32'):\n            return '\\x01' + escape + '\\x02'\n        else:\n            return escape\n    return escseq(name) + text + escseq('reset')",
    ".sphinx.util.console.py@@escseq": "def escseq(name: str) -> str:\n    escape = codes.get(name, '')\n    if input_mode and escape and (sys.platform != 'win32'):\n        return '\\x01' + escape + '\\x02'\n    else:\n        return escape",
    ".sphinx.util.requests.py@@_Session.request": "def request(self, method: str, url: str, _user_agent: str='', _tls_info: tuple[bool, str | dict[str, str] | None]=(), **kwargs: Any) -> requests.Response:\n    headers = kwargs.setdefault('headers', {})\n    headers.setdefault('User-Agent', _user_agent or _USER_AGENT)\n    if _tls_info:\n        tls_verify, tls_cacerts = _tls_info\n        verify = bool(kwargs.get('verify', tls_verify))\n        kwargs.setdefault('verify', verify and _get_tls_cacert(url, tls_cacerts))\n    else:\n        verify = kwargs.get('verify', True)\n    if verify:\n        return super().request(method, url, **kwargs)\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', category=InsecureRequestWarning)\n        return super().request(method, url, **kwargs)",
    ".sphinx.util.logging.py@@SphinxLoggerAdapter.log": "def log(self, level: int | str, msg: str, *args: Any, **kwargs: Any) -> None:\n    if isinstance(level, int):\n        super().log(level, msg, *args, **kwargs)\n    else:\n        levelno = LEVEL_NAMES[level]\n        super().log(levelno, msg, *args, **kwargs)",
    ".sphinx.util.logging.py@@SphinxLoggerAdapter.process": "def process(self, msg: str, kwargs: dict) -> tuple[str, dict]:\n    extra = kwargs.setdefault('extra', {})\n    for keyword in self.KEYWORDS:\n        if keyword in kwargs:\n            extra[keyword] = kwargs.pop(keyword)\n    return (msg, kwargs)",
    ".sphinx.util.logging.py@@SphinxLogRecordTranslator.filter": "def filter(self, record: SphinxWarningLogRecord) -> bool:\n    if isinstance(record, logging.LogRecord):\n        record.__class__ = self.LogRecordClass\n    location = getattr(record, 'location', None)\n    if isinstance(location, tuple):\n        docname, lineno = location\n        if docname:\n            if lineno:\n                record.location = f'{self.app.env.doc2path(docname)}:{lineno}'\n            else:\n                record.location = f'{self.app.env.doc2path(docname)}'\n        else:\n            record.location = None\n    elif isinstance(location, nodes.Node):\n        record.location = get_node_location(location)\n    elif location and ':' not in location:\n        record.location = f'{self.app.env.doc2path(location)}'\n    return True",
    ".sphinx.util.logging.py@@NewLineStreamHandler.emit": "def emit(self, record: logging.LogRecord) -> None:\n    try:\n        self.acquire()\n        if getattr(record, 'nonl', False):\n            self.terminator = ''\n        super().emit(record)\n    finally:\n        self.terminator = '\\n'\n        self.release()",
    ".sphinx.util.logging.py@@ColorizeFormatter.format": "def format(self, record: logging.LogRecord) -> str:\n    message = super().format(record)\n    color = getattr(record, 'color', None)\n    if color is None:\n        color = COLOR_MAP.get(record.levelno)\n    if color:\n        return colorize(color, message)\n    else:\n        return message",
    ".sphinx.util.requests.py@@_get_tls_cacert": "def _get_tls_cacert(url: str, certs: str | dict[str, str] | None) -> str | bool:\n    if not certs:\n        return True\n    elif isinstance(certs, (str, tuple)):\n        return certs\n    else:\n        hostname = urlsplit(url).netloc\n        if '@' in hostname:\n            _, hostname = hostname.split('@', 1)\n        return certs.get(hostname, True)",
    ".sphinx.util.logging.py@@SafeEncodingWriter.write": "def write(self, data: str) -> None:\n    try:\n        self.stream.write(data)\n    except UnicodeEncodeError:\n        self.stream.write(data.encode(self.encoding, 'replace').decode(self.encoding))",
    ".sphinx.util.logging.py@@SafeEncodingWriter.flush": "def flush(self) -> None:\n    if hasattr(self.stream, 'flush'):\n        self.stream.flush()",
    ".sphinx.builders.linkcheck.py@@_get_request_headers": "def _get_request_headers(uri: str, request_headers: dict[str, dict[str, str]]) -> dict[str, str]:\n    url = urlsplit(uri)\n    candidates = (f'{url.scheme}://{url.netloc}', f'{url.scheme}://{url.netloc}/', uri, '*')\n    for u in candidates:\n        if u in request_headers:\n            return {**DEFAULT_REQUEST_HEADERS, **request_headers[u]}\n    return {}",
    ".sphinx.builders.linkcheck.py@@contains_anchor": "def contains_anchor(response: Response, anchor: str) -> bool:\n    parser = AnchorCheckParser(unquote(anchor))\n    for chunk in response.iter_content(chunk_size=4096, decode_unicode=True):\n        if isinstance(chunk, bytes):\n            chunk = chunk.decode()\n        parser.feed(chunk)\n        if parser.found:\n            break\n    parser.close()\n    return parser.found",
    ".sphinx.builders.linkcheck.py@@AnchorCheckParser.__init__": "def __init__(self, search_anchor: str) -> None:\n    super().__init__()\n    self.search_anchor = search_anchor\n    self.found = False",
    ".sphinx.locale.__init__.py@@gettext": "def gettext(message: str) -> str:\n    if not is_translator_registered(catalog, namespace):\n        return _TranslationProxy(catalog, namespace, message)\n    else:\n        translator = get_translator(catalog, namespace)\n        return translator.gettext(message)",
    ".sphinx.locale.__init__.py@@is_translator_registered": "def is_translator_registered(catalog: str='sphinx', namespace: str='general') -> bool:\n    return (namespace, catalog) in translators",
    ".sphinx.locale.__init__.py@@_TranslationProxy.__init__": "def __init__(self, catalogue: str, namespace: str, message: str) -> None:\n    self._catalogue = catalogue\n    self._namespace = namespace\n    self._message = message",
    ".sphinx.environment.__init__.py@@BuildEnvironment.doc2path": "def doc2path(self, docname: str, base: bool=True) -> str:\n    return self.project.doc2path(docname, base)",
    ".sphinx.project.py@@Project.doc2path": "def doc2path(self, docname: str, basedir: bool=True) -> str:\n    docname = docname.replace(SEP, os.path.sep)\n    basename = os.path.join(self.srcdir, docname)\n    for suffix in self.source_suffix:\n        if os.path.isfile(basename + suffix):\n            break\n    else:\n        suffix = list(self.source_suffix)[0]\n    if basedir:\n        return basename + suffix\n    else:\n        return docname + suffix",
    ".sphinx.builders.linkcheck.py@@CheckExternalLinksBuilder.write_linkstat": "def write_linkstat(self, data: dict) -> None:\n    self.json_outfile.write(json.dumps(data))\n    self.json_outfile.write('\\n')",
    ".sphinx.builders.linkcheck.py@@CheckExternalLinksBuilder.process_result": "def process_result(self, result: CheckResult) -> None:\n    filename = self.env.doc2path(result.docname, False)\n    linkstat = {'filename': filename, 'lineno': result.lineno, 'status': result.status, 'code': result.code, 'uri': result.uri, 'info': result.message}\n    self.write_linkstat(linkstat)\n    if result.status == 'unchecked':\n        return\n    if result.status == 'working' and result.message == 'old':\n        return\n    if result.lineno:\n        logger.info('(%16s: line %4d) ', result.docname, result.lineno, nonl=True)\n    if result.status == 'ignored':\n        if result.message:\n            logger.info(darkgray('-ignored- ') + result.uri + ': ' + result.message)\n        else:\n            logger.info(darkgray('-ignored- ') + result.uri)\n    elif result.status == 'local':\n        logger.info(darkgray('-local-   ') + result.uri)\n        self.write_entry('local', result.docname, filename, result.lineno, result.uri)\n    elif result.status == 'working':\n        logger.info(darkgreen('ok        ') + result.uri + result.message)\n    elif result.status == 'broken':\n        if self.app.quiet or self.app.warningiserror:\n            logger.warning(__('broken link: %s (%s)'), result.uri, result.message, location=(result.docname, result.lineno))\n        else:\n            logger.info(red('broken    ') + result.uri + red(' - ' + result.message))\n        self.write_entry('broken', result.docname, filename, result.lineno, result.uri + ': ' + result.message)\n        self.broken_hyperlinks += 1\n    elif result.status == 'redirected':\n        try:\n            text, color = {301: ('permanently', purple), 302: ('with Found', purple), 303: ('with See Other', purple), 307: ('temporarily', turquoise), 308: ('permanently', purple)}[result.code]\n        except KeyError:\n            text, color = ('with unknown code', purple)\n        linkstat['text'] = text\n        if self.config.linkcheck_allowed_redirects:\n            logger.warning('redirect  ' + result.uri + ' - ' + text + ' to ' + result.message, location=(result.docname, result.lineno))\n        else:\n            logger.info(color('redirect  ') + result.uri + color(' - ' + text + ' to ' + result.message))\n        self.write_entry('redirected ' + text, result.docname, filename, result.lineno, result.uri + ' to ' + result.message)\n    else:\n        raise ValueError('Unknown status %s.' % result.status)",
    ".sphinx.builders.linkcheck.py@@_allowed_redirect": "def _allowed_redirect(url: str, new_url: str, allowed_redirects: dict[re.Pattern[str], re.Pattern[str]]) -> bool:\n    return any((from_url.match(url) and to_url.match(new_url) for from_url, to_url in allowed_redirects.items()))"
}