{
    ".sympy.external.pythonmpq.py@@PythonMPQ.__pow__": "def __pow__(self, exp):\n    p, q = (self.numerator, self.denominator)\n    if exp < 0:\n        p, q, exp = (q, p, -exp)\n    return self._new_check(p ** exp, q ** exp)",
    ".sympy.external.pythonmpq.py@@PythonMPQ._new_check": "def _new_check(cls, numerator, denominator):\n    if not denominator:\n        raise ZeroDivisionError(f'Zero divisor {numerator}/{denominator}')\n    elif denominator < 0:\n        numerator = -numerator\n        denominator = -denominator\n    return cls._new(numerator, denominator)",
    ".sympy.external.pythonmpq.py@@PythonMPQ._new": "def _new(cls, numerator, denominator):\n    obj = super().__new__(cls)\n    obj.numerator = numerator\n    obj.denominator = denominator\n    return obj",
    ".sympy.external.pythonmpq.py@@PythonMPQ.__mul__": "def __mul__(self, other):\n    if isinstance(other, PythonMPQ):\n        ap, aq = (self.numerator, self.denominator)\n        bp, bq = (other.numerator, other.denominator)\n        x1 = gcd(ap, bq)\n        x2 = gcd(bp, aq)\n        p, q = (ap // x1 * (bp // x2), aq // x2 * (bq // x1))\n    elif isinstance(other, int):\n        x = gcd(other, self.denominator)\n        p = self.numerator * (other // x)\n        q = self.denominator // x\n    else:\n        return NotImplemented\n    return self._new(p, q)",
    ".sympy.external.pythonmpq.py@@PythonMPQ.__sub__": "def __sub__(self, other):\n    if isinstance(other, PythonMPQ):\n        ap, aq = (self.numerator, self.denominator)\n        bp, bq = (other.numerator, other.denominator)\n        g = gcd(aq, bq)\n        if g == 1:\n            p = ap * bq - aq * bp\n            q = bq * aq\n        else:\n            q1, q2 = (aq // g, bq // g)\n            p, q = (ap * q2 - bp * q1, q1 * q2)\n            g2 = gcd(p, g)\n            p, q = (p // g2, q * (g // g2))\n    elif isinstance(other, int):\n        p = self.numerator - self.denominator * other\n        q = self.denominator\n    else:\n        return NotImplemented\n    return self._new(p, q)",
    ".sympy.external.pythonmpq.py@@PythonMPQ.__bool__": "def __bool__(self):\n    return bool(self.numerator)",
    ".sympy.polys.domains.gaussiandomains.py@@GaussianElement.__pow__": "def __pow__(self, exp):\n    if exp == 0:\n        return self.new(1, 0)\n    if exp < 0:\n        self, exp = (1 / self, -exp)\n    if exp == 1:\n        return self\n    pow2 = self\n    prod = self if exp % 2 else self._parent.one\n    exp //= 2\n    while exp:\n        pow2 *= pow2\n        if exp % 2:\n            prod *= pow2\n        exp //= 2\n    return prod",
    ".sympy.polys.domains.gaussiandomains.py@@GaussianElement.__rtruediv__": "def __rtruediv__(self, other):\n    try:\n        other = QQ_I.convert(other)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        return other.__truediv__(self)",
    ".sympy.polys.domains.domain.py@@Domain.convert": "def convert(self, element, base=None):\n    if _not_a_coeff(element):\n        raise CoercionFailed('%s is not in any domain' % element)\n    if base is not None:\n        return self.convert_from(element, base)\n    if self.of_type(element):\n        return element\n    from sympy.polys.domains import ZZ, QQ, RealField, ComplexField\n    if ZZ.of_type(element):\n        return self.convert_from(element, ZZ)\n    if isinstance(element, int):\n        return self.convert_from(ZZ(element), ZZ)\n    if HAS_GMPY:\n        integers = ZZ\n        if isinstance(element, integers.tp):\n            return self.convert_from(element, integers)\n        rationals = QQ\n        if isinstance(element, rationals.tp):\n            return self.convert_from(element, rationals)\n    if isinstance(element, float):\n        parent = RealField(tol=False)\n        return self.convert_from(parent(element), parent)\n    if isinstance(element, complex):\n        parent = ComplexField(tol=False)\n        return self.convert_from(parent(element), parent)\n    if isinstance(element, DomainElement):\n        return self.convert_from(element, element.parent())\n    if self.is_Numerical and getattr(element, 'is_ground', False):\n        return self.convert(element.LC())\n    if isinstance(element, Basic):\n        try:\n            return self.from_sympy(element)\n        except (TypeError, ValueError):\n            pass\n    elif not is_sequence(element):\n        try:\n            element = sympify(element, strict=True)\n            if isinstance(element, Basic):\n                return self.from_sympy(element)\n        except (TypeError, ValueError):\n            pass\n    raise CoercionFailed(\"can't convert %s of type %s to %s\" % (element, type(element), self))",
    ".sympy.polys.polyutils.py@@_not_a_coeff": "def _not_a_coeff(expr):\n    if type(expr) in illegal_types or expr in finf:\n        return True\n    if type(expr) is float and float(expr) != expr:\n        return True\n    return",
    ".sympy.polys.domains.domain.py@@Domain.of_type": "def of_type(self, element):\n    return isinstance(element, self.tp)",
    ".sympy.polys.domains.domain.py@@Domain.tp": "def tp(self):\n    return self.dtype",
    ".sympy.polys.domains.domain.py@@Domain.convert_from": "def convert_from(self, element, base):\n    if base.alias is not None:\n        method = 'from_' + base.alias\n    else:\n        method = 'from_' + base.__class__.__name__\n    _convert = getattr(self, method)\n    if _convert is not None:\n        result = _convert(element, base)\n        if result is not None:\n            return result\n    raise CoercionFailed(\"can't convert %s of type %s from %s to %s\" % (element, type(element), base, self))",
    ".sympy.polys.domains.gaussiandomains.py@@GaussianDomain.from_ZZ": "def from_ZZ(K1, a, K0):\n    return K1(a)",
    ".sympy.polys.domains.domain.py@@Domain.__call__": "def __call__(self, *args):\n    return self.new(*args)",
    ".sympy.polys.domains.domain.py@@Domain.new": "def new(self, *args):\n    return self.dtype(*args)",
    ".sympy.polys.domains.gaussiandomains.py@@GaussianElement.__new__": "def __new__(cls, x, y=0):\n    conv = cls.base.convert\n    return cls.new(conv(x), conv(y))",
    ".sympy.polys.domains.rationalfield.py@@RationalField.from_ZZ": "def from_ZZ(K1, a, K0):\n    return MPQ(a)",
    ".sympy.external.pythonmpq.py@@PythonMPQ.__new__": "def __new__(cls, numerator, denominator=None):\n    if denominator is not None:\n        if isinstance(numerator, int) and isinstance(denominator, int):\n            divisor = gcd(numerator, denominator)\n            numerator //= divisor\n            denominator //= divisor\n            return cls._new_check(numerator, denominator)\n    else:\n        if isinstance(numerator, int):\n            return cls._new(numerator, 1)\n        elif isinstance(numerator, PythonMPQ):\n            return cls._new(numerator.numerator, numerator.denominator)\n        if isinstance(numerator, (Decimal, float, str)):\n            numerator = Fraction(numerator)\n        if isinstance(numerator, Fraction):\n            return cls._new(numerator.numerator, numerator.denominator)\n    raise TypeError('PythonMPQ() requires numeric or string argument')",
    ".sympy.polys.domains.gaussiandomains.py@@GaussianElement.new": "def new(cls, x, y):\n    obj = super().__new__(cls)\n    obj.x = x\n    obj.y = y\n    return obj",
    ".sympy.polys.domains.gaussiandomains.py@@GaussianRational.__truediv__": "def __truediv__(self, other):\n    if not other:\n        raise ZeroDivisionError('{} / 0'.format(self))\n    x, y = self._get_xy(other)\n    if x is None:\n        return NotImplemented\n    c = x * x + y * y\n    return GaussianRational((self.x * x + self.y * y) / c, (-self.x * y + self.y * x) / c)",
    ".sympy.polys.domains.gaussiandomains.py@@GaussianElement.__bool__": "def __bool__(self):\n    return bool(self.x) or bool(self.y)",
    ".sympy.polys.domains.gaussiandomains.py@@GaussianElement._get_xy": "def _get_xy(cls, other):\n    if not isinstance(other, cls):\n        try:\n            other = cls._parent.convert(other)\n        except CoercionFailed:\n            return (None, None)\n    return (other.x, other.y)",
    ".sympy.external.pythonmpq.py@@PythonMPQ.__add__": "def __add__(self, other):\n    if isinstance(other, PythonMPQ):\n        ap, aq = (self.numerator, self.denominator)\n        bp, bq = (other.numerator, other.denominator)\n        g = gcd(aq, bq)\n        if g == 1:\n            p = ap * bq + aq * bp\n            q = bq * aq\n        else:\n            q1, q2 = (aq // g, bq // g)\n            p, q = (ap * q2 + bp * q1, q1 * q2)\n            g2 = gcd(p, g)\n            p, q = (p // g2, q * (g // g2))\n    elif isinstance(other, int):\n        p = self.numerator + self.denominator * other\n        q = self.denominator\n    else:\n        return NotImplemented\n    return self._new(p, q)",
    ".sympy.external.pythonmpq.py@@PythonMPQ.__truediv__": "def __truediv__(self, other):\n    if isinstance(other, PythonMPQ):\n        ap, aq = (self.numerator, self.denominator)\n        bp, bq = (other.numerator, other.denominator)\n        x1 = gcd(ap, bp)\n        x2 = gcd(bq, aq)\n        p, q = (ap // x1 * (bq // x2), aq // x2 * (bp // x1))\n    elif isinstance(other, int):\n        x = gcd(other, self.numerator)\n        p = self.numerator // x\n        q = self.denominator * (other // x)\n    else:\n        return NotImplemented\n    return self._new_check(p, q)",
    ".sympy.external.pythonmpq.py@@PythonMPQ.__neg__": "def __neg__(self):\n    return self._new(-self.numerator, self.denominator)",
    ".sympy.external.pythonmpq.py@@PythonMPQ.__eq__": "def __eq__(self, other):\n    if isinstance(other, PythonMPQ):\n        return self.numerator == other.numerator and self.denominator == other.denominator\n    elif isinstance(other, self._compatible_types):\n        return self.__eq__(PythonMPQ(other))\n    else:\n        return NotImplemented",
    ".sympy.polys.domains.gaussiandomains.py@@GaussianElement.__mul__": "def __mul__(self, other):\n    x, y = self._get_xy(other)\n    if x is not None:\n        return self.new(self.x * x - self.y * y, self.x * y + self.y * x)\n    else:\n        return NotImplemented",
    ".sympy.polys.domains.mpelements.py@@RealElement._set_mpf": "def _set_mpf(self, val):\n    self.__mpf__ = val",
    ".sympy.polys.domains.mpelements.py@@ComplexElement._set_mpc": "def _set_mpc(self, val):\n    self.__mpc__ = val",
    ".sympy.polys.fields.py@@FracElement.__pow__": "def __pow__(f, n):\n    if n >= 0:\n        return f.raw_new(f.numer ** n, f.denom ** n)\n    elif not f:\n        raise ZeroDivisionError\n    else:\n        return f.raw_new(f.denom ** (-n), f.numer ** (-n))",
    ".sympy.polys.fields.py@@FracElement.__bool__": "def __bool__(f):\n    return bool(f.numer)",
    ".sympy.polys.rings.py@@PolyElement.__pow__": "def __pow__(self, n):\n    ring = self.ring\n    if not n:\n        if self:\n            return ring.one\n        else:\n            raise ValueError('0**0')\n    elif len(self) == 1:\n        monom, coeff = list(self.items())[0]\n        p = ring.zero\n        if coeff == 1:\n            p[ring.monomial_pow(monom, n)] = coeff\n        else:\n            p[ring.monomial_pow(monom, n)] = coeff ** n\n        return p\n    n = int(n)\n    if n < 0:\n        raise ValueError('Negative exponent')\n    elif n == 1:\n        return self.copy()\n    elif n == 2:\n        return self.square()\n    elif n == 3:\n        return self * self.square()\n    elif len(self) <= 5:\n        return self._pow_multinomial(n)\n    else:\n        return self._pow_generic(n)",
    ".sympy.polys.rings.py@@PolyRing.zero": "def zero(self):\n    return self.dtype()",
    ".sympy.polys.fields.py@@FracElement.raw_new": "def raw_new(f, numer, denom):\n    return f.__class__(numer, denom)",
    ".sympy.polys.fields.py@@FracElement.__init__": "def __init__(self, numer, denom=None):\n    if denom is None:\n        denom = self.field.ring.one\n    elif not denom:\n        raise ZeroDivisionError('zero denominator')\n    self.numer = numer\n    self.denom = denom",
    ".sympy.polys.fields.py@@FracElement.__mul__": "def __mul__(f, g):\n    field = f.field\n    if not f or not g:\n        return field.zero\n    elif isinstance(g, field.dtype):\n        return f.new(f.numer * g.numer, f.denom * g.denom)\n    elif isinstance(g, field.ring.dtype):\n        return f.new(f.numer * g, f.denom)\n    elif isinstance(g, FracElement):\n        if isinstance(field.domain, FractionField) and field.domain.field == g.field:\n            pass\n        elif isinstance(g.field.domain, FractionField) and g.field.domain.field == field:\n            return g.__rmul__(f)\n        else:\n            return NotImplemented\n    elif isinstance(g, PolyElement):\n        if isinstance(field.domain, PolynomialRing) and field.domain.ring == g.ring:\n            pass\n        else:\n            return g.__rmul__(f)\n    return f.__rmul__(g)",
    ".sympy.polys.rings.py@@PolyElement.__mul__": "def __mul__(p1, p2):\n    ring = p1.ring\n    p = ring.zero\n    if not p1 or not p2:\n        return p\n    elif isinstance(p2, ring.dtype):\n        get = p.get\n        zero = ring.domain.zero\n        monomial_mul = ring.monomial_mul\n        p2it = list(p2.items())\n        for exp1, v1 in p1.items():\n            for exp2, v2 in p2it:\n                exp = monomial_mul(exp1, exp2)\n                p[exp] = get(exp, zero) + v1 * v2\n        p.strip_zero()\n        return p\n    elif isinstance(p2, PolyElement):\n        if isinstance(ring.domain, PolynomialRing) and ring.domain.ring == p2.ring:\n            pass\n        elif isinstance(p2.ring.domain, PolynomialRing) and p2.ring.domain.ring == ring:\n            return p2.__rmul__(p1)\n        else:\n            return NotImplemented\n    try:\n        p2 = ring.domain_new(p2)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        for exp1, v1 in p1.items():\n            v = v1 * p2\n            if v:\n                p[exp1] = v\n        return p",
    ".sympy.polys.rings.py@@PolyElement.strip_zero": "def strip_zero(self):\n    for k, v in list(self.items()):\n        if not v:\n            del self[k]",
    ".sympy.polys.fields.py@@FracElement.new": "def new(f, numer, denom):\n    return f.raw_new(*numer.cancel(denom))",
    ".sympy.polys.rings.py@@PolyElement.cancel": "def cancel(self, g):\n    f = self\n    ring = f.ring\n    if not f:\n        return (f, ring.one)\n    domain = ring.domain\n    if not (domain.is_Field and domain.has_assoc_Ring):\n        _, p, q = f.cofactors(g)\n    else:\n        new_ring = ring.clone(domain=domain.get_ring())\n        cq, f = f.clear_denoms()\n        cp, g = g.clear_denoms()\n        f = f.set_ring(new_ring)\n        g = g.set_ring(new_ring)\n        _, p, q = f.cofactors(g)\n        _, cp, cq = new_ring.domain.cofactors(cp, cq)\n        p = p.set_ring(ring)\n        q = q.set_ring(ring)\n        p = p.mul_ground(cp)\n        q = q.mul_ground(cq)\n    u = q.canonical_unit()\n    if u == domain.one:\n        p, q = (p, q)\n    elif u == -domain.one:\n        p, q = (-p, -q)\n    else:\n        p = p.mul_ground(u)\n        q = q.mul_ground(u)\n    return (p, q)",
    ".sympy.polys.rings.py@@PolyElement.cofactors": "def cofactors(f, g):\n    if not f and (not g):\n        zero = f.ring.zero\n        return (zero, zero, zero)\n    elif not f:\n        h, cff, cfg = f._gcd_zero(g)\n        return (h, cff, cfg)\n    elif not g:\n        h, cfg, cff = g._gcd_zero(f)\n        return (h, cff, cfg)\n    elif len(f) == 1:\n        h, cff, cfg = f._gcd_monom(g)\n        return (h, cff, cfg)\n    elif len(g) == 1:\n        h, cfg, cff = g._gcd_monom(f)\n        return (h, cff, cfg)\n    J, (f, g) = f.deflate(g)\n    h, cff, cfg = f._gcd(g)\n    return (h.inflate(J), cff.inflate(J), cfg.inflate(J))",
    ".sympy.polys.rings.py@@PolyElement._gcd_monom": "def _gcd_monom(f, g):\n    ring = f.ring\n    ground_gcd = ring.domain.gcd\n    ground_quo = ring.domain.quo\n    monomial_gcd = ring.monomial_gcd\n    monomial_ldiv = ring.monomial_ldiv\n    mf, cf = list(f.iterterms())[0]\n    _mgcd, _cgcd = (mf, cf)\n    for mg, cg in g.iterterms():\n        _mgcd = monomial_gcd(_mgcd, mg)\n        _cgcd = ground_gcd(_cgcd, cg)\n    h = f.new([(_mgcd, _cgcd)])\n    cff = f.new([(monomial_ldiv(mf, _mgcd), ground_quo(cf, _cgcd))])\n    cfg = f.new([(monomial_ldiv(mg, _mgcd), ground_quo(cg, _cgcd)) for mg, cg in g.iterterms()])\n    return (h, cff, cfg)",
    ".sympy.polys.rings.py@@PolyElement.iterterms": "def iterterms(self):\n    return iter(self.items())",
    ".sympy.polys.domains.integerring.py@@IntegerRing.gcd": "def gcd(self, a, b):\n    return gcd(a, b)",
    ".sympy.polys.rings.py@@PolyElement.new": "def new(self, init):\n    return self.__class__(init)",
    ".sympy.polys.domains.ring.py@@Ring.quo": "def quo(self, a, b):\n    return a // b",
    ".sympy.polys.rings.py@@PolyElement.canonical_unit": "def canonical_unit(f):\n    domain = f.ring.domain\n    return domain.canonical_unit(f.LC)",
    ".sympy.polys.rings.py@@PolyElement.LC": "def LC(self):\n    return self._get_coeff(self.leading_expv())",
    ".sympy.polys.rings.py@@PolyElement.leading_expv": "def leading_expv(self):\n    if self:\n        return self.ring.leading_expv(self)\n    else:\n        return None",
    ".sympy.polys.rings.py@@PolyElement._get_coeff": "def _get_coeff(self, expv):\n    return self.get(expv, self.ring.domain.zero)",
    ".sympy.polys.domains.domain.py@@Domain.canonical_unit": "def canonical_unit(self, a):\n    if self.is_negative(a):\n        return -self.one\n    else:\n        return self.one",
    ".sympy.polys.domains.domain.py@@Domain.is_negative": "def is_negative(self, a):\n    return a < 0"
}