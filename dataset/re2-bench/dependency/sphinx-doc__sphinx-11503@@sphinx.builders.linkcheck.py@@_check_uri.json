{
    ".sphinx.builders.linkcheck.py@@_get_request_headers": "def _get_request_headers(uri: str, request_headers: dict[str, dict[str, str]]) -> dict[str, str]:\n    url = urlsplit(uri)\n    candidates = (f'{url.scheme}://{url.netloc}', f'{url.scheme}://{url.netloc}/', uri, '*')\n    for u in candidates:\n        if u in request_headers:\n            return {**DEFAULT_REQUEST_HEADERS, **request_headers[u]}\n    return {}",
    ".sphinx.environment.__init__.py@@BuildEnvironment.doc2path": "def doc2path(self, docname: str, base: bool=True) -> str:\n    return self.project.doc2path(docname, base)",
    ".sphinx.util.requests.py@@_get_tls_cacert": "def _get_tls_cacert(url: str, certs: str | dict[str, str] | None) -> str | bool:\n    if not certs:\n        return True\n    elif isinstance(certs, (str, tuple)):\n        return certs\n    else:\n        hostname = urlsplit(url).netloc\n        if '@' in hostname:\n            _, hostname = hostname.split('@', 1)\n        return certs.get(hostname, True)",
    ".sphinx.project.py@@Project.doc2path": "def doc2path(self, docname: str, basedir: bool=True) -> str:\n    docname = docname.replace(SEP, os.path.sep)\n    basename = os.path.join(self.srcdir, docname)\n    for suffix in self.source_suffix:\n        if os.path.isfile(basename + suffix):\n            break\n    else:\n        suffix = list(self.source_suffix)[0]\n    if basedir:\n        return basename + suffix\n    else:\n        return docname + suffix",
    ".sphinx.util.logging.py@@SphinxLoggerAdapter.log": "def log(self, level: int | str, msg: str, *args: Any, **kwargs: Any) -> None:\n    if isinstance(level, int):\n        super().log(level, msg, *args, **kwargs)\n    else:\n        levelno = LEVEL_NAMES[level]\n        super().log(levelno, msg, *args, **kwargs)",
    ".sphinx.util.requests.py@@_Session.request": "def request(self, method: str, url: str, _user_agent: str='', _tls_info: tuple[bool, str | dict[str, str] | None]=(), **kwargs: Any) -> requests.Response:\n    headers = kwargs.setdefault('headers', {})\n    headers.setdefault('User-Agent', _user_agent or _USER_AGENT)\n    if _tls_info:\n        tls_verify, tls_cacerts = _tls_info\n        verify = bool(kwargs.get('verify', tls_verify))\n        kwargs.setdefault('verify', verify and _get_tls_cacert(url, tls_cacerts))\n    else:\n        verify = kwargs.get('verify', True)\n    if verify:\n        return super().request(method, url, **kwargs)\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', category=InsecureRequestWarning)\n        return super().request(method, url, **kwargs)",
    ".sphinx.util.logging.py@@SphinxLoggerAdapter.process": "def process(self, msg: str, kwargs: dict) -> tuple[str, dict]:\n    extra = kwargs.setdefault('extra', {})\n    for keyword in self.KEYWORDS:\n        if keyword in kwargs:\n            extra[keyword] = kwargs.pop(keyword)\n    return (msg, kwargs)",
    ".sphinx.util.logging.py@@InfoFilter.filter": "def filter(self, record: logging.LogRecord) -> bool:\n    return record.levelno < logging.WARNING",
    ".sphinx.util.logging.py@@SphinxLogRecordTranslator.filter": "def filter(self, record: SphinxWarningLogRecord) -> bool:\n    if isinstance(record, logging.LogRecord):\n        record.__class__ = self.LogRecordClass\n    location = getattr(record, 'location', None)\n    if isinstance(location, tuple):\n        docname, lineno = location\n        if docname:\n            if lineno:\n                record.location = f'{self.app.env.doc2path(docname)}:{lineno}'\n            else:\n                record.location = f'{self.app.env.doc2path(docname)}'\n        else:\n            record.location = None\n    elif isinstance(location, nodes.Node):\n        record.location = get_node_location(location)\n    elif location and ':' not in location:\n        record.location = f'{self.app.env.doc2path(location)}'\n    return True",
    ".sphinx.util.logging.py@@NewLineStreamHandler.emit": "def emit(self, record: logging.LogRecord) -> None:\n    try:\n        self.acquire()\n        if getattr(record, 'nonl', False):\n            self.terminator = ''\n        super().emit(record)\n    finally:\n        self.terminator = '\\n'\n        self.release()",
    ".sphinx.util.logging.py@@ColorizeFormatter.format": "def format(self, record: logging.LogRecord) -> str:\n    message = super().format(record)\n    color = getattr(record, 'color', None)\n    if color is None:\n        color = COLOR_MAP.get(record.levelno)\n    if color:\n        return colorize(color, message)\n    else:\n        return message",
    ".sphinx.util.logging.py@@SphinxLogRecord.getMessage": "def getMessage(self) -> str:\n    message = super().getMessage()\n    location = getattr(self, 'location', None)\n    if location:\n        message = f'{location}: {self.prefix}{message}'\n    elif self.prefix not in message:\n        message = self.prefix + message\n    return message",
    ".sphinx.util.logging.py@@SafeEncodingWriter.write": "def write(self, data: str) -> None:\n    try:\n        self.stream.write(data)\n    except UnicodeEncodeError:\n        self.stream.write(data.encode(self.encoding, 'replace').decode(self.encoding))",
    ".sphinx.builders.linkcheck.py@@AnchorCheckParser.__init__": "def __init__(self, search_anchor: str) -> None:\n    super().__init__()\n    self.search_anchor = search_anchor\n    self.found = False",
    ".sphinx.locale.__init__.py@@gettext": "def gettext(message: str) -> str:\n    if not is_translator_registered(catalog, namespace):\n        return _TranslationProxy(catalog, namespace, message)\n    else:\n        translator = get_translator(catalog, namespace)\n        return translator.gettext(message)",
    ".sphinx.locale.__init__.py@@is_translator_registered": "def is_translator_registered(catalog: str='sphinx', namespace: str='general') -> bool:\n    return (namespace, catalog) in translators",
    ".sphinx.locale.__init__.py@@_TranslationProxy.__init__": "def __init__(self, catalogue: str, namespace: str, message: str) -> None:\n    self._catalogue = catalogue\n    self._namespace = namespace\n    self._message = message",
    ".sphinx.util.logging.py@@SafeEncodingWriter.flush": "def flush(self) -> None:\n    if hasattr(self.stream, 'flush'):\n        self.stream.flush()",
    ".sphinx.builders.linkcheck.py@@_allowed_redirect": "def _allowed_redirect(url: str, new_url: str, allowed_redirects: dict[re.Pattern[str], re.Pattern[str]]) -> bool:\n    return any((from_url.match(url) and to_url.match(new_url) for from_url, to_url in allowed_redirects.items()))"
}