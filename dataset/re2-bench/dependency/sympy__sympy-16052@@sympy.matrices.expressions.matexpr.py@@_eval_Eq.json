{
    ".sympy.matrices.expressions.matexpr.py@@MatrixSymbol.shape": "def shape(self):\n    return self.args[1:3]",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, integer_types):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.matrices.expressions.matexpr.py@@ZeroMatrix.shape": "def shape(self):\n    return (self.args[0], self.args[1])",
    ".sympy.matrices.expressions.matexpr.py@@__sympifyit_wrapper": "def __sympifyit_wrapper(a, b):\n    try:\n        b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    if evaluate is None:\n        if global_evaluate[0] is False:\n            evaluate = global_evaluate[0]\n        else:\n            evaluate = True\n    try:\n        if a in sympy_classes:\n            return a\n    except TypeError:\n        pass\n    try:\n        cls = a.__class__\n    except AttributeError:\n        cls = type(a)\n    if cls in sympy_classes:\n        return a\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if type(a).__module__ == 'numpy':\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    try:\n        return converter[cls](a)\n    except KeyError:\n        for superclass in getmro(cls):\n            try:\n                return converter[superclass](a)\n            except KeyError:\n                continue\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    try:\n        return a._sympy_()\n    except AttributeError:\n        pass\n    if not strict:\n        try:\n            from ..tensor.array import Array\n            return Array(a.flat, a.shape)\n        except AttributeError:\n            pass\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                return sympify(coerce(a))\n            except (TypeError, ValueError, AttributeError, SympifyError):\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.decorators.py@@binary_op_wrapper": "def binary_op_wrapper(self, other):\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:\n            try:\n                f = getattr(other, method_name)\n            except AttributeError:\n                pass\n            else:\n                return f(self)\n    return func(self, other)",
    ".sympy.matrices.expressions.matmul.py@@MatMul.__new__": "def __new__(cls, *args, **kwargs):\n    check = kwargs.get('check', True)\n    if not args:\n        return GenericIdentity()\n    args = filter(lambda i: GenericIdentity() != i, args)\n    args = list(map(sympify, args))\n    obj = Basic.__new__(cls, *args)\n    factor, matrices = obj.as_coeff_matrices()\n    if check:\n        validate(*matrices)\n    if not matrices:\n        return factor\n    return obj",
    ".sympy.matrices.expressions.matexpr.py@@GenericIdentity.__new__": "def __new__(cls):\n    return super(Identity, cls).__new__(cls)",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.matrices.expressions.matexpr.py@@GenericIdentity.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.matrices.expressions.matexpr.py@@GenericIdentity.__eq__": "def __eq__(self, other):\n    return isinstance(other, GenericIdentity)",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.matrices.expressions.matmul.py@@MatMul.as_coeff_matrices": "def as_coeff_matrices(self):\n    scalars = [x for x in self.args if not x.is_Matrix]\n    matrices = [x for x in self.args if x.is_Matrix]\n    coeff = Mul(*scalars)\n    return (coeff, matrices)",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, **options):\n    from sympy import Order\n    args = list(map(_sympify, args))\n    args = [a for a in args if a is not cls.identity]\n    evaluate = options.get('evaluate')\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    if not evaluate:\n        return cls._from_args(args)\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if order_symbols is not None:\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.matrices.expressions.matmul.py@@validate": "def validate(*matrices):\n    for i in range(len(matrices) - 1):\n        A, B = matrices[i:i + 2]\n        if A.cols != B.rows:\n            raise ShapeError('Matrices %s and %s are not aligned' % (A, B))",
    ".sympy.matrices.expressions.matmul.py@@MatMul.doit": "def doit(self, **kwargs):\n    deep = kwargs.get('deep', True)\n    if deep:\n        args = [arg.doit(**kwargs) for arg in self.args]\n    else:\n        args = self.args\n    mats = [arg for arg in self.args if arg.is_Matrix]\n    expr = canonicalize(MatMul(*args))\n    return expr",
    ".sympy.core.basic.py@@Atom.doit": "def doit(self, **hints):\n    return self",
    ".sympy.core.basic.py@@Basic.doit": "def doit(self, **hints):\n    if hints.get('deep', True):\n        terms = [term.doit(**hints) if isinstance(term, Basic) else term for term in self.args]\n        return self.func(*terms)\n    else:\n        return self",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.matrices.expressions.matexpr.py@@ZeroMatrix.__new__": "def __new__(cls, m, n):\n    return super(ZeroMatrix, cls).__new__(cls, m, n)",
    ".sympy.core.basic.py@@Basic._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.strategies.core.py@@exhaustive_rl": "def exhaustive_rl(expr):\n    new, old = (rule(expr), expr)\n    while new != old:\n        new, old = (rule(new), new)\n    return new",
    ".sympy.strategies.core.py@@switch_rl": "def switch_rl(expr):\n    rl = ruledict.get(key(expr), identity)\n    return rl(expr)",
    ".sympy.strategies.core.py@@do_one_rl": "def do_one_rl(expr):\n    for rl in rules:\n        result = rl(expr)\n        if result != expr:\n            return result\n    return expr",
    ".sympy.matrices.expressions.matmul.py@@any_zeros": "def any_zeros(mul):\n    if any([arg.is_zero or (arg.is_Matrix and arg.is_ZeroMatrix) for arg in mul.args]):\n        matrices = [arg for arg in mul.args if arg.is_Matrix]\n        return ZeroMatrix(matrices[0].rows, matrices[-1].cols)\n    return mul",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    tself = type(self)\n    tother = type(other)\n    if type(self) is not type(other):\n        try:\n            other = _sympify(other)\n            tother = type(other)\n        except SympifyError:\n            return NotImplemented\n        if PY3 or type(tself).__ne__ is not type.__ne__:\n            if tself != tother:\n                return False\n        elif tself is not tother:\n            return False\n    return self._hashable_content() == other._hashable_content()",
    ".sympy.matrices.expressions.matadd.py@@MatAdd.__new__": "def __new__(cls, *args, **kwargs):\n    if not args:\n        return GenericZeroMatrix()\n    args = filter(lambda i: GenericZeroMatrix() != i, args)\n    args = list(map(sympify, args))\n    check = kwargs.get('check', False)\n    obj = Basic.__new__(cls, *args)\n    if check:\n        if all((not isinstance(i, MatrixExpr) for i in args)):\n            return Add.fromiter(args)\n        validate(*args)\n    return obj",
    ".sympy.matrices.expressions.matexpr.py@@GenericZeroMatrix.__new__": "def __new__(cls):\n    return super(ZeroMatrix, cls).__new__(cls)",
    ".sympy.matrices.expressions.matexpr.py@@GenericZeroMatrix.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.matrices.expressions.matexpr.py@@GenericZeroMatrix.__eq__": "def __eq__(self, other):\n    return isinstance(other, GenericZeroMatrix)",
    ".sympy.matrices.expressions.matadd.py@@validate": "def validate(*args):\n    if not all((arg.is_Matrix for arg in args)):\n        raise TypeError('Mix of Matrix and Scalar symbols')\n    A = args[0]\n    for B in args[1:]:\n        if A.shape != B.shape:\n            raise ShapeError('Matrices %s and %s are not aligned' % (A, B))",
    ".sympy.matrices.expressions.matadd.py@@MatAdd.doit": "def doit(self, **kwargs):\n    deep = kwargs.get('deep', True)\n    if deep:\n        args = [arg.doit(**kwargs) for arg in self.args]\n    else:\n        args = self.args\n    return canonicalize(MatAdd(*args))",
    ".sympy.strategies.core.py@@conditioned_rl": "def conditioned_rl(expr):\n    if cond(expr):\n        return rule(expr)\n    else:\n        return expr",
    ".sympy.strategies.rl.py@@ident_remove": "def ident_remove(expr):\n    ids = list(map(isid, expr.args))\n    if sum(ids) == 0:\n        return expr\n    elif sum(ids) != len(ids):\n        return new(expr.__class__, *[arg for arg, x in zip(expr.args, ids) if not x])\n    else:\n        return new(expr.__class__, expr.args[0])",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, string_types):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    try:\n        return _intcache[ival]\n    except KeyError:\n        obj = Expr.__new__(cls)\n        obj.p = ival\n        _intcache[ival] = obj\n        return obj",
    ".sympy.strategies.rl.py@@unpack": "def unpack(expr):\n    if len(expr.args) == 1:\n        return expr.args[0]\n    else:\n        return expr"
}