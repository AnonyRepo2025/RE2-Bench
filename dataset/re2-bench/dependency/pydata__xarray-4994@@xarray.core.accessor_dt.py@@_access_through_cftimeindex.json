{
    ".xarray.coding.cftimeindex.py@@CFTimeIndex.__new__": "def __new__(cls, data, name=None):\n    assert_all_valid_date_type(data)\n    if name is None and hasattr(data, 'name'):\n        name = data.name\n    result = object.__new__(cls)\n    result._data = np.array(data, dtype='O')\n    result.name = name\n    result._cache = {}\n    return result",
    ".xarray.coding.cftimeindex.py@@assert_all_valid_date_type": "def assert_all_valid_date_type(data):\n    import cftime\n    if len(data) > 0:\n        sample = data[0]\n        date_type = type(sample)\n        if not isinstance(sample, cftime.datetime):\n            raise TypeError('CFTimeIndex requires cftime.datetime objects. Got object of {}.'.format(date_type))\n        if not all((isinstance(value, date_type) for value in data)):\n            raise TypeError('CFTimeIndex requires using datetime objects of all the same type.  Got\\n{}.'.format(data))",
    ".xarray.coding.cftimeindex.py@@f": "def f(self, min_cftime_version=min_cftime_version):\n    import cftime\n    version = cftime.__version__\n    if LooseVersion(version) >= LooseVersion(min_cftime_version):\n        return get_date_field(self._data, name)\n    else:\n        raise ImportError('The {!r} accessor requires a minimum version of cftime of {}. Found an installed version of {}.'.format(name, min_cftime_version, version))",
    ".xarray.coding.cftimeindex.py@@get_date_field": "def get_date_field(datetimes, field):\n    return np.array([getattr(date, field) for date in datetimes])",
    ".xarray.core.accessor_dt.py@@_season_from_months": "def _season_from_months(months):\n    seasons = np.array(['DJF', 'MAM', 'JJA', 'SON'])\n    months = np.asarray(months)\n    return seasons[months // 3 % 4]"
}