{
    ".django.template.engine.py@@Engine.from_string": "def from_string(self, template_code):\n    return Template(template_code, engine=self)",
    ".django.template.base.py@@Template.__init__": "def __init__(self, template_string, origin=None, name=None, engine=None):\n    if engine is None:\n        from .engine import Engine\n        engine = Engine.get_default()\n    if origin is None:\n        origin = Origin(UNKNOWN_SOURCE)\n    self.name = name\n    self.origin = origin\n    self.engine = engine\n    self.source = str(template_string)\n    self.nodelist = self.compile_nodelist()",
    ".django.template.base.py@@Origin.__init__": "def __init__(self, name, template_name=None, loader=None):\n    self.name = name\n    self.template_name = template_name\n    self.loader = loader",
    ".django.template.base.py@@Template.compile_nodelist": "def compile_nodelist(self):\n    if self.engine.debug:\n        lexer = DebugLexer(self.source)\n    else:\n        lexer = Lexer(self.source)\n    tokens = lexer.tokenize()\n    parser = Parser(tokens, self.engine.template_libraries, self.engine.template_builtins, self.origin)\n    try:\n        return parser.parse()\n    except Exception as e:\n        if self.engine.debug:\n            e.template_debug = self.get_exception_info(e, e.token)\n        raise",
    ".django.template.base.py@@Lexer.__init__": "def __init__(self, template_string):\n    self.template_string = template_string\n    self.verbatim = False",
    ".django.template.base.py@@DebugLexer.tokenize": "def tokenize(self):\n    lineno = 1\n    result = []\n    upto = 0\n    for match in tag_re.finditer(self.template_string):\n        start, end = match.span()\n        if start > upto:\n            token_string = self.template_string[upto:start]\n            result.append(self.create_token(token_string, (upto, start), lineno, in_tag=False))\n            lineno += token_string.count('\\n')\n            upto = start\n        token_string = self.template_string[start:end]\n        result.append(self.create_token(token_string, (start, end), lineno, in_tag=True))\n        lineno += token_string.count('\\n')\n        upto = end\n    last_bit = self.template_string[upto:]\n    if last_bit:\n        result.append(self.create_token(last_bit, (upto, upto + len(last_bit)), lineno, in_tag=False))\n    return result",
    ".django.template.base.py@@Lexer.create_token": "def create_token(self, token_string, position, lineno, in_tag):\n    if in_tag and token_string.startswith(BLOCK_TAG_START):\n        block_content = token_string[2:-2].strip()\n        if self.verbatim and block_content == self.verbatim:\n            self.verbatim = False\n    if in_tag and (not self.verbatim):\n        if token_string.startswith(VARIABLE_TAG_START):\n            return Token(TokenType.VAR, token_string[2:-2].strip(), position, lineno)\n        elif token_string.startswith(BLOCK_TAG_START):\n            if block_content[:9] in ('verbatim', 'verbatim '):\n                self.verbatim = 'end%s' % block_content\n            return Token(TokenType.BLOCK, block_content, position, lineno)\n        elif token_string.startswith(COMMENT_TAG_START):\n            content = ''\n            if token_string.find(TRANSLATOR_COMMENT_MARK):\n                content = token_string[2:-2].strip()\n            return Token(TokenType.COMMENT, content, position, lineno)\n    else:\n        return Token(TokenType.TEXT, token_string, position, lineno)",
    ".django.template.base.py@@Token.__init__": "def __init__(self, token_type, contents, position=None, lineno=None):\n    self.token_type, self.contents = (token_type, contents)\n    self.lineno = lineno\n    self.position = position",
    ".django.template.base.py@@Parser.__init__": "def __init__(self, tokens, libraries=None, builtins=None, origin=None):\n    self.tokens = tokens\n    self.tags = {}\n    self.filters = {}\n    self.command_stack = []\n    if libraries is None:\n        libraries = {}\n    if builtins is None:\n        builtins = []\n    self.libraries = libraries\n    for builtin in builtins:\n        self.add_library(builtin)\n    self.origin = origin",
    ".django.template.base.py@@Parser.add_library": "def add_library(self, lib):\n    self.tags.update(lib.tags)\n    self.filters.update(lib.filters)",
    ".django.template.base.py@@Parser.parse": "def parse(self, parse_until=None):\n    if parse_until is None:\n        parse_until = []\n    nodelist = NodeList()\n    while self.tokens:\n        token = self.next_token()\n        if token.token_type.value == 0:\n            self.extend_nodelist(nodelist, TextNode(token.contents), token)\n        elif token.token_type.value == 1:\n            if not token.contents:\n                raise self.error(token, 'Empty variable tag on line %d' % token.lineno)\n            try:\n                filter_expression = self.compile_filter(token.contents)\n            except TemplateSyntaxError as e:\n                raise self.error(token, e)\n            var_node = VariableNode(filter_expression)\n            self.extend_nodelist(nodelist, var_node, token)\n        elif token.token_type.value == 2:\n            try:\n                command = token.contents.split()[0]\n            except IndexError:\n                raise self.error(token, 'Empty block tag on line %d' % token.lineno)\n            if command in parse_until:\n                self.prepend_token(token)\n                return nodelist\n            self.command_stack.append((command, token))\n            try:\n                compile_func = self.tags[command]\n            except KeyError:\n                self.invalid_block_tag(token, command, parse_until)\n            try:\n                compiled_result = compile_func(self, token)\n            except Exception as e:\n                raise self.error(token, e)\n            self.extend_nodelist(nodelist, compiled_result, token)\n            self.command_stack.pop()\n    if parse_until:\n        self.unclosed_block_tag(parse_until)\n    return nodelist",
    ".django.template.base.py@@Parser.next_token": "def next_token(self):\n    return self.tokens.pop(0)",
    ".django.template.defaulttags.py@@load": "def load(parser, token):\n    bits = token.contents.split()\n    if len(bits) >= 4 and bits[-2] == 'from':\n        name = bits[-1]\n        lib = find_library(parser, name)\n        subset = load_from_library(lib, name, bits[1:-2])\n        parser.add_library(subset)\n    else:\n        for name in bits[1:]:\n            lib = find_library(parser, name)\n            parser.add_library(lib)\n    return LoadNode()",
    ".django.template.defaulttags.py@@find_library": "def find_library(parser, name):\n    try:\n        return parser.libraries[name]\n    except KeyError:\n        raise TemplateSyntaxError(\"'%s' is not a registered tag library. Must be one of:\\n%s\" % (name, '\\n'.join(sorted(parser.libraries))))",
    ".django.template.base.py@@Parser.extend_nodelist": "def extend_nodelist(self, nodelist, node, token):\n    if node.must_be_first and nodelist.contains_nontext:\n        raise self.error(token, '%r must be the first tag in the template.' % node)\n    if isinstance(nodelist, NodeList) and (not isinstance(node, TextNode)):\n        nodelist.contains_nontext = True\n    node.token = token\n    node.origin = self.origin\n    nodelist.append(node)",
    ".django.template.base.py@@TextNode.__init__": "def __init__(self, s):\n    self.s = s",
    ".django.templatetags.i18n.py@@do_get_current_language_bidi": "def do_get_current_language_bidi(parser, token):\n    args = token.contents.split()\n    if len(args) != 3 or args[1] != 'as':\n        raise TemplateSyntaxError(\"'get_current_language_bidi' requires 'as variable' (got %r)\" % args)\n    return GetCurrentLanguageBidiNode(args[2])",
    ".django.templatetags.i18n.py@@GetCurrentLanguageBidiNode.__init__": "def __init__(self, variable):\n    self.variable = variable",
    ".django.template.defaulttags.py@@do_if": "def do_if(parser, token):\n    bits = token.split_contents()[1:]\n    condition = TemplateIfParser(parser, bits).parse()\n    nodelist = parser.parse(('elif', 'else', 'endif'))\n    conditions_nodelists = [(condition, nodelist)]\n    token = parser.next_token()\n    while token.contents.startswith('elif'):\n        bits = token.split_contents()[1:]\n        condition = TemplateIfParser(parser, bits).parse()\n        nodelist = parser.parse(('elif', 'else', 'endif'))\n        conditions_nodelists.append((condition, nodelist))\n        token = parser.next_token()\n    if token.contents == 'else':\n        nodelist = parser.parse(('endif',))\n        conditions_nodelists.append((None, nodelist))\n        token = parser.next_token()\n    if token.contents != 'endif':\n        raise TemplateSyntaxError('Malformed template tag at line {0}: \"{1}\"'.format(token.lineno, token.contents))\n    return IfNode(conditions_nodelists)",
    ".django.template.base.py@@Token.split_contents": "def split_contents(self):\n    split = []\n    bits = smart_split(self.contents)\n    for bit in bits:\n        if bit.startswith(('_(\"', \"_('\")):\n            sentinel = bit[2] + ')'\n            trans_bit = [bit]\n            while not bit.endswith(sentinel):\n                bit = next(bits)\n                trans_bit.append(bit)\n            bit = ' '.join(trans_bit)\n        split.append(bit)\n    return split",
    ".django.utils.text.py@@smart_split": "def smart_split(text):\n    for bit in smart_split_re.finditer(str(text)):\n        yield bit.group(0)",
    ".django.template.defaulttags.py@@TemplateIfParser.__init__": "def __init__(self, parser, *args, **kwargs):\n    self.template_parser = parser\n    super().__init__(*args, **kwargs)",
    ".django.template.smartif.py@@IfParser.__init__": "def __init__(self, tokens):\n    num_tokens = len(tokens)\n    mapped_tokens = []\n    i = 0\n    while i < num_tokens:\n        token = tokens[i]\n        if token == 'is' and i + 1 < num_tokens and (tokens[i + 1] == 'not'):\n            token = 'is not'\n            i += 1\n        elif token == 'not' and i + 1 < num_tokens and (tokens[i + 1] == 'in'):\n            token = 'not in'\n            i += 1\n        mapped_tokens.append(self.translate_token(token))\n        i += 1\n    self.tokens = mapped_tokens\n    self.pos = 0\n    self.current_token = self.next_token()",
    ".django.template.smartif.py@@IfParser.translate_token": "def translate_token(self, token):\n    try:\n        op = OPERATORS[token]\n    except (KeyError, TypeError):\n        return self.create_var(token)\n    else:\n        return op()",
    ".django.template.defaulttags.py@@TemplateIfParser.create_var": "def create_var(self, value):\n    return TemplateLiteral(self.template_parser.compile_filter(value), value)",
    ".django.template.base.py@@Parser.compile_filter": "def compile_filter(self, token):\n    return FilterExpression(token, self)",
    ".django.template.base.py@@FilterExpression.__init__": "def __init__(self, token, parser):\n    self.token = token\n    matches = filter_re.finditer(token)\n    var_obj = None\n    filters = []\n    upto = 0\n    for match in matches:\n        start = match.start()\n        if upto != start:\n            raise TemplateSyntaxError('Could not parse some characters: %s|%s|%s' % (token[:upto], token[upto:start], token[start:]))\n        if var_obj is None:\n            var, constant = match.group('var', 'constant')\n            if constant:\n                try:\n                    var_obj = Variable(constant).resolve({})\n                except VariableDoesNotExist:\n                    var_obj = None\n            elif var is None:\n                raise TemplateSyntaxError('Could not find variable at start of %s.' % token)\n            else:\n                var_obj = Variable(var)\n        else:\n            filter_name = match.group('filter_name')\n            args = []\n            constant_arg, var_arg = match.group('constant_arg', 'var_arg')\n            if constant_arg:\n                args.append((False, Variable(constant_arg).resolve({})))\n            elif var_arg:\n                args.append((True, Variable(var_arg)))\n            filter_func = parser.find_filter(filter_name)\n            self.args_check(filter_name, filter_func, args)\n            filters.append((filter_func, args))\n        upto = match.end()\n    if upto != len(token):\n        raise TemplateSyntaxError(\"Could not parse the remainder: '%s' from '%s'\" % (token[upto:], token))\n    self.filters = filters\n    self.var = var_obj",
    ".django.template.base.py@@Variable.__init__": "def __init__(self, var):\n    self.var = var\n    self.literal = None\n    self.lookups = None\n    self.translate = False\n    self.message_context = None\n    if not isinstance(var, str):\n        raise TypeError('Variable must be a string or number, got %s' % type(var))\n    try:\n        if '.' in var or 'e' in var.lower():\n            self.literal = float(var)\n            if var.endswith('.'):\n                raise ValueError\n        else:\n            self.literal = int(var)\n    except ValueError:\n        if var.startswith('_(') and var.endswith(')'):\n            self.translate = True\n            var = var[2:-1]\n        try:\n            self.literal = mark_safe(unescape_string_literal(var))\n        except ValueError:\n            if var.find(VARIABLE_ATTRIBUTE_SEPARATOR + '_') > -1 or var[0] == '_':\n                raise TemplateSyntaxError(\"Variables and attributes may not begin with underscores: '%s'\" % var)\n            self.lookups = tuple(var.split(VARIABLE_ATTRIBUTE_SEPARATOR))",
    ".django.utils.functional.py@@wrapper": "def wrapper(*args, **kwargs):\n    if any((isinstance(arg, Promise) for arg in itertools.chain(args, kwargs.values()))):\n        return lazy_func(*args, **kwargs)\n    return func(*args, **kwargs)",
    ".django.utils.text.py@@unescape_string_literal": "def unescape_string_literal(s):\n    if s[0] not in '\"\\'' or s[-1] != s[0]:\n        raise ValueError('Not a string literal: %r' % s)\n    quote = s[0]\n    return s[1:-1].replace('\\\\%s' % quote, quote).replace('\\\\\\\\', '\\\\')",
    ".django.template.defaulttags.py@@TemplateLiteral.__init__": "def __init__(self, value, text):\n    self.value = value\n    self.text = text",
    ".django.template.smartif.py@@IfParser.next_token": "def next_token(self):\n    if self.pos >= len(self.tokens):\n        return EndToken\n    else:\n        retval = self.tokens[self.pos]\n        self.pos += 1\n        return retval",
    ".django.template.smartif.py@@IfParser.parse": "def parse(self):\n    retval = self.expression()\n    if self.current_token is not EndToken:\n        raise self.error_class(\"Unused '%s' at end of if expression.\" % self.current_token.display())\n    return retval",
    ".django.template.smartif.py@@IfParser.expression": "def expression(self, rbp=0):\n    t = self.current_token\n    self.current_token = self.next_token()\n    left = t.nud(self)\n    while rbp < self.current_token.lbp:\n        t = self.current_token\n        self.current_token = self.next_token()\n        left = t.led(left, self)\n    return left",
    ".django.template.smartif.py@@Literal.nud": "def nud(self, parser):\n    return self",
    ".django.template.base.py@@Parser.prepend_token": "def prepend_token(self, token):\n    self.tokens.insert(0, token)",
    ".django.template.defaulttags.py@@IfNode.__init__": "def __init__(self, conditions_nodelists):\n    self.conditions_nodelists = conditions_nodelists",
    ".django.templatetags.i18n.py@@do_translate": "def do_translate(parser, token):\n    bits = token.split_contents()\n    if len(bits) < 2:\n        raise TemplateSyntaxError(\"'%s' takes at least one argument\" % bits[0])\n    message_string = parser.compile_filter(bits[1])\n    remaining = bits[2:]\n    noop = False\n    asvar = None\n    message_context = None\n    seen = set()\n    invalid_context = {'as', 'noop'}\n    while remaining:\n        option = remaining.pop(0)\n        if option in seen:\n            raise TemplateSyntaxError(\"The '%s' option was specified more than once.\" % option)\n        elif option == 'noop':\n            noop = True\n        elif option == 'context':\n            try:\n                value = remaining.pop(0)\n            except IndexError:\n                raise TemplateSyntaxError(\"No argument provided to the '%s' tag for the context option.\" % bits[0])\n            if value in invalid_context:\n                raise TemplateSyntaxError(\"Invalid argument '%s' provided to the '%s' tag for the context option\" % (value, bits[0]))\n            message_context = parser.compile_filter(value)\n        elif option == 'as':\n            try:\n                value = remaining.pop(0)\n            except IndexError:\n                raise TemplateSyntaxError(\"No argument provided to the '%s' tag for the as option.\" % bits[0])\n            asvar = value\n        else:\n            raise TemplateSyntaxError('Unknown argument for \\'%s\\' tag: \\'%s\\'. The only options available are \\'noop\\', \\'context\\' \"xxx\", and \\'as VAR\\'.' % (bits[0], option))\n        seen.add(option)\n    return TranslateNode(message_string, noop, asvar, message_context)",
    ".django.utils.safestring.py@@mark_safe": "def mark_safe(s):\n    if hasattr(s, '__html__'):\n        return s\n    if callable(s):\n        return _safety_decorator(mark_safe, s)\n    return SafeString(s)",
    ".django.template.base.py@@Variable.resolve": "def resolve(self, context):\n    if self.lookups is not None:\n        value = self._resolve_lookup(context)\n    else:\n        value = self.literal\n    if self.translate:\n        is_safe = isinstance(value, SafeData)\n        msgid = value.replace('%', '%%')\n        msgid = mark_safe(msgid) if is_safe else msgid\n        if self.message_context:\n            return pgettext_lazy(self.message_context, msgid)\n        else:\n            return gettext_lazy(msgid)\n    return value",
    ".django.templatetags.i18n.py@@TranslateNode.__init__": "def __init__(self, filter_expression, noop, asvar=None, message_context=None):\n    self.noop = noop\n    self.asvar = asvar\n    self.message_context = message_context\n    self.filter_expression = filter_expression\n    if isinstance(self.filter_expression.var, str):\n        self.filter_expression.var = Variable(\"'%s'\" % self.filter_expression.var)",
    ".django.utils.safestring.py@@SafeString.__str__": "def __str__(self):\n    return self",
    ".django.templatetags.i18n.py@@do_block_translate": "def do_block_translate(parser, token):\n    bits = token.split_contents()\n    options = {}\n    remaining_bits = bits[1:]\n    asvar = None\n    while remaining_bits:\n        option = remaining_bits.pop(0)\n        if option in options:\n            raise TemplateSyntaxError('The %r option was specified more than once.' % option)\n        if option == 'with':\n            value = token_kwargs(remaining_bits, parser, support_legacy=True)\n            if not value:\n                raise TemplateSyntaxError('\"with\" in %r tag needs at least one keyword argument.' % bits[0])\n        elif option == 'count':\n            value = token_kwargs(remaining_bits, parser, support_legacy=True)\n            if len(value) != 1:\n                raise TemplateSyntaxError('\"count\" in %r tag expected exactly one keyword argument.' % bits[0])\n        elif option == 'context':\n            try:\n                value = remaining_bits.pop(0)\n                value = parser.compile_filter(value)\n            except Exception:\n                raise TemplateSyntaxError('\"context\" in %r tag expected exactly one argument.' % bits[0])\n        elif option == 'trimmed':\n            value = True\n        elif option == 'asvar':\n            try:\n                value = remaining_bits.pop(0)\n            except IndexError:\n                raise TemplateSyntaxError(\"No argument provided to the '%s' tag for the asvar option.\" % bits[0])\n            asvar = value\n        else:\n            raise TemplateSyntaxError('Unknown argument for %r tag: %r.' % (bits[0], option))\n        options[option] = value\n    if 'count' in options:\n        countervar, counter = next(iter(options['count'].items()))\n    else:\n        countervar, counter = (None, None)\n    if 'context' in options:\n        message_context = options['context']\n    else:\n        message_context = None\n    extra_context = options.get('with', {})\n    trimmed = options.get('trimmed', False)\n    singular = []\n    plural = []\n    while parser.tokens:\n        token = parser.next_token()\n        if token.token_type in (TokenType.VAR, TokenType.TEXT):\n            singular.append(token)\n        else:\n            break\n    if countervar and counter:\n        if token.contents.strip() != 'plural':\n            raise TemplateSyntaxError(\"'blocktrans' doesn't allow other block tags inside it\")\n        while parser.tokens:\n            token = parser.next_token()\n            if token.token_type in (TokenType.VAR, TokenType.TEXT):\n                plural.append(token)\n            else:\n                break\n    if token.contents.strip() != 'endblocktrans':\n        raise TemplateSyntaxError(\"'blocktrans' doesn't allow other block tags (seen %r) inside it\" % token.contents)\n    return BlockTranslateNode(extra_context, singular, plural, countervar, counter, message_context, trimmed=trimmed, asvar=asvar)",
    ".django.templatetags.i18n.py@@BlockTranslateNode.__init__": "def __init__(self, extra_context, singular, plural=None, countervar=None, counter=None, message_context=None, trimmed=False, asvar=None):\n    self.extra_context = extra_context\n    self.singular = singular\n    self.plural = plural\n    self.countervar = countervar\n    self.counter = counter\n    self.message_context = message_context\n    self.trimmed = trimmed\n    self.asvar = asvar",
    ".django.template.base.py@@VariableNode.__init__": "def __init__(self, filter_expression):\n    self.filter_expression = filter_expression",
    ".django.utils.version.py@@get_docs_version": "def get_docs_version(version=None):\n    version = get_complete_version(version)\n    if version[3] != 'final':\n        return 'dev'\n    else:\n        return '%d.%d' % version[:2]",
    ".django.utils.version.py@@get_complete_version": "def get_complete_version(version=None):\n    if version is None:\n        from django import VERSION as version\n    else:\n        assert len(version) == 5\n        assert version[3] in ('alpha', 'beta', 'rc', 'final')\n    return version",
    ".django.template.context.py@@Context.__init__": "def __init__(self, dict_=None, autoescape=True, use_l10n=None, use_tz=None):\n    self.autoescape = autoescape\n    self.use_l10n = use_l10n\n    self.use_tz = use_tz\n    self.template_name = 'unknown'\n    self.render_context = RenderContext()\n    self.template = None\n    super().__init__(dict_)",
    ".django.template.context.py@@BaseContext.__init__": "def __init__(self, dict_=None):\n    self._reset_dicts(dict_)",
    ".django.template.context.py@@BaseContext._reset_dicts": "def _reset_dicts(self, value=None):\n    builtins = {'True': True, 'False': False, 'None': None}\n    self.dicts = [builtins]\n    if value is not None:\n        self.dicts.append(value)",
    ".django.dispatch.dispatcher.py@@Signal._remove_receiver": "def _remove_receiver(self, receiver=None):\n    self._dead_receivers = True"
}