{
    ".xarray.core.duck_array_ops.py@@push": "def push(array, n, axis):\n    from bottleneck import push\n    if is_duck_dask_array(array):\n        return dask_array_ops.push(array, n, axis)\n    else:\n        return push(array, n, axis)",
    ".xarray.core.pycompat.py@@is_duck_dask_array": "def is_duck_dask_array(x):\n    return is_duck_array(x) and is_dask_collection(x)",
    ".xarray.core.utils.py@@is_duck_array": "def is_duck_array(value: Any) -> bool:\n    if isinstance(value, np.ndarray):\n        return True\n    return hasattr(value, 'ndim') and hasattr(value, 'shape') and hasattr(value, 'dtype') and hasattr(value, '__array_function__') and hasattr(value, '__array_ufunc__')",
    ".xarray.core.dask_array_ops.py@@push": "def push(array, n, axis):\n    from bottleneck import push\n    if len(array.chunks[axis]) > 1 and n is not None and (n < array.shape[axis]):\n        raise NotImplementedError('Cannot fill along a chunked axis when limit is not None.Either rechunk to a single chunk along this axis or call .compute() or .load() first.')\n    if all((c == 1 for c in array.chunks[axis])):\n        array = array.rechunk({axis: 2})\n    pushed = array.map_blocks(push, axis=axis, n=n)\n    if len(array.chunks[axis]) > 1:\n        pushed = pushed.map_overlap(push, axis=axis, n=n, depth={axis: (1, 0)}, boundary='none')\n    return pushed"
}