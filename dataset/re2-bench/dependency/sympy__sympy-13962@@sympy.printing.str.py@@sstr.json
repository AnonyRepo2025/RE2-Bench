{
    ".sympy.printing.printer.py@@Printer.__init__": "def __init__(self, settings=None):\n    self._str = str\n    self._settings = self._default_settings.copy()\n    for key, val in self._global_settings.items():\n        if key in self._default_settings:\n            self._settings[key] = val\n    if settings is not None:\n        self._settings.update(settings)\n        if len(self._settings) > len(self._default_settings):\n            for key in self._settings:\n                if key not in self._default_settings:\n                    raise TypeError(\"Unknown setting '%s'.\" % key)\n    self._print_level = 0",
    ".sympy.printing.printer.py@@Printer.doprint": "def doprint(self, expr):\n    return self._str(self._print(expr))",
    ".sympy.printing.printer.py@@Printer._print": "def _print(self, expr, *args, **kwargs):\n    self._print_level += 1\n    try:\n        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):\n            return getattr(expr, self.printmethod)(self, *args, **kwargs)\n        for cls in type(expr).__mro__:\n            printmethod = '_print_' + cls.__name__\n            if hasattr(self, printmethod):\n                return getattr(self, printmethod)(expr, *args, **kwargs)\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1",
    ".sympy.printing.str.py@@StrPrinter._print_Symbol": "def _print_Symbol(self, expr):\n    return expr.name",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.printing.str.py@@StrPrinter._print_Function": "def _print_Function(self, expr):\n    return expr.func.__name__ + '(%s)' % self.stringify(expr.args, ', ')",
    ".sympy.core.function.py@@Application.func": "def func(self):\n    return self.__class__",
    ".sympy.printing.str.py@@StrPrinter.stringify": "def stringify(self, args, sep, level=0):\n    return sep.join([self.parenthesize(item, level) for item in args])",
    ".sympy.printing.str.py@@StrPrinter.parenthesize": "def parenthesize(self, item, level, strict=False):\n    if precedence(item) < level or (not strict and precedence(item) <= level):\n        return '(%s)' % self._print(item)\n    else:\n        return self._print(item)",
    ".sympy.printing.precedence.py@@precedence": "def precedence(item):\n    if hasattr(item, 'precedence'):\n        return item.precedence\n    try:\n        mro = item.__class__.__mro__\n    except AttributeError:\n        return PRECEDENCE['Atom']\n    for i in mro:\n        n = i.__name__\n        if n in PRECEDENCE_FUNCTIONS:\n            return PRECEDENCE_FUNCTIONS[n](item)\n        elif n in PRECEDENCE_VALUES:\n            return PRECEDENCE_VALUES[n]\n    return PRECEDENCE['Atom']",
    ".sympy.printing.str.py@@StrPrinter._print_Rational": "def _print_Rational(self, expr):\n    if expr.q == 1:\n        return str(expr.p)\n    else:\n        if self._settings.get('sympy_integers', False):\n            return 'S(%s)/%s' % (expr.p, expr.q)\n        return '%s/%s' % (expr.p, expr.q)",
    ".sympy.printing.str.py@@StrPrinter._print_Dummy": "def _print_Dummy(self, expr):\n    return '_' + expr.name",
    ".sympy.printing.str.py@@StrPrinter._print_Catalan": "def _print_Catalan(self, expr):\n    return 'Catalan'",
    ".sympy.printing.str.py@@StrPrinter._print_ComplexInfinity": "def _print_ComplexInfinity(self, expr):\n    return 'zoo'",
    ".sympy.printing.str.py@@StrPrinter._print_Derivative": "def _print_Derivative(self, expr):\n    dexpr = expr.expr\n    dvars = [i[0] if i[1] == 1 else i for i in expr.variable_count]\n    return 'Derivative(%s)' % ', '.join(map(self._print, [dexpr] + dvars))",
    ".sympy.core.function.py@@Derivative.expr": "def expr(self):\n    return self._args[0]",
    ".sympy.core.function.py@@Derivative.variable_count": "def variable_count(self):\n    return self._args[1:]",
    ".sympy.core.containers.py@@Tuple.__getitem__": "def __getitem__(self, i):\n    if isinstance(i, slice):\n        indices = i.indices(len(self))\n        return Tuple(*(self.args[j] for j in range(*indices)))\n    return self.args[i]",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, integer_types):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.printing.str.py@@StrPrinter._print_Pow": "def _print_Pow(self, expr, rational=False):\n    PREC = precedence(expr)\n    if expr.exp is S.Half and (not rational):\n        return 'sqrt(%s)' % self._print(expr.base)\n    if expr.is_commutative:\n        if -expr.exp is S.Half and (not rational):\n            return '%s/sqrt(%s)' % tuple(map(self._print, (S.One, expr.base)))\n        if expr.exp is -S.One:\n            return '%s/%s' % (self._print(S.One), self.parenthesize(expr.base, PREC, strict=False))\n    e = self.parenthesize(expr.exp, PREC, strict=False)\n    if self.printmethod == '_sympyrepr' and expr.exp.is_Rational and (expr.exp.q != 1):\n        if e.startswith('(Rational'):\n            return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e[1:-1])\n    return '%s**%s' % (self.parenthesize(expr.base, PREC, strict=False), e)",
    ".sympy.core.power.py@@Pow.exp": "def exp(self):\n    return self._args[1]",
    ".sympy.core.numbers.py@@Integer.__neg__": "def __neg__(self):\n    return Integer(-self.p)",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, string_types):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Integer can only work with integer expressions.')\n    try:\n        return _intcache[ival]\n    except KeyError:\n        obj = Expr.__new__(cls)\n        obj.p = ival\n        _intcache[ival] = obj\n        return obj",
    ".sympy.core.numbers.py@@One.__neg__": "def __neg__():\n    return S.NegativeOne",
    ".sympy.printing.precedence.py@@precedence_Integer": "def precedence_Integer(item):\n    if item.p < 0:\n        return PRECEDENCE['Add']\n    return PRECEDENCE['Atom']",
    ".sympy.printing.str.py@@StrPrinter._print_Integer": "def _print_Integer(self, expr):\n    if self._settings.get('sympy_integers', False):\n        return 'S(%s)' % expr\n    return str(expr.p)",
    ".sympy.core.power.py@@Pow.base": "def base(self):\n    return self._args[0]",
    ".sympy.printing.str.py@@StrPrinter._print_EulerGamma": "def _print_EulerGamma(self, expr):\n    return 'EulerGamma'",
    ".sympy.printing.str.py@@StrPrinter._print_Exp1": "def _print_Exp1(self, expr):\n    return 'E'",
    ".sympy.printing.str.py@@StrPrinter._print_WildFunction": "def _print_WildFunction(self, expr):\n    return expr.name + '_'",
    ".sympy.printing.str.py@@StrPrinter._print_tuple": "def _print_tuple(self, expr):\n    if len(expr) == 1:\n        return '(%s,)' % self._print(expr[0])\n    else:\n        return '(%s)' % self.stringify(expr, ', ')",
    ".sympy.printing.str.py@@StrPrinter._print_Zero": "def _print_Zero(self, expr):\n    if self._settings.get('sympy_integers', False):\n        return 'S(0)'\n    return '0'",
    ".sympy.printing.str.py@@StrPrinter._print_GoldenRatio": "def _print_GoldenRatio(self, expr):\n    return 'GoldenRatio'",
    ".sympy.printing.str.py@@StrPrinter._print_ImaginaryUnit": "def _print_ImaginaryUnit(self, expr):\n    return 'I'",
    ".sympy.printing.str.py@@StrPrinter._print_Infinity": "def _print_Infinity(self, expr):\n    return 'oo'",
    ".sympy.printing.str.py@@StrPrinter._print_Integral": "def _print_Integral(self, expr):\n\n    def _xab_tostr(xab):\n        if len(xab) == 1:\n            return self._print(xab[0])\n        else:\n            return self._print((xab[0],) + tuple(xab[1:]))\n    L = ', '.join([_xab_tostr(l) for l in expr.limits])\n    return 'Integral(%s, %s)' % (self._print(expr.function), L)",
    ".sympy.concrete.expr_with_limits.py@@ExprWithLimits.limits": "def limits(self):\n    return self._args[1:]",
    ".sympy.printing.str.py@@StrPrinter._xab_tostr": "def _xab_tostr(xab):\n    if len(xab) == 1:\n        return self._print(xab[0])\n    else:\n        return self._print((xab[0],) + tuple(xab[1:]))",
    ".sympy.core.containers.py@@Tuple.__len__": "def __len__(self):\n    return len(self.args)",
    ".sympy.concrete.expr_with_limits.py@@ExprWithLimits.function": "def function(self):\n    return self._args[0]",
    ".sympy.core.containers.py@@Tuple.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    if evaluate is None:\n        if global_evaluate[0] is False:\n            evaluate = global_evaluate[0]\n        else:\n            evaluate = True\n    try:\n        if a in sympy_classes:\n            return a\n    except TypeError:\n        pass\n    try:\n        cls = a.__class__\n    except AttributeError:\n        cls = type(a)\n    if cls in sympy_classes:\n        return a\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if type(a).__module__ == 'numpy':\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a)\n    try:\n        return converter[cls](a)\n    except KeyError:\n        for superclass in getmro(cls):\n            try:\n                return converter[superclass](a)\n            except KeyError:\n                continue\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    try:\n        return a._sympy_()\n    except AttributeError:\n        pass\n    if not strict:\n        try:\n            from ..tensor.array import Array\n            return Array(a.flat, a.shape)\n        except AttributeError:\n            pass\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                return sympify(coerce(a))\n            except (TypeError, ValueError, AttributeError, SympifyError):\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.printing.str.py@@StrPrinter._print_NegativeInfinity": "def _print_NegativeInfinity(self, expr):\n    return '-oo'",
    ".sympy.printing.str.py@@StrPrinter._print_AccumulationBounds": "def _print_AccumulationBounds(self, i):\n    return 'AccumBounds(%s, %s)' % (self._print(i.min), self._print(i.max))",
    ".sympy.calculus.util.py@@AccumulationBounds.min": "def min(self):\n    return self.args[0]",
    ".sympy.calculus.util.py@@AccumulationBounds.max": "def max(self):\n    return self.args[1]",
    ".sympy.core.numbers.py@@NegativeOne.__neg__": "def __neg__():\n    return S.One",
    ".sympy.printing.str.py@@StrPrinter._print_list": "def _print_list(self, expr):\n    return '[%s]' % self.stringify(expr, ', ')",
    ".sympy.matrices.matrices.py@@MatrixBase.__getattr__": "def __getattr__(self, attr):\n    if attr in ('diff', 'integrate', 'limit'):\n\n        def doit(*args):\n            item_doit = lambda item: getattr(item, attr)(*args)\n            return self.applyfunc(item_doit)\n        return doit\n    else:\n        raise AttributeError('%s has no attribute %s.' % (self.__class__.__name__, attr))",
    ".sympy.printing.str.py@@StrPrinter._print_MatrixBase": "def _print_MatrixBase(self, expr):\n    return expr._format_str(self)",
    ".sympy.matrices.matrices.py@@MatrixBase._format_str": "def _format_str(self, printer=None):\n    if not printer:\n        from sympy.printing.str import StrPrinter\n        printer = StrPrinter()\n    if self.rows == 0 or self.cols == 0:\n        return 'Matrix(%s, %s, [])' % (self.rows, self.cols)\n    if self.rows == 1:\n        return 'Matrix([%s])' % self.table(printer, rowsep=',\\n')\n    return 'Matrix([\\n%s])' % self.table(printer, rowsep=',\\n')",
    ".sympy.matrices.matrices.py@@MatrixBase.table": "def table(self, printer, rowstart='[', rowend=']', rowsep='\\n', colsep=', ', align='right'):\n    if self.rows == 0 or self.cols == 0:\n        return '[]'\n    res = []\n    maxlen = [0] * self.cols\n    for i in range(self.rows):\n        res.append([])\n        for j in range(self.cols):\n            s = printer._print(self[i, j])\n            res[-1].append(s)\n            maxlen[j] = max(len(s), maxlen[j])\n    align = {'left': 'ljust', 'right': 'rjust', 'center': 'center', '<': 'ljust', '>': 'rjust', '^': 'center'}[align]\n    for i, row in enumerate(res):\n        for j, elem in enumerate(row):\n            row[j] = getattr(elem, align)(maxlen[j])\n        res[i] = rowstart + colsep.join(row) + rowend\n    return rowsep.join(res)",
    ".sympy.matrices.dense.py@@DenseMatrix.__getitem__": "def __getitem__(self, key):\n    if isinstance(key, tuple):\n        i, j = key\n        try:\n            i, j = self.key2ij(key)\n            return self._mat[i * self.cols + j]\n        except (TypeError, IndexError):\n            if isinstance(i, Expr) and (not i.is_number) or (isinstance(j, Expr) and (not j.is_number)):\n                if (j < 0) is True or (j >= self.shape[1]) is True or (i < 0) is True or ((i >= self.shape[0]) is True):\n                    raise ValueError('index out of boundary')\n                from sympy.matrices.expressions.matexpr import MatrixElement\n                return MatrixElement(self, i, j)\n            if isinstance(i, slice):\n                i = list(range(self.rows))[i]\n            elif is_sequence(i):\n                pass\n            else:\n                i = [i]\n            if isinstance(j, slice):\n                j = list(range(self.cols))[j]\n            elif is_sequence(j):\n                pass\n            else:\n                j = [j]\n            return self.extract(i, j)\n    else:\n        if isinstance(key, slice):\n            return self._mat[key]\n        return self._mat[a2idx(key)]",
    ".sympy.matrices.matrices.py@@MatrixBase.key2ij": "def key2ij(self, key):\n    if is_sequence(key):\n        if not len(key) == 2:\n            raise TypeError('key must be a sequence of length 2')\n        return [a2idx(i, n) if not isinstance(i, slice) else i for i, n in zip(key, self.shape)]\n    elif isinstance(key, slice):\n        return key.indices(len(self))[:2]\n    else:\n        return divmod(a2idx(key, len(self)), self.cols)",
    ".sympy.core.compatibility.py@@is_sequence": "def is_sequence(i, include=None):\n    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))",
    ".sympy.core.compatibility.py@@iterable": "def iterable(i, exclude=(string_types, dict, NotIterable)):\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    ".sympy.matrices.common.py@@MatrixShaping.shape": "def shape(self):\n    return (self.rows, self.cols)",
    ".sympy.matrices.matrices.py@@a2idx": "def a2idx(j, n=None):\n    if type(j) is not int:\n        try:\n            j = j.__index__()\n        except AttributeError:\n            raise IndexError('Invalid index a[%r]' % (j,))\n    if n is not None:\n        if j < 0:\n            j += n\n        if not (j >= 0 and j < n):\n            raise IndexError('Index out of range: a[%s]' % j)\n    return int(j)",
    ".sympy.printing.str.py@@StrPrinter._print_Mul": "def _print_Mul(self, expr):\n    prec = precedence(expr)\n    c, e = expr.as_coeff_Mul()\n    if c < 0:\n        expr = _keep_coeff(-c, e)\n        sign = '-'\n    else:\n        sign = ''\n    a = []\n    b = []\n    if self.order not in ('old', 'none'):\n        args = expr.as_ordered_factors()\n    else:\n        args = Mul.make_args(expr)\n    for item in args:\n        if item.is_commutative and item.is_Pow and item.exp.is_Rational and item.exp.is_negative:\n            if item.exp != -1:\n                b.append(Pow(item.base, -item.exp, evaluate=False))\n            else:\n                b.append(Pow(item.base, -item.exp))\n        elif item.is_Rational and item is not S.Infinity:\n            if item.p != 1:\n                a.append(Rational(item.p))\n            if item.q != 1:\n                b.append(Rational(item.q))\n        else:\n            a.append(item)\n    a = a or [S.One]\n    a_str = [self.parenthesize(x, prec, strict=False) for x in a]\n    b_str = [self.parenthesize(x, prec, strict=False) for x in b]\n    if len(b) == 0:\n        return sign + '*'.join(a_str)\n    elif len(b) == 1:\n        return sign + '*'.join(a_str) + '/' + b_str[0]\n    else:\n        return sign + '*'.join(a_str) + '/(%s)' % '*'.join(b_str)",
    ".sympy.printing.precedence.py@@precedence_Mul": "def precedence_Mul(item):\n    if _coeff_isneg(item):\n        return PRECEDENCE['Add']\n    return PRECEDENCE['Mul']",
    ".sympy.core.function.py@@_coeff_isneg": "def _coeff_isneg(a):\n    if a.is_Mul:\n        a = a.args[0]\n    return a.is_Number and a.is_negative",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.mul.py@@Mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return (coeff, args[0])\n            else:\n                return (coeff, self._new_rawargs(*args))\n        elif coeff.is_negative:\n            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))\n    return (S.One, self)",
    ".sympy.core.numbers.py@@Integer.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.logic.boolalg.py@@BooleanFalse.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.printing.printer.py@@Printer.order": "def order(self):\n    if 'order' in self._settings:\n        return self._settings['order']\n    else:\n        raise AttributeError('No order defined.')",
    ".sympy.core.mul.py@@Mul.as_ordered_factors": "def as_ordered_factors(self, order=None):\n    cpart, ncpart = self.args_cnc()\n    cpart.sort(key=lambda expr: expr.sort_key(order=order))\n    return cpart + ncpart",
    ".sympy.core.expr.py@@Expr.args_cnc": "def args_cnc(self, cset=False, warn=True, split_1=True):\n    if self.is_Mul:\n        args = list(self.args)\n    else:\n        args = [self]\n    for i, mi in enumerate(args):\n        if not mi.is_commutative:\n            c = args[:i]\n            nc = args[i:]\n            break\n    else:\n        c = args\n        nc = []\n    if c and split_1 and (c[0].is_Number and c[0].is_negative and (c[0] is not S.NegativeOne)):\n        c[:1] = [S.NegativeOne, -c[0]]\n    if cset:\n        clen = len(c)\n        c = set(c)\n        if clen and warn and (len(c) != clen):\n            raise ValueError('repeated commutative arguments: %s' % [ci for ci in c if list(self.args).count(ci) > 1])\n    return [c, nc]",
    ".sympy.core.numbers.py@@Number.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (0, ()), (), self)",
    ".sympy.core.numbers.py@@Number.class_key": "def class_key(cls):\n    return (1, 0, 'Number')",
    ".sympy.core.expr.py@@Expr.sort_key": "def sort_key(self, order=None):\n    coeff, expr = self.as_coeff_Mul()\n    if expr.is_Pow:\n        expr, exp = expr.args\n    else:\n        expr, exp = (expr, S.One)\n    if expr.is_Dummy:\n        args = (expr.sort_key(),)\n    elif expr.is_Atom:\n        args = (str(expr),)\n    else:\n        if expr.is_Add:\n            args = expr.as_ordered_terms(order=order)\n        elif expr.is_Mul:\n            args = expr.as_ordered_factors(order=order)\n        else:\n            args = expr.args\n        args = tuple([default_sort_key(arg, order=order) for arg in args])\n    args = (len(args), tuple(args))\n    exp = exp.sort_key(order=order)\n    return (expr.class_key(), args, exp, coeff)",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (S.One, self)",
    ".sympy.core.basic.py@@Basic.class_key": "def class_key(cls):\n    return (5, 0, cls.__name__)",
    ".sympy.core.numbers.py@@Rational.__new__": "def __new__(cls, p, q=None, gcd=None):\n    if q is None:\n        if isinstance(p, Rational):\n            return p\n        if isinstance(p, string_types):\n            if p.count('/') > 1:\n                raise TypeError('invalid input: %s' % p)\n            pq = p.rsplit('/', 1)\n            if len(pq) == 2:\n                p, q = pq\n                fp = fractions.Fraction(p)\n                fq = fractions.Fraction(q)\n                f = fp / fq\n                return Rational(f.numerator, f.denominator, 1)\n            p = p.replace(' ', '')\n            try:\n                p = fractions.Fraction(p)\n            except ValueError:\n                pass\n        if not isinstance(p, string_types):\n            try:\n                if isinstance(p, fractions.Fraction):\n                    return Rational(p.numerator, p.denominator, 1)\n            except NameError:\n                pass\n            if isinstance(p, (float, Float)):\n                return Rational(*_as_integer_ratio(p))\n        if not isinstance(p, SYMPY_INTS + (Rational,)):\n            raise TypeError('invalid input: %s' % p)\n        q = q or S.One\n        gcd = 1\n    else:\n        p = Rational(p)\n        q = Rational(q)\n    if isinstance(q, Rational):\n        p *= q.q\n        q = q.p\n    if isinstance(p, Rational):\n        q *= p.q\n        p = p.p\n    if q == 0:\n        if p == 0:\n            if _errdict['divide']:\n                raise ValueError('Indeterminate 0/0')\n            else:\n                return S.NaN\n        return S.ComplexInfinity\n    if q < 0:\n        q = -q\n        p = -p\n    if not gcd:\n        gcd = igcd(abs(p), q)\n    if gcd > 1:\n        p //= gcd\n        q //= gcd\n    if q == 1:\n        return Integer(p)\n    if p == 1 and q == 2:\n        return S.Half\n    obj = Expr.__new__(cls)\n    obj.p = p\n    obj.q = q\n    return obj",
    ".sympy.printing.str.py@@StrPrinter._print_Basic": "def _print_Basic(self, expr):\n    l = [self._print(o) for o in expr.args]\n    return expr.__class__.__name__ + '(%s)' % ', '.join(l)",
    ".sympy.core.assumptions.py@@StdFactKB.copy": "def copy(self):\n    return self.__class__(self)",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.assumptions.py@@StdFactKB.generator": "def generator(self):\n    return self._generator.copy()",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.assumptions.py@@_ask": "def _ask(fact, obj):\n    assumptions = obj._assumptions\n    handler_map = obj._prop_handler\n    assumptions._tell(fact, None)\n    try:\n        evaluate = handler_map[fact]\n    except KeyError:\n        pass\n    else:\n        a = evaluate(obj)\n        if a is not None:\n            assumptions.deduce_all_facts(((fact, a),))\n            return a\n    prereq = list(_assume_rules.prereq[fact])\n    shuffle(prereq)\n    for pk in prereq:\n        if pk in assumptions:\n            continue\n        if pk in handler_map:\n            _ask(pk, obj)\n            ret_val = assumptions.get(fact)\n            if ret_val is not None:\n                return ret_val\n    return None",
    ".sympy.core.numbers.py@@Float._eval_is_negative": "def _eval_is_negative(self):\n    if self._mpf_ == _mpf_ninf:\n        return True\n    if self._mpf_ == _mpf_inf:\n        return False\n    return self.num < 0",
    ".sympy.core.numbers.py@@Float.num": "def num(self):\n    return mpmath.mpf(self._mpf_)",
    ".sympy.core.numbers.py@@Float.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    if other.is_NumberSymbol:\n        return other.__gt__(self)\n    if other.is_Rational and (not other.is_Integer):\n        self *= other.q\n        other = _sympify(other.p)\n    elif other.is_comparable:\n        other = other.evalf()\n    if other.is_Number and other is not S.NaN:\n        return _sympify(bool(mlib.mpf_lt(self._mpf_, other._as_mpf_val(self._prec))))\n    return Expr.__lt__(self, other)",
    ".sympy.core.basic.py@@Basic.is_comparable": "def is_comparable(self):\n    is_real = self.is_real\n    if is_real is False:\n        return False\n    if not self.is_number:\n        return False\n    n, i = [p.evalf(2) if not p.is_Number else p for p in self.as_real_imag()]\n    if not (i.is_Number and n.is_Number):\n        return False\n    if i:\n        return False\n    else:\n        return n._prec != 1",
    ".sympy.core.expr.py@@Expr.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy import im, re\n    if hints.get('ignore') == self:\n        return None\n    else:\n        return (re(self), im(self))",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Number:\n        if other.is_Rational:\n            return self.p == other.p and self.q == other.q\n        if other.is_Float:\n            return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)\n    return False",
    ".sympy.core.sympify.py@@SympifyError.__init__": "def __init__(self, expr, base_exc=None):\n    self.expr = expr\n    self.base_exc = base_exc",
    ".sympy.core.function.py@@Function.__new__": "def __new__(cls, *args, **options):\n    if cls is Function:\n        return UndefinedFunction(*args, **options)\n    n = len(args)\n    if n not in cls.nargs:\n        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'\n        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})\n    evaluate = options.get('evaluate', global_evaluate[0])\n    result = super(Function, cls).__new__(cls, *args, **options)\n    if evaluate and isinstance(result, cls) and result.args:\n        pr2 = min((cls._should_evalf(a) for a in result.args))\n        if pr2 > 0:\n            pr = max((cls._should_evalf(a) for a in result.args))\n            result = result.evalf(mlib.libmpf.prec_to_dps(pr))\n    return result",
    ".sympy.core.function.py@@FunctionClass.nargs": "def nargs(self):\n    from sympy.sets.sets import FiniteSet\n    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0",
    ".sympy.sets.sets.py@@FiniteSet.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_evaluate[0])\n    if evaluate:\n        args = list(map(sympify, args))\n        if len(args) == 0:\n            return EmptySet()\n    else:\n        args = list(map(sympify, args))\n    args = list(ordered(frozenset(tuple(args)), Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._elements = frozenset(args)\n    return obj",
    ".sympy.core.compatibility.py@@ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    d = defaultdict(list)\n    if keys:\n        if not isinstance(keys, (list, tuple)):\n            keys = [keys]\n        keys = list(keys)\n        f = keys.pop(0)\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n    for k in sorted(d.keys()):\n        if len(d[k]) > 1:\n            if keys:\n                d[k] = ordered(d[k], keys, default, warn)\n            elif default:\n                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)\n            elif warn:\n                from sympy.utilities.iterables import uniq\n                u = list(uniq(d[k]))\n                if len(u) > 1:\n                    raise ValueError('not enough keys to break ties: %s' % u)\n        for v in d[k]:\n            yield v\n        d.pop(k)",
    ".sympy.sets.sets.py@@Set._infimum_key": "def _infimum_key(expr):\n    try:\n        infimum = expr.inf\n        assert infimum.is_comparable\n    except (NotImplementedError, AttributeError, AssertionError, ValueError):\n        infimum = S.Infinity\n    return infimum",
    ".sympy.core.numbers.py@@Infinity.__hash__": "def __hash__(self):\n    return super(Infinity, self).__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super(Number, self).__hash__()",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.sets.sets.py@@Set.__contains__": "def __contains__(self, other):\n    symb = sympify(self.contains(other))\n    if not (symb is S.true or symb is S.false):\n        raise TypeError('contains did not evaluate to a bool: %r' % symb)\n    return bool(symb)",
    ".sympy.sets.sets.py@@Set.contains": "def contains(self, other):\n    other = sympify(other, strict=True)\n    ret = sympify(self._contains(other))\n    if ret is None:\n        ret = Contains(other, self, evaluate=False)\n    return ret",
    ".sympy.sets.sets.py@@FiniteSet._contains": "def _contains(self, other):\n    r = false\n    for e in self._elements:\n        t = Eq(e, other, evaluate=True)\n        if t is true:\n            return t\n        elif t is not false:\n            r = None\n    return r",
    ".sympy.core.relational.py@@Equality.__new__": "def __new__(cls, lhs, rhs=0, **options):\n    from sympy.core.add import Add\n    from sympy.core.logic import fuzzy_bool\n    from sympy.core.expr import _n2\n    from sympy.simplify.simplify import clear_coefficients\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    evaluate = options.pop('evaluate', global_evaluate[0])\n    if evaluate:\n        if hasattr(lhs, '_eval_Eq'):\n            r = lhs._eval_Eq(rhs)\n            if r is not None:\n                return r\n        if hasattr(rhs, '_eval_Eq'):\n            r = rhs._eval_Eq(lhs)\n            if r is not None:\n                return r\n        if lhs == rhs:\n            return S.true\n        elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):\n            return S.false\n        elif not (lhs.is_Symbol or rhs.is_Symbol) and isinstance(lhs, Boolean) != isinstance(rhs, Boolean):\n            return S.false\n        fin = L, R = [i.is_finite for i in (lhs, rhs)]\n        if None not in fin:\n            if L != R:\n                return S.false\n            if L is False:\n                if lhs == -rhs:\n                    return S.false\n                return S.true\n        elif None in fin and False in fin:\n            return Relational.__new__(cls, lhs, rhs, **options)\n        if all((isinstance(i, Expr) for i in (lhs, rhs))):\n            dif = lhs - rhs\n            z = dif.is_zero\n            if z is not None:\n                if z is False and dif.is_commutative:\n                    return S.false\n                if z:\n                    return S.true\n            n2 = _n2(lhs, rhs)\n            if n2 is not None:\n                return _sympify(n2 == 0)\n            n, d = dif.as_numer_denom()\n            rv = None\n            if n.is_zero:\n                rv = d.is_nonzero\n            elif n.is_finite:\n                if d.is_infinite:\n                    rv = S.true\n                elif n.is_zero is False:\n                    rv = d.is_infinite\n                    if rv is None:\n                        l, r = clear_coefficients(d, S.Infinity)\n                        args = [_.subs(l, r) for _ in (lhs, rhs)]\n                        if args != [lhs, rhs]:\n                            rv = fuzzy_bool(Eq(*args))\n                            if rv is True:\n                                rv = None\n            elif any((a.is_infinite for a in Add.make_args(n))):\n                rv = S.false\n            if rv is not None:\n                return _sympify(rv)\n    return Relational.__new__(cls, lhs, rhs, **options)",
    ".sympy.logic.boolalg.py@@BooleanTrue.__hash__": "def __hash__(self):\n    return hash(True)",
    ".sympy.logic.boolalg.py@@BooleanTrue.__nonzero__": "def __nonzero__(self):\n    return True",
    ".sympy.core.function.py@@Application.__new__": "def __new__(cls, *args, **options):\n    from sympy.sets.fancysets import Naturals0\n    from sympy.sets.sets import FiniteSet\n    args = list(map(sympify, args))\n    evaluate = options.pop('evaluate', global_evaluate[0])\n    options.pop('nargs', None)\n    if options:\n        raise ValueError('Unknown options: %s' % options)\n    if evaluate:\n        evaluated = cls.eval(*args)\n        if evaluated is not None:\n            return evaluated\n    obj = super(Application, cls).__new__(cls, *args, **options)\n    try:\n        if is_sequence(obj.nargs):\n            nargs = tuple(ordered(set(obj.nargs)))\n        elif obj.nargs is not None:\n            nargs = (as_int(obj.nargs),)\n        else:\n            nargs = None\n    except AttributeError:\n        nargs = obj._nargs\n    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()\n    return obj",
    ".sympy.functions.elementary.complexes.py@@re.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_real:\n        return arg\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        return S.Zero\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[0]\n    elif arg.is_Function and isinstance(arg, conjugate):\n        return re(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_real:\n                    reverted.append(coeff)\n            elif not term.has(S.ImaginaryUnit) and term.is_real:\n                excluded.append(term)\n            else:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[0])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) - im(b) + c",
    ".sympy.functions.elementary.complexes.py@@im.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_real:\n        return S.Zero\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        return -S.ImaginaryUnit * arg\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[1]\n    elif arg.is_Function and isinstance(arg, conjugate):\n        return -im(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_real:\n                    reverted.append(coeff)\n                else:\n                    excluded.append(coeff)\n            elif term.has(S.ImaginaryUnit) or not term.is_real:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[1])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) + re(b) + c",
    ".sympy.core.numbers.py@@Zero.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.core.evalf.py@@EvalfMixin.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    from sympy import Float, Number\n    n = n if n is not None else 15\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n    if n == 1 and isinstance(self, Number):\n        from sympy.core.expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        try:\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            return v\n    re, im, re_acc, im_acc = result\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im * S.ImaginaryUnit\n    else:\n        return re",
    ".sympy.core.evalf.py@@evalf": "def evalf(x, prec, options):\n    from sympy import re as re_, im as im_\n    try:\n        rf = evalf_table[x.func]\n        r = rf(x, prec, options)\n    except KeyError:\n        try:\n            if 'subs' in options:\n                x = x.subs(evalf_subs(prec, options['subs']))\n            xe = x._eval_evalf(prec)\n            re, im = xe.as_real_imag()\n            if re.has(re_) or im.has(im_):\n                raise NotImplementedError\n            if re == 0:\n                re = None\n                reprec = None\n            elif re.is_number:\n                re = re._to_mpmath(prec, allow_ints=False)._mpf_\n                reprec = prec\n            else:\n                raise NotImplementedError\n            if im == 0:\n                im = None\n                imprec = None\n            elif im.is_number:\n                im = im._to_mpmath(prec, allow_ints=False)._mpf_\n                imprec = prec\n            else:\n                raise NotImplementedError\n            r = (re, im, reprec, imprec)\n        except AttributeError:\n            raise NotImplementedError\n    if options.get('verbose'):\n        print('### input', x)\n        print('### output', to_str(r[0] or fzero, 50))\n        print('### raw', r)\n        print()\n    chop = options.get('chop', False)\n    if chop:\n        if chop is True:\n            chop_prec = prec\n        else:\n            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))\n            if chop_prec == 3:\n                chop_prec -= 1\n        r = chop_parts(r, chop_prec)\n    if options.get('strict'):\n        check_target(x, r, prec)\n    return r",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.core.numbers.py@@Integer._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_int(self.p, prec, rnd)",
    ".sympy.printing.precedence.py@@precedence_Float": "def precedence_Float(item):\n    if item < 0:\n        return PRECEDENCE['Add']\n    return PRECEDENCE['Atom']",
    ".sympy.printing.str.py@@StrPrinter._print_Float": "def _print_Float(self, expr):\n    prec = expr._prec\n    if prec < 5:\n        dps = 0\n    else:\n        dps = prec_to_dps(expr._prec)\n    if self._settings['full_prec'] is True:\n        strip = False\n    elif self._settings['full_prec'] is False:\n        strip = True\n    elif self._settings['full_prec'] == 'auto':\n        strip = self._print_level > 1\n    rv = mlib.to_str(expr._mpf_, dps, strip_zeros=strip)\n    if rv.startswith('-.0'):\n        rv = '-0.' + rv[3:]\n    elif rv.startswith('.0'):\n        rv = '0.' + rv[2:]\n    if rv.startswith('+'):\n        rv = rv[1:]\n    return rv",
    ".sympy.core.operations.py@@AssocOp._new_rawargs": "def _new_rawargs(self, *args, **kwargs):\n    if kwargs.pop('reeval', True) and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)",
    ".sympy.core.operations.py@@AssocOp._from_args": "def _from_args(cls, args, is_commutative=None):\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n    obj = super(AssocOp, cls).__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and((a.is_commutative for a in args))\n    obj.is_commutative = is_commutative\n    return obj",
    ".sympy.printing.str.py@@StrPrinter._print_NaN": "def _print_NaN(self, expr):\n    return 'nan'",
    ".sympy.printing.str.py@@StrPrinter._print_Order": "def _print_Order(self, expr):\n    if all((p is S.Zero for p in expr.point)) or not len(expr.variables):\n        if len(expr.variables) <= 1:\n            return 'O(%s)' % self._print(expr.expr)\n        else:\n            return 'O(%s)' % self.stringify((expr.expr,) + expr.variables, ', ', 0)\n    else:\n        return 'O(%s)' % self.stringify(expr.args, ', ', 0)",
    ".sympy.series.order.py@@Order.point": "def point(self):\n    if self.args[1:]:\n        return tuple((x[1] for x in self.args[1:]))\n    else:\n        return ()",
    ".sympy.series.order.py@@Order.variables": "def variables(self):\n    if self.args[1:]:\n        return tuple((x[0] for x in self.args[1:]))\n    else:\n        return ()",
    ".sympy.series.order.py@@Order.expr": "def expr(self):\n    return self.args[0]",
    ".sympy.printing.str.py@@StrPrinter._print_Tuple": "def _print_Tuple(self, expr):\n    return self._print_tuple(expr)",
    ".sympy.printing.str.py@@StrPrinter._print_Permutation": "def _print_Permutation(self, expr):\n    from sympy.combinatorics.permutations import Permutation, Cycle\n    if Permutation.print_cyclic:\n        if not expr.size:\n            return '()'\n        s = Cycle(expr)(expr.size - 1).__repr__()[len('Cycle'):]\n        last = s.rfind('(')\n        if not last == 0 and ',' not in s[last:]:\n            s = s[last:] + s[:last]\n        s = s.replace(',', '')\n        return s\n    else:\n        s = expr.support()\n        if not s:\n            if expr.size < 5:\n                return 'Permutation(%s)' % str(expr.array_form)\n            return 'Permutation([], size=%s)' % expr.size\n        trim = str(expr.array_form[:s[-1] + 1]) + ', size=%s' % expr.size\n        use = full = str(expr.array_form)\n        if len(trim) < len(full):\n            use = trim\n        return 'Permutation(%s)' % use",
    ".sympy.combinatorics.permutations.py@@Permutation.support": "def support(self):\n    a = self.array_form\n    return [i for i, e in enumerate(a) if a[i] != i]",
    ".sympy.combinatorics.permutations.py@@Permutation.array_form": "def array_form(self):\n    return self._array_form[:]",
    ".sympy.combinatorics.permutations.py@@Permutation.size": "def size(self):\n    return self._size",
    ".sympy.combinatorics.permutations.py@@Cycle.__init__": "def __init__(self, *args):\n    if not args:\n        return\n    if len(args) == 1:\n        if isinstance(args[0], Permutation):\n            for c in args[0].cyclic_form:\n                self.update(self(*c))\n            return\n        elif isinstance(args[0], Cycle):\n            for k, v in args[0].items():\n                self[k] = v\n            return\n    args = [as_int(a) for a in args]\n    if any((i < 0 for i in args)):\n        raise ValueError('negative integers are not allowed in a cycle.')\n    if has_dups(args):\n        raise ValueError('All elements must be unique in a cycle.')\n    for i in range(-len(args), 0):\n        self[args[i]] = args[i + 1]",
    ".sympy.combinatorics.permutations.py@@Permutation.cyclic_form": "def cyclic_form(self):\n    if self._cyclic_form is not None:\n        return list(self._cyclic_form)\n    array_form = self.array_form\n    unchecked = [True] * len(array_form)\n    cyclic_form = []\n    for i in range(len(array_form)):\n        if unchecked[i]:\n            cycle = []\n            cycle.append(i)\n            unchecked[i] = False\n            j = i\n            while unchecked[array_form[j]]:\n                j = array_form[j]\n                cycle.append(j)\n                unchecked[j] = False\n            if len(cycle) > 1:\n                cyclic_form.append(cycle)\n                assert cycle == list(minlex(cycle, is_set=True))\n    cyclic_form.sort()\n    self._cyclic_form = cyclic_form[:]\n    return cyclic_form",
    ".sympy.combinatorics.permutations.py@@Cycle.__call__": "def __call__(self, *other):\n    rv = Cycle(*other)\n    for k, v in zip(list(self.keys()), [rv[self[k]] for k in self.keys()]):\n        rv[k] = v\n    return rv",
    ".sympy.core.compatibility.py@@as_int": "def as_int(n):\n    try:\n        result = int(n)\n        if result != n:\n            raise TypeError\n    except TypeError:\n        raise ValueError('%s is not an integer' % (n,))\n    return result",
    ".sympy.utilities.iterables.py@@has_dups": "def has_dups(seq):\n    from sympy.core.containers import Dict\n    from sympy.sets.sets import Set\n    if isinstance(seq, (dict, set, Dict, Set)):\n        return False\n    uniq = set()\n    return any((True for s in seq if s in uniq or uniq.add(s)))",
    ".sympy.combinatorics.permutations.py@@Cycle.__repr__": "def __repr__(self):\n    if not self:\n        return 'Cycle()'\n    cycles = Permutation(self).cyclic_form\n    s = ''.join((str(tuple(c)) for c in cycles))\n    big = self.size - 1\n    if not any((i == big for c in cycles for i in c)):\n        s += '(%s)' % big\n    return 'Cycle%s' % s",
    ".sympy.combinatorics.permutations.py@@Permutation.__new__": "def __new__(cls, *args, **kwargs):\n    size = kwargs.pop('size', None)\n    if size is not None:\n        size = int(size)\n    ok = True\n    if not args:\n        return cls._af_new(list(range(size or 0)))\n    elif len(args) > 1:\n        return cls._af_new(Cycle(*args).list(size))\n    if len(args) == 1:\n        a = args[0]\n        if isinstance(a, cls):\n            if size is None or size == a.size:\n                return a\n            return cls(a.array_form, size=size)\n        if isinstance(a, Cycle):\n            return cls._af_new(a.list(size))\n        if not is_sequence(a):\n            return cls._af_new(list(range(a + 1)))\n        if has_variety((is_sequence(ai) for ai in a)):\n            ok = False\n    else:\n        ok = False\n    if not ok:\n        raise ValueError('Permutation argument must be a list of ints, a list of lists, Permutation or Cycle.')\n    args = list(args[0])\n    is_cycle = args and is_sequence(args[0])\n    if is_cycle:\n        args = [[int(i) for i in c] for c in args]\n    else:\n        args = [int(i) for i in args]\n    temp = flatten(args)\n    if has_dups(temp) and (not is_cycle):\n        raise ValueError('there were repeated elements.')\n    temp = set(temp)\n    if not is_cycle and any((i not in temp for i in range(len(temp)))):\n        raise ValueError('Integers 0 through %s must be present.' % max(temp))\n    if is_cycle:\n        c = Cycle()\n        for ci in args:\n            c = c(*ci)\n        aform = c.list()\n    else:\n        aform = list(args)\n    if size and size > len(aform):\n        aform.extend(list(range(len(aform), size)))\n    return cls._af_new(aform)",
    ".sympy.combinatorics.permutations.py@@Cycle.list": "def list(self, size=None):\n    if not self and size is None:\n        raise ValueError('must give size for empty Cycle')\n    if size is not None:\n        big = max([i for i in self.keys() if self[i] != i] + [0])\n        size = max(size, big + 1)\n    else:\n        size = self.size\n    return [self[i] for i in range(size)]",
    ".sympy.combinatorics.permutations.py@@Cycle.size": "def size(self):\n    if not self:\n        return 0\n    return max(self.keys()) + 1",
    ".sympy.combinatorics.permutations.py@@Permutation._af_new": "def _af_new(cls, perm):\n    p = Basic.__new__(cls, perm)\n    p._array_form = perm\n    p._size = len(perm)\n    return p",
    ".sympy.combinatorics.permutations.py@@Cycle.__missing__": "def __missing__(self, arg):\n    arg = as_int(arg)\n    self[arg] = arg\n    return arg",
    ".sympy.utilities.iterables.py@@minlex": "def minlex(seq, directed=True, is_set=False, small=None):\n    is_str = isinstance(seq, str)\n    seq = list(seq)\n    if small is None:\n        small = min(seq, key=default_sort_key)\n    if is_set:\n        i = seq.index(small)\n        if not directed:\n            n = len(seq)\n            p = (i + 1) % n\n            m = (i - 1) % n\n            if default_sort_key(seq[p]) > default_sort_key(seq[m]):\n                seq = list(reversed(seq))\n                i = n - i - 1\n        if i:\n            seq = rotate_left(seq, i)\n        best = seq\n    else:\n        count = seq.count(small)\n        if count == 1 and directed:\n            best = rotate_left(seq, seq.index(small))\n        else:\n            best = seq\n            for i in range(count):\n                seq = rotate_left(seq, seq.index(small, count != 1))\n                if seq < best:\n                    best = seq\n                if not directed:\n                    seq = rotate_left(seq, 1)\n                    seq = list(reversed(seq))\n                    if seq < best:\n                        best = seq\n                    seq = list(reversed(seq))\n                    seq = rotate_right(seq, 1)\n    if is_str:\n        return ''.join(best)\n    return tuple(best)",
    ".sympy.core.compatibility.py@@default_sort_key": "def default_sort_key(item, order=None):\n    from .singleton import S\n    from .basic import Basic\n    from .sympify import sympify, SympifyError\n    from .compatibility import iterable\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n    if iterable(item, exclude=string_types):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            args = list(item)\n            unordered = False\n        args = [default_sort_key(arg, order=order) for arg in args]\n        if unordered:\n            args = sorted(args)\n        cls_index, args = (10, (len(args), tuple(args)))\n    else:\n        if not isinstance(item, string_types):\n            try:\n                item = sympify(item)\n            except SympifyError:\n                pass\n            else:\n                if isinstance(item, Basic):\n                    return default_sort_key(item)\n        cls_index, args = (0, (1, (str(item),)))\n    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)",
    ".sympy.printing.str.py@@StrPrinter._print_Pi": "def _print_Pi(self, expr):\n    return 'pi'",
    ".sympy.printing.str.py@@StrPrinter._print_Poly": "def _print_Poly(self, expr):\n    ATOM_PREC = PRECEDENCE['Atom'] - 1\n    terms, gens = ([], [self.parenthesize(s, ATOM_PREC) for s in expr.gens])\n    for monom, coeff in expr.terms():\n        s_monom = []\n        for i, exp in enumerate(monom):\n            if exp > 0:\n                if exp == 1:\n                    s_monom.append(gens[i])\n                else:\n                    s_monom.append(gens[i] + '**%d' % exp)\n        s_monom = '*'.join(s_monom)\n        if coeff.is_Add:\n            if s_monom:\n                s_coeff = '(' + self._print(coeff) + ')'\n            else:\n                s_coeff = self._print(coeff)\n        else:\n            if s_monom:\n                if coeff is S.One:\n                    terms.extend(['+', s_monom])\n                    continue\n                if coeff is S.NegativeOne:\n                    terms.extend(['-', s_monom])\n                    continue\n            s_coeff = self._print(coeff)\n        if not s_monom:\n            s_term = s_coeff\n        else:\n            s_term = s_coeff + '*' + s_monom\n        if s_term.startswith('-'):\n            terms.extend(['-', s_term[1:]])\n        else:\n            terms.extend(['+', s_term])\n    if terms[0] in ['-', '+']:\n        modifier = terms.pop(0)\n        if modifier == '-':\n            terms[0] = '-' + terms[0]\n    format = expr.__class__.__name__ + '(%s, %s'\n    from sympy.polys.polyerrors import PolynomialError\n    try:\n        format += ', modulus=%s' % expr.get_modulus()\n    except PolynomialError:\n        format += \", domain='%s'\" % expr.get_domain()\n    format += ')'\n    for index, item in enumerate(gens):\n        if len(item) > 2 and (item[:1] == '(' and item[len(item) - 1:] == ')'):\n            gens[index] = item[1:len(item) - 1]\n    return format % (' '.join(terms), ', '.join(gens))",
    ".sympy.polys.polytools.py@@Poly.terms": "def terms(f, order=None):\n    return [(m, f.rep.dom.to_sympy(c)) for m, c in f.rep.terms(order=order)]",
    ".sympy.polys.polyclasses.py@@DMP.terms": "def terms(f, order=None):\n    return dmp_list_terms(f.rep, f.lev, f.dom, order=order)",
    ".sympy.polys.densebasic.py@@dmp_list_terms": "def dmp_list_terms(f, u, K, order=None):\n\n    def sort(terms, O):\n        return sorted(terms, key=lambda term: O(term[0]), reverse=True)\n    terms = _rec_list_terms(f, u, ())\n    if not terms:\n        return [((0,) * (u + 1), K.zero)]\n    if order is None:\n        return terms\n    else:\n        return sort(terms, monomial_key(order))",
    ".sympy.polys.densebasic.py@@_rec_list_terms": "def _rec_list_terms(g, v, monom):\n    d, terms = (dmp_degree(g, v), [])\n    if not v:\n        for i, c in enumerate(g):\n            if not c:\n                continue\n            terms.append((monom + (d - i,), c))\n    else:\n        w = v - 1\n        for i, c in enumerate(g):\n            terms.extend(_rec_list_terms(c, w, monom + (d - i,)))\n    return terms",
    ".sympy.polys.densebasic.py@@dmp_degree": "def dmp_degree(f, u):\n    if dmp_zero_p(f, u):\n        return -oo\n    else:\n        return len(f) - 1",
    ".sympy.polys.densebasic.py@@dmp_zero_p": "def dmp_zero_p(f, u):\n    while u:\n        if len(f) != 1:\n            return False\n        f = f[0]\n        u -= 1\n    return not f",
    ".sympy.core.numbers.py@@Infinity.__neg__": "def __neg__(self):\n    return S.NegativeInfinity",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.to_sympy": "def to_sympy(self, a):\n    return SymPyInteger(a)",
    ".sympy.polys.polytools.py@@Poly.get_modulus": "def get_modulus(f):\n    domain = f.get_domain()\n    if domain.is_FiniteField:\n        return Integer(domain.characteristic())\n    else:\n        raise PolynomialError('not a polynomial over a Galois field')",
    ".sympy.polys.polytools.py@@Poly.get_domain": "def get_domain(f):\n    return f.rep.dom",
    ".sympy.polys.domains.domain.py@@Domain.__str__": "def __str__(self):\n    return self.rep",
    ".sympy.core.expr.py@@Expr.__neg__": "def __neg__(self):\n    return Mul(S.NegativeOne, self)",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, **options):\n    from sympy import Order\n    args = list(map(_sympify, args))\n    args = [a for a in args if a is not cls.identity]\n    if not options.pop('evaluate', global_evaluate[0]):\n        return cls._from_args(args)\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if order_symbols is not None:\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.core.mul.py@@Mul.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        assert not a is S.One\n        if not a.is_zero and a.is_Rational:\n            r, b = b.as_coeff_Mul()\n            if b.is_Add:\n                if r is not S.One:\n                    rv = ([cls(a * r, b, evaluate=False)], [], None)\n                elif global_distribute[0] and b.is_commutative:\n                    r, b = b.as_coeff_Add()\n                    bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n                    _addsort(bargs)\n                    ar = a * r\n                    if ar:\n                        bargs.insert(0, ar)\n                    bargs = [Add._from_args(bargs)]\n                    rv = (bargs, [], None)\n        if rv:\n            return rv\n    c_part = []\n    nc_part = []\n    nc_seq = []\n    coeff = S.One\n    c_powers = []\n    num_exp = []\n    neg1e = S.Zero\n    pnum_rat = {}\n    order_symbols = None\n    for o in seq:\n        if o.is_Order:\n            o, order_symbols = o.as_expr_variables(order_symbols)\n        if o.is_Mul:\n            if o.is_commutative:\n                seq.extend(o.args)\n            else:\n                for q in o.args:\n                    if q.is_commutative:\n                        seq.append(q)\n                    else:\n                        nc_seq.append(q)\n                seq.append(NC_Marker)\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o is S.Zero):\n                return ([S.NaN], [], None)\n            elif coeff.is_Number:\n                coeff *= o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__mul__(coeff)\n            continue\n        elif isinstance(o, MatrixExpr):\n            coeff = o.__mul__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if not coeff:\n                return ([S.NaN], [], None)\n            if coeff is S.ComplexInfinity:\n                return ([S.ComplexInfinity], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o is S.ImaginaryUnit:\n            neg1e += S.Half\n            continue\n        elif o.is_commutative:\n            b, e = o.as_base_exp()\n            if o.is_Pow:\n                if b.is_Number:\n                    if e.is_Rational:\n                        if e.is_Integer:\n                            coeff *= Pow(b, e)\n                            continue\n                        elif e.is_negative:\n                            seq.append(Pow(b, e))\n                            continue\n                        elif b.is_negative:\n                            neg1e += e\n                            b = -b\n                        if b is not S.One:\n                            pnum_rat.setdefault(b, []).append(e)\n                        continue\n                    elif b.is_positive or e.is_integer:\n                        num_exp.append((b, e))\n                        continue\n                elif b is S.ImaginaryUnit and e.is_Rational:\n                    neg1e += e / 2\n                    continue\n            c_powers.append((b, e))\n        else:\n            if o is not NC_Marker:\n                nc_seq.append(o)\n            while nc_seq:\n                o = nc_seq.pop(0)\n                if not nc_part:\n                    nc_part.append(o)\n                    continue\n                o1 = nc_part.pop()\n                b1, e1 = o1.as_base_exp()\n                b2, e2 = o.as_base_exp()\n                new_exp = e1 + e2\n                if b1 == b2 and (not new_exp.is_Add):\n                    o12 = b1 ** new_exp\n                    if o12.is_commutative:\n                        seq.append(o12)\n                        continue\n                    else:\n                        nc_seq.insert(0, o12)\n                else:\n                    nc_part.append(o1)\n                    nc_part.append(o)\n\n    def _gather(c_powers):\n        common_b = {}\n        for b, e in c_powers:\n            co = e.as_coeff_Mul()\n            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n        for b, d in common_b.items():\n            for di, li in d.items():\n                d[di] = Add(*li)\n        new_c_powers = []\n        for b, e in common_b.items():\n            new_c_powers.extend([(b, c * t) for t, c in e.items()])\n        return new_c_powers\n    c_powers = _gather(c_powers)\n    num_exp = _gather(num_exp)\n    for i in range(2):\n        new_c_powers = []\n        changed = False\n        for b, e in c_powers:\n            if e.is_zero:\n                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):\n                    return ([S.NaN], [], None)\n                continue\n            if e is S.One:\n                if b.is_Number:\n                    coeff *= b\n                    continue\n                p = b\n            if e is not S.One:\n                p = Pow(b, e)\n                if p.is_Pow and (not b.is_Pow):\n                    bi = b\n                    b, e = p.as_base_exp()\n                    if b != bi:\n                        changed = True\n            c_part.append(p)\n            new_c_powers.append((b, e))\n        if changed and len(set((b for b, e in new_c_powers))) != len(new_c_powers):\n            c_part = []\n            c_powers = _gather(new_c_powers)\n        else:\n            break\n    inv_exp_dict = {}\n    for b, e in num_exp:\n        inv_exp_dict.setdefault(e, []).append(b)\n    for e, b in inv_exp_dict.items():\n        inv_exp_dict[e] = cls(*b)\n    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n    comb_e = {}\n    for b, e in pnum_rat.items():\n        comb_e.setdefault(Add(*e), []).append(b)\n    del pnum_rat\n    num_rat = []\n    for e, b in comb_e.items():\n        b = cls(*b)\n        if e.q == 1:\n            coeff *= Pow(b, e)\n            continue\n        if e.p > e.q:\n            e_i, ep = divmod(e.p, e.q)\n            coeff *= Pow(b, e_i)\n            e = Rational(ep, e.q)\n        num_rat.append((b, e))\n    del comb_e\n    pnew = defaultdict(list)\n    i = 0\n    while i < len(num_rat):\n        bi, ei = num_rat[i]\n        grow = []\n        for j in range(i + 1, len(num_rat)):\n            bj, ej = num_rat[j]\n            g = bi.gcd(bj)\n            if g is not S.One:\n                e = ei + ej\n                if e.q == 1:\n                    coeff *= Pow(g, e)\n                else:\n                    if e.p > e.q:\n                        e_i, ep = divmod(e.p, e.q)\n                        coeff *= Pow(g, e_i)\n                        e = Rational(ep, e.q)\n                    grow.append((g, e))\n                num_rat[j] = (bj / g, ej)\n                bi = bi / g\n                if bi is S.One:\n                    break\n        if bi is not S.One:\n            obj = Pow(bi, ei)\n            if obj.is_Number:\n                coeff *= obj\n            else:\n                for obj in Mul.make_args(obj):\n                    if obj.is_Number:\n                        coeff *= obj\n                    else:\n                        assert obj.is_Pow\n                        bi, ei = obj.args\n                        pnew[ei].append(bi)\n        num_rat.extend(grow)\n        i += 1\n    for e, b in pnew.items():\n        pnew[e] = cls(*b)\n    if neg1e:\n        p, q = neg1e.as_numer_denom()\n        n, p = divmod(p, q)\n        if n % 2:\n            coeff = -coeff\n        if q == 2:\n            c_part.append(S.ImaginaryUnit)\n        elif p:\n            neg1e = Rational(p, q)\n            for e, b in pnew.items():\n                if e == neg1e and b.is_positive:\n                    pnew[e] = -b\n                    break\n            else:\n                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n    c_part.extend([Pow(b, e) for e, b in pnew.items()])\n    if coeff is S.Infinity or coeff is S.NegativeInfinity:\n\n        def _handle_for_oo(c_part, coeff_sign):\n            new_c_part = []\n            for t in c_part:\n                if t.is_positive:\n                    continue\n                if t.is_negative:\n                    coeff_sign *= -1\n                    continue\n                new_c_part.append(t)\n            return (new_c_part, coeff_sign)\n        c_part, coeff_sign = _handle_for_oo(c_part, 1)\n        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n        coeff *= coeff_sign\n    if coeff is S.ComplexInfinity:\n        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n    elif coeff is S.Zero:\n        if any((c.is_finite == False for c in c_part)):\n            return ([S.NaN], [], order_symbols)\n        return ([coeff], [], order_symbols)\n    _new = []\n    for i in c_part:\n        if i.is_Number:\n            coeff *= i\n        else:\n            _new.append(i)\n    c_part = _new\n    _mulsort(c_part)\n    if coeff is not S.One:\n        c_part.insert(0, coeff)\n    if global_distribute[0] and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[1].is_Add:\n        coeff = c_part[0]\n        c_part = [Add(*[coeff * f for f in c_part[1].args])]\n    return (c_part, nc_part, order_symbols)",
    ".sympy.core.numbers.py@@Integer.__mul__": "def __mul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p * other)\n        elif isinstance(other, Integer):\n            return Integer(self.p * other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    ".sympy.core.expr.py@@Expr.as_base_exp": "def as_base_exp(self):\n    return (self, S.One)",
    ".sympy.core.mul.py@@Mul._gather": "def _gather(c_powers):\n    common_b = {}\n    for b, e in c_powers:\n        co = e.as_coeff_Mul()\n        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n    for b, d in common_b.items():\n        for di, li in d.items():\n            d[di] = Add(*li)\n    new_c_powers = []\n    for b, e in common_b.items():\n        new_c_powers.extend([(b, c * t) for t, c in e.items()])\n    return new_c_powers",
    ".sympy.core.numbers.py@@Rational.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (self, S.One)",
    ".sympy.core.mul.py@@_mulsort": "def _mulsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.basic.py@@Basic._exec_constructor_postprocessors": "def _exec_constructor_postprocessors(cls, obj):\n    clsname = obj.__class__.__name__\n    postprocessors = defaultdict(list)\n    for i in obj.args:\n        try:\n            if i in Basic._constructor_postprocessor_mapping:\n                for k, v in Basic._constructor_postprocessor_mapping[i].items():\n                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n            else:\n                postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)\n                for k, v in chain.from_iterable(postprocessor_mappings):\n                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n        except TypeError:\n            pass\n    for f in postprocessors.get(clsname, []):\n        obj = f(obj)\n    if len(postprocessors) > 0 and obj not in Basic._constructor_postprocessor_mapping:\n        Basic._constructor_postprocessor_mapping[obj] = postprocessors\n    return obj",
    ".sympy.polys.domains.expressiondomain.py@@ExpressionDomain.Expression.__nonzero__": "def __nonzero__(f):\n    return f.ex != 0",
    ".sympy.core.numbers.py@@Integer.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    from sympy import Pow\n    if self is other:\n        return True\n    if type(self) is not type(other):\n        try:\n            other = _sympify(other)\n        except SympifyError:\n            return NotImplemented\n        if type(self) != type(other):\n            return False\n    return self._hashable_content() == other._hashable_content()",
    ".sympy.polys.domains.expressiondomain.py@@ExpressionDomain.to_sympy": "def to_sympy(self, a):\n    return a.as_expr()",
    ".sympy.polys.domains.expressiondomain.py@@ExpressionDomain.Expression.as_expr": "def as_expr(f):\n    return f.ex",
    ".sympy.core.mul.py@@_keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = (coeff, factors)\n        else:\n            return coeff * factors\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and (not sign):\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and (coeff.q != 1):\n            q = S(coeff.q)\n            for i in factors.args:\n                c, t = i.as_coeff_Mul()\n                r = c / q\n                if r == int(r):\n                    return coeff * factors\n        return Mul._from_args((coeff, factors))\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        return coeff * factors",
    ".sympy.core.expr.py@@Expr.as_ordered_factors": "def as_ordered_factors(self, order=None):\n    return [self]",
    ".sympy.printing.str.py@@StrPrinter._print_PolyRing": "def _print_PolyRing(self, ring):\n    return 'Polynomial ring in %s over %s with %s order' % (', '.join(map(self._print, ring.symbols)), ring.domain, ring.order)",
    ".sympy.polys.orderings.py@@MonomialOrder.__str__": "def __str__(self):\n    return self.alias",
    ".sympy.printing.str.py@@StrPrinter._print_FracField": "def _print_FracField(self, field):\n    return 'Rational function field in %s over %s with %s order' % (', '.join(map(self._print, field.symbols)), field.domain, field.order)",
    ".sympy.printing.str.py@@StrPrinter._print_PolyElement": "def _print_PolyElement(self, poly):\n    return poly.str(self, PRECEDENCE, '%s**%s', '*')",
    ".sympy.polys.rings.py@@PolyElement.str": "def str(self, printer, precedence, exp_pattern, mul_symbol):\n    if not self:\n        return printer._print(self.ring.domain.zero)\n    prec_add = precedence['Add']\n    prec_mul = precedence['Mul']\n    prec_atom = precedence['Atom']\n    ring = self.ring\n    symbols = ring.symbols\n    ngens = ring.ngens\n    zm = ring.zero_monom\n    sexpvs = []\n    for expv, coeff in self.terms():\n        positive = ring.domain.is_positive(coeff)\n        sign = ' + ' if positive else ' - '\n        sexpvs.append(sign)\n        if expv == zm:\n            scoeff = printer._print(coeff)\n            if scoeff.startswith('-'):\n                scoeff = scoeff[1:]\n        else:\n            if not positive:\n                coeff = -coeff\n            if coeff != 1:\n                scoeff = printer.parenthesize(coeff, prec_mul, strict=True)\n            else:\n                scoeff = ''\n        sexpv = []\n        for i in range(ngens):\n            exp = expv[i]\n            if not exp:\n                continue\n            symbol = printer.parenthesize(symbols[i], prec_atom, strict=True)\n            if exp != 1:\n                if exp != int(exp) or exp < 0:\n                    sexp = printer.parenthesize(exp, prec_atom, strict=False)\n                else:\n                    sexp = exp\n                sexpv.append(exp_pattern % (symbol, sexp))\n            else:\n                sexpv.append('%s' % symbol)\n        if scoeff:\n            sexpv = [scoeff] + sexpv\n        sexpvs.append(mul_symbol.join(sexpv))\n    if sexpvs[0] in [' + ', ' - ']:\n        head = sexpvs.pop(0)\n        if head == ' - ':\n            sexpvs.insert(0, '-')\n    return ''.join(sexpvs)",
    ".sympy.polys.domains.polynomialring.py@@PolynomialRing.zero": "def zero(self):\n    return self.ring.zero",
    ".sympy.polys.rings.py@@PolyRing.zero": "def zero(self):\n    return self.dtype()",
    ".sympy.printing.str.py@@StrPrinter._print_int": "def _print_int(self, expr):\n    return str(expr)",
    ".sympy.polys.rings.py@@PolyElement.terms": "def terms(self, order=None):\n    return self._sorted(list(self.items()), order)",
    ".sympy.polys.rings.py@@PolyElement._sorted": "def _sorted(self, seq, order):\n    if order is None:\n        order = self.ring.order\n    else:\n        order = OrderOpt.preprocess(order)\n    if order is lex:\n        return sorted(seq, key=lambda monom: monom[0], reverse=True)\n    else:\n        return sorted(seq, key=lambda monom: order(monom[0]), reverse=True)",
    ".sympy.polys.domains.polynomialring.py@@PolynomialRing.is_positive": "def is_positive(self, a):\n    return self.domain.is_positive(a.LC)",
    ".sympy.polys.rings.py@@PolyElement.LC": "def LC(self):\n    return self._get_coeff(self.leading_expv())",
    ".sympy.polys.rings.py@@PolyElement.leading_expv": "def leading_expv(self):\n    if self:\n        return self.ring.leading_expv(self)\n    else:\n        return None",
    ".sympy.polys.rings.py@@PolyElement._get_coeff": "def _get_coeff(self, expv):\n    return self.get(expv, self.ring.domain.zero)",
    ".sympy.polys.domains.domain.py@@Domain.is_positive": "def is_positive(self, a):\n    return a > 0",
    ".sympy.polys.rings.py@@PolyElement.__ne__": "def __ne__(p1, p2):\n    return not p1 == p2",
    ".sympy.polys.rings.py@@PolyElement.__eq__": "def __eq__(p1, p2):\n    if not p2:\n        return not p1\n    elif isinstance(p2, PolyElement) and p2.ring == p1.ring:\n        return dict.__eq__(p1, p2)\n    elif len(p1) > 1:\n        return False\n    else:\n        return p1.get(p1.ring.zero_monom) == p2",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__eq__": "def __eq__(self, other):\n    if isinstance(other, PythonRational):\n        return self.q == other.q and self.p == other.p\n    elif isinstance(other, integer_types):\n        return self.q == 1 and self.p == other\n    else:\n        return False",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__nonzero__": "def __nonzero__(self):\n    return self.p != 0",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__int__": "def __int__(self):\n    p, q = (self.p, self.q)\n    if p < 0:\n        return -(-p // q)\n    return p // q",
    ".sympy.printing.str.py@@StrPrinter._print_PythonRational": "def _print_PythonRational(self, expr):\n    if expr.q == 1:\n        return str(expr.p)\n    else:\n        return '%d/%d' % (expr.p, expr.q)",
    ".sympy.printing.precedence.py@@precedence_PolyElement": "def precedence_PolyElement(item):\n    if item.is_generator:\n        return PRECEDENCE['Atom']\n    elif item.is_ground:\n        return precedence(item.coeff(1))\n    elif item.is_term:\n        return PRECEDENCE['Mul']\n    else:\n        return PRECEDENCE['Add']",
    ".sympy.polys.rings.py@@PolyElement.is_generator": "def is_generator(self):\n    return self in self.ring._gens_set",
    ".sympy.polys.rings.py@@PolyElement.__hash__": "def __hash__(self):\n    _hash = self._hash\n    if _hash is None:\n        self._hash = _hash = hash((self.ring, frozenset(self.items())))\n    return _hash",
    ".sympy.polys.rings.py@@PolyRing.__hash__": "def __hash__(self):\n    return self._hash",
    ".sympy.polys.rings.py@@PolyElement.is_ground": "def is_ground(self):\n    return not self or (len(self) == 1 and self.ring.zero_monom in self)",
    ".sympy.polys.rings.py@@PolyElement.is_term": "def is_term(self):\n    return len(self) <= 1",
    ".sympy.polys.rings.py@@PolyElement.__neg__": "def __neg__(self):\n    return self.new([(monom, -coeff) for monom, coeff in self.iterterms()])",
    ".sympy.polys.rings.py@@PolyElement.iterterms": "def iterterms(self):\n    return iter(self.items())",
    ".sympy.polys.rings.py@@PolyElement.new": "def new(self, init):\n    return self.__class__(init)",
    ".sympy.printing.str.py@@StrPrinter._print_FracElement": "def _print_FracElement(self, frac):\n    if frac.denom == 1:\n        return self._print(frac.numer)\n    else:\n        numer = self.parenthesize(frac.numer, PRECEDENCE['Mul'], strict=True)\n        denom = self.parenthesize(frac.denom, PRECEDENCE['Atom'], strict=True)\n        return numer + '/' + denom",
    ".sympy.polys.fields.py@@FracElement.__eq__": "def __eq__(f, g):\n    if isinstance(g, FracElement) and f.field == g.field:\n        return f.numer == g.numer and f.denom == g.denom\n    else:\n        return f.numer == g and f.denom == f.field.ring.one",
    ".sympy.polys.rings.py@@PolyRing.one": "def one(self):\n    return self.dtype(self._one)",
    ".sympy.polys.rings.py@@PolyRing.__eq__": "def __eq__(self, other):\n    return isinstance(other, PolyRing) and (self.symbols, self.domain, self.ngens, self.order) == (other.symbols, other.domain, other.ngens, other.order)",
    ".sympy.polys.domains.fractionfield.py@@FractionField.zero": "def zero(self):\n    return self.field.zero",
    ".sympy.polys.domains.fractionfield.py@@FractionField.is_positive": "def is_positive(self, a):\n    return self.domain.is_positive(a.numer.LC)",
    ".sympy.polys.fields.py@@FracElement.__ne__": "def __ne__(f, g):\n    return not f == g",
    ".sympy.polys.fields.py@@FracElement.__hash__": "def __hash__(self):\n    _hash = self._hash\n    if _hash is None:\n        self._hash = _hash = hash((self.field, self.numer, self.denom))\n    return _hash",
    ".sympy.polys.fields.py@@FracField.__hash__": "def __hash__(self):\n    return self._hash",
    ".sympy.polys.fields.py@@FracField.__eq__": "def __eq__(self, other):\n    return isinstance(other, FracField) and (self.symbols, self.ngens, self.domain, self.order) == (other.symbols, other.ngens, other.domain, other.order)",
    ".sympy.polys.rings.py@@PolyElement.coeff": "def coeff(self, element):\n    if element == 1:\n        return self._get_coeff(self.ring.zero_monom)\n    elif isinstance(element, self.ring.dtype):\n        terms = list(element.iterterms())\n        if len(terms) == 1:\n            monom, coeff = terms[0]\n            if coeff == self.ring.domain.one:\n                return self._get_coeff(monom)\n    raise ValueError('expected a monomial, got %s' % element)",
    ".sympy.printing.precedence.py@@precedence_FracElement": "def precedence_FracElement(item):\n    if item.denom == 1:\n        return precedence_PolyElement(item.numer)\n    else:\n        return PRECEDENCE['Mul']",
    ".sympy.polys.fields.py@@FracElement.__neg__": "def __neg__(f):\n    return f.raw_new(-f.numer, f.denom)",
    ".sympy.polys.fields.py@@FracElement.raw_new": "def raw_new(f, numer, denom):\n    return f.__class__(numer, denom)",
    ".sympy.polys.fields.py@@FracElement.__init__": "def __init__(self, numer, denom=None):\n    if denom is None:\n        denom = self.field.ring.one\n    elif not denom:\n        raise ZeroDivisionError('zero denominator')\n    self.numer = numer\n    self.denom = denom",
    ".sympy.core.numbers.py@@Rational.__neg__": "def __neg__(self):\n    return Rational(-self.p, self.q)",
    ".sympy.core.numbers.py@@igcd": "def igcd(*args):\n    if len(args) < 2:\n        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))\n    if 1 in args:\n        a = 1\n        k = 0\n    else:\n        a = abs(as_int(args[0]))\n        k = 1\n    if a != 1:\n        while k < len(args):\n            b = args[k]\n            k += 1\n            try:\n                a = _gcdcache[a, b]\n            except KeyError:\n                b = as_int(b)\n                if not b:\n                    continue\n                if b == 1:\n                    a = 1\n                    break\n                if b < 0:\n                    b = -b\n                t = (a, b)\n                a = igcd2(a, b)\n                _gcdcache[t] = _gcdcache[t[1], t[0]] = a\n    while k < len(args):\n        ok = as_int(args[k])\n        k += 1\n    return a",
    ".sympy.printing.precedence.py@@precedence_Rational": "def precedence_Rational(item):\n    if item.p < 0:\n        return PRECEDENCE['Add']\n    return PRECEDENCE['Mul']",
    ".sympy.core.numbers.py@@Float.__neg__": "def __neg__(self):\n    return Float._new(mlib.mpf_neg(self._mpf_), self._prec)",
    ".sympy.core.numbers.py@@Float._new": "def _new(cls, _mpf_, _prec):\n    if _mpf_ == _mpf_zero:\n        return S.Zero\n    elif _mpf_ == _mpf_nan:\n        return S.NaN\n    obj = Expr.__new__(cls)\n    obj._mpf_ = mpf_norm(_mpf_, _prec)\n    obj._prec = _prec\n    return obj",
    ".sympy.core.numbers.py@@mpf_norm": "def mpf_norm(mpf, prec):\n    sign, man, expt, bc = mpf\n    if not man:\n        if not bc:\n            return _mpf_zero\n        else:\n            return mpf\n    from mpmath.libmp.backend import MPZ\n    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n    return rv",
    ".sympy.printing.str.py@@StrPrinter._print_Relational": "def _print_Relational(self, expr):\n    charmap = {'==': 'Eq', '!=': 'Ne', ':=': 'Assignment', '+=': 'AddAugmentedAssignment', '-=': 'SubAugmentedAssignment', '*=': 'MulAugmentedAssignment', '/=': 'DivAugmentedAssignment', '%=': 'ModAugmentedAssignment'}\n    if expr.rel_op in charmap:\n        return '%s(%s, %s)' % (charmap[expr.rel_op], expr.lhs, expr.rhs)\n    return '%s %s %s' % (self.parenthesize(expr.lhs, precedence(expr)), self._relationals.get(expr.rel_op) or expr.rel_op, self.parenthesize(expr.rhs, precedence(expr)))",
    ".sympy.core.relational.py@@Relational.lhs": "def lhs(self):\n    return self._args[0]",
    ".sympy.core.relational.py@@Relational.rhs": "def rhs(self):\n    return self._args[1]",
    ".sympy.printing.str.py@@StrPrinter._print_GroebnerBasis": "def _print_GroebnerBasis(self, basis):\n    cls = basis.__class__.__name__\n    exprs = [self._print_Add(arg, order=basis.order) for arg in basis.exprs]\n    exprs = '[%s]' % ', '.join(exprs)\n    gens = [self._print(gen) for gen in basis.gens]\n    domain = \"domain='%s'\" % self._print(basis.domain)\n    order = \"order='%s'\" % self._print(basis.order)\n    args = [exprs] + gens + [domain, order]\n    return '%s(%s)' % (cls, ', '.join(args))",
    ".sympy.polys.polytools.py@@GroebnerBasis.exprs": "def exprs(self):\n    return [poly.as_expr() for poly in self._basis]",
    ".sympy.polys.polytools.py@@GroebnerBasis.gens": "def gens(self):\n    return self._options.gens",
    ".sympy.polys.polyoptions.py@@OptionType.getter": "def getter(self):\n    try:\n        return self[cls.option]\n    except KeyError:\n        return cls.default()",
    ".sympy.polys.polytools.py@@GroebnerBasis.domain": "def domain(self):\n    return self._options.domain",
    ".sympy.printing.str.py@@StrPrinter.emptyPrinter": "def emptyPrinter(self, expr):\n    if isinstance(expr, str):\n        return expr\n    elif isinstance(expr, Basic):\n        if hasattr(expr, 'args'):\n            return repr(expr)\n        else:\n            raise\n    else:\n        return str(expr)",
    ".sympy.polys.polytools.py@@GroebnerBasis.order": "def order(self):\n    return self._options.order",
    ".sympy.polys.polyoptions.py@@Order.default": "def default(cls):\n    return sympy.polys.orderings.lex",
    ".sympy.printing.str.py@@StrPrinter._print_set": "def _print_set(self, s):\n    items = sorted(s, key=default_sort_key)\n    args = ', '.join((self._print(item) for item in items))\n    if not args:\n        return 'set()'\n    return '{%s}' % args",
    ".sympy.printing.str.py@@StrPrinter._print_frozenset": "def _print_frozenset(self, s):\n    if not s:\n        return 'frozenset()'\n    return 'frozenset(%s)' % self._print_set(s)",
    ".sympy.core.numbers.py@@Integer.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s > %s' % (self, other))\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    ".sympy.printing.str.py@@StrPrinter._print_Quaternion": "def _print_Quaternion(self, expr):\n    s = [self.parenthesize(i, PRECEDENCE['Mul'], strict=True) for i in expr.args]\n    a = [s[0]] + [i + '*' + j for i, j in zip(s[1:], 'ijk')]\n    return ' + '.join(a)",
    ".sympy.printing.str.py@@StrPrinter._print_Wild": "def _print_Wild(self, expr):\n    return expr.name + '_'",
    ".sympy.printing.str.py@@StrPrinter._print_str": "def _print_str(self, expr):\n    return expr",
    ".sympy.printing.str.py@@StrPrinter._print_FiniteSet": "def _print_FiniteSet(self, s):\n    s = sorted(s, key=default_sort_key)\n    if len(s) > 10:\n        printset = s[:3] + ['...'] + s[-3:]\n    else:\n        printset = s\n    return '{' + ', '.join((self._print(el) for el in printset)) + '}'",
    ".sympy.sets.sets.py@@FiniteSet.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.sets.sets.py@@FiniteSet.__len__": "def __len__(self):\n    return len(self.args)",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__hash__": "def __hash__(self):\n    if self.q == 1:\n        return hash(self.p)\n    else:\n        return hash((self.p, self.q))",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__gt__": "def __gt__(self, other):\n    return self._cmp(other, operator.gt)",
    ".sympy.polys.domains.pythonrational.py@@PythonRational._cmp": "def _cmp(self, other, op):\n    try:\n        diff = self - other\n    except TypeError:\n        return NotImplemented\n    else:\n        return op(diff.p, 0)",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__sub__": "def __sub__(self, other):\n    from sympy.polys.domains.groundtypes import python_gcd as gcd\n    if isinstance(other, PythonRational):\n        ap, aq, bp, bq = (self.p, self.q, other.p, other.q)\n        g = gcd(aq, bq)\n        if g == 1:\n            p = ap * bq - aq * bp\n            q = bq * aq\n        else:\n            q1, q2 = (aq // g, bq // g)\n            p, q = (ap * q2 - bp * q1, q1 * q2)\n            g2 = gcd(p, g)\n            p, q = (p // g2, q * (g // g2))\n    elif isinstance(other, integer_types):\n        p = self.p - self.q * other\n        q = self.q\n    else:\n        return NotImplemented\n    return self.__class__(p, q, _gcd=False)",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__init__": "def __init__(self, p, q=1, _gcd=True):\n    from sympy.polys.domains.groundtypes import python_gcd as gcd\n    if isinstance(p, Integer):\n        p = p.p\n    elif isinstance(p, Rational):\n        p, q = (p.p, p.q)\n    if not q:\n        raise ZeroDivisionError('rational number')\n    elif q < 0:\n        p, q = (-p, -q)\n    if not p:\n        self.p = 0\n        self.q = 1\n    elif p == 1 or q == 1:\n        self.p = p\n        self.q = q\n    else:\n        if _gcd:\n            x = gcd(p, q)\n            if x != 1:\n                p //= x\n                q //= x\n        self.p = p\n        self.q = q",
    ".sympy.printing.str.py@@StrPrinter._print_Object": "def _print_Object(self, object):\n    return 'Object(\"%s\")' % object.name",
    ".sympy.printing.str.py@@StrPrinter._print_Category": "def _print_Category(self, category):\n    return 'Category(\"%s\")' % category.name",
    ".sympy.categories.baseclasses.py@@Category.name": "def name(self):\n    return self.args[0].name",
    ".sympy.printing.str.py@@StrPrinter._print_Tr": "def _print_Tr(self, expr):\n    return '%s(%s)' % ('Tr', self._print(expr.args[0]))",
    ".sympy.printing.str.py@@StrPrinter._print_MatMul": "def _print_MatMul(self, expr):\n    return '*'.join([self.parenthesize(arg, precedence(expr)) for arg in expr.args])",
    ".sympy.printing.str.py@@StrPrinter._print_MatAdd": "def _print_MatAdd(self, expr):\n    return ' + '.join([self.parenthesize(arg, precedence(expr)) for arg in expr.args])",
    ".sympy.matrices.expressions.matexpr.py@@MatrixSymbol.name": "def name(self):\n    return self.args[0]",
    ".sympy.printing.str.py@@StrPrinter._print_MatrixSlice": "def _print_MatrixSlice(self, expr):\n\n    def strslice(x):\n        x = list(x)\n        if x[2] == 1:\n            del x[2]\n        if x[1] == x[0] + 1:\n            del x[1]\n        if x[0] == 0:\n            x[0] = ''\n        return ':'.join(map(self._print, x))\n    return self._print(expr.parent) + '[' + strslice(expr.rowslice) + ', ' + strslice(expr.colslice) + ']'",
    ".sympy.printing.str.py@@StrPrinter.strslice": "def strslice(x):\n    x = list(x)\n    if x[2] == 1:\n        del x[2]\n    if x[1] == x[0] + 1:\n        del x[1]\n    if x[0] == 0:\n        x[0] = ''\n    return ':'.join(map(self._print, x))",
    ".sympy.core.numbers.py@@Integer.__add__": "def __add__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    ".sympy.printing.str.py@@StrPrinter._print_BooleanTrue": "def _print_BooleanTrue(self, expr):\n    return 'True'",
    ".sympy.printing.str.py@@StrPrinter._print_BooleanFalse": "def _print_BooleanFalse(self, expr):\n    return 'False'",
    ".sympy.printing.str.py@@StrPrinter._print_Complement": "def _print_Complement(self, expr):\n    return ' \\\\ '.join((self._print(set) for set in expr.args))",
    ".sympy.printing.str.py@@StrPrinter._print_Reals": "def _print_Reals(self, expr):\n    return 'S.Reals'",
    ".sympy.printing.str.py@@StrPrinter._print_Naturals": "def _print_Naturals(self, expr):\n    return 'S.Naturals'"
}