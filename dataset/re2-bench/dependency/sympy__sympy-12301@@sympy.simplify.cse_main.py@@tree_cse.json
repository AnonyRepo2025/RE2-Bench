{
    ".sympy.core.compatibility.py@@iterable": "def iterable(i, exclude=(string_types, dict, NotIterable)):\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    from sympy import Pow\n    if self is other:\n        return True\n    from .function import AppliedUndef, UndefinedFunction as UndefFunc\n    if isinstance(self, UndefFunc) and isinstance(other, UndefFunc):\n        if self.class_key() == other.class_key():\n            return True\n        else:\n            return False\n    if type(self) is not type(other):\n        if isinstance(self, Pow) and self.exp == 1:\n            return self.base == other\n        if isinstance(other, Pow) and other.exp == 1:\n            return self == other.base\n        try:\n            other = _sympify(other)\n        except SympifyError:\n            return False\n        if isinstance(self, AppliedUndef) and isinstance(other, AppliedUndef):\n            if self.class_key() != other.class_key():\n                return False\n        elif type(self) is not type(other):\n            return False\n    return self._hashable_content() == other._hashable_content()",
    ".sympy.core.basic.py@@Basic._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.logic.boolalg.py@@BooleanTrue.__hash__": "def __hash__(self):\n    return hash(True)",
    ".sympy.core.function.py@@Subs.__hash__": "def __hash__(self):\n    return super(Subs, self).__hash__()",
    ".sympy.polys.rootoftools.py@@ComplexRootOf.args": "def args(self):\n    return (self.expr, Integer(self.index))",
    ".sympy.polys.rootoftools.py@@ComplexRootOf.expr": "def expr(self):\n    return self.poly.as_expr()",
    ".sympy.polys.polytools.py@@Poly.as_expr": "def as_expr(f, *gens):\n    if not gens:\n        gens = f.gens\n    elif len(gens) == 1 and isinstance(gens[0], dict):\n        mapping = gens[0]\n        gens = list(f.gens)\n        for gen, value in mapping.items():\n            try:\n                index = gens.index(gen)\n            except ValueError:\n                raise GeneratorsError(\"%s doesn't have %s as generator\" % (f, gen))\n            else:\n                gens[index] = value\n    return basic_from_dict(f.rep.to_sympy_dict(), *gens)",
    ".sympy.polys.polyclasses.py@@DMP.to_sympy_dict": "def to_sympy_dict(f, zero=False):\n    rep = dmp_to_dict(f.rep, f.lev, f.dom, zero=zero)\n    for k, v in rep.items():\n        rep[k] = f.dom.to_sympy(v)\n    return rep",
    ".sympy.polys.densebasic.py@@dmp_to_dict": "def dmp_to_dict(f, u, K=None, zero=False):\n    if not u:\n        return dup_to_dict(f, K, zero=zero)\n    if dmp_zero_p(f, u) and zero:\n        return {(0,) * (u + 1): K.zero}\n    n, v, result = (dmp_degree(f, u), u - 1, {})\n    if n == -oo:\n        n = -1\n    for k in range(0, n + 1):\n        h = dmp_to_dict(f[n - k], v)\n        for exp, coeff in h.items():\n            result[(k,) + exp] = coeff\n    return result",
    ".sympy.polys.densebasic.py@@dup_to_dict": "def dup_to_dict(f, K=None, zero=False):\n    if not f and zero:\n        return {(0,): K.zero}\n    n, result = (len(f) - 1, {})\n    for k in range(0, n + 1):\n        if f[n - k]:\n            result[k,] = f[n - k]\n    return result",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.to_sympy": "def to_sympy(self, a):\n    return SymPyInteger(a)",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, string_types):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Integer can only work with integer expressions.')\n    try:\n        return _intcache[ival]\n    except KeyError:\n        obj = Expr.__new__(cls)\n        obj.p = ival\n        _intcache[ival] = obj\n        return obj",
    ".sympy.polys.polyutils.py@@expr_from_dict": "def expr_from_dict(rep, *gens):\n    result = []\n    for monom, coeff in rep.items():\n        term = [coeff]\n        for g, m in zip(gens, monom):\n            if m:\n                term.append(Pow(g, m))\n        result.append(Mul(*term))\n    return Add(*result)",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, **options):\n    from sympy import Order\n    args = list(map(_sympify, args))\n    args = [a for a in args if a is not cls.identity]\n    if not options.pop('evaluate', global_evaluate[0]):\n        return cls._from_args(args)\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    if order_symbols is not None:\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    if evaluate is None:\n        if global_evaluate[0] is False:\n            evaluate = global_evaluate[0]\n        else:\n            evaluate = True\n    try:\n        if a in sympy_classes:\n            return a\n    except TypeError:\n        pass\n    try:\n        cls = a.__class__\n    except AttributeError:\n        cls = type(a)\n    if cls in sympy_classes:\n        return a\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    try:\n        return converter[cls](a)\n    except KeyError:\n        for superclass in getmro(cls):\n            try:\n                return converter[superclass](a)\n            except KeyError:\n                continue\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    try:\n        return a._sympy_()\n    except AttributeError:\n        pass\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                return sympify(coerce(a))\n            except (TypeError, ValueError, AttributeError, SympifyError):\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.power.py@@Pow.__new__": "def __new__(cls, b, e, evaluate=None):\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    from sympy.functions.elementary.exponential import exp_polar\n    b = _sympify(b)\n    e = _sympify(e)\n    if evaluate:\n        if e is S.Zero:\n            return S.One\n        elif e is S.One:\n            return b\n        elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and e.is_integer and _coeff_isneg(b):\n            if e.is_even:\n                b = -b\n            elif e.is_odd:\n                return -Pow(-b, e)\n        if S.NaN in (b, e):\n            return S.NaN\n        elif b is S.One:\n            if abs(e).is_infinite:\n                return S.NaN\n            return S.One\n        else:\n            if not e.is_Atom and b is not S.Exp1 and (b.func is not exp_polar):\n                from sympy import numer, denom, log, sign, im, factor_terms\n                c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n                den = denom(ex)\n                if den.func is log and den.args[0] == b:\n                    return S.Exp1 ** (c * numer(ex))\n                elif den.is_Add:\n                    s = sign(im(b))\n                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):\n                        return S.Exp1 ** (c * numer(ex))\n            obj = b._eval_power(e)\n            if obj is not None:\n                return obj\n    obj = Expr.__new__(cls, b, e)\n    obj.is_commutative = b.is_commutative and e.is_commutative\n    return obj",
    ".sympy.core.function.py@@_coeff_isneg": "def _coeff_isneg(a):\n    if a.is_Mul:\n        a = a.args[0]\n    return a.is_Number and a.is_negative",
    ".sympy.core.numbers.py@@NaN.__hash__": "def __hash__(self):\n    return super(NaN, self).__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super(Number, self).__hash__()",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, integer_types):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return False\n    if isinstance(other, NumberSymbol):\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if isinstance(other, Number):\n        if isinstance(other, Rational):\n            return self.p == other.p and self.q == other.q\n        if isinstance(other, Float):\n            return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)\n    return False",
    ".sympy.core.expr.py@@Expr._eval_power": "def _eval_power(self, other):\n    return None",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.mul.py@@Mul.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        assert not a is S.One\n        if not a.is_zero and a.is_Rational:\n            r, b = b.as_coeff_Mul()\n            if b.is_Add:\n                if r is not S.One:\n                    rv = ([cls(a * r, b, evaluate=False)], [], None)\n                elif b.is_commutative:\n                    if a is S.One:\n                        rv = ([b], [], None)\n                    else:\n                        r, b = b.as_coeff_Add()\n                        bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n                        _addsort(bargs)\n                        ar = a * r\n                        if ar:\n                            bargs.insert(0, ar)\n                        bargs = [Add._from_args(bargs)]\n                        rv = (bargs, [], None)\n        if rv:\n            return rv\n    c_part = []\n    nc_part = []\n    nc_seq = []\n    coeff = S.One\n    c_powers = []\n    num_exp = []\n    neg1e = S.Zero\n    pnum_rat = {}\n    order_symbols = None\n    for o in seq:\n        if o.is_Order:\n            o, order_symbols = o.as_expr_variables(order_symbols)\n        if o.is_Mul:\n            if o.is_commutative:\n                seq.extend(o.args)\n            else:\n                for q in o.args:\n                    if q.is_commutative:\n                        seq.append(q)\n                    else:\n                        nc_seq.append(q)\n                seq.append(NC_Marker)\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o is S.Zero):\n                return ([S.NaN], [], None)\n            elif coeff.is_Number:\n                coeff *= o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__mul__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if not coeff:\n                return ([S.NaN], [], None)\n            if coeff is S.ComplexInfinity:\n                return ([S.ComplexInfinity], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o is S.ImaginaryUnit:\n            neg1e += S.Half\n            continue\n        elif o.is_commutative:\n            b, e = o.as_base_exp()\n            if o.is_Pow:\n                if b.is_Number:\n                    if e.is_Rational:\n                        if e.is_Integer:\n                            coeff *= Pow(b, e)\n                            continue\n                        elif e.is_negative:\n                            seq.append(Pow(b, e))\n                            continue\n                        elif b.is_negative:\n                            neg1e += e\n                            b = -b\n                        if b is not S.One:\n                            pnum_rat.setdefault(b, []).append(e)\n                        continue\n                    elif b.is_positive or e.is_integer:\n                        num_exp.append((b, e))\n                        continue\n                elif b is S.ImaginaryUnit and e.is_Rational:\n                    neg1e += e / 2\n                    continue\n            c_powers.append((b, e))\n        else:\n            if o is not NC_Marker:\n                nc_seq.append(o)\n            while nc_seq:\n                o = nc_seq.pop(0)\n                if not nc_part:\n                    nc_part.append(o)\n                    continue\n                o1 = nc_part.pop()\n                b1, e1 = o1.as_base_exp()\n                b2, e2 = o.as_base_exp()\n                new_exp = e1 + e2\n                if b1 == b2 and (not new_exp.is_Add):\n                    o12 = b1 ** new_exp\n                    if o12.is_commutative:\n                        seq.append(o12)\n                        continue\n                    else:\n                        nc_seq.insert(0, o12)\n                else:\n                    nc_part.append(o1)\n                    nc_part.append(o)\n\n    def _gather(c_powers):\n        common_b = {}\n        for b, e in c_powers:\n            co = e.as_coeff_Mul()\n            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n        for b, d in common_b.items():\n            for di, li in d.items():\n                d[di] = Add(*li)\n        new_c_powers = []\n        for b, e in common_b.items():\n            new_c_powers.extend([(b, c * t) for t, c in e.items()])\n        return new_c_powers\n    c_powers = _gather(c_powers)\n    num_exp = _gather(num_exp)\n    for i in range(2):\n        new_c_powers = []\n        changed = False\n        for b, e in c_powers:\n            if e.is_zero:\n                continue\n            if e is S.One:\n                if b.is_Number:\n                    coeff *= b\n                    continue\n                p = b\n            if e is not S.One:\n                p = Pow(b, e)\n                if p.is_Pow and (not b.is_Pow):\n                    bi = b\n                    b, e = p.as_base_exp()\n                    if b != bi:\n                        changed = True\n            c_part.append(p)\n            new_c_powers.append((b, e))\n        if changed and len(set((b for b, e in new_c_powers))) != len(new_c_powers):\n            c_part = []\n            c_powers = _gather(new_c_powers)\n        else:\n            break\n    inv_exp_dict = {}\n    for b, e in num_exp:\n        inv_exp_dict.setdefault(e, []).append(b)\n    for e, b in inv_exp_dict.items():\n        inv_exp_dict[e] = cls(*b)\n    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n    comb_e = {}\n    for b, e in pnum_rat.items():\n        comb_e.setdefault(Add(*e), []).append(b)\n    del pnum_rat\n    num_rat = []\n    for e, b in comb_e.items():\n        b = cls(*b)\n        if e.q == 1:\n            coeff *= Pow(b, e)\n            continue\n        if e.p > e.q:\n            e_i, ep = divmod(e.p, e.q)\n            coeff *= Pow(b, e_i)\n            e = Rational(ep, e.q)\n        num_rat.append((b, e))\n    del comb_e\n    pnew = defaultdict(list)\n    i = 0\n    while i < len(num_rat):\n        bi, ei = num_rat[i]\n        grow = []\n        for j in range(i + 1, len(num_rat)):\n            bj, ej = num_rat[j]\n            g = bi.gcd(bj)\n            if g is not S.One:\n                e = ei + ej\n                if e.q == 1:\n                    coeff *= Pow(g, e)\n                else:\n                    if e.p > e.q:\n                        e_i, ep = divmod(e.p, e.q)\n                        coeff *= Pow(g, e_i)\n                        e = Rational(ep, e.q)\n                    grow.append((g, e))\n                num_rat[j] = (bj / g, ej)\n                bi = bi / g\n                if bi is S.One:\n                    break\n        if bi is not S.One:\n            obj = Pow(bi, ei)\n            if obj.is_Number:\n                coeff *= obj\n            else:\n                for obj in Mul.make_args(obj):\n                    if obj.is_Number:\n                        coeff *= obj\n                    else:\n                        assert obj.is_Pow\n                        bi, ei = obj.args\n                        pnew[ei].append(bi)\n        num_rat.extend(grow)\n        i += 1\n    for e, b in pnew.items():\n        pnew[e] = cls(*b)\n    if neg1e:\n        p, q = neg1e.as_numer_denom()\n        n, p = divmod(p, q)\n        if n % 2:\n            coeff = -coeff\n        if q == 2:\n            c_part.append(S.ImaginaryUnit)\n        elif p:\n            neg1e = Rational(p, q)\n            for e, b in pnew.items():\n                if e == neg1e and b.is_positive:\n                    pnew[e] = -b\n                    break\n            else:\n                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n    c_part.extend([Pow(b, e) for e, b in pnew.items()])\n    if coeff is S.Infinity or coeff is S.NegativeInfinity:\n\n        def _handle_for_oo(c_part, coeff_sign):\n            new_c_part = []\n            for t in c_part:\n                if t.is_positive:\n                    continue\n                if t.is_negative:\n                    coeff_sign *= -1\n                    continue\n                new_c_part.append(t)\n            return (new_c_part, coeff_sign)\n        c_part, coeff_sign = _handle_for_oo(c_part, 1)\n        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n        coeff *= coeff_sign\n    if coeff is S.ComplexInfinity:\n        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n    elif coeff is S.Zero:\n        if any((c.is_finite == False for c in c_part)):\n            return ([S.NaN], [], order_symbols)\n        return ([coeff], [], order_symbols)\n    _new = []\n    for i in c_part:\n        if i.is_Number:\n            coeff *= i\n        else:\n            _new.append(i)\n    c_part = _new\n    _mulsort(c_part)\n    if coeff is not S.One:\n        c_part.insert(0, coeff)\n    if not nc_part and len(c_part) == 2 and c_part[0].is_Number and c_part[1].is_Add:\n        coeff = c_part[0]\n        c_part = [Add(*[coeff * f for f in c_part[1].args])]\n    return (c_part, nc_part, order_symbols)",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (S.One, self)",
    ".sympy.core.numbers.py@@Integer.__mul__": "def __mul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p * other)\n        elif isinstance(other, Integer):\n            return Integer(self.p * other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    ".sympy.core.power.py@@Pow.as_base_exp": "def as_base_exp(self):\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and (b.q != 1):\n        return (Integer(b.q), -e)\n    return (b, e)",
    ".sympy.core.mul.py@@Mul._gather": "def _gather(c_powers):\n    common_b = {}\n    for b, e in c_powers:\n        co = e.as_coeff_Mul()\n        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n    for b, d in common_b.items():\n        for di, li in d.items():\n            d[di] = Add(*li)\n    new_c_powers = []\n    for b, e in common_b.items():\n        new_c_powers.extend([(b, c * t) for t, c in e.items()])\n    return new_c_powers",
    ".sympy.core.numbers.py@@Rational.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (self, S.One)",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self.__eq__(other)",
    ".sympy.core.numbers.py@@Zero.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.core.mul.py@@_mulsort": "def _mulsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.operations.py@@AssocOp._from_args": "def _from_args(cls, args, is_commutative=None):\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n    obj = super(AssocOp, cls).__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and((a.is_commutative for a in args))\n    obj.is_commutative = is_commutative\n    return obj",
    ".sympy.core.add.py@@Add.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        if a.is_Rational:\n            if b.is_Mul:\n                rv = ([a, b], [], None)\n        if rv:\n            if all((s.is_commutative for s in rv[0])):\n                return rv\n            return ([], rv[0], None)\n    terms = {}\n    coeff = S.Zero\n    order_factors = []\n    for o in seq:\n        if o.is_Order:\n            for o1 in order_factors:\n                if o1.contains(o):\n                    o = None\n                    break\n            if o is None:\n                continue\n            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False):\n                return ([S.NaN], [], None)\n            if coeff.is_Number:\n                coeff += o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__add__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if coeff.is_finite is False:\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o.is_Add:\n            seq.extend(o.args)\n            continue\n        elif o.is_Mul:\n            c, s = o.as_coeff_Mul()\n        elif o.is_Pow:\n            b, e = o.as_base_exp()\n            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):\n                seq.append(b ** e)\n                continue\n            c, s = (S.One, o)\n        else:\n            c = S.One\n            s = o\n        if s in terms:\n            terms[s] += c\n            if terms[s] is S.NaN:\n                return ([S.NaN], [], None)\n        else:\n            terms[s] = c\n    newseq = []\n    noncommutative = False\n    for s, c in terms.items():\n        if c is S.Zero:\n            continue\n        elif c is S.One:\n            newseq.append(s)\n        elif s.is_Mul:\n            cs = s._new_rawargs(*(c,) + s.args)\n            newseq.append(cs)\n        elif s.is_Add:\n            newseq.append(Mul(c, s, evaluate=False))\n        else:\n            newseq.append(Mul(c, s))\n        noncommutative = noncommutative or not s.is_commutative\n    if coeff is S.Infinity:\n        newseq = [f for f in newseq if not (f.is_nonnegative or (f.is_real and f.is_finite))]\n    elif coeff is S.NegativeInfinity:\n        newseq = [f for f in newseq if not (f.is_nonpositive or (f.is_real and f.is_finite))]\n    if coeff is S.ComplexInfinity:\n        newseq = [c for c in newseq if not (c.is_finite and c.is_real is not None)]\n    if order_factors:\n        newseq2 = []\n        for t in newseq:\n            for o in order_factors:\n                if o.contains(t):\n                    t = None\n                    break\n            if t is not None:\n                newseq2.append(t)\n        newseq = newseq2 + order_factors\n        for o in order_factors:\n            if o.contains(coeff):\n                coeff = S.Zero\n                break\n    _addsort(newseq)\n    if coeff is not S.Zero:\n        newseq.insert(0, coeff)\n    if noncommutative:\n        return ([], newseq, None)\n    else:\n        return (newseq, [], None)",
    ".sympy.core.numbers.py@@Integer.__add__": "def __add__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    ".sympy.core.mul.py@@Mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return (coeff, args[0])\n            else:\n                return (coeff, self._new_rawargs(*args))\n        elif coeff.is_negative:\n            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))\n    return (S.One, self)",
    ".sympy.core.add.py@@_addsort": "def _addsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.basic.py@@Basic.compare": "def compare(self, other):\n    if self is other:\n        return 0\n    n1 = self.__class__\n    n2 = other.__class__\n    c = (n1 > n2) - (n1 < n2)\n    if c:\n        return c\n    st = self._hashable_content()\n    ot = other._hashable_content()\n    c = (len(st) > len(ot)) - (len(st) < len(ot))\n    if c:\n        return c\n    for l, r in zip(st, ot):\n        l = Basic(*l) if isinstance(l, frozenset) else l\n        r = Basic(*r) if isinstance(r, frozenset) else r\n        if isinstance(l, Basic):\n            c = l.compare(r)\n        else:\n            c = (l > r) - (l < r)\n        if c:\n            return c\n    return 0",
    ".sympy.core.core.py@@BasicMeta.__gt__": "def __gt__(cls, other):\n    if cls.__cmp__(other) == 1:\n        return True\n    return False",
    ".sympy.core.core.py@@BasicMeta.__cmp__": "def __cmp__(cls, other):\n    if not isinstance(other, BasicMeta):\n        return -1\n    n1 = cls.__name__\n    n2 = other.__name__\n    if n1 == n2:\n        return 0\n    UNKNOWN = len(ordering_of_classes) + 1\n    try:\n        i1 = ordering_of_classes.index(n1)\n    except ValueError:\n        i1 = UNKNOWN\n    try:\n        i2 = ordering_of_classes.index(n2)\n    except ValueError:\n        i2 = UNKNOWN\n    if i1 == UNKNOWN and i2 == UNKNOWN:\n        return (n1 > n2) - (n1 < n2)\n    return (i1 > i2) - (i1 < i2)",
    ".sympy.core.core.py@@BasicMeta.__lt__": "def __lt__(cls, other):\n    if cls.__cmp__(other) == -1:\n        return True\n    return False",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.__iter__": "def __iter__(self):\n    yield self.expr\n    yield self.cond",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.expr": "def expr(self):\n    return self.args[0]"
}