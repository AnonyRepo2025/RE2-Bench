{
    ".django.db.models.base.py@@Model._get_pk_val": "def _get_pk_val(self, meta=None):\n    meta = meta or self._meta\n    return getattr(self, meta.pk.attname)",
    ".django.db.transaction.py@@atomic": "def atomic(using=None, savepoint=True):\n    if callable(using):\n        return Atomic(DEFAULT_DB_ALIAS, savepoint)(using)\n    else:\n        return Atomic(using, savepoint)",
    ".django.db.transaction.py@@Atomic.__init__": "def __init__(self, using, savepoint):\n    self.using = using\n    self.savepoint = savepoint",
    ".django.db.transaction.py@@Atomic.__enter__": "def __enter__(self):\n    connection = get_connection(self.using)\n    if not connection.in_atomic_block:\n        connection.commit_on_exit = True\n        connection.needs_rollback = False\n        if not connection.get_autocommit():\n            connection.in_atomic_block = True\n            connection.commit_on_exit = False\n    if connection.in_atomic_block:\n        if self.savepoint and (not connection.needs_rollback):\n            sid = connection.savepoint()\n            connection.savepoint_ids.append(sid)\n        else:\n            connection.savepoint_ids.append(None)\n    else:\n        connection.set_autocommit(False, force_begin_transaction_with_broken_autocommit=True)\n        connection.in_atomic_block = True",
    ".django.db.transaction.py@@get_connection": "def get_connection(using=None):\n    if using is None:\n        using = DEFAULT_DB_ALIAS\n    return connections[using]",
    ".django.db.utils.py@@ConnectionHandler.__getitem__": "def __getitem__(self, alias):\n    if hasattr(self._connections, alias):\n        return getattr(self._connections, alias)\n    self.ensure_defaults(alias)\n    self.prepare_test_settings(alias)\n    db = self.databases[alias]\n    backend = load_backend(db['ENGINE'])\n    conn = backend.DatabaseWrapper(db, alias)\n    setattr(self._connections, alias, conn)\n    return conn",
    ".django.dispatch.dispatcher.py@@Signal.send": "def send(self, sender, **named):\n    if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS:\n        return []\n    return [(receiver, receiver(signal=self, sender=sender, **named)) for receiver in self._live_receivers(sender)]",
    ".django.dispatch.dispatcher.py@@Signal._live_receivers": "def _live_receivers(self, sender):\n    receivers = None\n    if self.use_caching and (not self._dead_receivers):\n        receivers = self.sender_receivers_cache.get(sender)\n        if receivers is NO_RECEIVERS:\n            return []\n    if receivers is None:\n        with self.lock:\n            self._clear_dead_receivers()\n            senderkey = _make_id(sender)\n            receivers = []\n            for (receiverkey, r_senderkey), receiver in self.receivers:\n                if r_senderkey == NONE_ID or r_senderkey == senderkey:\n                    receivers.append(receiver)\n            if self.use_caching:\n                if not receivers:\n                    self.sender_receivers_cache[sender] = NO_RECEIVERS\n                else:\n                    self.sender_receivers_cache[sender] = receivers\n    non_weak_receivers = []\n    for receiver in receivers:\n        if isinstance(receiver, weakref.ReferenceType):\n            receiver = receiver()\n            if receiver is not None:\n                non_weak_receivers.append(receiver)\n        else:\n            non_weak_receivers.append(receiver)\n    return non_weak_receivers",
    ".django.dispatch.dispatcher.py@@Signal._clear_dead_receivers": "def _clear_dead_receivers(self):\n    if self._dead_receivers:\n        self._dead_receivers = False\n        self.receivers = [r for r in self.receivers if not (isinstance(r[1], weakref.ReferenceType) and r[1]() is None)]",
    ".django.dispatch.dispatcher.py@@_make_id": "def _make_id(target):\n    if hasattr(target, '__func__'):\n        return (id(target.__self__), id(target.__func__))\n    return id(target)",
    ".django.db.models.query.py@@QuerySet._raw_delete": "def _raw_delete(self, using):\n    query = self.query.clone()\n    query.__class__ = sql.DeleteQuery\n    cursor = query.get_compiler(using).execute_sql(CURSOR)\n    if cursor:\n        with cursor:\n            return cursor.rowcount\n    return 0",
    ".django.db.models.query.py@@QuerySet.query": "def query(self):\n    if self._deferred_filter:\n        negate, args, kwargs = self._deferred_filter\n        self._filter_or_exclude_inplace(negate, *args, **kwargs)\n        self._deferred_filter = None\n    return self._query",
    ".django.db.models.sql.query.py@@Query.clone": "def clone(self):\n    obj = Empty()\n    obj.__class__ = self.__class__\n    obj.__dict__ = self.__dict__.copy()\n    obj.alias_refcount = self.alias_refcount.copy()\n    obj.alias_map = self.alias_map.copy()\n    obj.external_aliases = self.external_aliases.copy()\n    obj.table_map = self.table_map.copy()\n    obj.where = self.where.clone()\n    obj.annotations = self.annotations.copy()\n    if self.annotation_select_mask is None:\n        obj.annotation_select_mask = None\n    else:\n        obj.annotation_select_mask = self.annotation_select_mask.copy()\n    obj._annotation_select_cache = None\n    obj.extra = self.extra.copy()\n    if self.extra_select_mask is None:\n        obj.extra_select_mask = None\n    else:\n        obj.extra_select_mask = self.extra_select_mask.copy()\n    if self._extra_select_cache is None:\n        obj._extra_select_cache = None\n    else:\n        obj._extra_select_cache = self._extra_select_cache.copy()\n    if self.select_related is not False:\n        obj.select_related = copy.deepcopy(obj.select_related)\n    if 'subq_aliases' in self.__dict__:\n        obj.subq_aliases = self.subq_aliases.copy()\n    obj.used_aliases = self.used_aliases.copy()\n    obj._filtered_relations = self._filtered_relations.copy()\n    try:\n        del obj.base_table\n    except AttributeError:\n        pass\n    return obj",
    ".django.db.models.sql.where.py@@WhereNode.clone": "def clone(self):\n    clone = self.__class__._new_instance(children=[], connector=self.connector, negated=self.negated)\n    for child in self.children:\n        if hasattr(child, 'clone'):\n            clone.children.append(child.clone())\n        else:\n            clone.children.append(child)\n    return clone",
    ".django.utils.tree.py@@Node._new_instance": "def _new_instance(cls, children=None, connector=None, negated=False):\n    obj = Node(children, connector, negated)\n    obj.__class__ = cls\n    return obj",
    ".django.utils.tree.py@@Node.__init__": "def __init__(self, children=None, connector=None, negated=False):\n    self.children = children[:] if children else []\n    self.connector = connector or self.default\n    self.negated = negated",
    ".django.db.models.sql.query.py@@Query.get_compiler": "def get_compiler(self, using=None, connection=None):\n    if using is None and connection is None:\n        raise ValueError('Need either using or connection')\n    if using:\n        connection = connections[using]\n    return connection.ops.compiler(self.compiler)(self, connection, using)",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.compiler": "def compiler(self, compiler_name):\n    if self._cache is None:\n        self._cache = import_module(self.compiler_module)\n    return getattr(self._cache, compiler_name)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.__init__": "def __init__(self, query, connection, using):\n    self.query = query\n    self.connection = connection\n    self.using = using\n    self.quote_cache = {'*': '*'}\n    self.select = None\n    self.annotation_col_map = None\n    self.klass_info = None\n    self.ordering_parts = re.compile('^(.*)\\\\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)\n    self._meta_ordering = None",
    ".django.db.models.sql.compiler.py@@SQLCompiler.execute_sql": "def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n    result_type = result_type or NO_RESULTS\n    try:\n        sql, params = self.as_sql()\n        if not sql:\n            raise EmptyResultSet\n    except EmptyResultSet:\n        if result_type == MULTI:\n            return iter([])\n        else:\n            return\n    if chunked_fetch:\n        cursor = self.connection.chunked_cursor()\n    else:\n        cursor = self.connection.cursor()\n    try:\n        cursor.execute(sql, params)\n    except Exception:\n        cursor.close()\n        raise\n    if result_type == CURSOR:\n        return cursor\n    if result_type == SINGLE:\n        try:\n            val = cursor.fetchone()\n            if val:\n                return val[0:self.col_count]\n            return val\n        finally:\n            cursor.close()\n    if result_type == NO_RESULTS:\n        cursor.close()\n        return\n    result = cursor_iter(cursor, self.connection.features.empty_fetchmany_value, self.col_count if self.has_extra_select else None, chunk_size)\n    if not chunked_fetch or not self.connection.features.can_use_chunked_reads:\n        try:\n            return list(result)\n        finally:\n            cursor.close()\n    return result",
    ".django.db.models.sql.compiler.py@@SQLDeleteCompiler.as_sql": "def as_sql(self):\n    if self.single_alias:\n        return self._as_sql(self.query)\n    innerq = self.query.clone()\n    innerq.__class__ = Query\n    innerq.clear_select_clause()\n    pk = self.query.model._meta.pk\n    innerq.select = [pk.get_col(self.query.get_initial_alias())]\n    outerq = Query(self.query.model)\n    outerq.where = self.query.where_class()\n    outerq.add_q(Q(pk__in=innerq))\n    return self._as_sql(outerq)",
    ".django.utils.functional.py@@cached_property.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    res = instance.__dict__[self.name] = self.func(instance)\n    return res",
    ".django.db.models.sql.compiler.py@@SQLDeleteCompiler.single_alias": "def single_alias(self):\n    return sum((self.query.alias_refcount[t] > 0 for t in self.query.alias_map)) == 1",
    ".django.db.models.sql.compiler.py@@SQLDeleteCompiler._as_sql": "def _as_sql(self, query):\n    result = ['DELETE FROM %s' % self.quote_name_unless_alias(query.base_table)]\n    where, params = self.compile(query.where)\n    if where:\n        result.append('WHERE %s' % where)\n    return (' '.join(result), tuple(params))",
    ".django.db.models.sql.query.py@@Query.base_table": "def base_table(self):\n    for alias in self.alias_map:\n        return alias",
    ".django.db.models.sql.compiler.py@@SQLCompiler.quote_name_unless_alias": "def quote_name_unless_alias(self, name):\n    if name in self.quote_cache:\n        return self.quote_cache[name]\n    if name in self.query.alias_map and name not in self.query.table_map or name in self.query.extra_select or (self.query.external_aliases.get(name) and name not in self.query.table_map):\n        self.quote_cache[name] = name\n        return name\n    r = self.connection.ops.quote_name(name)\n    self.quote_cache[name] = r\n    return r",
    ".django.db.models.sql.query.py@@Query.extra_select": "def extra_select(self):\n    if self._extra_select_cache is not None:\n        return self._extra_select_cache\n    if not self.extra:\n        return {}\n    elif self.extra_select_mask is not None:\n        self._extra_select_cache = {k: v for k, v in self.extra.items() if k in self.extra_select_mask}\n        return self._extra_select_cache\n    else:\n        return self.extra",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.quote_name": "def quote_name(self, name):\n    if name.startswith('\"') and name.endswith('\"'):\n        return name\n    return '\"%s\"' % name",
    ".django.db.models.sql.compiler.py@@SQLCompiler.compile": "def compile(self, node):\n    vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)\n    if vendor_impl:\n        sql, params = vendor_impl(self, self.connection)\n    else:\n        sql, params = node.as_sql(self, self.connection)\n    return (sql, params)",
    ".django.db.models.sql.where.py@@WhereNode.as_sql": "def as_sql(self, compiler, connection):\n    result = []\n    result_params = []\n    if self.connector == AND:\n        full_needed, empty_needed = (len(self.children), 1)\n    else:\n        full_needed, empty_needed = (1, len(self.children))\n    for child in self.children:\n        try:\n            sql, params = compiler.compile(child)\n        except EmptyResultSet:\n            empty_needed -= 1\n        else:\n            if sql:\n                result.append(sql)\n                result_params.extend(params)\n            else:\n                full_needed -= 1\n        if empty_needed == 0:\n            if self.negated:\n                return ('', [])\n            else:\n                raise EmptyResultSet\n        if full_needed == 0:\n            if self.negated:\n                raise EmptyResultSet\n            else:\n                return ('', [])\n    conn = ' %s ' % self.connector\n    sql_string = conn.join(result)\n    if sql_string:\n        if self.negated:\n            sql_string = 'NOT (%s)' % sql_string\n        elif len(result) > 1 or self.resolved:\n            sql_string = '(%s)' % sql_string\n    return (sql_string, result_params)",
    ".django.db.models.fields.related_lookups.py@@RelatedIn.as_sql": "def as_sql(self, compiler, connection):\n    if isinstance(self.lhs, MultiColSource):\n        from django.db.models.sql.where import WhereNode, SubqueryConstraint, AND, OR\n        root_constraint = WhereNode(connector=OR)\n        if self.rhs_is_direct_value():\n            values = [get_normalized_value(value, self.lhs) for value in self.rhs]\n            for value in values:\n                value_constraint = WhereNode()\n                for source, target, val in zip(self.lhs.sources, self.lhs.targets, value):\n                    lookup_class = target.get_lookup('exact')\n                    lookup = lookup_class(target.get_col(self.lhs.alias, source), val)\n                    value_constraint.add(lookup, AND)\n                root_constraint.add(value_constraint, OR)\n        else:\n            root_constraint.add(SubqueryConstraint(self.lhs.alias, [target.column for target in self.lhs.targets], [source.name for source in self.lhs.sources], self.rhs), AND)\n        return root_constraint.as_sql(compiler, connection)\n    else:\n        if not getattr(self.rhs, 'has_select_fields', True) and (not getattr(self.lhs.field.target_field, 'primary_key', False)):\n            self.rhs.clear_select_clause()\n            if getattr(self.lhs.output_field, 'primary_key', False) and self.lhs.output_field.model == self.rhs.model:\n                target_field = self.lhs.field.name\n            else:\n                target_field = self.lhs.field.target_field.name\n            self.rhs.add_fields([target_field], True)\n        return super().as_sql(compiler, connection)",
    ".django.db.models.lookups.py@@In.as_sql": "def as_sql(self, compiler, connection):\n    max_in_list_size = connection.ops.max_in_list_size()\n    if self.rhs_is_direct_value() and max_in_list_size and (len(self.rhs) > max_in_list_size):\n        return self.split_parameter_list_as_sql(compiler, connection)\n    return super().as_sql(compiler, connection)",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.max_in_list_size": "def max_in_list_size(self):\n    return None",
    ".django.db.models.lookups.py@@Lookup.rhs_is_direct_value": "def rhs_is_direct_value(self):\n    return not hasattr(self.rhs, 'as_sql')",
    ".django.db.models.lookups.py@@BuiltinLookup.as_sql": "def as_sql(self, compiler, connection):\n    lhs_sql, params = self.process_lhs(compiler, connection)\n    rhs_sql, rhs_params = self.process_rhs(compiler, connection)\n    params.extend(rhs_params)\n    rhs_sql = self.get_rhs_op(connection, rhs_sql)\n    return ('%s %s' % (lhs_sql, rhs_sql), params)",
    ".django.db.models.lookups.py@@BuiltinLookup.process_lhs": "def process_lhs(self, compiler, connection, lhs=None):\n    lhs_sql, params = super().process_lhs(compiler, connection, lhs)\n    field_internal_type = self.lhs.output_field.get_internal_type()\n    db_type = self.lhs.output_field.db_type(connection=connection)\n    lhs_sql = connection.ops.field_cast_sql(db_type, field_internal_type) % lhs_sql\n    lhs_sql = connection.ops.lookup_cast(self.lookup_name, field_internal_type) % lhs_sql\n    return (lhs_sql, list(params))",
    ".django.db.models.lookups.py@@Lookup.process_lhs": "def process_lhs(self, compiler, connection, lhs=None):\n    lhs = lhs or self.lhs\n    if hasattr(lhs, 'resolve_expression'):\n        lhs = lhs.resolve_expression(compiler.query)\n    return compiler.compile(lhs)",
    ".django.db.models.expressions.py@@BaseExpression.resolve_expression": "def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n    c = self.copy()\n    c.is_summary = summarize\n    c.set_source_expressions([expr.resolve_expression(query, allow_joins, reuse, summarize) if expr else None for expr in c.get_source_expressions()])\n    return c",
    ".django.db.models.expressions.py@@BaseExpression.copy": "def copy(self):\n    return copy.copy(self)",
    ".django.db.models.expressions.py@@BaseExpression.__getstate__": "def __getstate__(self):\n    state = self.__dict__.copy()\n    state.pop('convert_value', None)\n    return state",
    ".django.utils.deconstruct.py@@__new__": "def __new__(cls, *args, **kwargs):\n    obj = super(klass, cls).__new__(cls)\n    obj._constructor_args = (args, kwargs)\n    return obj",
    ".django.db.models.expressions.py@@BaseExpression.get_source_expressions": "def get_source_expressions(self):\n    return []",
    ".django.db.models.expressions.py@@BaseExpression.set_source_expressions": "def set_source_expressions(self, exprs):\n    assert not exprs",
    ".django.db.models.expressions.py@@Col.as_sql": "def as_sql(self, compiler, connection):\n    alias, column = (self.alias, self.target.column)\n    identifiers = (alias, column) if alias else (column,)\n    sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))\n    return (sql, [])",
    ".django.db.models.fields.__init__.py@@Field.get_internal_type": "def get_internal_type(self):\n    return self.__class__.__name__",
    ".django.db.models.fields.related.py@@ForeignKey.db_type": "def db_type(self, connection):\n    return self.target_field.rel_db_type(connection=connection)",
    ".django.db.models.fields.related.py@@ForeignKey.target_field": "def target_field(self):\n    return self.foreign_related_fields[0]",
    ".django.db.models.fields.__init__.py@@AutoField.rel_db_type": "def rel_db_type(self, connection):\n    return IntegerField().db_type(connection=connection)",
    ".django.db.models.fields.__init__.py@@Field.__init__": "def __init__(self, verbose_name=None, name=None, primary_key=False, max_length=None, unique=False, blank=False, null=False, db_index=False, rel=None, default=NOT_PROVIDED, editable=True, serialize=True, unique_for_date=None, unique_for_month=None, unique_for_year=None, choices=None, help_text='', db_column=None, db_tablespace=None, auto_created=False, validators=(), error_messages=None):\n    self.name = name\n    self.verbose_name = verbose_name\n    self._verbose_name = verbose_name\n    self.primary_key = primary_key\n    self.max_length, self._unique = (max_length, unique)\n    self.blank, self.null = (blank, null)\n    self.remote_field = rel\n    self.is_relation = self.remote_field is not None\n    self.default = default\n    self.editable = editable\n    self.serialize = serialize\n    self.unique_for_date = unique_for_date\n    self.unique_for_month = unique_for_month\n    self.unique_for_year = unique_for_year\n    if isinstance(choices, collections.abc.Iterator):\n        choices = list(choices)\n    self.choices = choices\n    self.help_text = help_text\n    self.db_index = db_index\n    self.db_column = db_column\n    self._db_tablespace = db_tablespace\n    self.auto_created = auto_created\n    if auto_created:\n        self.creation_counter = Field.auto_creation_counter\n        Field.auto_creation_counter -= 1\n    else:\n        self.creation_counter = Field.creation_counter\n        Field.creation_counter += 1\n    self._validators = list(validators)\n    messages = {}\n    for c in reversed(self.__class__.__mro__):\n        messages.update(getattr(c, 'default_error_messages', {}))\n    messages.update(error_messages or {})\n    self._error_messages = error_messages\n    self.error_messages = messages",
    ".django.db.models.fields.__init__.py@@Field.db_type": "def db_type(self, connection):\n    data = self.db_type_parameters(connection)\n    try:\n        return connection.data_types[self.get_internal_type()] % data\n    except KeyError:\n        return None",
    ".django.db.models.fields.__init__.py@@Field.db_type_parameters": "def db_type_parameters(self, connection):\n    return DictWrapper(self.__dict__, connection.ops.quote_name, 'qn_')",
    ".django.utils.datastructures.py@@DictWrapper.__init__": "def __init__(self, data, func, prefix):\n    super().__init__(data)\n    self.func = func\n    self.prefix = prefix",
    ".django.db.models.fields.__init__.py@@IntegerField.get_internal_type": "def get_internal_type(self):\n    return 'IntegerField'",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.field_cast_sql": "def field_cast_sql(self, db_type, internal_type):\n    return '%s'",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.lookup_cast": "def lookup_cast(self, lookup_type, internal_type=None):\n    return '%s'",
    ".django.db.models.lookups.py@@In.process_rhs": "def process_rhs(self, compiler, connection):\n    db_rhs = getattr(self.rhs, '_db', None)\n    if db_rhs is not None and db_rhs != connection.alias:\n        raise ValueError(\"Subqueries aren't allowed across different databases. Force the inner query to be evaluated using `list(inner_query)`.\")\n    if self.rhs_is_direct_value():\n        try:\n            rhs = OrderedSet(self.rhs)\n        except TypeError:\n            rhs = self.rhs\n        if not rhs:\n            raise EmptyResultSet\n        sqls, sqls_params = self.batch_process_rhs(compiler, connection, rhs)\n        placeholder = '(' + ', '.join(sqls) + ')'\n        return (placeholder, sqls_params)\n    else:\n        if not getattr(self.rhs, 'has_select_fields', True):\n            self.rhs.clear_select_clause()\n            self.rhs.add_fields(['pk'])\n        return super().process_rhs(compiler, connection)",
    ".django.utils.datastructures.py@@OrderedSet.__init__": "def __init__(self, iterable=None):\n    self.dict = dict.fromkeys(iterable or ())",
    ".django.utils.datastructures.py@@OrderedSet.__bool__": "def __bool__(self):\n    return bool(self.dict)",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueIterableMixin.batch_process_rhs": "def batch_process_rhs(self, compiler, connection, rhs=None):\n    pre_processed = super().batch_process_rhs(compiler, connection, rhs)\n    sql, params = zip(*(self.resolve_expression_parameter(compiler, connection, sql, param) for sql, param in zip(*pre_processed)))\n    params = itertools.chain.from_iterable(params)\n    return (sql, tuple(params))",
    ".django.db.models.lookups.py@@Lookup.batch_process_rhs": "def batch_process_rhs(self, compiler, connection, rhs=None):\n    if rhs is None:\n        rhs = self.rhs\n    if self.bilateral_transforms:\n        sqls, sqls_params = ([], [])\n        for p in rhs:\n            value = Value(p, output_field=self.lhs.output_field)\n            value = self.apply_bilateral_transforms(value)\n            value = value.resolve_expression(compiler.query)\n            sql, sql_params = compiler.compile(value)\n            sqls.append(sql)\n            sqls_params.extend(sql_params)\n    else:\n        _, params = self.get_db_prep_lookup(rhs, connection)\n        sqls, sqls_params = (['%s'] * len(params), params)\n    return (sqls, sqls_params)",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueMixin.get_db_prep_lookup": "def get_db_prep_lookup(self, value, connection):\n    field = getattr(self.lhs.output_field, 'target_field', None)\n    get_db_prep_value = getattr(field, 'get_db_prep_value', None) or self.lhs.output_field.get_db_prep_value\n    return ('%s', [get_db_prep_value(v, connection, prepared=True) for v in value] if self.get_db_prep_lookup_value_is_iterable else [get_db_prep_value(value, connection, prepared=True)])",
    ".django.utils.datastructures.py@@OrderedSet.__iter__": "def __iter__(self):\n    return iter(self.dict)",
    ".django.db.models.fields.__init__.py@@AutoFieldMixin.get_db_prep_value": "def get_db_prep_value(self, value, connection, prepared=False):\n    if not prepared:\n        value = self.get_prep_value(value)\n        value = connection.ops.validate_autopk_value(value)\n    return value",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueIterableMixin.resolve_expression_parameter": "def resolve_expression_parameter(self, compiler, connection, sql, param):\n    params = [param]\n    if hasattr(param, 'resolve_expression'):\n        param = param.resolve_expression(compiler.query)\n    if hasattr(param, 'as_sql'):\n        sql, params = param.as_sql(compiler, connection)\n    return (sql, params)",
    ".django.db.models.lookups.py@@In.get_rhs_op": "def get_rhs_op(self, connection, rhs):\n    return 'IN %s' % rhs",
    ".django.utils.asyncio.py@@inner": "def inner(*args, **kwargs):\n    if not os.environ.get('DJANGO_ALLOW_ASYNC_UNSAFE'):\n        try:\n            event_loop = asyncio.get_event_loop()\n        except RuntimeError:\n            pass\n        else:\n            if event_loop.is_running():\n                raise SynchronousOnlyOperation(message)\n    return func(*args, **kwargs)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.cursor": "def cursor(self):\n    return self._cursor()",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper._cursor": "def _cursor(self, name=None):\n    self.ensure_connection()\n    with self.wrap_database_errors:\n        return self._prepare_cursor(self.create_cursor(name))",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.ensure_connection": "def ensure_connection(self):\n    if self.connection is None:\n        with self.wrap_database_errors:\n            self.connect()",
    ".django.db.utils.py@@DatabaseErrorWrapper.__enter__": "def __enter__(self):\n    pass",
    ".django.db.backends.sqlite3.base.py@@DatabaseWrapper.create_cursor": "def create_cursor(self, name=None):\n    return self.connection.cursor(factory=SQLiteCursorWrapper)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper._prepare_cursor": "def _prepare_cursor(self, cursor):\n    self.validate_thread_sharing()\n    if self.queries_logged:\n        wrapped_cursor = self.make_debug_cursor(cursor)\n    else:\n        wrapped_cursor = self.make_cursor(cursor)\n    return wrapped_cursor",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.validate_thread_sharing": "def validate_thread_sharing(self):\n    if not (self.allow_thread_sharing or self._thread_ident == _thread.get_ident()):\n        raise DatabaseError(\"DatabaseWrapper objects created in a thread can only be used in that same thread. The object with alias '%s' was created in thread id %s and this is thread id %s.\" % (self.alias, self._thread_ident, _thread.get_ident()))",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.allow_thread_sharing": "def allow_thread_sharing(self):\n    with self._thread_sharing_lock:\n        return self._thread_sharing_count > 0",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.queries_logged": "def queries_logged(self):\n    return self.force_debug_cursor or settings.DEBUG",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.make_debug_cursor": "def make_debug_cursor(self, cursor):\n    return utils.CursorDebugWrapper(cursor, self)",
    ".django.db.backends.utils.py@@CursorWrapper.__init__": "def __init__(self, cursor, db):\n    self.cursor = cursor\n    self.db = db",
    ".django.db.utils.py@@DatabaseErrorWrapper.__exit__": "def __exit__(self, exc_type, exc_value, traceback):\n    if exc_type is None:\n        return\n    for dj_exc_type in (DataError, OperationalError, IntegrityError, InternalError, ProgrammingError, NotSupportedError, DatabaseError, InterfaceError, Error):\n        db_exc_type = getattr(self.wrapper.Database, dj_exc_type.__name__)\n        if issubclass(exc_type, db_exc_type):\n            dj_exc_value = dj_exc_type(*exc_value.args)\n            if dj_exc_type not in (DataError, IntegrityError):\n                self.wrapper.errors_occurred = True\n            raise dj_exc_value.with_traceback(traceback) from exc_value",
    ".django.db.backends.utils.py@@CursorDebugWrapper.execute": "def execute(self, sql, params=None):\n    with self.debug_sql(sql, params, use_last_executed_query=True):\n        return super().execute(sql, params)",
    ".django.db.backends.utils.py@@CursorDebugWrapper.debug_sql": "def debug_sql(self, sql=None, params=None, use_last_executed_query=False, many=False):\n    start = time.monotonic()\n    try:\n        yield\n    finally:\n        stop = time.monotonic()\n        duration = stop - start\n        if use_last_executed_query:\n            sql = self.db.ops.last_executed_query(self.cursor, sql, params)\n        try:\n            times = len(params) if many else ''\n        except TypeError:\n            times = '?'\n        self.db.queries_log.append({'sql': '%s times: %s' % (times, sql) if many else sql, 'time': '%.3f' % duration})\n        logger.debug('(%.3f) %s; args=%s', duration, sql, params, extra={'duration': duration, 'sql': sql, 'params': params})",
    ".django.db.backends.utils.py@@CursorWrapper.execute": "def execute(self, sql, params=None):\n    return self._execute_with_wrappers(sql, params, many=False, executor=self._execute)",
    ".django.db.backends.utils.py@@CursorWrapper._execute_with_wrappers": "def _execute_with_wrappers(self, sql, params, many, executor):\n    context = {'connection': self.db, 'cursor': self}\n    for wrapper in reversed(self.db.execute_wrappers):\n        executor = functools.partial(wrapper, executor)\n    return executor(sql, params, many, context)",
    ".django.db.backends.utils.py@@CursorWrapper._execute": "def _execute(self, sql, params, *ignored_wrapper_args):\n    self.db.validate_no_broken_transaction()\n    with self.db.wrap_database_errors:\n        if params is None:\n            return self.cursor.execute(sql)\n        else:\n            return self.cursor.execute(sql, params)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.validate_no_broken_transaction": "def validate_no_broken_transaction(self):\n    if self.needs_rollback:\n        raise TransactionManagementError(\"An error occurred in the current transaction. You can't execute queries until the end of the 'atomic' block.\")",
    ".django.db.backends.sqlite3.base.py@@SQLiteCursorWrapper.execute": "def execute(self, query, params=None):\n    if params is None:\n        return Database.Cursor.execute(self, query)\n    query = self.convert_query(query)\n    return Database.Cursor.execute(self, query, params)",
    ".django.db.backends.sqlite3.base.py@@SQLiteCursorWrapper.convert_query": "def convert_query(self, query):\n    return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')",
    ".django.utils.functional.py@@inner": "def inner(self, *args):\n    if self._wrapped is empty:\n        self._setup()\n    return func(self._wrapped, *args)",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.last_executed_query": "def last_executed_query(self, cursor, sql, params):\n    if params:\n        if isinstance(params, (list, tuple)):\n            params = self._quote_params_for_last_executed_query(params)\n        else:\n            values = tuple(params.values())\n            values = self._quote_params_for_last_executed_query(values)\n            params = dict(zip(params, values))\n        return sql % params\n    else:\n        return sql",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations._quote_params_for_last_executed_query": "def _quote_params_for_last_executed_query(self, params):\n    BATCH_SIZE = 999\n    if len(params) > BATCH_SIZE:\n        results = ()\n        for index in range(0, len(params), BATCH_SIZE):\n            chunk = params[index:index + BATCH_SIZE]\n            results += self._quote_params_for_last_executed_query(chunk)\n        return results\n    sql = 'SELECT ' + ', '.join(['QUOTE(?)'] * len(params))\n    cursor = self.connection.connection.cursor()\n    try:\n        return cursor.execute(sql, params).fetchone()\n    finally:\n        cursor.close()",
    ".django.db.backends.utils.py@@CursorWrapper.__enter__": "def __enter__(self):\n    return self",
    ".django.db.backends.utils.py@@CursorWrapper.__getattr__": "def __getattr__(self, attr):\n    cursor_attr = getattr(self.cursor, attr)\n    if attr in CursorWrapper.WRAP_ERROR_ATTRS:\n        return self.db.wrap_database_errors(cursor_attr)\n    else:\n        return cursor_attr",
    ".django.db.backends.utils.py@@CursorWrapper.__exit__": "def __exit__(self, type, value, traceback):\n    try:\n        self.close()\n    except self.db.Database.Error:\n        pass",
    ".django.db.models.sql.query.py@@Query.__init__": "def __init__(self, model, where=WhereNode, alias_cols=True):\n    self.model = model\n    self.alias_refcount = {}\n    self.alias_map = {}\n    self.alias_cols = alias_cols\n    self.external_aliases = {}\n    self.table_map = {}\n    self.default_cols = True\n    self.default_ordering = True\n    self.standard_ordering = True\n    self.used_aliases = set()\n    self.filter_is_sticky = False\n    self.subquery = False\n    self.select = ()\n    self.where = where()\n    self.where_class = where\n    self.group_by = None\n    self.order_by = ()\n    self.low_mark, self.high_mark = (0, None)\n    self.distinct = False\n    self.distinct_fields = ()\n    self.select_for_update = False\n    self.select_for_update_nowait = False\n    self.select_for_update_skip_locked = False\n    self.select_for_update_of = ()\n    self.select_related = False\n    self.max_depth = 5\n    self.values_select = ()\n    self.annotations = {}\n    self.annotation_select_mask = None\n    self._annotation_select_cache = None\n    self.combinator = None\n    self.combinator_all = False\n    self.combined_queries = ()\n    self.extra = {}\n    self.extra_select_mask = None\n    self._extra_select_cache = None\n    self.extra_tables = ()\n    self.extra_order_by = ()\n    self.deferred_loading = (frozenset(), True)\n    self._filtered_relations = {}\n    self.explain_query = False\n    self.explain_format = None\n    self.explain_options = {}",
    ".django.db.models.sql.subqueries.py@@DeleteQuery.delete_batch": "def delete_batch(self, pk_list, using):\n    num_deleted = 0\n    field = self.get_meta().pk\n    for offset in range(0, len(pk_list), GET_ITERATOR_CHUNK_SIZE):\n        self.where = self.where_class()\n        self.add_q(Q(**{field.attname + '__in': pk_list[offset:offset + GET_ITERATOR_CHUNK_SIZE]}))\n        num_deleted += self.do_query(self.get_meta().db_table, self.where, using=using)\n    return num_deleted",
    ".django.db.models.sql.query.py@@Query.get_meta": "def get_meta(self):\n    return self.model._meta",
    ".django.db.models.query_utils.py@@Q.__init__": "def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n    super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)",
    ".django.db.models.sql.query.py@@Query.add_q": "def add_q(self, q_object):\n    existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}\n    clause, _ = self._add_q(q_object, self.used_aliases)\n    if clause:\n        self.where.add(clause, AND)\n    self.demote_joins(existing_inner)",
    ".django.db.models.sql.query.py@@Query._add_q": "def _add_q(self, q_object, used_aliases, branch_negated=False, current_negated=False, allow_joins=True, split_subq=True, check_filterable=True):\n    connector = q_object.connector\n    current_negated = current_negated ^ q_object.negated\n    branch_negated = branch_negated or q_object.negated\n    target_clause = self.where_class(connector=connector, negated=q_object.negated)\n    joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)\n    for child in q_object.children:\n        child_clause, needed_inner = self.build_filter(child, can_reuse=used_aliases, branch_negated=branch_negated, current_negated=current_negated, allow_joins=allow_joins, split_subq=split_subq, check_filterable=check_filterable)\n        joinpromoter.add_votes(needed_inner)\n        if child_clause:\n            target_clause.add(child_clause, connector)\n    needed_inner = joinpromoter.update_join_types(self)\n    return (target_clause, needed_inner)",
    ".django.db.models.sql.query.py@@JoinPromoter.__init__": "def __init__(self, connector, num_children, negated):\n    self.connector = connector\n    self.negated = negated\n    if self.negated:\n        if connector == AND:\n            self.effective_connector = OR\n        else:\n            self.effective_connector = AND\n    else:\n        self.effective_connector = self.connector\n    self.num_children = num_children\n    self.votes = Counter()",
    ".django.db.models.sql.query.py@@Query.build_filter": "def build_filter(self, filter_expr, branch_negated=False, current_negated=False, can_reuse=None, allow_joins=True, split_subq=True, reuse_with_filtered_relation=False, check_filterable=True):\n    if isinstance(filter_expr, dict):\n        raise FieldError('Cannot parse keyword query as dict')\n    if isinstance(filter_expr, Q):\n        return self._add_q(filter_expr, branch_negated=branch_negated, current_negated=current_negated, used_aliases=can_reuse, allow_joins=allow_joins, split_subq=split_subq, check_filterable=check_filterable)\n    if hasattr(filter_expr, 'resolve_expression'):\n        if not getattr(filter_expr, 'conditional', False):\n            raise TypeError('Cannot filter against a non-conditional expression.')\n        condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True)\n        clause = self.where_class()\n        clause.add(condition, AND)\n        return (clause, [])\n    arg, value = filter_expr\n    if not arg:\n        raise FieldError('Cannot parse keyword query %r' % arg)\n    lookups, parts, reffed_expression = self.solve_lookup_type(arg)\n    if check_filterable:\n        self.check_filterable(reffed_expression)\n    if not allow_joins and len(parts) > 1:\n        raise FieldError('Joined field references are not permitted in this query')\n    pre_joins = self.alias_refcount.copy()\n    value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n    used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n    if check_filterable:\n        self.check_filterable(value)\n    clause = self.where_class()\n    if reffed_expression:\n        condition = self.build_lookup(lookups, reffed_expression, value)\n        clause.add(condition, AND)\n        return (clause, [])\n    opts = self.get_meta()\n    alias = self.get_initial_alias()\n    allow_many = not branch_negated or not split_subq\n    try:\n        join_info = self.setup_joins(parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many, reuse_with_filtered_relation=reuse_with_filtered_relation)\n        if isinstance(value, Iterator):\n            value = list(value)\n        self.check_related_objects(join_info.final_field, value, join_info.opts)\n        self._lookup_joins = join_info.joins\n    except MultiJoin as e:\n        return self.split_exclude(filter_expr, can_reuse, e.names_with_path)\n    used_joins.update(join_info.joins)\n    targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)\n    if can_reuse is not None:\n        can_reuse.update(join_list)\n    if join_info.final_field.is_relation:\n        num_lookups = len(lookups)\n        if num_lookups > 1:\n            raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))\n        if len(targets) == 1:\n            col = self._get_col(targets[0], join_info.final_field, alias)\n        else:\n            col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)\n    else:\n        col = self._get_col(targets[0], join_info.final_field, alias)\n    condition = self.build_lookup(lookups, col, value)\n    lookup_type = condition.lookup_name\n    clause.add(condition, AND)\n    require_outer = lookup_type == 'isnull' and condition.rhs is True and (not current_negated)\n    if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and (condition.rhs is not None):\n        require_outer = True\n        if lookup_type != 'isnull' and (self.is_nullable(targets[0]) or self.alias_map[join_list[-1]].join_type == LOUTER):\n            lookup_class = targets[0].get_lookup('isnull')\n            col = self._get_col(targets[0], join_info.targets[0], alias)\n            clause.add(lookup_class(col, False), AND)\n    return (clause, used_joins if not require_outer else ())",
    ".django.db.models.sql.query.py@@Query.solve_lookup_type": "def solve_lookup_type(self, lookup):\n    lookup_splitted = lookup.split(LOOKUP_SEP)\n    if self.annotations:\n        expression, expression_lookups = refs_expression(lookup_splitted, self.annotations)\n        if expression:\n            return (expression_lookups, (), expression)\n    _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())\n    field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]\n    if len(lookup_parts) > 1 and (not field_parts):\n        raise FieldError('Invalid lookup \"%s\" for model %s\".' % (lookup, self.get_meta().model.__name__))\n    return (lookup_parts, field_parts, False)",
    ".django.db.models.sql.query.py@@Query.names_to_path": "def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n    path, names_with_path = ([], [])\n    for pos, name in enumerate(names):\n        cur_names_with_path = (name, [])\n        if name == 'pk':\n            name = opts.pk.name\n        field = None\n        filtered_relation = None\n        try:\n            field = opts.get_field(name)\n        except FieldDoesNotExist:\n            if name in self.annotation_select:\n                field = self.annotation_select[name].output_field\n            elif name in self._filtered_relations and pos == 0:\n                filtered_relation = self._filtered_relations[name]\n                field = opts.get_field(filtered_relation.relation_name)\n        if field is not None:\n            if field.is_relation and (not field.related_model):\n                raise FieldError('Field %r does not generate an automatic reverse relation and therefore cannot be used for reverse querying. If it is a GenericForeignKey, consider adding a GenericRelation.' % name)\n            try:\n                model = field.model._meta.concrete_model\n            except AttributeError:\n                model = None\n        else:\n            pos -= 1\n            if pos == -1 or fail_on_missing:\n                available = sorted([*get_field_names_from_opts(opts), *self.annotation_select, *self._filtered_relations])\n                raise FieldError(\"Cannot resolve keyword '%s' into field. Choices are: %s\" % (name, ', '.join(available)))\n            break\n        if model is not opts.model:\n            path_to_parent = opts.get_path_to_parent(model)\n            if path_to_parent:\n                path.extend(path_to_parent)\n                cur_names_with_path[1].extend(path_to_parent)\n                opts = path_to_parent[-1].to_opts\n        if hasattr(field, 'get_path_info'):\n            pathinfos = field.get_path_info(filtered_relation)\n            if not allow_many:\n                for inner_pos, p in enumerate(pathinfos):\n                    if p.m2m:\n                        cur_names_with_path[1].extend(pathinfos[0:inner_pos + 1])\n                        names_with_path.append(cur_names_with_path)\n                        raise MultiJoin(pos + 1, names_with_path)\n            last = pathinfos[-1]\n            path.extend(pathinfos)\n            final_field = last.join_field\n            opts = last.to_opts\n            targets = last.target_fields\n            cur_names_with_path[1].extend(pathinfos)\n            names_with_path.append(cur_names_with_path)\n        else:\n            final_field = field\n            targets = (field,)\n            if fail_on_missing and pos + 1 != len(names):\n                raise FieldError(\"Cannot resolve keyword %r into field. Join on '%s' not permitted.\" % (names[pos + 1], name))\n            break\n    return (path, final_field, targets, names[pos + 1:])",
    ".django.db.models.options.py@@Options.get_field": "def get_field(self, field_name):\n    try:\n        return self._forward_fields_map[field_name]\n    except KeyError:\n        if not self.apps.models_ready:\n            raise FieldDoesNotExist(\"%s has no field named '%s'. The app cache isn't ready yet, so if this is an auto-created related field, it won't be available yet.\" % (self.object_name, field_name))\n    try:\n        return self.fields_map[field_name]\n    except KeyError:\n        raise FieldDoesNotExist(\"%s has no field named '%s'\" % (self.object_name, field_name))",
    ".django.db.models.sql.query.py@@Query.check_filterable": "def check_filterable(self, expression):\n    if not getattr(expression, 'filterable', True):\n        raise NotSupportedError(expression.__class__.__name__ + ' is disallowed in the filter clause.')\n    if hasattr(expression, 'get_source_expressions'):\n        for expr in expression.get_source_expressions():\n            self.check_filterable(expr)",
    ".django.db.models.sql.query.py@@Query.resolve_lookup_value": "def resolve_lookup_value(self, value, can_reuse, allow_joins):\n    if hasattr(value, 'resolve_expression'):\n        value = value.resolve_expression(self, reuse=can_reuse, allow_joins=allow_joins)\n    elif isinstance(value, (list, tuple)):\n        return type(value)((self.resolve_lookup_value(sub_value, can_reuse, allow_joins) for sub_value in value))\n    return value",
    ".django.db.models.sql.query.py@@Query.get_initial_alias": "def get_initial_alias(self):\n    if self.alias_map:\n        alias = self.base_table\n        self.ref_alias(alias)\n    else:\n        alias = self.join(BaseTable(self.get_meta().db_table, None))\n    return alias",
    ".django.db.models.sql.datastructures.py@@BaseTable.__init__": "def __init__(self, table_name, alias):\n    self.table_name = table_name\n    self.table_alias = alias",
    ".django.db.models.sql.query.py@@Query.join": "def join(self, join, reuse=None, reuse_with_filtered_relation=False):\n    if reuse_with_filtered_relation and reuse:\n        reuse_aliases = [a for a, j in self.alias_map.items() if a in reuse and j.equals(join, with_filtered_relation=False)]\n    else:\n        reuse_aliases = [a for a, j in self.alias_map.items() if (reuse is None or a in reuse) and j == join]\n    if reuse_aliases:\n        if join.table_alias in reuse_aliases:\n            reuse_alias = join.table_alias\n        else:\n            reuse_alias = reuse_aliases[-1]\n        self.ref_alias(reuse_alias)\n        return reuse_alias\n    alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)\n    if join.join_type:\n        if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n            join_type = LOUTER\n        else:\n            join_type = INNER\n        join.join_type = join_type\n    join.table_alias = alias\n    self.alias_map[alias] = join\n    return alias",
    ".django.db.models.sql.query.py@@Query.table_alias": "def table_alias(self, table_name, create=False, filtered_relation=None):\n    alias_list = self.table_map.get(table_name)\n    if not create and alias_list:\n        alias = alias_list[0]\n        self.alias_refcount[alias] += 1\n        return (alias, False)\n    if alias_list:\n        alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)\n        alias_list.append(alias)\n    else:\n        alias = filtered_relation.alias if filtered_relation is not None else table_name\n        self.table_map[table_name] = [alias]\n    self.alias_refcount[alias] = 1\n    return (alias, True)",
    ".django.db.models.sql.query.py@@Query.setup_joins": "def setup_joins(self, names, opts, alias, can_reuse=None, allow_many=True, reuse_with_filtered_relation=False):\n    joins = [alias]\n\n    def final_transformer(field, alias):\n        return field.get_col(alias)\n    last_field_exception = None\n    for pivot in range(len(names), 0, -1):\n        try:\n            path, final_field, targets, rest = self.names_to_path(names[:pivot], opts, allow_many, fail_on_missing=True)\n        except FieldError as exc:\n            if pivot == 1:\n                raise\n            else:\n                last_field_exception = exc\n        else:\n            transforms = names[pivot:]\n            break\n    for name in transforms:\n\n        def transform(field, alias, *, name, previous):\n            try:\n                wrapped = previous(field, alias)\n                return self.try_transform(wrapped, name)\n            except FieldError:\n                if isinstance(final_field, Field) and last_field_exception:\n                    raise last_field_exception\n                else:\n                    raise\n        final_transformer = functools.partial(transform, name=name, previous=final_transformer)\n    for join in path:\n        if join.filtered_relation:\n            filtered_relation = join.filtered_relation.clone()\n            table_alias = filtered_relation.alias\n        else:\n            filtered_relation = None\n            table_alias = None\n        opts = join.to_opts\n        if join.direct:\n            nullable = self.is_nullable(join.join_field)\n        else:\n            nullable = True\n        connection = Join(opts.db_table, alias, table_alias, INNER, join.join_field, nullable, filtered_relation=filtered_relation)\n        reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None\n        alias = self.join(connection, reuse=reuse, reuse_with_filtered_relation=reuse_with_filtered_relation)\n        joins.append(alias)\n        if filtered_relation:\n            filtered_relation.path = joins[:]\n    return JoinInfo(final_field, targets, opts, joins, path, final_transformer)",
    ".django.db.models.sql.query.py@@Query.check_related_objects": "def check_related_objects(self, field, value, opts):\n    if field.is_relation:\n        if isinstance(value, Query) and (not value.has_select_fields) and (not check_rel_lookup_compatibility(value.model, opts, field)):\n            raise ValueError('Cannot use QuerySet for \"%s\": Use a QuerySet for \"%s\".' % (value.model._meta.object_name, opts.object_name))\n        elif hasattr(value, '_meta'):\n            self.check_query_object_type(value, opts, field)\n        elif hasattr(value, '__iter__'):\n            for v in value:\n                self.check_query_object_type(v, opts, field)",
    ".django.db.models.sql.query.py@@Query.trim_joins": "def trim_joins(self, targets, joins, path):\n    joins = joins[:]\n    for pos, info in enumerate(reversed(path)):\n        if len(joins) == 1 or not info.direct:\n            break\n        if info.filtered_relation:\n            break\n        join_targets = {t.column for t in info.join_field.foreign_related_fields}\n        cur_targets = {t.column for t in targets}\n        if not cur_targets.issubset(join_targets):\n            break\n        targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}\n        targets = tuple((targets_dict[t.column] for t in targets))\n        self.unref_alias(joins.pop())\n    return (targets, joins[-1], joins)",
    ".django.db.models.sql.query.py@@Query._get_col": "def _get_col(self, target, field, alias):\n    if not self.alias_cols:\n        alias = None\n    return target.get_col(alias, field)",
    ".django.db.models.fields.__init__.py@@Field.get_col": "def get_col(self, alias, output_field=None):\n    if output_field is None:\n        output_field = self\n    if alias != self.model._meta.db_table or output_field != self:\n        from django.db.models.expressions import Col\n        return Col(alias, self, output_field)\n    else:\n        return self.cached_col",
    ".django.db.models.fields.__init__.py@@Field.__eq__": "def __eq__(self, other):\n    if isinstance(other, Field):\n        return self.creation_counter == other.creation_counter\n    return NotImplemented",
    ".django.db.models.sql.query.py@@Query.build_lookup": "def build_lookup(self, lookups, lhs, rhs):\n    *transforms, lookup_name = lookups or ['exact']\n    for name in transforms:\n        lhs = self.try_transform(lhs, name)\n    lookup_class = lhs.get_lookup(lookup_name)\n    if not lookup_class:\n        if lhs.field.is_relation:\n            raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))\n        lhs = self.try_transform(lhs, lookup_name)\n        lookup_name = 'exact'\n        lookup_class = lhs.get_lookup(lookup_name)\n        if not lookup_class:\n            return\n    lookup = lookup_class(lhs, rhs)\n    if lookup.rhs is None and (not lookup.can_use_none_as_rhs):\n        if lookup_name not in ('exact', 'iexact'):\n            raise ValueError('Cannot use None as a query value')\n        return lhs.get_lookup('isnull')(lhs, True)\n    if connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and lookup_name == 'exact' and (lookup.rhs == ''):\n        return lhs.get_lookup('isnull')(lhs, True)\n    return lookup",
    ".django.db.models.expressions.py@@BaseExpression.get_lookup": "def get_lookup(self, lookup):\n    return self.output_field.get_lookup(lookup)",
    ".django.db.models.query_utils.py@@RegisterLookupMixin.get_lookup": "def get_lookup(self, lookup_name):\n    from django.db.models.lookups import Lookup\n    found = self._get_lookup(lookup_name)\n    if found is None and hasattr(self, 'output_field'):\n        return self.output_field.get_lookup(lookup_name)\n    if found is not None and (not issubclass(found, Lookup)):\n        return None\n    return found",
    ".django.db.models.query_utils.py@@RegisterLookupMixin._get_lookup": "def _get_lookup(cls, lookup_name):\n    return cls.get_lookups().get(lookup_name, None)",
    ".django.db.models.lookups.py@@Lookup.__init__": "def __init__(self, lhs, rhs):\n    self.lhs, self.rhs = (lhs, rhs)\n    self.rhs = self.get_prep_lookup()\n    if hasattr(self.lhs, 'get_bilateral_transforms'):\n        bilateral_transforms = self.lhs.get_bilateral_transforms()\n    else:\n        bilateral_transforms = []\n    if bilateral_transforms:\n        from django.db.models.sql.query import Query\n        if isinstance(rhs, Query):\n            raise NotImplementedError('Bilateral transformations on nested querysets are not implemented.')\n    self.bilateral_transforms = bilateral_transforms",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueIterableMixin.get_prep_lookup": "def get_prep_lookup(self):\n    if hasattr(self.rhs, 'resolve_expression'):\n        return self.rhs\n    prepared_values = []\n    for rhs_value in self.rhs:\n        if hasattr(rhs_value, 'resolve_expression'):\n            pass\n        elif self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):\n            rhs_value = self.lhs.output_field.get_prep_value(rhs_value)\n        prepared_values.append(rhs_value)\n    return prepared_values",
    ".django.db.models.fields.__init__.py@@IntegerField.get_prep_value": "def get_prep_value(self, value):\n    value = super().get_prep_value(value)\n    if value is None:\n        return None\n    try:\n        return int(value)\n    except (TypeError, ValueError) as e:\n        raise e.__class__(\"Field '%s' expected a number but got %r.\" % (self.name, value)) from e",
    ".django.db.models.fields.__init__.py@@Field.get_prep_value": "def get_prep_value(self, value):\n    if isinstance(value, Promise):\n        value = value._proxy____cast()\n    return value",
    ".django.utils.tree.py@@Node.add": "def add(self, data, conn_type, squash=True):\n    if data in self.children:\n        return data\n    if not squash:\n        self.children.append(data)\n        return data\n    if self.connector == conn_type:\n        if isinstance(data, Node) and (not data.negated) and (data.connector == conn_type or len(data) == 1):\n            self.children.extend(data.children)\n            return self\n        else:\n            self.children.append(data)\n            return data\n    else:\n        obj = self._new_instance(self.children, self.connector, self.negated)\n        self.connector = conn_type\n        self.children = [obj, data]\n        return data",
    ".django.db.models.sql.query.py@@JoinPromoter.add_votes": "def add_votes(self, votes):\n    self.votes.update(votes)",
    ".django.utils.tree.py@@Node.__bool__": "def __bool__(self):\n    return bool(self.children)",
    ".django.db.models.sql.query.py@@JoinPromoter.update_join_types": "def update_join_types(self, query):\n    to_promote = set()\n    to_demote = set()\n    for table, votes in self.votes.items():\n        if self.effective_connector == 'OR' and votes < self.num_children:\n            to_promote.add(table)\n        if self.effective_connector == 'AND' or (self.effective_connector == 'OR' and votes == self.num_children):\n            to_demote.add(table)\n    query.promote_joins(to_promote)\n    query.demote_joins(to_demote)\n    return to_demote",
    ".django.db.models.sql.query.py@@Query.promote_joins": "def promote_joins(self, aliases):\n    aliases = list(aliases)\n    while aliases:\n        alias = aliases.pop(0)\n        if self.alias_map[alias].join_type is None:\n            continue\n        assert self.alias_map[alias].join_type is not None\n        parent_alias = self.alias_map[alias].parent_alias\n        parent_louter = parent_alias and self.alias_map[parent_alias].join_type == LOUTER\n        already_louter = self.alias_map[alias].join_type == LOUTER\n        if (self.alias_map[alias].nullable or parent_louter) and (not already_louter):\n            self.alias_map[alias] = self.alias_map[alias].promote()\n            aliases.extend((join for join in self.alias_map if self.alias_map[join].parent_alias == alias and join not in aliases))",
    ".django.db.models.sql.query.py@@Query.demote_joins": "def demote_joins(self, aliases):\n    aliases = list(aliases)\n    while aliases:\n        alias = aliases.pop(0)\n        if self.alias_map[alias].join_type == LOUTER:\n            self.alias_map[alias] = self.alias_map[alias].demote()\n            parent_alias = self.alias_map[alias].parent_alias\n            if self.alias_map[parent_alias].join_type == INNER:\n                aliases.append(parent_alias)",
    ".django.db.models.sql.subqueries.py@@DeleteQuery.do_query": "def do_query(self, table, where, using):\n    self.alias_map = {table: self.alias_map[table]}\n    self.where = where\n    cursor = self.get_compiler(using).execute_sql(CURSOR)\n    if cursor:\n        with cursor:\n            return cursor.rowcount\n    return 0",
    ".django.db.models.fields.__init__.py@@AutoField.get_internal_type": "def get_internal_type(self):\n    return 'AutoField'",
    ".django.db.models.sql.query.py@@Query.ref_alias": "def ref_alias(self, alias):\n    self.alias_refcount[alias] += 1",
    ".django.db.models.options.py@@Options.label": "def label(self):\n    return '%s.%s' % (self.app_label, self.object_name)",
    ".django.db.models.fields.__init__.py@@Field.cached_col": "def cached_col(self):\n    from django.db.models.expressions import Col\n    return Col(self.model._meta.db_table, self)",
    ".django.db.models.expressions.py@@Col.__init__": "def __init__(self, alias, target, output_field=None):\n    if output_field is None:\n        output_field = target\n    super().__init__(output_field=output_field)\n    self.alias, self.target = (alias, target)",
    ".django.db.models.expressions.py@@BaseExpression.__init__": "def __init__(self, output_field=None):\n    if output_field is not None:\n        self.output_field = output_field",
    ".django.db.transaction.py@@Atomic.__exit__": "def __exit__(self, exc_type, exc_value, traceback):\n    connection = get_connection(self.using)\n    if connection.savepoint_ids:\n        sid = connection.savepoint_ids.pop()\n    else:\n        connection.in_atomic_block = False\n    try:\n        if connection.closed_in_transaction:\n            pass\n        elif exc_type is None and (not connection.needs_rollback):\n            if connection.in_atomic_block:\n                if sid is not None:\n                    try:\n                        connection.savepoint_commit(sid)\n                    except DatabaseError:\n                        try:\n                            connection.savepoint_rollback(sid)\n                            connection.savepoint_commit(sid)\n                        except Error:\n                            connection.needs_rollback = True\n                        raise\n            else:\n                try:\n                    connection.commit()\n                except DatabaseError:\n                    try:\n                        connection.rollback()\n                    except Error:\n                        connection.close()\n                    raise\n        else:\n            connection.needs_rollback = False\n            if connection.in_atomic_block:\n                if sid is None:\n                    connection.needs_rollback = True\n                else:\n                    try:\n                        connection.savepoint_rollback(sid)\n                        connection.savepoint_commit(sid)\n                    except Error:\n                        connection.needs_rollback = True\n            else:\n                try:\n                    connection.rollback()\n                except Error:\n                    connection.close()\n    finally:\n        if not connection.in_atomic_block:\n            if connection.closed_in_transaction:\n                connection.connection = None\n            else:\n                connection.set_autocommit(True)\n        elif not connection.savepoint_ids and (not connection.commit_on_exit):\n            if connection.closed_in_transaction:\n                connection.connection = None\n            else:\n                connection.in_atomic_block = False",
    ".django.db.models.query_utils.py@@DeferredAttribute.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    data = instance.__dict__\n    field_name = self.field.attname\n    if field_name not in data:\n        val = self._check_parent_chain(instance)\n        if val is None:\n            instance.refresh_from_db(fields=[field_name])\n            val = getattr(instance, field_name)\n        data[field_name] = val\n    return data[field_name]",
    ".django.dispatch.dispatcher.py@@Signal.has_listeners": "def has_listeners(self, sender=None):\n    return bool(self._live_receivers(sender))",
    ".django.db.models.fields.__init__.py@@Field.rel_db_type": "def rel_db_type(self, connection):\n    return self.db_type(connection)",
    ".django.db.models.fields.related.py@@ForeignKey.get_db_prep_value": "def get_db_prep_value(self, value, connection, prepared=False):\n    return self.target_field.get_db_prep_value(value, connection, prepared)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.make_cursor": "def make_cursor(self, cursor):\n    return utils.CursorWrapper(cursor, self)",
    ".django.db.models.fields.related.py@@ForeignObject.get_path_info": "def get_path_info(self, filtered_relation=None):\n    opts = self.remote_field.model._meta\n    from_opts = self.model._meta\n    return [PathInfo(from_opts=from_opts, to_opts=opts, target_fields=self.foreign_related_fields, join_field=self, m2m=False, direct=True, filtered_relation=filtered_relation)]",
    ".django.db.models.options.py@@Options.fields_map": "def fields_map(self):\n    res = {}\n    fields = self._get_fields(forward=False, include_hidden=True)\n    for field in fields:\n        res[field.name] = field\n        try:\n            res[field.attname] = field\n        except AttributeError:\n            pass\n    return res",
    ".django.db.models.options.py@@Options._get_fields": "def _get_fields(self, forward=True, reverse=True, include_parents=True, include_hidden=False, seen_models=None):\n    if include_parents not in (True, False, PROXY_PARENTS):\n        raise TypeError('Invalid argument for include_parents: %s' % (include_parents,))\n    topmost_call = seen_models is None\n    if topmost_call:\n        seen_models = set()\n    seen_models.add(self.model)\n    cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)\n    try:\n        return self._get_fields_cache[cache_key]\n    except KeyError:\n        pass\n    fields = []\n    if include_parents is not False:\n        for parent in self.parents:\n            if parent in seen_models:\n                continue\n            if parent._meta.concrete_model != self.concrete_model and include_parents == PROXY_PARENTS:\n                continue\n            for obj in parent._meta._get_fields(forward=forward, reverse=reverse, include_parents=include_parents, include_hidden=include_hidden, seen_models=seen_models):\n                if not getattr(obj, 'parent_link', False) or obj.model == self.concrete_model:\n                    fields.append(obj)\n    if reverse and (not self.proxy):\n        all_fields = self._relation_tree\n        for field in all_fields:\n            if include_hidden or not field.remote_field.hidden:\n                fields.append(field.remote_field)\n    if forward:\n        fields += self.local_fields\n        fields += self.local_many_to_many\n        if topmost_call:\n            fields += self.private_fields\n    fields = make_immutable_fields_list('get_fields()', fields)\n    self._get_fields_cache[cache_key] = fields\n    return fields",
    ".django.db.models.sql.query.py@@Query.annotation_select": "def annotation_select(self):\n    if self._annotation_select_cache is not None:\n        return self._annotation_select_cache\n    elif not self.annotations:\n        return {}\n    elif self.annotation_select_mask is not None:\n        self._annotation_select_cache = {k: v for k, v in self.annotations.items() if k in self.annotation_select_mask}\n        return self._annotation_select_cache\n    else:\n        return self.annotations",
    ".django.db.models.sql.query.py@@Query.is_nullable": "def is_nullable(self, field):\n    return connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and field.empty_strings_allowed or field.null",
    ".django.db.models.sql.datastructures.py@@Join.__init__": "def __init__(self, table_name, parent_alias, table_alias, join_type, join_field, nullable, filtered_relation=None):\n    self.table_name = table_name\n    self.parent_alias = parent_alias\n    self.table_alias = table_alias\n    self.join_type = join_type\n    self.join_cols = join_field.get_joining_columns()\n    self.join_field = join_field\n    self.nullable = nullable\n    self.filtered_relation = filtered_relation",
    ".django.db.models.fields.related.py@@ForeignObject.get_joining_columns": "def get_joining_columns(self, reverse_join=False):\n    source = self.reverse_related_fields if reverse_join else self.related_fields\n    return tuple(((lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source))",
    ".django.db.models.sql.datastructures.py@@Join.__eq__": "def __eq__(self, other):\n    return self.equals(other, with_filtered_relation=True)",
    ".django.db.models.sql.datastructures.py@@Join.equals": "def equals(self, other, with_filtered_relation):\n    return isinstance(other, self.__class__) and self.table_name == other.table_name and (self.parent_alias == other.parent_alias) and (self.join_field == other.join_field) and (not with_filtered_relation or self.filtered_relation == other.filtered_relation)",
    ".django.db.models.sql.query.py@@Query.check_query_object_type": "def check_query_object_type(self, value, opts, field):\n    if hasattr(value, '_meta'):\n        if not check_rel_lookup_compatibility(value._meta.model, opts, field):\n            raise ValueError('Cannot query \"%s\": Must be \"%s\" instance.' % (value, opts.object_name))",
    ".django.db.models.sql.query.py@@Query.unref_alias": "def unref_alias(self, alias, amount=1):\n    self.alias_refcount[alias] -= amount",
    ".django.db.models.fields.related.py@@ForeignKey.get_col": "def get_col(self, alias, output_field=None):\n    if output_field is None:\n        output_field = self.target_field\n        while isinstance(output_field, ForeignKey):\n            output_field = output_field.target_field\n            if output_field is self:\n                raise ValueError('Cannot resolve output_field.')\n    return super().get_col(alias, output_field)",
    ".django.db.models.fields.related_lookups.py@@RelatedIn.get_prep_lookup": "def get_prep_lookup(self):\n    if not isinstance(self.lhs, MultiColSource) and self.rhs_is_direct_value():\n        self.rhs = [get_normalized_value(val, self.lhs)[0] for val in self.rhs]\n        if hasattr(self.lhs.output_field, 'get_path_info'):\n            target_field = self.lhs.output_field.get_path_info()[-1].target_fields[-1]\n            self.rhs = [target_field.get_prep_value(v) for v in self.rhs]\n    return super().get_prep_lookup()",
    ".django.db.models.fields.related_lookups.py@@get_normalized_value": "def get_normalized_value(value, lhs):\n    from django.db.models import Model\n    if isinstance(value, Model):\n        value_list = []\n        sources = lhs.output_field.get_path_info()[-1].target_fields\n        for source in sources:\n            while not isinstance(value, source.model) and source.remote_field:\n                source = source.remote_field.model._meta.get_field(source.remote_field.field_name)\n            try:\n                value_list.append(getattr(value, source.attname))\n            except AttributeError:\n                return (value.pk,)\n        return tuple(value_list)\n    if not isinstance(value, tuple):\n        return (value,)\n    return value",
    ".django.db.models.fields.related.py@@ForeignKey.get_prep_value": "def get_prep_value(self, value):\n    return self.target_field.get_prep_value(value)",
    ".django.db.models.fields.related_descriptors.py@@ForeignKeyDeferredAttribute.__set__": "def __set__(self, instance, value):\n    if instance.__dict__.get(self.field.attname) != value and self.field.is_cached(instance):\n        self.field.delete_cached_value(instance)\n    instance.__dict__[self.field.attname] = value",
    ".django.db.models.fields.mixins.py@@FieldCacheMixin.is_cached": "def is_cached(self, instance):\n    return self.get_cache_name() in instance._state.fields_cache",
    ".django.db.models.fields.related.py@@RelatedField.get_cache_name": "def get_cache_name(self):\n    return self.name",
    ".django.db.models.fields.mixins.py@@FieldCacheMixin.delete_cached_value": "def delete_cached_value(self, instance):\n    del instance._state.fields_cache[self.get_cache_name()]",
    ".django.db.models.fields.related_descriptors.py@@ReverseManyToOneDescriptor.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    return self.related_manager_cls(instance)",
    ".django.db.models.fields.related_descriptors.py@@ReverseManyToOneDescriptor.related_manager_cls": "def related_manager_cls(self):\n    related_model = self.rel.related_model\n    return create_reverse_many_to_one_manager(related_model._default_manager.__class__, self.rel)",
    ".django.db.models.base.py@@ModelBase._default_manager": "def _default_manager(cls):\n    return cls._meta.default_manager",
    ".django.db.models.fields.related_descriptors.py@@create_reverse_many_to_one_manager": "def create_reverse_many_to_one_manager(superclass, rel):\n\n    class RelatedManager(superclass):\n\n        def __init__(self, instance):\n            super().__init__()\n            self.instance = instance\n            self.model = rel.related_model\n            self.field = rel.field\n            self.core_filters = {self.field.name: instance}\n\n        def __call__(self, *, manager):\n            manager = getattr(self.model, manager)\n            manager_class = create_reverse_many_to_one_manager(manager.__class__, rel)\n            return manager_class(self.instance)\n        do_not_call_in_templates = True\n\n        def _apply_rel_filters(self, queryset):\n            db = self._db or router.db_for_read(self.model, instance=self.instance)\n            empty_strings_as_null = connections[db].features.interprets_empty_strings_as_nulls\n            queryset._add_hints(instance=self.instance)\n            if self._db:\n                queryset = queryset.using(self._db)\n            queryset = queryset.filter(**self.core_filters)\n            for field in self.field.foreign_related_fields:\n                val = getattr(self.instance, field.attname)\n                if val is None or (val == '' and empty_strings_as_null):\n                    return queryset.none()\n            if self.field.many_to_one:\n                try:\n                    target_field = self.field.target_field\n                except FieldError:\n                    rel_obj_id = tuple([getattr(self.instance, target_field.attname) for target_field in self.field.get_path_info()[-1].target_fields])\n                else:\n                    rel_obj_id = getattr(self.instance, target_field.attname)\n                queryset._known_related_objects = {self.field: {rel_obj_id: self.instance}}\n            return queryset\n\n        def _remove_prefetched_objects(self):\n            try:\n                self.instance._prefetched_objects_cache.pop(self.field.remote_field.get_cache_name())\n            except (AttributeError, KeyError):\n                pass\n\n        def get_queryset(self):\n            try:\n                return self.instance._prefetched_objects_cache[self.field.remote_field.get_cache_name()]\n            except (AttributeError, KeyError):\n                queryset = super().get_queryset()\n                return self._apply_rel_filters(queryset)\n\n        def get_prefetch_queryset(self, instances, queryset=None):\n            if queryset is None:\n                queryset = super().get_queryset()\n            queryset._add_hints(instance=instances[0])\n            queryset = queryset.using(queryset._db or self._db)\n            rel_obj_attr = self.field.get_local_related_value\n            instance_attr = self.field.get_foreign_related_value\n            instances_dict = {instance_attr(inst): inst for inst in instances}\n            query = {'%s__in' % self.field.name: instances}\n            queryset = queryset.filter(**query)\n            for rel_obj in queryset:\n                instance = instances_dict[rel_obj_attr(rel_obj)]\n                setattr(rel_obj, self.field.name, instance)\n            cache_name = self.field.remote_field.get_cache_name()\n            return (queryset, rel_obj_attr, instance_attr, False, cache_name, False)\n\n        def add(self, *objs, bulk=True):\n            self._remove_prefetched_objects()\n            objs = list(objs)\n            db = router.db_for_write(self.model, instance=self.instance)\n\n            def check_and_update_obj(obj):\n                if not isinstance(obj, self.model):\n                    raise TypeError(\"'%s' instance expected, got %r\" % (self.model._meta.object_name, obj))\n                setattr(obj, self.field.name, self.instance)\n            if bulk:\n                pks = []\n                for obj in objs:\n                    check_and_update_obj(obj)\n                    if obj._state.adding or obj._state.db != db:\n                        raise ValueError(\"%r instance isn't saved. Use bulk=False or save the object first.\" % obj)\n                    pks.append(obj.pk)\n                self.model._base_manager.using(db).filter(pk__in=pks).update(**{self.field.name: self.instance})\n            else:\n                with transaction.atomic(using=db, savepoint=False):\n                    for obj in objs:\n                        check_and_update_obj(obj)\n                        obj.save()\n        add.alters_data = True\n\n        def create(self, **kwargs):\n            kwargs[self.field.name] = self.instance\n            db = router.db_for_write(self.model, instance=self.instance)\n            return super(RelatedManager, self.db_manager(db)).create(**kwargs)\n        create.alters_data = True\n\n        def get_or_create(self, **kwargs):\n            kwargs[self.field.name] = self.instance\n            db = router.db_for_write(self.model, instance=self.instance)\n            return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)\n        get_or_create.alters_data = True\n\n        def update_or_create(self, **kwargs):\n            kwargs[self.field.name] = self.instance\n            db = router.db_for_write(self.model, instance=self.instance)\n            return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)\n        update_or_create.alters_data = True\n        if rel.field.null:\n\n            def remove(self, *objs, bulk=True):\n                if not objs:\n                    return\n                val = self.field.get_foreign_related_value(self.instance)\n                old_ids = set()\n                for obj in objs:\n                    if not isinstance(obj, self.model):\n                        raise TypeError(\"'%s' instance expected, got %r\" % (self.model._meta.object_name, obj))\n                    if self.field.get_local_related_value(obj) == val:\n                        old_ids.add(obj.pk)\n                    else:\n                        raise self.field.remote_field.model.DoesNotExist('%r is not related to %r.' % (obj, self.instance))\n                self._clear(self.filter(pk__in=old_ids), bulk)\n            remove.alters_data = True\n\n            def clear(self, *, bulk=True):\n                self._clear(self, bulk)\n            clear.alters_data = True\n\n            def _clear(self, queryset, bulk):\n                self._remove_prefetched_objects()\n                db = router.db_for_write(self.model, instance=self.instance)\n                queryset = queryset.using(db)\n                if bulk:\n                    queryset.update(**{self.field.name: None})\n                else:\n                    with transaction.atomic(using=db, savepoint=False):\n                        for obj in queryset:\n                            setattr(obj, self.field.name, None)\n                            obj.save(update_fields=[self.field.name])\n            _clear.alters_data = True\n\n        def set(self, objs, *, bulk=True, clear=False):\n            objs = tuple(objs)\n            if self.field.null:\n                db = router.db_for_write(self.model, instance=self.instance)\n                with transaction.atomic(using=db, savepoint=False):\n                    if clear:\n                        self.clear(bulk=bulk)\n                        self.add(*objs, bulk=bulk)\n                    else:\n                        old_objs = set(self.using(db).all())\n                        new_objs = []\n                        for obj in objs:\n                            if obj in old_objs:\n                                old_objs.remove(obj)\n                            else:\n                                new_objs.append(obj)\n                        self.remove(*old_objs, bulk=bulk)\n                        self.add(*new_objs, bulk=bulk)\n            else:\n                self.add(*objs, bulk=bulk)\n        set.alters_data = True\n    return RelatedManager",
    ".django.db.models.manager.py@@BaseManager.__new__": "def __new__(cls, *args, **kwargs):\n    obj = super().__new__(cls)\n    obj._constructor_args = (args, kwargs)\n    return obj",
    ".django.db.models.manager.py@@BaseManager.__init__": "def __init__(self):\n    super().__init__()\n    self._set_creation_counter()\n    self.model = None\n    self.name = None\n    self._db = None\n    self._hints = {}",
    ".django.db.models.manager.py@@BaseManager._set_creation_counter": "def _set_creation_counter(self):\n    self.creation_counter = BaseManager.creation_counter\n    BaseManager.creation_counter += 1",
    ".django.db.models.manager.py@@BaseManager.all": "def all(self):\n    return self.get_queryset()",
    ".django.db.models.manager.py@@BaseManager.get_queryset": "def get_queryset(self):\n    return self._queryset_class(model=self.model, using=self._db, hints=self._hints)",
    ".django.db.models.query.py@@QuerySet.__init__": "def __init__(self, model=None, query=None, using=None, hints=None):\n    self.model = model\n    self._db = using\n    self._hints = hints or {}\n    self._query = query or sql.Query(self.model)\n    self._result_cache = None\n    self._sticky_filter = False\n    self._for_write = False\n    self._prefetch_related_lookups = ()\n    self._prefetch_done = False\n    self._known_related_objects = {}\n    self._iterable_class = ModelIterable\n    self._fields = None\n    self._defer_next_filter = False\n    self._deferred_filter = None",
    ".django.db.utils.py@@ConnectionRouter._route_db": "def _route_db(self, model, **hints):\n    chosen_db = None\n    for router in self.routers:\n        try:\n            method = getattr(router, action)\n        except AttributeError:\n            pass\n        else:\n            chosen_db = method(model, **hints)\n            if chosen_db:\n                return chosen_db\n    instance = hints.get('instance')\n    if instance is not None and instance._state.db:\n        return instance._state.db\n    return DEFAULT_DB_ALIAS",
    ".django.db.models.query.py@@QuerySet._add_hints": "def _add_hints(self, **hints):\n    self._hints.update(hints)",
    ".django.db.models.query.py@@QuerySet.filter": "def filter(self, *args, **kwargs):\n    self._not_support_combined_queries('filter')\n    return self._filter_or_exclude(False, *args, **kwargs)",
    ".django.db.models.query.py@@QuerySet._not_support_combined_queries": "def _not_support_combined_queries(self, operation_name):\n    if self.query.combinator:\n        raise NotSupportedError('Calling QuerySet.%s() after %s() is not supported.' % (operation_name, self.query.combinator))",
    ".django.db.models.query.py@@QuerySet._filter_or_exclude": "def _filter_or_exclude(self, negate, *args, **kwargs):\n    if args or kwargs:\n        assert not self.query.is_sliced, 'Cannot filter a query once a slice has been taken.'\n    clone = self._chain()\n    if self._defer_next_filter:\n        self._defer_next_filter = False\n        clone._deferred_filter = (negate, args, kwargs)\n    else:\n        clone._filter_or_exclude_inplace(negate, *args, **kwargs)\n    return clone",
    ".django.db.models.sql.query.py@@Query.is_sliced": "def is_sliced(self):\n    return self.low_mark != 0 or self.high_mark is not None",
    ".django.db.models.query.py@@QuerySet._chain": "def _chain(self, **kwargs):\n    obj = self._clone()\n    if obj._sticky_filter:\n        obj.query.filter_is_sticky = True\n        obj._sticky_filter = False\n    obj.__dict__.update(kwargs)\n    return obj",
    ".django.db.models.query.py@@QuerySet._clone": "def _clone(self):\n    c = self.__class__(model=self.model, query=self.query.chain(), using=self._db, hints=self._hints)\n    c._sticky_filter = self._sticky_filter\n    c._for_write = self._for_write\n    c._prefetch_related_lookups = self._prefetch_related_lookups[:]\n    c._known_related_objects = self._known_related_objects\n    c._iterable_class = self._iterable_class\n    c._fields = self._fields\n    return c",
    ".django.db.models.sql.query.py@@Query.chain": "def chain(self, klass=None):\n    obj = self.clone()\n    if klass and obj.__class__ != klass:\n        obj.__class__ = klass\n    if not obj.filter_is_sticky:\n        obj.used_aliases = set()\n    obj.filter_is_sticky = False\n    if hasattr(obj, '_setup_query'):\n        obj._setup_query()\n    return obj",
    ".django.db.models.query.py@@QuerySet._filter_or_exclude_inplace": "def _filter_or_exclude_inplace(self, negate, *args, **kwargs):\n    if negate:\n        self._query.add_q(~Q(*args, **kwargs))\n    else:\n        self._query.add_q(Q(*args, **kwargs))",
    ".django.db.models.query_utils.py@@check_rel_lookup_compatibility": "def check_rel_lookup_compatibility(model, target_opts, field):\n\n    def check(opts):\n        return model._meta.concrete_model == opts.concrete_model or opts.concrete_model in model._meta.get_parent_list() or model in opts.get_parent_list()\n    return check(target_opts) or (getattr(field, 'primary_key', False) and check(field.model._meta))",
    ".django.db.models.query_utils.py@@check": "def check(opts):\n    return model._meta.concrete_model == opts.concrete_model or opts.concrete_model in model._meta.get_parent_list() or model in opts.get_parent_list()",
    ".django.db.models.fields.related_lookups.py@@RelatedLookupMixin.get_prep_lookup": "def get_prep_lookup(self):\n    if not isinstance(self.lhs, MultiColSource) and (not hasattr(self.rhs, 'resolve_expression')):\n        self.rhs = get_normalized_value(self.rhs, self.lhs)[0]\n        if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_path_info'):\n            target_field = self.lhs.output_field.get_path_info()[-1].target_fields[-1]\n            self.rhs = target_field.get_prep_value(self.rhs)\n    return super().get_prep_lookup()",
    ".django.db.models.lookups.py@@Lookup.get_prep_lookup": "def get_prep_lookup(self):\n    if hasattr(self.rhs, 'resolve_expression'):\n        return self.rhs\n    if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):\n        return self.lhs.output_field.get_prep_value(self.rhs)\n    return self.rhs",
    ".django.db.models.sql.datastructures.py@@Join.demote": "def demote(self):\n    new = self.relabeled_clone({})\n    new.join_type = INNER\n    return new",
    ".django.db.models.sql.datastructures.py@@Join.relabeled_clone": "def relabeled_clone(self, change_map):\n    new_parent_alias = change_map.get(self.parent_alias, self.parent_alias)\n    new_table_alias = change_map.get(self.table_alias, self.table_alias)\n    if self.filtered_relation is not None:\n        filtered_relation = self.filtered_relation.clone()\n        filtered_relation.path = [change_map.get(p, p) for p in self.filtered_relation.path]\n    else:\n        filtered_relation = None\n    return self.__class__(self.table_name, new_parent_alias, new_table_alias, self.join_type, self.join_field, self.nullable, filtered_relation=filtered_relation)",
    ".django.db.models.fields.__init__.py@@Field.__hash__": "def __hash__(self):\n    return hash(self.creation_counter)",
    ".django.db.models.query.py@@QuerySet.__iter__": "def __iter__(self):\n    self._fetch_all()\n    return iter(self._result_cache)",
    ".django.db.models.query.py@@QuerySet._fetch_all": "def _fetch_all(self):\n    if self._result_cache is None:\n        self._result_cache = list(self._iterable_class(self))\n    if self._prefetch_related_lookups and (not self._prefetch_done):\n        self._prefetch_related_objects()",
    ".django.db.models.query.py@@BaseIterable.__init__": "def __init__(self, queryset, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n    self.queryset = queryset\n    self.chunked_fetch = chunked_fetch\n    self.chunk_size = chunk_size",
    ".django.db.models.query.py@@ModelIterable.__iter__": "def __iter__(self):\n    queryset = self.queryset\n    db = queryset.db\n    compiler = queryset.query.get_compiler(using=db)\n    results = compiler.execute_sql(chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size)\n    select, klass_info, annotation_col_map = (compiler.select, compiler.klass_info, compiler.annotation_col_map)\n    model_cls = klass_info['model']\n    select_fields = klass_info['select_fields']\n    model_fields_start, model_fields_end = (select_fields[0], select_fields[-1] + 1)\n    init_list = [f[0].target.attname for f in select[model_fields_start:model_fields_end]]\n    related_populators = get_related_populators(klass_info, select, db)\n    known_related_objects = [(field, related_objs, operator.attrgetter(*[field.attname if from_field == 'self' else queryset.model._meta.get_field(from_field).attname for from_field in field.from_fields])) for field, related_objs in queryset._known_related_objects.items()]\n    for row in compiler.results_iter(results):\n        obj = model_cls.from_db(db, init_list, row[model_fields_start:model_fields_end])\n        for rel_populator in related_populators:\n            rel_populator.populate(row, obj)\n        if annotation_col_map:\n            for attr_name, col_pos in annotation_col_map.items():\n                setattr(obj, attr_name, row[col_pos])\n        for field, rel_objs, rel_getter in known_related_objects:\n            if field.is_cached(obj):\n                continue\n            rel_obj_id = rel_getter(obj)\n            try:\n                rel_obj = rel_objs[rel_obj_id]\n            except KeyError:\n                pass\n            else:\n                setattr(obj, field.name, rel_obj)\n        yield obj",
    ".django.db.models.query.py@@QuerySet.db": "def db(self):\n    if self._for_write:\n        return self._db or router.db_for_write(self.model, **self._hints)\n    return self._db or router.db_for_read(self.model, **self._hints)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.as_sql": "def as_sql(self, with_limits=True, with_col_aliases=False):\n    refcounts_before = self.query.alias_refcount.copy()\n    try:\n        extra_select, order_by, group_by = self.pre_sql_setup()\n        for_update_part = None\n        with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n        combinator = self.query.combinator\n        features = self.connection.features\n        if combinator:\n            if not getattr(features, 'supports_select_{}'.format(combinator)):\n                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n        else:\n            distinct_fields, distinct_params = self.get_distinct()\n            from_, f_params = self.get_from_clause()\n            where, w_params = self.compile(self.where) if self.where is not None else ('', [])\n            having, h_params = self.compile(self.having) if self.having is not None else ('', [])\n            result = ['SELECT']\n            params = []\n            if self.query.distinct:\n                distinct_result, distinct_params = self.connection.ops.distinct_sql(distinct_fields, distinct_params)\n                result += distinct_result\n                params += distinct_params\n            out_cols = []\n            col_idx = 1\n            for _, (s_sql, s_params), alias in self.select + extra_select:\n                if alias:\n                    s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n                elif with_col_aliases:\n                    s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n                    col_idx += 1\n                params.extend(s_params)\n                out_cols.append(s_sql)\n            result += [', '.join(out_cols), 'FROM', *from_]\n            params.extend(f_params)\n            if self.query.select_for_update and self.connection.features.has_select_for_update:\n                if self.connection.get_autocommit():\n                    raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')\n                if with_limit_offset and (not self.connection.features.supports_select_for_update_with_limit):\n                    raise NotSupportedError('LIMIT/OFFSET is not supported with select_for_update on this database backend.')\n                nowait = self.query.select_for_update_nowait\n                skip_locked = self.query.select_for_update_skip_locked\n                of = self.query.select_for_update_of\n                if nowait and (not self.connection.features.has_select_for_update_nowait):\n                    raise NotSupportedError('NOWAIT is not supported on this database backend.')\n                elif skip_locked and (not self.connection.features.has_select_for_update_skip_locked):\n                    raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')\n                elif of and (not self.connection.features.has_select_for_update_of):\n                    raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')\n                for_update_part = self.connection.ops.for_update_sql(nowait=nowait, skip_locked=skip_locked, of=self.get_select_for_update_of_arguments())\n            if for_update_part and self.connection.features.for_update_after_from:\n                result.append(for_update_part)\n            if where:\n                result.append('WHERE %s' % where)\n                params.extend(w_params)\n            grouping = []\n            for g_sql, g_params in group_by:\n                grouping.append(g_sql)\n                params.extend(g_params)\n            if grouping:\n                if distinct_fields:\n                    raise NotImplementedError('annotate() + distinct(fields) is not implemented.')\n                order_by = order_by or self.connection.ops.force_no_ordering()\n                result.append('GROUP BY %s' % ', '.join(grouping))\n                if self._meta_ordering:\n                    order_by = None\n            if having:\n                result.append('HAVING %s' % having)\n                params.extend(h_params)\n        if self.query.explain_query:\n            result.insert(0, self.connection.ops.explain_query_prefix(self.query.explain_format, **self.query.explain_options))\n        if order_by:\n            ordering = []\n            for _, (o_sql, o_params, _) in order_by:\n                ordering.append(o_sql)\n                params.extend(o_params)\n            result.append('ORDER BY %s' % ', '.join(ordering))\n        if with_limit_offset:\n            result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))\n        if for_update_part and (not self.connection.features.for_update_after_from):\n            result.append(for_update_part)\n        if self.query.subquery and extra_select:\n            sub_selects = []\n            sub_params = []\n            for index, (select, _, alias) in enumerate(self.select, start=1):\n                if not alias and with_col_aliases:\n                    alias = 'col%d' % index\n                if alias:\n                    sub_selects.append('%s.%s' % (self.connection.ops.quote_name('subquery'), self.connection.ops.quote_name(alias)))\n                else:\n                    select_clone = select.relabeled_clone({select.alias: 'subquery'})\n                    subselect, subparams = select_clone.as_sql(self, self.connection)\n                    sub_selects.append(subselect)\n                    sub_params.extend(subparams)\n            return ('SELECT %s FROM (%s) subquery' % (', '.join(sub_selects), ' '.join(result)), tuple(sub_params + params))\n        return (' '.join(result), tuple(params))\n    finally:\n        self.query.reset_refcounts(refcounts_before)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.pre_sql_setup": "def pre_sql_setup(self):\n    self.setup_query()\n    order_by = self.get_order_by()\n    self.where, self.having = self.query.where.split_having()\n    extra_select = self.get_extra_select(order_by, self.select)\n    self.has_extra_select = bool(extra_select)\n    group_by = self.get_group_by(self.select + extra_select, order_by)\n    return (extra_select, order_by, group_by)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.setup_query": "def setup_query(self):\n    if all((self.query.alias_refcount[a] == 0 for a in self.query.alias_map)):\n        self.query.get_initial_alias()\n    self.select, self.klass_info, self.annotation_col_map = self.get_select()\n    self.col_count = len(self.select)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_select": "def get_select(self):\n    select = []\n    klass_info = None\n    annotations = {}\n    select_idx = 0\n    for alias, (sql, params) in self.query.extra_select.items():\n        annotations[alias] = select_idx\n        select.append((RawSQL(sql, params), alias))\n        select_idx += 1\n    assert not (self.query.select and self.query.default_cols)\n    if self.query.default_cols:\n        cols = self.get_default_columns()\n    else:\n        cols = self.query.select\n    if cols:\n        select_list = []\n        for col in cols:\n            select_list.append(select_idx)\n            select.append((col, None))\n            select_idx += 1\n        klass_info = {'model': self.query.model, 'select_fields': select_list}\n    for alias, annotation in self.query.annotation_select.items():\n        annotations[alias] = select_idx\n        select.append((annotation, alias))\n        select_idx += 1\n    if self.query.select_related:\n        related_klass_infos = self.get_related_selections(select)\n        klass_info['related_klass_infos'] = related_klass_infos\n\n        def get_select_from_parent(klass_info):\n            for ki in klass_info['related_klass_infos']:\n                if ki['from_parent']:\n                    ki['select_fields'] = klass_info['select_fields'] + ki['select_fields']\n                get_select_from_parent(ki)\n        get_select_from_parent(klass_info)\n    ret = []\n    for col, alias in select:\n        try:\n            sql, params = self.compile(col)\n        except EmptyResultSet:\n            sql, params = ('0', ())\n        else:\n            sql, params = col.select_format(self, sql, params)\n        ret.append((col, (sql, params), alias))\n    return (ret, klass_info, annotations)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_default_columns": "def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n    result = []\n    if opts is None:\n        opts = self.query.get_meta()\n    only_load = self.deferred_to_columns()\n    start_alias = start_alias or self.query.get_initial_alias()\n    seen_models = {None: start_alias}\n    for field in opts.concrete_fields:\n        model = field.model._meta.concrete_model\n        if model == opts.model:\n            model = None\n        if from_parent and model is not None and issubclass(from_parent._meta.concrete_model, model._meta.concrete_model):\n            continue\n        if field.model in only_load and field.attname not in only_load[field.model]:\n            continue\n        alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n        column = field.get_col(alias)\n        result.append(column)\n    return result",
    ".django.db.models.sql.compiler.py@@SQLCompiler.deferred_to_columns": "def deferred_to_columns(self):\n    columns = {}\n    self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)\n    return columns",
    ".django.db.models.sql.query.py@@Query.deferred_to_data": "def deferred_to_data(self, target, callback):\n    field_names, defer = self.deferred_loading\n    if not field_names:\n        return\n    orig_opts = self.get_meta()\n    seen = {}\n    must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n    for field_name in field_names:\n        parts = field_name.split(LOOKUP_SEP)\n        cur_model = self.model._meta.concrete_model\n        opts = orig_opts\n        for name in parts[:-1]:\n            old_model = cur_model\n            if name in self._filtered_relations:\n                name = self._filtered_relations[name].relation_name\n            source = opts.get_field(name)\n            if is_reverse_o2o(source):\n                cur_model = source.related_model\n            else:\n                cur_model = source.remote_field.model\n            opts = cur_model._meta\n            if not is_reverse_o2o(source):\n                must_include[old_model].add(source)\n            add_to_dict(must_include, cur_model, opts.pk)\n        field = opts.get_field(parts[-1])\n        is_reverse_object = field.auto_created and (not field.concrete)\n        model = field.related_model if is_reverse_object else field.model\n        model = model._meta.concrete_model\n        if model == opts.model:\n            model = cur_model\n        if not is_reverse_o2o(field):\n            add_to_dict(seen, model, field)\n    if defer:\n        workset = {}\n        for model, values in seen.items():\n            for field in model._meta.local_fields:\n                if field not in values:\n                    m = field.model._meta.concrete_model\n                    add_to_dict(workset, m, field)\n        for model, values in must_include.items():\n            if model in workset:\n                workset[model].update(values)\n        for model, values in workset.items():\n            callback(target, model, values)\n    else:\n        for model, values in must_include.items():\n            if model in seen:\n                seen[model].update(values)\n            else:\n                seen[model] = values\n        for model in orig_opts.get_parent_list():\n            seen.setdefault(model, set())\n        for model, values in seen.items():\n            callback(target, model, values)",
    ".django.db.models.sql.query.py@@Query.join_parent_model": "def join_parent_model(self, opts, model, alias, seen):\n    if model in seen:\n        return seen[model]\n    chain = opts.get_base_chain(model)\n    if not chain:\n        return alias\n    curr_opts = opts\n    for int_model in chain:\n        if int_model in seen:\n            curr_opts = int_model._meta\n            alias = seen[int_model]\n            continue\n        if not curr_opts.parents[int_model]:\n            curr_opts = int_model._meta\n            continue\n        link_field = curr_opts.get_ancestor_link(int_model)\n        join_info = self.setup_joins([link_field.name], curr_opts, alias)\n        curr_opts = int_model._meta\n        alias = seen[int_model] = join_info.joins[-1]\n    return alias or seen[None]",
    ".django.db.models.expressions.py@@BaseExpression.select_format": "def select_format(self, compiler, sql, params):\n    return self.output_field.select_format(compiler, sql, params)",
    ".django.db.models.fields.__init__.py@@Field.select_format": "def select_format(self, compiler, sql, params):\n    return (sql, params)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_order_by": "def get_order_by(self):\n    if self.query.extra_order_by:\n        ordering = self.query.extra_order_by\n    elif not self.query.default_ordering:\n        ordering = self.query.order_by\n    elif self.query.order_by:\n        ordering = self.query.order_by\n    elif self.query.get_meta().ordering:\n        ordering = self.query.get_meta().ordering\n        self._meta_ordering = ordering\n    else:\n        ordering = []\n    if self.query.standard_ordering:\n        asc, desc = ORDER_DIR['ASC']\n    else:\n        asc, desc = ORDER_DIR['DESC']\n    order_by = []\n    for field in ordering:\n        if hasattr(field, 'resolve_expression'):\n            if isinstance(field, Value):\n                field = Cast(field, field.output_field)\n            if not isinstance(field, OrderBy):\n                field = field.asc()\n            if not self.query.standard_ordering:\n                field = field.copy()\n                field.reverse_ordering()\n            order_by.append((field, False))\n            continue\n        if field == '?':\n            order_by.append((OrderBy(Random()), False))\n            continue\n        col, order = get_order_dir(field, asc)\n        descending = order == 'DESC'\n        if col in self.query.annotation_select:\n            order_by.append((OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending), True))\n            continue\n        if col in self.query.annotations:\n            expr = self.query.annotations[col]\n            if isinstance(expr, Value):\n                expr = Cast(expr, expr.output_field)\n            order_by.append((OrderBy(expr, descending=descending), False))\n            continue\n        if '.' in field:\n            table, col = col.split('.', 1)\n            order_by.append((OrderBy(RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []), descending=descending), False))\n            continue\n        if not self.query.extra or col not in self.query.extra:\n            order_by.extend(self.find_ordering_name(field, self.query.get_meta(), default_order=asc))\n        elif col not in self.query.extra_select:\n            order_by.append((OrderBy(RawSQL(*self.query.extra[col]), descending=descending), False))\n        else:\n            order_by.append((OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending), True))\n    result = []\n    seen = set()\n    for expr, is_ref in order_by:\n        resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n        if self.query.combinator:\n            src = resolved.get_source_expressions()[0]\n            for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n                if is_ref and col_alias == src.refs:\n                    src = src.source\n                elif col_alias:\n                    continue\n                if src == sel_expr:\n                    resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n                    break\n            else:\n                if col_alias:\n                    raise DatabaseError('ORDER BY term does not match any column in the result set.')\n                self.query.add_select_col(src)\n                resolved.set_source_expressions([RawSQL('%d' % len(self.query.select), ())])\n        sql, params = self.compile(resolved)\n        without_ordering = self.ordering_parts.search(sql).group(1)\n        params_hash = make_hashable(params)\n        if (without_ordering, params_hash) in seen:\n            continue\n        seen.add((without_ordering, params_hash))\n        result.append((resolved, (sql, params, is_ref)))\n    return result",
    ".django.db.models.sql.where.py@@WhereNode.split_having": "def split_having(self, negated=False):\n    if not self.contains_aggregate:\n        return (self, None)\n    in_negated = negated ^ self.negated\n    may_need_split = in_negated and self.connector == AND or (not in_negated and self.connector == OR)\n    if may_need_split and self.contains_aggregate:\n        return (None, self)\n    where_parts = []\n    having_parts = []\n    for c in self.children:\n        if hasattr(c, 'split_having'):\n            where_part, having_part = c.split_having(in_negated)\n            if where_part is not None:\n                where_parts.append(where_part)\n            if having_part is not None:\n                having_parts.append(having_part)\n        elif c.contains_aggregate:\n            having_parts.append(c)\n        else:\n            where_parts.append(c)\n    having_node = self.__class__(having_parts, self.connector, self.negated) if having_parts else None\n    where_node = self.__class__(where_parts, self.connector, self.negated) if where_parts else None\n    return (where_node, having_node)",
    ".django.db.models.sql.where.py@@WhereNode.contains_aggregate": "def contains_aggregate(self):\n    return self._contains_aggregate(self)",
    ".django.db.models.sql.where.py@@WhereNode._contains_aggregate": "def _contains_aggregate(cls, obj):\n    if isinstance(obj, tree.Node):\n        return any((cls._contains_aggregate(c) for c in obj.children))\n    return obj.contains_aggregate",
    ".django.db.models.lookups.py@@Lookup.contains_aggregate": "def contains_aggregate(self):\n    return self.lhs.contains_aggregate or getattr(self.rhs, 'contains_aggregate', False)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_extra_select": "def get_extra_select(self, order_by, select):\n    extra_select = []\n    if self.query.distinct and (not self.query.distinct_fields):\n        select_sql = [t[1] for t in select]\n        for expr, (sql, params, is_ref) in order_by:\n            without_ordering = self.ordering_parts.search(sql).group(1)\n            if not is_ref and (without_ordering, params) not in select_sql:\n                extra_select.append((expr, (without_ordering, params), None))\n    return extra_select",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_group_by": "def get_group_by(self, select, order_by):\n    if self.query.group_by is None:\n        return []\n    expressions = []\n    if self.query.group_by is not True:\n        for expr in self.query.group_by:\n            if not hasattr(expr, 'as_sql'):\n                expressions.append(self.query.resolve_ref(expr))\n            else:\n                expressions.append(expr)\n    ref_sources = {expr.source for expr in expressions if isinstance(expr, Ref)}\n    for expr, _, _ in select:\n        if expr in ref_sources:\n            continue\n        cols = expr.get_group_by_cols()\n        for col in cols:\n            expressions.append(col)\n    for expr, (sql, params, is_ref) in order_by:\n        if not is_ref:\n            expressions.extend(expr.get_group_by_cols())\n    having_group_by = self.having.get_group_by_cols() if self.having else ()\n    for expr in having_group_by:\n        expressions.append(expr)\n    result = []\n    seen = set()\n    expressions = self.collapse_group_by(expressions, having_group_by)\n    for expr in expressions:\n        sql, params = self.compile(expr)\n        params_hash = make_hashable(params)\n        if (sql, params_hash) not in seen:\n            result.append((sql, params))\n            seen.add((sql, params_hash))\n    return result",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_distinct": "def get_distinct(self):\n    result = []\n    params = []\n    opts = self.query.get_meta()\n    for name in self.query.distinct_fields:\n        parts = name.split(LOOKUP_SEP)\n        _, targets, alias, joins, path, _, transform_function = self._setup_joins(parts, opts, None)\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        for target in targets:\n            if name in self.query.annotation_select:\n                result.append(name)\n            else:\n                r, p = self.compile(transform_function(target, alias))\n                result.append(r)\n                params.append(p)\n    return (result, params)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_from_clause": "def get_from_clause(self):\n    result = []\n    params = []\n    for alias in tuple(self.query.alias_map):\n        if not self.query.alias_refcount[alias]:\n            continue\n        try:\n            from_clause = self.query.alias_map[alias]\n        except KeyError:\n            continue\n        clause_sql, clause_params = self.compile(from_clause)\n        result.append(clause_sql)\n        params.extend(clause_params)\n    for t in self.query.extra_tables:\n        alias, _ = self.query.table_alias(t)\n        if alias not in self.query.alias_map or self.query.alias_refcount[alias] == 1:\n            result.append(', %s' % self.quote_name_unless_alias(alias))\n    return (result, params)",
    ".django.db.models.sql.datastructures.py@@BaseTable.as_sql": "def as_sql(self, compiler, connection):\n    alias_str = '' if self.table_alias == self.table_name else ' %s' % self.table_alias\n    base_sql = compiler.quote_name_unless_alias(self.table_name)\n    return (base_sql + alias_str, [])",
    ".django.db.models.fields.related_lookups.py@@RelatedLookupMixin.as_sql": "def as_sql(self, compiler, connection):\n    if isinstance(self.lhs, MultiColSource):\n        assert self.rhs_is_direct_value()\n        self.rhs = get_normalized_value(self.rhs, self.lhs)\n        from django.db.models.sql.where import WhereNode, AND\n        root_constraint = WhereNode()\n        for target, source, val in zip(self.lhs.targets, self.lhs.sources, self.rhs):\n            lookup_class = target.get_lookup(self.lookup_name)\n            root_constraint.add(lookup_class(target.get_col(self.lhs.alias, source), val), AND)\n        return root_constraint.as_sql(compiler, connection)\n    return super().as_sql(compiler, connection)",
    ".django.db.models.lookups.py@@Exact.as_sql": "def as_sql(self, compiler, connection):\n    if isinstance(self.rhs, bool) and getattr(self.lhs, 'conditional', False) and connection.ops.conditional_expression_supported_in_where_clause(self.lhs):\n        lhs_sql, params = self.process_lhs(compiler, connection)\n        template = '%s' if self.rhs else 'NOT %s'\n        return (template % lhs_sql, params)\n    return super().as_sql(compiler, connection)",
    ".django.db.models.lookups.py@@Exact.process_rhs": "def process_rhs(self, compiler, connection):\n    from django.db.models.sql.query import Query\n    if isinstance(self.rhs, Query):\n        if self.rhs.has_limit_one():\n            if not self.rhs.has_select_fields:\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n        else:\n            raise ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.')\n    return super().process_rhs(compiler, connection)",
    ".django.db.models.lookups.py@@Lookup.process_rhs": "def process_rhs(self, compiler, connection):\n    value = self.rhs\n    if self.bilateral_transforms:\n        if self.rhs_is_direct_value():\n            value = Value(value, output_field=self.lhs.output_field)\n        value = self.apply_bilateral_transforms(value)\n        value = value.resolve_expression(compiler.query)\n    if hasattr(value, 'as_sql'):\n        return compiler.compile(value)\n    else:\n        return self.get_db_prep_lookup(value, connection)",
    ".django.db.models.lookups.py@@BuiltinLookup.get_rhs_op": "def get_rhs_op(self, connection, rhs):\n    return connection.operators[self.lookup_name] % rhs",
    ".django.db.models.sql.query.py@@Query.reset_refcounts": "def reset_refcounts(self, to_counts):\n    for alias, cur_refcount in self.alias_refcount.copy().items():\n        unref_amount = cur_refcount - to_counts.get(alias, 0)\n        self.unref_alias(alias, unref_amount)",
    ".django.db.models.sql.compiler.py@@cursor_iter": "def cursor_iter(cursor, sentinel, col_count, itersize):\n    try:\n        for rows in iter(lambda: cursor.fetchmany(itersize), sentinel):\n            yield (rows if col_count is None else [r[:col_count] for r in rows])\n    finally:\n        cursor.close()",
    ".django.db.utils.py@@DatabaseErrorWrapper.__call__": "def __call__(self, func):\n\n    def inner(*args, **kwargs):\n        with self:\n            return func(*args, **kwargs)\n    return inner",
    ".django.db.utils.py@@DatabaseErrorWrapper.inner": "def inner(*args, **kwargs):\n    with self:\n        return func(*args, **kwargs)",
    ".django.db.models.query.py@@get_related_populators": "def get_related_populators(klass_info, select, db):\n    iterators = []\n    related_klass_infos = klass_info.get('related_klass_infos', [])\n    for rel_klass_info in related_klass_infos:\n        rel_cls = RelatedPopulator(rel_klass_info, select, db)\n        iterators.append(rel_cls)\n    return iterators",
    ".django.db.models.sql.compiler.py@@SQLCompiler.results_iter": "def results_iter(self, results=None, tuple_expected=False, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n    if results is None:\n        results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)\n    fields = [s[0] for s in self.select[0:self.col_count]]\n    converters = self.get_converters(fields)\n    rows = chain.from_iterable(results)\n    if converters:\n        rows = self.apply_converters(rows, converters)\n        if tuple_expected:\n            rows = map(tuple, rows)\n    return rows",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_converters": "def get_converters(self, expressions):\n    converters = {}\n    for i, expression in enumerate(expressions):\n        if expression:\n            backend_converters = self.connection.ops.get_db_converters(expression)\n            field_converters = expression.get_db_converters(self.connection)\n            if backend_converters or field_converters:\n                converters[i] = (backend_converters + field_converters, expression)\n    return converters",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.get_db_converters": "def get_db_converters(self, expression):\n    converters = super().get_db_converters(expression)\n    internal_type = expression.output_field.get_internal_type()\n    if internal_type == 'DateTimeField':\n        converters.append(self.convert_datetimefield_value)\n    elif internal_type == 'DateField':\n        converters.append(self.convert_datefield_value)\n    elif internal_type == 'TimeField':\n        converters.append(self.convert_timefield_value)\n    elif internal_type == 'DecimalField':\n        converters.append(self.get_decimalfield_converter(expression))\n    elif internal_type == 'UUIDField':\n        converters.append(self.convert_uuidfield_value)\n    elif internal_type in ('NullBooleanField', 'BooleanField'):\n        converters.append(self.convert_booleanfield_value)\n    return converters",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.get_db_converters": "def get_db_converters(self, expression):\n    return []",
    ".django.db.models.expressions.py@@Col.get_db_converters": "def get_db_converters(self, connection):\n    if self.target == self.output_field:\n        return self.output_field.get_db_converters(connection)\n    return self.output_field.get_db_converters(connection) + self.target.get_db_converters(connection)",
    ".django.db.models.fields.__init__.py@@Field.get_db_converters": "def get_db_converters(self, connection):\n    if hasattr(self, 'from_db_value'):\n        return [self.from_db_value]\n    return []",
    ".django.db.models.fields.__init__.py@@CharField.get_internal_type": "def get_internal_type(self):\n    return 'CharField'",
    ".django.db.models.fields.related.py@@ForeignKey.get_db_converters": "def get_db_converters(self, connection):\n    converters = super().get_db_converters(connection)\n    if connection.features.interprets_empty_strings_as_nulls:\n        converters += [self.convert_empty_strings]\n    return converters",
    ".django.db.models.base.py@@Model.from_db": "def from_db(cls, db, field_names, values):\n    if len(values) != len(cls._meta.concrete_fields):\n        values_iter = iter(values)\n        values = [next(values_iter) if f.attname in field_names else DEFERRED for f in cls._meta.concrete_fields]\n    new = cls(*values)\n    new._state.adding = False\n    new._state.db = db\n    return new",
    ".django.db.models.base.py@@Model.__init__": "def __init__(self, *args, **kwargs):\n    cls = self.__class__\n    opts = self._meta\n    _setattr = setattr\n    _DEFERRED = DEFERRED\n    pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    self._state = ModelState()\n    if len(args) > len(opts.concrete_fields):\n        raise IndexError('Number of args exceeds number of fields')\n    if not kwargs:\n        fields_iter = iter(opts.concrete_fields)\n        for val, field in zip(args, fields_iter):\n            if val is _DEFERRED:\n                continue\n            _setattr(self, field.attname, val)\n    else:\n        fields_iter = iter(opts.fields)\n        for val, field in zip(args, fields_iter):\n            if val is _DEFERRED:\n                continue\n            _setattr(self, field.attname, val)\n            kwargs.pop(field.name, None)\n    for field in fields_iter:\n        is_related_object = False\n        if field.attname not in kwargs and field.column is None:\n            continue\n        if kwargs:\n            if isinstance(field.remote_field, ForeignObjectRel):\n                try:\n                    rel_obj = kwargs.pop(field.name)\n                    is_related_object = True\n                except KeyError:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        val = field.get_default()\n            else:\n                try:\n                    val = kwargs.pop(field.attname)\n                except KeyError:\n                    val = field.get_default()\n        else:\n            val = field.get_default()\n        if is_related_object:\n            if rel_obj is not _DEFERRED:\n                _setattr(self, field.name, rel_obj)\n        elif val is not _DEFERRED:\n            _setattr(self, field.attname, val)\n    if kwargs:\n        property_names = opts._property_names\n        for prop in tuple(kwargs):\n            try:\n                if prop in property_names or opts.get_field(prop):\n                    if kwargs[prop] is not _DEFERRED:\n                        _setattr(self, prop, kwargs[prop])\n                    del kwargs[prop]\n            except (AttributeError, FieldDoesNotExist):\n                pass\n        for kwarg in kwargs:\n            raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\n    super().__init__()\n    post_init.send(sender=cls, instance=self)",
    ".django.db.models.base.py@@ModelStateFieldsCacheDescriptor.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    res = instance.fields_cache = {}\n    return res",
    ".django.db.models.fields.related_descriptors.py@@ForwardManyToOneDescriptor.__set__": "def __set__(self, instance, value):\n    if value is not None and (not isinstance(value, self.field.remote_field.model._meta.concrete_model)):\n        raise ValueError('Cannot assign \"%r\": \"%s.%s\" must be a \"%s\" instance.' % (value, instance._meta.object_name, self.field.name, self.field.remote_field.model._meta.object_name))\n    elif value is not None:\n        if instance._state.db is None:\n            instance._state.db = router.db_for_write(instance.__class__, instance=value)\n        if value._state.db is None:\n            value._state.db = router.db_for_write(value.__class__, instance=instance)\n        if not router.allow_relation(value, instance):\n            raise ValueError('Cannot assign \"%r\": the current database router prevents this relation.' % value)\n    remote_field = self.field.remote_field\n    if value is None:\n        related = self.field.get_cached_value(instance, default=None)\n        if related is not None:\n            remote_field.set_cached_value(related, None)\n        for lh_field, rh_field in self.field.related_fields:\n            setattr(instance, lh_field.attname, None)\n    else:\n        for lh_field, rh_field in self.field.related_fields:\n            setattr(instance, lh_field.attname, getattr(value, rh_field.attname))\n    self.field.set_cached_value(instance, value)\n    if value is not None and (not remote_field.multiple):\n        remote_field.set_cached_value(value, instance)",
    ".django.db.utils.py@@ConnectionRouter.allow_relation": "def allow_relation(self, obj1, obj2, **hints):\n    for router in self.routers:\n        try:\n            method = router.allow_relation\n        except AttributeError:\n            pass\n        else:\n            allow = method(obj1, obj2, **hints)\n            if allow is not None:\n                return allow\n    return obj1._state.db == obj2._state.db",
    ".django.db.models.fields.mixins.py@@FieldCacheMixin.set_cached_value": "def set_cached_value(self, instance, value):\n    instance._state.fields_cache[self.get_cache_name()] = value",
    ".django.db.models.sql.subqueries.py@@UpdateQuery.__init__": "def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self._setup_query()",
    ".django.db.models.sql.subqueries.py@@UpdateQuery._setup_query": "def _setup_query(self):\n    self.values = []\n    self.related_ids = None\n    self.related_updates = {}",
    ".django.db.models.sql.subqueries.py@@UpdateQuery.update_batch": "def update_batch(self, pk_list, values, using):\n    self.add_update_values(values)\n    for offset in range(0, len(pk_list), GET_ITERATOR_CHUNK_SIZE):\n        self.where = self.where_class()\n        self.add_q(Q(pk__in=pk_list[offset:offset + GET_ITERATOR_CHUNK_SIZE]))\n        self.get_compiler(using).execute_sql(NO_RESULTS)",
    ".django.db.models.sql.subqueries.py@@UpdateQuery.add_update_values": "def add_update_values(self, values):\n    values_seq = []\n    for name, val in values.items():\n        field = self.get_meta().get_field(name)\n        direct = not (field.auto_created and (not field.concrete)) or not field.concrete\n        model = field.model._meta.concrete_model\n        if not direct or (field.is_relation and field.many_to_many):\n            raise FieldError('Cannot update model field %r (only non-relations and foreign keys permitted).' % field)\n        if model is not self.get_meta().concrete_model:\n            self.add_related_update(model, field, val)\n            continue\n        values_seq.append((field, model, val))\n    return self.add_update_fields(values_seq)",
    ".django.db.models.sql.subqueries.py@@UpdateQuery.add_update_fields": "def add_update_fields(self, values_seq):\n    for field, model, val in values_seq:\n        if hasattr(val, 'resolve_expression'):\n            val = val.resolve_expression(self, allow_joins=False, for_save=True)\n        self.values.append((field, model, val))",
    ".django.db.models.sql.compiler.py@@SQLUpdateCompiler.execute_sql": "def execute_sql(self, result_type):\n    cursor = super().execute_sql(result_type)\n    try:\n        rows = cursor.rowcount if cursor else 0\n        is_empty = cursor is None\n    finally:\n        if cursor:\n            cursor.close()\n    for query in self.query.get_related_updates():\n        aux_rows = query.get_compiler(self.using).execute_sql(result_type)\n        if is_empty and aux_rows:\n            rows = aux_rows\n            is_empty = False\n    return rows",
    ".django.db.models.sql.compiler.py@@SQLUpdateCompiler.as_sql": "def as_sql(self):\n    self.pre_sql_setup()\n    if not self.query.values:\n        return ('', ())\n    qn = self.quote_name_unless_alias\n    values, update_params = ([], [])\n    for field, model, val in self.query.values:\n        if hasattr(val, 'resolve_expression'):\n            val = val.resolve_expression(self.query, allow_joins=False, for_save=True)\n            if val.contains_aggregate:\n                raise FieldError('Aggregate functions are not allowed in this query (%s=%r).' % (field.name, val))\n            if val.contains_over_clause:\n                raise FieldError('Window expressions are not allowed in this query (%s=%r).' % (field.name, val))\n        elif hasattr(val, 'prepare_database_save'):\n            if field.remote_field:\n                val = field.get_db_prep_save(val.prepare_database_save(field), connection=self.connection)\n            else:\n                raise TypeError('Tried to update field %s with a model instance, %r. Use a value compatible with %s.' % (field, val, field.__class__.__name__))\n        else:\n            val = field.get_db_prep_save(val, connection=self.connection)\n        if hasattr(field, 'get_placeholder'):\n            placeholder = field.get_placeholder(val, self, self.connection)\n        else:\n            placeholder = '%s'\n        name = field.column\n        if hasattr(val, 'as_sql'):\n            sql, params = self.compile(val)\n            values.append('%s = %s' % (qn(name), placeholder % sql))\n            update_params.extend(params)\n        elif val is not None:\n            values.append('%s = %s' % (qn(name), placeholder))\n            update_params.append(val)\n        else:\n            values.append('%s = NULL' % qn(name))\n    table = self.query.base_table\n    result = ['UPDATE %s SET' % qn(table), ', '.join(values)]\n    where, params = self.compile(self.query.where)\n    if where:\n        result.append('WHERE %s' % where)\n    return (' '.join(result), tuple(update_params + params))",
    ".django.db.models.sql.compiler.py@@SQLUpdateCompiler.pre_sql_setup": "def pre_sql_setup(self):\n    refcounts_before = self.query.alias_refcount.copy()\n    self.query.get_initial_alias()\n    count = self.query.count_active_tables()\n    if not self.query.related_updates and count == 1:\n        return\n    query = self.query.chain(klass=Query)\n    query.select_related = False\n    query.clear_ordering(True)\n    query.extra = {}\n    query.select = []\n    query.add_fields([query.get_meta().pk.name])\n    super().pre_sql_setup()\n    must_pre_select = count > 1 and (not self.connection.features.update_can_self_select)\n    self.query.where = self.query.where_class()\n    if self.query.related_updates or must_pre_select:\n        idents = []\n        for rows in query.get_compiler(self.using).execute_sql(MULTI):\n            idents.extend((r[0] for r in rows))\n        self.query.add_filter(('pk__in', idents))\n        self.query.related_ids = idents\n    else:\n        self.query.add_filter(('pk__in', query))\n    self.query.reset_refcounts(refcounts_before)",
    ".django.db.models.sql.query.py@@Query.count_active_tables": "def count_active_tables(self):\n    return len([1 for count in self.alias_refcount.values() if count])",
    ".django.db.models.fields.related.py@@ForeignKey.get_db_prep_save": "def get_db_prep_save(self, value, connection):\n    if value is None or (value == '' and (not self.target_field.empty_strings_allowed or connection.features.interprets_empty_strings_as_nulls)):\n        return None\n    else:\n        return self.target_field.get_db_prep_save(value, connection=connection)",
    ".django.db.models.sql.subqueries.py@@UpdateQuery.get_related_updates": "def get_related_updates(self):\n    if not self.related_updates:\n        return []\n    result = []\n    for model, values in self.related_updates.items():\n        query = UpdateQuery(model)\n        query.values = values\n        if self.related_ids is not None:\n            query.add_filter(('pk__in', self.related_ids))\n        result.append(query)\n    return result",
    ".django.db.models.deletion.py@@get_candidate_relations_to_delete": "def get_candidate_relations_to_delete(opts):\n    return (f for f in opts.get_fields(include_hidden=True) if f.auto_created and (not f.concrete) and (f.one_to_one or f.one_to_many))",
    ".django.db.models.options.py@@Options.get_fields": "def get_fields(self, include_parents=True, include_hidden=False):\n    if include_parents is False:\n        include_parents = PROXY_PARENTS\n    return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)",
    ".django.db.models.manager.py@@ManagerDescriptor.__get__": "def __get__(self, instance, cls=None):\n    if instance is not None:\n        raise AttributeError(\"Manager isn't accessible via %s instances\" % cls.__name__)\n    if cls._meta.abstract:\n        raise AttributeError(\"Manager isn't available; %s is abstract\" % (cls._meta.object_name,))\n    if cls._meta.swapped:\n        raise AttributeError(\"Manager isn't available; '%s.%s' has been swapped for '%s'\" % (cls._meta.app_label, cls._meta.object_name, cls._meta.swapped))\n    return cls._meta.managers_map[self.manager.name]",
    ".django.db.models.options.py@@Options.swapped": "def swapped(self):\n    if self.swappable:\n        swapped_for = getattr(settings, self.swappable, None)\n        if swapped_for:\n            try:\n                swapped_label, swapped_object = swapped_for.split('.')\n            except ValueError:\n                return swapped_for\n            if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:\n                return swapped_for\n    return None",
    ".django.db.models.manager.py@@BaseManager.manager_method": "def manager_method(self, *args, **kwargs):\n    return getattr(self.get_queryset(), name)(*args, **kwargs)",
    ".django.db.models.query.py@@QuerySet.__bool__": "def __bool__(self):\n    self._fetch_all()\n    return bool(self._result_cache)",
    ".django.db.models.fields.__init__.py@@BooleanField.get_internal_type": "def get_internal_type(self):\n    return 'BooleanField'",
    ".django.db.models.sql.compiler.py@@SQLCompiler.apply_converters": "def apply_converters(self, rows, converters):\n    connection = self.connection\n    converters = list(converters.items())\n    for row in map(list, rows):\n        for pos, (convs, expression) in converters:\n            value = row[pos]\n            for converter in convs:\n                value = converter(value, expression, connection)\n            row[pos] = value\n        yield row",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.convert_booleanfield_value": "def convert_booleanfield_value(self, value, expression, connection):\n    return bool(value) if value in (1, 0) else value",
    ".django.db.models.fields.__init__.py@@Field.get_db_prep_value": "def get_db_prep_value(self, value, connection, prepared=False):\n    if not prepared:\n        value = self.get_prep_value(value)\n    return value",
    ".django.db.models.sql.query.py@@Query.clear_select_clause": "def clear_select_clause(self):\n    self.select = ()\n    self.default_cols = False\n    self.select_related = False\n    self.set_extra_mask(())\n    self.set_annotation_mask(())",
    ".django.db.models.sql.query.py@@Query.set_extra_mask": "def set_extra_mask(self, names):\n    if names is None:\n        self.extra_select_mask = None\n    else:\n        self.extra_select_mask = set(names)\n    self._extra_select_cache = None",
    ".django.db.models.sql.query.py@@Query.set_annotation_mask": "def set_annotation_mask(self, names):\n    if names is None:\n        self.annotation_select_mask = None\n    else:\n        self.annotation_select_mask = set(names)\n    self._annotation_select_cache = None",
    ".django.db.models.sql.query.py@@Query.resolve_expression": "def resolve_expression(self, query, *args, **kwargs):\n    clone = self.clone()\n    clone.bump_prefix(query)\n    clone.subquery = True\n    if self.low_mark == 0 and self.high_mark is None and (not self.distinct_fields) and (not self.select_for_update):\n        clone.clear_ordering(True)\n    clone.where.resolve_expression(query, *args, **kwargs)\n    for key, value in clone.annotations.items():\n        resolved = value.resolve_expression(query, *args, **kwargs)\n        if hasattr(resolved, 'external_aliases'):\n            resolved.external_aliases.update(clone.external_aliases)\n        clone.annotations[key] = resolved\n    for alias, table in query.alias_map.items():\n        clone.external_aliases[alias] = isinstance(table, Join) and table.join_field.related_model._meta.db_table != alias or (isinstance(table, BaseTable) and table.table_name != table.table_alias)\n    return clone",
    ".django.db.models.sql.query.py@@Query.bump_prefix": "def bump_prefix(self, outer_query):\n\n    def prefix_gen():\n        alphabet = ascii_uppercase\n        prefix = chr(ord(self.alias_prefix) + 1)\n        yield prefix\n        for n in count(1):\n            seq = alphabet[alphabet.index(prefix):] if prefix else alphabet\n            for s in product(seq, repeat=n):\n                yield ''.join(s)\n            prefix = None\n    if self.alias_prefix != outer_query.alias_prefix:\n        return\n    local_recursion_limit = sys.getrecursionlimit() // 16\n    for pos, prefix in enumerate(prefix_gen()):\n        if prefix not in self.subq_aliases:\n            self.alias_prefix = prefix\n            break\n        if pos > local_recursion_limit:\n            raise RecursionError('Maximum recursion depth exceeded: too many subqueries.')\n    self.subq_aliases = self.subq_aliases.union([self.alias_prefix])\n    outer_query.subq_aliases = outer_query.subq_aliases.union(self.subq_aliases)\n    self.change_aliases({alias: '%s%d' % (self.alias_prefix, pos) for pos, alias in enumerate(self.alias_map)})",
    ".django.db.models.sql.query.py@@Query.prefix_gen": "def prefix_gen():\n    alphabet = ascii_uppercase\n    prefix = chr(ord(self.alias_prefix) + 1)\n    yield prefix\n    for n in count(1):\n        seq = alphabet[alphabet.index(prefix):] if prefix else alphabet\n        for s in product(seq, repeat=n):\n            yield ''.join(s)\n        prefix = None",
    ".django.db.models.sql.query.py@@Query.change_aliases": "def change_aliases(self, change_map):\n    assert set(change_map).isdisjoint(change_map.values())\n    self.where.relabel_aliases(change_map)\n    if isinstance(self.group_by, tuple):\n        self.group_by = tuple([col.relabeled_clone(change_map) for col in self.group_by])\n    self.select = tuple([col.relabeled_clone(change_map) for col in self.select])\n    self.annotations = self.annotations and {key: col.relabeled_clone(change_map) for key, col in self.annotations.items()}\n    for old_alias, new_alias in change_map.items():\n        if old_alias not in self.alias_map:\n            continue\n        alias_data = self.alias_map[old_alias].relabeled_clone(change_map)\n        self.alias_map[new_alias] = alias_data\n        self.alias_refcount[new_alias] = self.alias_refcount[old_alias]\n        del self.alias_refcount[old_alias]\n        del self.alias_map[old_alias]\n        table_aliases = self.table_map[alias_data.table_name]\n        for pos, alias in enumerate(table_aliases):\n            if alias == old_alias:\n                table_aliases[pos] = new_alias\n                break\n    self.external_aliases = {change_map.get(alias, alias): aliased or alias in change_map for alias, aliased in self.external_aliases.items()}",
    ".django.db.models.sql.where.py@@WhereNode.relabel_aliases": "def relabel_aliases(self, change_map):\n    for pos, child in enumerate(self.children):\n        if hasattr(child, 'relabel_aliases'):\n            child.relabel_aliases(change_map)\n        elif hasattr(child, 'relabeled_clone'):\n            self.children[pos] = child.relabeled_clone(change_map)",
    ".django.db.models.lookups.py@@Lookup.relabeled_clone": "def relabeled_clone(self, relabels):\n    new = copy(self)\n    new.lhs = new.lhs.relabeled_clone(relabels)\n    if hasattr(new.rhs, 'relabeled_clone'):\n        new.rhs = new.rhs.relabeled_clone(relabels)\n    return new",
    ".django.db.models.expressions.py@@Col.relabeled_clone": "def relabeled_clone(self, relabels):\n    if self.alias is None:\n        return self\n    return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)",
    ".django.db.models.sql.datastructures.py@@BaseTable.relabeled_clone": "def relabeled_clone(self, change_map):\n    return self.__class__(self.table_name, change_map.get(self.table_alias, self.table_alias))",
    ".django.db.models.sql.query.py@@Query.clear_ordering": "def clear_ordering(self, force_empty):\n    self.order_by = ()\n    self.extra_order_by = ()\n    if force_empty:\n        self.default_ordering = False",
    ".django.db.models.sql.where.py@@WhereNode.resolve_expression": "def resolve_expression(self, *args, **kwargs):\n    clone = self.clone()\n    clone._resolve_node(clone, *args, **kwargs)\n    clone.resolved = True\n    return clone",
    ".django.db.models.sql.where.py@@WhereNode._resolve_node": "def _resolve_node(cls, node, query, *args, **kwargs):\n    if hasattr(node, 'children'):\n        for child in node.children:\n            cls._resolve_node(child, query, *args, **kwargs)\n    if hasattr(node, 'lhs'):\n        node.lhs = cls._resolve_leaf(node.lhs, query, *args, **kwargs)\n    if hasattr(node, 'rhs'):\n        node.rhs = cls._resolve_leaf(node.rhs, query, *args, **kwargs)",
    ".django.db.models.sql.where.py@@WhereNode._resolve_leaf": "def _resolve_leaf(expr, query, *args, **kwargs):\n    if hasattr(expr, 'resolve_expression'):\n        expr = expr.resolve_expression(query, *args, **kwargs)\n    return expr",
    ".django.db.models.sql.query.py@@Query.has_select_fields": "def has_select_fields(self):\n    return bool(self.select or self.annotation_select_mask or self.extra_select_mask)",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueIterableMixin.process_rhs": "def process_rhs(self, compiler, connection):\n    if self.rhs_is_direct_value():\n        return self.batch_process_rhs(compiler, connection)\n    else:\n        return super().process_rhs(compiler, connection)",
    ".django.db.models.sql.query.py@@Query.as_sql": "def as_sql(self, compiler, connection):\n    sql, params = self.get_compiler(connection=connection).as_sql()\n    if self.subquery:\n        sql = '(%s)' % sql\n    return (sql, params)",
    ".django.db.models.expressions.py@@BaseExpression.contains_aggregate": "def contains_aggregate(self):\n    return any((expr and expr.contains_aggregate for expr in self.get_source_expressions()))",
    ".django.db.models.sql.datastructures.py@@Join.as_sql": "def as_sql(self, compiler, connection):\n    join_conditions = []\n    params = []\n    qn = compiler.quote_name_unless_alias\n    qn2 = connection.ops.quote_name\n    for lhs_col, rhs_col in self.join_cols:\n        join_conditions.append('%s.%s = %s.%s' % (qn(self.parent_alias), qn2(lhs_col), qn(self.table_alias), qn2(rhs_col)))\n    extra_cond = self.join_field.get_extra_restriction(compiler.query.where_class, self.table_alias, self.parent_alias)\n    if extra_cond:\n        extra_sql, extra_params = compiler.compile(extra_cond)\n        join_conditions.append('(%s)' % extra_sql)\n        params.extend(extra_params)\n    if self.filtered_relation:\n        extra_sql, extra_params = compiler.compile(self.filtered_relation)\n        if extra_sql:\n            join_conditions.append('(%s)' % extra_sql)\n            params.extend(extra_params)\n    if not join_conditions:\n        declared_field = getattr(self.join_field, 'field', self.join_field)\n        raise ValueError('Join generated an empty ON clause. %s did not yield either joining columns or extra restrictions.' % declared_field.__class__)\n    on_clause_sql = ' AND '.join(join_conditions)\n    alias_str = '' if self.table_alias == self.table_name else ' %s' % self.table_alias\n    sql = '%s %s%s ON (%s)' % (self.join_type, qn(self.table_name), alias_str, on_clause_sql)\n    return (sql, params)",
    ".django.db.models.fields.related.py@@ForeignObject.get_extra_restriction": "def get_extra_restriction(self, where_class, alias, related_alias):\n    return None",
    ".django.db.models.fields.__init__.py@@TextField.get_internal_type": "def get_internal_type(self):\n    return 'TextField'",
    ".django.db.models.options.py@@Options._forward_fields_map": "def _forward_fields_map(self):\n    res = {}\n    fields = self._get_fields(reverse=False)\n    for field in fields:\n        res[field.name] = field\n        try:\n            res[field.attname] = field\n        except AttributeError:\n            pass\n    return res",
    ".django.db.transaction.py@@mark_for_rollback_on_error": "def mark_for_rollback_on_error(using=None):\n    try:\n        yield\n    except Exception:\n        connection = get_connection(using)\n        if connection.in_atomic_block:\n            connection.needs_rollback = True\n        raise",
    ".django.db.models.query.py@@QuerySet.update": "def update(self, **kwargs):\n    self._not_support_combined_queries('update')\n    assert not self.query.is_sliced, 'Cannot update a query once a slice has been taken.'\n    self._for_write = True\n    query = self.query.chain(sql.UpdateQuery)\n    query.add_update_values(kwargs)\n    query.annotations = {}\n    with transaction.mark_for_rollback_on_error(using=self.db):\n        rows = query.get_compiler(self.db).execute_sql(CURSOR)\n    self._result_cache = None\n    return rows",
    ".django.db.models.base.py@@Model.prepare_database_save": "def prepare_database_save(self, field):\n    if self.pk is None:\n        raise ValueError('Unsaved model instance %r cannot be used in an ORM query.' % self)\n    return getattr(self, field.remote_field.get_related_field().attname)",
    ".django.db.models.fields.reverse_related.py@@ManyToOneRel.get_related_field": "def get_related_field(self):\n    field = self.model._meta.get_field(self.field_name)\n    if not field.concrete:\n        raise exceptions.FieldDoesNotExist(\"No related field named '%s'\" % self.field_name)\n    return field",
    ".django.db.models.fields.__init__.py@@Field.get_db_prep_save": "def get_db_prep_save(self, value, connection):\n    return self.get_db_prep_value(value, connection=connection, prepared=False)",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.validate_autopk_value": "def validate_autopk_value(self, value):\n    return value"
}