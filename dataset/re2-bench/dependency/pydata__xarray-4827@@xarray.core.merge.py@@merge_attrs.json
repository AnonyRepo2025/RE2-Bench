{
    ".xarray.core.utils.py@@compat_dict_union": "def compat_dict_union(first_dict: Mapping[K, V], second_dict: Mapping[K, V], compat: Callable[[V, V], bool]=equivalent) -> MutableMapping[K, V]:\n    new_dict = dict(first_dict)\n    update_safety_check(first_dict, second_dict, compat)\n    new_dict.update(second_dict)\n    return new_dict",
    ".xarray.core.utils.py@@update_safety_check": "def update_safety_check(first_dict: Mapping[K, V], second_dict: Mapping[K, V], compat: Callable[[V, V], bool]=equivalent) -> None:\n    for k, v in second_dict.items():\n        if k in first_dict and (not compat(v, first_dict[k])):\n            raise ValueError('unsafe to merge dictionaries without overriding values; conflicting key %r' % k)",
    ".xarray.core.utils.py@@equivalent": "def equivalent(first: T, second: T) -> bool:\n    from . import duck_array_ops\n    if isinstance(first, np.ndarray) or isinstance(second, np.ndarray):\n        return duck_array_ops.array_equiv(first, second)\n    elif isinstance(first, list) or isinstance(second, list):\n        return list_equiv(first, second)\n    else:\n        return first is second or first == second or (pd.isnull(first) and pd.isnull(second))",
    ".xarray.core.utils.py@@dict_equiv": "def dict_equiv(first: Mapping[K, V], second: Mapping[K, V], compat: Callable[[V, V], bool]=equivalent) -> bool:\n    for k in first:\n        if k not in second or not compat(first[k], second[k]):\n            return False\n    for k in second:\n        if k not in first:\n            return False\n    return True",
    ".xarray.core.duck_array_ops.py@@array_equiv": "def array_equiv(arr1, arr2):\n    arr1 = asarray(arr1)\n    arr2 = asarray(arr2)\n    lazy_equiv = lazy_array_equiv(arr1, arr2)\n    if lazy_equiv is None:\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore', \"In the future, 'NAT == x'\")\n            flag_array = (arr1 == arr2) | isnull(arr1) & isnull(arr2)\n            return bool(flag_array.all())\n    else:\n        return lazy_equiv",
    ".xarray.core.duck_array_ops.py@@asarray": "def asarray(data, xp=np):\n    return data if is_duck_array(data) else xp.asarray(data)",
    ".xarray.core.utils.py@@is_duck_array": "def is_duck_array(value: Any) -> bool:\n    if isinstance(value, np.ndarray):\n        return True\n    return hasattr(value, 'ndim') and hasattr(value, 'shape') and hasattr(value, 'dtype') and hasattr(value, '__array_function__') and hasattr(value, '__array_ufunc__')",
    ".xarray.core.duck_array_ops.py@@lazy_array_equiv": "def lazy_array_equiv(arr1, arr2):\n    if arr1 is arr2:\n        return True\n    arr1 = asarray(arr1)\n    arr2 = asarray(arr2)\n    if arr1.shape != arr2.shape:\n        return False\n    if dask_array and is_duck_dask_array(arr1) and is_duck_dask_array(arr2):\n        if tokenize(arr1) == tokenize(arr2):\n            return True\n        else:\n            return None\n    return None",
    ".xarray.core.pycompat.py@@is_duck_dask_array": "def is_duck_dask_array(x):\n    return is_duck_array(x) and is_dask_collection(x)",
    ".xarray.core.duck_array_ops.py@@isnull": "def isnull(data):\n    data = asarray(data)\n    scalar_type = data.dtype.type\n    if issubclass(scalar_type, (np.datetime64, np.timedelta64)):\n        return isnat(data)\n    elif issubclass(scalar_type, np.inexact):\n        return isnan(data)\n    elif issubclass(scalar_type, (np.bool_, np.integer, np.character, np.void)):\n        return zeros_like(data, dtype=bool)\n    elif isinstance(data, (np.ndarray, dask_array_type)):\n        return pandas_isnull(data)\n    else:\n        return data != data",
    ".xarray.core.duck_array_ops.py@@f": "def f(values, axis=None, skipna=None, **kwargs):\n    if kwargs.pop('out', None) is not None:\n        raise TypeError(f'`out` is not valid for {name}')\n    values = asarray(values)\n    if coerce_strings and values.dtype.kind in 'SU':\n        values = values.astype(object)\n    func = None\n    if skipna or (skipna is None and values.dtype.kind in 'cfO'):\n        nanname = 'nan' + name\n        func = getattr(nanops, nanname)\n    else:\n        if name in ['sum', 'prod']:\n            kwargs.pop('min_count', None)\n        func = _dask_or_eager_func(name, dask_module=dask_module)\n    try:\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore', 'All-NaN slice encountered')\n            return func(values, axis=axis, **kwargs)\n    except AttributeError:\n        if not is_duck_dask_array(values):\n            raise\n        try:\n            return func(values, axis=axis, dtype=values.dtype, **kwargs)\n        except (AttributeError, TypeError):\n            raise NotImplementedError(f'{name} is not yet implemented on dask arrays')"
}