{
    ".django.db.models.options.py@@Options.swapped": "def swapped(self):\n    if self.swappable:\n        swapped_for = getattr(settings, self.swappable, None)\n        if swapped_for:\n            try:\n                swapped_label, swapped_object = swapped_for.split('.')\n            except ValueError:\n                return swapped_for\n            if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:\n                return swapped_for\n    return None",
    ".django.db.models.options.py@@Options.label_lower": "def label_lower(self):\n    return '%s.%s' % (self.app_label, self.model_name)",
    ".django.contrib.auth.management.__init__.py@@get_system_username": "def get_system_username():\n    try:\n        result = getpass.getuser()\n    except (ImportError, KeyError):\n        return ''\n    return result",
    ".django.db.models.options.py@@Options.get_field": "def get_field(self, field_name):\n    try:\n        return self._forward_fields_map[field_name]\n    except KeyError:\n        if not self.apps.models_ready:\n            raise FieldDoesNotExist(\"%s has no field named '%s'. The app cache isn't ready yet, so if this is an auto-created related field, it won't be available yet.\" % (self.object_name, field_name))\n    try:\n        return self.fields_map[field_name]\n    except KeyError:\n        raise FieldDoesNotExist(\"%s has no field named '%s'\" % (self.object_name, field_name))",
    ".django.db.models.fields.__init__.py@@Field.run_validators": "def run_validators(self, value):\n    if value in self.empty_values:\n        return\n    errors = []\n    for v in self.validators:\n        try:\n            v(value)\n        except exceptions.ValidationError as e:\n            if hasattr(e, 'code') and e.code in self.error_messages:\n                e.message = self.error_messages[e.code]\n            errors.extend(e.error_list)\n    if errors:\n        raise exceptions.ValidationError(errors)",
    ".django.core.validators.py@@RegexValidator.__call__": "def __call__(self, value):\n    regex_matches = self.regex.search(str(value))\n    invalid_input = regex_matches if self.inverse_match else not regex_matches\n    if invalid_input:\n        raise ValidationError(self.message, code=self.code, params={'value': value})",
    ".django.utils.functional.py@@inner": "def inner(self, *args):\n    if self._wrapped is empty:\n        self._setup()\n    return func(self._wrapped, *args)",
    ".django.core.validators.py@@BaseValidator.__call__": "def __call__(self, value):\n    cleaned = self.clean(value)\n    limit_value = self.limit_value() if callable(self.limit_value) else self.limit_value\n    params = {'limit_value': limit_value, 'show_value': cleaned, 'value': value}\n    if self.compare(cleaned, limit_value):\n        raise ValidationError(self.message, code=self.code, params=params)",
    ".django.core.validators.py@@MaxLengthValidator.clean": "def clean(self, x):\n    return len(x)",
    ".django.core.validators.py@@MaxLengthValidator.compare": "def compare(self, a, b):\n    return a > b",
    ".django.db.models.base.py@@ModelBase._default_manager": "def _default_manager(cls):\n    return cls._meta.default_manager",
    ".django.db.models.manager.py@@BaseManager.db_manager": "def db_manager(self, using=None, hints=None):\n    obj = copy.copy(self)\n    obj._db = using or self._db\n    obj._hints = hints or self._hints\n    return obj",
    ".django.db.models.manager.py@@BaseManager.__new__": "def __new__(cls, *args, **kwargs):\n    obj = super().__new__(cls)\n    obj._constructor_args = (args, kwargs)\n    return obj",
    ".django.db.models.manager.py@@BaseManager.manager_method": "def manager_method(self, *args, **kwargs):\n    return getattr(self.get_queryset(), name)(*args, **kwargs)",
    ".django.db.models.manager.py@@BaseManager.get_queryset": "def get_queryset(self):\n    return self._queryset_class(model=self.model, using=self._db, hints=self._hints)",
    ".django.db.models.query.py@@QuerySet.__init__": "def __init__(self, model=None, query=None, using=None, hints=None):\n    self.model = model\n    self._db = using\n    self._hints = hints or {}\n    self._query = query or sql.Query(self.model)\n    self._result_cache = None\n    self._sticky_filter = False\n    self._for_write = False\n    self._prefetch_related_lookups = ()\n    self._prefetch_done = False\n    self._known_related_objects = {}\n    self._iterable_class = ModelIterable\n    self._fields = None\n    self._defer_next_filter = False\n    self._deferred_filter = None",
    ".django.utils.deconstruct.py@@__new__": "def __new__(cls, *args, **kwargs):\n    obj = super(klass, cls).__new__(cls)\n    obj._constructor_args = (args, kwargs)\n    return obj",
    ".django.db.models.sql.query.py@@Query.__init__": "def __init__(self, model, where=WhereNode, alias_cols=True):\n    self.model = model\n    self.alias_refcount = {}\n    self.alias_map = {}\n    self.alias_cols = alias_cols\n    self.external_aliases = {}\n    self.table_map = {}\n    self.default_cols = True\n    self.default_ordering = True\n    self.standard_ordering = True\n    self.used_aliases = set()\n    self.filter_is_sticky = False\n    self.subquery = False\n    self.select = ()\n    self.where = where()\n    self.where_class = where\n    self.group_by = None\n    self.order_by = ()\n    self.low_mark, self.high_mark = (0, None)\n    self.distinct = False\n    self.distinct_fields = ()\n    self.select_for_update = False\n    self.select_for_update_nowait = False\n    self.select_for_update_skip_locked = False\n    self.select_for_update_of = ()\n    self.select_for_no_key_update = False\n    self.select_related = False\n    self.max_depth = 5\n    self.values_select = ()\n    self.annotations = {}\n    self.annotation_select_mask = None\n    self._annotation_select_cache = None\n    self.combinator = None\n    self.combinator_all = False\n    self.combined_queries = ()\n    self.extra = {}\n    self.extra_select_mask = None\n    self._extra_select_cache = None\n    self.extra_tables = ()\n    self.extra_order_by = ()\n    self.deferred_loading = (frozenset(), True)\n    self._filtered_relations = {}\n    self.explain_query = False\n    self.explain_format = None\n    self.explain_options = {}",
    ".django.utils.tree.py@@Node.__init__": "def __init__(self, children=None, connector=None, negated=False):\n    self.children = children[:] if children else []\n    self.connector = connector or self.default\n    self.negated = negated",
    ".django.db.models.query.py@@QuerySet.get": "def get(self, *args, **kwargs):\n    clone = self._chain() if self.query.combinator else self.filter(*args, **kwargs)\n    if self.query.can_filter() and (not self.query.distinct_fields):\n        clone = clone.order_by()\n    limit = None\n    if not clone.query.select_for_update or connections[clone.db].features.supports_select_for_update_with_limit:\n        limit = MAX_GET_RESULTS\n        clone.query.set_limits(high=limit)\n    num = len(clone)\n    if num == 1:\n        return clone._result_cache[0]\n    if not num:\n        raise self.model.DoesNotExist('%s matching query does not exist.' % self.model._meta.object_name)\n    raise self.model.MultipleObjectsReturned('get() returned more than one %s -- it returned %s!' % (self.model._meta.object_name, num if not limit or num < limit else 'more than %s' % (limit - 1)))",
    ".django.db.models.query.py@@QuerySet.query": "def query(self):\n    if self._deferred_filter:\n        negate, args, kwargs = self._deferred_filter\n        self._filter_or_exclude_inplace(negate, args, kwargs)\n        self._deferred_filter = None\n    return self._query",
    ".django.db.models.query.py@@QuerySet.filter": "def filter(self, *args, **kwargs):\n    self._not_support_combined_queries('filter')\n    return self._filter_or_exclude(False, args, kwargs)",
    ".django.db.models.query.py@@QuerySet._not_support_combined_queries": "def _not_support_combined_queries(self, operation_name):\n    if self.query.combinator:\n        raise NotSupportedError('Calling QuerySet.%s() after %s() is not supported.' % (operation_name, self.query.combinator))",
    ".django.db.models.query.py@@QuerySet._filter_or_exclude": "def _filter_or_exclude(self, negate, args, kwargs):\n    if args or kwargs:\n        assert not self.query.is_sliced, 'Cannot filter a query once a slice has been taken.'\n    clone = self._chain()\n    if self._defer_next_filter:\n        self._defer_next_filter = False\n        clone._deferred_filter = (negate, args, kwargs)\n    else:\n        clone._filter_or_exclude_inplace(negate, args, kwargs)\n    return clone",
    ".django.db.models.sql.query.py@@Query.is_sliced": "def is_sliced(self):\n    return self.low_mark != 0 or self.high_mark is not None",
    ".django.db.models.query.py@@QuerySet._chain": "def _chain(self, **kwargs):\n    obj = self._clone()\n    if obj._sticky_filter:\n        obj.query.filter_is_sticky = True\n        obj._sticky_filter = False\n    obj.__dict__.update(kwargs)\n    return obj",
    ".django.db.models.query.py@@QuerySet._clone": "def _clone(self):\n    c = self.__class__(model=self.model, query=self.query.chain(), using=self._db, hints=self._hints)\n    c._sticky_filter = self._sticky_filter\n    c._for_write = self._for_write\n    c._prefetch_related_lookups = self._prefetch_related_lookups[:]\n    c._known_related_objects = self._known_related_objects\n    c._iterable_class = self._iterable_class\n    c._fields = self._fields\n    return c",
    ".django.db.models.sql.query.py@@Query.chain": "def chain(self, klass=None):\n    obj = self.clone()\n    if klass and obj.__class__ != klass:\n        obj.__class__ = klass\n    if not obj.filter_is_sticky:\n        obj.used_aliases = set()\n    obj.filter_is_sticky = False\n    if hasattr(obj, '_setup_query'):\n        obj._setup_query()\n    return obj",
    ".django.db.models.sql.query.py@@Query.clone": "def clone(self):\n    obj = Empty()\n    obj.__class__ = self.__class__\n    obj.__dict__ = self.__dict__.copy()\n    obj.alias_refcount = self.alias_refcount.copy()\n    obj.alias_map = self.alias_map.copy()\n    obj.external_aliases = self.external_aliases.copy()\n    obj.table_map = self.table_map.copy()\n    obj.where = self.where.clone()\n    obj.annotations = self.annotations.copy()\n    if self.annotation_select_mask is None:\n        obj.annotation_select_mask = None\n    else:\n        obj.annotation_select_mask = self.annotation_select_mask.copy()\n    obj.combined_queries = tuple((query.clone() for query in self.combined_queries))\n    obj._annotation_select_cache = None\n    obj.extra = self.extra.copy()\n    if self.extra_select_mask is None:\n        obj.extra_select_mask = None\n    else:\n        obj.extra_select_mask = self.extra_select_mask.copy()\n    if self._extra_select_cache is None:\n        obj._extra_select_cache = None\n    else:\n        obj._extra_select_cache = self._extra_select_cache.copy()\n    if self.select_related is not False:\n        obj.select_related = copy.deepcopy(obj.select_related)\n    if 'subq_aliases' in self.__dict__:\n        obj.subq_aliases = self.subq_aliases.copy()\n    obj.used_aliases = self.used_aliases.copy()\n    obj._filtered_relations = self._filtered_relations.copy()\n    try:\n        del obj.base_table\n    except AttributeError:\n        pass\n    return obj",
    ".django.db.models.sql.where.py@@WhereNode.clone": "def clone(self):\n    clone = self.__class__._new_instance(children=[], connector=self.connector, negated=self.negated)\n    for child in self.children:\n        if hasattr(child, 'clone'):\n            clone.children.append(child.clone())\n        else:\n            clone.children.append(child)\n    return clone",
    ".django.utils.tree.py@@Node._new_instance": "def _new_instance(cls, children=None, connector=None, negated=False):\n    obj = Node(children, connector, negated)\n    obj.__class__ = cls\n    return obj",
    ".django.db.models.query.py@@QuerySet._filter_or_exclude_inplace": "def _filter_or_exclude_inplace(self, negate, args, kwargs):\n    if negate:\n        self._query.add_q(~Q(*args, **kwargs))\n    else:\n        self._query.add_q(Q(*args, **kwargs))",
    ".django.db.models.query_utils.py@@Q.__init__": "def __init__(self, *args, _connector=None, _negated=False, **kwargs):\n    super().__init__(children=[*args, *sorted(kwargs.items())], connector=_connector, negated=_negated)",
    ".django.db.models.sql.query.py@@Query.add_q": "def add_q(self, q_object):\n    existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}\n    clause, _ = self._add_q(q_object, self.used_aliases)\n    if clause:\n        self.where.add(clause, AND)\n    self.demote_joins(existing_inner)",
    ".django.db.models.sql.query.py@@Query._add_q": "def _add_q(self, q_object, used_aliases, branch_negated=False, current_negated=False, allow_joins=True, split_subq=True, check_filterable=True):\n    connector = q_object.connector\n    current_negated = current_negated ^ q_object.negated\n    branch_negated = branch_negated or q_object.negated\n    target_clause = self.where_class(connector=connector, negated=q_object.negated)\n    joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)\n    for child in q_object.children:\n        child_clause, needed_inner = self.build_filter(child, can_reuse=used_aliases, branch_negated=branch_negated, current_negated=current_negated, allow_joins=allow_joins, split_subq=split_subq, check_filterable=check_filterable)\n        joinpromoter.add_votes(needed_inner)\n        if child_clause:\n            target_clause.add(child_clause, connector)\n    needed_inner = joinpromoter.update_join_types(self)\n    return (target_clause, needed_inner)",
    ".django.db.models.sql.query.py@@JoinPromoter.__init__": "def __init__(self, connector, num_children, negated):\n    self.connector = connector\n    self.negated = negated\n    if self.negated:\n        if connector == AND:\n            self.effective_connector = OR\n        else:\n            self.effective_connector = AND\n    else:\n        self.effective_connector = self.connector\n    self.num_children = num_children\n    self.votes = Counter()",
    ".django.db.models.sql.query.py@@Query.build_filter": "def build_filter(self, filter_expr, branch_negated=False, current_negated=False, can_reuse=None, allow_joins=True, split_subq=True, reuse_with_filtered_relation=False, check_filterable=True):\n    if isinstance(filter_expr, dict):\n        raise FieldError('Cannot parse keyword query as dict')\n    if isinstance(filter_expr, Q):\n        return self._add_q(filter_expr, branch_negated=branch_negated, current_negated=current_negated, used_aliases=can_reuse, allow_joins=allow_joins, split_subq=split_subq, check_filterable=check_filterable)\n    if hasattr(filter_expr, 'resolve_expression'):\n        if not getattr(filter_expr, 'conditional', False):\n            raise TypeError('Cannot filter against a non-conditional expression.')\n        condition = self.build_lookup(['exact'], filter_expr.resolve_expression(self, allow_joins=allow_joins), True)\n        clause = self.where_class()\n        clause.add(condition, AND)\n        return (clause, [])\n    arg, value = filter_expr\n    if not arg:\n        raise FieldError('Cannot parse keyword query %r' % arg)\n    lookups, parts, reffed_expression = self.solve_lookup_type(arg)\n    if check_filterable:\n        self.check_filterable(reffed_expression)\n    if not allow_joins and len(parts) > 1:\n        raise FieldError('Joined field references are not permitted in this query')\n    pre_joins = self.alias_refcount.copy()\n    value = self.resolve_lookup_value(value, can_reuse, allow_joins)\n    used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}\n    if check_filterable:\n        self.check_filterable(value)\n    clause = self.where_class()\n    if reffed_expression:\n        condition = self.build_lookup(lookups, reffed_expression, value)\n        clause.add(condition, AND)\n        return (clause, [])\n    opts = self.get_meta()\n    alias = self.get_initial_alias()\n    allow_many = not branch_negated or not split_subq\n    try:\n        join_info = self.setup_joins(parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many, reuse_with_filtered_relation=reuse_with_filtered_relation)\n        if isinstance(value, Iterator):\n            value = list(value)\n        self.check_related_objects(join_info.final_field, value, join_info.opts)\n        self._lookup_joins = join_info.joins\n    except MultiJoin as e:\n        return self.split_exclude(filter_expr, can_reuse, e.names_with_path)\n    used_joins.update(join_info.joins)\n    targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)\n    if can_reuse is not None:\n        can_reuse.update(join_list)\n    if join_info.final_field.is_relation:\n        num_lookups = len(lookups)\n        if num_lookups > 1:\n            raise FieldError('Related Field got invalid lookup: {}'.format(lookups[0]))\n        if len(targets) == 1:\n            col = self._get_col(targets[0], join_info.final_field, alias)\n        else:\n            col = MultiColSource(alias, targets, join_info.targets, join_info.final_field)\n    else:\n        col = self._get_col(targets[0], join_info.final_field, alias)\n    condition = self.build_lookup(lookups, col, value)\n    lookup_type = condition.lookup_name\n    clause.add(condition, AND)\n    require_outer = lookup_type == 'isnull' and condition.rhs is True and (not current_negated)\n    if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and (condition.rhs is not None):\n        require_outer = True\n        if lookup_type != 'isnull':\n            if self.is_nullable(targets[0]) or self.alias_map[join_list[-1]].join_type == LOUTER:\n                lookup_class = targets[0].get_lookup('isnull')\n                col = self._get_col(targets[0], join_info.targets[0], alias)\n                clause.add(lookup_class(col, False), AND)\n            if isinstance(value, Col) and self.is_nullable(value.target):\n                lookup_class = value.target.get_lookup('isnull')\n                clause.add(lookup_class(value, False), AND)\n    return (clause, used_joins if not require_outer else ())",
    ".django.db.models.sql.query.py@@Query.solve_lookup_type": "def solve_lookup_type(self, lookup):\n    lookup_splitted = lookup.split(LOOKUP_SEP)\n    if self.annotations:\n        expression, expression_lookups = refs_expression(lookup_splitted, self.annotations)\n        if expression:\n            return (expression_lookups, (), expression)\n    _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())\n    field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]\n    if len(lookup_parts) > 1 and (not field_parts):\n        raise FieldError('Invalid lookup \"%s\" for model %s\".' % (lookup, self.get_meta().model.__name__))\n    return (lookup_parts, field_parts, False)",
    ".django.db.models.sql.query.py@@Query.get_meta": "def get_meta(self):\n    return self.model._meta",
    ".django.db.models.sql.query.py@@Query.names_to_path": "def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):\n    path, names_with_path = ([], [])\n    for pos, name in enumerate(names):\n        cur_names_with_path = (name, [])\n        if name == 'pk':\n            name = opts.pk.name\n        field = None\n        filtered_relation = None\n        try:\n            field = opts.get_field(name)\n        except FieldDoesNotExist:\n            if name in self.annotation_select:\n                field = self.annotation_select[name].output_field\n            elif name in self._filtered_relations and pos == 0:\n                filtered_relation = self._filtered_relations[name]\n                if LOOKUP_SEP in filtered_relation.relation_name:\n                    parts = filtered_relation.relation_name.split(LOOKUP_SEP)\n                    filtered_relation_path, field, _, _ = self.names_to_path(parts, opts, allow_many, fail_on_missing)\n                    path.extend(filtered_relation_path[:-1])\n                else:\n                    field = opts.get_field(filtered_relation.relation_name)\n        if field is not None:\n            if field.is_relation and (not field.related_model):\n                raise FieldError('Field %r does not generate an automatic reverse relation and therefore cannot be used for reverse querying. If it is a GenericForeignKey, consider adding a GenericRelation.' % name)\n            try:\n                model = field.model._meta.concrete_model\n            except AttributeError:\n                model = None\n        else:\n            pos -= 1\n            if pos == -1 or fail_on_missing:\n                available = sorted([*get_field_names_from_opts(opts), *self.annotation_select, *self._filtered_relations])\n                raise FieldError(\"Cannot resolve keyword '%s' into field. Choices are: %s\" % (name, ', '.join(available)))\n            break\n        if model is not opts.model:\n            path_to_parent = opts.get_path_to_parent(model)\n            if path_to_parent:\n                path.extend(path_to_parent)\n                cur_names_with_path[1].extend(path_to_parent)\n                opts = path_to_parent[-1].to_opts\n        if hasattr(field, 'get_path_info'):\n            pathinfos = field.get_path_info(filtered_relation)\n            if not allow_many:\n                for inner_pos, p in enumerate(pathinfos):\n                    if p.m2m:\n                        cur_names_with_path[1].extend(pathinfos[0:inner_pos + 1])\n                        names_with_path.append(cur_names_with_path)\n                        raise MultiJoin(pos + 1, names_with_path)\n            last = pathinfos[-1]\n            path.extend(pathinfos)\n            final_field = last.join_field\n            opts = last.to_opts\n            targets = last.target_fields\n            cur_names_with_path[1].extend(pathinfos)\n            names_with_path.append(cur_names_with_path)\n        else:\n            final_field = field\n            targets = (field,)\n            if fail_on_missing and pos + 1 != len(names):\n                raise FieldError(\"Cannot resolve keyword %r into field. Join on '%s' not permitted.\" % (names[pos + 1], name))\n            break\n    return (path, final_field, targets, names[pos + 1:])",
    ".django.db.models.sql.query.py@@Query.check_filterable": "def check_filterable(self, expression):\n    if hasattr(expression, 'resolve_expression') and (not getattr(expression, 'filterable', True)):\n        raise NotSupportedError(expression.__class__.__name__ + ' is disallowed in the filter clause.')\n    if hasattr(expression, 'get_source_expressions'):\n        for expr in expression.get_source_expressions():\n            self.check_filterable(expr)",
    ".django.db.models.sql.query.py@@Query.resolve_lookup_value": "def resolve_lookup_value(self, value, can_reuse, allow_joins):\n    if hasattr(value, 'resolve_expression'):\n        value = value.resolve_expression(self, reuse=can_reuse, allow_joins=allow_joins)\n    elif isinstance(value, (list, tuple)):\n        return type(value)((self.resolve_lookup_value(sub_value, can_reuse, allow_joins) for sub_value in value))\n    return value",
    ".django.db.models.sql.query.py@@Query.get_initial_alias": "def get_initial_alias(self):\n    if self.alias_map:\n        alias = self.base_table\n        self.ref_alias(alias)\n    else:\n        alias = self.join(BaseTable(self.get_meta().db_table, None))\n    return alias",
    ".django.db.models.sql.datastructures.py@@BaseTable.__init__": "def __init__(self, table_name, alias):\n    self.table_name = table_name\n    self.table_alias = alias",
    ".django.db.models.sql.query.py@@Query.join": "def join(self, join, reuse=None, reuse_with_filtered_relation=False):\n    if reuse_with_filtered_relation and reuse:\n        reuse_aliases = [a for a, j in self.alias_map.items() if a in reuse and j.equals(join, with_filtered_relation=False)]\n    else:\n        reuse_aliases = [a for a, j in self.alias_map.items() if (reuse is None or a in reuse) and j == join]\n    if reuse_aliases:\n        if join.table_alias in reuse_aliases:\n            reuse_alias = join.table_alias\n        else:\n            reuse_alias = reuse_aliases[-1]\n        self.ref_alias(reuse_alias)\n        return reuse_alias\n    alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)\n    if join.join_type:\n        if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:\n            join_type = LOUTER\n        else:\n            join_type = INNER\n        join.join_type = join_type\n    join.table_alias = alias\n    self.alias_map[alias] = join\n    return alias",
    ".django.db.models.sql.query.py@@Query.table_alias": "def table_alias(self, table_name, create=False, filtered_relation=None):\n    alias_list = self.table_map.get(table_name)\n    if not create and alias_list:\n        alias = alias_list[0]\n        self.alias_refcount[alias] += 1\n        return (alias, False)\n    if alias_list:\n        alias = '%s%d' % (self.alias_prefix, len(self.alias_map) + 1)\n        alias_list.append(alias)\n    else:\n        alias = filtered_relation.alias if filtered_relation is not None else table_name\n        self.table_map[table_name] = [alias]\n    self.alias_refcount[alias] = 1\n    return (alias, True)",
    ".django.db.models.sql.query.py@@Query.setup_joins": "def setup_joins(self, names, opts, alias, can_reuse=None, allow_many=True, reuse_with_filtered_relation=False):\n    joins = [alias]\n\n    def final_transformer(field, alias):\n        return field.get_col(alias)\n    last_field_exception = None\n    for pivot in range(len(names), 0, -1):\n        try:\n            path, final_field, targets, rest = self.names_to_path(names[:pivot], opts, allow_many, fail_on_missing=True)\n        except FieldError as exc:\n            if pivot == 1:\n                raise\n            else:\n                last_field_exception = exc\n        else:\n            transforms = names[pivot:]\n            break\n    for name in transforms:\n\n        def transform(field, alias, *, name, previous):\n            try:\n                wrapped = previous(field, alias)\n                return self.try_transform(wrapped, name)\n            except FieldError:\n                if isinstance(final_field, Field) and last_field_exception:\n                    raise last_field_exception\n                else:\n                    raise\n        final_transformer = functools.partial(transform, name=name, previous=final_transformer)\n    for join in path:\n        if join.filtered_relation:\n            filtered_relation = join.filtered_relation.clone()\n            table_alias = filtered_relation.alias\n        else:\n            filtered_relation = None\n            table_alias = None\n        opts = join.to_opts\n        if join.direct:\n            nullable = self.is_nullable(join.join_field)\n        else:\n            nullable = True\n        connection = Join(opts.db_table, alias, table_alias, INNER, join.join_field, nullable, filtered_relation=filtered_relation)\n        reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None\n        alias = self.join(connection, reuse=reuse, reuse_with_filtered_relation=reuse_with_filtered_relation)\n        joins.append(alias)\n        if filtered_relation:\n            filtered_relation.path = joins[:]\n    return JoinInfo(final_field, targets, opts, joins, path, final_transformer)",
    ".django.db.models.sql.query.py@@Query.check_related_objects": "def check_related_objects(self, field, value, opts):\n    if field.is_relation:\n        if isinstance(value, Query) and (not value.has_select_fields) and (not check_rel_lookup_compatibility(value.model, opts, field)):\n            raise ValueError('Cannot use QuerySet for \"%s\": Use a QuerySet for \"%s\".' % (value.model._meta.object_name, opts.object_name))\n        elif hasattr(value, '_meta'):\n            self.check_query_object_type(value, opts, field)\n        elif hasattr(value, '__iter__'):\n            for v in value:\n                self.check_query_object_type(v, opts, field)",
    ".django.db.models.sql.query.py@@Query.trim_joins": "def trim_joins(self, targets, joins, path):\n    joins = joins[:]\n    for pos, info in enumerate(reversed(path)):\n        if len(joins) == 1 or not info.direct:\n            break\n        if info.filtered_relation:\n            break\n        join_targets = {t.column for t in info.join_field.foreign_related_fields}\n        cur_targets = {t.column for t in targets}\n        if not cur_targets.issubset(join_targets):\n            break\n        targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}\n        targets = tuple((targets_dict[t.column] for t in targets))\n        self.unref_alias(joins.pop())\n    return (targets, joins[-1], joins)",
    ".django.db.models.sql.query.py@@Query._get_col": "def _get_col(self, target, field, alias):\n    if not self.alias_cols:\n        alias = None\n    return target.get_col(alias, field)",
    ".django.db.models.fields.__init__.py@@Field.get_col": "def get_col(self, alias, output_field=None):\n    if output_field is None:\n        output_field = self\n    if alias != self.model._meta.db_table or output_field != self:\n        from django.db.models.expressions import Col\n        return Col(alias, self, output_field)\n    else:\n        return self.cached_col",
    ".django.db.models.fields.__init__.py@@Field.__eq__": "def __eq__(self, other):\n    if isinstance(other, Field):\n        return self.creation_counter == other.creation_counter\n    return NotImplemented",
    ".django.db.models.sql.query.py@@Query.build_lookup": "def build_lookup(self, lookups, lhs, rhs):\n    *transforms, lookup_name = lookups or ['exact']\n    for name in transforms:\n        lhs = self.try_transform(lhs, name)\n    lookup_class = lhs.get_lookup(lookup_name)\n    if not lookup_class:\n        if lhs.field.is_relation:\n            raise FieldError('Related Field got invalid lookup: {}'.format(lookup_name))\n        lhs = self.try_transform(lhs, lookup_name)\n        lookup_name = 'exact'\n        lookup_class = lhs.get_lookup(lookup_name)\n        if not lookup_class:\n            return\n    lookup = lookup_class(lhs, rhs)\n    if lookup.rhs is None and (not lookup.can_use_none_as_rhs):\n        if lookup_name not in ('exact', 'iexact'):\n            raise ValueError('Cannot use None as a query value')\n        return lhs.get_lookup('isnull')(lhs, True)\n    if connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and lookup_name == 'exact' and (lookup.rhs == ''):\n        return lhs.get_lookup('isnull')(lhs, True)\n    return lookup",
    ".django.db.models.expressions.py@@BaseExpression.get_lookup": "def get_lookup(self, lookup):\n    return self.output_field.get_lookup(lookup)",
    ".django.db.models.query_utils.py@@RegisterLookupMixin.get_lookup": "def get_lookup(self, lookup_name):\n    from django.db.models.lookups import Lookup\n    found = self._get_lookup(lookup_name)\n    if found is None and hasattr(self, 'output_field'):\n        return self.output_field.get_lookup(lookup_name)\n    if found is not None and (not issubclass(found, Lookup)):\n        return None\n    return found",
    ".django.db.models.query_utils.py@@RegisterLookupMixin._get_lookup": "def _get_lookup(cls, lookup_name):\n    return cls.get_lookups().get(lookup_name, None)",
    ".django.db.models.lookups.py@@Lookup.__init__": "def __init__(self, lhs, rhs):\n    self.lhs, self.rhs = (lhs, rhs)\n    self.rhs = self.get_prep_lookup()\n    if hasattr(self.lhs, 'get_bilateral_transforms'):\n        bilateral_transforms = self.lhs.get_bilateral_transforms()\n    else:\n        bilateral_transforms = []\n    if bilateral_transforms:\n        from django.db.models.sql.query import Query\n        if isinstance(rhs, Query):\n            raise NotImplementedError('Bilateral transformations on nested querysets are not implemented.')\n    self.bilateral_transforms = bilateral_transforms",
    ".django.db.models.lookups.py@@Lookup.get_prep_lookup": "def get_prep_lookup(self):\n    if hasattr(self.rhs, 'resolve_expression'):\n        return self.rhs\n    if self.prepare_rhs and hasattr(self.lhs.output_field, 'get_prep_value'):\n        return self.lhs.output_field.get_prep_value(self.rhs)\n    return self.rhs",
    ".django.db.models.fields.__init__.py@@CharField.get_prep_value": "def get_prep_value(self, value):\n    value = super().get_prep_value(value)\n    return self.to_python(value)",
    ".django.db.models.fields.__init__.py@@Field.get_prep_value": "def get_prep_value(self, value):\n    if isinstance(value, Promise):\n        value = value._proxy____cast()\n    return value",
    ".django.db.models.fields.__init__.py@@CharField.to_python": "def to_python(self, value):\n    if isinstance(value, str) or value is None:\n        return value\n    return str(value)",
    ".django.db.utils.py@@ConnectionHandler.__getitem__": "def __getitem__(self, alias):\n    if hasattr(self._connections, alias):\n        return getattr(self._connections, alias)\n    self.ensure_defaults(alias)\n    self.prepare_test_settings(alias)\n    db = self.databases[alias]\n    backend = load_backend(db['ENGINE'])\n    conn = backend.DatabaseWrapper(db, alias)\n    setattr(self._connections, alias, conn)\n    return conn",
    ".django.utils.tree.py@@Node.add": "def add(self, data, conn_type, squash=True):\n    if data in self.children:\n        return data\n    if not squash:\n        self.children.append(data)\n        return data\n    if self.connector == conn_type:\n        if isinstance(data, Node) and (not data.negated) and (data.connector == conn_type or len(data) == 1):\n            self.children.extend(data.children)\n            return self\n        else:\n            self.children.append(data)\n            return data\n    else:\n        obj = self._new_instance(self.children, self.connector, self.negated)\n        self.connector = conn_type\n        self.children = [obj, data]\n        return data",
    ".django.db.models.sql.query.py@@JoinPromoter.add_votes": "def add_votes(self, votes):\n    self.votes.update(votes)",
    ".django.utils.tree.py@@Node.__bool__": "def __bool__(self):\n    return bool(self.children)",
    ".django.db.models.sql.query.py@@JoinPromoter.update_join_types": "def update_join_types(self, query):\n    to_promote = set()\n    to_demote = set()\n    for table, votes in self.votes.items():\n        if self.effective_connector == 'OR' and votes < self.num_children:\n            to_promote.add(table)\n        if self.effective_connector == 'AND' or (self.effective_connector == 'OR' and votes == self.num_children):\n            to_demote.add(table)\n    query.promote_joins(to_promote)\n    query.demote_joins(to_demote)\n    return to_demote",
    ".django.db.models.sql.query.py@@Query.promote_joins": "def promote_joins(self, aliases):\n    aliases = list(aliases)\n    while aliases:\n        alias = aliases.pop(0)\n        if self.alias_map[alias].join_type is None:\n            continue\n        assert self.alias_map[alias].join_type is not None\n        parent_alias = self.alias_map[alias].parent_alias\n        parent_louter = parent_alias and self.alias_map[parent_alias].join_type == LOUTER\n        already_louter = self.alias_map[alias].join_type == LOUTER\n        if (self.alias_map[alias].nullable or parent_louter) and (not already_louter):\n            self.alias_map[alias] = self.alias_map[alias].promote()\n            aliases.extend((join for join in self.alias_map if self.alias_map[join].parent_alias == alias and join not in aliases))",
    ".django.db.models.sql.query.py@@Query.demote_joins": "def demote_joins(self, aliases):\n    aliases = list(aliases)\n    while aliases:\n        alias = aliases.pop(0)\n        if self.alias_map[alias].join_type == LOUTER:\n            self.alias_map[alias] = self.alias_map[alias].demote()\n            parent_alias = self.alias_map[alias].parent_alias\n            if self.alias_map[parent_alias].join_type == INNER:\n                aliases.append(parent_alias)",
    ".django.db.models.sql.query.py@@Query.can_filter": "def can_filter(self):\n    return not self.is_sliced",
    ".django.db.models.query.py@@QuerySet.order_by": "def order_by(self, *field_names):\n    assert not self.query.is_sliced, 'Cannot reorder a query once a slice has been taken.'\n    obj = self._chain()\n    obj.query.clear_ordering(force_empty=False)\n    obj.query.add_ordering(*field_names)\n    return obj",
    ".django.db.models.sql.query.py@@Query.clear_ordering": "def clear_ordering(self, force_empty):\n    self.order_by = ()\n    self.extra_order_by = ()\n    if force_empty:\n        self.default_ordering = False",
    ".django.db.models.sql.query.py@@Query.add_ordering": "def add_ordering(self, *ordering):\n    errors = []\n    for item in ordering:\n        if isinstance(item, str):\n            if '.' in item:\n                warnings.warn('Passing column raw column aliases to order_by() is deprecated. Wrap %r in a RawSQL expression before passing it to order_by().' % item, category=RemovedInDjango40Warning, stacklevel=3)\n                continue\n            if item == '?':\n                continue\n            if item.startswith('-'):\n                item = item[1:]\n            if item in self.annotations:\n                continue\n            if self.extra and item in self.extra:\n                continue\n            self.names_to_path(item.split(LOOKUP_SEP), self.model._meta)\n        elif not hasattr(item, 'resolve_expression'):\n            errors.append(item)\n        if getattr(item, 'contains_aggregate', False):\n            raise FieldError('Using an aggregate in order_by() without also including it in annotate() is not allowed: %s' % item)\n    if errors:\n        raise FieldError('Invalid order_by arguments: %s' % errors)\n    if ordering:\n        self.order_by += ordering\n    else:\n        self.default_ordering = False",
    ".django.db.models.sql.query.py@@Query.set_limits": "def set_limits(self, low=None, high=None):\n    if high is not None:\n        if self.high_mark is not None:\n            self.high_mark = min(self.high_mark, self.low_mark + high)\n        else:\n            self.high_mark = self.low_mark + high\n    if low is not None:\n        if self.high_mark is not None:\n            self.low_mark = min(self.high_mark, self.low_mark + low)\n        else:\n            self.low_mark = self.low_mark + low\n    if self.low_mark == self.high_mark:\n        self.set_empty()",
    ".django.db.models.query.py@@QuerySet.__len__": "def __len__(self):\n    self._fetch_all()\n    return len(self._result_cache)",
    ".django.db.models.query.py@@QuerySet._fetch_all": "def _fetch_all(self):\n    if self._result_cache is None:\n        self._result_cache = list(self._iterable_class(self))\n    if self._prefetch_related_lookups and (not self._prefetch_done):\n        self._prefetch_related_objects()",
    ".django.db.models.query.py@@BaseIterable.__init__": "def __init__(self, queryset, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n    self.queryset = queryset\n    self.chunked_fetch = chunked_fetch\n    self.chunk_size = chunk_size",
    ".django.db.models.query.py@@ModelIterable.__iter__": "def __iter__(self):\n    queryset = self.queryset\n    db = queryset.db\n    compiler = queryset.query.get_compiler(using=db)\n    results = compiler.execute_sql(chunked_fetch=self.chunked_fetch, chunk_size=self.chunk_size)\n    select, klass_info, annotation_col_map = (compiler.select, compiler.klass_info, compiler.annotation_col_map)\n    model_cls = klass_info['model']\n    select_fields = klass_info['select_fields']\n    model_fields_start, model_fields_end = (select_fields[0], select_fields[-1] + 1)\n    init_list = [f[0].target.attname for f in select[model_fields_start:model_fields_end]]\n    related_populators = get_related_populators(klass_info, select, db)\n    known_related_objects = [(field, related_objs, operator.attrgetter(*[field.attname if from_field == 'self' else queryset.model._meta.get_field(from_field).attname for from_field in field.from_fields])) for field, related_objs in queryset._known_related_objects.items()]\n    for row in compiler.results_iter(results):\n        obj = model_cls.from_db(db, init_list, row[model_fields_start:model_fields_end])\n        for rel_populator in related_populators:\n            rel_populator.populate(row, obj)\n        if annotation_col_map:\n            for attr_name, col_pos in annotation_col_map.items():\n                setattr(obj, attr_name, row[col_pos])\n        for field, rel_objs, rel_getter in known_related_objects:\n            if field.is_cached(obj):\n                continue\n            rel_obj_id = rel_getter(obj)\n            try:\n                rel_obj = rel_objs[rel_obj_id]\n            except KeyError:\n                pass\n            else:\n                setattr(obj, field.name, rel_obj)\n        yield obj",
    ".django.db.models.query.py@@QuerySet.db": "def db(self):\n    if self._for_write:\n        return self._db or router.db_for_write(self.model, **self._hints)\n    return self._db or router.db_for_read(self.model, **self._hints)",
    ".django.db.models.sql.query.py@@Query.get_compiler": "def get_compiler(self, using=None, connection=None):\n    if using is None and connection is None:\n        raise ValueError('Need either using or connection')\n    if using:\n        connection = connections[using]\n    return connection.ops.compiler(self.compiler)(self, connection, using)",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.compiler": "def compiler(self, compiler_name):\n    if self._cache is None:\n        self._cache = import_module(self.compiler_module)\n    return getattr(self._cache, compiler_name)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.__init__": "def __init__(self, query, connection, using):\n    self.query = query\n    self.connection = connection\n    self.using = using\n    self.quote_cache = {'*': '*'}\n    self.select = None\n    self.annotation_col_map = None\n    self.klass_info = None\n    self._meta_ordering = None",
    ".django.db.models.sql.compiler.py@@SQLCompiler.execute_sql": "def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n    result_type = result_type or NO_RESULTS\n    try:\n        sql, params = self.as_sql()\n        if not sql:\n            raise EmptyResultSet\n    except EmptyResultSet:\n        if result_type == MULTI:\n            return iter([])\n        else:\n            return\n    if chunked_fetch:\n        cursor = self.connection.chunked_cursor()\n    else:\n        cursor = self.connection.cursor()\n    try:\n        cursor.execute(sql, params)\n    except Exception:\n        cursor.close()\n        raise\n    if result_type == CURSOR:\n        return cursor\n    if result_type == SINGLE:\n        try:\n            val = cursor.fetchone()\n            if val:\n                return val[0:self.col_count]\n            return val\n        finally:\n            cursor.close()\n    if result_type == NO_RESULTS:\n        cursor.close()\n        return\n    result = cursor_iter(cursor, self.connection.features.empty_fetchmany_value, self.col_count if self.has_extra_select else None, chunk_size)\n    if not chunked_fetch or not self.connection.features.can_use_chunked_reads:\n        try:\n            return list(result)\n        finally:\n            cursor.close()\n    return result",
    ".django.db.models.sql.compiler.py@@SQLCompiler.as_sql": "def as_sql(self, with_limits=True, with_col_aliases=False):\n    refcounts_before = self.query.alias_refcount.copy()\n    try:\n        extra_select, order_by, group_by = self.pre_sql_setup()\n        for_update_part = None\n        with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)\n        combinator = self.query.combinator\n        features = self.connection.features\n        if combinator:\n            if not getattr(features, 'supports_select_{}'.format(combinator)):\n                raise NotSupportedError('{} is not supported on this database backend.'.format(combinator))\n            result, params = self.get_combinator_sql(combinator, self.query.combinator_all)\n        else:\n            distinct_fields, distinct_params = self.get_distinct()\n            from_, f_params = self.get_from_clause()\n            where, w_params = self.compile(self.where) if self.where is not None else ('', [])\n            having, h_params = self.compile(self.having) if self.having is not None else ('', [])\n            result = ['SELECT']\n            params = []\n            if self.query.distinct:\n                distinct_result, distinct_params = self.connection.ops.distinct_sql(distinct_fields, distinct_params)\n                result += distinct_result\n                params += distinct_params\n            out_cols = []\n            col_idx = 1\n            for _, (s_sql, s_params), alias in self.select + extra_select:\n                if alias:\n                    s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))\n                elif with_col_aliases:\n                    s_sql = '%s AS %s' % (s_sql, 'Col%d' % col_idx)\n                    col_idx += 1\n                params.extend(s_params)\n                out_cols.append(s_sql)\n            result += [', '.join(out_cols), 'FROM', *from_]\n            params.extend(f_params)\n            if self.query.select_for_update and self.connection.features.has_select_for_update:\n                if self.connection.get_autocommit():\n                    raise TransactionManagementError('select_for_update cannot be used outside of a transaction.')\n                if with_limit_offset and (not self.connection.features.supports_select_for_update_with_limit):\n                    raise NotSupportedError('LIMIT/OFFSET is not supported with select_for_update on this database backend.')\n                nowait = self.query.select_for_update_nowait\n                skip_locked = self.query.select_for_update_skip_locked\n                of = self.query.select_for_update_of\n                no_key = self.query.select_for_no_key_update\n                if nowait and (not self.connection.features.has_select_for_update_nowait):\n                    raise NotSupportedError('NOWAIT is not supported on this database backend.')\n                elif skip_locked and (not self.connection.features.has_select_for_update_skip_locked):\n                    raise NotSupportedError('SKIP LOCKED is not supported on this database backend.')\n                elif of and (not self.connection.features.has_select_for_update_of):\n                    raise NotSupportedError('FOR UPDATE OF is not supported on this database backend.')\n                elif no_key and (not self.connection.features.has_select_for_no_key_update):\n                    raise NotSupportedError('FOR NO KEY UPDATE is not supported on this database backend.')\n                for_update_part = self.connection.ops.for_update_sql(nowait=nowait, skip_locked=skip_locked, of=self.get_select_for_update_of_arguments(), no_key=no_key)\n            if for_update_part and self.connection.features.for_update_after_from:\n                result.append(for_update_part)\n            if where:\n                result.append('WHERE %s' % where)\n                params.extend(w_params)\n            grouping = []\n            for g_sql, g_params in group_by:\n                grouping.append(g_sql)\n                params.extend(g_params)\n            if grouping:\n                if distinct_fields:\n                    raise NotImplementedError('annotate() + distinct(fields) is not implemented.')\n                order_by = order_by or self.connection.ops.force_no_ordering()\n                result.append('GROUP BY %s' % ', '.join(grouping))\n                if self._meta_ordering:\n                    order_by = None\n            if having:\n                result.append('HAVING %s' % having)\n                params.extend(h_params)\n        if self.query.explain_query:\n            result.insert(0, self.connection.ops.explain_query_prefix(self.query.explain_format, **self.query.explain_options))\n        if order_by:\n            ordering = []\n            for _, (o_sql, o_params, _) in order_by:\n                ordering.append(o_sql)\n                params.extend(o_params)\n            result.append('ORDER BY %s' % ', '.join(ordering))\n        if with_limit_offset:\n            result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))\n        if for_update_part and (not self.connection.features.for_update_after_from):\n            result.append(for_update_part)\n        if self.query.subquery and extra_select:\n            sub_selects = []\n            sub_params = []\n            for index, (select, _, alias) in enumerate(self.select, start=1):\n                if not alias and with_col_aliases:\n                    alias = 'col%d' % index\n                if alias:\n                    sub_selects.append('%s.%s' % (self.connection.ops.quote_name('subquery'), self.connection.ops.quote_name(alias)))\n                else:\n                    select_clone = select.relabeled_clone({select.alias: 'subquery'})\n                    subselect, subparams = select_clone.as_sql(self, self.connection)\n                    sub_selects.append(subselect)\n                    sub_params.extend(subparams)\n            return ('SELECT %s FROM (%s) subquery' % (', '.join(sub_selects), ' '.join(result)), tuple(sub_params + params))\n        return (' '.join(result), tuple(params))\n    finally:\n        self.query.reset_refcounts(refcounts_before)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.pre_sql_setup": "def pre_sql_setup(self):\n    self.setup_query()\n    order_by = self.get_order_by()\n    self.where, self.having = self.query.where.split_having()\n    extra_select = self.get_extra_select(order_by, self.select)\n    self.has_extra_select = bool(extra_select)\n    group_by = self.get_group_by(self.select + extra_select, order_by)\n    return (extra_select, order_by, group_by)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.setup_query": "def setup_query(self):\n    if all((self.query.alias_refcount[a] == 0 for a in self.query.alias_map)):\n        self.query.get_initial_alias()\n    self.select, self.klass_info, self.annotation_col_map = self.get_select()\n    self.col_count = len(self.select)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_select": "def get_select(self):\n    select = []\n    klass_info = None\n    annotations = {}\n    select_idx = 0\n    for alias, (sql, params) in self.query.extra_select.items():\n        annotations[alias] = select_idx\n        select.append((RawSQL(sql, params), alias))\n        select_idx += 1\n    assert not (self.query.select and self.query.default_cols)\n    if self.query.default_cols:\n        cols = self.get_default_columns()\n    else:\n        cols = self.query.select\n    if cols:\n        select_list = []\n        for col in cols:\n            select_list.append(select_idx)\n            select.append((col, None))\n            select_idx += 1\n        klass_info = {'model': self.query.model, 'select_fields': select_list}\n    for alias, annotation in self.query.annotation_select.items():\n        annotations[alias] = select_idx\n        select.append((annotation, alias))\n        select_idx += 1\n    if self.query.select_related:\n        related_klass_infos = self.get_related_selections(select)\n        klass_info['related_klass_infos'] = related_klass_infos\n\n        def get_select_from_parent(klass_info):\n            for ki in klass_info['related_klass_infos']:\n                if ki['from_parent']:\n                    ki['select_fields'] = klass_info['select_fields'] + ki['select_fields']\n                get_select_from_parent(ki)\n        get_select_from_parent(klass_info)\n    ret = []\n    for col, alias in select:\n        try:\n            sql, params = self.compile(col)\n        except EmptyResultSet:\n            sql, params = ('0', ())\n        else:\n            sql, params = col.select_format(self, sql, params)\n        ret.append((col, (sql, params), alias))\n    return (ret, klass_info, annotations)",
    ".django.db.models.sql.query.py@@Query.extra_select": "def extra_select(self):\n    if self._extra_select_cache is not None:\n        return self._extra_select_cache\n    if not self.extra:\n        return {}\n    elif self.extra_select_mask is not None:\n        self._extra_select_cache = {k: v for k, v in self.extra.items() if k in self.extra_select_mask}\n        return self._extra_select_cache\n    else:\n        return self.extra",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_default_columns": "def get_default_columns(self, start_alias=None, opts=None, from_parent=None):\n    result = []\n    if opts is None:\n        opts = self.query.get_meta()\n    only_load = self.deferred_to_columns()\n    start_alias = start_alias or self.query.get_initial_alias()\n    seen_models = {None: start_alias}\n    for field in opts.concrete_fields:\n        model = field.model._meta.concrete_model\n        if model == opts.model:\n            model = None\n        if from_parent and model is not None and issubclass(from_parent._meta.concrete_model, model._meta.concrete_model):\n            continue\n        if field.model in only_load and field.attname not in only_load[field.model]:\n            continue\n        alias = self.query.join_parent_model(opts, model, start_alias, seen_models)\n        column = field.get_col(alias)\n        result.append(column)\n    return result",
    ".django.db.models.sql.compiler.py@@SQLCompiler.deferred_to_columns": "def deferred_to_columns(self):\n    columns = {}\n    self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)\n    return columns",
    ".django.db.models.sql.query.py@@Query.deferred_to_data": "def deferred_to_data(self, target, callback):\n    field_names, defer = self.deferred_loading\n    if not field_names:\n        return\n    orig_opts = self.get_meta()\n    seen = {}\n    must_include = {orig_opts.concrete_model: {orig_opts.pk}}\n    for field_name in field_names:\n        parts = field_name.split(LOOKUP_SEP)\n        cur_model = self.model._meta.concrete_model\n        opts = orig_opts\n        for name in parts[:-1]:\n            old_model = cur_model\n            if name in self._filtered_relations:\n                name = self._filtered_relations[name].relation_name\n            source = opts.get_field(name)\n            if is_reverse_o2o(source):\n                cur_model = source.related_model\n            else:\n                cur_model = source.remote_field.model\n            opts = cur_model._meta\n            if not is_reverse_o2o(source):\n                must_include[old_model].add(source)\n            add_to_dict(must_include, cur_model, opts.pk)\n        field = opts.get_field(parts[-1])\n        is_reverse_object = field.auto_created and (not field.concrete)\n        model = field.related_model if is_reverse_object else field.model\n        model = model._meta.concrete_model\n        if model == opts.model:\n            model = cur_model\n        if not is_reverse_o2o(field):\n            add_to_dict(seen, model, field)\n    if defer:\n        workset = {}\n        for model, values in seen.items():\n            for field in model._meta.local_fields:\n                if field not in values:\n                    m = field.model._meta.concrete_model\n                    add_to_dict(workset, m, field)\n        for model, values in must_include.items():\n            if model in workset:\n                workset[model].update(values)\n        for model, values in workset.items():\n            callback(target, model, values)\n    else:\n        for model, values in must_include.items():\n            if model in seen:\n                seen[model].update(values)\n            else:\n                seen[model] = values\n        for model in orig_opts.get_parent_list():\n            seen.setdefault(model, set())\n        for model, values in seen.items():\n            callback(target, model, values)",
    ".django.utils.functional.py@@cached_property.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    res = instance.__dict__[self.name] = self.func(instance)\n    return res",
    ".django.db.models.sql.query.py@@Query.base_table": "def base_table(self):\n    for alias in self.alias_map:\n        return alias",
    ".django.db.models.sql.query.py@@Query.ref_alias": "def ref_alias(self, alias):\n    self.alias_refcount[alias] += 1",
    ".django.db.models.sql.query.py@@Query.join_parent_model": "def join_parent_model(self, opts, model, alias, seen):\n    if model in seen:\n        return seen[model]\n    chain = opts.get_base_chain(model)\n    if not chain:\n        return alias\n    curr_opts = opts\n    for int_model in chain:\n        if int_model in seen:\n            curr_opts = int_model._meta\n            alias = seen[int_model]\n            continue\n        if not curr_opts.parents[int_model]:\n            curr_opts = int_model._meta\n            continue\n        link_field = curr_opts.get_ancestor_link(int_model)\n        join_info = self.setup_joins([link_field.name], curr_opts, alias)\n        curr_opts = int_model._meta\n        alias = seen[int_model] = join_info.joins[-1]\n    return alias or seen[None]",
    ".django.db.models.sql.query.py@@Query.annotation_select": "def annotation_select(self):\n    if self._annotation_select_cache is not None:\n        return self._annotation_select_cache\n    elif not self.annotations:\n        return {}\n    elif self.annotation_select_mask is not None:\n        self._annotation_select_cache = {k: v for k, v in self.annotations.items() if k in self.annotation_select_mask}\n        return self._annotation_select_cache\n    else:\n        return self.annotations",
    ".django.db.models.sql.compiler.py@@SQLCompiler.compile": "def compile(self, node):\n    vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)\n    if vendor_impl:\n        sql, params = vendor_impl(self, self.connection)\n    else:\n        sql, params = node.as_sql(self, self.connection)\n    return (sql, params)",
    ".django.db.models.expressions.py@@Col.as_sql": "def as_sql(self, compiler, connection):\n    alias, column = (self.alias, self.target.column)\n    identifiers = (alias, column) if alias else (column,)\n    sql = '.'.join(map(compiler.quote_name_unless_alias, identifiers))\n    return (sql, [])",
    ".django.db.models.sql.compiler.py@@SQLCompiler.quote_name_unless_alias": "def quote_name_unless_alias(self, name):\n    if name in self.quote_cache:\n        return self.quote_cache[name]\n    if name in self.query.alias_map and name not in self.query.table_map or name in self.query.extra_select or (self.query.external_aliases.get(name) and name not in self.query.table_map):\n        self.quote_cache[name] = name\n        return name\n    r = self.connection.ops.quote_name(name)\n    self.quote_cache[name] = r\n    return r",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.quote_name": "def quote_name(self, name):\n    if name.startswith('\"') and name.endswith('\"'):\n        return name\n    return '\"%s\"' % name",
    ".django.db.models.expressions.py@@BaseExpression.select_format": "def select_format(self, compiler, sql, params):\n    if hasattr(self.output_field, 'select_format'):\n        return self.output_field.select_format(compiler, sql, params)\n    return (sql, params)",
    ".django.db.models.fields.__init__.py@@Field.select_format": "def select_format(self, compiler, sql, params):\n    return (sql, params)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_order_by": "def get_order_by(self):\n    if self.query.extra_order_by:\n        ordering = self.query.extra_order_by\n    elif not self.query.default_ordering:\n        ordering = self.query.order_by\n    elif self.query.order_by:\n        ordering = self.query.order_by\n    elif self.query.get_meta().ordering:\n        ordering = self.query.get_meta().ordering\n        self._meta_ordering = ordering\n    else:\n        ordering = []\n    if self.query.standard_ordering:\n        asc, desc = ORDER_DIR['ASC']\n    else:\n        asc, desc = ORDER_DIR['DESC']\n    order_by = []\n    for field in ordering:\n        if hasattr(field, 'resolve_expression'):\n            if isinstance(field, Value):\n                field = Cast(field, field.output_field)\n            if not isinstance(field, OrderBy):\n                field = field.asc()\n            if not self.query.standard_ordering:\n                field = field.copy()\n                field.reverse_ordering()\n            order_by.append((field, False))\n            continue\n        if field == '?':\n            order_by.append((OrderBy(Random()), False))\n            continue\n        col, order = get_order_dir(field, asc)\n        descending = order == 'DESC'\n        if col in self.query.annotation_select:\n            order_by.append((OrderBy(Ref(col, self.query.annotation_select[col]), descending=descending), True))\n            continue\n        if col in self.query.annotations:\n            expr = self.query.annotations[col]\n            if isinstance(expr, Value):\n                expr = Cast(expr, expr.output_field)\n            order_by.append((OrderBy(expr, descending=descending), False))\n            continue\n        if '.' in field:\n            table, col = col.split('.', 1)\n            order_by.append((OrderBy(RawSQL('%s.%s' % (self.quote_name_unless_alias(table), col), []), descending=descending), False))\n            continue\n        if not self.query.extra or col not in self.query.extra:\n            order_by.extend(self.find_ordering_name(field, self.query.get_meta(), default_order=asc))\n        elif col not in self.query.extra_select:\n            order_by.append((OrderBy(RawSQL(*self.query.extra[col]), descending=descending), False))\n        else:\n            order_by.append((OrderBy(Ref(col, RawSQL(*self.query.extra[col])), descending=descending), True))\n    result = []\n    seen = set()\n    for expr, is_ref in order_by:\n        resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)\n        if self.query.combinator:\n            src = resolved.get_source_expressions()[0]\n            expr_src = expr.get_source_expressions()[0]\n            for idx, (sel_expr, _, col_alias) in enumerate(self.select):\n                if is_ref and col_alias == src.refs:\n                    src = src.source\n                elif col_alias and (not (isinstance(expr_src, F) and col_alias == expr_src.name)):\n                    continue\n                if src == sel_expr:\n                    resolved.set_source_expressions([RawSQL('%d' % (idx + 1), ())])\n                    break\n            else:\n                if col_alias:\n                    raise DatabaseError('ORDER BY term does not match any column in the result set.')\n                self.query.add_select_col(src)\n                resolved.set_source_expressions([RawSQL('%d' % len(self.query.select), ())])\n        sql, params = self.compile(resolved)\n        without_ordering = self.ordering_parts.search(sql)[1]\n        params_hash = make_hashable(params)\n        if (without_ordering, params_hash) in seen:\n            continue\n        seen.add((without_ordering, params_hash))\n        result.append((resolved, (sql, params, is_ref)))\n    return result",
    ".django.db.models.sql.where.py@@WhereNode.split_having": "def split_having(self, negated=False):\n    if not self.contains_aggregate:\n        return (self, None)\n    in_negated = negated ^ self.negated\n    may_need_split = in_negated and self.connector == AND or (not in_negated and self.connector == OR)\n    if may_need_split and self.contains_aggregate:\n        return (None, self)\n    where_parts = []\n    having_parts = []\n    for c in self.children:\n        if hasattr(c, 'split_having'):\n            where_part, having_part = c.split_having(in_negated)\n            if where_part is not None:\n                where_parts.append(where_part)\n            if having_part is not None:\n                having_parts.append(having_part)\n        elif c.contains_aggregate:\n            having_parts.append(c)\n        else:\n            where_parts.append(c)\n    having_node = self.__class__(having_parts, self.connector, self.negated) if having_parts else None\n    where_node = self.__class__(where_parts, self.connector, self.negated) if where_parts else None\n    return (where_node, having_node)",
    ".django.db.models.sql.where.py@@WhereNode.contains_aggregate": "def contains_aggregate(self):\n    return self._contains_aggregate(self)",
    ".django.db.models.sql.where.py@@WhereNode._contains_aggregate": "def _contains_aggregate(cls, obj):\n    if isinstance(obj, tree.Node):\n        return any((cls._contains_aggregate(c) for c in obj.children))\n    return obj.contains_aggregate",
    ".django.db.models.lookups.py@@Lookup.contains_aggregate": "def contains_aggregate(self):\n    return self.lhs.contains_aggregate or getattr(self.rhs, 'contains_aggregate', False)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_extra_select": "def get_extra_select(self, order_by, select):\n    extra_select = []\n    if self.query.distinct and (not self.query.distinct_fields):\n        select_sql = [t[1] for t in select]\n        for expr, (sql, params, is_ref) in order_by:\n            without_ordering = self.ordering_parts.search(sql)[1]\n            if not is_ref and (without_ordering, params) not in select_sql:\n                extra_select.append((expr, (without_ordering, params), None))\n    return extra_select",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_group_by": "def get_group_by(self, select, order_by):\n    if self.query.group_by is None:\n        return []\n    expressions = []\n    if self.query.group_by is not True:\n        for expr in self.query.group_by:\n            if not hasattr(expr, 'as_sql'):\n                expressions.append(self.query.resolve_ref(expr))\n            else:\n                expressions.append(expr)\n    ref_sources = {expr.source for expr in expressions if isinstance(expr, Ref)}\n    for expr, _, _ in select:\n        if expr in ref_sources:\n            continue\n        cols = expr.get_group_by_cols()\n        for col in cols:\n            expressions.append(col)\n    for expr, (sql, params, is_ref) in order_by:\n        if not is_ref:\n            expressions.extend(expr.get_group_by_cols())\n    having_group_by = self.having.get_group_by_cols() if self.having else ()\n    for expr in having_group_by:\n        expressions.append(expr)\n    result = []\n    seen = set()\n    expressions = self.collapse_group_by(expressions, having_group_by)\n    for expr in expressions:\n        sql, params = self.compile(expr)\n        sql, params = expr.select_format(self, sql, params)\n        params_hash = make_hashable(params)\n        if (sql, params_hash) not in seen:\n            result.append((sql, params))\n            seen.add((sql, params_hash))\n    return result",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_distinct": "def get_distinct(self):\n    result = []\n    params = []\n    opts = self.query.get_meta()\n    for name in self.query.distinct_fields:\n        parts = name.split(LOOKUP_SEP)\n        _, targets, alias, joins, path, _, transform_function = self._setup_joins(parts, opts, None)\n        targets, alias, _ = self.query.trim_joins(targets, joins, path)\n        for target in targets:\n            if name in self.query.annotation_select:\n                result.append(name)\n            else:\n                r, p = self.compile(transform_function(target, alias))\n                result.append(r)\n                params.append(p)\n    return (result, params)",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_from_clause": "def get_from_clause(self):\n    result = []\n    params = []\n    for alias in tuple(self.query.alias_map):\n        if not self.query.alias_refcount[alias]:\n            continue\n        try:\n            from_clause = self.query.alias_map[alias]\n        except KeyError:\n            continue\n        clause_sql, clause_params = self.compile(from_clause)\n        result.append(clause_sql)\n        params.extend(clause_params)\n    for t in self.query.extra_tables:\n        alias, _ = self.query.table_alias(t)\n        if alias not in self.query.alias_map or self.query.alias_refcount[alias] == 1:\n            result.append(', %s' % self.quote_name_unless_alias(alias))\n    return (result, params)",
    ".django.db.models.sql.datastructures.py@@BaseTable.as_sql": "def as_sql(self, compiler, connection):\n    alias_str = '' if self.table_alias == self.table_name else ' %s' % self.table_alias\n    base_sql = compiler.quote_name_unless_alias(self.table_name)\n    return (base_sql + alias_str, [])",
    ".django.db.models.sql.where.py@@WhereNode.as_sql": "def as_sql(self, compiler, connection):\n    result = []\n    result_params = []\n    if self.connector == AND:\n        full_needed, empty_needed = (len(self.children), 1)\n    else:\n        full_needed, empty_needed = (1, len(self.children))\n    for child in self.children:\n        try:\n            sql, params = compiler.compile(child)\n        except EmptyResultSet:\n            empty_needed -= 1\n        else:\n            if sql:\n                result.append(sql)\n                result_params.extend(params)\n            else:\n                full_needed -= 1\n        if empty_needed == 0:\n            if self.negated:\n                return ('', [])\n            else:\n                raise EmptyResultSet\n        if full_needed == 0:\n            if self.negated:\n                raise EmptyResultSet\n            else:\n                return ('', [])\n    conn = ' %s ' % self.connector\n    sql_string = conn.join(result)\n    if sql_string:\n        if self.negated:\n            sql_string = 'NOT (%s)' % sql_string\n        elif len(result) > 1 or self.resolved:\n            sql_string = '(%s)' % sql_string\n    return (sql_string, result_params)",
    ".django.db.models.lookups.py@@Exact.as_sql": "def as_sql(self, compiler, connection):\n    if isinstance(self.rhs, bool) and getattr(self.lhs, 'conditional', False) and connection.ops.conditional_expression_supported_in_where_clause(self.lhs):\n        lhs_sql, params = self.process_lhs(compiler, connection)\n        template = '%s' if self.rhs else 'NOT %s'\n        return (template % lhs_sql, params)\n    return super().as_sql(compiler, connection)",
    ".django.db.models.lookups.py@@BuiltinLookup.as_sql": "def as_sql(self, compiler, connection):\n    lhs_sql, params = self.process_lhs(compiler, connection)\n    rhs_sql, rhs_params = self.process_rhs(compiler, connection)\n    params.extend(rhs_params)\n    rhs_sql = self.get_rhs_op(connection, rhs_sql)\n    return ('%s %s' % (lhs_sql, rhs_sql), params)",
    ".django.db.models.lookups.py@@BuiltinLookup.process_lhs": "def process_lhs(self, compiler, connection, lhs=None):\n    lhs_sql, params = super().process_lhs(compiler, connection, lhs)\n    field_internal_type = self.lhs.output_field.get_internal_type()\n    db_type = self.lhs.output_field.db_type(connection=connection)\n    lhs_sql = connection.ops.field_cast_sql(db_type, field_internal_type) % lhs_sql\n    lhs_sql = connection.ops.lookup_cast(self.lookup_name, field_internal_type) % lhs_sql\n    return (lhs_sql, list(params))",
    ".django.db.models.lookups.py@@Lookup.process_lhs": "def process_lhs(self, compiler, connection, lhs=None):\n    lhs = lhs or self.lhs\n    if hasattr(lhs, 'resolve_expression'):\n        lhs = lhs.resolve_expression(compiler.query)\n    return compiler.compile(lhs)",
    ".django.db.models.expressions.py@@BaseExpression.resolve_expression": "def resolve_expression(self, query=None, allow_joins=True, reuse=None, summarize=False, for_save=False):\n    c = self.copy()\n    c.is_summary = summarize\n    c.set_source_expressions([expr.resolve_expression(query, allow_joins, reuse, summarize) if expr else None for expr in c.get_source_expressions()])\n    return c",
    ".django.db.models.expressions.py@@BaseExpression.copy": "def copy(self):\n    return copy.copy(self)",
    ".django.db.models.expressions.py@@BaseExpression.__getstate__": "def __getstate__(self):\n    state = self.__dict__.copy()\n    state.pop('convert_value', None)\n    return state",
    ".django.db.models.expressions.py@@BaseExpression.get_source_expressions": "def get_source_expressions(self):\n    return []",
    ".django.db.models.expressions.py@@BaseExpression.set_source_expressions": "def set_source_expressions(self, exprs):\n    assert not exprs",
    ".django.db.models.fields.__init__.py@@CharField.get_internal_type": "def get_internal_type(self):\n    return 'CharField'",
    ".django.db.models.fields.__init__.py@@Field.db_type": "def db_type(self, connection):\n    data = self.db_type_parameters(connection)\n    try:\n        return connection.data_types[self.get_internal_type()] % data\n    except KeyError:\n        return None",
    ".django.db.models.fields.__init__.py@@Field.db_type_parameters": "def db_type_parameters(self, connection):\n    return DictWrapper(self.__dict__, connection.ops.quote_name, 'qn_')",
    ".django.utils.datastructures.py@@DictWrapper.__init__": "def __init__(self, data, func, prefix):\n    super().__init__(data)\n    self.func = func\n    self.prefix = prefix",
    ".django.utils.datastructures.py@@DictWrapper.__getitem__": "def __getitem__(self, key):\n    use_func = key.startswith(self.prefix)\n    if use_func:\n        key = key[len(self.prefix):]\n    value = super().__getitem__(key)\n    if use_func:\n        return self.func(value)\n    return value",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.field_cast_sql": "def field_cast_sql(self, db_type, internal_type):\n    return '%s'",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.lookup_cast": "def lookup_cast(self, lookup_type, internal_type=None):\n    return '%s'",
    ".django.db.models.lookups.py@@Exact.process_rhs": "def process_rhs(self, compiler, connection):\n    from django.db.models.sql.query import Query\n    if isinstance(self.rhs, Query):\n        if self.rhs.has_limit_one():\n            if not self.rhs.has_select_fields:\n                self.rhs.clear_select_clause()\n                self.rhs.add_fields(['pk'])\n        else:\n            raise ValueError('The QuerySet value for an exact lookup must be limited to one result using slicing.')\n    return super().process_rhs(compiler, connection)",
    ".django.db.models.lookups.py@@Lookup.process_rhs": "def process_rhs(self, compiler, connection):\n    value = self.rhs\n    if self.bilateral_transforms:\n        if self.rhs_is_direct_value():\n            value = Value(value, output_field=self.lhs.output_field)\n        value = self.apply_bilateral_transforms(value)\n        value = value.resolve_expression(compiler.query)\n    if hasattr(value, 'as_sql'):\n        return compiler.compile(value)\n    else:\n        return self.get_db_prep_lookup(value, connection)",
    ".django.db.models.lookups.py@@FieldGetDbPrepValueMixin.get_db_prep_lookup": "def get_db_prep_lookup(self, value, connection):\n    field = getattr(self.lhs.output_field, 'target_field', None)\n    get_db_prep_value = getattr(field, 'get_db_prep_value', None) or self.lhs.output_field.get_db_prep_value\n    return ('%s', [get_db_prep_value(v, connection, prepared=True) for v in value] if self.get_db_prep_lookup_value_is_iterable else [get_db_prep_value(value, connection, prepared=True)])",
    ".django.db.models.fields.__init__.py@@Field.get_db_prep_value": "def get_db_prep_value(self, value, connection, prepared=False):\n    if not prepared:\n        value = self.get_prep_value(value)\n    return value",
    ".django.db.models.lookups.py@@BuiltinLookup.get_rhs_op": "def get_rhs_op(self, connection, rhs):\n    return connection.operators[self.lookup_name] % rhs",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.limit_offset_sql": "def limit_offset_sql(self, low_mark, high_mark):\n    limit, offset = self._get_limit_offset_params(low_mark, high_mark)\n    return ' '.join((sql for sql in ('LIMIT %d' % limit if limit else None, 'OFFSET %d' % offset if offset else None) if sql))",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations._get_limit_offset_params": "def _get_limit_offset_params(self, low_mark, high_mark):\n    offset = low_mark or 0\n    if high_mark is not None:\n        return (high_mark - offset, offset)\n    elif offset:\n        return (self.connection.ops.no_limit_value(), offset)\n    return (None, offset)",
    ".django.db.models.sql.query.py@@Query.reset_refcounts": "def reset_refcounts(self, to_counts):\n    for alias, cur_refcount in self.alias_refcount.copy().items():\n        unref_amount = cur_refcount - to_counts.get(alias, 0)\n        self.unref_alias(alias, unref_amount)",
    ".django.db.models.sql.query.py@@Query.unref_alias": "def unref_alias(self, alias, amount=1):\n    self.alias_refcount[alias] -= amount",
    ".django.utils.asyncio.py@@inner": "def inner(*args, **kwargs):\n    if not os.environ.get('DJANGO_ALLOW_ASYNC_UNSAFE'):\n        try:\n            event_loop = asyncio.get_event_loop()\n        except RuntimeError:\n            pass\n        else:\n            if event_loop.is_running():\n                raise SynchronousOnlyOperation(message)\n    return func(*args, **kwargs)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.cursor": "def cursor(self):\n    return self._cursor()",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper._cursor": "def _cursor(self, name=None):\n    self.ensure_connection()\n    with self.wrap_database_errors:\n        return self._prepare_cursor(self.create_cursor(name))",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.ensure_connection": "def ensure_connection(self):\n    if self.connection is None:\n        with self.wrap_database_errors:\n            self.connect()",
    ".django.db.utils.py@@DatabaseErrorWrapper.__enter__": "def __enter__(self):\n    pass",
    ".django.db.backends.sqlite3.base.py@@DatabaseWrapper.create_cursor": "def create_cursor(self, name=None):\n    return self.connection.cursor(factory=SQLiteCursorWrapper)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper._prepare_cursor": "def _prepare_cursor(self, cursor):\n    self.validate_thread_sharing()\n    if self.queries_logged:\n        wrapped_cursor = self.make_debug_cursor(cursor)\n    else:\n        wrapped_cursor = self.make_cursor(cursor)\n    return wrapped_cursor",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.validate_thread_sharing": "def validate_thread_sharing(self):\n    if not (self.allow_thread_sharing or self._thread_ident == _thread.get_ident()):\n        raise DatabaseError(\"DatabaseWrapper objects created in a thread can only be used in that same thread. The object with alias '%s' was created in thread id %s and this is thread id %s.\" % (self.alias, self._thread_ident, _thread.get_ident()))",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.allow_thread_sharing": "def allow_thread_sharing(self):\n    with self._thread_sharing_lock:\n        return self._thread_sharing_count > 0",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.queries_logged": "def queries_logged(self):\n    return self.force_debug_cursor or settings.DEBUG",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.make_cursor": "def make_cursor(self, cursor):\n    return utils.CursorWrapper(cursor, self)",
    ".django.db.backends.utils.py@@CursorWrapper.__init__": "def __init__(self, cursor, db):\n    self.cursor = cursor\n    self.db = db",
    ".django.db.utils.py@@DatabaseErrorWrapper.__exit__": "def __exit__(self, exc_type, exc_value, traceback):\n    if exc_type is None:\n        return\n    for dj_exc_type in (DataError, OperationalError, IntegrityError, InternalError, ProgrammingError, NotSupportedError, DatabaseError, InterfaceError, Error):\n        db_exc_type = getattr(self.wrapper.Database, dj_exc_type.__name__)\n        if issubclass(exc_type, db_exc_type):\n            dj_exc_value = dj_exc_type(*exc_value.args)\n            if dj_exc_type not in (DataError, IntegrityError):\n                self.wrapper.errors_occurred = True\n            raise dj_exc_value.with_traceback(traceback) from exc_value",
    ".django.db.backends.utils.py@@CursorWrapper.execute": "def execute(self, sql, params=None):\n    return self._execute_with_wrappers(sql, params, many=False, executor=self._execute)",
    ".django.db.backends.utils.py@@CursorWrapper._execute_with_wrappers": "def _execute_with_wrappers(self, sql, params, many, executor):\n    context = {'connection': self.db, 'cursor': self}\n    for wrapper in reversed(self.db.execute_wrappers):\n        executor = functools.partial(wrapper, executor)\n    return executor(sql, params, many, context)",
    ".django.db.backends.utils.py@@CursorWrapper._execute": "def _execute(self, sql, params, *ignored_wrapper_args):\n    self.db.validate_no_broken_transaction()\n    with self.db.wrap_database_errors:\n        if params is None:\n            return self.cursor.execute(sql)\n        else:\n            return self.cursor.execute(sql, params)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.validate_no_broken_transaction": "def validate_no_broken_transaction(self):\n    if self.needs_rollback:\n        raise TransactionManagementError(\"An error occurred in the current transaction. You can't execute queries until the end of the 'atomic' block.\")",
    ".django.db.backends.sqlite3.base.py@@SQLiteCursorWrapper.execute": "def execute(self, query, params=None):\n    if params is None:\n        return Database.Cursor.execute(self, query)\n    query = self.convert_query(query)\n    return Database.Cursor.execute(self, query, params)",
    ".django.db.backends.sqlite3.base.py@@SQLiteCursorWrapper.convert_query": "def convert_query(self, query):\n    return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')",
    ".django.db.models.sql.compiler.py@@cursor_iter": "def cursor_iter(cursor, sentinel, col_count, itersize):\n    try:\n        for rows in iter(lambda: cursor.fetchmany(itersize), sentinel):\n            yield (rows if col_count is None else [r[:col_count] for r in rows])\n    finally:\n        cursor.close()",
    ".django.db.backends.utils.py@@CursorWrapper.__getattr__": "def __getattr__(self, attr):\n    cursor_attr = getattr(self.cursor, attr)\n    if attr in CursorWrapper.WRAP_ERROR_ATTRS:\n        return self.db.wrap_database_errors(cursor_attr)\n    else:\n        return cursor_attr",
    ".django.db.utils.py@@DatabaseErrorWrapper.__call__": "def __call__(self, func):\n\n    def inner(*args, **kwargs):\n        with self:\n            return func(*args, **kwargs)\n    return inner",
    ".django.db.utils.py@@DatabaseErrorWrapper.inner": "def inner(*args, **kwargs):\n    with self:\n        return func(*args, **kwargs)",
    ".django.db.models.query.py@@get_related_populators": "def get_related_populators(klass_info, select, db):\n    iterators = []\n    related_klass_infos = klass_info.get('related_klass_infos', [])\n    for rel_klass_info in related_klass_infos:\n        rel_cls = RelatedPopulator(rel_klass_info, select, db)\n        iterators.append(rel_cls)\n    return iterators",
    ".django.db.models.sql.compiler.py@@SQLCompiler.results_iter": "def results_iter(self, results=None, tuple_expected=False, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):\n    if results is None:\n        results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)\n    fields = [s[0] for s in self.select[0:self.col_count]]\n    converters = self.get_converters(fields)\n    rows = chain.from_iterable(results)\n    if converters:\n        rows = self.apply_converters(rows, converters)\n        if tuple_expected:\n            rows = map(tuple, rows)\n    return rows",
    ".django.db.models.sql.compiler.py@@SQLCompiler.get_converters": "def get_converters(self, expressions):\n    converters = {}\n    for i, expression in enumerate(expressions):\n        if expression:\n            backend_converters = self.connection.ops.get_db_converters(expression)\n            field_converters = expression.get_db_converters(self.connection)\n            if backend_converters or field_converters:\n                converters[i] = (backend_converters + field_converters, expression)\n    return converters",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.get_db_converters": "def get_db_converters(self, expression):\n    converters = super().get_db_converters(expression)\n    internal_type = expression.output_field.get_internal_type()\n    if internal_type == 'DateTimeField':\n        converters.append(self.convert_datetimefield_value)\n    elif internal_type == 'DateField':\n        converters.append(self.convert_datefield_value)\n    elif internal_type == 'TimeField':\n        converters.append(self.convert_timefield_value)\n    elif internal_type == 'DecimalField':\n        converters.append(self.get_decimalfield_converter(expression))\n    elif internal_type == 'UUIDField':\n        converters.append(self.convert_uuidfield_value)\n    elif internal_type in ('NullBooleanField', 'BooleanField'):\n        converters.append(self.convert_booleanfield_value)\n    return converters",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.get_db_converters": "def get_db_converters(self, expression):\n    return []",
    ".django.db.models.fields.__init__.py@@AutoField.get_internal_type": "def get_internal_type(self):\n    return 'AutoField'",
    ".django.db.models.expressions.py@@Col.get_db_converters": "def get_db_converters(self, connection):\n    if self.target == self.output_field:\n        return self.output_field.get_db_converters(connection)\n    return self.output_field.get_db_converters(connection) + self.target.get_db_converters(connection)",
    ".django.db.models.fields.__init__.py@@Field.get_db_converters": "def get_db_converters(self, connection):\n    if hasattr(self, 'from_db_value'):\n        return [self.from_db_value]\n    return []",
    ".django.db.models.fields.__init__.py@@DateTimeField.get_internal_type": "def get_internal_type(self):\n    return 'DateTimeField'",
    ".django.db.models.fields.__init__.py@@BooleanField.get_internal_type": "def get_internal_type(self):\n    return 'BooleanField'",
    ".django.db.models.sql.compiler.py@@SQLCompiler.apply_converters": "def apply_converters(self, rows, converters):\n    connection = self.connection\n    converters = list(converters.items())\n    for row in map(list, rows):\n        for pos, (convs, expression) in converters:\n            value = row[pos]\n            for converter in convs:\n                value = converter(value, expression, connection)\n            row[pos] = value\n        yield row",
    ".django.db.models.options.py@@Options.default_manager": "def default_manager(self):\n    default_manager_name = self.default_manager_name\n    if not default_manager_name and (not self.local_managers):\n        for parent in self.model.mro()[1:]:\n            if hasattr(parent, '_meta'):\n                default_manager_name = parent._meta.default_manager_name\n                break\n    if default_manager_name:\n        try:\n            return self.managers_map[default_manager_name]\n        except KeyError:\n            raise ValueError('%s has no manager named %r' % (self.object_name, default_manager_name))\n    if self.managers:\n        return self.managers[0]",
    ".django.db.models.options.py@@Options.managers": "def managers(self):\n    managers = []\n    seen_managers = set()\n    bases = (b for b in self.model.mro() if hasattr(b, '_meta'))\n    for depth, base in enumerate(bases):\n        for manager in base._meta.local_managers:\n            if manager.name in seen_managers:\n                continue\n            manager = copy.copy(manager)\n            manager.model = self.model\n            seen_managers.add(manager.name)\n            managers.append((depth, manager.creation_counter, manager))\n    return make_immutable_fields_list('managers', (m[2] for m in sorted(managers)))",
    ".django.db.models.options.py@@make_immutable_fields_list": "def make_immutable_fields_list(name, data):\n    return ImmutableList(data, warning=IMMUTABLE_WARNING % name)",
    ".django.utils.datastructures.py@@ImmutableList.__new__": "def __new__(cls, *args, warning='ImmutableList object is immutable.', **kwargs):\n    self = tuple.__new__(cls, *args, **kwargs)\n    self.warning = warning\n    return self",
    ".django.db.models.options.py@@Options.concrete_fields": "def concrete_fields(self):\n    return make_immutable_fields_list('concrete_fields', (f for f in self.fields if f.concrete))",
    ".django.db.models.options.py@@Options.fields": "def fields(self):\n\n    def is_not_an_m2m_field(f):\n        return not (f.is_relation and f.many_to_many)\n\n    def is_not_a_generic_relation(f):\n        return not (f.is_relation and f.one_to_many)\n\n    def is_not_a_generic_foreign_key(f):\n        return not (f.is_relation and f.many_to_one and (not (hasattr(f.remote_field, 'model') and f.remote_field.model)))\n    return make_immutable_fields_list('fields', (f for f in self._get_fields(reverse=False) if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f)))",
    ".django.db.models.options.py@@Options._get_fields": "def _get_fields(self, forward=True, reverse=True, include_parents=True, include_hidden=False, seen_models=None):\n    if include_parents not in (True, False, PROXY_PARENTS):\n        raise TypeError('Invalid argument for include_parents: %s' % (include_parents,))\n    topmost_call = seen_models is None\n    if topmost_call:\n        seen_models = set()\n    seen_models.add(self.model)\n    cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)\n    try:\n        return self._get_fields_cache[cache_key]\n    except KeyError:\n        pass\n    fields = []\n    if include_parents is not False:\n        for parent in self.parents:\n            if parent in seen_models:\n                continue\n            if parent._meta.concrete_model != self.concrete_model and include_parents == PROXY_PARENTS:\n                continue\n            for obj in parent._meta._get_fields(forward=forward, reverse=reverse, include_parents=include_parents, include_hidden=include_hidden, seen_models=seen_models):\n                if not getattr(obj, 'parent_link', False) or obj.model == self.concrete_model:\n                    fields.append(obj)\n    if reverse and (not self.proxy):\n        all_fields = self._relation_tree\n        for field in all_fields:\n            if include_hidden or not field.remote_field.hidden:\n                fields.append(field.remote_field)\n    if forward:\n        fields += self.local_fields\n        fields += self.local_many_to_many\n        if topmost_call:\n            fields += self.private_fields\n    fields = make_immutable_fields_list('get_fields()', fields)\n    self._get_fields_cache[cache_key] = fields\n    return fields",
    ".django.db.models.options.py@@Options.is_not_an_m2m_field": "def is_not_an_m2m_field(f):\n    return not (f.is_relation and f.many_to_many)",
    ".django.db.models.options.py@@Options.is_not_a_generic_relation": "def is_not_a_generic_relation(f):\n    return not (f.is_relation and f.one_to_many)",
    ".django.db.models.options.py@@Options.is_not_a_generic_foreign_key": "def is_not_a_generic_foreign_key(f):\n    return not (f.is_relation and f.many_to_one and (not (hasattr(f.remote_field, 'model') and f.remote_field.model)))",
    ".django.utils.dateparse.py@@parse_datetime": "def parse_datetime(value):\n    match = datetime_re.match(value)\n    if match:\n        kw = match.groupdict()\n        kw['microsecond'] = kw['microsecond'] and kw['microsecond'].ljust(6, '0')\n        tzinfo = kw.pop('tzinfo')\n        if tzinfo == 'Z':\n            tzinfo = utc\n        elif tzinfo is not None:\n            offset_mins = int(tzinfo[-2:]) if len(tzinfo) > 3 else 0\n            offset = 60 * int(tzinfo[1:3]) + offset_mins\n            if tzinfo[0] == '-':\n                offset = -offset\n            tzinfo = get_fixed_timezone(offset)\n        kw = {k: int(v) for k, v in kw.items() if v is not None}\n        kw['tzinfo'] = tzinfo\n        return datetime.datetime(**kw)",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.convert_datetimefield_value": "def convert_datetimefield_value(self, value, expression, connection):\n    if value is not None:\n        if not isinstance(value, datetime.datetime):\n            value = parse_datetime(value)\n        if settings.USE_TZ and (not timezone.is_aware(value)):\n            value = timezone.make_aware(value, self.connection.timezone)\n    return value",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.convert_booleanfield_value": "def convert_booleanfield_value(self, value, expression, connection):\n    return bool(value) if value in (1, 0) else value",
    ".django.db.models.base.py@@Model.from_db": "def from_db(cls, db, field_names, values):\n    if len(values) != len(cls._meta.concrete_fields):\n        values_iter = iter(values)\n        values = [next(values_iter) if f.attname in field_names else DEFERRED for f in cls._meta.concrete_fields]\n    new = cls(*values)\n    new._state.adding = False\n    new._state.db = db\n    return new",
    ".django.db.models.base.py@@Model.__init__": "def __init__(self, *args, **kwargs):\n    cls = self.__class__\n    opts = self._meta\n    _setattr = setattr\n    _DEFERRED = DEFERRED\n    if opts.abstract:\n        raise TypeError('Abstract models cannot be instantiated.')\n    pre_init.send(sender=cls, args=args, kwargs=kwargs)\n    self._state = ModelState()\n    if len(args) > len(opts.concrete_fields):\n        raise IndexError('Number of args exceeds number of fields')\n    if not kwargs:\n        fields_iter = iter(opts.concrete_fields)\n        for val, field in zip(args, fields_iter):\n            if val is _DEFERRED:\n                continue\n            _setattr(self, field.attname, val)\n    else:\n        fields_iter = iter(opts.fields)\n        for val, field in zip(args, fields_iter):\n            if val is _DEFERRED:\n                continue\n            _setattr(self, field.attname, val)\n            kwargs.pop(field.name, None)\n    for field in fields_iter:\n        is_related_object = False\n        if field.attname not in kwargs and field.column is None:\n            continue\n        if kwargs:\n            if isinstance(field.remote_field, ForeignObjectRel):\n                try:\n                    rel_obj = kwargs.pop(field.name)\n                    is_related_object = True\n                except KeyError:\n                    try:\n                        val = kwargs.pop(field.attname)\n                    except KeyError:\n                        val = field.get_default()\n            else:\n                try:\n                    val = kwargs.pop(field.attname)\n                except KeyError:\n                    val = field.get_default()\n        else:\n            val = field.get_default()\n        if is_related_object:\n            if rel_obj is not _DEFERRED:\n                _setattr(self, field.name, rel_obj)\n        elif val is not _DEFERRED:\n            _setattr(self, field.attname, val)\n    if kwargs:\n        property_names = opts._property_names\n        for prop in tuple(kwargs):\n            try:\n                if prop in property_names or opts.get_field(prop):\n                    if kwargs[prop] is not _DEFERRED:\n                        _setattr(self, prop, kwargs[prop])\n                    del kwargs[prop]\n            except (AttributeError, FieldDoesNotExist):\n                pass\n        for kwarg in kwargs:\n            raise TypeError(\"%s() got an unexpected keyword argument '%s'\" % (cls.__name__, kwarg))\n    super().__init__()\n    post_init.send(sender=cls, instance=self)",
    ".django.dispatch.dispatcher.py@@Signal.send": "def send(self, sender, **named):\n    if not self.receivers or self.sender_receivers_cache.get(sender) is NO_RECEIVERS:\n        return []\n    return [(receiver, receiver(signal=self, sender=sender, **named)) for receiver in self._live_receivers(sender)]"
}