{
    ".django.db.backends.sqlite3.creation.py@@DatabaseCreation._get_test_db_name": "def _get_test_db_name(self):\n    test_database_name = self.connection.settings_dict['TEST']['NAME'] or ':memory:'\n    if test_database_name == ':memory:':\n        return 'file:memorydb_%s?mode=memory&cache=shared' % self.connection.alias\n    return test_database_name",
    ".django.db.__init__.py@@DefaultConnectionProxy.__getattr__": "def __getattr__(self, item):\n    return getattr(connections[DEFAULT_DB_ALIAS], item)",
    ".django.db.utils.py@@ConnectionHandler.__getitem__": "def __getitem__(self, alias):\n    if hasattr(self._connections, alias):\n        return getattr(self._connections, alias)\n    self.ensure_defaults(alias)\n    self.prepare_test_settings(alias)\n    db = self.databases[alias]\n    backend = load_backend(db['ENGINE'])\n    conn = backend.DatabaseWrapper(db, alias)\n    setattr(self._connections, alias, conn)\n    return conn",
    ".django.utils.asyncio.py@@inner": "def inner(*args, **kwargs):\n    try:\n        event_loop = asyncio.get_event_loop()\n    except RuntimeError:\n        pass\n    else:\n        if event_loop.is_running():\n            raise SynchronousOnlyOperation(message)\n    return func(*args, **kwargs)",
    ".django.db.backends.sqlite3.base.py@@DatabaseWrapper.close": "def close(self):\n    self.validate_thread_sharing()\n    if not self.is_in_memory_db():\n        BaseDatabaseWrapper.close(self)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.validate_thread_sharing": "def validate_thread_sharing(self):\n    if not (self.allow_thread_sharing or self._thread_ident == _thread.get_ident()):\n        raise DatabaseError(\"DatabaseWrapper objects created in a thread can only be used in that same thread. The object with alias '%s' was created in thread id %s and this is thread id %s.\" % (self.alias, self._thread_ident, _thread.get_ident()))",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.allow_thread_sharing": "def allow_thread_sharing(self):\n    with self._thread_sharing_lock:\n        return self._thread_sharing_count > 0",
    ".django.db.backends.sqlite3.base.py@@DatabaseWrapper.is_in_memory_db": "def is_in_memory_db(self):\n    return self.creation.is_in_memory_db(self.settings_dict['NAME'])",
    ".django.db.backends.sqlite3.creation.py@@DatabaseCreation.is_in_memory_db": "def is_in_memory_db(database_name):\n    return not isinstance(database_name, Path) and (database_name == ':memory:' or 'mode=memory' in database_name)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.close": "def close(self):\n    self.validate_thread_sharing()\n    self.run_on_commit = []\n    if self.closed_in_transaction or self.connection is None:\n        return\n    try:\n        self._close()\n    finally:\n        if self.in_atomic_block:\n            self.closed_in_transaction = True\n            self.needs_rollback = True\n        else:\n            self.connection = None",
    ".django.core.management.__init__.py@@call_command": "def call_command(command_name, *args, **options):\n    if isinstance(command_name, BaseCommand):\n        command = command_name\n        command_name = command.__class__.__module__.split('.')[-1]\n    else:\n        try:\n            app_name = get_commands()[command_name]\n        except KeyError:\n            raise CommandError('Unknown command: %r' % command_name)\n        if isinstance(app_name, BaseCommand):\n            command = app_name\n        else:\n            command = load_command_class(app_name, command_name)\n    parser = command.create_parser('', command_name)\n    opt_mapping = {min(s_opt.option_strings).lstrip('-').replace('-', '_'): s_opt.dest for s_opt in parser._actions if s_opt.option_strings}\n    arg_options = {opt_mapping.get(key, key): value for key, value in options.items()}\n    parse_args = [str(a) for a in args]\n\n    def get_actions(parser):\n        for opt in parser._actions:\n            if isinstance(opt, _SubParsersAction):\n                for sub_opt in opt.choices.values():\n                    yield from get_actions(sub_opt)\n            else:\n                yield opt\n    parser_actions = list(get_actions(parser))\n    mutually_exclusive_required_options = {opt for group in parser._mutually_exclusive_groups for opt in group._group_actions if group.required}\n    parse_args += ['{}={}'.format(min(opt.option_strings), arg_options[opt.dest]) for opt in parser_actions if opt.dest in options and (opt.required or opt in mutually_exclusive_required_options)]\n    defaults = parser.parse_args(args=parse_args)\n    defaults = dict(defaults._get_kwargs(), **arg_options)\n    stealth_options = set(command.base_stealth_options + command.stealth_options)\n    dest_parameters = {action.dest for action in parser_actions}\n    valid_options = (dest_parameters | stealth_options).union(opt_mapping)\n    unknown_options = set(options) - valid_options\n    if unknown_options:\n        raise TypeError('Unknown option(s) for %s command: %s. Valid options are: %s.' % (command_name, ', '.join(sorted(unknown_options)), ', '.join(sorted(valid_options))))\n    args = defaults.pop('args', ())\n    if 'skip_checks' not in options:\n        defaults['skip_checks'] = True\n    return command.execute(*args, **defaults)",
    ".django.core.management.__init__.py@@load_command_class": "def load_command_class(app_name, name):\n    module = import_module('%s.management.commands.%s' % (app_name, name))\n    return module.Command()",
    ".django.core.management.base.py@@BaseCommand.__init__": "def __init__(self, stdout=None, stderr=None, no_color=False, force_color=False):\n    self.stdout = OutputWrapper(stdout or sys.stdout)\n    self.stderr = OutputWrapper(stderr or sys.stderr)\n    if no_color and force_color:\n        raise CommandError(\"'no_color' and 'force_color' can't be used together.\")\n    if no_color:\n        self.style = no_style()\n    else:\n        self.style = color_style(force_color)\n        self.stderr.style_func = self.style.ERROR",
    ".django.core.management.base.py@@OutputWrapper.__init__": "def __init__(self, out, ending='\\n'):\n    self._out = out\n    self.style_func = None\n    self.ending = ending",
    ".django.core.management.base.py@@OutputWrapper.style_func": "def style_func(self):\n    return self._style_func",
    ".django.core.management.color.py@@color_style": "def color_style(force_color=False):\n    if not force_color and (not supports_color()):\n        return no_style()\n    return make_style(os.environ.get('DJANGO_COLORS', ''))",
    ".django.core.management.color.py@@supports_color": "def supports_color():\n    plat = sys.platform\n    supported_platform = plat != 'Pocket PC' and (plat != 'win32' or 'ANSICON' in os.environ)\n    is_a_tty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()\n    return supported_platform and is_a_tty",
    ".django.core.management.base.py@@OutputWrapper.isatty": "def isatty(self):\n    return hasattr(self._out, 'isatty') and self._out.isatty()",
    ".django.core.management.base.py@@BaseCommand.create_parser": "def create_parser(self, prog_name, subcommand, **kwargs):\n    parser = CommandParser(prog='%s %s' % (os.path.basename(prog_name), subcommand), description=self.help or None, formatter_class=DjangoHelpFormatter, missing_args_message=getattr(self, 'missing_args_message', None), called_from_command_line=getattr(self, '_called_from_command_line', None), **kwargs)\n    parser.add_argument('--version', action='version', version=self.get_version())\n    parser.add_argument('-v', '--verbosity', default=1, type=int, choices=[0, 1, 2, 3], help='Verbosity level; 0=minimal output, 1=normal output, 2=verbose output, 3=very verbose output')\n    parser.add_argument('--settings', help='The Python path to a settings module, e.g. \"myproject.settings.main\". If this isn\\'t provided, the DJANGO_SETTINGS_MODULE environment variable will be used.')\n    parser.add_argument('--pythonpath', help='A directory to add to the Python path, e.g. \"/home/djangoprojects/myproject\".')\n    parser.add_argument('--traceback', action='store_true', help='Raise on CommandError exceptions')\n    parser.add_argument('--no-color', action='store_true', help=\"Don't colorize the command output.\")\n    parser.add_argument('--force-color', action='store_true', help='Force colorization of the command output.')\n    if self.requires_system_checks:\n        parser.add_argument('--skip-checks', action='store_true', help='Skip system checks.')\n    self.add_arguments(parser)\n    return parser",
    ".django.core.management.base.py@@CommandParser.__init__": "def __init__(self, *, missing_args_message=None, called_from_command_line=None, **kwargs):\n    self.missing_args_message = missing_args_message\n    self.called_from_command_line = called_from_command_line\n    super().__init__(**kwargs)",
    ".django.core.management.base.py@@BaseCommand.get_version": "def get_version(self):\n    return django.get_version()",
    ".django.utils.version.py@@get_version": "def get_version(version=None):\n    version = get_complete_version(version)\n    main = get_main_version(version)\n    sub = ''\n    if version[3] == 'alpha' and version[4] == 0:\n        git_changeset = get_git_changeset()\n        if git_changeset:\n            sub = '.dev%s' % git_changeset\n    elif version[3] != 'final':\n        mapping = {'alpha': 'a', 'beta': 'b', 'rc': 'rc'}\n        sub = mapping[version[3]] + str(version[4])\n    return main + sub",
    ".django.utils.version.py@@get_complete_version": "def get_complete_version(version=None):\n    if version is None:\n        from django import VERSION as version\n    else:\n        assert len(version) == 5\n        assert version[3] in ('alpha', 'beta', 'rc', 'final')\n    return version",
    ".django.utils.version.py@@get_main_version": "def get_main_version(version=None):\n    version = get_complete_version(version)\n    parts = 2 if version[2] == 0 else 3\n    return '.'.join((str(x) for x in version[:parts]))",
    ".django.core.management.commands.createcachetable.py@@Command.add_arguments": "def add_arguments(self, parser):\n    parser.add_argument('args', metavar='table_name', nargs='*', help='Optional table names. Otherwise, settings.CACHES is used to find cache tables.')\n    parser.add_argument('--database', default=DEFAULT_DB_ALIAS, help='Nominates a database onto which the cache tables will be installed. Defaults to the \"default\" database.')\n    parser.add_argument('--dry-run', action='store_true', help='Does not create the table, just prints the SQL that would be run.')",
    ".django.core.management.__init__.py@@get_actions": "def get_actions(parser):\n    for opt in parser._actions:\n        if isinstance(opt, _SubParsersAction):\n            for sub_opt in opt.choices.values():\n                yield from get_actions(sub_opt)\n        else:\n            yield opt",
    ".django.core.management.base.py@@CommandParser.parse_args": "def parse_args(self, args=None, namespace=None):\n    if self.missing_args_message and (not (args or any((not arg.startswith('-') for arg in args)))):\n        self.error(self.missing_args_message)\n    return super().parse_args(args, namespace)",
    ".django.core.management.base.py@@BaseCommand.execute": "def execute(self, *args, **options):\n    if options['force_color'] and options['no_color']:\n        raise CommandError(\"The --no-color and --force-color options can't be used together.\")\n    if options['force_color']:\n        self.style = color_style(force_color=True)\n    elif options['no_color']:\n        self.style = no_style()\n        self.stderr.style_func = None\n    if options.get('stdout'):\n        self.stdout = OutputWrapper(options['stdout'])\n    if options.get('stderr'):\n        self.stderr = OutputWrapper(options['stderr'])\n    if self.requires_system_checks and (not options['skip_checks']):\n        self.check()\n    if self.requires_migrations_checks:\n        self.check_migrations()\n    output = self.handle(*args, **options)\n    if output:\n        if self.output_transaction:\n            connection = connections[options.get('database', DEFAULT_DB_ALIAS)]\n            output = '%s\\n%s\\n%s' % (self.style.SQL_KEYWORD(connection.ops.start_transaction_sql()), output, self.style.SQL_KEYWORD(connection.ops.end_transaction_sql()))\n        self.stdout.write(output)\n    return output",
    ".django.core.management.commands.createcachetable.py@@Command.handle": "def handle(self, *tablenames, **options):\n    db = options['database']\n    self.verbosity = options['verbosity']\n    dry_run = options['dry_run']\n    if tablenames:\n        for tablename in tablenames:\n            self.create_table(db, tablename, dry_run)\n    else:\n        for cache_alias in settings.CACHES:\n            cache = caches[cache_alias]\n            if isinstance(cache, BaseDatabaseCache):\n                self.create_table(db, cache._table, dry_run)",
    ".django.core.cache.__init__.py@@CacheHandler.__getitem__": "def __getitem__(self, alias):\n    try:\n        return self._caches.caches[alias]\n    except AttributeError:\n        self._caches.caches = {}\n    except KeyError:\n        pass\n    if alias not in settings.CACHES:\n        raise InvalidCacheBackendError(\"Could not find config for '%s' in settings.CACHES\" % alias)\n    cache = _create_cache(alias)\n    self._caches.caches[alias] = cache\n    return cache",
    ".django.core.cache.__init__.py@@_create_cache": "def _create_cache(backend, **kwargs):\n    try:\n        try:\n            conf = settings.CACHES[backend]\n        except KeyError:\n            try:\n                import_string(backend)\n            except ImportError as e:\n                raise InvalidCacheBackendError(\"Could not find backend '%s': %s\" % (backend, e))\n            location = kwargs.pop('LOCATION', '')\n            params = kwargs\n        else:\n            params = {**conf, **kwargs}\n            backend = params.pop('BACKEND')\n            location = params.pop('LOCATION', '')\n        backend_cls = import_string(backend)\n    except ImportError as e:\n        raise InvalidCacheBackendError(\"Could not find backend '%s': %s\" % (backend, e))\n    return backend_cls(location, params)",
    ".django.utils.module_loading.py@@import_string": "def import_string(dotted_path):\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n    except ValueError as err:\n        raise ImportError(\"%s doesn't look like a module path\" % dotted_path) from err\n    module = import_module(module_path)\n    try:\n        return getattr(module, class_name)\n    except AttributeError as err:\n        raise ImportError('Module \"%s\" does not define a \"%s\" attribute/class' % (module_path, class_name)) from err",
    ".django.core.cache.backends.locmem.py@@LocMemCache.__init__": "def __init__(self, name, params):\n    super().__init__(params)\n    self._cache = _caches.setdefault(name, OrderedDict())\n    self._expire_info = _expire_info.setdefault(name, {})\n    self._lock = _locks.setdefault(name, Lock())",
    ".django.core.cache.backends.base.py@@BaseCache.__init__": "def __init__(self, params):\n    timeout = params.get('timeout', params.get('TIMEOUT', 300))\n    if timeout is not None:\n        try:\n            timeout = int(timeout)\n        except (ValueError, TypeError):\n            timeout = 300\n    self.default_timeout = timeout\n    options = params.get('OPTIONS', {})\n    max_entries = params.get('max_entries', options.get('MAX_ENTRIES', 300))\n    try:\n        self._max_entries = int(max_entries)\n    except (ValueError, TypeError):\n        self._max_entries = 300\n    cull_frequency = params.get('cull_frequency', options.get('CULL_FREQUENCY', 3))\n    try:\n        self._cull_frequency = int(cull_frequency)\n    except (ValueError, TypeError):\n        self._cull_frequency = 3\n    self.key_prefix = params.get('KEY_PREFIX', '')\n    self.version = params.get('VERSION', 1)\n    self.key_func = get_key_func(params.get('KEY_FUNCTION'))",
    ".django.core.cache.backends.base.py@@get_key_func": "def get_key_func(key_func):\n    if key_func is not None:\n        if callable(key_func):\n            return key_func\n        else:\n            return import_string(key_func)\n    return default_key_func",
    ".django.core.management.base.py@@OutputWrapper.__getattr__": "def __getattr__(self, name):\n    return getattr(self._out, name)",
    ".django.core.management.commands.migrate.py@@Command.add_arguments": "def add_arguments(self, parser):\n    parser.add_argument('app_label', nargs='?', help='App label of an application to synchronize the state.')\n    parser.add_argument('migration_name', nargs='?', help='Database state will be brought to the state after that migration. Use the name \"zero\" to unapply all migrations.')\n    parser.add_argument('--noinput', '--no-input', action='store_false', dest='interactive', help='Tells Django to NOT prompt the user for input of any kind.')\n    parser.add_argument('--database', default=DEFAULT_DB_ALIAS, help='Nominates a database to synchronize. Defaults to the \"default\" database.')\n    parser.add_argument('--fake', action='store_true', help='Mark migrations as run without actually running them.')\n    parser.add_argument('--fake-initial', action='store_true', help='Detect if tables already exist and fake-apply initial migrations if so. Make sure that the current database schema matches your initial migration before using this flag. Django will only check for an existing table name.')\n    parser.add_argument('--plan', action='store_true', help='Shows a list of the migration actions that will be performed.')\n    parser.add_argument('--run-syncdb', action='store_true', help='Creates tables for apps without migrations.')"
}