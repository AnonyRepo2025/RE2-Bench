{
    ".sympy.physics.quantum.gate.py@@Gate.nqubits": "def nqubits(self):\n    return len(self.targets)",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.numbers.py@@Integer.__index__": "def __index__(self):\n    return self.p",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    if evaluate is None:\n        if global_evaluate[0] is False:\n            evaluate = global_evaluate[0]\n        else:\n            evaluate = True\n    try:\n        if a in sympy_classes:\n            return a\n    except TypeError:\n        pass\n    try:\n        cls = a.__class__\n    except AttributeError:\n        cls = type(a)\n    if cls in sympy_classes:\n        return a\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if type(a).__module__ == 'numpy':\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    try:\n        return converter[cls](a)\n    except KeyError:\n        for superclass in getmro(cls):\n            try:\n                return converter[superclass](a)\n            except KeyError:\n                continue\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    try:\n        return a._sympy_()\n    except AttributeError:\n        pass\n    if not strict:\n        try:\n            from ..tensor.array import Array\n            return Array(a.flat, a.shape)\n        except AttributeError:\n            pass\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                return sympify(coerce(a))\n            except (TypeError, ValueError, AttributeError, SympifyError):\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.containers.py@@Tuple.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, string_types):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    try:\n        return _intcache[ival]\n    except KeyError:\n        obj = Expr.__new__(cls)\n        obj.p = ival\n        _intcache[ival] = obj\n        return obj",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.containers.py@@Tuple.__len__": "def __len__(self):\n    return len(self.args)",
    ".sympy.matrices.dense.py@@eye": "def eye(*args, **kwargs):\n    from .dense import Matrix\n    return Matrix.eye(*args, **kwargs)",
    ".sympy.matrices.common.py@@MatrixSpecial.eye": "def eye(kls, rows, cols=None, **kwargs):\n    if cols is None:\n        cols = rows\n    klass = kwargs.get('cls', kls)\n    rows, cols = (as_int(rows), as_int(cols))\n    return klass._eval_eye(rows, cols)",
    ".sympy.core.compatibility.py@@as_int": "def as_int(n):\n    try:\n        result = int(n)\n        if result != n:\n            raise TypeError\n    except TypeError:\n        raise ValueError('%s is not an integer' % (n,))\n    return result",
    ".sympy.matrices.common.py@@MatrixSpecial._eval_eye": "def _eval_eye(cls, rows, cols):\n\n    def entry(i, j):\n        return S.One if i == j else S.Zero\n    return cls._new(rows, cols, entry)",
    ".sympy.matrices.dense.py@@MutableDenseMatrix._new": "def _new(cls, *args, **kwargs):\n    if kwargs.get('copy', True) is False:\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list)\n    self = object.__new__(cls)\n    self.rows = rows\n    self.cols = cols\n    self._mat = flat_list\n    return self",
    ".sympy.matrices.matrices.py@@MatrixBase._handle_creation_inputs": "def _handle_creation_inputs(cls, *args, **kwargs):\n    from sympy.matrices.sparse import SparseMatrix\n    flat_list = None\n    if len(args) == 1:\n        if isinstance(args[0], SparseMatrix):\n            return (args[0].rows, args[0].cols, flatten(args[0].tolist()))\n        elif isinstance(args[0], MatrixBase):\n            return (args[0].rows, args[0].cols, args[0]._mat)\n        elif isinstance(args[0], Basic) and args[0].is_Matrix:\n            return (args[0].rows, args[0].cols, args[0].as_explicit()._mat)\n        elif hasattr(args[0], '__array__'):\n            arr = args[0].__array__()\n            if len(arr.shape) == 2:\n                rows, cols = (arr.shape[0], arr.shape[1])\n                flat_list = [cls._sympify(i) for i in arr.ravel()]\n                return (rows, cols, flat_list)\n            elif len(arr.shape) == 1:\n                rows, cols = (arr.shape[0], 1)\n                flat_list = [S.Zero] * rows\n                for i in range(len(arr)):\n                    flat_list[i] = cls._sympify(arr[i])\n                return (rows, cols, flat_list)\n            else:\n                raise NotImplementedError('SymPy supports just 1D and 2D matrices')\n        elif is_sequence(args[0]) and (not isinstance(args[0], DeferredVector)):\n            in_mat = []\n            ncol = set()\n            for row in args[0]:\n                if isinstance(row, MatrixBase):\n                    in_mat.extend(row.tolist())\n                    if row.cols or row.rows:\n                        ncol.add(row.cols)\n                else:\n                    in_mat.append(row)\n                    try:\n                        ncol.add(len(row))\n                    except TypeError:\n                        ncol.add(1)\n            if len(ncol) > 1:\n                raise ValueError('Got rows of variable lengths: %s' % sorted(list(ncol)))\n            cols = ncol.pop() if ncol else 0\n            rows = len(in_mat) if cols else 0\n            if rows:\n                if not is_sequence(in_mat[0]):\n                    cols = 1\n                    flat_list = [cls._sympify(i) for i in in_mat]\n                    return (rows, cols, flat_list)\n            flat_list = []\n            for j in range(rows):\n                for i in range(cols):\n                    flat_list.append(cls._sympify(in_mat[j][i]))\n    elif len(args) == 3:\n        rows = as_int(args[0])\n        cols = as_int(args[1])\n        if rows < 0 or cols < 0:\n            raise ValueError('Cannot create a {} x {} matrix. Both dimensions must be positive'.format(rows, cols))\n        if len(args) == 3 and isinstance(args[2], Callable):\n            op = args[2]\n            flat_list = []\n            for i in range(rows):\n                flat_list.extend([cls._sympify(op(cls._sympify(i), cls._sympify(j))) for j in range(cols)])\n        elif len(args) == 3 and is_sequence(args[2]):\n            flat_list = args[2]\n            if len(flat_list) != rows * cols:\n                raise ValueError('List length should be equal to rows*columns')\n            flat_list = [cls._sympify(i) for i in flat_list]\n    elif len(args) == 0:\n        rows = cols = 0\n        flat_list = []\n    if flat_list is None:\n        raise TypeError('Data type not understood')\n    return (rows, cols, flat_list)",
    ".sympy.matrices.common.py@@MatrixSpecial.entry": "def entry(i, j):\n    return S.Zero",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, integer_types):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.physics.quantum.qexpr.py@@QExpr.label": "def label(self):\n    if len(self.args) == 0:\n        return self._eval_args(list(self.default_args()))\n    else:\n        return self.args",
    ".sympy.physics.quantum.qexpr.py@@QExpr.__new__": "def __new__(cls, *args, **kwargs):\n    args = cls._eval_args(args, **kwargs)\n    if len(args) == 0:\n        args = cls._eval_args(tuple(cls.default_args()), **kwargs)\n    inst = Expr.__new__(cls, *args)\n    inst.hilbert_space = cls._eval_hilbert_space(args)\n    return inst",
    ".sympy.physics.quantum.qubit.py@@IntQubitState._eval_args": "def _eval_args(cls, args, nqubits=None):\n    if len(args) == 1 and isinstance(args[0], QubitState):\n        return QubitState._eval_args(args)\n    elif not all((isinstance(a, (int, Integer)) for a in args)):\n        raise ValueError('values must be integers, got (%s)' % (tuple((type(a) for a in args)),))\n    if nqubits is not None:\n        if not isinstance(nqubits, (int, Integer)):\n            raise ValueError('nqubits must be an integer, got (%s)' % type(nqubits))\n        if len(args) != 1:\n            raise ValueError('too many positional arguments (%s). should be (number, nqubits=n)' % (args,))\n        return cls._eval_args_with_nqubits(args[0], nqubits)\n    if len(args) == 1 and args[0] > 1:\n        rvalues = reversed(range(bitcount(abs(args[0]))))\n        qubit_values = [args[0] >> i & 1 for i in rvalues]\n        return QubitState._eval_args(qubit_values)\n    elif len(args) == 2 and args[1] > 1:\n        return cls._eval_args_with_nqubits(args[0], args[1])\n    else:\n        return QubitState._eval_args(args)",
    ".sympy.physics.quantum.qubit.py@@IntQubitState._eval_args_with_nqubits": "def _eval_args_with_nqubits(cls, number, nqubits):\n    need = bitcount(abs(number))\n    if nqubits < need:\n        raise ValueError('cannot represent %s with %s bits' % (number, nqubits))\n    qubit_values = [number >> i & 1 for i in reversed(range(nqubits))]\n    return QubitState._eval_args(qubit_values)",
    ".sympy.physics.quantum.qubit.py@@QubitState._eval_args": "def _eval_args(cls, args):\n    if len(args) == 1 and isinstance(args[0], QubitState):\n        return args[0].qubit_values\n    if len(args) == 1 and isinstance(args[0], string_types):\n        args = tuple(args[0])\n    args = sympify(args)\n    for element in args:\n        if not (element == 1 or element == 0):\n            raise ValueError('Qubit values must be 0 or 1, got: %r' % element)\n    return args",
    ".sympy.core.compatibility.py@@iterable": "def iterable(i, exclude=(string_types, dict, NotIterable)):\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    ".sympy.physics.quantum.qubit.py@@QubitState._eval_hilbert_space": "def _eval_hilbert_space(cls, args):\n    return ComplexSpace(2) ** len(args)",
    ".sympy.physics.quantum.hilbert.py@@ComplexSpace.__new__": "def __new__(cls, dimension):\n    dimension = sympify(dimension)\n    r = cls.eval(dimension)\n    if isinstance(r, Basic):\n        return r\n    obj = Basic.__new__(cls, dimension)\n    return obj",
    ".sympy.physics.quantum.hilbert.py@@ComplexSpace.eval": "def eval(cls, dimension):\n    if len(dimension.atoms()) == 1:\n        if not (dimension.is_Integer and dimension > 0 or dimension is oo or dimension.is_Symbol):\n            raise TypeError('The dimension of a ComplexSpace can onlybe a positive integer, oo, or a Symbol: %r' % dimension)\n    else:\n        for dim in dimension.atoms():\n            if not (dim.is_Integer or dim is oo or dim.is_Symbol):\n                raise TypeError('The dimension of a ComplexSpace can only contain integers, oo, or a Symbol: %r' % dim)",
    ".sympy.core.basic.py@@Basic.atoms": "def atoms(self, *types):\n    if types:\n        types = tuple([t if isinstance(t, type) else type(t) for t in types])\n    else:\n        types = (Atom,)\n    result = set()\n    for expr in preorder_traversal(self):\n        if isinstance(expr, types):\n            result.add(expr)\n    return result",
    ".sympy.core.basic.py@@preorder_traversal.__init__": "def __init__(self, node, keys=None):\n    self._skip_flag = False\n    self._pt = self._preorder_traversal(node, keys)",
    ".sympy.core.basic.py@@preorder_traversal.__iter__": "def __iter__(self):\n    return self",
    ".sympy.core.basic.py@@preorder_traversal.__next__": "def __next__(self):\n    return next(self._pt)",
    ".sympy.core.basic.py@@preorder_traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            for subtree in self._preorder_traversal(arg, keys):\n                yield subtree\n    elif iterable(node):\n        for item in node:\n            for subtree in self._preorder_traversal(item, keys):\n                yield subtree",
    ".sympy.core.numbers.py@@Integer.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s > %s' % (self, other))\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.logic.boolalg.py@@BooleanTrue.__nonzero__": "def __nonzero__(self):\n    return True",
    ".sympy.physics.quantum.hilbert.py@@HilbertSpace.__pow__": "def __pow__(self, other, mod=None):\n    if mod is not None:\n        raise ValueError('The third argument to __pow__ is not supported         for Hilbert spaces.')\n    return TensorPowerHilbertSpace(self, other)",
    ".sympy.physics.quantum.hilbert.py@@TensorPowerHilbertSpace.__new__": "def __new__(cls, *args):\n    r = cls.eval(args)\n    if isinstance(r, Basic):\n        return r\n    return Basic.__new__(cls, *r)",
    ".sympy.physics.quantum.hilbert.py@@TensorPowerHilbertSpace.eval": "def eval(cls, args):\n    new_args = (args[0], sympify(args[1]))\n    exp = new_args[1]\n    if exp == 1:\n        return args[0]\n    if exp == 0:\n        return sympify(1)\n    if len(exp.atoms()) == 1:\n        if not (exp.is_Integer and exp >= 0 or exp.is_Symbol):\n            raise ValueError('Hilbert spaces can only be raised to             positive integers or Symbols: %r' % exp)\n    else:\n        for power in exp.atoms():\n            if not (power.is_Integer or power.is_Symbol):\n                raise ValueError('Tensor powers can only contain integers                 or Symbols: %r' % power)\n    return new_args",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    tself = type(self)\n    tother = type(other)\n    if type(self) is not type(other):\n        try:\n            other = _sympify(other)\n            tother = type(other)\n        except SympifyError:\n            return NotImplemented\n        if PY3 or type(tself).__ne__ is not type.__ne__:\n            if tself != tother:\n                return False\n        elif tself is not tother:\n            return False\n    return self._hashable_content() == other._hashable_content()",
    ".sympy.core.basic.py@@Basic._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.singleton.py@@Singleton.__call__": "def __call__(self, *args, **kwargs):\n    if self not in Singleton._instances:\n        Singleton._instances[self] = super(Singleton, self).__call__(*args, **kwargs)\n    return Singleton._instances[self]\n\n    def __getnewargs__(self):\n        return ()\n    self.__getnewargs__ = __getnewargs__",
    ".sympy.matrices.dense.py@@MutableDenseMatrix.__setitem__": "def __setitem__(self, key, value):\n    rv = self._setitem(key, value)\n    if rv is not None:\n        i, j, value = rv\n        self._mat[i * self.cols + j] = value",
    ".sympy.matrices.matrices.py@@MatrixBase._setitem": "def _setitem(self, key, value):\n    from .dense import Matrix\n    is_slice = isinstance(key, slice)\n    i, j = key = self.key2ij(key)\n    is_mat = isinstance(value, MatrixBase)\n    if type(i) is slice or type(j) is slice:\n        if is_mat:\n            self.copyin_matrix(key, value)\n            return\n        if not isinstance(value, Expr) and is_sequence(value):\n            self.copyin_list(key, value)\n            return\n        raise ValueError('unexpected value: %s' % value)\n    else:\n        if not is_mat and (not isinstance(value, Basic)) and is_sequence(value):\n            value = Matrix(value)\n            is_mat = True\n        if is_mat:\n            if is_slice:\n                key = (slice(*divmod(i, self.cols)), slice(*divmod(j, self.cols)))\n            else:\n                key = (slice(i, i + value.rows), slice(j, j + value.cols))\n            self.copyin_matrix(key, value)\n        else:\n            return (i, j, self._sympify(value))\n        return",
    ".sympy.matrices.matrices.py@@MatrixBase.key2ij": "def key2ij(self, key):\n    from sympy.matrices.common import a2idx as a2idx_\n    if is_sequence(key):\n        if not len(key) == 2:\n            raise TypeError('key must be a sequence of length 2')\n        return [a2idx_(i, n) if not isinstance(i, slice) else i for i, n in zip(key, self.shape)]\n    elif isinstance(key, slice):\n        return key.indices(len(self))[:2]\n    else:\n        return divmod(a2idx_(key, len(self)), self.cols)",
    ".sympy.core.compatibility.py@@is_sequence": "def is_sequence(i, include=None):\n    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))",
    ".sympy.matrices.common.py@@MatrixShaping.shape": "def shape(self):\n    return (self.rows, self.cols)",
    ".sympy.matrices.common.py@@a2idx": "def a2idx(j, n=None):\n    if type(j) is not int:\n        try:\n            j = j.__index__()\n        except AttributeError:\n            raise IndexError('Invalid index a[%r]' % (j,))\n    if n is not None:\n        if j < 0:\n            j += n\n        if not (j >= 0 and j < n):\n            raise IndexError('Index out of range: a[%s]' % (j,))\n    return int(j)",
    ".sympy.core.numbers.py@@Integer.__ge__": "def __ge__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s >= %s' % (self, other))\n    if other.is_Integer:\n        return _sympify(self.p >= other.p)\n    return Rational.__ge__(self, other)",
    ".sympy.physics.quantum.qubit.py@@QubitState.nqubits": "def nqubits(self):\n    return self.dimension",
    ".sympy.physics.quantum.qubit.py@@QubitState.dimension": "def dimension(self):\n    return len(self.qubit_values)",
    ".sympy.physics.quantum.qubit.py@@QubitState.qubit_values": "def qubit_values(self):\n    return self.label"
}