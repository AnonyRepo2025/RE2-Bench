{
    ".xarray.coding.variables.py@@unpack_for_decoding": "def unpack_for_decoding(var):\n    return (var.dims, var._data, var.attrs.copy(), var.encoding.copy())",
    ".xarray.core.variable.py@@Variable.dims": "def dims(self):\n    return self._dims",
    ".xarray.core.variable.py@@Variable.attrs": "def attrs(self) -> Dict[Hashable, Any]:\n    if self._attrs is None:\n        self._attrs = {}\n    return self._attrs",
    ".xarray.core.variable.py@@Variable.encoding": "def encoding(self):\n    if self._encoding is None:\n        self._encoding = {}\n    return self._encoding",
    ".xarray.coding.variables.py@@pop_to": "def pop_to(source, dest, key, name=None):\n    value = source.pop(key, None)\n    if value is not None:\n        safe_setitem(dest, key, value, name=name)\n    return value",
    ".xarray.coding.variables.py@@safe_setitem": "def safe_setitem(dest, key, value, name=None):\n    if key in dest:\n        var_str = f' on variable {name!r}' if name else ''\n        raise ValueError(\"failed to prevent overwriting existing key {} in attrs{}. This is probably an encoding field used by xarray to describe how a variable is serialized. To proceed, remove this key from the variable's attributes manually.\".format(key, var_str))\n    dest[key] = value",
    ".xarray.coding.variables.py@@lazy_elemwise_func": "def lazy_elemwise_func(array, func, dtype):\n    if is_duck_dask_array(array):\n        import dask.array as da\n        return da.map_blocks(func, array, dtype=dtype)\n    else:\n        return _ElementwiseFunctionArray(array, func, dtype)",
    ".xarray.core.pycompat.py@@is_duck_dask_array": "def is_duck_dask_array(x):\n    return is_duck_array(x) and is_dask_collection(x)",
    ".xarray.core.utils.py@@is_duck_array": "def is_duck_array(value: Any) -> bool:\n    if isinstance(value, np.ndarray):\n        return True\n    return hasattr(value, 'ndim') and hasattr(value, 'shape') and hasattr(value, 'dtype') and hasattr(value, '__array_function__') and hasattr(value, '__array_ufunc__')",
    ".xarray.coding.variables.py@@_ElementwiseFunctionArray.__init__": "def __init__(self, array, func, dtype):\n    assert not is_duck_dask_array(array)\n    self.array = indexing.as_indexable(array)\n    self.func = func\n    self._dtype = dtype",
    ".xarray.core.indexing.py@@as_indexable": "def as_indexable(array):\n    if isinstance(array, ExplicitlyIndexed):\n        return array\n    if isinstance(array, np.ndarray):\n        return NumpyIndexingAdapter(array)\n    if isinstance(array, pd.Index):\n        return PandasIndexAdapter(array)\n    if isinstance(array, dask_array_type):\n        return DaskIndexingAdapter(array)\n    if hasattr(array, '__array_function__'):\n        return NdArrayLikeIndexingAdapter(array)\n    raise TypeError('Invalid array type: {}'.format(type(array)))",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.__init__": "def __init__(self, array):\n    if not isinstance(array, np.ndarray):\n        raise TypeError('NumpyIndexingAdapter only wraps np.ndarray. Trying to wrap {}'.format(type(array)))\n    self.array = array"
}