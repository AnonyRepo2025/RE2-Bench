{
    ".astropy.utils.decorators.py@@lazyproperty.__get__": "def __get__(self, obj, owner=None):\n    try:\n        obj_dict = obj.__dict__\n        val = obj_dict.get(self._key, _NotFound)\n        if val is _NotFound:\n            with self._lock:\n                val = obj_dict.get(self._key, _NotFound)\n                if val is _NotFound:\n                    val = self.fget(obj)\n                    obj_dict[self._key] = val\n        return val\n    except AttributeError:\n        if obj is None:\n            return self\n        raise",
    ".astropy.units.core.py@@_UnitMetaClass.__call__": "def __call__(self, s='', represents=None, format=None, namespace=None, doc=None, parse_strict='raise'):\n    if hasattr(s, '_get_physical_type_id'):\n        return s\n    from .quantity import Quantity\n    if isinstance(represents, Quantity):\n        if is_effectively_unity(represents.value):\n            represents = represents.unit\n        else:\n            represents = CompositeUnit(represents.value * represents.unit.scale, bases=represents.unit.bases, powers=represents.unit.powers, _error_check=False)\n    if isinstance(s, Quantity):\n        if is_effectively_unity(s.value):\n            s = s.unit\n        else:\n            s = CompositeUnit(s.value * s.unit.scale, bases=s.unit.bases, powers=s.unit.powers, _error_check=False)\n    if isinstance(represents, UnitBase):\n        return super().__call__(s, represents, format=format, namespace=namespace, doc=doc)\n    if isinstance(s, UnitBase):\n        return s\n    elif isinstance(s, (bytes, str)):\n        if len(s.strip()) == 0:\n            return dimensionless_unscaled\n        if format is None:\n            format = unit_format.Generic\n        f = unit_format.get_format(format)\n        if isinstance(s, bytes):\n            s = s.decode('ascii')\n        try:\n            return f.parse(s)\n        except NotImplementedError:\n            raise\n        except Exception as e:\n            if parse_strict == 'silent':\n                pass\n            else:\n                if f is not unit_format.Generic:\n                    format_clause = f.name + ' '\n                else:\n                    format_clause = ''\n                msg = f\"'{s}' did not parse as {format_clause}unit: {str(e)} If this is meant to be a custom unit, define it with 'u.def_unit'. To have it recognized inside a file reader or other code, enable it with 'u.add_enabled_units'. For details, see https://docs.astropy.org/en/latest/units/combining_and_defining.html\"\n                if parse_strict == 'raise':\n                    raise ValueError(msg)\n                elif parse_strict == 'warn':\n                    warnings.warn(msg, UnitsWarning)\n                else:\n                    raise ValueError(\"'parse_strict' must be 'warn', 'raise' or 'silent'\")\n            return UnrecognizedUnit(s)\n    elif isinstance(s, (int, float, np.floating, np.integer)):\n        return CompositeUnit(s, [], [], _error_check=False)\n    elif isinstance(s, tuple):\n        from .structured import StructuredUnit\n        return StructuredUnit(s)\n    elif s is None:\n        raise TypeError('None is not a valid Unit')\n    else:\n        raise TypeError(f'{s} can not be converted to a Unit')",
    ".astropy.constants.constant.py@@Constant.__quantity_subclass__": "def __quantity_subclass__(self, unit):\n    return (super().__quantity_subclass__(unit)[0], False)",
    ".astropy.units.utils.py@@is_effectively_unity": "def is_effectively_unity(value):\n    try:\n        return _JUST_BELOW_UNITY <= value <= _JUST_ABOVE_UNITY\n    except TypeError:\n        return _JUST_BELOW_UNITY <= value.real <= _JUST_ABOVE_UNITY and _JUST_BELOW_UNITY <= value.imag + 1 <= _JUST_ABOVE_UNITY",
    ".astropy.units.core.py@@CompositeUnit.scale": "def scale(self):\n    return self._scale",
    ".astropy.units.core.py@@CompositeUnit.bases": "def bases(self):\n    return self._bases",
    ".astropy.units.core.py@@CompositeUnit.powers": "def powers(self):\n    return self._powers",
    ".astropy.units.core.py@@CompositeUnit.__init__": "def __init__(self, scale, bases, powers, decompose=False, decompose_bases=set(), _error_check=True):\n    if _error_check:\n        for base in bases:\n            if not isinstance(base, UnitBase):\n                raise TypeError('bases must be sequence of UnitBase instances')\n        powers = [validate_power(p) for p in powers]\n    if not decompose and len(bases) == 1 and (powers[0] >= 0):\n        unit = bases[0]\n        power = powers[0]\n        if power == 1:\n            scale *= unit.scale\n            self._bases = unit.bases\n            self._powers = unit.powers\n        elif power == 0:\n            self._bases = []\n            self._powers = []\n        else:\n            scale *= unit.scale ** power\n            self._bases = unit.bases\n            self._powers = [operator.mul(*resolve_fractions(p, power)) for p in unit.powers]\n        self._scale = sanitize_scale(scale)\n    else:\n        self._scale = scale\n        self._bases = bases\n        self._powers = powers\n        self._expand_and_gather(decompose=decompose, bases=decompose_bases)",
    ".astropy.units.core.py@@UnitBase.scale": "def scale(self):\n    return 1.0",
    ".astropy.units.core.py@@UnitBase.bases": "def bases(self):\n    return [self]",
    ".astropy.units.core.py@@UnitBase.powers": "def powers(self):\n    return [1]",
    ".astropy.units.utils.py@@sanitize_scale": "def sanitize_scale(scale):\n    if is_effectively_unity(scale):\n        return 1.0\n    if scale.__class__ is float:\n        return scale\n    if hasattr(scale, 'dtype'):\n        scale = scale.item()\n    if scale.imag:\n        if abs(scale.real) > abs(scale.imag):\n            if is_effectively_unity(scale.imag / scale.real + 1):\n                return scale.real\n        elif is_effectively_unity(scale.real / scale.imag + 1):\n            return complex(0.0, scale.imag)\n        return scale\n    else:\n        return scale.real",
    ".astropy.units.core.py@@CompositeUnit._expand_and_gather": "def _expand_and_gather(self, decompose=False, bases=set()):\n\n    def add_unit(unit, power, scale):\n        if bases and unit not in bases:\n            for base in bases:\n                try:\n                    scale *= unit._to(base) ** power\n                except UnitsError:\n                    pass\n                else:\n                    unit = base\n                    break\n        if unit in new_parts:\n            a, b = resolve_fractions(new_parts[unit], power)\n            new_parts[unit] = a + b\n        else:\n            new_parts[unit] = power\n        return scale\n    new_parts = {}\n    scale = self._scale\n    for b, p in zip(self._bases, self._powers):\n        if decompose and b not in bases:\n            b = b.decompose(bases=bases)\n        if isinstance(b, CompositeUnit):\n            scale *= b._scale ** p\n            for b_sub, p_sub in zip(b._bases, b._powers):\n                a, b = resolve_fractions(p_sub, p)\n                scale = add_unit(b_sub, a * b, scale)\n        else:\n            scale = add_unit(b, p, scale)\n    new_parts = [x for x in new_parts.items() if x[1] != 0]\n    new_parts.sort(key=lambda x: (-x[1], getattr(x[0], 'name', '')))\n    self._bases = [x[0] for x in new_parts]\n    self._powers = [x[1] for x in new_parts]\n    self._scale = sanitize_scale(scale)",
    ".astropy.units.core.py@@CompositeUnit.add_unit": "def add_unit(unit, power, scale):\n    if bases and unit not in bases:\n        for base in bases:\n            try:\n                scale *= unit._to(base) ** power\n            except UnitsError:\n                pass\n            else:\n                unit = base\n                break\n    if unit in new_parts:\n        a, b = resolve_fractions(new_parts[unit], power)\n        new_parts[unit] = a + b\n    else:\n        new_parts[unit] = power\n    return scale",
    ".astropy.units.core.py@@Unit.__hash__": "def __hash__(self):\n    if self._hash is None:\n        self._hash = hash((self.name, self._represents))\n    return self._hash",
    ".astropy.units.core.py@@UnitBase.__hash__": "def __hash__(self):\n    if self._hash is None:\n        parts = [str(self.scale)] + [x.name for x in self.bases] + [str(x) for x in self.powers]\n        self._hash = hash(tuple(parts))\n    return self._hash",
    ".astropy.units.core.py@@NamedUnit.name": "def name(self):\n    return self._names[0]",
    ".astropy.utils.data_info.py@@DataInfo.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        self._parent_cls = owner_cls\n        return self\n    info = instance.__dict__.get('info')\n    if info is None:\n        info = instance.__dict__['info'] = self.__class__(bound=True)\n    info._parent_ref = weakref.ref(instance)\n    return info",
    ".astropy.utils.data_info.py@@BaseColumnInfo.__set__": "def __set__(self, instance, value):\n    try:\n        if not instance.shape:\n            return\n    except AttributeError:\n        pass\n    super().__set__(instance, value)",
    ".astropy.utils.data_info.py@@DataInfo.__set__": "def __set__(self, instance, value):\n    if instance is None:\n        raise ValueError('cannot set unbound descriptor')\n    if isinstance(value, DataInfo):\n        info = instance.__dict__['info'] = self.__class__(bound=True)\n        attr_names = info.attr_names\n        if value.__class__ is self.__class__:\n            attr_names = attr_names & set(value._attrs)\n        else:\n            attr_names = attr_names & value.attr_names - value._attrs_no_copy\n        for attr in attr_names - info.attrs_from_parent - info._attrs_no_copy:\n            info._attrs[attr] = deepcopy(getattr(value, attr))\n    else:\n        raise TypeError('info must be set with a DataInfo instance')",
    ".astropy.utils.data_info.py@@BaseColumnInfo.__init__": "def __init__(self, bound=False):\n    super().__init__(bound=bound)\n    if bound:\n        self._format_funcs = {}",
    ".astropy.utils.data_info.py@@DataInfo.__init__": "def __init__(self, bound=False):\n    if bound:\n        self._attrs = {}",
    ".astropy.utils.data_info.py@@InfoAttribute.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        return self\n    return instance._attrs.get(self.attr, self.default)",
    ".astropy.utils.data_info.py@@MixinInfo.name": "def name(self):\n    return self._attrs.get('name')",
    ".astropy.units.function.logarithmic.py@@DexUnit._quantity_class": "def _quantity_class(self):\n    return Dex",
    ".astropy.units.function.core.py@@FunctionQuantity.__quantity_subclass__": "def __quantity_subclass__(self, unit):\n    if isinstance(unit, FunctionUnitBase):\n        return (self.__class__, True)\n    else:\n        return (super().__quantity_subclass__(unit)[0], False)",
    ".astropy.units.function.core.py@@FunctionQuantity._set_unit": "def _set_unit(self, unit):\n    if not isinstance(unit, self._unit_class):\n        try:\n            unit = self._unit_class(function_unit=unit or 'nonsense')\n        except Exception:\n            raise UnitTypeError(f\"{type(self).__name__} instances require {self._unit_class.__name__} function units, so cannot set it to '{unit}'.\")\n    self._unit = unit",
    ".astropy.units.quantity.py@@SpecificTypeQuantity.__quantity_subclass__": "def __quantity_subclass__(self, unit):\n    if unit.is_equivalent(self._equivalent_unit):\n        return (type(self), True)\n    else:\n        return (super().__quantity_subclass__(unit)[0], False)",
    ".astropy.units.core.py@@UnitBase.is_equivalent": "def is_equivalent(self, other, equivalencies=[]):\n    equivalencies = self._normalize_equivalencies(equivalencies)\n    if isinstance(other, tuple):\n        return any((self.is_equivalent(u, equivalencies) for u in other))\n    other = Unit(other, parse_strict='silent')\n    return self._is_equivalent(other, equivalencies)",
    ".astropy.units.core.py@@UnitBase._normalize_equivalencies": "def _normalize_equivalencies(equivalencies):\n    normalized = _normalize_equivalencies(equivalencies)\n    if equivalencies is not None:\n        normalized += get_current_unit_registry().equivalencies\n    return normalized",
    ".astropy.units.core.py@@_normalize_equivalencies": "def _normalize_equivalencies(equivalencies):\n    if equivalencies is None:\n        return []\n    normalized = []\n    for i, equiv in enumerate(equivalencies):\n        if len(equiv) == 2:\n            funit, tunit = equiv\n            a = b = lambda x: x\n        elif len(equiv) == 3:\n            funit, tunit, a = equiv\n            b = a\n        elif len(equiv) == 4:\n            funit, tunit, a, b = equiv\n        else:\n            raise ValueError(f'Invalid equivalence entry {i}: {equiv!r}')\n        if not (funit is Unit(funit) and (tunit is None or tunit is Unit(tunit)) and callable(a) and callable(b)):\n            raise ValueError(f'Invalid equivalence entry {i}: {equiv!r}')\n        normalized.append((funit, tunit, a, b))\n    return normalized",
    ".astropy.units.core.py@@get_current_unit_registry": "def get_current_unit_registry():\n    return _unit_registries[-1]",
    ".astropy.units.core.py@@_UnitRegistry.equivalencies": "def equivalencies(self):\n    return list(self._equivalencies)",
    ".astropy.units.core.py@@UnitBase._is_equivalent": "def _is_equivalent(self, other, equivalencies=[]):\n    if isinstance(other, UnrecognizedUnit):\n        return False\n    if self._get_physical_type_id() == other._get_physical_type_id():\n        return True\n    elif len(equivalencies):\n        unit = self.decompose()\n        other = other.decompose()\n        for a, b, forward, backward in equivalencies:\n            if b is None:\n                try:\n                    (other / unit).decompose([a])\n                    return True\n                except Exception:\n                    pass\n            elif a._is_equivalent(unit) and b._is_equivalent(other) or (b._is_equivalent(unit) and a._is_equivalent(other)):\n                return True\n    return False",
    ".astropy.units.core.py@@UnitBase._get_physical_type_id": "def _get_physical_type_id(self):\n    if self._type_id is None:\n        unit = self.decompose()\n        self._type_id = tuple(zip((base.name for base in unit.bases), unit.powers))\n    return self._type_id",
    ".astropy.units.quantity.py@@SpecificTypeQuantity._set_unit": "def _set_unit(self, unit):\n    if unit is None or not unit.is_equivalent(self._equivalent_unit):\n        raise UnitTypeError(\"{} instances require units equivalent to '{}'\".format(type(self).__name__, self._equivalent_unit) + (', but no unit was given.' if unit is None else f\", so cannot set it to '{unit}'.\"))\n    super()._set_unit(unit)",
    ".astropy.units.core.py@@CompositeUnit.decompose": "def decompose(self, bases=set()):\n    if len(bases) == 0 and self._decomposed_cache is not None:\n        return self._decomposed_cache\n    for base in self.bases:\n        if not isinstance(base, IrreducibleUnit) or (len(bases) and base not in bases):\n            break\n    else:\n        if len(bases) == 0:\n            self._decomposed_cache = self\n        return self\n    x = CompositeUnit(self.scale, self.bases, self.powers, decompose=True, decompose_bases=bases)\n    if len(bases) == 0:\n        self._decomposed_cache = x\n    return x",
    ".astropy.units.utils.py@@validate_power": "def validate_power(p):\n    denom = getattr(p, 'denominator', None)\n    if denom is None:\n        try:\n            p = float(p)\n        except Exception:\n            if not np.isscalar(p):\n                raise ValueError('Quantities and Units may only be raised to a scalar power')\n            else:\n                raise\n        p = maybe_simple_fraction(p)\n        if isinstance(p, float):\n            return p\n        denom = p.denominator\n    if denom == 1:\n        p = p.numerator\n    elif denom & denom - 1 == 0:\n        p = float(p)\n    return p",
    ".astropy.units.core.py@@Unit.decompose": "def decompose(self, bases=set()):\n    return self._represents.decompose(bases=bases)",
    ".astropy.units.utils.py@@resolve_fractions": "def resolve_fractions(a, b):\n    a_is_fraction = a.__class__ is not int and a.__class__ is not float and isinstance(a, Fraction)\n    b_is_fraction = b.__class__ is not int and b.__class__ is not float and isinstance(b, Fraction)\n    if a_is_fraction and (not b_is_fraction):\n        b = maybe_simple_fraction(b)\n    elif not a_is_fraction and b_is_fraction:\n        a = maybe_simple_fraction(a)\n    return (a, b)",
    ".astropy.units.core.py@@IrreducibleUnit.decompose": "def decompose(self, bases=set()):\n    if len(bases) and self not in bases:\n        for base in bases:\n            try:\n                scale = self._to(base)\n            except UnitsError:\n                pass\n            else:\n                if is_effectively_unity(scale):\n                    return base\n                else:\n                    return CompositeUnit(scale, [base], [1], _error_check=False)\n        raise UnitConversionError(f'Unit {self} can not be decomposed into the requested bases')\n    return self",
    ".astropy.units.structured.py@@StructuredUnit.__new__": "def __new__(cls, units, names=None):\n    dtype = None\n    if names is not None:\n        if isinstance(names, StructuredUnit):\n            dtype = names._units.dtype\n            names = names.field_names\n        elif isinstance(names, np.dtype):\n            if not names.fields:\n                raise ValueError('dtype should be structured, with fields.')\n            dtype = np.dtype([(name, DTYPE_OBJECT) for name in names.names])\n            names = _names_from_dtype(names)\n        else:\n            if not isinstance(names, tuple):\n                names = (names,)\n            names = _normalize_names(names)\n    if not isinstance(units, tuple):\n        units = Unit(units)\n        if isinstance(units, StructuredUnit):\n            if names is None or units.field_names == names:\n                return units\n            units = units.values()\n        else:\n            units = (units,)\n    if names is None:\n        names = tuple((f'f{i}' for i in range(len(units))))\n    elif len(units) != len(names):\n        raise ValueError('lengths of units and field names must match.')\n    converted = []\n    for unit, name in zip(units, names):\n        if isinstance(name, list):\n            unit = cls(unit, name[1])\n            name = name[0]\n        else:\n            unit = Unit(unit)\n            if dtype is not None and isinstance(unit, StructuredUnit):\n                raise ValueError('units do not match in depth with field names from dtype or structured unit.')\n        converted.append(unit)\n    self = super().__new__(cls)\n    if dtype is None:\n        dtype = np.dtype([(name[0] if isinstance(name, list) else name, DTYPE_OBJECT) for name in names])\n    self._units = np.array(tuple(converted), dtype)[()]\n    return self",
    ".astropy.units.structured.py@@_names_from_dtype": "def _names_from_dtype(dtype):\n    names = []\n    for name in dtype.names:\n        subdtype = dtype.fields[name][0]\n        if subdtype.names:\n            names.append([name, _names_from_dtype(subdtype)])\n        else:\n            names.append(name)\n    return tuple(names)",
    ".astropy.units.structured.py@@StructuredUnit.field_names": "def field_names(self):\n    return tuple(([name, unit.field_names] if isinstance(unit, StructuredUnit) else name for name, unit in self.items()))",
    ".astropy.units.structured.py@@StructuredUnit.items": "def items(self):\n    return tuple(zip(self._units.dtype.names, self._units.item()))"
}