{
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.relational.py@@is_eq": "def is_eq(lhs, rhs, assumptions=None):\n    from sympy.assumptions.wrapper import AssumptionsWrapper, is_infinite, is_extended_real\n    from sympy.core.add import Add\n    from sympy.functions.elementary.complexes import arg\n    from sympy.simplify.simplify import clear_coefficients\n    from sympy.utilities.iterables import sift\n    for side1, side2 in ((lhs, rhs), (rhs, lhs)):\n        eval_func = getattr(side1, '_eval_Eq', None)\n        if eval_func is not None:\n            retval = eval_func(side2)\n            if retval is not None:\n                return retval\n    retval = _eval_is_eq(lhs, rhs)\n    if retval is not None:\n        return retval\n    if dispatch(type(lhs), type(rhs)) != dispatch(type(rhs), type(lhs)):\n        retval = _eval_is_eq(rhs, lhs)\n        if retval is not None:\n            return retval\n    if lhs == rhs:\n        return True\n    elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):\n        return False\n    elif not (lhs.is_Symbol or rhs.is_Symbol) and isinstance(lhs, Boolean) != isinstance(rhs, Boolean):\n        return False\n    _lhs = AssumptionsWrapper(lhs, assumptions)\n    _rhs = AssumptionsWrapper(rhs, assumptions)\n    if _lhs.is_infinite or _rhs.is_infinite:\n        if fuzzy_xor([_lhs.is_infinite, _rhs.is_infinite]):\n            return False\n        if fuzzy_xor([_lhs.is_extended_real, _rhs.is_extended_real]):\n            return False\n        if fuzzy_and([_lhs.is_extended_real, _rhs.is_extended_real]):\n            return fuzzy_xor([lhs.is_extended_positive, fuzzy_not(rhs.is_extended_positive)])\n        I = S.ImaginaryUnit\n\n        def split_real_imag(expr):\n            real_imag = lambda t: 'real' if is_extended_real(t, assumptions) else 'imag' if is_extended_real(I * t, assumptions) else None\n            return sift(Add.make_args(expr), real_imag)\n        lhs_ri = split_real_imag(lhs)\n        if not lhs_ri[None]:\n            rhs_ri = split_real_imag(rhs)\n            if not rhs_ri[None]:\n                eq_real = is_eq(Add(*lhs_ri['real']), Add(*rhs_ri['real']), assumptions)\n                eq_imag = is_eq(I * Add(*lhs_ri['imag']), I * Add(*rhs_ri['imag']), assumptions)\n                return fuzzy_and(map(fuzzy_bool, [eq_real, eq_imag]))\n        arglhs = arg(lhs)\n        argrhs = arg(rhs)\n        if not (arglhs == S.NaN and argrhs == S.NaN):\n            return fuzzy_bool(is_eq(arglhs, argrhs, assumptions))\n    if all((isinstance(i, Expr) for i in (lhs, rhs))):\n        dif = lhs - rhs\n        _dif = AssumptionsWrapper(dif, assumptions)\n        z = _dif.is_zero\n        if z is not None:\n            if z is False and _dif.is_commutative:\n                return False\n            if z:\n                return True\n        n2 = _n2(lhs, rhs)\n        if n2 is not None:\n            return _sympify(n2 == 0)\n        n, d = dif.as_numer_denom()\n        rv = None\n        _n = AssumptionsWrapper(n, assumptions)\n        _d = AssumptionsWrapper(d, assumptions)\n        if _n.is_zero:\n            rv = _d.is_nonzero\n        elif _n.is_finite:\n            if _d.is_infinite:\n                rv = True\n            elif _n.is_zero is False:\n                rv = _d.is_infinite\n                if rv is None:\n                    l, r = clear_coefficients(d, S.Infinity)\n                    args = [_.subs(l, r) for _ in (lhs, rhs)]\n                    if args != [lhs, rhs]:\n                        rv = fuzzy_bool(is_eq(*args, assumptions))\n                        if rv is True:\n                            rv = None\n        elif any((is_infinite(a, assumptions) for a in Add.make_args(n))):\n            rv = False\n        if rv is not None:\n            return rv",
    ".sympy.assumptions.wrapper.py@@AssumptionsWrapperMeta.__init__": "def __init__(cls, *args, **kws):\n    for fact in _assume_defined:\n        pname = '_eval_%s' % as_property(fact)\n        setattr(cls, pname, make_eval_method(fact))\n    super().__init__(cls, *args, **kws)",
    ".sympy.core.assumptions.py@@as_property": "def as_property(fact):\n    return 'is_%s' % fact",
    ".sympy.assumptions.wrapper.py@@make_eval_method": "def make_eval_method(fact):\n\n    def getit(self):\n        try:\n            pred = getattr(Q, fact)\n            ret = ask(pred(self.expr), self.assumptions)\n            return ret\n        except AttributeError:\n            return None\n    return getit",
    ".sympy.core.assumptions.py@@ManagedProperties.__init__": "def __init__(cls, *args, **kws):\n    BasicMeta.__init__(cls, *args, **kws)\n    local_defs = {}\n    for k in _assume_defined:\n        attrname = as_property(k)\n        v = cls.__dict__.get(attrname, '')\n        if isinstance(v, (bool, int, type(None))):\n            if v is not None:\n                v = bool(v)\n            local_defs[k] = v\n    defs = {}\n    for base in reversed(cls.__bases__):\n        assumptions = getattr(base, '_explicit_class_assumptions', None)\n        if assumptions is not None:\n            defs.update(assumptions)\n    defs.update(local_defs)\n    cls._explicit_class_assumptions = defs\n    cls.default_assumptions = StdFactKB(defs)\n    cls._prop_handler = {}\n    for k in _assume_defined:\n        eval_is_meth = getattr(cls, '_eval_is_%s' % k, None)\n        if eval_is_meth is not None:\n            cls._prop_handler[k] = eval_is_meth\n    for k, v in cls.default_assumptions.items():\n        setattr(cls, as_property(k), v)\n    derived_from_bases = set()\n    for base in cls.__bases__:\n        default_assumptions = getattr(base, 'default_assumptions', None)\n        if default_assumptions is not None:\n            derived_from_bases.update(default_assumptions)\n    for fact in derived_from_bases - set(cls.default_assumptions):\n        pname = as_property(fact)\n        if pname not in cls.__dict__:\n            setattr(cls, pname, make_property(fact))\n    for fact in _assume_defined:\n        pname = as_property(fact)\n        if not hasattr(cls, pname):\n            setattr(cls, pname, make_property(fact))",
    ".sympy.core.core.py@@BasicMeta.__init__": "def __init__(cls, *args, **kws):\n    all_classes.add(cls)\n    cls.__sympy__ = property(lambda self: True)",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    super().__init__(_assume_rules)\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.__init__": "def __init__(self, rules):\n    self.rules = rules",
    ".sympy.multipledispatch.dispatcher.py@@Dispatcher.__call__": "def __call__(self, *args, **kwargs):\n    types = tuple([type(arg) for arg in args])\n    try:\n        func = self._cache[types]\n    except KeyError:\n        func = self.dispatch(*types)\n        if not func:\n            raise NotImplementedError('Could not find signature for %s: <%s>' % (self.name, str_signature(types)))\n        self._cache[types] = func\n    try:\n        return func(*args, **kwargs)\n    except MDNotImplementedError:\n        funcs = self.dispatch_iter(*types)\n        next(funcs)\n        for func in funcs:\n            try:\n                return func(*args, **kwargs)\n            except MDNotImplementedError:\n                pass\n        raise NotImplementedError('Matching functions for %s: <%s> found, but none completed successfully' % (self.name, str_signature(types)))",
    ".sympy.multipledispatch.dispatcher.py@@Dispatcher.dispatch": "def dispatch(self, *types):\n    if types in self.funcs:\n        return self.funcs[types]\n    try:\n        return next(self.dispatch_iter(*types))\n    except StopIteration:\n        return None",
    ".sympy.multipledispatch.dispatcher.py@@Dispatcher.dispatch_iter": "def dispatch_iter(self, *types):\n    n = len(types)\n    for signature in self.ordering:\n        if len(signature) == n and all(map(issubclass, types, signature)):\n            result = self.funcs[signature]\n            yield result",
    ".sympy.core.relational.py@@_eval_is_eq": "def _eval_is_eq(lhs, rhs):\n    return None",
    ".sympy.multipledispatch.core.py@@dispatch": "def dispatch(*types, namespace=global_namespace, on_ambiguity=ambiguity_warn):\n    types = tuple(types)\n\n    def _(func):\n        name = func.__name__\n        if ismethod(func):\n            dispatcher = inspect.currentframe().f_back.f_locals.get(name, MethodDispatcher(name))\n        else:\n            if name not in namespace:\n                namespace[name] = Dispatcher(name)\n            dispatcher = namespace[name]\n        dispatcher.add(types, func, on_ambiguity=on_ambiguity)\n        return dispatcher\n    return _",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.assumptions.wrapper.py@@AssumptionsWrapper.__new__": "def __new__(cls, expr, assumptions=None):\n    if assumptions is None:\n        return expr\n    obj = super().__new__(cls, expr, assumptions)\n    obj.expr = expr\n    obj.assumptions = assumptions\n    return obj",
    ".sympy.core.numbers.py@@Integer.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, str):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    if ival == 1:\n        return S.One\n    if ival == -1:\n        return S.NegativeOne\n    if ival == 0:\n        return S.Zero\n    obj = Expr.__new__(cls)\n    obj.p = ival\n    return obj",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.assumptions.py@@StdFactKB.copy": "def copy(self):\n    return self.__class__(self)",
    ".sympy.core.assumptions.py@@StdFactKB.generator": "def generator(self):\n    return self._generator.copy()",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.assumptions.py@@_ask": "def _ask(fact, obj):\n    assumptions = obj._assumptions\n    handler_map = obj._prop_handler\n    assumptions._tell(fact, None)\n    try:\n        evaluate = handler_map[fact]\n    except KeyError:\n        pass\n    else:\n        a = evaluate(obj)\n        if a is not None:\n            assumptions.deduce_all_facts(((fact, a),))\n            return a\n    prereq = list(_assume_rules.prereq[fact])\n    shuffle(prereq)\n    for pk in prereq:\n        if pk in assumptions:\n            continue\n        if pk in handler_map:\n            _ask(pk, obj)\n            ret_val = assumptions.get(fact)\n            if ret_val is not None:\n                return ret_val\n    return None",
    ".sympy.core.numbers.py@@Rational._eval_is_zero": "def _eval_is_zero(self):\n    return self.p == 0",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    from sympy.core.power import integer_log\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if not isinstance(other, Number):\n        return False\n    if not self:\n        return not other\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Rational:\n        return self.p == other.p and self.q == other.q\n    if other.is_Float:\n        if self.q & self.q - 1:\n            return False\n        s, m, t = other._mpf_[:3]\n        if s:\n            m = -m\n        if not t:\n            if not self.is_Integer or self.is_even:\n                return False\n            return m == self.p\n        if t > 0:\n            if not self.is_Integer:\n                return False\n            return self.p and (not self.p % m) and (integer_log(self.p // m, 2) == (t, True))\n        if self.is_Integer:\n            return False\n        return m == self.p and integer_log(self.q, 2) == (-t, True)\n    return False",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    cls = getattr(a, '__class__', None)\n    if cls is None:\n        cls = type(a)\n    conv = converter.get(cls, None)\n    if conv is not None:\n        return conv(a)\n    for superclass in getmro(cls):\n        try:\n            return converter[superclass](a)\n        except KeyError:\n            continue\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from ..tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(), locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        else:\n            for coerce in (float, int):\n                try:\n                    return sympify(coerce(a))\n                except (TypeError, ValueError, AttributeError, SympifyError):\n                    continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    if not isinstance(a, str):\n        try:\n            a = str(a)\n        except Exception as exc:\n            raise SympifyError(a, exc)\n        from sympy.utilities.exceptions import SymPyDeprecationWarning\n        SymPyDeprecationWarning(feature='String fallback in sympify', useinstead='sympify(str(obj)) or ' + 'sympy.core.sympify.converter or obj._sympy_', issue=18066, deprecated_since_version='1.6').warn()\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.numbers.py@@Zero.__bool__": "def __bool__(self):\n    return False",
    ".sympy.core.logic.py@@fuzzy_xor": "def fuzzy_xor(args):\n    t = f = 0\n    for a in args:\n        ai = fuzzy_bool(a)\n        if ai:\n            t += 1\n        elif ai is False:\n            f += 1\n        else:\n            return\n    return t % 2 == 1",
    ".sympy.core.logic.py@@fuzzy_bool": "def fuzzy_bool(x):\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)"
}