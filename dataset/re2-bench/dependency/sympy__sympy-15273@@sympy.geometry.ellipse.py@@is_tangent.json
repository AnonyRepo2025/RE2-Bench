{
    ".sympy.geometry.ellipse.py@@Circle.intersection": "def intersection(self, o):\n    return Ellipse.intersection(self, o)",
    ".sympy.core.symbol.py@@Dummy.__new__": "def __new__(cls, name=None, dummy_index=None, **assumptions):\n    if dummy_index is not None:\n        assert name is not None, 'If you specify a dummy_index, you must also provide a name'\n    if name is None:\n        name = 'Dummy_' + str(Dummy._count)\n    if dummy_index is None:\n        dummy_index = Dummy._base_dummy_index + Dummy._count\n        Dummy._count += 1\n    cls._sanitize(assumptions, cls)\n    obj = Symbol.__xnew__(cls, name, **assumptions)\n    obj.dummy_index = dummy_index\n    return obj",
    ".sympy.core.symbol.py@@Symbol._sanitize": "def _sanitize(assumptions, obj=None):\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    if is_commutative is None:\n        whose = '%s ' % obj.__name__ if obj else ''\n        raise ValueError('%scommutativity must be True or False.' % whose)\n    for key in list(assumptions.keys()):\n        from collections import defaultdict\n        from sympy.utilities.exceptions import SymPyDeprecationWarning\n        keymap = defaultdict(lambda: None)\n        keymap.update({'bounded': 'finite', 'unbounded': 'infinite', 'infinitesimal': 'zero'})\n        if keymap[key]:\n            SymPyDeprecationWarning(feature='%s assumption' % key, useinstead='%s' % keymap[key], issue=8071, deprecated_since_version='0.7.6').warn()\n            assumptions[keymap[key]] = assumptions[key]\n            assumptions.pop(key)\n            key = keymap[key]\n        v = assumptions[key]\n        if v is None:\n            assumptions.pop(key)\n            continue\n        assumptions[key] = bool(v)",
    ".sympy.core.logic.py@@fuzzy_bool": "def fuzzy_bool(x):\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    ".sympy.core.symbol.py@@Symbol.__new_stage2__": "def __new_stage2__(cls, name, **assumptions):\n    if not isinstance(name, string_types):\n        raise TypeError('name should be a string, not %s' % repr(type(name)))\n    obj = Expr.__new__(cls)\n    obj.name = name\n    tmp_asm_copy = assumptions.copy()\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    assumptions['commutative'] = is_commutative\n    obj._assumptions = StdFactKB(assumptions)\n    obj._assumptions._generator = tmp_asm_copy\n    return obj",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.geometry.point.py@@Point.__eq__": "def __eq__(self, other):\n    if not isinstance(other, Point) or len(self.args) != len(other.args):\n        return False\n    return self.args == other.args",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, integer_types):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.geometry.ellipse.py@@Circle.vradius": "def vradius(self):\n    return abs(self.radius)",
    ".sympy.geometry.ellipse.py@@Circle.radius": "def radius(self):\n    return self.args[1]",
    ".sympy.core.numbers.py@@One.__abs__": "def __abs__():\n    return S.One",
    ".sympy.geometry.ellipse.py@@Circle.equation": "def equation(self, x='x', y='y'):\n    x = _symbol(x, real=True)\n    y = _symbol(y, real=True)\n    t1 = (x - self.center.x) ** 2\n    t2 = (y - self.center.y) ** 2\n    return t1 + t2 - self.major ** 2",
    ".sympy.core.symbol.py@@_symbol": "def _symbol(s, matching_symbol=None, **assumptions):\n    if isinstance(s, string_types):\n        if matching_symbol and matching_symbol.name == s:\n            return matching_symbol\n        return Symbol(s, **assumptions)\n    elif isinstance(s, Symbol):\n        return s\n    else:\n        raise ValueError('symbol must be string for symbol name or Symbol')",
    ".sympy.geometry.point.py@@Point2D.x": "def x(self):\n    return self.args[0]",
    ".sympy.core.decorators.py@@__sympifyit_wrapper": "def __sympifyit_wrapper(a, b):\n    try:\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    ".sympy.core.decorators.py@@binary_op_wrapper": "def binary_op_wrapper(self, other):\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:\n            try:\n                f = getattr(other, method_name)\n            except AttributeError:\n                pass\n            else:\n                return f(self)\n    return func(self, other)",
    ".sympy.core.expr.py@@Expr.__sub__": "def __sub__(self, other):\n    return Add(self, -other)",
    ".sympy.core.numbers.py@@Zero.__neg__": "def __neg__():\n    return S.Zero",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, **options):\n    from sympy import Order\n    args = list(map(_sympify, args))\n    args = [a for a in args if a is not cls.identity]\n    evaluate = options.get('evaluate')\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    if not evaluate:\n        return cls._from_args(args)\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if order_symbols is not None:\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    if evaluate is None:\n        if global_evaluate[0] is False:\n            evaluate = global_evaluate[0]\n        else:\n            evaluate = True\n    try:\n        if a in sympy_classes:\n            return a\n    except TypeError:\n        pass\n    try:\n        cls = a.__class__\n    except AttributeError:\n        cls = type(a)\n    if cls in sympy_classes:\n        return a\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if type(a).__module__ == 'numpy':\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    try:\n        return converter[cls](a)\n    except KeyError:\n        for superclass in getmro(cls):\n            try:\n                return converter[superclass](a)\n            except KeyError:\n                continue\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    try:\n        return a._sympy_()\n    except AttributeError:\n        pass\n    if not strict:\n        try:\n            from ..tensor.array import Array\n            return Array(a.flat, a.shape)\n        except AttributeError:\n            pass\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                return sympify(coerce(a))\n            except (TypeError, ValueError, AttributeError, SympifyError):\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.symbol.py@@Dummy._hashable_content": "def _hashable_content(self):\n    return Symbol._hashable_content(self) + (self.dummy_index,)",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return dict(((key, value) for key, value in self._assumptions.items() if value is not None))",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.expr.py@@Expr.__pow__": "def __pow__(self, other, mod=None):\n    if mod is None:\n        return self._pow(other)\n    try:\n        _self, other, mod = (as_int(self), as_int(other), as_int(mod))\n        if other >= 0:\n            return pow(_self, other, mod)\n        else:\n            from sympy.core.numbers import mod_inverse\n            return mod_inverse(pow(_self, -other, mod), mod)\n    except ValueError:\n        power = self._pow(other)\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, string_types):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    try:\n        return _intcache[ival]\n    except KeyError:\n        obj = Expr.__new__(cls)\n        obj.p = ival\n        _intcache[ival] = obj\n        return obj",
    ".sympy.core.expr.py@@Expr._pow": "def _pow(self, other):\n    return Pow(self, other)",
    ".sympy.core.power.py@@Pow.__new__": "def __new__(cls, b, e, evaluate=None):\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    from sympy.functions.elementary.exponential import exp_polar\n    b = _sympify(b)\n    e = _sympify(e)\n    if evaluate:\n        if e is S.ComplexInfinity:\n            return S.NaN\n        if e is S.Zero:\n            return S.One\n        elif e is S.One:\n            return b\n        elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and e.is_integer and _coeff_isneg(b):\n            if e.is_even:\n                b = -b\n            elif e.is_odd:\n                return -Pow(-b, e)\n        if S.NaN in (b, e):\n            return S.NaN\n        elif b is S.One:\n            if abs(e).is_infinite:\n                return S.NaN\n            return S.One\n        else:\n            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):\n                from sympy import numer, denom, log, sign, im, factor_terms\n                c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n                den = denom(ex)\n                if isinstance(den, log) and den.args[0] == b:\n                    return S.Exp1 ** (c * numer(ex))\n                elif den.is_Add:\n                    s = sign(im(b))\n                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):\n                        return S.Exp1 ** (c * numer(ex))\n            obj = b._eval_power(e)\n            if obj is not None:\n                return obj\n    obj = Expr.__new__(cls, b, e)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if not isinstance(obj, Pow):\n        return obj\n    obj.is_commutative = b.is_commutative and e.is_commutative\n    return obj",
    ".sympy.core.function.py@@_coeff_isneg": "def _coeff_isneg(a):\n    if a.is_Mul:\n        a = a.args[0]\n    return a.is_Number and a.is_negative",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    tself = type(self)\n    tother = type(other)\n    if type(self) is not type(other):\n        try:\n            other = _sympify(other)\n            tother = type(other)\n        except SympifyError:\n            return NotImplemented\n        if PY3 or type(tself).__ne__ is not type.__ne__:\n            if tself != tother:\n                return False\n        elif tself is not tother:\n            return False\n    return self._hashable_content() == other._hashable_content()",
    ".sympy.core.numbers.py@@NaN.__hash__": "def __hash__(self):\n    return super(NaN, self).__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super(Number, self).__hash__()",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Number:\n        if other.is_Rational:\n            return self.p == other.p and self.q == other.q\n        if other.is_Float:\n            return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)\n    return False",
    ".sympy.core.expr.py@@Expr._eval_power": "def _eval_power(self, other):\n    return None",
    ".sympy.core.basic.py@@Basic._exec_constructor_postprocessors": "def _exec_constructor_postprocessors(cls, obj):\n    clsname = obj.__class__.__name__\n    postprocessors = defaultdict(list)\n    for i in obj.args:\n        try:\n            if i in Basic._constructor_postprocessor_mapping:\n                for k, v in Basic._constructor_postprocessor_mapping[i].items():\n                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n            else:\n                postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)\n                for k, v in chain.from_iterable(postprocessor_mappings):\n                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n        except TypeError:\n            pass\n    for f in postprocessors.get(clsname, []):\n        obj = f(obj)\n    if len(postprocessors) > 0 and obj not in Basic._constructor_postprocessor_mapping:\n        Basic._constructor_postprocessor_mapping[obj] = postprocessors\n    return obj",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.geometry.point.py@@Point2D.y": "def y(self):\n    return self.args[1]",
    ".sympy.core.expr.py@@Expr.__add__": "def __add__(self, other):\n    return Add(self, other)",
    ".sympy.core.basic.py@@Basic._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.add.py@@Add.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    from sympy.tensor.tensor import TensExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        if a.is_Rational:\n            if b.is_Mul:\n                rv = ([a, b], [], None)\n        if rv:\n            if all((s.is_commutative for s in rv[0])):\n                return rv\n            return ([], rv[0], None)\n    terms = {}\n    coeff = S.Zero\n    order_factors = []\n    for o in seq:\n        if o.is_Order:\n            for o1 in order_factors:\n                if o1.contains(o):\n                    o = None\n                    break\n            if o is None:\n                continue\n            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False):\n                return ([S.NaN], [], None)\n            if coeff.is_Number:\n                coeff += o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__add__(coeff)\n            continue\n        elif isinstance(o, MatrixExpr):\n            coeff = o.__add__(coeff) if coeff else o\n            continue\n        elif isinstance(o, TensExpr):\n            coeff = o.__add__(coeff) if coeff else o\n            continue\n        elif o is S.ComplexInfinity:\n            if coeff.is_finite is False:\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o.is_Add:\n            seq.extend(o.args)\n            continue\n        elif o.is_Mul:\n            c, s = o.as_coeff_Mul()\n        elif o.is_Pow:\n            b, e = o.as_base_exp()\n            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):\n                seq.append(b ** e)\n                continue\n            c, s = (S.One, o)\n        else:\n            c = S.One\n            s = o\n        if s in terms:\n            terms[s] += c\n            if terms[s] is S.NaN:\n                return ([S.NaN], [], None)\n        else:\n            terms[s] = c\n    newseq = []\n    noncommutative = False\n    for s, c in terms.items():\n        if c is S.Zero:\n            continue\n        elif c is S.One:\n            newseq.append(s)\n        elif s.is_Mul:\n            cs = s._new_rawargs(*(c,) + s.args)\n            newseq.append(cs)\n        elif s.is_Add:\n            newseq.append(Mul(c, s, evaluate=False))\n        else:\n            newseq.append(Mul(c, s))\n        noncommutative = noncommutative or not s.is_commutative\n    if coeff is S.Infinity:\n        newseq = [f for f in newseq if not (f.is_nonnegative or (f.is_real and f.is_finite))]\n    elif coeff is S.NegativeInfinity:\n        newseq = [f for f in newseq if not (f.is_nonpositive or (f.is_real and f.is_finite))]\n    if coeff is S.ComplexInfinity:\n        newseq = [c for c in newseq if not (c.is_finite and c.is_real is not None)]\n    if order_factors:\n        newseq2 = []\n        for t in newseq:\n            for o in order_factors:\n                if o.contains(t):\n                    t = None\n                    break\n            if t is not None:\n                newseq2.append(t)\n        newseq = newseq2 + order_factors\n        for o in order_factors:\n            if o.contains(coeff):\n                coeff = S.Zero\n                break\n    _addsort(newseq)\n    if coeff is not S.Zero:\n        newseq.insert(0, coeff)\n    if noncommutative:\n        return ([], newseq, None)\n    else:\n        return (newseq, [], None)",
    ".sympy.core.power.py@@Pow.as_base_exp": "def as_base_exp(self):\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and (b.q != 1):\n        return (Integer(b.q), -e)\n    return (b, e)",
    ".sympy.core.add.py@@_addsort": "def _addsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.basic.py@@Basic.compare": "def compare(self, other):\n    if self is other:\n        return 0\n    n1 = self.__class__\n    n2 = other.__class__\n    c = (n1 > n2) - (n1 < n2)\n    if c:\n        return c\n    st = self._hashable_content()\n    ot = other._hashable_content()\n    c = (len(st) > len(ot)) - (len(st) < len(ot))\n    if c:\n        return c\n    for l, r in zip(st, ot):\n        l = Basic(*l) if isinstance(l, frozenset) else l\n        r = Basic(*r) if isinstance(r, frozenset) else r\n        if isinstance(l, Basic):\n            c = l.compare(r)\n        else:\n            c = (l > r) - (l < r)\n        if c:\n            return c\n    return 0",
    ".sympy.core.core.py@@BasicMeta.__gt__": "def __gt__(cls, other):\n    if cls.__cmp__(other) == 1:\n        return True\n    return False",
    ".sympy.core.core.py@@BasicMeta.__cmp__": "def __cmp__(cls, other):\n    if not isinstance(other, BasicMeta):\n        return -1\n    n1 = cls.__name__\n    n2 = other.__name__\n    if n1 == n2:\n        return 0\n    UNKNOWN = len(ordering_of_classes) + 1\n    try:\n        i1 = ordering_of_classes.index(n1)\n    except ValueError:\n        i1 = UNKNOWN\n    try:\n        i2 = ordering_of_classes.index(n2)\n    except ValueError:\n        i2 = UNKNOWN\n    if i1 == UNKNOWN and i2 == UNKNOWN:\n        return (n1 > n2) - (n1 < n2)\n    return (i1 > i2) - (i1 < i2)",
    ".sympy.core.core.py@@BasicMeta.__lt__": "def __lt__(cls, other):\n    if cls.__cmp__(other) == -1:\n        return True\n    return False",
    ".sympy.core.operations.py@@AssocOp._from_args": "def _from_args(cls, args, is_commutative=None):\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n    obj = super(AssocOp, cls).__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and((a.is_commutative for a in args))\n    obj.is_commutative = is_commutative\n    return obj",
    ".sympy.core.numbers.py@@Integer.__abs__": "def __abs__(self):\n    if self.p >= 0:\n        return self\n    else:\n        return Integer(-self.p)",
    ".sympy.core.numbers.py@@One.__neg__": "def __neg__():\n    return S.NegativeOne",
    ".sympy.core.numbers.py@@Integer.__add__": "def __add__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    ".sympy.core.numbers.py@@Integer.__neg__": "def __neg__(self):\n    return Integer(-self.p)",
    ".sympy.core.expr.py@@Expr.is_number": "def is_number(self):\n    return all((obj.is_number for obj in self.args))",
    ".sympy.core.add.py@@Add._eval_power": "def _eval_power(self, e):\n    if e.is_Rational and self.is_number:\n        from sympy.core.evalf import pure_complex\n        from sympy.core.mul import _unevaluated_Mul\n        from sympy.core.exprtools import factor_terms\n        from sympy.core.function import expand_multinomial\n        from sympy.functions.elementary.complexes import sign\n        from sympy.functions.elementary.miscellaneous import sqrt\n        ri = pure_complex(self)\n        if ri:\n            r, i = ri\n            if e.q == 2:\n                D = sqrt(r ** 2 + i ** 2)\n                if D.is_Rational:\n                    root = sqrt(factor_terms((D - r) / 2)) ** e.p\n                    return root * expand_multinomial(((D + r) / abs(i) + sign(i) * S.ImaginaryUnit) ** e.p)\n            elif e == -1:\n                return _unevaluated_Mul(r - i * S.ImaginaryUnit, 1 / (r ** 2 + i ** 2))",
    ".sympy.solvers.solvers.py@@solve": "def solve(f, *symbols, **flags):\n\n    def _sympified_list(w):\n        return list(map(sympify, w if iterable(w) else [w]))\n    bare_f = not iterable(f)\n    ordered_symbols = symbols and symbols[0] and (isinstance(symbols[0], Symbol) or is_sequence(symbols[0], include=GeneratorType))\n    f, symbols = (_sympified_list(w) for w in [f, symbols])\n    implicit = flags.get('implicit', False)\n    if not symbols:\n        symbols = set().union(*[fi.free_symbols for fi in f])\n        if len(symbols) < len(f):\n            for fi in f:\n                pot = preorder_traversal(fi)\n                for p in pot:\n                    if isinstance(p, AppliedUndef):\n                        flags['dict'] = True\n                        symbols.add(p)\n                        pot.skip()\n        symbols = list(symbols)\n        ordered_symbols = False\n    elif len(symbols) == 1 and iterable(symbols[0]):\n        symbols = symbols[0]\n    exclude = flags.pop('exclude', set())\n    if exclude:\n        if isinstance(exclude, Expr):\n            exclude = [exclude]\n        exclude = set().union(*[e.free_symbols for e in sympify(exclude)])\n    symbols = [s for s in symbols if s not in exclude]\n    for i, fi in enumerate(f):\n        if isinstance(fi, (Equality, Unequality)):\n            if 'ImmutableDenseMatrix' in [type(a).__name__ for a in fi.args]:\n                fi = fi.lhs - fi.rhs\n            else:\n                args = fi.args\n                if args[1] in (S.true, S.false):\n                    args = (args[1], args[0])\n                L, R = args\n                if L in (S.false, S.true):\n                    if isinstance(fi, Unequality):\n                        L = ~L\n                    if R.is_Relational:\n                        fi = ~R if L is S.false else R\n                    elif R.is_Symbol:\n                        return L\n                    elif R.is_Boolean and (~R).is_Symbol:\n                        return ~L\n                    else:\n                        raise NotImplementedError(filldedent('\\n                            Unanticipated argument of Eq when other arg\\n                            is True or False.\\n                        '))\n                else:\n                    fi = Add(fi.lhs, -fi.rhs, evaluate=False)\n            f[i] = fi\n        if isinstance(fi, (bool, BooleanAtom)) or fi.is_Relational:\n            return reduce_inequalities(f, symbols=symbols)\n        if isinstance(fi, Poly):\n            f[i] = fi.as_expr()\n        f[i] = f[i].replace(lambda w: isinstance(w, HyperbolicFunction), lambda w: w.rewrite(exp))\n        if f[i].is_Matrix:\n            bare_f = False\n            f.extend(list(f[i]))\n            f[i] = S.Zero\n        freei = f[i].free_symbols\n        if freei and all((s.is_real or s.is_imaginary for s in freei)):\n            fr, fi = f[i].as_real_imag()\n            had = f[i].atoms(re, im, arg, atan2)\n            if fr and fi and (fr != fi) and (not any((i.atoms(re, im, arg, atan2) - had for i in (fr, fi)))):\n                if bare_f:\n                    bare_f = False\n                f[i:i + 1] = [fr, fi]\n    w = Dummy('w')\n    piece = Lambda(w, Piecewise((w, Ge(w, 0)), (-w, True)))\n    for i, fi in enumerate(f):\n        reps = []\n        for a in fi.atoms(Abs):\n            if not a.has(*symbols):\n                continue\n            if a.args[0].is_real is None:\n                raise NotImplementedError('solving %s when the argument is not real or imaginary.' % a)\n            reps.append((a, piece(a.args[0]) if a.args[0].is_real else piece(a.args[0] * S.ImaginaryUnit)))\n        fi = fi.subs(reps)\n        _arg = [a for a in fi.atoms(arg) if a.has(*symbols)]\n        fi = fi.xreplace(dict(list(zip(_arg, [atan(im(a.args[0]) / re(a.args[0])) for a in _arg]))))\n        f[i] = fi\n    irf = []\n    for s in symbols:\n        if s.is_real or s.is_imaginary:\n            continue\n        if any((fi.has(re(s), im(s)) for fi in f)):\n            irf.append((s, re(s) + S.ImaginaryUnit * im(s)))\n    if irf:\n        for s, rhs in irf:\n            for i, fi in enumerate(f):\n                f[i] = fi.xreplace({s: rhs})\n            f.append(s - rhs)\n            symbols.extend([re(s), im(s)])\n        if bare_f:\n            bare_f = False\n        flags['dict'] = True\n    symbols = list(uniq(symbols))\n    if not ordered_symbols:\n        symbols = sorted(symbols, key=default_sort_key)\n    f, symbols, swap_sym = recast_to_symbols(f, symbols)\n    symset = set(symbols)\n    newf = []\n    for fi in f:\n        ok = False\n        if fi.has(*symset):\n            ok = True\n        else:\n            free = fi.free_symbols\n            if not free:\n                if fi.is_Number:\n                    if fi.is_zero:\n                        continue\n                    return []\n                ok = True\n            elif fi.is_constant():\n                ok = True\n        if ok:\n            newf.append(fi)\n    if not newf:\n        return []\n    f = newf\n    del newf\n    seen = set()\n    non_inverts = set()\n    for fi in f:\n        pot = preorder_traversal(fi)\n        for p in pot:\n            if not isinstance(p, Expr) or isinstance(p, Piecewise):\n                pass\n            elif (isinstance(p, bool) or not p.args or p in symset or p.is_Add or p.is_Mul or (p.is_Pow and (not implicit)) or (p.is_Function and (not implicit))) and p.func not in (re, im):\n                continue\n            elif not p in seen:\n                seen.add(p)\n                if p.free_symbols & symset:\n                    non_inverts.add(p)\n                else:\n                    continue\n            pot.skip()\n    del seen\n    non_inverts = dict(list(zip(non_inverts, [Dummy() for d in non_inverts])))\n    f = [fi.subs(non_inverts) for fi in f]\n    non_inverts = [(v, k.xreplace(swap_sym).subs(swap_sym)) for k, v in non_inverts.items()]\n    floats = False\n    if flags.get('rational', True) is not False:\n        for i, fi in enumerate(f):\n            if fi.has(Float):\n                floats = True\n                f[i] = nsimplify(fi, rational=True)\n    flags['_denominators'] = _simple_dens(f[0], symbols)\n\n    def _has_piecewise(e):\n        if e.is_Piecewise:\n            return e.has(*symbols)\n        return any([_has_piecewise(a) for a in e.args])\n    for i, fi in enumerate(f):\n        if _has_piecewise(fi):\n            f[i] = piecewise_fold(fi)\n    if bare_f:\n        solution = _solve(f[0], *symbols, **flags)\n    else:\n        solution = _solve_system(f, symbols, **flags)\n    if non_inverts:\n\n        def _do_dict(solution):\n            return dict([(k, v.subs(non_inverts)) for k, v in solution.items()])\n        for i in range(1):\n            if isinstance(solution, dict):\n                solution = _do_dict(solution)\n                break\n            elif solution and isinstance(solution, list):\n                if isinstance(solution[0], dict):\n                    solution = [_do_dict(s) for s in solution]\n                    break\n                elif isinstance(solution[0], tuple):\n                    solution = [tuple([v.subs(non_inverts) for v in s]) for s in solution]\n                    break\n                else:\n                    solution = [v.subs(non_inverts) for v in solution]\n                    break\n            elif not solution:\n                break\n        else:\n            raise NotImplementedError(filldedent('\\n                            no handling of %s was implemented' % solution))\n    if swap_sym:\n        symbols = [swap_sym.get(k, k) for k in symbols]\n        if isinstance(solution, dict):\n            solution = dict([(swap_sym.get(k, k), v.subs(swap_sym)) for k, v in solution.items()])\n        elif solution and isinstance(solution, list) and isinstance(solution[0], dict):\n            for i, sol in enumerate(solution):\n                solution[i] = dict([(swap_sym.get(k, k), v.subs(swap_sym)) for k, v in sol.items()])\n    if not flags.get('dict', False) and solution and ordered_symbols and (not isinstance(solution, dict)) and all((isinstance(sol, dict) for sol in solution)):\n        solution = [tuple([r.get(s, s).subs(r) for s in symbols]) for r in solution]\n    check = flags.get('check', True)\n    if floats and solution and (flags.get('rational', None) is None):\n        solution = nfloat(solution, exponent=False)\n    if check and solution:\n        warn = flags.get('warn', False)\n        got_None = []\n        no_False = []\n        if isinstance(solution, tuple):\n            return solution\n        elif isinstance(solution, list):\n            if isinstance(solution[0], tuple):\n                for sol in solution:\n                    for symb, val in zip(symbols, sol):\n                        test = check_assumptions(val, **symb.assumptions0)\n                        if test is False:\n                            break\n                        if test is None:\n                            got_None.append(sol)\n                    else:\n                        no_False.append(sol)\n            elif isinstance(solution[0], dict):\n                for sol in solution:\n                    a_None = False\n                    for symb, val in sol.items():\n                        test = check_assumptions(val, **symb.assumptions0)\n                        if test:\n                            continue\n                        if test is False:\n                            break\n                        a_None = True\n                    else:\n                        no_False.append(sol)\n                        if a_None:\n                            got_None.append(sol)\n            else:\n                for sol in solution:\n                    test = check_assumptions(sol, **symbols[0].assumptions0)\n                    if test is False:\n                        continue\n                    no_False.append(sol)\n                    if test is None:\n                        got_None.append(sol)\n        elif isinstance(solution, dict):\n            a_None = False\n            for symb, val in solution.items():\n                test = check_assumptions(val, **symb.assumptions0)\n                if test:\n                    continue\n                if test is False:\n                    no_False = None\n                    break\n                a_None = True\n            else:\n                no_False = solution\n                if a_None:\n                    got_None.append(solution)\n        elif isinstance(solution, (Relational, And, Or)):\n            if len(symbols) != 1:\n                raise ValueError('Length should be 1')\n            if warn and symbols[0].assumptions0:\n                warnings.warn(filldedent(\"\\n                    \\tWarning: assumptions about variable '%s' are\\n                    not handled currently.\" % symbols[0]))\n        else:\n            raise TypeError('Unrecognized solution')\n        solution = no_False\n        if warn and got_None:\n            warnings.warn(filldedent(\"\\n                \\tWarning: assumptions concerning following solution(s)\\n                can't be checked:\" + '\\n\\t' + ', '.join((str(s) for s in got_None))))\n    as_dict = flags.get('dict', False)\n    as_set = flags.get('set', False)\n    if not as_set and isinstance(solution, list):\n        solution.sort(key=default_sort_key)\n    if not as_dict and (not as_set):\n        return solution or []\n    if not solution:\n        solution = []\n    elif isinstance(solution, dict):\n        solution = [solution]\n    elif iterable(solution[0]):\n        solution = [dict(list(zip(symbols, s))) for s in solution]\n    elif isinstance(solution[0], dict):\n        pass\n    else:\n        if len(symbols) != 1:\n            raise ValueError('Length should be 1')\n        solution = [{symbols[0]: s} for s in solution]\n    if as_dict:\n        return solution\n    assert as_set\n    if not solution:\n        return ([], set())\n    k = list(ordered(solution[0].keys()))\n    return (k, {tuple([s[ki] for ki in k]) for s in solution})",
    ".sympy.core.compatibility.py@@iterable": "def iterable(i, exclude=(string_types, dict, NotIterable)):\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    ".sympy.core.compatibility.py@@is_sequence": "def is_sequence(i, include=None):\n    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))",
    ".sympy.solvers.solvers.py@@_sympified_list": "def _sympified_list(w):\n    return list(map(sympify, w if iterable(w) else [w]))",
    ".sympy.core.basic.py@@Basic.replace": "def replace(self, query, value, map=False, simultaneous=True, exact=False):\n    from sympy.core.symbol import Dummy\n    from sympy.simplify.simplify import bottom_up\n    try:\n        query = sympify(query)\n    except SympifyError:\n        pass\n    try:\n        value = sympify(value)\n    except SympifyError:\n        pass\n    if isinstance(query, type):\n        _query = lambda expr: isinstance(expr, query)\n        if isinstance(value, type):\n            _value = lambda expr, result: value(*expr.args)\n        elif callable(value):\n            _value = lambda expr, result: value(*expr.args)\n        else:\n            raise TypeError('given a type, replace() expects another type or a callable')\n    elif isinstance(query, Basic):\n        _query = lambda expr: expr.match(query)\n        if isinstance(value, Basic):\n            if exact:\n                _value = lambda expr, result: value.subs(result) if all((val for val in result.values())) else expr\n            else:\n                _value = lambda expr, result: value.subs(result)\n        elif callable(value):\n            if exact:\n                _value = lambda expr, result: value(**dict([(str(key)[:-1], val) for key, val in result.items()])) if all((val for val in result.values())) else expr\n            else:\n                _value = lambda expr, result: value(**dict([(str(key)[:-1], val) for key, val in result.items()]))\n        else:\n            raise TypeError('given an expression, replace() expects another expression or a callable')\n    elif callable(query):\n        _query = query\n        if callable(value):\n            _value = lambda expr, result: value(expr)\n        else:\n            raise TypeError('given a callable, replace() expects another callable')\n    else:\n        raise TypeError('first argument to replace() must be a type, an expression or a callable')\n    mapping = {}\n    mask = []\n\n    def rec_replace(expr):\n        result = _query(expr)\n        if result or result == {}:\n            new = _value(expr, result)\n            if new is not None and new != expr:\n                mapping[expr] = new\n                if simultaneous:\n                    com = getattr(new, 'is_commutative', True)\n                    if com is None:\n                        com = True\n                    d = Dummy(commutative=com)\n                    mask.append((d, new))\n                    expr = d\n                else:\n                    expr = new\n        return expr\n    rv = bottom_up(self, rec_replace, atoms=True)\n    if simultaneous:\n        mask = list(reversed(mask))\n        for o, n in mask:\n            r = {o: n}\n            rv = rv.xreplace(r)\n    if not map:\n        return rv\n    else:\n        if simultaneous:\n            for o, n in mask:\n                r = {o: n}\n                mapping = {k.xreplace(r): v.xreplace(r) for k, v in mapping.items()}\n        return (rv, mapping)",
    ".sympy.parsing.sympy_parser.py@@parse_expr": "def parse_expr(s, local_dict=None, transformations=standard_transformations, global_dict=None, evaluate=True):\n    if local_dict is None:\n        local_dict = {}\n    if global_dict is None:\n        global_dict = {}\n        exec_('from sympy import *', global_dict)\n    code = stringify_expr(s, local_dict, global_dict, transformations)\n    if not evaluate:\n        code = compile(evaluateFalse(code), '<string>', 'eval')\n    return eval_expr(code, local_dict, global_dict)",
    ".sympy.parsing.sympy_parser.py@@stringify_expr": "def stringify_expr(s, local_dict, global_dict, transformations):\n    tokens = []\n    input_code = StringIO(s.strip())\n    for toknum, tokval, _, _, _ in generate_tokens(input_code.readline):\n        tokens.append((toknum, tokval))\n    for transform in transformations:\n        tokens = transform(tokens, local_dict, global_dict)\n    return untokenize(tokens)",
    ".sympy.parsing.sympy_parser.py@@lambda_notation": "def lambda_notation(tokens, local_dict, global_dict):\n    result = []\n    flag = False\n    toknum, tokval = tokens[0]\n    tokLen = len(tokens)\n    if toknum == NAME and tokval == 'lambda':\n        if tokLen == 2:\n            result.extend(tokens)\n        elif tokLen > 2:\n            result.extend([(NAME, 'Lambda'), (OP, '('), (OP, '('), (OP, ')'), (OP, ')')])\n            for tokNum, tokVal in tokens[1:]:\n                if tokNum == OP and tokVal == ':':\n                    tokVal = ','\n                    flag = True\n                if not flag and tokNum == OP and (tokVal in ['*', '**']):\n                    raise TokenError('Starred arguments in lambda not supported')\n                if flag:\n                    result.insert(-1, (tokNum, tokVal))\n                else:\n                    result.insert(-2, (tokNum, tokVal))\n    else:\n        result.extend(tokens)\n    return result",
    ".sympy.parsing.sympy_parser.py@@auto_symbol": "def auto_symbol(tokens, local_dict, global_dict):\n    result = []\n    prevTok = (None, None)\n    tokens.append((None, None))\n    for tok, nextTok in zip(tokens, tokens[1:]):\n        tokNum, tokVal = tok\n        nextTokNum, nextTokVal = nextTok\n        if tokNum == NAME:\n            name = tokVal\n            if name in ['True', 'False', 'None'] or iskeyword(name) or (prevTok[0] == OP and prevTok[1] == '.') or (prevTok[0] == OP and prevTok[1] in ('(', ',') and (nextTokNum == OP) and (nextTokVal == '=')):\n                result.append((NAME, name))\n                continue\n            elif name in local_dict:\n                if isinstance(local_dict[name], Symbol) and nextTokVal == '(':\n                    result.extend([(NAME, 'Function'), (OP, '('), (NAME, repr(str(local_dict[name]))), (OP, ')')])\n                else:\n                    result.append((NAME, name))\n                continue\n            elif name in global_dict:\n                obj = global_dict[name]\n                if isinstance(obj, (Basic, type)) or callable(obj):\n                    result.append((NAME, name))\n                    continue\n            result.extend([(NAME, 'Symbol' if nextTokVal != '(' else 'Function'), (OP, '('), (NAME, repr(str(name))), (OP, ')')])\n        else:\n            result.append((tokNum, tokVal))\n        prevTok = (tokNum, tokVal)\n    return result",
    ".sympy.parsing.sympy_parser.py@@repeated_decimals": "def repeated_decimals(tokens, local_dict, global_dict):\n    result = []\n\n    def is_digit(s):\n        return all((i in '0123456789_' for i in s))\n    num = []\n    for toknum, tokval in tokens:\n        if toknum == NUMBER:\n            if not num and '.' in tokval and ('e' not in tokval.lower()) and ('j' not in tokval.lower()):\n                num.append((toknum, tokval))\n            elif is_digit(tokval) and len(num) == 2:\n                num.append((toknum, tokval))\n            elif is_digit(tokval) and len(num) == 3 and is_digit(num[-1][1]):\n                num.append((toknum, tokval))\n            else:\n                num = []\n        elif toknum == OP:\n            if tokval == '[' and len(num) == 1:\n                num.append((OP, tokval))\n            elif tokval == ']' and len(num) >= 3:\n                num.append((OP, tokval))\n            elif tokval == '.' and (not num):\n                num.append((NUMBER, '0.'))\n            else:\n                num = []\n        else:\n            num = []\n        result.append((toknum, tokval))\n        if num and num[-1][1] == ']':\n            result = result[:-len(num)]\n            pre, post = num[0][1].split('.')\n            repetend = num[2][1]\n            if len(num) == 5:\n                repetend += num[3][1]\n            pre = pre.replace('_', '')\n            post = post.replace('_', '')\n            repetend = repetend.replace('_', '')\n            zeros = '0' * len(post)\n            post, repetends = [w.lstrip('0') for w in [post, repetend]]\n            a = pre or '0'\n            b, c = (post or '0', '1' + zeros)\n            d, e = (repetends, '9' * len(repetend) + zeros)\n            seq = [(OP, '('), (NAME, 'Integer'), (OP, '('), (NUMBER, a), (OP, ')'), (OP, '+'), (NAME, 'Rational'), (OP, '('), (NUMBER, b), (OP, ','), (NUMBER, c), (OP, ')'), (OP, '+'), (NAME, 'Rational'), (OP, '('), (NUMBER, d), (OP, ','), (NUMBER, e), (OP, ')'), (OP, ')')]\n            result.extend(seq)\n            num = []\n    return result",
    ".sympy.parsing.sympy_parser.py@@is_digit": "def is_digit(s):\n    return all((i in '0123456789_' for i in s))",
    ".sympy.parsing.sympy_parser.py@@auto_number": "def auto_number(tokens, local_dict, global_dict):\n    result = []\n    for toknum, tokval in tokens:\n        if toknum == NUMBER:\n            number = tokval\n            postfix = []\n            if number.endswith('j') or number.endswith('J'):\n                number = number[:-1]\n                postfix = [(OP, '*'), (NAME, 'I')]\n            if '.' in number or (('e' in number or 'E' in number) and (not (number.startswith('0x') or number.startswith('0X')))):\n                seq = [(NAME, 'Float'), (OP, '('), (NUMBER, repr(str(number))), (OP, ')')]\n            else:\n                seq = [(NAME, 'Integer'), (OP, '('), (NUMBER, number), (OP, ')')]\n            result.extend(seq + postfix)\n        else:\n            result.append((toknum, tokval))\n    return result",
    ".sympy.parsing.sympy_parser.py@@factorial_notation": "def factorial_notation(tokens, local_dict, global_dict):\n    result = []\n    nfactorial = 0\n    for toknum, tokval in tokens:\n        if toknum == ERRORTOKEN:\n            op = tokval\n            if op == '!':\n                nfactorial += 1\n            else:\n                nfactorial = 0\n                result.append((OP, op))\n        else:\n            if nfactorial == 1:\n                result = _add_factorial_tokens('factorial', result)\n            elif nfactorial == 2:\n                result = _add_factorial_tokens('factorial2', result)\n            elif nfactorial > 2:\n                raise TokenError\n            nfactorial = 0\n            result.append((toknum, tokval))\n    return result",
    ".sympy.parsing.sympy_parser.py@@convert_xor": "def convert_xor(tokens, local_dict, global_dict):\n    result = []\n    for toknum, tokval in tokens:\n        if toknum == OP:\n            if tokval == '^':\n                result.append((OP, '**'))\n            else:\n                result.append((toknum, tokval))\n        else:\n            result.append((toknum, tokval))\n    return result",
    ".sympy.parsing.sympy_parser.py@@eval_expr": "def eval_expr(code, local_dict, global_dict):\n    expr = eval(code, global_dict, local_dict)\n    return expr",
    ".sympy.core.sympify.py@@SympifyError.__init__": "def __init__(self, expr, base_exc=None):\n    self.expr = expr\n    self.base_exc = base_exc",
    ".sympy.simplify.simplify.py@@bottom_up": "def bottom_up(rv, F, atoms=False, nonbasic=False):\n    try:\n        if rv.args:\n            args = tuple([bottom_up(a, F, atoms, nonbasic) for a in rv.args])\n            if args != rv.args:\n                rv = rv.func(*args)\n            rv = F(rv)\n        elif atoms:\n            rv = F(rv)\n    except AttributeError:\n        if nonbasic:\n            try:\n                rv = F(rv)\n            except TypeError:\n                pass\n    return rv",
    ".sympy.core.basic.py@@Basic.rec_replace": "def rec_replace(expr):\n    result = _query(expr)\n    if result or result == {}:\n        new = _value(expr, result)\n        if new is not None and new != expr:\n            mapping[expr] = new\n            if simultaneous:\n                com = getattr(new, 'is_commutative', True)\n                if com is None:\n                    com = True\n                d = Dummy(commutative=com)\n                mask.append((d, new))\n                expr = d\n            else:\n                expr = new\n    return expr",
    ".sympy.core.basic.py@@Basic.free_symbols": "def free_symbols(self):\n    return set().union(*[a.free_symbols for a in self.args])",
    ".sympy.core.symbol.py@@Symbol.free_symbols": "def free_symbols(self):\n    return {self}",
    ".sympy.core.add.py@@Add.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    sargs, terms = (self.args, [])\n    re_part, im_part = ([], [])\n    for term in sargs:\n        re, im = term.as_real_imag(deep=deep)\n        re_part.append(re)\n        im_part.append(im)\n    return (self.func(*re_part), self.func(*im_part))",
    ".sympy.core.expr.py@@Expr.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy import im, re\n    if hints.get('ignore') == self:\n        return None\n    else:\n        return (re(self), im(self))",
    ".sympy.core.function.py@@Function.__new__": "def __new__(cls, *args, **options):\n    if cls is Function:\n        return UndefinedFunction(*args, **options)\n    n = len(args)\n    if n not in cls.nargs:\n        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'\n        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})\n    evaluate = options.get('evaluate', global_evaluate[0])\n    result = super(Function, cls).__new__(cls, *args, **options)\n    if evaluate and isinstance(result, cls) and result.args:\n        pr2 = min((cls._should_evalf(a) for a in result.args))\n        if pr2 > 0:\n            pr = max((cls._should_evalf(a) for a in result.args))\n            result = result.evalf(mlib.libmpf.prec_to_dps(pr))\n    return result",
    ".sympy.core.function.py@@FunctionClass.nargs": "def nargs(self):\n    from sympy.sets.sets import FiniteSet\n    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0",
    ".sympy.sets.sets.py@@FiniteSet.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_evaluate[0])\n    if evaluate:\n        args = list(map(sympify, args))\n        if len(args) == 0:\n            return EmptySet()\n    else:\n        args = list(map(sympify, args))\n    args = list(ordered(frozenset(tuple(args)), Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._elements = frozenset(args)\n    return obj",
    ".sympy.core.compatibility.py@@ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    d = defaultdict(list)\n    if keys:\n        if not isinstance(keys, (list, tuple)):\n            keys = [keys]\n        keys = list(keys)\n        f = keys.pop(0)\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n    for k in sorted(d.keys()):\n        if len(d[k]) > 1:\n            if keys:\n                d[k] = ordered(d[k], keys, default, warn)\n            elif default:\n                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)\n            elif warn:\n                from sympy.utilities.iterables import uniq\n                u = list(uniq(d[k]))\n                if len(u) > 1:\n                    raise ValueError('not enough keys to break ties: %s' % u)\n        for v in d[k]:\n            yield v\n        d.pop(k)",
    ".sympy.sets.sets.py@@Set._infimum_key": "def _infimum_key(expr):\n    try:\n        infimum = expr.inf\n        assert infimum.is_comparable\n    except (NotImplementedError, AttributeError, AssertionError, ValueError):\n        infimum = S.Infinity\n    return infimum",
    ".sympy.core.numbers.py@@Infinity.__hash__": "def __hash__(self):\n    return super(Infinity, self).__hash__()",
    ".sympy.sets.sets.py@@Set.__contains__": "def __contains__(self, other):\n    symb = sympify(self.contains(other))\n    if not (symb is S.true or symb is S.false):\n        raise TypeError('contains did not evaluate to a bool: %r' % symb)\n    return bool(symb)",
    ".sympy.sets.sets.py@@Set.contains": "def contains(self, other):\n    other = sympify(other, strict=True)\n    ret = sympify(self._contains(other))\n    if ret is None:\n        ret = Contains(other, self, evaluate=False)\n    return ret",
    ".sympy.sets.sets.py@@FiniteSet._contains": "def _contains(self, other):\n    r = false\n    for e in self._elements:\n        t = Eq(e, other, evaluate=True)\n        if t is true:\n            return t\n        elif t is not false:\n            r = None\n    return r",
    ".sympy.core.relational.py@@Equality.__new__": "def __new__(cls, lhs, rhs=0, **options):\n    from sympy.core.add import Add\n    from sympy.core.logic import fuzzy_bool\n    from sympy.core.expr import _n2\n    from sympy.simplify.simplify import clear_coefficients\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    evaluate = options.pop('evaluate', global_evaluate[0])\n    if evaluate:\n        if hasattr(lhs, '_eval_Eq'):\n            r = lhs._eval_Eq(rhs)\n            if r is not None:\n                return r\n        if hasattr(rhs, '_eval_Eq'):\n            r = rhs._eval_Eq(lhs)\n            if r is not None:\n                return r\n        if lhs == rhs:\n            return S.true\n        elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):\n            return S.false\n        elif not (lhs.is_Symbol or rhs.is_Symbol) and isinstance(lhs, Boolean) != isinstance(rhs, Boolean):\n            return S.false\n        fin = L, R = [i.is_finite for i in (lhs, rhs)]\n        if None not in fin:\n            if L != R:\n                return S.false\n            if L is False:\n                if lhs == -rhs:\n                    return S.false\n                return S.true\n        elif None in fin and False in fin:\n            return Relational.__new__(cls, lhs, rhs, **options)\n        if all((isinstance(i, Expr) for i in (lhs, rhs))):\n            dif = lhs - rhs\n            z = dif.is_zero\n            if z is not None:\n                if z is False and dif.is_commutative:\n                    return S.false\n                if z:\n                    return S.true\n            n2 = _n2(lhs, rhs)\n            if n2 is not None:\n                return _sympify(n2 == 0)\n            n, d = dif.as_numer_denom()\n            rv = None\n            if n.is_zero:\n                rv = d.is_nonzero\n            elif n.is_finite:\n                if d.is_infinite:\n                    rv = S.true\n                elif n.is_zero is False:\n                    rv = d.is_infinite\n                    if rv is None:\n                        l, r = clear_coefficients(d, S.Infinity)\n                        args = [_.subs(l, r) for _ in (lhs, rhs)]\n                        if args != [lhs, rhs]:\n                            rv = fuzzy_bool(Eq(*args))\n                            if rv is True:\n                                rv = None\n            elif any((a.is_infinite for a in Add.make_args(n))):\n                rv = S.false\n            if rv is not None:\n                return _sympify(rv)\n    return Relational.__new__(cls, lhs, rhs, **options)",
    ".sympy.logic.boolalg.py@@BooleanTrue.__hash__": "def __hash__(self):\n    return hash(True)",
    ".sympy.logic.boolalg.py@@BooleanTrue.__nonzero__": "def __nonzero__(self):\n    return True",
    ".sympy.core.function.py@@Application.__new__": "def __new__(cls, *args, **options):\n    from sympy.sets.fancysets import Naturals0\n    from sympy.sets.sets import FiniteSet\n    args = list(map(sympify, args))\n    evaluate = options.pop('evaluate', global_evaluate[0])\n    options.pop('nargs', None)\n    if options:\n        raise ValueError('Unknown options: %s' % options)\n    if evaluate:\n        evaluated = cls.eval(*args)\n        if evaluated is not None:\n            return evaluated\n    obj = super(Application, cls).__new__(cls, *args, **options)\n    try:\n        if is_sequence(obj.nargs):\n            nargs = tuple(ordered(set(obj.nargs)))\n        elif obj.nargs is not None:\n            nargs = (as_int(obj.nargs),)\n        else:\n            nargs = None\n    except AttributeError:\n        nargs = obj._nargs\n    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()\n    return obj",
    ".sympy.functions.elementary.complexes.py@@re.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_real:\n        return arg\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        return S.Zero\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[0]\n    elif arg.is_Function and isinstance(arg, conjugate):\n        return re(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_real:\n                    reverted.append(coeff)\n            elif not term.has(S.ImaginaryUnit) and term.is_real:\n                excluded.append(term)\n            else:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[0])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) - im(b) + c",
    ".sympy.functions.elementary.complexes.py@@im.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_real:\n        return S.Zero\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        return -S.ImaginaryUnit * arg\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[1]\n    elif arg.is_Function and isinstance(arg, conjugate):\n        return -im(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_real:\n                    reverted.append(coeff)\n                else:\n                    excluded.append(coeff)\n            elif term.has(S.ImaginaryUnit) or not term.is_real:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[1])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) + re(b) + c",
    ".sympy.core.power.py@@Pow.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy import atan2, cos, im, re, sin\n    from sympy.polys.polytools import poly\n    if self.exp.is_Integer:\n        exp = self.exp\n        re, im = self.base.as_real_imag(deep=deep)\n        if not im:\n            return (self, S.Zero)\n        a, b = symbols('a b', cls=Dummy)\n        if exp >= 0:\n            if re.is_Number and im.is_Number:\n                expr = expand_multinomial(self.base ** exp)\n                if expr != self:\n                    return expr.as_real_imag()\n            expr = poly((a + b) ** exp)\n        else:\n            mag = re ** 2 + im ** 2\n            re, im = (re / mag, -im / mag)\n            if re.is_Number and im.is_Number:\n                expr = expand_multinomial((re + im * S.ImaginaryUnit) ** (-exp))\n                if expr != self:\n                    return expr.as_real_imag()\n            expr = poly((a + b) ** (-exp))\n        r = [i for i in expr.terms() if not i[0][1] % 2]\n        re_part = Add(*[cc * a ** aa * b ** bb for (aa, bb), cc in r])\n        r = [i for i in expr.terms() if i[0][1] % 4 == 1]\n        im_part1 = Add(*[cc * a ** aa * b ** bb for (aa, bb), cc in r])\n        r = [i for i in expr.terms() if i[0][1] % 4 == 3]\n        im_part3 = Add(*[cc * a ** aa * b ** bb for (aa, bb), cc in r])\n        return (re_part.subs({a: re, b: S.ImaginaryUnit * im}), im_part1.subs({a: re, b: im}) + im_part3.subs({a: re, b: -im}))\n    elif self.exp.is_Rational:\n        re, im = self.base.as_real_imag(deep=deep)\n        if im.is_zero and self.exp is S.Half:\n            if re.is_nonnegative:\n                return (self, S.Zero)\n            if re.is_nonpositive:\n                return (S.Zero, (-self.base) ** self.exp)\n        r = self.func(self.func(re, 2) + self.func(im, 2), S.Half)\n        t = atan2(im, re)\n        rp, tp = (self.func(r, self.exp), t * self.exp)\n        return (rp * cos(tp), rp * sin(tp))\n    elif deep:\n        hints['complex'] = False\n        expanded = self.expand(deep, **hints)\n        if hints.get('ignore') == expanded:\n            return None\n        else:\n            return (re(expanded), im(expanded))\n    else:\n        return (re(self), im(self))",
    ".sympy.core.power.py@@Pow.exp": "def exp(self):\n    return self._args[1]",
    ".sympy.core.power.py@@Pow.base": "def base(self):\n    return self._args[0]",
    ".sympy.core.symbol.py@@Symbol.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy import im, re\n    if hints.get('ignore') == self:\n        return None\n    else:\n        return (re(self), im(self))",
    ".sympy.core.numbers.py@@Zero.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.core.basic.py@@Basic.atoms": "def atoms(self, *types):\n    if types:\n        types = tuple([t if isinstance(t, type) else type(t) for t in types])\n    else:\n        types = (Atom,)\n    result = set()\n    for expr in preorder_traversal(self):\n        if isinstance(expr, types):\n            result.add(expr)\n    return result",
    ".sympy.core.basic.py@@preorder_traversal.__init__": "def __init__(self, node, keys=None):\n    self._skip_flag = False\n    self._pt = self._preorder_traversal(node, keys)",
    ".sympy.core.basic.py@@preorder_traversal.__iter__": "def __iter__(self):\n    return self",
    ".sympy.core.basic.py@@preorder_traversal.__next__": "def __next__(self):\n    return next(self._pt)",
    ".sympy.core.basic.py@@preorder_traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            for subtree in self._preorder_traversal(arg, keys):\n                yield subtree\n    elif iterable(node):\n        for item in node:\n            for subtree in self._preorder_traversal(item, keys):\n                yield subtree",
    ".sympy.core.relational.py@@_Inequality.__new__": "def __new__(cls, lhs, rhs, **options):\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    evaluate = options.pop('evaluate', global_evaluate[0])\n    if evaluate:\n        r = cls._eval_relation(lhs, rhs)\n        if r is not None:\n            return r\n    return Relational.__new__(cls, lhs, rhs, **options)",
    ".sympy.core.relational.py@@GreaterThan._eval_relation": "def _eval_relation(cls, lhs, rhs):\n    return _sympify(lhs.__ge__(rhs))",
    ".sympy.core.expr.py@@Expr.__ge__": "def __ge__(self, other):\n    from sympy import GreaterThan\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s >= %s' % (self, other))\n    for me in (self, other):\n        if me.is_complex and me.is_real is False:\n            raise TypeError('Invalid comparison of complex %s' % me)\n        if me is S.NaN:\n            raise TypeError('Invalid NaN comparison')\n    n2 = _n2(self, other)\n    if n2 is not None:\n        return _sympify(n2 >= 0)\n    if self.is_real or other.is_real:\n        dif = self - other\n        if dif.is_nonnegative is not None and dif.is_nonnegative is not dif.is_negative:\n            return sympify(dif.is_nonnegative)\n    return GreaterThan(self, other, evaluate=False)",
    ".sympy.core.assumptions.py@@_ask": "def _ask(fact, obj):\n    assumptions = obj._assumptions\n    handler_map = obj._prop_handler\n    assumptions._tell(fact, None)\n    try:\n        evaluate = handler_map[fact]\n    except KeyError:\n        pass\n    else:\n        a = evaluate(obj)\n        if a is not None:\n            assumptions.deduce_all_facts(((fact, a),))\n            return a\n    prereq = list(_assume_rules.prereq[fact])\n    shuffle(prereq)\n    for pk in prereq:\n        if pk in assumptions:\n            continue\n        if pk in handler_map:\n            _ask(pk, obj)\n            ret_val = assumptions.get(fact)\n            if ret_val is not None:\n                return ret_val\n    return None",
    ".sympy.core.expr.py@@Expr._eval_is_negative": "def _eval_is_negative(self):\n    from sympy.polys.numberfields import minimal_polynomial\n    from sympy.polys.polyerrors import NotAlgebraic\n    if self.is_number:\n        if self.is_real is False:\n            return False\n        try:\n            n2 = self._eval_evalf(2)\n            if n2 is None:\n                raise AttributeError\n            if n2._prec == 1:\n                raise AttributeError\n            if n2 == S.NaN:\n                raise AttributeError\n        except (AttributeError, ValueError):\n            return None\n        n, i = self.evalf(2).as_real_imag()\n        if not i.is_Number or not n.is_Number:\n            return False\n        if n._prec != 1 and i._prec != 1:\n            return bool(not i and n < 0)\n        elif n._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):\n            try:\n                if minimal_polynomial(self).is_Symbol:\n                    return False\n            except (NotAlgebraic, NotImplementedError):\n                pass",
    ".sympy.core.expr.py@@Expr._eval_is_positive": "def _eval_is_positive(self):\n    from sympy.polys.numberfields import minimal_polynomial\n    from sympy.polys.polyerrors import NotAlgebraic\n    if self.is_number:\n        if self.is_real is False:\n            return False\n        try:\n            n2 = self._eval_evalf(2)\n            if n2 is None:\n                raise AttributeError\n            if n2._prec == 1:\n                raise AttributeError\n            if n2 == S.NaN:\n                raise AttributeError\n        except (AttributeError, ValueError):\n            return None\n        n, i = self.evalf(2).as_real_imag()\n        if not i.is_Number or not n.is_Number:\n            return False\n        if n._prec != 1 and i._prec != 1:\n            return bool(not i and n > 0)\n        elif n._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):\n            try:\n                if minimal_polynomial(self).is_Symbol:\n                    return False\n            except (NotAlgebraic, NotImplementedError):\n                pass",
    ".sympy.core.expr.py@@_n2": "def _n2(a, b):\n    if a.is_comparable and b.is_comparable:\n        dif = (a - b).evalf(2)\n        if dif.is_comparable:\n            return dif",
    ".sympy.core.relational.py@@Relational.__new__": "def __new__(cls, lhs, rhs, rop=None, **assumptions):\n    if cls is not Relational:\n        return Expr.__new__(cls, lhs, rhs, **assumptions)\n    try:\n        cls = cls.ValidRelationOperator[rop]\n        rv = cls(lhs, rhs, **assumptions)\n        if isinstance(rv, (Eq, Ne)):\n            pass\n        elif isinstance(rv, Relational):\n            from sympy.core.symbol import Symbol\n            from sympy.logic.boolalg import Boolean\n            from sympy.utilities.misc import filldedent\n            for a in rv.args:\n                if isinstance(a, Symbol):\n                    continue\n                if isinstance(a, Boolean):\n                    from sympy.utilities.misc import filldedent\n                    raise TypeError(filldedent('\\n                        A Boolean argument can only be used in\\n                        Eq and Ne; all other relationals expect\\n                        real expressions.\\n                    '))\n        return rv\n    except KeyError:\n        raise ValueError('Invalid relational operator symbol: %r' % rop)",
    ".sympy.core.expr.py@@Expr.__neg__": "def __neg__(self):\n    return Mul(S.NegativeOne, self)",
    ".sympy.core.mul.py@@Mul.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n            seq = [a, b]\n        assert not a is S.One\n        if not a.is_zero and a.is_Rational:\n            r, b = b.as_coeff_Mul()\n            if b.is_Add:\n                if r is not S.One:\n                    rv = ([cls(a * r, b, evaluate=False)], [], None)\n                elif global_distribute[0] and b.is_commutative:\n                    r, b = b.as_coeff_Add()\n                    bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n                    _addsort(bargs)\n                    ar = a * r\n                    if ar:\n                        bargs.insert(0, ar)\n                    bargs = [Add._from_args(bargs)]\n                    rv = (bargs, [], None)\n        if rv:\n            return rv\n    c_part = []\n    nc_part = []\n    nc_seq = []\n    coeff = S.One\n    c_powers = []\n    num_exp = []\n    neg1e = S.Zero\n    pnum_rat = {}\n    order_symbols = None\n    for o in seq:\n        if o.is_Order:\n            o, order_symbols = o.as_expr_variables(order_symbols)\n        if o.is_Mul:\n            if o.is_commutative:\n                seq.extend(o.args)\n            else:\n                for q in o.args:\n                    if q.is_commutative:\n                        seq.append(q)\n                    else:\n                        nc_seq.append(q)\n                seq.append(NC_Marker)\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o is S.Zero):\n                return ([S.NaN], [], None)\n            elif coeff.is_Number or isinstance(coeff, AccumBounds):\n                coeff *= o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__mul__(coeff)\n            continue\n        elif isinstance(o, MatrixExpr):\n            coeff = o.__mul__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if not coeff:\n                return ([S.NaN], [], None)\n            if coeff is S.ComplexInfinity:\n                return ([S.ComplexInfinity], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o is S.ImaginaryUnit:\n            neg1e += S.Half\n            continue\n        elif o.is_commutative:\n            b, e = o.as_base_exp()\n            if o.is_Pow:\n                if b.is_Number:\n                    if e.is_Rational:\n                        if e.is_Integer:\n                            coeff *= Pow(b, e)\n                            continue\n                        elif e.is_negative:\n                            seq.append(Pow(b, e))\n                            continue\n                        elif b.is_negative:\n                            neg1e += e\n                            b = -b\n                        if b is not S.One:\n                            pnum_rat.setdefault(b, []).append(e)\n                        continue\n                    elif b.is_positive or e.is_integer:\n                        num_exp.append((b, e))\n                        continue\n                elif b is S.ImaginaryUnit and e.is_Rational:\n                    neg1e += e / 2\n                    continue\n            c_powers.append((b, e))\n        else:\n            if o is not NC_Marker:\n                nc_seq.append(o)\n            while nc_seq:\n                o = nc_seq.pop(0)\n                if not nc_part:\n                    nc_part.append(o)\n                    continue\n                o1 = nc_part.pop()\n                b1, e1 = o1.as_base_exp()\n                b2, e2 = o.as_base_exp()\n                new_exp = e1 + e2\n                if b1 == b2 and (not new_exp.is_Add):\n                    o12 = b1 ** new_exp\n                    if o12.is_commutative:\n                        seq.append(o12)\n                        continue\n                    else:\n                        nc_seq.insert(0, o12)\n                else:\n                    nc_part.append(o1)\n                    nc_part.append(o)\n\n    def _gather(c_powers):\n        common_b = {}\n        for b, e in c_powers:\n            co = e.as_coeff_Mul()\n            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n        for b, d in common_b.items():\n            for di, li in d.items():\n                d[di] = Add(*li)\n        new_c_powers = []\n        for b, e in common_b.items():\n            new_c_powers.extend([(b, c * t) for t, c in e.items()])\n        return new_c_powers\n    c_powers = _gather(c_powers)\n    num_exp = _gather(num_exp)\n    for i in range(2):\n        new_c_powers = []\n        changed = False\n        for b, e in c_powers:\n            if e.is_zero:\n                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):\n                    return ([S.NaN], [], None)\n                continue\n            if e is S.One:\n                if b.is_Number:\n                    coeff *= b\n                    continue\n                p = b\n            if e is not S.One:\n                p = Pow(b, e)\n                if p.is_Pow and (not b.is_Pow):\n                    bi = b\n                    b, e = p.as_base_exp()\n                    if b != bi:\n                        changed = True\n            c_part.append(p)\n            new_c_powers.append((b, e))\n        if changed and len(set((b for b, e in new_c_powers))) != len(new_c_powers):\n            c_part = []\n            c_powers = _gather(new_c_powers)\n        else:\n            break\n    inv_exp_dict = {}\n    for b, e in num_exp:\n        inv_exp_dict.setdefault(e, []).append(b)\n    for e, b in inv_exp_dict.items():\n        inv_exp_dict[e] = cls(*b)\n    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n    comb_e = {}\n    for b, e in pnum_rat.items():\n        comb_e.setdefault(Add(*e), []).append(b)\n    del pnum_rat\n    num_rat = []\n    for e, b in comb_e.items():\n        b = cls(*b)\n        if e.q == 1:\n            coeff *= Pow(b, e)\n            continue\n        if e.p > e.q:\n            e_i, ep = divmod(e.p, e.q)\n            coeff *= Pow(b, e_i)\n            e = Rational(ep, e.q)\n        num_rat.append((b, e))\n    del comb_e\n    pnew = defaultdict(list)\n    i = 0\n    while i < len(num_rat):\n        bi, ei = num_rat[i]\n        grow = []\n        for j in range(i + 1, len(num_rat)):\n            bj, ej = num_rat[j]\n            g = bi.gcd(bj)\n            if g is not S.One:\n                e = ei + ej\n                if e.q == 1:\n                    coeff *= Pow(g, e)\n                else:\n                    if e.p > e.q:\n                        e_i, ep = divmod(e.p, e.q)\n                        coeff *= Pow(g, e_i)\n                        e = Rational(ep, e.q)\n                    grow.append((g, e))\n                num_rat[j] = (bj / g, ej)\n                bi = bi / g\n                if bi is S.One:\n                    break\n        if bi is not S.One:\n            obj = Pow(bi, ei)\n            if obj.is_Number:\n                coeff *= obj\n            else:\n                for obj in Mul.make_args(obj):\n                    if obj.is_Number:\n                        coeff *= obj\n                    else:\n                        assert obj.is_Pow\n                        bi, ei = obj.args\n                        pnew[ei].append(bi)\n        num_rat.extend(grow)\n        i += 1\n    for e, b in pnew.items():\n        pnew[e] = cls(*b)\n    if neg1e:\n        p, q = neg1e.as_numer_denom()\n        n, p = divmod(p, q)\n        if n % 2:\n            coeff = -coeff\n        if q == 2:\n            c_part.append(S.ImaginaryUnit)\n        elif p:\n            neg1e = Rational(p, q)\n            for e, b in pnew.items():\n                if e == neg1e and b.is_positive:\n                    pnew[e] = -b\n                    break\n            else:\n                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n    c_part.extend([Pow(b, e) for e, b in pnew.items()])\n    if coeff is S.Infinity or coeff is S.NegativeInfinity:\n\n        def _handle_for_oo(c_part, coeff_sign):\n            new_c_part = []\n            for t in c_part:\n                if t.is_positive:\n                    continue\n                if t.is_negative:\n                    coeff_sign *= -1\n                    continue\n                new_c_part.append(t)\n            return (new_c_part, coeff_sign)\n        c_part, coeff_sign = _handle_for_oo(c_part, 1)\n        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n        coeff *= coeff_sign\n    if coeff is S.ComplexInfinity:\n        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n    elif coeff is S.Zero:\n        if any((c.is_finite == False for c in c_part)):\n            return ([S.NaN], [], order_symbols)\n        return ([coeff], [], order_symbols)\n    _new = []\n    for i in c_part:\n        if i.is_Number:\n            coeff *= i\n        else:\n            _new.append(i)\n    c_part = _new\n    _mulsort(c_part)\n    if coeff is not S.One:\n        c_part.insert(0, coeff)\n    if global_distribute[0] and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add:\n        coeff = c_part[0]\n        c_part = [Add(*[coeff * f for f in c_part[1].args])]\n    return (c_part, nc_part, order_symbols)",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (S.One, self)",
    ".sympy.core.numbers.py@@Integer.__mul__": "def __mul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p * other)\n        elif isinstance(other, Integer):\n            return Integer(self.p * other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    ".sympy.core.expr.py@@Expr.as_base_exp": "def as_base_exp(self):\n    return (self, S.One)",
    ".sympy.core.mul.py@@Mul._gather": "def _gather(c_powers):\n    common_b = {}\n    for b, e in c_powers:\n        co = e.as_coeff_Mul()\n        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n    for b, d in common_b.items():\n        for di, li in d.items():\n            d[di] = Add(*li)\n    new_c_powers = []\n    for b, e in common_b.items():\n        new_c_powers.extend([(b, c * t) for t, c in e.items()])\n    return new_c_powers",
    ".sympy.core.numbers.py@@Rational.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (self, S.One)",
    ".sympy.core.mul.py@@_mulsort": "def _mulsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.functions.elementary.piecewise.py@@Piecewise.__new__": "def __new__(cls, *args, **options):\n    if len(args) == 0:\n        raise TypeError('At least one (expr, cond) pair expected.')\n    newargs = []\n    for ec in args:\n        pair = ExprCondPair(*getattr(ec, 'args', ec))\n        cond = pair.cond\n        if cond is false:\n            continue\n        newargs.append(pair)\n        if cond is true:\n            break\n    if options.pop('evaluate', True):\n        r = cls.eval(*newargs)\n    else:\n        r = None\n    if r is None:\n        return Basic.__new__(cls, *newargs, **options)\n    else:\n        return r",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.__new__": "def __new__(cls, expr, cond):\n    expr = as_Basic(expr)\n    if cond == True:\n        return Tuple.__new__(cls, expr, true)\n    elif cond == False:\n        return Tuple.__new__(cls, expr, false)\n    elif isinstance(cond, Basic) and cond.has(Piecewise):\n        cond = piecewise_fold(cond)\n        if isinstance(cond, Piecewise):\n            cond = cond.rewrite(ITE)\n    if not isinstance(cond, Boolean):\n        raise TypeError(filldedent('\\n            Second argument must be a Boolean,\\n            not `%s`' % func_name(cond)))\n    return Tuple.__new__(cls, expr, cond)",
    ".sympy.core.basic.py@@as_Basic": "def as_Basic(expr):\n    from sympy.utilities.misc import func_name\n    try:\n        return _sympify(expr)\n    except SympifyError:\n        raise TypeError('Argument must be a Basic object, not `%s`' % func_name(expr))",
    ".sympy.core.basic.py@@Basic.has": "def has(self, *patterns):\n    return any((self._has(pattern) for pattern in patterns))",
    ".sympy.core.basic.py@@Basic._has": "def _has(self, pattern):\n    from sympy.core.function import UndefinedFunction, Function\n    if isinstance(pattern, UndefinedFunction):\n        return any((f.func == pattern or f == pattern for f in self.atoms(Function, UndefinedFunction)))\n    pattern = sympify(pattern)\n    if isinstance(pattern, BasicMeta):\n        return any((isinstance(arg, pattern) for arg in preorder_traversal(self)))\n    try:\n        match = pattern._has_matcher()\n        return any((match(arg) for arg in preorder_traversal(self)))\n    except AttributeError:\n        return any((arg == pattern for arg in preorder_traversal(self)))",
    ".sympy.core.containers.py@@Tuple.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.cond": "def cond(self):\n    return self.args[1]",
    ".sympy.functions.elementary.piecewise.py@@Piecewise.eval": "def eval(cls, *_args):\n    if not _args:\n        return Undefined\n    if len(_args) == 1 and _args[0][-1] == True:\n        return _args[0][0]\n    newargs = []\n    current_cond = set()\n    args = []\n    for e, c in _args:\n        if not c.is_Atom and (not isinstance(c, Relational)):\n            free = c.free_symbols\n            if len(free) == 1:\n                funcs = [i for i in c.atoms(Function) if not isinstance(i, Boolean)]\n                if len(funcs) == 1 and len(c.xreplace({list(funcs)[0]: Dummy()}).free_symbols) == 1:\n                    free = funcs\n                _c = c\n                x = free.pop()\n                try:\n                    c = c.as_set().as_relational(x)\n                except NotImplementedError:\n                    pass\n                else:\n                    reps = {}\n                    for i in c.atoms(Relational):\n                        ic = i.canonical\n                        if ic.rhs in (S.Infinity, S.NegativeInfinity):\n                            if not _c.has(ic.rhs):\n                                reps[i] = S.true\n                            elif '=' not in ic.rel_op and c.xreplace({x: i.rhs}) != _c.xreplace({x: i.rhs}):\n                                reps[i] = Relational(i.lhs, i.rhs, i.rel_op + '=')\n                    c = c.xreplace(reps)\n        args.append((e, _canonical(c)))\n    for expr, cond in args:\n        if isinstance(expr, Piecewise):\n            unmatching = []\n            for i, (e, c) in enumerate(expr.args):\n                if c in current_cond:\n                    continue\n                if c == cond:\n                    if c != True:\n                        if unmatching:\n                            expr = Piecewise(*unmatching + [(e, c)])\n                        else:\n                            expr = e\n                    break\n                else:\n                    unmatching.append((e, c))\n        got = False\n        for i in [cond] + (list(cond.args) if isinstance(cond, And) else []):\n            if i in current_cond:\n                got = True\n                break\n        if got:\n            continue\n        if isinstance(cond, And):\n            nonredundant = []\n            for c in cond.args:\n                if isinstance(c, Relational) and (~c).canonical in current_cond:\n                    continue\n                nonredundant.append(c)\n            cond = cond.func(*nonredundant)\n        elif isinstance(cond, Relational):\n            if (~cond).canonical in current_cond:\n                cond = S.true\n        current_cond.add(cond)\n        if newargs:\n            if newargs[-1].expr == expr:\n                orcond = Or(cond, newargs[-1].cond)\n                if isinstance(orcond, (And, Or)):\n                    orcond = distribute_and_over_or(orcond)\n                newargs[-1] = ExprCondPair(expr, orcond)\n                continue\n            elif newargs[-1].cond == cond:\n                orexpr = Or(expr, newargs[-1].expr)\n                if isinstance(orexpr, (And, Or)):\n                    orexpr = distribute_and_over_or(orexpr)\n                newargs[-1] == ExprCondPair(orexpr, cond)\n                continue\n        newargs.append(ExprCondPair(expr, cond))\n    missing = len(newargs) != len(_args)\n    same = all((a == b for a, b in zip(newargs, _args)))\n    if not newargs:\n        raise ValueError(filldedent('\\n            There are no conditions (or none that\\n            are not trivially false) to define an\\n            expression.'))\n    if missing or not same:\n        return cls(*newargs)",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.__iter__": "def __iter__(self):\n    yield self.expr\n    yield self.cond",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.expr": "def expr(self):\n    return self.args[0]",
    ".sympy.core.relational.py@@_canonical": "def _canonical(cond):\n    try:\n        reps = dict([(r, r.canonical) for r in cond.atoms(Relational)])\n        return cond.xreplace(reps)\n    except AttributeError:\n        return cond",
    ".sympy.core.relational.py@@Relational.canonical": "def canonical(self):\n    args = self.args\n    r = self\n    if r.rhs.is_Number:\n        if r.lhs.is_Number and r.lhs > r.rhs:\n            r = r.reversed\n    elif r.lhs.is_Number:\n        r = r.reversed\n    elif tuple(ordered(args)) != args:\n        r = r.reversed\n    return r",
    ".sympy.core.relational.py@@Relational.rhs": "def rhs(self):\n    return self._args[1]",
    ".sympy.core.relational.py@@Relational.lhs": "def lhs(self):\n    return self._args[0]",
    ".sympy.core.basic.py@@Basic.xreplace": "def xreplace(self, rule):\n    value, _ = self._xreplace(rule)\n    return value",
    ".sympy.core.basic.py@@Basic._xreplace": "def _xreplace(self, rule):\n    if self in rule:\n        return (rule[self], True)\n    elif rule:\n        args = []\n        changed = False\n        for a in self.args:\n            try:\n                a_xr = a._xreplace(rule)\n                args.append(a_xr[0])\n                changed |= a_xr[1]\n            except AttributeError:\n                args.append(a)\n        args = tuple(args)\n        if changed:\n            return (self.func(*args), True)\n    return (self, False)",
    ".sympy.logic.boolalg.py@@Boolean.__invert__": "def __invert__(self):\n    return Not(self)",
    ".sympy.logic.boolalg.py@@Not.eval": "def eval(cls, arg):\n    from sympy import Equality, GreaterThan, LessThan, StrictGreaterThan, StrictLessThan, Unequality\n    if isinstance(arg, Number) or arg in (True, False):\n        return false if arg else true\n    if arg.is_Not:\n        return arg.args[0]\n    if isinstance(arg, Equality):\n        return Unequality(*arg.args)\n    if isinstance(arg, Unequality):\n        return Equality(*arg.args)\n    if isinstance(arg, StrictLessThan):\n        return GreaterThan(*arg.args)\n    if isinstance(arg, StrictGreaterThan):\n        return LessThan(*arg.args)\n    if isinstance(arg, LessThan):\n        return StrictGreaterThan(*arg.args)\n    if isinstance(arg, GreaterThan):\n        return StrictLessThan(*arg.args)",
    ".sympy.core.relational.py@@StrictLessThan._eval_relation": "def _eval_relation(cls, lhs, rhs):\n    return _sympify(lhs.__lt__(rhs))",
    ".sympy.core.expr.py@@Expr.__lt__": "def __lt__(self, other):\n    from sympy import StrictLessThan\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    for me in (self, other):\n        if me.is_complex and me.is_real is False:\n            raise TypeError('Invalid comparison of complex %s' % me)\n        if me is S.NaN:\n            raise TypeError('Invalid NaN comparison')\n    n2 = _n2(self, other)\n    if n2 is not None:\n        return _sympify(n2 < 0)\n    if self.is_real or other.is_real:\n        dif = self - other\n        if dif.is_negative is not None and dif.is_negative is not dif.is_nonnegative:\n            return sympify(dif.is_negative)\n    return StrictLessThan(self, other, evaluate=False)",
    ".sympy.core.containers.py@@Tuple.__eq__": "def __eq__(self, other):\n    if isinstance(other, Basic):\n        return super(Tuple, self).__eq__(other)\n    return self.args == other",
    ".sympy.core.function.py@@Lambda.__new__": "def __new__(cls, variables, expr):\n    from sympy.sets.sets import FiniteSet\n    v = list(variables) if iterable(variables) else [variables]\n    for i in v:\n        if not getattr(i, 'is_symbol', False):\n            raise TypeError('variable is not a symbol: %s' % i)\n    if len(v) == 1 and v[0] == expr:\n        return S.IdentityFunction\n    obj = Expr.__new__(cls, Tuple(*v), sympify(expr))\n    obj.nargs = FiniteSet(len(v))\n    return obj",
    ".sympy.core.containers.py@@Tuple.__hash__": "def __hash__(self):\n    return hash(self.args)",
    ".sympy.core.basic.py@@Basic.subs": "def subs(self, *args, **kwargs):\n    from sympy.core.containers import Dict\n    from sympy.utilities import default_sort_key\n    from sympy import Dummy, Symbol\n    unordered = False\n    if len(args) == 1:\n        sequence = args[0]\n        if isinstance(sequence, set):\n            unordered = True\n        elif isinstance(sequence, (Dict, Mapping)):\n            unordered = True\n            sequence = sequence.items()\n        elif not iterable(sequence):\n            from sympy.utilities.misc import filldedent\n            raise ValueError(filldedent('\\n               When a single argument is passed to subs\\n               it should be a dictionary of old: new pairs or an iterable\\n               of (old, new) tuples.'))\n    elif len(args) == 2:\n        sequence = [args]\n    else:\n        raise ValueError('subs accepts either 1 or 2 arguments')\n    sequence = list(sequence)\n    for i in range(len(sequence)):\n        s = list(sequence[i])\n        for j, si in enumerate(s):\n            try:\n                si = sympify(si, strict=True)\n            except SympifyError:\n                if type(si) is str:\n                    si = Symbol(si)\n                else:\n                    sequence[i] = None\n                    break\n            s[j] = si\n        else:\n            sequence[i] = None if _aresame(*s) else tuple(s)\n    sequence = list(filter(None, sequence))\n    if unordered:\n        sequence = dict(sequence)\n        if not all((k.is_Atom for k in sequence)):\n            d = {}\n            for o, n in sequence.items():\n                try:\n                    ops = (o.count_ops(), len(o.args))\n                except TypeError:\n                    ops = (0, 0)\n                d.setdefault(ops, []).append((o, n))\n            newseq = []\n            for k in sorted(d.keys(), reverse=True):\n                newseq.extend(sorted([v[0] for v in d[k]], key=default_sort_key))\n            sequence = [(k, sequence[k]) for k in newseq]\n            del newseq, d\n        else:\n            sequence = sorted([(k, v) for k, v in sequence.items()], key=default_sort_key)\n    if kwargs.pop('simultaneous', False):\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy()\n        for old, new in sequence:\n            d = Dummy(commutative=new.is_commutative)\n            rv = rv._subs(old, d * m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    ".sympy.utilities.iterables.py@@uniq": "def uniq(seq, result=None):\n    try:\n        seen = set()\n        result = result or []\n        for i, s in enumerate(seq):\n            if not (s in seen or seen.add(s)):\n                yield s\n    except TypeError:\n        if s not in result:\n            yield s\n            result.append(s)\n        if hasattr(seq, '__getitem__'):\n            for s in uniq(seq[i + 1:], result):\n                yield s\n        else:\n            for s in uniq(seq, result):\n                yield s",
    ".sympy.solvers.solvers.py@@recast_to_symbols": "def recast_to_symbols(eqs, symbols):\n    if not iterable(eqs) and iterable(symbols):\n        raise ValueError('Both eqs and symbols must be iterable')\n    new_symbols = list(symbols)\n    swap_sym = {}\n    for i, s in enumerate(symbols):\n        if not isinstance(s, Symbol) and s not in swap_sym:\n            swap_sym[s] = Dummy('X%d' % i)\n            new_symbols[i] = swap_sym[s]\n    new_f = []\n    for i in eqs:\n        try:\n            new_f.append(i.subs(swap_sym))\n        except AttributeError:\n            new_f.append(i)\n    swap_sym = {v: k for k, v in swap_sym.items()}\n    return (new_f, new_symbols, swap_sym)",
    ".sympy.core.basic.py@@Basic._has_matcher": "def _has_matcher(self):\n    return lambda other: self == other",
    ".sympy.solvers.solvers.py@@_simple_dens": "def _simple_dens(f, symbols):\n    dens = set()\n    for d in denoms(f, symbols):\n        if d.is_Pow and d.exp.is_Number:\n            if d.exp.is_zero:\n                continue\n            d = d.base\n        dens.add(d)\n    return dens",
    ".sympy.solvers.solvers.py@@denoms": "def denoms(eq, *symbols):\n    pot = preorder_traversal(eq)\n    dens = set()\n    for p in pot:\n        den = denom(p)\n        if den is S.One:\n            continue\n        for d in Mul.make_args(den):\n            dens.add(d)\n    if not symbols:\n        return dens\n    elif len(symbols) == 1:\n        if iterable(symbols[0]):\n            symbols = symbols[0]\n    rv = []\n    for d in dens:\n        free = d.free_symbols\n        if any((s in free for s in symbols)):\n            rv.append(d)\n    return set(rv)",
    ".sympy.simplify.radsimp.py@@denom": "def denom(expr):\n    return fraction(expr)[1]",
    ".sympy.simplify.radsimp.py@@fraction": "def fraction(expr, exact=False):\n    expr = sympify(expr)\n    numer, denom = ([], [])\n    for term in Mul.make_args(expr):\n        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):\n            b, ex = term.as_base_exp()\n            if ex.is_negative:\n                if ex is S.NegativeOne:\n                    denom.append(b)\n                elif exact:\n                    if ex.is_constant():\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n            elif ex.is_positive:\n                numer.append(term)\n            elif not exact and ex.is_Mul:\n                n, d = term.as_numer_denom()\n                numer.append(n)\n                denom.append(d)\n            else:\n                numer.append(term)\n        elif term.is_Rational:\n            n, d = term.as_numer_denom()\n            numer.append(n)\n            denom.append(d)\n        else:\n            numer.append(term)\n    if exact:\n        return (Mul(*numer, evaluate=False), Mul(*denom, evaluate=False))\n    else:\n        return (Mul(*numer), Mul(*denom))",
    ".sympy.core.operations.py@@AssocOp.make_args": "def make_args(cls, expr):\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    ".sympy.core.numbers.py@@Integer.as_numer_denom": "def as_numer_denom(self):\n    return (self, S.One)",
    ".sympy.solvers.solvers.py@@_has_piecewise": "def _has_piecewise(e):\n    if e.is_Piecewise:\n        return e.has(*symbols)\n    return any([_has_piecewise(a) for a in e.args])",
    ".sympy.solvers.solvers.py@@_solve_system": "def _solve_system(exprs, symbols, **flags):\n    if not exprs:\n        return []\n    polys = []\n    dens = set()\n    failed = []\n    result = False\n    linear = False\n    manual = flags.get('manual', False)\n    checkdens = check = flags.get('check', True)\n    for j, g in enumerate(exprs):\n        dens.update(_simple_dens(g, symbols))\n        i, d = _invert(g, *symbols)\n        g = d - i\n        g = g.as_numer_denom()[0]\n        if manual:\n            failed.append(g)\n            continue\n        poly = g.as_poly(*symbols, extension=True)\n        if poly is not None:\n            polys.append(poly)\n        else:\n            failed.append(g)\n    if not polys:\n        solved_syms = []\n    elif all((p.is_linear for p in polys)):\n        n, m = (len(polys), len(symbols))\n        matrix = zeros(n, m + 1)\n        for i, poly in enumerate(polys):\n            for monom, coeff in poly.terms():\n                try:\n                    j = monom.index(1)\n                    matrix[i, j] = coeff\n                except ValueError:\n                    matrix[i, m] = -coeff\n        if flags.pop('particular', False):\n            result = minsolve_linear_system(matrix, *symbols, **flags)\n        else:\n            result = solve_linear_system(matrix, *symbols, **flags)\n        if failed:\n            if result:\n                solved_syms = list(result.keys())\n            else:\n                solved_syms = []\n        else:\n            linear = True\n    elif len(symbols) > len(polys):\n        from sympy.utilities.iterables import subsets\n        free = set().union(*[p.free_symbols for p in polys])\n        free = list(ordered(free.intersection(symbols)))\n        got_s = set()\n        result = []\n        for syms in subsets(free, len(polys)):\n            try:\n                res = solve_poly_system(polys, *syms)\n                if res:\n                    for r in res:\n                        skip = False\n                        for r1 in r:\n                            if got_s and any([ss in r1.free_symbols for ss in got_s]):\n                                skip = True\n                        if not skip:\n                            got_s.update(syms)\n                            result.extend([dict(list(zip(syms, r)))])\n            except NotImplementedError:\n                pass\n        if got_s:\n            solved_syms = list(got_s)\n        else:\n            raise NotImplementedError('no valid subset found')\n    else:\n        try:\n            result = solve_poly_system(polys, *symbols)\n            if result:\n                solved_syms = symbols\n                result = [dict(list(zip(solved_syms, r))) for r in result]\n        except NotImplementedError:\n            failed.extend([g.as_expr() for g in polys])\n            solved_syms = []\n            result = None\n    if result:\n        if isinstance(result, dict):\n            result = [result]\n    else:\n        result = [{}]\n    if failed:\n\n        def _ok_syms(e, sort=False):\n            rv = e.free_symbols - solved_syms & legal\n            if sort:\n                rv = list(rv)\n                rv.sort(key=default_sort_key)\n            return rv\n        solved_syms = set(solved_syms)\n        legal = set(symbols)\n        u = Dummy()\n        for eq in ordered(failed, lambda _: len(_ok_syms(_))):\n            newresult = []\n            bad_results = []\n            got_s = set()\n            hit = False\n            for r in result:\n                eq2 = eq.subs(r)\n                if check and r:\n                    b = checksol(u, u, eq2, minimal=True)\n                    if b is not None:\n                        if b:\n                            newresult.append(r)\n                        else:\n                            bad_results.append(r)\n                        continue\n                ok_syms = _ok_syms(eq2, sort=True)\n                if not ok_syms:\n                    if r:\n                        newresult.append(r)\n                    break\n                for s in ok_syms:\n                    try:\n                        soln = _solve(eq2, s, **flags)\n                    except NotImplementedError:\n                        continue\n                    for sol in soln:\n                        if got_s and any([ss in sol.free_symbols for ss in got_s]):\n                            continue\n                        rnew = r.copy()\n                        for k, v in r.items():\n                            rnew[k] = v.subs(s, sol)\n                        rnew[s] = sol\n                        newresult.append(rnew)\n                    hit = True\n                    got_s.add(s)\n                if not hit:\n                    raise NotImplementedError('could not solve %s' % eq2)\n            else:\n                result = newresult\n                for b in bad_results:\n                    if b in result:\n                        result.remove(b)\n    default_simplify = bool(failed)\n    if flags.get('simplify', default_simplify):\n        for r in result:\n            for k in r:\n                r[k] = simplify(r[k])\n        flags['simplify'] = False\n    if checkdens:\n        result = [r for r in result if not any((checksol(d, r, **flags) for d in dens))]\n    if check and (not linear):\n        result = [r for r in result if not any((checksol(e, r, **flags) is False for e in exprs))]\n    result = [r for r in result if r]\n    if linear and result:\n        result = result[0]\n    return result",
    ".sympy.solvers.solvers.py@@_invert": "def _invert(eq, *symbols, **kwargs):\n    eq = sympify(eq)\n    free = eq.free_symbols\n    if not symbols:\n        symbols = free\n    if not free & set(symbols):\n        return (eq, S.Zero)\n    dointpow = bool(kwargs.get('integer_power', False))\n    lhs = eq\n    rhs = S.Zero\n    while True:\n        was = lhs\n        while True:\n            indep, dep = lhs.as_independent(*symbols)\n            if lhs.is_Add:\n                if indep is S.Zero:\n                    break\n                lhs = dep\n                rhs -= indep\n            else:\n                if indep is S.One:\n                    break\n                lhs = dep\n                rhs /= indep\n        if lhs.is_Add:\n            terms = {}\n            for a in lhs.args:\n                i, d = a.as_independent(*symbols)\n                terms.setdefault(d, []).append(i)\n            if any((len(v) > 1 for v in terms.values())):\n                args = []\n                for d, i in terms.items():\n                    if len(i) > 1:\n                        args.append(Add(*i) * d)\n                    else:\n                        args.append(i[0] * d)\n                lhs = Add(*args)\n        if lhs.is_Add and (not rhs) and (len(lhs.args) == 2) and (not lhs.is_polynomial(*symbols)):\n            a, b = ordered(lhs.args)\n            ai, ad = a.as_independent(*symbols)\n            bi, bd = b.as_independent(*symbols)\n            if any((_ispow(i) for i in (ad, bd))):\n                a_base, a_exp = ad.as_base_exp()\n                b_base, b_exp = bd.as_base_exp()\n                if a_base == b_base:\n                    lhs = powsimp(powdenest(ad / bd))\n                    rhs = -bi / ai\n                else:\n                    rat = ad / bd\n                    _lhs = powsimp(ad / bd)\n                    if _lhs != rat:\n                        lhs = _lhs\n                        rhs = -bi / ai\n            elif ai == -bi:\n                if isinstance(ad, Function) and ad.func == bd.func:\n                    if len(ad.args) == len(bd.args) == 1:\n                        lhs = ad.args[0] - bd.args[0]\n                    elif len(ad.args) == len(bd.args):\n                        raise NotImplementedError('equal function with more than 1 argument')\n                    else:\n                        raise ValueError('function with different numbers of args')\n        elif lhs.is_Mul and any((_ispow(a) for a in lhs.args)):\n            lhs = powsimp(powdenest(lhs))\n        if lhs.is_Function:\n            if hasattr(lhs, 'inverse') and len(lhs.args) == 1:\n                rhs = lhs.inverse()(rhs)\n                lhs = lhs.args[0]\n            elif isinstance(lhs, atan2):\n                y, x = lhs.args\n                lhs = 2 * atan(y / (sqrt(x ** 2 + y ** 2) + x))\n            elif lhs.func == rhs.func:\n                if len(lhs.args) == len(rhs.args) == 1:\n                    lhs = lhs.args[0]\n                    rhs = rhs.args[0]\n                elif len(lhs.args) == len(rhs.args):\n                    raise NotImplementedError('equal function with more than 1 argument')\n                else:\n                    raise ValueError('function with different numbers of args')\n        if rhs and lhs.is_Pow and lhs.exp.is_Integer and (lhs.exp < 0):\n            lhs = 1 / lhs\n            rhs = 1 / rhs\n        if lhs.is_Pow and (lhs.exp.is_Integer and dointpow or (not lhs.exp.is_Integer and len(symbols) > 1 and (len(lhs.base.free_symbols & set(symbols)) > 1))):\n            rhs = rhs ** (1 / lhs.exp)\n            lhs = lhs.base\n        if lhs == was:\n            break\n    return (rhs, lhs)",
    ".sympy.core.expr.py@@Expr.as_independent": "def as_independent(self, *deps, **hint):\n    from .symbol import Symbol\n    from .add import _unevaluated_Add\n    from .mul import _unevaluated_Mul\n    from sympy.utilities.iterables import sift\n    if self.is_zero:\n        return (S.Zero, S.Zero)\n    func = self.func\n    if hint.get('as_Add', isinstance(self, Add)):\n        want = Add\n    else:\n        want = Mul\n    sym = set()\n    other = []\n    for d in deps:\n        if isinstance(d, Symbol):\n            sym.add(d)\n        else:\n            other.append(d)\n\n    def has(e):\n        has_other = e.has(*other)\n        if not sym:\n            return has_other\n        return has_other or e.has(*e.free_symbols & sym)\n    if want is not func or (func is not Add and func is not Mul):\n        if has(self):\n            return (want.identity, self)\n        else:\n            return (self, want.identity)\n    elif func is Add:\n        args = list(self.args)\n    else:\n        args, nc = self.args_cnc()\n    d = sift(args, lambda x: has(x))\n    depend = d[True]\n    indep = d[False]\n    if func is Add:\n        return (Add(*indep), _unevaluated_Add(*depend))\n    else:\n        for i, n in enumerate(nc):\n            if has(n):\n                depend.extend(nc[i:])\n                break\n            indep.append(n)\n        return (Mul(*indep), Mul(*depend, evaluate=False) if nc else _unevaluated_Mul(*depend))",
    ".sympy.core.assumptions.py@@StdFactKB.copy": "def copy(self):\n    return self.__class__(self)",
    ".sympy.core.add.py@@Add._eval_is_zero": "def _eval_is_zero(self):\n    if self.is_commutative is False:\n        return\n    nz = []\n    z = 0\n    im_or_z = False\n    im = False\n    for a in self.args:\n        if a.is_real:\n            if a.is_zero:\n                z += 1\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im = True\n        elif (S.ImaginaryUnit * a).is_real:\n            im_or_z = True\n        else:\n            return\n    if z == len(self.args):\n        return True\n    if len(nz) == len(self.args):\n        return None\n    b = self.func(*nz)\n    if b.is_zero:\n        if not im_or_z and (not im):\n            return True\n        if im and (not im_or_z):\n            return False\n    if b.is_zero is False:\n        return False",
    ".sympy.core.power.py@@Pow._eval_is_real": "def _eval_is_real(self):\n    from sympy import arg, exp, log, Mul\n    real_b = self.base.is_real\n    if real_b is None:\n        if self.base.func == exp and self.base.args[0].is_imaginary:\n            return self.exp.is_imaginary\n        return\n    real_e = self.exp.is_real\n    if real_e is None:\n        return\n    if real_b and real_e:\n        if self.base.is_positive:\n            return True\n        elif self.base.is_nonnegative:\n            if self.exp.is_nonnegative:\n                return True\n        elif self.exp.is_integer:\n            return True\n        elif self.base.is_negative:\n            if self.exp.is_Rational:\n                return False\n    if real_e and self.exp.is_negative:\n        return Pow(self.base, -self.exp).is_real\n    im_b = self.base.is_imaginary\n    im_e = self.exp.is_imaginary\n    if im_b:\n        if self.exp.is_integer:\n            if self.exp.is_even:\n                return True\n            elif self.exp.is_odd:\n                return False\n        elif im_e and log(self.base).is_imaginary:\n            return True\n        elif self.exp.is_Add:\n            c, a = self.exp.as_coeff_Add()\n            if c and c.is_Integer:\n                return Mul(self.base ** c, self.base ** a, evaluate=False).is_real\n        elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):\n            if (self.exp / 2).is_integer is False:\n                return False\n    if real_b and im_e:\n        if self.base is S.NegativeOne:\n            return True\n        c = self.exp.coeff(S.ImaginaryUnit)\n        if c:\n            ok = (c * log(self.base) / S.Pi).is_Integer\n            if ok is not None:\n                return ok\n    if real_b is False:\n        i = arg(self.base) * self.exp / S.Pi\n        return i.is_integer",
    ".sympy.core.power.py@@Pow._eval_is_zero": "def _eval_is_zero(self):\n    if self.base.is_zero:\n        if self.exp.is_positive:\n            return True\n        elif self.exp.is_nonpositive:\n            return False\n    elif self.base.is_zero is False:\n        if self.exp.is_finite:\n            return False\n        elif self.exp.is_infinite:\n            if (1 - abs(self.base)).is_positive:\n                return self.exp.is_positive\n            elif (1 - abs(self.base)).is_negative:\n                return self.exp.is_negative\n    else:\n        return None",
    ".sympy.core.power.py@@Pow._eval_is_negative": "def _eval_is_negative(self):\n    if self.base.is_negative:\n        if self.exp.is_odd:\n            return True\n        if self.exp.is_even:\n            return False\n    elif self.base.is_positive:\n        if self.exp.is_real:\n            return False\n    elif self.base.is_nonnegative:\n        if self.exp.is_nonnegative:\n            return False\n    elif self.base.is_nonpositive:\n        if self.exp.is_even:\n            return False\n    elif self.base.is_real:\n        if self.exp.is_even:\n            return False",
    ".sympy.core.power.py@@Pow._eval_is_algebraic": "def _eval_is_algebraic(self):\n\n    def _is_one(expr):\n        try:\n            return (expr - 1).is_zero\n        except ValueError:\n            return False\n    if self.base.is_zero or _is_one(self.base):\n        return True\n    elif self.exp.is_rational:\n        if self.base.is_algebraic is False:\n            return self.exp.is_zero\n        return self.base.is_algebraic\n    elif self.base.is_algebraic and self.exp.is_algebraic:\n        if fuzzy_not(self.base.is_zero) and fuzzy_not(_is_one(self.base)) or self.base.is_integer is False or self.base.is_irrational:\n            return self.exp.is_rational",
    ".sympy.core.power.py@@Pow._is_one": "def _is_one(expr):\n    try:\n        return (expr - 1).is_zero\n    except ValueError:\n        return False",
    ".sympy.core.logic.py@@_fuzzy_group": "def _fuzzy_group(args, quick_exit=False):\n    saw_other = False\n    for a in args:\n        if a is True:\n            continue\n        if a is None:\n            return\n        if quick_exit and saw_other:\n            return\n        saw_other = True\n    return not saw_other",
    ".sympy.core.add.py@@Add._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all((x.is_rational is True for x in others)):\n                return True\n            return None\n        if a is None:\n            return\n    return False",
    ".sympy.core.add.py@@Add._eval_is_odd": "def _eval_is_odd(self):\n    l = [f for f in self.args if not f.is_even is True]\n    if not l:\n        return False\n    if l[0].is_odd:\n        return self._new_rawargs(*l[1:]).is_even",
    ".sympy.core.operations.py@@AssocOp._new_rawargs": "def _new_rawargs(self, *args, **kwargs):\n    if kwargs.pop('reeval', True) and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)",
    ".sympy.core.add.py@@Add._eval_is_nonpositive": "def _eval_is_nonpositive(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_nonpositive:\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s != self and s.is_nonpositive:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v != self and v.is_nonpositive:\n                        return True",
    ".sympy.core.add.py@@Add.as_coeff_Add": "def as_coeff_Add(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number and (not rational) or coeff.is_Rational:\n        return (coeff, self._new_rawargs(*args))\n    return (S.Zero, self)",
    ".sympy.core.add.py@@Add._eval_is_positive": "def _eval_is_positive(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if self.is_number:\n        return super(Add, self)._eval_is_positive()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s != self and s.is_positive and a.is_nonnegative:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v != self and v.is_positive:\n                    return True\n    pos = nonneg = nonpos = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        ispos = a.is_positive\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((ispos, a.is_nonnegative)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if ispos:\n            pos = True\n            continue\n        elif a.is_nonnegative:\n            nonneg = True\n            continue\n        elif a.is_nonpositive:\n            nonpos = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonpos and (not nonneg) and pos:\n        return True\n    elif not nonpos and pos:\n        return True\n    elif not pos and (not nonneg):\n        return False",
    ".sympy.core.exprtools.py@@_monotonic_sign": "def _monotonic_sign(self):\n    if not self.is_real:\n        return\n    if (-self).is_Symbol:\n        rv = _monotonic_sign(-self)\n        return rv if rv is None else -rv\n    if not self.is_Add and self.as_numer_denom()[1].is_number:\n        s = self\n        if s.is_prime:\n            if s.is_odd:\n                return S(3)\n            else:\n                return S(2)\n        elif s.is_composite:\n            if s.is_odd:\n                return S(9)\n            else:\n                return S(4)\n        elif s.is_positive:\n            if s.is_even:\n                if s.is_prime is False:\n                    return S(4)\n                else:\n                    return S(2)\n            elif s.is_integer:\n                return S.One\n            else:\n                return _eps\n        elif s.is_negative:\n            if s.is_even:\n                return S(-2)\n            elif s.is_integer:\n                return S.NegativeOne\n            else:\n                return -_eps\n        if s.is_zero or s.is_nonpositive or s.is_nonnegative:\n            return S.Zero\n        return None\n    free = self.free_symbols\n    if len(free) == 1:\n        if self.is_polynomial():\n            from sympy.polys.polytools import real_roots\n            from sympy.polys.polyroots import roots\n            from sympy.polys.polyerrors import PolynomialError\n            x = free.pop()\n            x0 = _monotonic_sign(x)\n            if x0 == _eps or x0 == -_eps:\n                x0 = S.Zero\n            if x0 is not None:\n                d = self.diff(x)\n                if d.is_number:\n                    roots = []\n                else:\n                    try:\n                        roots = real_roots(d)\n                    except (PolynomialError, NotImplementedError):\n                        roots = [r for r in roots(d, x) if r.is_real]\n                y = self.subs(x, x0)\n                if x.is_nonnegative and all((r <= x0 for r in roots)):\n                    if y.is_nonnegative and d.is_positive:\n                        if y:\n                            return y if y.is_positive else Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_negative:\n                        if y:\n                            return y if y.is_negative else Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n                elif x.is_nonpositive and all((r >= x0 for r in roots)):\n                    if y.is_nonnegative and d.is_negative:\n                        if y:\n                            return Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_positive:\n                        if y:\n                            return Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n        else:\n            n, d = self.as_numer_denom()\n            den = None\n            if n.is_number:\n                den = _monotonic_sign(d)\n            elif not d.is_number:\n                if _monotonic_sign(n) is not None:\n                    den = _monotonic_sign(d)\n            if den is not None and (den.is_positive or den.is_negative):\n                v = n * den\n                if v.is_positive:\n                    return Dummy('pos', positive=True)\n                elif v.is_nonnegative:\n                    return Dummy('nneg', nonnegative=True)\n                elif v.is_negative:\n                    return Dummy('neg', negative=True)\n                elif v.is_nonpositive:\n                    return Dummy('npos', nonpositive=True)\n        return None\n    c, a = self.as_coeff_Add()\n    v = None\n    if not a.is_polynomial():\n        n, d = a.as_numer_denom()\n        if not (n.is_number or d.is_number):\n            return\n        if (a.is_Mul or a.is_Pow) and a.is_rational and all((p.exp.is_Integer for p in a.atoms(Pow) if p.is_Pow)) and (a.is_positive or a.is_negative):\n            v = S(1)\n            for ai in Mul.make_args(a):\n                if ai.is_number:\n                    v *= ai\n                    continue\n                reps = {}\n                for x in ai.free_symbols:\n                    reps[x] = _monotonic_sign(x)\n                    if reps[x] is None:\n                        return\n                v *= ai.subs(reps)\n    elif c:\n        if not any((p for p in a.atoms(Pow) if not p.is_number)) and (a.is_nonpositive or a.is_nonnegative):\n            free = list(a.free_symbols)\n            p = {}\n            for i in free:\n                v = _monotonic_sign(i)\n                if v is None:\n                    return\n                p[i] = v or (_eps if i.is_nonnegative else -_eps)\n            v = a.xreplace(p)\n    if v is not None:\n        rv = v + c\n        if v.is_nonnegative and rv.is_positive:\n            return rv.subs(_eps, 0)\n        if v.is_nonpositive and rv.is_negative:\n            return rv.subs(_eps, 0)",
    ".sympy.core.expr.py@@Expr.as_numer_denom": "def as_numer_denom(self):\n    return (self, S.One)",
    ".sympy.core.add.py@@Add._eval_is_negative": "def _eval_is_negative(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if self.is_number:\n        return super(Add, self)._eval_is_negative()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s != self and s.is_negative and a.is_nonpositive:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v != self and v.is_negative:\n                    return True\n    neg = nonpos = nonneg = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        isneg = a.is_negative\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((isneg, a.is_nonpositive)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if isneg:\n            neg = True\n            continue\n        elif a.is_nonpositive:\n            nonpos = True\n            continue\n        elif a.is_nonnegative:\n            nonneg = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonneg and (not nonpos) and neg:\n        return True\n    elif not nonneg and neg:\n        return True\n    elif not neg and (not nonpos):\n        return False",
    ".sympy.core.add.py@@Add._eval_is_nonnegative": "def _eval_is_nonnegative(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_nonnegative:\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s != self and s.is_nonnegative:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v != self and v.is_nonnegative:\n                        return True",
    ".sympy.core.power.py@@Pow._eval_is_prime": "def _eval_is_prime(self):\n    if self.base.is_integer and self.exp.is_integer and (self.exp - 1).is_positive:\n        return False",
    ".sympy.core.power.py@@Pow._eval_is_rational": "def _eval_is_rational(self):\n    p = self.func(*self.as_base_exp())\n    if not p.is_Pow:\n        return p.is_rational\n    b, e = p.as_base_exp()\n    if e.is_Rational and b.is_Rational:\n        return False\n    if e.is_integer:\n        if b.is_rational:\n            if fuzzy_not(b.is_zero) or e.is_nonnegative:\n                return True\n            if b == e:\n                return True\n        elif b.is_irrational:\n            return e.is_zero",
    ".sympy.core.power.py@@Pow._eval_is_odd": "def _eval_is_odd(self):\n    if self.exp.is_integer:\n        if self.exp.is_positive:\n            return self.base.is_odd\n        elif self.exp.is_nonnegative and self.base.is_odd:\n            return True\n        elif self.base is S.NegativeOne:\n            return True",
    ".sympy.core.power.py@@Pow._eval_is_even": "def _eval_is_even(self):\n    if self.exp.is_integer and self.exp.is_positive:\n        return self.base.is_even",
    ".sympy.core.power.py@@Pow._eval_is_integer": "def _eval_is_integer(self):\n    b, e = self.args\n    if b.is_rational:\n        if b.is_integer is False and e.is_positive:\n            return False\n    if b.is_integer and e.is_integer:\n        if b is S.NegativeOne:\n            return True\n        if e.is_nonnegative or e.is_positive:\n            return True\n    if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):\n        if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):\n            return False\n    if b.is_Number and e.is_Number:\n        check = self.func(*self.args)\n        return check.is_Integer",
    ".sympy.core.power.py@@Pow._eval_is_composite": "def _eval_is_composite(self):\n    if self.base.is_integer and self.exp.is_integer and ((self.base - 1).is_positive and (self.exp - 1).is_positive or ((self.base + 1).is_negative and self.exp.is_positive and self.exp.is_even)):\n        return True",
    ".sympy.core.power.py@@Pow._eval_is_positive": "def _eval_is_positive(self):\n    from sympy import log\n    if self.base == self.exp:\n        if self.base.is_nonnegative:\n            return True\n    elif self.base.is_positive:\n        if self.exp.is_real:\n            return True\n    elif self.base.is_negative:\n        if self.exp.is_even:\n            return True\n        if self.exp.is_odd:\n            return False\n    elif self.base.is_nonpositive:\n        if self.exp.is_odd:\n            return False\n    elif self.base.is_imaginary:\n        if self.exp.is_integer:\n            m = self.exp % 4\n            if m.is_zero:\n                return True\n            if m.is_integer and m.is_zero is False:\n                return False\n        if self.exp.is_imaginary:\n            return log(self.base).is_imaginary",
    ".sympy.core.power.py@@Pow._eval_is_finite": "def _eval_is_finite(self):\n    if self.exp.is_negative:\n        if self.base.is_zero:\n            return False\n        if self.base.is_infinite:\n            return True\n    c1 = self.base.is_finite\n    if c1 is None:\n        return\n    c2 = self.exp.is_finite\n    if c2 is None:\n        return\n    if c1 and c2:\n        if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):\n            return True",
    ".sympy.core.power.py@@Pow._eval_is_complex": "def _eval_is_complex(self):\n    if all((a.is_complex for a in self.args)):\n        return True",
    ".sympy.core.power.py@@Pow._eval_is_imaginary": "def _eval_is_imaginary(self):\n    from sympy import arg, log\n    if self.base.is_imaginary:\n        if self.exp.is_integer:\n            odd = self.exp.is_odd\n            if odd is not None:\n                return odd\n            return\n    if self.exp.is_imaginary:\n        imlog = log(self.base).is_imaginary\n        if imlog is not None:\n            return False\n    if self.base.is_real and self.exp.is_real:\n        if self.base.is_positive:\n            return False\n        else:\n            rat = self.exp.is_rational\n            if not rat:\n                return rat\n            if self.exp.is_integer:\n                return False\n            else:\n                half = (2 * self.exp).is_integer\n                if half:\n                    return self.base.is_negative\n                return half\n    if self.base.is_real is False:\n        i = arg(self.base) * self.exp / S.Pi\n        isodd = (2 * i).is_odd\n        if isodd is not None:\n            return isodd\n    if self.exp.is_negative:\n        return (1 / self).is_imaginary",
    ".sympy.core.add.py@@Add._eval_is_imaginary": "def _eval_is_imaginary(self):\n    nz = []\n    im_I = []\n    for a in self.args:\n        if a.is_real:\n            if a.is_zero:\n                pass\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im_I.append(a * S.ImaginaryUnit)\n        elif (S.ImaginaryUnit * a).is_real:\n            im_I.append(a * S.ImaginaryUnit)\n        else:\n            return\n    b = self.func(*nz)\n    if b.is_zero:\n        return fuzzy_not(self.func(*im_I).is_zero)\n    elif b.is_zero is False:\n        return False",
    ".sympy.core.add.py@@Add.__neg__": "def __neg__(self):\n    return self * -1",
    ".sympy.core.expr.py@@Expr.__mul__": "def __mul__(self, other):\n    return Mul(self, other)",
    ".sympy.core.mul.py@@_keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = (coeff, factors)\n        else:\n            return coeff * factors\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and (not sign):\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and (coeff.q != 1):\n            q = S(coeff.q)\n            for i in factors.args:\n                c, t = i.as_coeff_Mul()\n                r = c / q\n                if r == int(r):\n                    return coeff * factors\n        return Mul._from_args((coeff, factors))\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        return coeff * factors",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.logic.py@@fuzzy_and": "def fuzzy_and(args):\n    rv = True\n    for ai in args:\n        ai = fuzzy_bool(ai)\n        if ai is False:\n            return False\n        if rv:\n            rv = ai\n    return rv",
    ".sympy.core.expr.py@@Expr.is_polynomial": "def is_polynomial(self, *syms):\n    if syms:\n        syms = set(map(sympify, syms))\n    else:\n        syms = self.free_symbols\n    if syms.intersection(self.free_symbols) == set([]):\n        return True\n    else:\n        return self._eval_is_polynomial(syms)",
    ".sympy.core.add.py@@Add._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    return all((term._eval_is_polynomial(syms) for term in self.args))",
    ".sympy.core.power.py@@Pow._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    if self.exp.has(*syms):\n        return False\n    if self.base.has(*syms):\n        return bool(self.base._eval_is_polynomial(syms) and self.exp.is_Integer and (self.exp >= 0))\n    else:\n        return True",
    ".sympy.core.expr.py@@AtomicExpr._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    return True",
    ".sympy.core.numbers.py@@Integer.__ge__": "def __ge__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s >= %s' % (self, other))\n    if other.is_Integer:\n        return _sympify(self.p >= other.p)\n    return Rational.__ge__(self, other)",
    ".sympy.utilities.iterables.py@@sift": "def sift(seq, keyfunc, binary=False):\n    if not binary:\n        m = defaultdict(list)\n        for i in seq:\n            m[keyfunc(i)].append(i)\n        return m\n    sift = F, T = ([], [])\n    for i in seq:\n        try:\n            sift[keyfunc(i)].append(i)\n        except (IndexError, TypeError):\n            raise ValueError('keyfunc gave non-binary output')\n    return (T, F)",
    ".sympy.core.expr.py@@Expr.has": "def has(e):\n    has_other = e.has(*other)\n    if not sym:\n        return has_other\n    return has_other or e.has(*e.free_symbols & sym)",
    ".sympy.core.add.py@@_unevaluated_Add": "def _unevaluated_Add(*args):\n    args = list(args)\n    newargs = []\n    co = S.Zero\n    while args:\n        a = args.pop()\n        if a.is_Add:\n            args.extend(a.args)\n        elif a.is_Number:\n            co += a\n        else:\n            newargs.append(a)\n    _addsort(newargs)\n    if co:\n        newargs.insert(0, co)\n    return Add._from_args(newargs)",
    ".sympy.core.numbers.py@@Integer.__sub__": "def __sub__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    ".sympy.core.add.py@@Add.as_numer_denom": "def as_numer_denom(self):\n    content, expr = self.primitive()\n    ncon, dcon = content.as_numer_denom()\n    nd = defaultdict(list)\n    for f in expr.args:\n        ni, di = f.as_numer_denom()\n        nd[di].append(ni)\n    if len(nd) == 1:\n        d, n = nd.popitem()\n        return (self.func(*[_keep_coeff(ncon, ni) for ni in n]), _keep_coeff(dcon, d))\n    for d, n in nd.items():\n        if len(n) == 1:\n            nd[d] = n[0]\n        else:\n            nd[d] = self.func(*n)\n    denoms, numers = [list(i) for i in zip(*iter(nd.items()))]\n    n, d = (self.func(*[Mul(*denoms[:i] + [numers[i]] + denoms[i + 1:]) for i in range(len(numers))]), Mul(*denoms))\n    return (_keep_coeff(ncon, n), _keep_coeff(dcon, d))",
    ".sympy.core.add.py@@Add.primitive": "def primitive(self):\n    terms = []\n    inf = False\n    for a in self.args:\n        c, m = a.as_coeff_Mul()\n        if not c.is_Rational:\n            c = S.One\n            m = a\n        inf = inf or m is S.ComplexInfinity\n        terms.append((c.p, c.q, m))\n    if not inf:\n        ngcd = reduce(igcd, [t[0] for t in terms], 0)\n        dlcm = reduce(ilcm, [t[1] for t in terms], 1)\n    else:\n        ngcd = reduce(igcd, [t[0] for t in terms if t[1]], 0)\n        dlcm = reduce(ilcm, [t[1] for t in terms if t[1]], 1)\n    if ngcd == dlcm == 1:\n        return (S.One, self)\n    if not inf:\n        for i, (p, q, term) in enumerate(terms):\n            terms[i] = _keep_coeff(Rational(p // ngcd * (dlcm // q)), term)\n    else:\n        for i, (p, q, term) in enumerate(terms):\n            if q:\n                terms[i] = _keep_coeff(Rational(p // ngcd * (dlcm // q)), term)\n            else:\n                terms[i] = _keep_coeff(Rational(p, q), term)\n    if terms[0].is_Number or terms[0] is S.ComplexInfinity:\n        c = terms.pop(0)\n    else:\n        c = None\n    _addsort(terms)\n    if c:\n        terms.insert(0, c)\n    return (Rational(ngcd, dlcm), self._new_rawargs(*terms))",
    ".sympy.core.numbers.py@@igcd": "def igcd(*args):\n    if len(args) < 2:\n        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))\n    if 1 in args:\n        a = 1\n        k = 0\n    else:\n        a = abs(as_int(args[0]))\n        k = 1\n    if a != 1:\n        while k < len(args):\n            b = args[k]\n            k += 1\n            try:\n                a = _gcdcache[a, b]\n            except KeyError:\n                b = as_int(b)\n                if not b:\n                    continue\n                if b == 1:\n                    a = 1\n                    break\n                if b < 0:\n                    b = -b\n                t = (a, b)\n                a = igcd2(a, b)\n                _gcdcache[t] = _gcdcache[t[1], t[0]] = a\n    while k < len(args):\n        ok = as_int(args[k])\n        k += 1\n    return a",
    ".sympy.core.compatibility.py@@as_int": "def as_int(n):\n    try:\n        result = int(n)\n        if result != n:\n            raise TypeError\n    except TypeError:\n        raise ValueError('%s is not an integer' % (n,))\n    return result",
    ".sympy.core.numbers.py@@ilcm": "def ilcm(*args):\n    if len(args) < 2:\n        raise TypeError('ilcm() takes at least 2 arguments (%s given)' % len(args))\n    if 0 in args:\n        return 0\n    a = args[0]\n    for b in args[1:]:\n        a = a // igcd(a, b) * b\n    return a",
    ".sympy.core.power.py@@Pow.as_numer_denom": "def as_numer_denom(self):\n    if not self.is_commutative:\n        return (self, S.One)\n    base, exp = self.as_base_exp()\n    n, d = base.as_numer_denom()\n    neg_exp = exp.is_negative\n    if not neg_exp and (not (-exp).is_negative):\n        neg_exp = _coeff_isneg(exp)\n    int_exp = exp.is_integer\n    if not (d.is_real or int_exp):\n        n = base\n        d = S.One\n    dnonpos = d.is_nonpositive\n    if dnonpos:\n        n, d = (-n, -d)\n    elif dnonpos is None and (not int_exp):\n        n = base\n        d = S.One\n    if neg_exp:\n        n, d = (d, n)\n        exp = -exp\n    if exp.is_infinite:\n        if n is S.One and d is not S.One:\n            return (n, self.func(d, exp))\n        if n is not S.One and d is S.One:\n            return (self.func(n, exp), d)\n    return (self.func(n, exp), self.func(d, exp))",
    ".sympy.core.basic.py@@Basic.as_poly": "def as_poly(self, *gens, **args):\n    from sympy.polys import Poly, PolynomialError\n    try:\n        poly = Poly(self, *gens, **args)\n        if not poly.is_Poly:\n            return None\n        else:\n            return poly\n    except PolynomialError:\n        return None",
    ".sympy.polys.polytools.py@@Poly.__new__": "def __new__(cls, rep, *gens, **args):\n    opt = options.build_options(gens, args)\n    if 'order' in opt:\n        raise NotImplementedError(\"'order' keyword is not implemented yet\")\n    if iterable(rep, exclude=str):\n        if isinstance(rep, dict):\n            return cls._from_dict(rep, opt)\n        else:\n            return cls._from_list(list(rep), opt)\n    else:\n        rep = sympify(rep)\n        if rep.is_Poly:\n            return cls._from_poly(rep, opt)\n        else:\n            return cls._from_expr(rep, opt)",
    ".sympy.polys.polyoptions.py@@build_options": "def build_options(gens, args=None):\n    if args is None:\n        gens, args = ((), gens)\n    if len(args) != 1 or 'opt' not in args or gens:\n        return Options(gens, args)\n    else:\n        return args['opt']",
    ".sympy.polys.polyoptions.py@@Options.__init__": "def __init__(self, gens, args, flags=None, strict=False):\n    dict.__init__(self)\n    if gens and args.get('gens', ()):\n        raise OptionError(\"both '*gens' and keyword argument 'gens' supplied\")\n    elif gens:\n        args = dict(args)\n        args['gens'] = gens\n    defaults = args.pop('defaults', {})\n\n    def preprocess_options(args):\n        for option, value in args.items():\n            try:\n                cls = self.__options__[option]\n            except KeyError:\n                raise OptionError(\"'%s' is not a valid option\" % option)\n            if issubclass(cls, Flag):\n                if flags is None or option not in flags:\n                    if strict:\n                        raise OptionError(\"'%s' flag is not allowed in this context\" % option)\n            if value is not None:\n                self[option] = cls.preprocess(value)\n    preprocess_options(args)\n    for key, value in dict(defaults).items():\n        if key in self:\n            del defaults[key]\n        else:\n            for option in self.keys():\n                cls = self.__options__[option]\n                if key in cls.excludes:\n                    del defaults[key]\n                    break\n    preprocess_options(defaults)\n    for option in self.keys():\n        cls = self.__options__[option]\n        for require_option in cls.requires:\n            if self.get(require_option) is None:\n                raise OptionError(\"'%s' option is only allowed together with '%s'\" % (option, require_option))\n        for exclude_option in cls.excludes:\n            if self.get(exclude_option) is not None:\n                raise OptionError(\"'%s' option is not allowed together with '%s'\" % (option, exclude_option))\n    for option in self.__order__:\n        self.__options__[option].postprocess(self)",
    ".sympy.polys.polyoptions.py@@Options.preprocess_options": "def preprocess_options(args):\n    for option, value in args.items():\n        try:\n            cls = self.__options__[option]\n        except KeyError:\n            raise OptionError(\"'%s' is not a valid option\" % option)\n        if issubclass(cls, Flag):\n            if flags is None or option not in flags:\n                if strict:\n                    raise OptionError(\"'%s' flag is not allowed in this context\" % option)\n        if value is not None:\n            self[option] = cls.preprocess(value)",
    ".sympy.polys.polyoptions.py@@Extension.preprocess": "def preprocess(cls, extension):\n    if extension == 1:\n        return bool(extension)\n    elif extension == 0:\n        raise OptionError(\"'False' is an invalid argument for 'extension'\")\n    else:\n        if not hasattr(extension, '__iter__'):\n            extension = set([extension])\n        elif not extension:\n            extension = None\n        else:\n            extension = set(extension)\n        return extension",
    ".sympy.polys.polyoptions.py@@Gens.preprocess": "def preprocess(cls, gens):\n    if isinstance(gens, Basic):\n        gens = (gens,)\n    elif len(gens) == 1 and hasattr(gens[0], '__iter__'):\n        gens = gens[0]\n    if gens == (None,):\n        gens = ()\n    elif has_dups(gens):\n        raise GeneratorsError('duplicated generators: %s' % str(gens))\n    elif any((gen.is_commutative is False for gen in gens)):\n        raise GeneratorsError('non-commutative generators: %s' % str(gens))\n    return tuple(gens)",
    ".sympy.utilities.iterables.py@@has_dups": "def has_dups(seq):\n    from sympy.core.containers import Dict\n    from sympy.sets.sets import Set\n    if isinstance(seq, (dict, set, Dict, Set)):\n        return False\n    uniq = set()\n    return any((True for s in seq if s in uniq or uniq.add(s)))",
    ".sympy.polys.polyoptions.py@@Option.postprocess": "def postprocess(cls, options):\n    pass",
    ".sympy.polys.polyoptions.py@@Extension.postprocess": "def postprocess(cls, options):\n    if 'extension' in options and options['extension'] is not True:\n        options['domain'] = sympy.polys.domains.QQ.algebraic_field(*options['extension'])",
    ".sympy.polys.polyoptions.py@@Gaussian.postprocess": "def postprocess(cls, options):\n    if 'gaussian' in options and options['gaussian'] is True:\n        options['extension'] = set([S.ImaginaryUnit])\n        Extension.postprocess(options)",
    ".sympy.polys.polyoptions.py@@Domain.postprocess": "def postprocess(cls, options):\n    if 'gens' in options and 'domain' in options and options['domain'].is_Composite and set(options['domain'].symbols) & set(options['gens']):\n        raise GeneratorsError('ground domain and generators interfere together')\n    elif ('gens' not in options or not options['gens']) and 'domain' in options and (options['domain'] == sympy.polys.domains.EX):\n        raise GeneratorsError('you have to provide generators because EX domain was requested')",
    ".sympy.polys.polyoptions.py@@Auto.postprocess": "def postprocess(cls, options):\n    if ('domain' in options or 'field' in options) and 'auto' not in options:\n        options['auto'] = False",
    ".sympy.polys.polyoptions.py@@Modulus.postprocess": "def postprocess(cls, options):\n    if 'modulus' in options:\n        modulus = options['modulus']\n        symmetric = options.get('symmetric', True)\n        options['domain'] = sympy.polys.domains.FF(modulus, symmetric)",
    ".sympy.polys.polyoptions.py@@Split.postprocess": "def postprocess(cls, options):\n    if 'split' in options:\n        raise NotImplementedError(\"'split' option is not implemented yet\")",
    ".sympy.polys.polytools.py@@Poly._from_expr": "def _from_expr(cls, rep, opt):\n    rep, opt = _dict_from_expr(rep, opt)\n    return cls._from_dict(rep, opt)",
    ".sympy.polys.polyutils.py@@_dict_from_expr": "def _dict_from_expr(expr, opt):\n    if expr.is_commutative is False:\n        raise PolynomialError('non-commutative expressions are not supported')\n\n    def _is_expandable_pow(expr):\n        return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add\n    if opt.expand is not False:\n        if not isinstance(expr, Expr):\n            raise PolynomialError('expression must be of type Expr')\n        expr = expr.expand()\n        while any((_is_expandable_pow(i) or (i.is_Mul and any((_is_expandable_pow(j) for j in i.args))) for i in Add.make_args(expr))):\n            expr = expand_multinomial(expr)\n        while any((i.is_Mul and any((j.is_Add for j in i.args)) for i in Add.make_args(expr))):\n            expr = expand_mul(expr)\n    if opt.gens:\n        rep, gens = _dict_from_expr_if_gens(expr, opt)\n    else:\n        rep, gens = _dict_from_expr_no_gens(expr, opt)\n    return (rep, opt.clone({'gens': gens}))",
    ".sympy.polys.polyoptions.py@@OptionType.getter": "def getter(self):\n    try:\n        return self[cls.option]\n    except KeyError:\n        return cls.default()",
    ".sympy.polys.polyoptions.py@@Expand.default": "def default(cls):\n    return True",
    ".sympy.core.expr.py@@Expr.expand": "def expand(self, deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints):\n    from sympy.simplify.radsimp import fraction\n    hints.update(power_base=power_base, power_exp=power_exp, mul=mul, log=log, multinomial=multinomial, basic=basic)\n    expr = self\n    if hints.pop('frac', False):\n        n, d = [a.expand(deep=deep, modulus=modulus, **hints) for a in fraction(self)]\n        return n / d\n    elif hints.pop('denom', False):\n        n, d = fraction(self)\n        return n / d.expand(deep=deep, modulus=modulus, **hints)\n    elif hints.pop('numer', False):\n        n, d = fraction(self)\n        return n.expand(deep=deep, modulus=modulus, **hints) / d\n\n    def _expand_hint_key(hint):\n        if hint == 'mul':\n            return 'mulz'\n        return hint\n    for hint in sorted(hints.keys(), key=_expand_hint_key):\n        use_hint = hints[hint]\n        if use_hint:\n            hint = '_eval_expand_' + hint\n            expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)\n    while True:\n        was = expr\n        if hints.get('multinomial', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_multinomial', deep=deep, **hints)\n        if hints.get('mul', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_mul', deep=deep, **hints)\n        if hints.get('log', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_log', deep=deep, **hints)\n        if expr == was:\n            break\n    if modulus is not None:\n        modulus = sympify(modulus)\n        if not modulus.is_Integer or modulus <= 0:\n            raise ValueError('modulus must be a positive integer, got %s' % modulus)\n        terms = []\n        for term in Add.make_args(expr):\n            coeff, tail = term.as_coeff_Mul(rational=True)\n            coeff %= modulus\n            if coeff:\n                terms.append(coeff * tail)\n        expr = Add(*terms)\n    return expr",
    ".sympy.core.expr.py@@Expr._expand_hint_key": "def _expand_hint_key(hint):\n    if hint == 'mul':\n        return 'mulz'\n    return hint",
    ".sympy.core.expr.py@@Expr._expand_hint": "def _expand_hint(expr, hint, deep=True, **hints):\n    hit = False\n    if deep and getattr(expr, 'args', ()) and (not expr.is_Atom):\n        sargs = []\n        for arg in expr.args:\n            arg, arghit = Expr._expand_hint(arg, hint, **hints)\n            hit |= arghit\n            sargs.append(arg)\n        if hit:\n            expr = expr.func(*sargs)\n    if hasattr(expr, hint):\n        newexpr = getattr(expr, hint)(**hints)\n        if newexpr != expr:\n            return (newexpr, True)\n    return (expr, hit)",
    ".sympy.core.power.py@@Pow._eval_expand_multinomial": "def _eval_expand_multinomial(self, **hints):\n    base, exp = self.args\n    result = self\n    if exp.is_Rational and exp.p > 0 and base.is_Add:\n        if not exp.is_Integer:\n            n = Integer(exp.p // exp.q)\n            if not n:\n                return result\n            else:\n                radical, result = (self.func(base, exp - n), [])\n                expanded_base_n = self.func(base, n)\n                if expanded_base_n.is_Pow:\n                    expanded_base_n = expanded_base_n._eval_expand_multinomial()\n                for term in Add.make_args(expanded_base_n):\n                    result.append(term * radical)\n                return Add(*result)\n        n = int(exp)\n        if base.is_commutative:\n            order_terms, other_terms = ([], [])\n            for b in base.args:\n                if b.is_Order:\n                    order_terms.append(b)\n                else:\n                    other_terms.append(b)\n            if order_terms:\n                f = Add(*other_terms)\n                o = Add(*order_terms)\n                if n == 2:\n                    return expand_multinomial(f ** n, deep=False) + n * f * o\n                else:\n                    g = expand_multinomial(f ** (n - 1), deep=False)\n                    return expand_mul(f * g, deep=False) + n * g * o\n            if base.is_number:\n                a, b = base.as_real_imag()\n                if a.is_Rational and b.is_Rational:\n                    if not a.is_Integer:\n                        if not b.is_Integer:\n                            k = self.func(a.q * b.q, n)\n                            a, b = (a.p * b.q, a.q * b.p)\n                        else:\n                            k = self.func(a.q, n)\n                            a, b = (a.p, a.q * b)\n                    elif not b.is_Integer:\n                        k = self.func(b.q, n)\n                        a, b = (a * b.q, b.p)\n                    else:\n                        k = 1\n                    a, b, c, d = (int(a), int(b), 1, 0)\n                    while n:\n                        if n & 1:\n                            c, d = (a * c - b * d, b * c + a * d)\n                            n -= 1\n                        a, b = (a * a - b * b, 2 * a * b)\n                        n //= 2\n                    I = S.ImaginaryUnit\n                    if k == 1:\n                        return c + I * d\n                    else:\n                        return Integer(c) / k + I * d / k\n            p = other_terms\n            from sympy import multinomial_coefficients\n            from sympy.polys.polyutils import basic_from_dict\n            expansion_dict = multinomial_coefficients(len(p), n)\n            return basic_from_dict(expansion_dict, *p)\n        elif n == 2:\n            return Add(*[f * g for f in base.args for g in base.args])\n        else:\n            multi = (base ** (n - 1))._eval_expand_multinomial()\n            if multi.is_Add:\n                return Add(*[f * g for f in base.args for g in multi.args])\n            else:\n                return Add(*[f * multi for f in base.args])\n    elif exp.is_Rational and exp.p < 0 and base.is_Add and (abs(exp.p) > exp.q):\n        return 1 / self.func(base, -exp)._eval_expand_multinomial()\n    elif exp.is_Add and base.is_Number:\n        coeff, tail = (S.One, S.Zero)\n        for term in exp.args:\n            if term.is_Number:\n                coeff *= self.func(base, term)\n            else:\n                tail += term\n        return coeff * self.func(base, tail)\n    else:\n        return result",
    ".sympy.core.power.py@@Pow._eval_expand_power_base": "def _eval_expand_power_base(self, **hints):\n    force = hints.get('force', False)\n    b = self.base\n    e = self.exp\n    if not b.is_Mul:\n        return self\n    cargs, nc = b.args_cnc(split_1=False)\n    if nc:\n        nc = [i._eval_expand_power_base(**hints) if hasattr(i, '_eval_expand_power_base') else i for i in nc]\n        if e.is_Integer:\n            if e.is_positive:\n                rv = Mul(*nc * e)\n            else:\n                rv = Mul(*[i ** (-1) for i in nc[::-1]] * -e)\n            if cargs:\n                rv *= Mul(*cargs) ** e\n            return rv\n        if not cargs:\n            return self.func(Mul(*nc), e, evaluate=False)\n        nc = [Mul(*nc)]\n    other, maybe_real = sift(cargs, lambda x: x.is_real is False, binary=True)\n\n    def pred(x):\n        if x is S.ImaginaryUnit:\n            return S.ImaginaryUnit\n        polar = x.is_polar\n        if polar:\n            return True\n        if polar is None:\n            return fuzzy_bool(x.is_nonnegative)\n    sifted = sift(maybe_real, pred)\n    nonneg = sifted[True]\n    other += sifted[None]\n    neg = sifted[False]\n    imag = sifted[S.ImaginaryUnit]\n    if imag:\n        I = S.ImaginaryUnit\n        i = len(imag) % 4\n        if i == 0:\n            pass\n        elif i == 1:\n            other.append(I)\n        elif i == 2:\n            if neg:\n                nonn = -neg.pop()\n                if nonn is not S.One:\n                    nonneg.append(nonn)\n            else:\n                neg.append(S.NegativeOne)\n        else:\n            if neg:\n                nonn = -neg.pop()\n                if nonn is not S.One:\n                    nonneg.append(nonn)\n            else:\n                neg.append(S.NegativeOne)\n            other.append(I)\n        del imag\n    if force or e.is_integer:\n        cargs = nonneg + neg + other\n        other = nc\n    else:\n        assert not e.is_Integer\n        if len(neg) > 1:\n            o = S.One\n            if not other and neg[0].is_Number:\n                o *= neg.pop(0)\n            if len(neg) % 2:\n                o = -o\n            for n in neg:\n                nonneg.append(-n)\n            if o is not S.One:\n                other.append(o)\n        elif neg and other:\n            if neg[0].is_Number and neg[0] is not S.NegativeOne:\n                other.append(S.NegativeOne)\n                nonneg.append(-neg[0])\n            else:\n                other.extend(neg)\n        else:\n            other.extend(neg)\n        del neg\n        cargs = nonneg\n        other += nc\n    rv = S.One\n    if cargs:\n        rv *= Mul(*[self.func(b, e, evaluate=False) for b in cargs])\n    if other:\n        rv *= self.func(Mul(*other), e, evaluate=False)\n    return rv",
    ".sympy.core.power.py@@Pow._eval_expand_power_exp": "def _eval_expand_power_exp(self, **hints):\n    b = self.base\n    e = self.exp\n    if e.is_Add and e.is_commutative:\n        expr = []\n        for x in e.args:\n            expr.append(self.func(self.base, x))\n        return Mul(*expr)\n    return self.func(b, e)",
    ".sympy.polys.polyutils.py@@_is_expandable_pow": "def _is_expandable_pow(expr):\n    return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add",
    ".sympy.polys.polyutils.py@@_dict_from_expr_if_gens": "def _dict_from_expr_if_gens(expr, opt):\n    (poly,), gens = _parallel_dict_from_expr_if_gens((expr,), opt)\n    return (poly, gens)",
    ".sympy.polys.polyutils.py@@_parallel_dict_from_expr_if_gens": "def _parallel_dict_from_expr_if_gens(exprs, opt):\n    k, indices = (len(opt.gens), {})\n    for i, g in enumerate(opt.gens):\n        indices[g] = i\n    polys = []\n    for expr in exprs:\n        poly = {}\n        if expr.is_Equality:\n            expr = expr.lhs - expr.rhs\n        for term in Add.make_args(expr):\n            coeff, monom = ([], [0] * k)\n            for factor in Mul.make_args(term):\n                if not _not_a_coeff(factor) and factor.is_Number:\n                    coeff.append(factor)\n                else:\n                    try:\n                        if opt.series is False:\n                            base, exp = decompose_power(factor)\n                            if exp < 0:\n                                exp, base = (-exp, Pow(base, -S.One))\n                        else:\n                            base, exp = decompose_power_rat(factor)\n                        monom[indices[base]] = exp\n                    except KeyError:\n                        if not factor.free_symbols.intersection(opt.gens):\n                            coeff.append(factor)\n                        else:\n                            raise PolynomialError('%s contains an element of the set of generators.' % factor)\n            monom = tuple(monom)\n            if monom in poly:\n                poly[monom] += Mul(*coeff)\n            else:\n                poly[monom] = Mul(*coeff)\n        polys.append(poly)\n    return (polys, opt.gens)",
    ".sympy.polys.polyutils.py@@_not_a_coeff": "def _not_a_coeff(expr):\n    return expr in [S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity]",
    ".sympy.core.numbers.py@@NaN.__eq__": "def __eq__(self, other):\n    return other is S.NaN",
    ".sympy.core.numbers.py@@Infinity.__eq__": "def __eq__(self, other):\n    return other is S.Infinity",
    ".sympy.core.numbers.py@@NegativeInfinity.__eq__": "def __eq__(self, other):\n    return other is S.NegativeInfinity",
    ".sympy.polys.polyoptions.py@@Series.default": "def default(cls):\n    return False",
    ".sympy.core.exprtools.py@@decompose_power": "def decompose_power(expr):\n    base, exp = expr.as_base_exp()\n    if exp.is_Number:\n        if exp.is_Rational:\n            if not exp.is_Integer:\n                base = Pow(base, Rational(1, exp.q))\n            exp = exp.p\n        else:\n            base, exp = (expr, 1)\n    else:\n        exp, tail = exp.as_coeff_Mul(rational=True)\n        if exp is S.NegativeOne:\n            base, exp = (Pow(base, tail), -1)\n        elif exp is not S.One:\n            tail = _keep_coeff(Rational(1, exp.q), tail)\n            base, exp = (Pow(base, tail), exp.p)\n        else:\n            base, exp = (expr, 1)\n    return (base, exp)",
    ".sympy.polys.polyoptions.py@@Options.clone": "def clone(self, updates={}):\n    obj = dict.__new__(self.__class__)\n    for option, value in self.items():\n        obj[option] = value\n    for option, value in updates.items():\n        obj[option] = value\n    return obj",
    ".sympy.polys.polytools.py@@Poly._from_dict": "def _from_dict(cls, rep, opt):\n    gens = opt.gens\n    if not gens:\n        raise GeneratorsNeeded(\"can't initialize from 'dict' without generators\")\n    level = len(gens) - 1\n    domain = opt.domain\n    if domain is None:\n        domain, rep = construct_domain(rep, opt=opt)\n    else:\n        for monom, coeff in rep.items():\n            rep[monom] = domain.convert(coeff)\n    return cls.new(DMP.from_dict(rep, level, domain), *gens)",
    ".sympy.polys.polyoptions.py@@Option.default": "def default(cls):\n    return None",
    ".sympy.polys.constructor.py@@construct_domain": "def construct_domain(obj, **args):\n    opt = build_options(args)\n    if hasattr(obj, '__iter__'):\n        if isinstance(obj, dict):\n            if not obj:\n                monoms, coeffs = ([], [])\n            else:\n                monoms, coeffs = list(zip(*list(obj.items())))\n        else:\n            coeffs = obj\n    else:\n        coeffs = [obj]\n    coeffs = list(map(sympify, coeffs))\n    result = _construct_simple(coeffs, opt)\n    if result is not None:\n        if result is not False:\n            domain, coeffs = result\n        else:\n            domain, coeffs = _construct_expression(coeffs, opt)\n    else:\n        if opt.composite is False:\n            result = None\n        else:\n            result = _construct_composite(coeffs, opt)\n        if result is not None:\n            domain, coeffs = result\n        else:\n            domain, coeffs = _construct_expression(coeffs, opt)\n    if hasattr(obj, '__iter__'):\n        if isinstance(obj, dict):\n            return (domain, dict(list(zip(monoms, coeffs))))\n        else:\n            return (domain, coeffs)\n    else:\n        return (domain, coeffs[0])",
    ".sympy.polys.constructor.py@@_construct_simple": "def _construct_simple(coeffs, opt):\n    result, rationals, reals, algebraics = ({}, False, False, False)\n    if opt.extension is True:\n        is_algebraic = lambda coeff: coeff.is_number and coeff.is_algebraic\n    else:\n        is_algebraic = lambda coeff: False\n    for coeff in coeffs:\n        if coeff.is_Rational:\n            if not coeff.is_Integer:\n                rationals = True\n        elif coeff.is_Float:\n            if not algebraics:\n                reals = True\n            else:\n                return False\n        elif is_algebraic(coeff):\n            if not reals:\n                algebraics = True\n            else:\n                return False\n        else:\n            return None\n    if algebraics:\n        domain, result = _construct_algebraic(coeffs, opt)\n    else:\n        if reals:\n            max_prec = max([c._prec for c in coeffs])\n            domain = RealField(prec=max_prec)\n        elif opt.field or rationals:\n            domain = QQ\n        else:\n            domain = ZZ\n        result = []\n        for coeff in coeffs:\n            result.append(domain.from_sympy(coeff))\n    return (domain, result)",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.from_sympy": "def from_sympy(self, a):\n    if a.is_Integer:\n        return PythonInteger(a.p)\n    elif a.is_Float and int(a) == a:\n        return PythonInteger(int(a))\n    else:\n        raise CoercionFailed('expected an integer, got %s' % a)",
    ".sympy.polys.polyclasses.py@@DMP.from_dict": "def from_dict(cls, rep, lev, dom):\n    return cls(dmp_from_dict(rep, lev, dom), dom, lev)",
    ".sympy.polys.densebasic.py@@dmp_from_dict": "def dmp_from_dict(f, u, K):\n    if not u:\n        return dup_from_dict(f, K)\n    if not f:\n        return dmp_zero(u)\n    coeffs = {}\n    for monom, coeff in f.items():\n        head, tail = (monom[0], monom[1:])\n        if head in coeffs:\n            coeffs[head][tail] = coeff\n        else:\n            coeffs[head] = {tail: coeff}\n    n, v, h = (max(coeffs.keys()), u - 1, [])\n    for k in range(n, -1, -1):\n        coeff = coeffs.get(k)\n        if coeff is not None:\n            h.append(dmp_from_dict(coeff, v, K))\n        else:\n            h.append(dmp_zero(v))\n    return dmp_strip(h, u)",
    ".sympy.polys.densebasic.py@@dup_from_dict": "def dup_from_dict(f, K):\n    if not f:\n        return []\n    n, h = (max(f.keys()), [])\n    if type(n) is int:\n        for k in range(n, -1, -1):\n            h.append(f.get(k, K.zero))\n    else:\n        n, = n\n        for k in range(n, -1, -1):\n            h.append(f.get((k,), K.zero))\n    return dup_strip(h)",
    ".sympy.polys.densebasic.py@@dup_strip": "def dup_strip(f):\n    if not f or f[0]:\n        return f\n    i = 0\n    for cf in f:\n        if cf:\n            break\n        else:\n            i += 1\n    return f[i:]",
    ".sympy.polys.densebasic.py@@dmp_zero": "def dmp_zero(u):\n    r = []\n    for i in range(u):\n        r = [r]\n    return r",
    ".sympy.polys.densebasic.py@@dmp_strip": "def dmp_strip(f, u):\n    if not u:\n        return dup_strip(f)\n    if dmp_zero_p(f, u):\n        return f\n    i, v = (0, u - 1)\n    for c in f:\n        if not dmp_zero_p(c, v):\n            break\n        else:\n            i += 1\n    if i == len(f):\n        return dmp_zero(u)\n    else:\n        return f[i:]",
    ".sympy.polys.densebasic.py@@dmp_zero_p": "def dmp_zero_p(f, u):\n    while u:\n        if len(f) != 1:\n            return False\n        f = f[0]\n        u -= 1\n    return not f",
    ".sympy.polys.polyclasses.py@@DMP.__init__": "def __init__(self, rep, dom, lev=None, ring=None):\n    if lev is not None:\n        if type(rep) is dict:\n            rep = dmp_from_dict(rep, lev, dom)\n        elif type(rep) is not list:\n            rep = dmp_ground(dom.convert(rep), lev)\n    else:\n        rep, lev = dmp_validate(rep)\n    self.rep = rep\n    self.lev = lev\n    self.dom = dom\n    self.ring = ring",
    ".sympy.polys.polytools.py@@Poly.new": "def new(cls, rep, *gens):\n    if not isinstance(rep, DMP):\n        raise PolynomialError('invalid polynomial representation: %s' % rep)\n    elif rep.lev != len(gens) - 1:\n        raise PolynomialError('invalid arguments: %s, %s' % (rep, gens))\n    obj = Basic.__new__(cls)\n    obj.rep = rep\n    obj.gens = gens\n    return obj",
    ".sympy.core.numbers.py@@Integer.__int__": "def __int__(self):\n    return self.p",
    ".sympy.ntheory.multinomial.py@@multinomial_coefficients": "def multinomial_coefficients(m, n):\n    m = as_int(m)\n    n = as_int(n)\n    if not m:\n        if n:\n            return {}\n        return {(): 1}\n    if m == 2:\n        return binomial_coefficients(n)\n    if m >= 2 * n and n > 1:\n        return dict(multinomial_coefficients_iterator(m, n))\n    t = [n] + [0] * (m - 1)\n    r = {tuple(t): 1}\n    if n:\n        j = 0\n    else:\n        j = m\n    while j < m - 1:\n        tj = t[j]\n        if j:\n            t[j] = 0\n            t[0] = tj\n        if tj > 1:\n            t[j + 1] += 1\n            j = 0\n            start = 1\n            v = 0\n        else:\n            j += 1\n            start = j + 1\n            v = r[tuple(t)]\n            t[j] += 1\n        for k in range(start, m):\n            if t[k]:\n                t[k] -= 1\n                v += r[tuple(t)]\n                t[k] += 1\n        t[0] -= 1\n        r[tuple(t)] = v * tj // (n - t[0])\n    return r",
    ".sympy.ntheory.multinomial.py@@binomial_coefficients": "def binomial_coefficients(n):\n    n = as_int(n)\n    d = {(0, n): 1, (n, 0): 1}\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k, n - k] = d[n - k, k] = a\n    return d",
    ".sympy.polys.polyutils.py@@expr_from_dict": "def expr_from_dict(rep, *gens):\n    result = []\n    for monom, coeff in rep.items():\n        term = [coeff]\n        for g, m in zip(gens, monom):\n            if m:\n                term.append(Pow(g, m))\n        result.append(Mul(*term))\n    return Add(*result)",
    ".sympy.core.numbers.py@@Integer._eval_power": "def _eval_power(self, expt):\n    from sympy import perfect_power\n    if expt is S.Infinity:\n        if self.p > S.One:\n            return S.Infinity\n        return S.Infinity + S.ImaginaryUnit * S.Infinity\n    if expt is S.NegativeInfinity:\n        return Rational(1, self) ** S.Infinity\n    if not isinstance(expt, Number):\n        if self.is_negative and expt.is_even:\n            return (-self) ** expt\n    if isinstance(expt, Float):\n        return super(Integer, self)._eval_power(expt)\n    if not isinstance(expt, Rational):\n        return\n    if expt is S.Half and self.is_negative:\n        return S.ImaginaryUnit * Pow(-self, expt)\n    if expt.is_negative:\n        ne = -expt\n        if self.is_negative:\n            return S.NegativeOne ** expt * Rational(1, -self) ** ne\n        else:\n            return Rational(1, self.p) ** ne\n    x, xexact = integer_nthroot(abs(self.p), expt.q)\n    if xexact:\n        result = Integer(x ** abs(expt.p))\n        if self.is_negative:\n            result *= S.NegativeOne ** expt\n        return result\n    b_pos = int(abs(self.p))\n    p = perfect_power(b_pos)\n    if p is not False:\n        dict = {p[0]: p[1]}\n    else:\n        dict = Integer(b_pos).factors(limit=2 ** 15)\n    out_int = 1\n    out_rad = 1\n    sqr_int = 1\n    sqr_gcd = 0\n    sqr_dict = {}\n    for prime, exponent in dict.items():\n        exponent *= expt.p\n        div_e, div_m = divmod(exponent, expt.q)\n        if div_e > 0:\n            out_int *= prime ** div_e\n        if div_m > 0:\n            g = igcd(div_m, expt.q)\n            if g != 1:\n                out_rad *= Pow(prime, Rational(div_m // g, expt.q // g))\n            else:\n                sqr_dict[prime] = div_m\n    for p, ex in sqr_dict.items():\n        if sqr_gcd == 0:\n            sqr_gcd = ex\n        else:\n            sqr_gcd = igcd(sqr_gcd, ex)\n            if sqr_gcd == 1:\n                break\n    for k, v in sqr_dict.items():\n        sqr_int *= k ** (v // sqr_gcd)\n    if sqr_int == b_pos and out_int == 1 and (out_rad == 1):\n        result = None\n    else:\n        result = out_int * out_rad * Pow(sqr_int, Rational(sqr_gcd, expt.q))\n        if self.is_negative:\n            result *= Pow(S.NegativeOne, expt)\n    return result",
    ".sympy.core.power.py@@integer_nthroot": "def integer_nthroot(y, n):\n    y, n = (as_int(y), as_int(n))\n    if y < 0:\n        raise ValueError('y must be nonnegative')\n    if n < 1:\n        raise ValueError('n must be positive')\n    if y in (0, 1):\n        return (y, True)\n    if n == 1:\n        return (y, True)\n    if n == 2:\n        x, rem = mpmath_sqrtrem(y)\n        return (int(x), not rem)\n    if n > y:\n        return (1, False)\n    try:\n        guess = int(y ** (1.0 / n) + 0.5)\n    except OverflowError:\n        exp = _log(y, 2) / n\n        if exp > 53:\n            shift = int(exp - 53)\n            guess = int(2.0 ** (exp - shift) + 1) << shift\n        else:\n            guess = int(2.0 ** exp)\n    if guess > 2 ** 50:\n        xprev, x = (-1, guess)\n        while 1:\n            t = x ** (n - 1)\n            xprev, x = (x, ((n - 1) * x + y // t) // n)\n            if abs(x - xprev) < 2:\n                break\n    else:\n        x = guess\n    t = x ** n\n    while t < y:\n        x += 1\n        t = x ** n\n    while t > y:\n        x -= 1\n        t = x ** n\n    return (int(x), t == y)",
    ".sympy.core.mul.py@@Mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return (coeff, args[0])\n            else:\n                return (coeff, self._new_rawargs(*args))\n        elif coeff.is_negative:\n            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))\n    return (S.One, self)",
    ".sympy.core.mul.py@@Mul._eval_expand_mul": "def _eval_expand_mul(self, **hints):\n    from sympy import fraction\n    expr = self\n    n, d = fraction(expr)\n    if d.is_Mul:\n        n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i for i in (n, d)]\n        expr = n / d\n        if not expr.is_Mul:\n            return expr\n    plain, sums, rewrite = ([], [], False)\n    for factor in expr.args:\n        if factor.is_Add:\n            sums.append(factor)\n            rewrite = True\n        elif factor.is_commutative:\n            plain.append(factor)\n        else:\n            sums.append(Basic(factor))\n    if not rewrite:\n        return expr\n    else:\n        plain = self.func(*plain)\n        if sums:\n            deep = hints.get('deep', False)\n            terms = self.func._expandsums(sums)\n            args = []\n            for term in terms:\n                t = self.func(plain, term)\n                if t.is_Mul and any((a.is_Add for a in t.args)) and deep:\n                    t = t._eval_expand_mul()\n                args.append(t)\n            return Add(*args)\n        else:\n            return plain",
    ".sympy.polys.polytools.py@@Poly.is_linear": "def is_linear(f):\n    return f.rep.is_linear",
    ".sympy.polys.polyclasses.py@@DMP.is_linear": "def is_linear(f):\n    return all((sum(monom) <= 1 for monom in dmp_to_dict(f.rep, f.lev, f.dom).keys()))",
    ".sympy.polys.densebasic.py@@dmp_to_dict": "def dmp_to_dict(f, u, K=None, zero=False):\n    if not u:\n        return dup_to_dict(f, K, zero=zero)\n    if dmp_zero_p(f, u) and zero:\n        return {(0,) * (u + 1): K.zero}\n    n, v, result = (dmp_degree(f, u), u - 1, {})\n    if n == -oo:\n        n = -1\n    for k in range(0, n + 1):\n        h = dmp_to_dict(f[n - k], v)\n        for exp, coeff in h.items():\n            result[(k,) + exp] = coeff\n    return result",
    ".sympy.polys.densebasic.py@@dmp_degree": "def dmp_degree(f, u):\n    if dmp_zero_p(f, u):\n        return -oo\n    else:\n        return len(f) - 1",
    ".sympy.core.numbers.py@@Infinity.__neg__": "def __neg__(self):\n    return S.NegativeInfinity",
    ".sympy.polys.densebasic.py@@dup_to_dict": "def dup_to_dict(f, K=None, zero=False):\n    if not f and zero:\n        return {(0,): K.zero}\n    n, result = (len(f) - 1, {})\n    for k in range(0, n + 1):\n        if f[n - k]:\n            result[k,] = f[n - k]\n    return result",
    ".sympy.solvers.polysys.py@@solve_poly_system": "def solve_poly_system(seq, *gens, **args):\n    try:\n        polys, opt = parallel_poly_from_expr(seq, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('solve_poly_system', len(seq), exc)\n    if len(polys) == len(opt.gens) == 2:\n        f, g = polys\n        if all((i <= 2 for i in f.degree_list() + g.degree_list())):\n            try:\n                return solve_biquadratic(f, g, opt)\n            except SolveFailed:\n                pass\n    return solve_generic(polys, opt)",
    ".sympy.polys.polytools.py@@parallel_poly_from_expr": "def parallel_poly_from_expr(exprs, *gens, **args):\n    opt = options.build_options(gens, args)\n    return _parallel_poly_from_expr(exprs, opt)",
    ".sympy.polys.polytools.py@@_parallel_poly_from_expr": "def _parallel_poly_from_expr(exprs, opt):\n    from sympy.functions.elementary.piecewise import Piecewise\n    if len(exprs) == 2:\n        f, g = exprs\n        if isinstance(f, Poly) and isinstance(g, Poly):\n            f = f.__class__._from_poly(f, opt)\n            g = g.__class__._from_poly(g, opt)\n            f, g = f.unify(g)\n            opt.gens = f.gens\n            opt.domain = f.domain\n            if opt.polys is None:\n                opt.polys = True\n            return ([f, g], opt)\n    origs, exprs = (list(exprs), [])\n    _exprs, _polys = ([], [])\n    failed = False\n    for i, expr in enumerate(origs):\n        expr = sympify(expr)\n        if isinstance(expr, Basic):\n            if expr.is_Poly:\n                _polys.append(i)\n            else:\n                _exprs.append(i)\n                if opt.expand:\n                    expr = expr.expand()\n        else:\n            failed = True\n        exprs.append(expr)\n    if failed:\n        raise PolificationFailed(opt, origs, exprs, True)\n    if _polys:\n        for i in _polys:\n            exprs[i] = exprs[i].as_expr()\n    reps, opt = _parallel_dict_from_expr(exprs, opt)\n    if not opt.gens:\n        raise PolificationFailed(opt, origs, exprs, True)\n    for k in opt.gens:\n        if isinstance(k, Piecewise):\n            raise PolynomialError('Piecewise generators do not make sense')\n    coeffs_list, lengths = ([], [])\n    all_monoms = []\n    all_coeffs = []\n    for rep in reps:\n        monoms, coeffs = list(zip(*list(rep.items())))\n        coeffs_list.extend(coeffs)\n        all_monoms.append(monoms)\n        lengths.append(len(coeffs))\n    domain = opt.domain\n    if domain is None:\n        opt.domain, coeffs_list = construct_domain(coeffs_list, opt=opt)\n    else:\n        coeffs_list = list(map(domain.from_sympy, coeffs_list))\n    for k in lengths:\n        all_coeffs.append(coeffs_list[:k])\n        coeffs_list = coeffs_list[k:]\n    polys = []\n    for monoms, coeffs in zip(all_monoms, all_coeffs):\n        rep = dict(list(zip(monoms, coeffs)))\n        poly = Poly._from_dict(rep, opt)\n        polys.append(poly)\n    if opt.polys is None:\n        opt.polys = bool(_polys)\n    return (polys, opt)",
    ".sympy.polys.polytools.py@@Poly._from_poly": "def _from_poly(cls, rep, opt):\n    if cls != rep.__class__:\n        rep = cls.new(rep.rep, *rep.gens)\n    gens = opt.gens\n    field = opt.field\n    domain = opt.domain\n    if gens and rep.gens != gens:\n        if set(rep.gens) != set(gens):\n            return cls._from_expr(rep.as_expr(), opt)\n        else:\n            rep = rep.reorder(*gens)\n    if 'domain' in opt and domain:\n        rep = rep.set_domain(domain)\n    elif field is True:\n        rep = rep.to_field()\n    return rep",
    ".sympy.polys.polytools.py@@Poly.unify": "def unify(f, g):\n    _, per, F, G = f._unify(g)\n    return (per(F), per(G))",
    ".sympy.polys.polytools.py@@Poly._unify": "def _unify(f, g):\n    g = sympify(g)\n    if not g.is_Poly:\n        try:\n            return (f.rep.dom, f.per, f.rep, f.rep.per(f.rep.dom.from_sympy(g)))\n        except CoercionFailed:\n            raise UnificationFailed(\"can't unify %s with %s\" % (f, g))\n    if isinstance(f.rep, DMP) and isinstance(g.rep, DMP):\n        gens = _unify_gens(f.gens, g.gens)\n        dom, lev = (f.rep.dom.unify(g.rep.dom, gens), len(gens) - 1)\n        if f.gens != gens:\n            f_monoms, f_coeffs = _dict_reorder(f.rep.to_dict(), f.gens, gens)\n            if f.rep.dom != dom:\n                f_coeffs = [dom.convert(c, f.rep.dom) for c in f_coeffs]\n            F = DMP(dict(list(zip(f_monoms, f_coeffs))), dom, lev)\n        else:\n            F = f.rep.convert(dom)\n        if g.gens != gens:\n            g_monoms, g_coeffs = _dict_reorder(g.rep.to_dict(), g.gens, gens)\n            if g.rep.dom != dom:\n                g_coeffs = [dom.convert(c, g.rep.dom) for c in g_coeffs]\n            G = DMP(dict(list(zip(g_monoms, g_coeffs))), dom, lev)\n        else:\n            G = g.rep.convert(dom)\n    else:\n        raise UnificationFailed(\"can't unify %s with %s\" % (f, g))\n    cls = f.__class__\n\n    def per(rep, dom=dom, gens=gens, remove=None):\n        if remove is not None:\n            gens = gens[:remove] + gens[remove + 1:]\n            if not gens:\n                return dom.to_sympy(rep)\n        return cls.new(rep, *gens)\n    return (dom, per, F, G)",
    ".sympy.polys.polytools.py@@Poly.__hash__": "def __hash__(self):\n    return super(Poly, self).__hash__()",
    ".sympy.polys.polytools.py@@Poly._hashable_content": "def _hashable_content(self):\n    return (self.rep, self.gens)",
    ".sympy.polys.polyclasses.py@@DMP.__hash__": "def __hash__(f):\n    return hash((f.__class__.__name__, f.to_tuple(), f.lev, f.dom, f.ring))",
    ".sympy.polys.polyclasses.py@@DMP.to_tuple": "def to_tuple(f):\n    return dmp_to_tuple(f.rep, f.lev)",
    ".sympy.polys.densebasic.py@@dmp_to_tuple": "def dmp_to_tuple(f, u):\n    if not u:\n        return tuple(f)\n    v = u - 1\n    return tuple((dmp_to_tuple(c, v) for c in f))",
    ".sympy.polys.domains.domain.py@@Domain.__hash__": "def __hash__(self):\n    return hash((self.__class__.__name__, self.dtype))",
    ".sympy.polys.polyutils.py@@_unify_gens": "def _unify_gens(f_gens, g_gens):\n    f_gens = list(f_gens)\n    g_gens = list(g_gens)\n    if f_gens == g_gens:\n        return tuple(f_gens)\n    gens, common, k = ([], [], 0)\n    for gen in f_gens:\n        if gen in g_gens:\n            common.append(gen)\n    for i, gen in enumerate(g_gens):\n        if gen in common:\n            g_gens[i], k = (common[k], k + 1)\n    for gen in common:\n        i = f_gens.index(gen)\n        gens.extend(f_gens[:i])\n        f_gens = f_gens[i + 1:]\n        i = g_gens.index(gen)\n        gens.extend(g_gens[:i])\n        g_gens = g_gens[i + 1:]\n        gens.append(gen)\n    gens.extend(f_gens)\n    gens.extend(g_gens)\n    return tuple(gens)",
    ".sympy.polys.domains.domain.py@@Domain.unify": "def unify(K0, K1, symbols=None):\n    if symbols is not None:\n        return K0.unify_with_symbols(K1, symbols)\n    if K0 == K1:\n        return K0\n    if K0.is_EX:\n        return K0\n    if K1.is_EX:\n        return K1\n    if K0.is_Composite or K1.is_Composite:\n        K0_ground = K0.dom if K0.is_Composite else K0\n        K1_ground = K1.dom if K1.is_Composite else K1\n        K0_symbols = K0.symbols if K0.is_Composite else ()\n        K1_symbols = K1.symbols if K1.is_Composite else ()\n        domain = K0_ground.unify(K1_ground)\n        symbols = _unify_gens(K0_symbols, K1_symbols)\n        order = K0.order if K0.is_Composite else K1.order\n        if (K0.is_FractionField and K1.is_PolynomialRing or (K1.is_FractionField and K0.is_PolynomialRing)) and (not K0_ground.is_Field or not K1_ground.is_Field) and domain.is_Field:\n            domain = domain.get_ring()\n        if K0.is_Composite and (not K1.is_Composite or K0.is_FractionField or K1.is_PolynomialRing):\n            cls = K0.__class__\n        else:\n            cls = K1.__class__\n        from sympy.polys.domains.old_polynomialring import GlobalPolynomialRing\n        if cls == GlobalPolynomialRing:\n            return cls(domain, symbols)\n        return cls(domain, symbols, order)\n\n    def mkinexact(cls, K0, K1):\n        prec = max(K0.precision, K1.precision)\n        tol = max(K0.tolerance, K1.tolerance)\n        return cls(prec=prec, tol=tol)\n    if K0.is_ComplexField and K1.is_ComplexField:\n        return mkinexact(K0.__class__, K0, K1)\n    if K0.is_ComplexField and K1.is_RealField:\n        return mkinexact(K0.__class__, K0, K1)\n    if K0.is_RealField and K1.is_ComplexField:\n        return mkinexact(K1.__class__, K1, K0)\n    if K0.is_RealField and K1.is_RealField:\n        return mkinexact(K0.__class__, K0, K1)\n    if K0.is_ComplexField or K0.is_RealField:\n        return K0\n    if K1.is_ComplexField or K1.is_RealField:\n        return K1\n    if K0.is_AlgebraicField and K1.is_AlgebraicField:\n        return K0.__class__(K0.dom.unify(K1.dom), *_unify_gens(K0.orig_ext, K1.orig_ext))\n    elif K0.is_AlgebraicField:\n        return K0\n    elif K1.is_AlgebraicField:\n        return K1\n    if K0.is_RationalField:\n        return K0\n    if K1.is_RationalField:\n        return K1\n    if K0.is_IntegerRing:\n        return K0\n    if K1.is_IntegerRing:\n        return K1\n    if K0.is_FiniteField and K1.is_FiniteField:\n        return K0.__class__(max(K0.mod, K1.mod, key=default_sort_key))\n    from sympy.polys.domains import EX\n    return EX",
    ".sympy.polys.domains.domain.py@@Domain.unify_with_symbols": "def unify_with_symbols(K0, K1, symbols):\n    if K0.is_Composite and set(K0.symbols) & set(symbols) or (K1.is_Composite and set(K1.symbols) & set(symbols)):\n        raise UnificationFailed(\"can't unify %s with %s, given %s generators\" % (K0, K1, tuple(symbols)))\n    return K0.unify(K1)",
    ".sympy.polys.domains.domain.py@@Domain.__eq__": "def __eq__(self, other):\n    return isinstance(other, Domain) and self.dtype == other.dtype",
    ".sympy.polys.polyclasses.py@@DMP.convert": "def convert(f, dom):\n    if f.dom == dom:\n        return f\n    else:\n        return DMP(dmp_convert(f.rep, f.lev, f.dom, dom), dom, f.lev)",
    ".sympy.polys.polytools.py@@Poly.per": "def per(f, rep, gens=None, remove=None):\n    if gens is None:\n        gens = f.gens\n    if remove is not None:\n        gens = gens[:remove] + gens[remove + 1:]\n        if not gens:\n            return f.rep.dom.to_sympy(rep)\n    return f.__class__.new(rep, *gens)",
    ".sympy.polys.polyoptions.py@@Options.__setattr__": "def __setattr__(self, attr, value):\n    if attr in self.__options__:\n        self[attr] = value\n    else:\n        super(Options, self).__setattr__(attr, value)",
    ".sympy.polys.polytools.py@@Poly.domain": "def domain(self):\n    return self.get_domain()",
    ".sympy.polys.polytools.py@@Poly.get_domain": "def get_domain(f):\n    return f.rep.dom",
    ".sympy.polys.polytools.py@@Poly.degree_list": "def degree_list(f):\n    if hasattr(f.rep, 'degree_list'):\n        return f.rep.degree_list()\n    else:\n        raise OperationNotSupported(f, 'degree_list')",
    ".sympy.polys.polyclasses.py@@DMP.degree_list": "def degree_list(f):\n    return dmp_degree_list(f.rep, f.lev)",
    ".sympy.polys.densebasic.py@@dmp_degree_list": "def dmp_degree_list(f, u):\n    degs = [-oo] * (u + 1)\n    _rec_degree_list(f, u, 0, degs)\n    return tuple(degs)",
    ".sympy.polys.densebasic.py@@_rec_degree_list": "def _rec_degree_list(g, v, i, degs):\n    degs[i] = max(degs[i], dmp_degree(g, v))\n    if v > 0:\n        v, i = (v - 1, i + 1)\n        for c in g:\n            _rec_degree_list(c, v, i, degs)",
    ".sympy.core.numbers.py@@NegativeInfinity.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    if other.is_real:\n        if other.is_finite or other is S.Infinity:\n            return S.true\n        elif other.is_nonnegative:\n            return S.true\n        elif other.is_infinite and other.is_negative:\n            return S.false\n    return Expr.__lt__(self, other)",
    ".sympy.core.numbers.py@@NegativeInfinity.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s > %s' % (self, other))\n    if other.is_real:\n        return S.false\n    return Expr.__gt__(self, other)",
    ".sympy.logic.boolalg.py@@BooleanFalse.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.solvers.polysys.py@@solve_biquadratic": "def solve_biquadratic(f, g, opt):\n    G = groebner([f, g])\n    if len(G) == 1 and G[0].is_ground:\n        return None\n    if len(G) != 2:\n        raise SolveFailed\n    x, y = opt.gens\n    p, q = G\n    if not p.gcd(q).is_ground:\n        raise SolveFailed\n    p = Poly(p, x, expand=False)\n    p_roots = [rcollect(expr, y) for expr in roots(p).keys()]\n    q = q.ltrim(-1)\n    q_roots = list(roots(q).keys())\n    solutions = []\n    for q_root in q_roots:\n        for p_root in p_roots:\n            solution = (p_root.subs(y, q_root), q_root)\n            solutions.append(solution)\n    return sorted(solutions, key=default_sort_key)",
    ".sympy.polys.polytools.py@@groebner": "def groebner(F, *gens, **args):\n    return GroebnerBasis(F, *gens, **args)",
    ".sympy.polys.polytools.py@@GroebnerBasis.__new__": "def __new__(cls, F, *gens, **args):\n    options.allowed_flags(args, ['polys', 'method'])\n    try:\n        polys, opt = parallel_poly_from_expr(F, *gens, **args)\n    except PolificationFailed as exc:\n        raise ComputationFailed('groebner', len(F), exc)\n    from sympy.polys.rings import PolyRing\n    ring = PolyRing(opt.gens, opt.domain, opt.order)\n    polys = [ring.from_dict(poly.rep.to_dict()) for poly in polys if poly]\n    G = _groebner(polys, ring, method=opt.method)\n    G = [Poly._from_dict(g, opt) for g in G]\n    return cls._new(G, opt)",
    ".sympy.polys.polyoptions.py@@allowed_flags": "def allowed_flags(args, flags):\n    flags = set(flags)\n    for arg in args.keys():\n        try:\n            if Options.__options__[arg].is_Flag and (not arg in flags):\n                raise FlagError(\"'%s' flag is not allowed in this context\" % arg)\n        except KeyError:\n            raise OptionError(\"'%s' is not a valid option\" % arg)",
    ".sympy.polys.polyoptions.py@@Gens.default": "def default(cls):\n    return ()",
    ".sympy.polys.polyoptions.py@@Order.default": "def default(cls):\n    return sympy.polys.orderings.lex",
    ".sympy.polys.rings.py@@PolyRing.__new__": "def __new__(cls, symbols, domain, order=lex):\n    symbols = tuple(_parse_symbols(symbols))\n    ngens = len(symbols)\n    domain = DomainOpt.preprocess(domain)\n    order = OrderOpt.preprocess(order)\n    _hash_tuple = (cls.__name__, symbols, ngens, domain, order)\n    obj = _ring_cache.get(_hash_tuple)\n    if obj is None:\n        if domain.is_Composite and set(symbols) & set(domain.symbols):\n            raise GeneratorsError(\"polynomial ring and it's ground domain share generators\")\n        obj = object.__new__(cls)\n        obj._hash_tuple = _hash_tuple\n        obj._hash = hash(_hash_tuple)\n        obj.dtype = type('PolyElement', (PolyElement,), {'ring': obj})\n        obj.symbols = symbols\n        obj.ngens = ngens\n        obj.domain = domain\n        obj.order = order\n        obj.zero_monom = (0,) * ngens\n        obj.gens = obj._gens()\n        obj._gens_set = set(obj.gens)\n        obj._one = [(obj.zero_monom, domain.one)]\n        if ngens:\n            codegen = MonomialOps(ngens)\n            obj.monomial_mul = codegen.mul()\n            obj.monomial_pow = codegen.pow()\n            obj.monomial_mulpow = codegen.mulpow()\n            obj.monomial_ldiv = codegen.ldiv()\n            obj.monomial_div = codegen.div()\n            obj.monomial_lcm = codegen.lcm()\n            obj.monomial_gcd = codegen.gcd()\n        else:\n            monunit = lambda a, b: ()\n            obj.monomial_mul = monunit\n            obj.monomial_pow = monunit\n            obj.monomial_mulpow = lambda a, b, c: ()\n            obj.monomial_ldiv = monunit\n            obj.monomial_div = monunit\n            obj.monomial_lcm = monunit\n            obj.monomial_gcd = monunit\n        if order is lex:\n            obj.leading_expv = lambda f: max(f)\n        else:\n            obj.leading_expv = lambda f: max(f, key=order)\n        for symbol, generator in zip(obj.symbols, obj.gens):\n            if isinstance(symbol, Symbol):\n                name = symbol.name\n                if not hasattr(obj, name):\n                    setattr(obj, name, generator)\n        _ring_cache[_hash_tuple] = obj\n    return obj",
    ".sympy.polys.rings.py@@_parse_symbols": "def _parse_symbols(symbols):\n    if isinstance(symbols, string_types):\n        return _symbols(symbols, seq=True) if symbols else ()\n    elif isinstance(symbols, Expr):\n        return (symbols,)\n    elif is_sequence(symbols):\n        if all((isinstance(s, string_types) for s in symbols)):\n            return _symbols(symbols)\n        elif all((isinstance(s, Expr) for s in symbols)):\n            return symbols\n    raise GeneratorsError('expected a string, Symbol or expression or a non-empty sequence of strings, Symbols or expressions')",
    ".sympy.polys.polyoptions.py@@Domain.preprocess": "def preprocess(cls, domain):\n    if isinstance(domain, sympy.polys.domains.Domain):\n        return domain\n    elif hasattr(domain, 'to_domain'):\n        return domain.to_domain()\n    elif isinstance(domain, string_types):\n        if domain in ['Z', 'ZZ']:\n            return sympy.polys.domains.ZZ\n        if domain in ['Q', 'QQ']:\n            return sympy.polys.domains.QQ\n        if domain == 'EX':\n            return sympy.polys.domains.EX\n        r = cls._re_realfield.match(domain)\n        if r is not None:\n            _, _, prec = r.groups()\n            if prec is None:\n                return sympy.polys.domains.RR\n            else:\n                return sympy.polys.domains.RealField(int(prec))\n        r = cls._re_complexfield.match(domain)\n        if r is not None:\n            _, _, prec = r.groups()\n            if prec is None:\n                return sympy.polys.domains.CC\n            else:\n                return sympy.polys.domains.ComplexField(int(prec))\n        r = cls._re_finitefield.match(domain)\n        if r is not None:\n            return sympy.polys.domains.FF(int(r.groups()[1]))\n        r = cls._re_polynomial.match(domain)\n        if r is not None:\n            ground, gens = r.groups()\n            gens = list(map(sympify, gens.split(',')))\n            if ground in ['Z', 'ZZ']:\n                return sympy.polys.domains.ZZ.poly_ring(*gens)\n            else:\n                return sympy.polys.domains.QQ.poly_ring(*gens)\n        r = cls._re_fraction.match(domain)\n        if r is not None:\n            ground, gens = r.groups()\n            gens = list(map(sympify, gens.split(',')))\n            if ground in ['Z', 'ZZ']:\n                return sympy.polys.domains.ZZ.frac_field(*gens)\n            else:\n                return sympy.polys.domains.QQ.frac_field(*gens)\n        r = cls._re_algebraic.match(domain)\n        if r is not None:\n            gens = list(map(sympify, r.groups()[1].split(',')))\n            return sympy.polys.domains.QQ.algebraic_field(*gens)\n    raise OptionError('expected a valid domain specification, got %s' % domain)",
    ".sympy.polys.polyoptions.py@@Order.preprocess": "def preprocess(cls, order):\n    return sympy.polys.orderings.monomial_key(order)",
    ".sympy.polys.orderings.py@@monomial_key": "def monomial_key(order=None, gens=None):\n    if order is None:\n        order = lex\n    if isinstance(order, Symbol):\n        order = str(order)\n    if isinstance(order, str):\n        try:\n            order = _monomial_key[order]\n        except KeyError:\n            raise ValueError(\"supported monomial orderings are 'lex', 'grlex' and 'grevlex', got %r\" % order)\n    if hasattr(order, '__call__'):\n        if gens is not None:\n\n            def _order(expr):\n                return order(expr.as_poly(*gens).degree_list())\n            return _order\n        return order\n    else:\n        raise ValueError('monomial ordering specification must be a string or a callable, got %s' % order)",
    ".sympy.polys.orderings.py@@MonomialOrder.__hash__": "def __hash__(self):\n    return hash(self.__class__)",
    ".sympy.polys.rings.py@@PolyRing._gens": "def _gens(self):\n    one = self.domain.one\n    _gens = []\n    for i in range(self.ngens):\n        expv = self.monomial_basis(i)\n        poly = self.zero\n        poly[expv] = one\n        _gens.append(poly)\n    return tuple(_gens)",
    ".sympy.polys.rings.py@@PolyRing.monomial_basis": "def monomial_basis(self, i):\n    basis = [0] * self.ngens\n    basis[i] = 1\n    return tuple(basis)",
    ".sympy.polys.rings.py@@PolyRing.zero": "def zero(self):\n    return self.dtype()",
    ".sympy.polys.rings.py@@PolyElement.__hash__": "def __hash__(self):\n    _hash = self._hash\n    if _hash is None:\n        self._hash = _hash = hash((self.ring, frozenset(self.items())))\n    return _hash",
    ".sympy.polys.rings.py@@PolyRing.__hash__": "def __hash__(self):\n    return self._hash",
    ".sympy.polys.monomials.py@@MonomialOps.__init__": "def __init__(self, ngens):\n    self.ngens = ngens",
    ".sympy.polys.monomials.py@@MonomialOps.mul": "def mul(self):\n    name = 'monomial_mul'\n    template = dedent('    def %(name)s(A, B):\\n        (%(A)s,) = A\\n        (%(B)s,) = B\\n        return (%(AB)s,)\\n    ')\n    A = self._vars('a')\n    B = self._vars('b')\n    AB = ['%s + %s' % (a, b) for a, b in zip(A, B)]\n    code = template % dict(name=name, A=', '.join(A), B=', '.join(B), AB=', '.join(AB))\n    return self._build(code, name)",
    ".sympy.polys.monomials.py@@MonomialOps._vars": "def _vars(self, name):\n    return ['%s%s' % (name, i) for i in range(self.ngens)]",
    ".sympy.polys.monomials.py@@MonomialOps._build": "def _build(self, code, name):\n    ns = {}\n    exec_(code, ns)\n    return ns[name]",
    ".sympy.polys.monomials.py@@MonomialOps.pow": "def pow(self):\n    name = 'monomial_pow'\n    template = dedent('    def %(name)s(A, k):\\n        (%(A)s,) = A\\n        return (%(Ak)s,)\\n    ')\n    A = self._vars('a')\n    Ak = ['%s*k' % a for a in A]\n    code = template % dict(name=name, A=', '.join(A), Ak=', '.join(Ak))\n    return self._build(code, name)",
    ".sympy.polys.monomials.py@@MonomialOps.mulpow": "def mulpow(self):\n    name = 'monomial_mulpow'\n    template = dedent('    def %(name)s(A, B, k):\\n        (%(A)s,) = A\\n        (%(B)s,) = B\\n        return (%(ABk)s,)\\n    ')\n    A = self._vars('a')\n    B = self._vars('b')\n    ABk = ['%s + %s*k' % (a, b) for a, b in zip(A, B)]\n    code = template % dict(name=name, A=', '.join(A), B=', '.join(B), ABk=', '.join(ABk))\n    return self._build(code, name)",
    ".sympy.polys.monomials.py@@MonomialOps.ldiv": "def ldiv(self):\n    name = 'monomial_ldiv'\n    template = dedent('    def %(name)s(A, B):\\n        (%(A)s,) = A\\n        (%(B)s,) = B\\n        return (%(AB)s,)\\n    ')\n    A = self._vars('a')\n    B = self._vars('b')\n    AB = ['%s - %s' % (a, b) for a, b in zip(A, B)]\n    code = template % dict(name=name, A=', '.join(A), B=', '.join(B), AB=', '.join(AB))\n    return self._build(code, name)",
    ".sympy.polys.monomials.py@@MonomialOps.div": "def div(self):\n    name = 'monomial_div'\n    template = dedent('    def %(name)s(A, B):\\n        (%(A)s,) = A\\n        (%(B)s,) = B\\n        %(RAB)s\\n        return (%(R)s,)\\n    ')\n    A = self._vars('a')\n    B = self._vars('b')\n    RAB = ['r%(i)s = a%(i)s - b%(i)s\\n    if r%(i)s < 0: return None' % dict(i=i) for i in range(self.ngens)]\n    R = self._vars('r')\n    code = template % dict(name=name, A=', '.join(A), B=', '.join(B), RAB='\\n    '.join(RAB), R=', '.join(R))\n    return self._build(code, name)",
    ".sympy.polys.monomials.py@@MonomialOps.lcm": "def lcm(self):\n    name = 'monomial_lcm'\n    template = dedent('    def %(name)s(A, B):\\n        (%(A)s,) = A\\n        (%(B)s,) = B\\n        return (%(AB)s,)\\n    ')\n    A = self._vars('a')\n    B = self._vars('b')\n    AB = ['%s if %s >= %s else %s' % (a, a, b, b) for a, b in zip(A, B)]\n    code = template % dict(name=name, A=', '.join(A), B=', '.join(B), AB=', '.join(AB))\n    return self._build(code, name)",
    ".sympy.polys.monomials.py@@MonomialOps.gcd": "def gcd(self):\n    name = 'monomial_gcd'\n    template = dedent('    def %(name)s(A, B):\\n        (%(A)s,) = A\\n        (%(B)s,) = B\\n        return (%(AB)s,)\\n    ')\n    A = self._vars('a')\n    B = self._vars('b')\n    AB = ['%s if %s <= %s else %s' % (a, a, b, b) for a, b in zip(A, B)]\n    code = template % dict(name=name, A=', '.join(A), B=', '.join(B), AB=', '.join(AB))\n    return self._build(code, name)",
    ".sympy.polys.polytools.py@@Poly.__nonzero__": "def __nonzero__(f):\n    return not f.is_zero",
    ".sympy.polys.polytools.py@@Poly.is_zero": "def is_zero(f):\n    return f.rep.is_zero",
    ".sympy.polys.polyclasses.py@@DMP.is_zero": "def is_zero(f):\n    return dmp_zero_p(f.rep, f.lev)",
    ".sympy.polys.polyclasses.py@@DMP.to_dict": "def to_dict(f, zero=False):\n    return dmp_to_dict(f.rep, f.lev, f.dom, zero=zero)",
    ".sympy.polys.rings.py@@PolyRing.from_dict": "def from_dict(self, element):\n    domain_new = self.domain_new\n    poly = self.zero\n    for monom, coeff in element.items():\n        coeff = domain_new(coeff)\n        if coeff:\n            poly[monom] = coeff\n    return poly",
    ".sympy.polys.rings.py@@PolyRing.domain_new": "def domain_new(self, element, orig_domain=None):\n    return self.domain.convert(element, orig_domain)",
    ".sympy.polys.domains.domain.py@@Domain.convert": "def convert(self, element, base=None):\n    if base is not None:\n        return self.convert_from(element, base)\n    if self.of_type(element):\n        return element\n    from sympy.polys.domains import PythonIntegerRing, GMPYIntegerRing, GMPYRationalField, RealField, ComplexField\n    if isinstance(element, integer_types):\n        return self.convert_from(element, PythonIntegerRing())\n    if HAS_GMPY:\n        integers = GMPYIntegerRing()\n        if isinstance(element, integers.tp):\n            return self.convert_from(element, integers)\n        rationals = GMPYRationalField()\n        if isinstance(element, rationals.tp):\n            return self.convert_from(element, rationals)\n    if isinstance(element, float):\n        parent = RealField(tol=False)\n        return self.convert_from(parent(element), parent)\n    if isinstance(element, complex):\n        parent = ComplexField(tol=False)\n        return self.convert_from(parent(element), parent)\n    if isinstance(element, DomainElement):\n        return self.convert_from(element, element.parent())\n    if self.is_Numerical and getattr(element, 'is_ground', False):\n        return self.convert(element.LC())\n    if isinstance(element, Basic):\n        try:\n            return self.from_sympy(element)\n        except (TypeError, ValueError):\n            pass\n    elif not is_sequence(element):\n        try:\n            element = sympify(element)\n            if isinstance(element, Basic):\n                return self.from_sympy(element)\n        except (TypeError, ValueError):\n            pass\n    raise CoercionFailed(\"can't convert %s of type %s to %s\" % (element, type(element), self))",
    ".sympy.polys.domains.domain.py@@Domain.of_type": "def of_type(self, element):\n    return isinstance(element, self.tp)",
    ".sympy.polys.domains.domain.py@@Domain.tp": "def tp(self):\n    return self.dtype",
    ".sympy.polys.groebnertools.py@@groebner": "def groebner(seq, ring, method=None):\n    if method is None:\n        method = query('groebner')\n    _groebner_methods = {'buchberger': _buchberger, 'f5b': _f5b}\n    try:\n        _groebner = _groebner_methods[method]\n    except KeyError:\n        raise ValueError(\"'%s' is not a valid Groebner bases algorithm (valid are 'buchberger' and 'f5b')\" % method)\n    domain, orig = (ring.domain, None)\n    if not domain.is_Field or not domain.has_assoc_Field:\n        try:\n            orig, ring = (ring, ring.clone(domain=domain.get_field()))\n        except DomainError:\n            raise DomainError(\"can't compute a Groebner basis over %s\" % domain)\n        else:\n            seq = [s.set_ring(ring) for s in seq]\n    G = _groebner(seq, ring)\n    if orig is not None:\n        G = [g.clear_denoms()[1].set_ring(orig) for g in G]\n    return G",
    ".sympy.polys.polyconfig.py@@query": "def query(key):\n    return _current_config.get(key.upper(), None)",
    ".sympy.polys.domains.integerring.py@@IntegerRing.get_field": "def get_field(self):\n    from sympy.polys.domains import QQ\n    return QQ",
    ".sympy.polys.rings.py@@PolyRing.clone": "def clone(self, symbols=None, domain=None, order=None):\n    return self.__class__(symbols or self.symbols, domain or self.domain, order or self.order)",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__hash__": "def __hash__(self):\n    if self.q == 1:\n        return hash(self.p)\n    else:\n        return hash((self.p, self.q))",
    ".sympy.polys.rings.py@@PolyElement.set_ring": "def set_ring(self, new_ring):\n    if self.ring == new_ring:\n        return self\n    elif self.ring.symbols != new_ring.symbols:\n        terms = list(zip(*_dict_reorder(self, self.ring.symbols, new_ring.symbols)))\n        return new_ring.from_terms(terms)\n    else:\n        return new_ring.from_dict(self)",
    ".sympy.polys.rings.py@@PolyRing.__eq__": "def __eq__(self, other):\n    return isinstance(other, PolyRing) and (self.symbols, self.domain, self.ngens, self.order) == (other.symbols, other.domain, other.ngens, other.order)",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.__init__": "def __init__(self):",
    ".sympy.polys.domains.domain.py@@Domain.convert_from": "def convert_from(self, element, base):\n    if base.alias is not None:\n        method = 'from_' + base.alias\n    else:\n        method = 'from_' + base.__class__.__name__\n    _convert = getattr(self, method)\n    if _convert is not None:\n        result = _convert(element, base)\n        if result is not None:\n            return result\n    raise CoercionFailed(\"can't convert %s of type %s from %s to %s\" % (element, type(element), base, self))",
    ".sympy.polys.domains.pythonrationalfield.py@@PythonRationalField.from_ZZ_python": "def from_ZZ_python(K1, a, K0):\n    return PythonRational(a)",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__init__": "def __init__(self, p, q=1, _gcd=True):\n    from sympy.polys.domains.groundtypes import python_gcd as gcd\n    if isinstance(p, Integer):\n        p = p.p\n    elif isinstance(p, Rational):\n        p, q = (p.p, p.q)\n    if not q:\n        raise ZeroDivisionError('rational number')\n    elif q < 0:\n        p, q = (-p, -q)\n    if not p:\n        self.p = 0\n        self.q = 1\n    elif p == 1 or q == 1:\n        self.p = p\n        self.q = q\n    else:\n        if _gcd:\n            x = gcd(p, q)\n            if x != 1:\n                p //= x\n                q //= x\n        self.p = p\n        self.q = q",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__nonzero__": "def __nonzero__(self):\n    return self.p != 0",
    ".sympy.polys.groebnertools.py@@_buchberger": "def _buchberger(f, ring):\n    order = ring.order\n    domain = ring.domain\n    monomial_mul = ring.monomial_mul\n    monomial_div = ring.monomial_div\n    monomial_lcm = ring.monomial_lcm\n\n    def select(P):\n        pr = min(P, key=lambda pair: order(monomial_lcm(f[pair[0]].LM, f[pair[1]].LM)))\n        return pr\n\n    def normal(g, J):\n        h = g.rem([f[j] for j in J])\n        if not h:\n            return None\n        else:\n            h = h.monic()\n            if not h in I:\n                I[h] = len(f)\n                f.append(h)\n            return (h.LM, I[h])\n\n    def update(G, B, ih):\n        h = f[ih]\n        mh = h.LM\n        C = G.copy()\n        D = set()\n        while C:\n            ig = C.pop()\n            g = f[ig]\n            mg = g.LM\n            LCMhg = monomial_lcm(mh, mg)\n\n            def lcm_divides(ip):\n                m = monomial_lcm(mh, f[ip].LM)\n                return monomial_div(LCMhg, m)\n            if monomial_mul(mh, mg) == LCMhg or (not any((lcm_divides(ipx) for ipx in C)) and (not any((lcm_divides(pr[1]) for pr in D)))):\n                D.add((ih, ig))\n        E = set()\n        while D:\n            ih, ig = D.pop()\n            mg = f[ig].LM\n            LCMhg = monomial_lcm(mh, mg)\n            if not monomial_mul(mh, mg) == LCMhg:\n                E.add((ih, ig))\n        B_new = set()\n        while B:\n            ig1, ig2 = B.pop()\n            mg1 = f[ig1].LM\n            mg2 = f[ig2].LM\n            LCM12 = monomial_lcm(mg1, mg2)\n            if not monomial_div(LCM12, mh) or monomial_lcm(mg1, mh) == LCM12 or monomial_lcm(mg2, mh) == LCM12:\n                B_new.add((ig1, ig2))\n        B_new |= E\n        G_new = set()\n        while G:\n            ig = G.pop()\n            mg = f[ig].LM\n            if not monomial_div(mg, mh):\n                G_new.add(ig)\n        G_new.add(ih)\n        return (G_new, B_new)\n    if not f:\n        return []\n    f1 = f[:]\n    while True:\n        f = f1[:]\n        f1 = []\n        for i in range(len(f)):\n            p = f[i]\n            r = p.rem(f[:i])\n            if r:\n                f1.append(r.monic())\n        if f == f1:\n            break\n    I = {}\n    F = set()\n    G = set()\n    CP = set()\n    for i, h in enumerate(f):\n        I[h] = i\n        F.add(i)\n    while F:\n        h = min([f[x] for x in F], key=lambda f: order(f.LM))\n        ih = I[h]\n        F.remove(ih)\n        G, CP = update(G, CP, ih)\n    reductions_to_zero = 0\n    while CP:\n        ig1, ig2 = select(CP)\n        CP.remove((ig1, ig2))\n        h = spoly(f[ig1], f[ig2], ring)\n        G1 = sorted(G, key=lambda g: order(f[g].LM))\n        ht = normal(h, G1)\n        if ht:\n            G, CP = update(G, CP, ht[1])\n        else:\n            reductions_to_zero += 1\n    Gr = set()\n    for ig in G:\n        ht = normal(f[ig], G - set([ig]))\n        if ht:\n            Gr.add(ht[1])\n    Gr = [f[ig] for ig in Gr]\n    Gr = sorted(Gr, key=lambda f: order(f.LM), reverse=True)\n    return Gr",
    ".sympy.polys.rings.py@@PolyElement.rem": "def rem(self, G):\n    f = self\n    if isinstance(G, PolyElement):\n        G = [G]\n    if any((not g for g in G)):\n        raise ZeroDivisionError('polynomial division')\n    ring = f.ring\n    domain = ring.domain\n    order = ring.order\n    zero = domain.zero\n    monomial_mul = ring.monomial_mul\n    r = ring.zero\n    term_div = f._term_div()\n    ltf = f.LT\n    f = f.copy()\n    get = f.get\n    while f:\n        for g in G:\n            tq = term_div(ltf, g.LT)\n            if tq is not None:\n                m, c = tq\n                for mg, cg in g.iterterms():\n                    m1 = monomial_mul(mg, m)\n                    c1 = get(m1, zero) - c * cg\n                    if not c1:\n                        del f[m1]\n                    else:\n                        f[m1] = c1\n                ltm = f.leading_expv()\n                if ltm is not None:\n                    ltf = (ltm, f[ltm])\n                break\n        else:\n            ltm, ltc = ltf\n            if ltm in r:\n                r[ltm] += ltc\n            else:\n                r[ltm] = ltc\n            del f[ltm]\n            ltm = f.leading_expv()\n            if ltm is not None:\n                ltf = (ltm, f[ltm])\n    return r",
    ".sympy.polys.rings.py@@PolyElement._term_div": "def _term_div(self):\n    zm = self.ring.zero_monom\n    domain = self.ring.domain\n    domain_quo = domain.quo\n    monomial_div = self.ring.monomial_div\n    if domain.is_Field:\n\n        def term_div(a_lm_a_lc, b_lm_b_lc):\n            a_lm, a_lc = a_lm_a_lc\n            b_lm, b_lc = b_lm_b_lc\n            if b_lm == zm:\n                monom = a_lm\n            else:\n                monom = monomial_div(a_lm, b_lm)\n            if monom is not None:\n                return (monom, domain_quo(a_lc, b_lc))\n            else:\n                return None\n    else:\n\n        def term_div(a_lm_a_lc, b_lm_b_lc):\n            a_lm, a_lc = a_lm_a_lc\n            b_lm, b_lc = b_lm_b_lc\n            if b_lm == zm:\n                monom = a_lm\n            else:\n                monom = monomial_div(a_lm, b_lm)\n            if not (monom is None or a_lc % b_lc):\n                return (monom, domain_quo(a_lc, b_lc))\n            else:\n                return None\n    return term_div",
    ".sympy.polys.rings.py@@PolyElement.LT": "def LT(self):\n    expv = self.leading_expv()\n    if expv is None:\n        return (self.ring.zero_monom, self.ring.domain.zero)\n    else:\n        return (expv, self._get_coeff(expv))",
    ".sympy.polys.rings.py@@PolyElement.leading_expv": "def leading_expv(self):\n    if self:\n        return self.ring.leading_expv(self)\n    else:\n        return None",
    ".sympy.polys.rings.py@@PolyElement._get_coeff": "def _get_coeff(self, expv):\n    return self.get(expv, self.ring.domain.zero)",
    ".sympy.polys.rings.py@@PolyElement.copy": "def copy(self):\n    return self.new(self)",
    ".sympy.polys.rings.py@@PolyElement.new": "def new(self, init):\n    return self.__class__(init)",
    ".sympy.polys.rings.py@@PolyElement.monic": "def monic(f):\n    if not f:\n        return f\n    else:\n        return f.quo_ground(f.LC)",
    ".sympy.polys.rings.py@@PolyElement.LC": "def LC(self):\n    return self._get_coeff(self.leading_expv())",
    ".sympy.polys.rings.py@@PolyElement.quo_ground": "def quo_ground(f, x):\n    domain = f.ring.domain\n    if not x:\n        raise ZeroDivisionError('polynomial division')\n    if not f or x == domain.one:\n        return f\n    if domain.is_Field:\n        quo = domain.quo\n        terms = [(monom, quo(coeff, x)) for monom, coeff in f.iterterms()]\n    else:\n        terms = [(monom, coeff // x) for monom, coeff in f.iterterms() if not coeff % x]\n    return f.new(terms)",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__eq__": "def __eq__(self, other):\n    if isinstance(other, PythonRational):\n        return self.q == other.q and self.p == other.p\n    elif isinstance(other, integer_types):\n        return self.q == 1 and self.p == other\n    else:\n        return False",
    ".sympy.polys.rings.py@@PolyElement.term_div": "def term_div(a_lm_a_lc, b_lm_b_lc):\n    a_lm, a_lc = a_lm_a_lc\n    b_lm, b_lc = b_lm_b_lc\n    if b_lm == zm:\n        monom = a_lm\n    else:\n        monom = monomial_div(a_lm, b_lm)\n    if not (monom is None or a_lc % b_lc):\n        return (monom, domain_quo(a_lc, b_lc))\n    else:\n        return None",
    ".sympy.polys.domains.field.py@@Field.quo": "def quo(self, a, b):\n    return a / b",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__div__": "def __div__(self, other):\n    from sympy.polys.domains.groundtypes import python_gcd as gcd\n    if isinstance(other, PythonRational):\n        ap, aq, bp, bq = (self.p, self.q, other.p, other.q)\n        x1 = gcd(ap, bp)\n        x2 = gcd(bq, aq)\n        p, q = (ap // x1 * (bq // x2), aq // x2 * (bp // x1))\n    elif isinstance(other, integer_types):\n        x = gcd(other, self.p)\n        p = self.p // x\n        q = self.q * (other // x)\n    else:\n        return NotImplemented\n    return self.__class__(p, q, _gcd=False)",
    ".sympy.polys.rings.py@@PolyElement.iterterms": "def iterterms(self):\n    return iter(self.items())",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__mul__": "def __mul__(self, other):\n    from sympy.polys.domains.groundtypes import python_gcd as gcd\n    if isinstance(other, PythonRational):\n        ap, aq, bp, bq = (self.p, self.q, other.p, other.q)\n        x1 = gcd(ap, bq)\n        x2 = gcd(bp, aq)\n        p, q = (ap // x1 * (bp // x2), aq // x2 * (bq // x1))\n    elif isinstance(other, integer_types):\n        x = gcd(other, self.q)\n        p = self.p * (other // x)\n        q = self.q // x\n    else:\n        return NotImplemented\n    return self.__class__(p, q, _gcd=False)",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.__sub__": "def __sub__(self, other):\n    from sympy.polys.domains.groundtypes import python_gcd as gcd\n    if isinstance(other, PythonRational):\n        ap, aq, bp, bq = (self.p, self.q, other.p, other.q)\n        g = gcd(aq, bq)\n        if g == 1:\n            p = ap * bq - aq * bp\n            q = bq * aq\n        else:\n            q1, q2 = (aq // g, bq // g)\n            p, q = (ap * q2 - bp * q1, q1 * q2)\n            g2 = gcd(p, g)\n            p, q = (p // g2, q * (g // g2))\n    elif isinstance(other, integer_types):\n        p = self.p - self.q * other\n        q = self.q\n    else:\n        return NotImplemented\n    return self.__class__(p, q, _gcd=False)",
    ".sympy.polys.rings.py@@PolyElement.__eq__": "def __eq__(p1, p2):\n    if not p2:\n        return not p1\n    elif isinstance(p2, PolyElement) and p2.ring == p1.ring:\n        return dict.__eq__(p1, p2)\n    elif len(p1) > 1:\n        return False\n    else:\n        return p1.get(p1.ring.zero_monom) == p2",
    ".sympy.polys.rings.py@@PolyElement.LM": "def LM(self):\n    expv = self.leading_expv()\n    if expv is None:\n        return self.ring.zero_monom\n    else:\n        return expv",
    ".sympy.polys.orderings.py@@LexOrder.__call__": "def __call__(self, monomial):\n    return monomial",
    ".sympy.polys.groebnertools.py@@update": "def update(G, B, ih):\n    h = f[ih]\n    mh = h.LM\n    C = G.copy()\n    D = set()\n    while C:\n        ig = C.pop()\n        g = f[ig]\n        mg = g.LM\n        LCMhg = monomial_lcm(mh, mg)\n\n        def lcm_divides(ip):\n            m = monomial_lcm(mh, f[ip].LM)\n            return monomial_div(LCMhg, m)\n        if monomial_mul(mh, mg) == LCMhg or (not any((lcm_divides(ipx) for ipx in C)) and (not any((lcm_divides(pr[1]) for pr in D)))):\n            D.add((ih, ig))\n    E = set()\n    while D:\n        ih, ig = D.pop()\n        mg = f[ig].LM\n        LCMhg = monomial_lcm(mh, mg)\n        if not monomial_mul(mh, mg) == LCMhg:\n            E.add((ih, ig))\n    B_new = set()\n    while B:\n        ig1, ig2 = B.pop()\n        mg1 = f[ig1].LM\n        mg2 = f[ig2].LM\n        LCM12 = monomial_lcm(mg1, mg2)\n        if not monomial_div(LCM12, mh) or monomial_lcm(mg1, mh) == LCM12 or monomial_lcm(mg2, mh) == LCM12:\n            B_new.add((ig1, ig2))\n    B_new |= E\n    G_new = set()\n    while G:\n        ig = G.pop()\n        mg = f[ig].LM\n        if not monomial_div(mg, mh):\n            G_new.add(ig)\n    G_new.add(ih)\n    return (G_new, B_new)",
    ".sympy.polys.groebnertools.py@@select": "def select(P):\n    pr = min(P, key=lambda pair: order(monomial_lcm(f[pair[0]].LM, f[pair[1]].LM)))\n    return pr",
    ".sympy.polys.groebnertools.py@@spoly": "def spoly(p1, p2, ring):\n    LM1 = p1.LM\n    LM2 = p2.LM\n    LCM12 = ring.monomial_lcm(LM1, LM2)\n    m1 = ring.monomial_div(LCM12, LM1)\n    m2 = ring.monomial_div(LCM12, LM2)\n    s1 = p1.mul_monom(m1)\n    s2 = p2.mul_monom(m2)\n    s = s1 - s2\n    return s",
    ".sympy.polys.rings.py@@PolyElement.mul_monom": "def mul_monom(f, monom):\n    monomial_mul = f.ring.monomial_mul\n    terms = [(monomial_mul(f_monom, monom), f_coeff) for f_monom, f_coeff in f.items()]\n    return f.new(terms)",
    ".sympy.polys.rings.py@@PolyElement.__sub__": "def __sub__(p1, p2):\n    if not p2:\n        return p1.copy()\n    ring = p1.ring\n    if isinstance(p2, ring.dtype):\n        p = p1.copy()\n        get = p.get\n        zero = ring.domain.zero\n        for k, v in p2.items():\n            v = get(k, zero) - v\n            if v:\n                p[k] = v\n            else:\n                del p[k]\n        return p\n    elif isinstance(p2, PolyElement):\n        if isinstance(ring.domain, PolynomialRing) and ring.domain.ring == p2.ring:\n            pass\n        elif isinstance(p2.ring.domain, PolynomialRing) and p2.ring.domain.ring == ring:\n            return p2.__rsub__(p1)\n        else:\n            return NotImplemented\n    try:\n        p2 = ring.domain_new(p2)\n    except CoercionFailed:\n        return NotImplemented\n    else:\n        p = p1.copy()\n        zm = ring.zero_monom\n        if zm not in p1.keys():\n            p[zm] = -p2\n        elif p2 == p[zm]:\n            del p[zm]\n        else:\n            p[zm] -= p2\n        return p",
    ".sympy.polys.groebnertools.py@@normal": "def normal(g, J):\n    h = g.rem([f[j] for j in J])\n    if not h:\n        return None\n    else:\n        h = h.monic()\n        if not h in I:\n            I[h] = len(f)\n            f.append(h)\n        return (h.LM, I[h])",
    ".sympy.polys.rings.py@@PolyElement.clear_denoms": "def clear_denoms(self):\n    domain = self.ring.domain\n    if not domain.is_Field or not domain.has_assoc_Ring:\n        return (domain.one, self)\n    ground_ring = domain.get_ring()\n    common = ground_ring.one\n    lcm = ground_ring.lcm\n    denom = domain.denom\n    for coeff in self.values():\n        common = lcm(common, denom(coeff))\n    poly = self.new([(k, v * common) for k, v in self.items()])\n    return (common, poly)",
    ".sympy.polys.domains.pythonrationalfield.py@@PythonRationalField.get_ring": "def get_ring(self):\n    from sympy.polys.domains import PythonIntegerRing\n    return PythonIntegerRing()",
    ".sympy.polys.domains.pythonrationalfield.py@@PythonRationalField.denom": "def denom(self, a):\n    return a.denominator",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.denom": "def denom(self):\n    return self.q",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.lcm": "def lcm(self, a, b):\n    return python_lcm(a, b)",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.parent": "def parent(self):\n    from sympy.polys.domains import PythonRationalField\n    return PythonRationalField()",
    ".sympy.polys.domains.pythonrationalfield.py@@PythonRationalField.__init__": "def __init__(self):\n    pass",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.from_QQ_python": "def from_QQ_python(K1, a, K0):\n    if a.denominator == 1:\n        return a.numerator",
    ".sympy.polys.domains.pythonrational.py@@PythonRational.numer": "def numer(self):\n    return self.p",
    ".sympy.polys.polytools.py@@GroebnerBasis._new": "def _new(cls, basis, options):\n    obj = Basic.__new__(cls)\n    obj._basis = tuple(basis)\n    obj._options = options\n    return obj",
    ".sympy.polys.polytools.py@@GroebnerBasis.__len__": "def __len__(self):\n    return len(self._basis)",
    ".sympy.polys.polytools.py@@GroebnerBasis.__iter__": "def __iter__(self):\n    if self._options.polys:\n        return iter(self.polys)\n    else:\n        return iter(self.exprs)",
    ".sympy.polys.polytools.py@@GroebnerBasis.polys": "def polys(self):\n    return list(self._basis)",
    ".sympy.polys.polytools.py@@Poly.gcd": "def gcd(f, g):\n    _, per, F, G = f._unify(g)\n    if hasattr(f.rep, 'gcd'):\n        result = F.gcd(G)\n    else:\n        raise OperationNotSupported(f, 'gcd')\n    return per(result)",
    ".sympy.polys.polyclasses.py@@DMP.gcd": "def gcd(f, g):\n    lev, dom, per, F, G = f.unify(g)\n    return per(dmp_gcd(F, G, lev, dom))",
    ".sympy.polys.polyclasses.py@@DMP.unify": "def unify(f, g):\n    if not isinstance(g, DMP) or f.lev != g.lev:\n        raise UnificationFailed(\"can't unify %s with %s\" % (f, g))\n    if f.dom == g.dom and f.ring == g.ring:\n        return (f.lev, f.dom, f.per, f.rep, g.rep)\n    else:\n        lev, dom = (f.lev, f.dom.unify(g.dom))\n        ring = f.ring\n        if g.ring is not None:\n            if ring is not None:\n                ring = ring.unify(g.ring)\n            else:\n                ring = g.ring\n        F = dmp_convert(f.rep, lev, f.dom, dom)\n        G = dmp_convert(g.rep, lev, g.dom, dom)\n\n        def per(rep, dom=dom, lev=lev, kill=False):\n            if kill:\n                if not lev:\n                    return rep\n                else:\n                    lev -= 1\n            return DMP(rep, dom, lev, ring)\n        return (lev, dom, per, F, G)",
    ".sympy.polys.euclidtools.py@@dmp_gcd": "def dmp_gcd(f, g, u, K):\n    return dmp_inner_gcd(f, g, u, K)[0]",
    ".sympy.polys.euclidtools.py@@dmp_inner_gcd": "def dmp_inner_gcd(f, g, u, K):\n    if not u:\n        return dup_inner_gcd(f, g, K)\n    J, (f, g) = dmp_multi_deflate((f, g), u, K)\n    h, cff, cfg = _dmp_inner_gcd(f, g, u, K)\n    return (dmp_inflate(h, J, u, K), dmp_inflate(cff, J, u, K), dmp_inflate(cfg, J, u, K))",
    ".sympy.polys.densebasic.py@@dmp_multi_deflate": "def dmp_multi_deflate(polys, u, K):\n    if not u:\n        M, H = dup_multi_deflate(polys, K)\n        return ((M,), H)\n    F, B = ([], [0] * (u + 1))\n    for p in polys:\n        f = dmp_to_dict(p, u)\n        if not dmp_zero_p(p, u):\n            for M in f.keys():\n                for i, m in enumerate(M):\n                    B[i] = igcd(B[i], m)\n        F.append(f)\n    for i, b in enumerate(B):\n        if not b:\n            B[i] = 1\n    B = tuple(B)\n    if all((b == 1 for b in B)):\n        return (B, polys)\n    H = []\n    for f in F:\n        h = {}\n        for A, coeff in f.items():\n            N = [a // b for a, b in zip(A, B)]\n            h[tuple(N)] = coeff\n        H.append(dmp_from_dict(h, u, K))\n    return (B, tuple(H))",
    ".sympy.polys.euclidtools.py@@_dmp_inner_gcd": "def _dmp_inner_gcd(f, g, u, K):\n    if not K.is_Exact:\n        try:\n            exact = K.get_exact()\n        except DomainError:\n            return (dmp_one(u, K), f, g)\n        f = dmp_convert(f, u, K, exact)\n        g = dmp_convert(g, u, K, exact)\n        h, cff, cfg = _dmp_inner_gcd(f, g, u, exact)\n        h = dmp_convert(h, u, exact, K)\n        cff = dmp_convert(cff, u, exact, K)\n        cfg = dmp_convert(cfg, u, exact, K)\n        return (h, cff, cfg)\n    elif K.is_Field:\n        if K.is_QQ and query('USE_HEU_GCD'):\n            try:\n                return dmp_qq_heu_gcd(f, g, u, K)\n            except HeuristicGCDFailed:\n                pass\n        return dmp_ff_prs_gcd(f, g, u, K)\n    else:\n        if K.is_ZZ and query('USE_HEU_GCD'):\n            try:\n                return dmp_zz_heu_gcd(f, g, u, K)\n            except HeuristicGCDFailed:\n                pass\n        return dmp_rr_prs_gcd(f, g, u, K)",
    ".sympy.polys.euclidtools.py@@dmp_zz_heu_gcd": "def dmp_zz_heu_gcd(f, g, u, K):\n    if not u:\n        return dup_zz_heu_gcd(f, g, K)\n    result = _dmp_rr_trivial_gcd(f, g, u, K)\n    if result is not None:\n        return result\n    gcd, f, g = dmp_ground_extract(f, g, u, K)\n    f_norm = dmp_max_norm(f, u, K)\n    g_norm = dmp_max_norm(g, u, K)\n    B = K(2 * min(f_norm, g_norm) + 29)\n    x = max(min(B, 99 * K.sqrt(B)), 2 * min(f_norm // abs(dmp_ground_LC(f, u, K)), g_norm // abs(dmp_ground_LC(g, u, K))) + 2)\n    for i in range(0, HEU_GCD_MAX):\n        ff = dmp_eval(f, x, u, K)\n        gg = dmp_eval(g, x, u, K)\n        v = u - 1\n        if not (dmp_zero_p(ff, v) or dmp_zero_p(gg, v)):\n            h, cff, cfg = dmp_zz_heu_gcd(ff, gg, v, K)\n            h = _dmp_zz_gcd_interpolate(h, x, v, K)\n            h = dmp_ground_primitive(h, u, K)[1]\n            cff_, r = dmp_div(f, h, u, K)\n            if dmp_zero_p(r, u):\n                cfg_, r = dmp_div(g, h, u, K)\n                if dmp_zero_p(r, u):\n                    h = dmp_mul_ground(h, gcd, u, K)\n                    return (h, cff_, cfg_)\n            cff = _dmp_zz_gcd_interpolate(cff, x, v, K)\n            h, r = dmp_div(f, cff, u, K)\n            if dmp_zero_p(r, u):\n                cfg_, r = dmp_div(g, h, u, K)\n                if dmp_zero_p(r, u):\n                    h = dmp_mul_ground(h, gcd, u, K)\n                    return (h, cff, cfg_)\n            cfg = _dmp_zz_gcd_interpolate(cfg, x, v, K)\n            h, r = dmp_div(g, cfg, u, K)\n            if dmp_zero_p(r, u):\n                cff_, r = dmp_div(f, h, u, K)\n                if dmp_zero_p(r, u):\n                    h = dmp_mul_ground(h, gcd, u, K)\n                    return (h, cff_, cfg)\n        x = 73794 * x * K.sqrt(K.sqrt(x)) // 27011\n    raise HeuristicGCDFailed('no luck')",
    ".sympy.polys.euclidtools.py@@_dmp_rr_trivial_gcd": "def _dmp_rr_trivial_gcd(f, g, u, K):\n    zero_f = dmp_zero_p(f, u)\n    zero_g = dmp_zero_p(g, u)\n    if_contain_one = dmp_one_p(f, u, K) or dmp_one_p(g, u, K)\n    if zero_f and zero_g:\n        return tuple(dmp_zeros(3, u, K))\n    elif zero_f:\n        if K.is_nonnegative(dmp_ground_LC(g, u, K)):\n            return (g, dmp_zero(u), dmp_one(u, K))\n        else:\n            return (dmp_neg(g, u, K), dmp_zero(u), dmp_ground(-K.one, u))\n    elif zero_g:\n        if K.is_nonnegative(dmp_ground_LC(f, u, K)):\n            return (f, dmp_one(u, K), dmp_zero(u))\n        else:\n            return (dmp_neg(f, u, K), dmp_ground(-K.one, u), dmp_zero(u))\n    elif if_contain_one:\n        return (dmp_one(u, K), f, g)\n    elif query('USE_SIMPLIFY_GCD'):\n        return _dmp_simplify_gcd(f, g, u, K)\n    else:\n        return None",
    ".sympy.polys.densebasic.py@@dmp_one_p": "def dmp_one_p(f, u, K):\n    return dmp_ground_p(f, K.one, u)",
    ".sympy.polys.densebasic.py@@dmp_ground_p": "def dmp_ground_p(f, c, u):\n    if c is not None and (not c):\n        return dmp_zero_p(f, u)\n    while u:\n        if len(f) != 1:\n            return False\n        f = f[0]\n        u -= 1\n    if c is None:\n        return len(f) <= 1\n    else:\n        return f == [c]",
    ".sympy.polys.euclidtools.py@@_dmp_simplify_gcd": "def _dmp_simplify_gcd(f, g, u, K):\n    df = dmp_degree(f, u)\n    dg = dmp_degree(g, u)\n    if df > 0 and dg > 0:\n        return None\n    if not (df or dg):\n        F = dmp_LC(f, K)\n        G = dmp_LC(g, K)\n    elif not df:\n        F = dmp_LC(f, K)\n        G = dmp_content(g, u, K)\n    else:\n        F = dmp_content(f, u, K)\n        G = dmp_LC(g, K)\n    v = u - 1\n    h = dmp_gcd(F, G, v, K)\n    cff = [dmp_quo(cf, h, v, K) for cf in f]\n    cfg = [dmp_quo(cg, h, v, K) for cg in g]\n    return ([h], cff, cfg)",
    ".sympy.polys.euclidtools.py@@dmp_content": "def dmp_content(f, u, K):\n    cont, v = (dmp_LC(f, K), u - 1)\n    if dmp_zero_p(f, u):\n        return cont\n    for c in f[1:]:\n        cont = dmp_gcd(cont, c, v, K)\n        if dmp_one_p(cont, v, K):\n            break\n    if K.is_negative(dmp_ground_LC(cont, v, K)):\n        return dmp_neg(cont, v, K)\n    else:\n        return cont",
    ".sympy.polys.densebasic.py@@poly_LC": "def poly_LC(f, K):\n    if not f:\n        return K.zero\n    else:\n        return f[0]",
    ".sympy.polys.euclidtools.py@@dup_inner_gcd": "def dup_inner_gcd(f, g, K):\n    if not K.is_Exact:\n        try:\n            exact = K.get_exact()\n        except DomainError:\n            return ([K.one], f, g)\n        f = dup_convert(f, K, exact)\n        g = dup_convert(g, K, exact)\n        h, cff, cfg = dup_inner_gcd(f, g, exact)\n        h = dup_convert(h, exact, K)\n        cff = dup_convert(cff, exact, K)\n        cfg = dup_convert(cfg, exact, K)\n        return (h, cff, cfg)\n    elif K.is_Field:\n        if K.is_QQ and query('USE_HEU_GCD'):\n            try:\n                return dup_qq_heu_gcd(f, g, K)\n            except HeuristicGCDFailed:\n                pass\n        return dup_ff_prs_gcd(f, g, K)\n    else:\n        if K.is_ZZ and query('USE_HEU_GCD'):\n            try:\n                return dup_zz_heu_gcd(f, g, K)\n            except HeuristicGCDFailed:\n                pass\n        return dup_rr_prs_gcd(f, g, K)",
    ".sympy.polys.euclidtools.py@@dup_zz_heu_gcd": "def dup_zz_heu_gcd(f, g, K):\n    result = _dup_rr_trivial_gcd(f, g, K)\n    if result is not None:\n        return result\n    df = dup_degree(f)\n    dg = dup_degree(g)\n    gcd, f, g = dup_extract(f, g, K)\n    if df == 0 or dg == 0:\n        return ([gcd], f, g)\n    f_norm = dup_max_norm(f, K)\n    g_norm = dup_max_norm(g, K)\n    B = K(2 * min(f_norm, g_norm) + 29)\n    x = max(min(B, 99 * K.sqrt(B)), 2 * min(f_norm // abs(dup_LC(f, K)), g_norm // abs(dup_LC(g, K))) + 2)\n    for i in range(0, HEU_GCD_MAX):\n        ff = dup_eval(f, x, K)\n        gg = dup_eval(g, x, K)\n        if ff and gg:\n            h = K.gcd(ff, gg)\n            cff = ff // h\n            cfg = gg // h\n            h = _dup_zz_gcd_interpolate(h, x, K)\n            h = dup_primitive(h, K)[1]\n            cff_, r = dup_div(f, h, K)\n            if not r:\n                cfg_, r = dup_div(g, h, K)\n                if not r:\n                    h = dup_mul_ground(h, gcd, K)\n                    return (h, cff_, cfg_)\n            cff = _dup_zz_gcd_interpolate(cff, x, K)\n            h, r = dup_div(f, cff, K)\n            if not r:\n                cfg_, r = dup_div(g, h, K)\n                if not r:\n                    h = dup_mul_ground(h, gcd, K)\n                    return (h, cff, cfg_)\n            cfg = _dup_zz_gcd_interpolate(cfg, x, K)\n            h, r = dup_div(g, cfg, K)\n            if not r:\n                cff_, r = dup_div(f, h, K)\n                if not r:\n                    h = dup_mul_ground(h, gcd, K)\n                    return (h, cff_, cfg)\n        x = 73794 * x * K.sqrt(K.sqrt(x)) // 27011\n    raise HeuristicGCDFailed('no luck')",
    ".sympy.polys.euclidtools.py@@_dup_rr_trivial_gcd": "def _dup_rr_trivial_gcd(f, g, K):\n    if not (f or g):\n        return ([], [], [])\n    elif not f:\n        if K.is_nonnegative(dup_LC(g, K)):\n            return (g, [], [K.one])\n        else:\n            return (dup_neg(g, K), [], [-K.one])\n    elif not g:\n        if K.is_nonnegative(dup_LC(f, K)):\n            return (f, [K.one], [])\n        else:\n            return (dup_neg(f, K), [-K.one], [])\n    return None",
    ".sympy.polys.densebasic.py@@dup_degree": "def dup_degree(f):\n    if not f:\n        return -oo\n    return len(f) - 1",
    ".sympy.polys.densetools.py@@dup_extract": "def dup_extract(f, g, K):\n    fc = dup_content(f, K)\n    gc = dup_content(g, K)\n    gcd = K.gcd(fc, gc)\n    if not K.is_one(gcd):\n        f = dup_quo_ground(f, gcd, K)\n        g = dup_quo_ground(g, gcd, K)\n    return (gcd, f, g)",
    ".sympy.polys.densetools.py@@dup_content": "def dup_content(f, K):\n    from sympy.polys.domains import QQ\n    if not f:\n        return K.zero\n    cont = K.zero\n    if K == QQ:\n        for c in f:\n            cont = K.gcd(cont, c)\n    else:\n        for c in f:\n            cont = K.gcd(cont, c)\n            if K.is_one(cont):\n                break\n    return cont",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.gcd": "def gcd(self, a, b):\n    return python_gcd(a, b)",
    ".sympy.polys.domains.domain.py@@Domain.is_one": "def is_one(self, a):\n    return a == self.one",
    ".sympy.polys.densebasic.py@@dmp_ground_LC": "def dmp_ground_LC(f, u, K):\n    while u:\n        f = dmp_LC(f, K)\n        u -= 1\n    return dup_LC(f, K)",
    ".sympy.polys.domains.domain.py@@Domain.is_negative": "def is_negative(self, a):\n    return a < 0",
    ".sympy.polys.densearith.py@@dmp_quo": "def dmp_quo(f, g, u, K):\n    return dmp_div(f, g, u, K)[0]",
    ".sympy.polys.densearith.py@@dmp_div": "def dmp_div(f, g, u, K):\n    if K.is_Field:\n        return dmp_ff_div(f, g, u, K)\n    else:\n        return dmp_rr_div(f, g, u, K)",
    ".sympy.polys.densearith.py@@dmp_rr_div": "def dmp_rr_div(f, g, u, K):\n    if not u:\n        return dup_rr_div(f, g, K)\n    df = dmp_degree(f, u)\n    dg = dmp_degree(g, u)\n    if dg < 0:\n        raise ZeroDivisionError('polynomial division')\n    q, r, dr = (dmp_zero(u), f, df)\n    if df < dg:\n        return (q, r)\n    lc_g, v = (dmp_LC(g, K), u - 1)\n    while True:\n        lc_r = dmp_LC(r, K)\n        c, R = dmp_rr_div(lc_r, lc_g, v, K)\n        if not dmp_zero_p(R, v):\n            break\n        j = dr - dg\n        q = dmp_add_term(q, c, j, u, K)\n        h = dmp_mul_term(g, c, j, u, K)\n        r = dmp_sub(r, h, u, K)\n        _dr, dr = (dr, dmp_degree(r, u))\n        if dr < dg:\n            break\n        elif not dr < _dr:\n            raise PolynomialDivisionFailed(f, g, K)\n    return (q, r)",
    ".sympy.polys.densearith.py@@dup_rr_div": "def dup_rr_div(f, g, K):\n    df = dup_degree(f)\n    dg = dup_degree(g)\n    q, r, dr = ([], f, df)\n    if not g:\n        raise ZeroDivisionError('polynomial division')\n    elif df < dg:\n        return (q, r)\n    lc_g = dup_LC(g, K)\n    while True:\n        lc_r = dup_LC(r, K)\n        if lc_r % lc_g:\n            break\n        c = K.exquo(lc_r, lc_g)\n        j = dr - dg\n        q = dup_add_term(q, c, j, K)\n        h = dup_mul_term(g, c, j, K)\n        r = dup_sub(r, h, K)\n        _dr, dr = (dr, dup_degree(r))\n        if dr < dg:\n            break\n        elif not dr < _dr:\n            raise PolynomialDivisionFailed(f, g, K)\n    return (q, r)",
    ".sympy.polys.domains.ring.py@@Ring.exquo": "def exquo(self, a, b):\n    if a % b:\n        raise ExactQuotientFailed(a, b, self)\n    else:\n        return a // b",
    ".sympy.polys.densearith.py@@dup_add_term": "def dup_add_term(f, c, i, K):\n    if not c:\n        return f\n    n = len(f)\n    m = n - i - 1\n    if i == n - 1:\n        return dup_strip([f[0] + c] + f[1:])\n    elif i >= n:\n        return [c] + [K.zero] * (i - n) + f\n    else:\n        return f[:m] + [f[m] + c] + f[m + 1:]",
    ".sympy.polys.densearith.py@@dup_mul_term": "def dup_mul_term(f, c, i, K):\n    if not c or not f:\n        return []\n    else:\n        return [cf * c for cf in f] + [K.zero] * i",
    ".sympy.polys.densearith.py@@dup_sub": "def dup_sub(f, g, K):\n    if not f:\n        return dup_neg(g, K)\n    if not g:\n        return f\n    df = dup_degree(f)\n    dg = dup_degree(g)\n    if df == dg:\n        return dup_strip([a - b for a, b in zip(f, g)])\n    else:\n        k = abs(df - dg)\n        if df > dg:\n            h, f = (f[:k], f[k:])\n        else:\n            h, g = (dup_neg(g[:k], K), g[k:])\n        return h + [a - b for a, b in zip(f, g)]",
    ".sympy.polys.densebasic.py@@dmp_inflate": "def dmp_inflate(f, M, u, K):\n    if not u:\n        return dup_inflate(f, M[0], K)\n    if all((m == 1 for m in M)):\n        return f\n    else:\n        return _rec_inflate(f, M, u, 0, K)",
    ".sympy.polys.densebasic.py@@_rec_inflate": "def _rec_inflate(g, M, v, i, K):\n    if not v:\n        return dup_inflate(g, M[i], K)\n    if M[i] <= 0:\n        raise IndexError('all M[i] must be positive, got %s' % M[i])\n    w, j = (v - 1, i + 1)\n    g = [_rec_inflate(c, M, w, j, K) for c in g]\n    result = [g[0]]\n    for coeff in g[1:]:\n        for _ in range(1, M[i]):\n            result.append(dmp_zero(w))\n        result.append(coeff)\n    return result",
    ".sympy.polys.densebasic.py@@dup_inflate": "def dup_inflate(f, m, K):\n    if m <= 0:\n        raise IndexError(\"'m' must be positive, got %s\" % m)\n    if m == 1 or not f:\n        return f\n    result = [f[0]]\n    for coeff in f[1:]:\n        result.extend([K.zero] * (m - 1))\n        result.append(coeff)\n    return result",
    ".sympy.polys.polyclasses.py@@DMP.per": "def per(f, rep, dom=None, kill=False, ring=None):\n    lev = f.lev\n    if kill:\n        if not lev:\n            return rep\n        else:\n            lev -= 1\n    if dom is None:\n        dom = f.dom\n    if ring is None:\n        ring = f.ring\n    return DMP(rep, dom, lev, ring)",
    ".sympy.polys.polytools.py@@Poly.is_ground": "def is_ground(f):\n    return f.rep.is_ground",
    ".sympy.polys.polyclasses.py@@DMP.is_ground": "def is_ground(f):\n    return dmp_ground_p(f.rep, None, f.lev)",
    ".sympy.polys.polyoptions.py@@BooleanOption.preprocess": "def preprocess(cls, value):\n    if value in [True, False]:\n        return bool(value)\n    else:\n        raise OptionError(\"'%s' must have a boolean value assigned, got %s\" % (cls.option, value))",
    ".sympy.polys.polytools.py@@Poly.as_expr": "def as_expr(f, *gens):\n    if not gens:\n        gens = f.gens\n    elif len(gens) == 1 and isinstance(gens[0], dict):\n        mapping = gens[0]\n        gens = list(f.gens)\n        for gen, value in mapping.items():\n            try:\n                index = gens.index(gen)\n            except ValueError:\n                raise GeneratorsError(\"%s doesn't have %s as generator\" % (f, gen))\n            else:\n                gens[index] = value\n    return basic_from_dict(f.rep.to_sympy_dict(), *gens)",
    ".sympy.polys.polyclasses.py@@DMP.to_sympy_dict": "def to_sympy_dict(f, zero=False):\n    rep = dmp_to_dict(f.rep, f.lev, f.dom, zero=zero)\n    for k, v in rep.items():\n        rep[k] = f.dom.to_sympy(v)\n    return rep",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.to_sympy": "def to_sympy(self, a):\n    return SymPyInteger(a)",
    ".sympy.polys.polyroots.py@@roots": "def roots(f, *gens, **flags):\n    from sympy.polys.polytools import to_rational_coeffs\n    flags = dict(flags)\n    auto = flags.pop('auto', True)\n    cubics = flags.pop('cubics', True)\n    trig = flags.pop('trig', False)\n    quartics = flags.pop('quartics', True)\n    quintics = flags.pop('quintics', False)\n    multiple = flags.pop('multiple', False)\n    filter = flags.pop('filter', None)\n    predicate = flags.pop('predicate', None)\n    if isinstance(f, list):\n        if gens:\n            raise ValueError('redundant generators given')\n        x = Dummy('x')\n        poly, i = ({}, len(f) - 1)\n        for coeff in f:\n            poly[i], i = (sympify(coeff), i - 1)\n        f = Poly(poly, x, field=True)\n    else:\n        try:\n            f = Poly(f, *gens, **flags)\n            if f.length == 2 and f.degree() != 1:\n                n = f.degree()\n                npow_bases = []\n                expr = f.as_expr()\n                con = expr.as_independent(*gens)[0]\n                for p in Mul.make_args(con):\n                    if p.is_Pow and (not p.exp % n):\n                        npow_bases.append(p.base ** (p.exp / n))\n                    else:\n                        other.append(p)\n                    if npow_bases:\n                        b = Mul(*npow_bases)\n                        B = Dummy()\n                        d = roots(Poly(expr - con + B ** n * Mul(*others), *gens, **flags), *gens, **flags)\n                        rv = {}\n                        for k, v in d.items():\n                            rv[k.subs(B, b)] = v\n                        return rv\n        except GeneratorsNeeded:\n            if multiple:\n                return []\n            else:\n                return {}\n        if f.is_multivariate:\n            raise PolynomialError('multivariate polynomials are not supported')\n\n    def _update_dict(result, root, k):\n        if root in result:\n            result[root] += k\n        else:\n            result[root] = k\n\n    def _try_decompose(f):\n        factors, roots = (f.decompose(), [])\n        for root in _try_heuristics(factors[0]):\n            roots.append(root)\n        for factor in factors[1:]:\n            previous, roots = (list(roots), [])\n            for root in previous:\n                g = factor - Poly(root, f.gen)\n                for root in _try_heuristics(g):\n                    roots.append(root)\n        return roots\n\n    def _try_heuristics(f):\n        if f.is_ground:\n            return []\n        if f.is_monomial:\n            return [S(0)] * f.degree()\n        if f.length() == 2:\n            if f.degree() == 1:\n                return list(map(cancel, roots_linear(f)))\n            else:\n                return roots_binomial(f)\n        result = []\n        for i in [-1, 1]:\n            if not f.eval(i):\n                f = f.quo(Poly(f.gen - i, f.gen))\n                result.append(i)\n                break\n        n = f.degree()\n        if n == 1:\n            result += list(map(cancel, roots_linear(f)))\n        elif n == 2:\n            result += list(map(cancel, roots_quadratic(f)))\n        elif f.is_cyclotomic:\n            result += roots_cyclotomic(f)\n        elif n == 3 and cubics:\n            result += roots_cubic(f, trig=trig)\n        elif n == 4 and quartics:\n            result += roots_quartic(f)\n        elif n == 5 and quintics:\n            result += roots_quintic(f)\n        return result\n    (k,), f = f.terms_gcd()\n    if not k:\n        zeros = {}\n    else:\n        zeros = {S(0): k}\n    coeff, f = preprocess_roots(f)\n    if auto and f.get_domain().is_Ring:\n        f = f.to_field()\n    rescale_x = None\n    translate_x = None\n    result = {}\n    if not f.is_ground:\n        if not f.get_domain().is_Exact:\n            for r in f.nroots():\n                _update_dict(result, r, 1)\n        elif f.degree() == 1:\n            result[roots_linear(f)[0]] = 1\n        elif f.length() == 2:\n            roots_fun = roots_quadratic if f.degree() == 2 else roots_binomial\n            for r in roots_fun(f):\n                _update_dict(result, r, 1)\n        else:\n            _, factors = Poly(f.as_expr()).factor_list()\n            if len(factors) == 1 and f.degree() == 2:\n                for r in roots_quadratic(f):\n                    _update_dict(result, r, 1)\n            elif len(factors) == 1 and factors[0][1] == 1:\n                if f.get_domain().is_EX:\n                    res = to_rational_coeffs(f)\n                    if res:\n                        if res[0] is None:\n                            translate_x, f = res[2:]\n                        else:\n                            rescale_x, f = (res[1], res[-1])\n                        result = roots(f)\n                        if not result:\n                            for root in _try_decompose(f):\n                                _update_dict(result, root, 1)\n                    else:\n                        for r in _try_heuristics(f):\n                            _update_dict(result, r, 1)\n                else:\n                    for root in _try_decompose(f):\n                        _update_dict(result, root, 1)\n            else:\n                for factor, k in factors:\n                    for r in _try_heuristics(Poly(factor, f.gen, field=True)):\n                        _update_dict(result, r, k)\n    if coeff is not S.One:\n        _result, result = (result, {})\n        for root, k in _result.items():\n            result[coeff * root] = k\n    result.update(zeros)\n    if filter not in [None, 'C']:\n        handlers = {'Z': lambda r: r.is_Integer, 'Q': lambda r: r.is_Rational, 'R': lambda r: r.is_real, 'I': lambda r: r.is_imaginary}\n        try:\n            query = handlers[filter]\n        except KeyError:\n            raise ValueError('Invalid filter: %s' % filter)\n        for zero in dict(result).keys():\n            if not query(zero):\n                del result[zero]\n    if predicate is not None:\n        for zero in dict(result).keys():\n            if not predicate(zero):\n                del result[zero]\n    if rescale_x:\n        result1 = {}\n        for k, v in result.items():\n            result1[k * rescale_x] = v\n        result = result1\n    if translate_x:\n        result1 = {}\n        for k, v in result.items():\n            result1[k + translate_x] = v\n        result = result1\n    if not multiple:\n        return result\n    else:\n        zeros = []\n        for zero in ordered(result):\n            zeros.extend([zero] * result[zero])\n        return zeros",
    ".sympy.polys.polytools.py@@Poly.is_multivariate": "def is_multivariate(f):\n    return len(f.gens) != 1",
    ".sympy.polys.polytools.py@@Poly.terms_gcd": "def terms_gcd(f):\n    if hasattr(f.rep, 'terms_gcd'):\n        J, result = f.rep.terms_gcd()\n    else:\n        raise OperationNotSupported(f, 'terms_gcd')\n    return (J, f.per(result))",
    ".sympy.polys.polyclasses.py@@DMP.terms_gcd": "def terms_gcd(f):\n    J, F = dmp_terms_gcd(f.rep, f.lev, f.dom)\n    return (J, f.per(F))",
    ".sympy.polys.densebasic.py@@dmp_terms_gcd": "def dmp_terms_gcd(f, u, K):\n    if dmp_ground_TC(f, u, K) or dmp_zero_p(f, u):\n        return ((0,) * (u + 1), f)\n    F = dmp_to_dict(f, u)\n    G = monomial_min(*list(F.keys()))\n    if all((g == 0 for g in G)):\n        return (G, f)\n    f = {}\n    for monom, coeff in F.items():\n        f[monomial_div(monom, G)] = coeff\n    return (G, dmp_from_dict(f, u, K))",
    ".sympy.polys.densebasic.py@@dmp_ground_TC": "def dmp_ground_TC(f, u, K):\n    while u:\n        f = dmp_TC(f, K)\n        u -= 1\n    return dup_TC(f, K)",
    ".sympy.polys.densebasic.py@@poly_TC": "def poly_TC(f, K):\n    if not f:\n        return K.zero\n    else:\n        return f[-1]",
    ".sympy.polys.polyroots.py@@preprocess_roots": "def preprocess_roots(poly):\n    coeff = S.One\n    poly_func = poly.func\n    try:\n        _, poly = poly.clear_denoms(convert=True)\n    except DomainError:\n        return (coeff, poly)\n    poly = poly.primitive()[1]\n    poly = poly.retract()\n    if poly.get_domain().is_Poly and all((c.is_term for c in poly.rep.coeffs())):\n        poly = poly.inject()\n        strips = list(zip(*poly.monoms()))\n        gens = list(poly.gens[1:])\n        base, strips = (strips[0], strips[1:])\n        for gen, strip in zip(list(gens), strips):\n            reverse = False\n            if strip[0] < strip[-1]:\n                strip = reversed(strip)\n                reverse = True\n            ratio = None\n            for a, b in zip(base, strip):\n                if not a and (not b):\n                    continue\n                elif not a or not b:\n                    break\n                elif b % a != 0:\n                    break\n                else:\n                    _ratio = b // a\n                    if ratio is None:\n                        ratio = _ratio\n                    elif ratio != _ratio:\n                        break\n            else:\n                if reverse:\n                    ratio = -ratio\n                poly = poly.eval(gen, 1)\n                coeff *= gen ** (-ratio)\n                gens.remove(gen)\n        if gens:\n            poly = poly.eject(*gens)\n    if poly.is_univariate and poly.get_domain().is_ZZ:\n        basis = _integer_basis(poly)\n        if basis is not None:\n            n = poly.degree()\n\n            def func(k, coeff):\n                return coeff // basis ** (n - k[0])\n            poly = poly.termwise(func)\n            coeff *= basis\n    if not isinstance(poly, poly_func):\n        poly = poly_func(poly)\n    return (coeff, poly)",
    ".sympy.polys.polytools.py@@Poly.clear_denoms": "def clear_denoms(self, convert=False):\n    f = self\n    if not f.rep.dom.is_Field:\n        return (S.One, f)\n    dom = f.get_domain()\n    if dom.has_assoc_Ring:\n        dom = f.rep.dom.get_ring()\n    if hasattr(f.rep, 'clear_denoms'):\n        coeff, result = f.rep.clear_denoms()\n    else:\n        raise OperationNotSupported(f, 'clear_denoms')\n    coeff, f = (dom.to_sympy(coeff), f.per(result))\n    if not convert or not dom.has_assoc_Ring:\n        return (coeff, f)\n    else:\n        return (coeff, f.to_ring())",
    ".sympy.polys.polytools.py@@Poly.primitive": "def primitive(f):\n    if hasattr(f.rep, 'primitive'):\n        cont, result = f.rep.primitive()\n    else:\n        raise OperationNotSupported(f, 'primitive')\n    return (f.rep.dom.to_sympy(cont), f.per(result))",
    ".sympy.polys.polyclasses.py@@DMP.primitive": "def primitive(f):\n    cont, F = dmp_ground_primitive(f.rep, f.lev, f.dom)\n    return (cont, f.per(F))",
    ".sympy.polys.densetools.py@@dmp_ground_primitive": "def dmp_ground_primitive(f, u, K):\n    if not u:\n        return dup_primitive(f, K)\n    if dmp_zero_p(f, u):\n        return (K.zero, f)\n    cont = dmp_ground_content(f, u, K)\n    if K.is_one(cont):\n        return (cont, f)\n    else:\n        return (cont, dmp_quo_ground(f, cont, u, K))",
    ".sympy.polys.densetools.py@@dup_primitive": "def dup_primitive(f, K):\n    if not f:\n        return (K.zero, f)\n    cont = dup_content(f, K)\n    if K.is_one(cont):\n        return (cont, f)\n    else:\n        return (cont, dup_quo_ground(f, cont, K))",
    ".sympy.polys.polytools.py@@Poly.retract": "def retract(f, field=None):\n    dom, rep = construct_domain(f.as_dict(zero=True), field=field, composite=f.domain.is_Composite or None)\n    return f.from_dict(rep, f.gens, domain=dom)",
    ".sympy.polys.polytools.py@@Poly.as_dict": "def as_dict(f, native=False, zero=False):\n    if native:\n        return f.rep.to_dict(zero=zero)\n    else:\n        return f.rep.to_sympy_dict(zero=zero)",
    ".sympy.polys.polytools.py@@Poly.from_dict": "def from_dict(cls, rep, *gens, **args):\n    opt = options.build_options(gens, args)\n    return cls._from_dict(rep, opt)",
    ".sympy.polys.polytools.py@@Poly.is_univariate": "def is_univariate(f):\n    return len(f.gens) == 1",
    ".sympy.polys.polyroots.py@@_integer_basis": "def _integer_basis(poly):\n    monoms, coeffs = list(zip(*poly.terms()))\n    monoms, = list(zip(*monoms))\n    coeffs = list(map(abs, coeffs))\n    if coeffs[0] < coeffs[-1]:\n        coeffs = list(reversed(coeffs))\n        n = monoms[0]\n        monoms = [n - i for i in reversed(monoms)]\n    else:\n        return None\n    monoms = monoms[:-1]\n    coeffs = coeffs[:-1]\n    divs = reversed(divisors(gcd_list(coeffs))[1:])\n    try:\n        div = next(divs)\n    except StopIteration:\n        return None\n    while True:\n        for monom, coeff in zip(monoms, coeffs):\n            if coeff % div ** monom != 0:\n                try:\n                    div = next(divs)\n                except StopIteration:\n                    return None\n                else:\n                    break\n        else:\n            return div",
    ".sympy.polys.polytools.py@@Poly.terms": "def terms(f, order=None):\n    return [(m, f.rep.dom.to_sympy(c)) for m, c in f.rep.terms(order=order)]",
    ".sympy.polys.polyclasses.py@@DMP.terms": "def terms(f, order=None):\n    return dmp_list_terms(f.rep, f.lev, f.dom, order=order)",
    ".sympy.polys.densebasic.py@@dmp_list_terms": "def dmp_list_terms(f, u, K, order=None):\n\n    def sort(terms, O):\n        return sorted(terms, key=lambda term: O(term[0]), reverse=True)\n    terms = _rec_list_terms(f, u, ())\n    if not terms:\n        return [((0,) * (u + 1), K.zero)]\n    if order is None:\n        return terms\n    else:\n        return sort(terms, monomial_key(order))",
    ".sympy.polys.densebasic.py@@_rec_list_terms": "def _rec_list_terms(g, v, monom):\n    d, terms = (dmp_degree(g, v), [])\n    if not v:\n        for i, c in enumerate(g):\n            if not c:\n                continue\n            terms.append((monom + (d - i,), c))\n    else:\n        w = v - 1\n        for i, c in enumerate(g):\n            terms.extend(_rec_list_terms(c, w, monom + (d - i,)))\n    return terms",
    ".sympy.core.numbers.py@@NegativeOne.__abs__": "def __abs__():\n    return S.One",
    ".sympy.core.numbers.py@@Integer.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    ".sympy.polys.polytools.py@@Poly.to_field": "def to_field(f):\n    if hasattr(f.rep, 'to_field'):\n        result = f.rep.to_field()\n    else:\n        raise OperationNotSupported(f, 'to_field')\n    return f.per(result)",
    ".sympy.polys.polyclasses.py@@DMP.to_field": "def to_field(f):\n    return f.convert(f.dom.get_field())",
    ".sympy.polys.densebasic.py@@dmp_convert": "def dmp_convert(f, u, K0, K1):\n    if not u:\n        return dup_convert(f, K0, K1)\n    if K0 is not None and K0 == K1:\n        return f\n    v = u - 1\n    return dmp_strip([dmp_convert(c, v, K0, K1) for c in f], u)",
    ".sympy.polys.densebasic.py@@dup_convert": "def dup_convert(f, K0, K1):\n    if K0 is not None and K0 == K1:\n        return f\n    else:\n        return dup_strip([K1.convert(c, K0) for c in f])",
    ".sympy.polys.polytools.py@@Poly.degree": "def degree(f, gen=0):\n    j = f._gen_to_level(gen)\n    if hasattr(f.rep, 'degree'):\n        return f.rep.degree(j)\n    else:\n        raise OperationNotSupported(f, 'degree')",
    ".sympy.polys.polytools.py@@Poly._gen_to_level": "def _gen_to_level(f, gen):\n    if isinstance(gen, int):\n        length = len(f.gens)\n        if -length <= gen < length:\n            if gen < 0:\n                return length + gen\n            else:\n                return gen\n        else:\n            raise PolynomialError('-%s <= gen < %s expected, got %s' % (length, length, gen))\n    else:\n        try:\n            return f.gens.index(sympify(gen))\n        except ValueError:\n            raise PolynomialError('a valid generator expected, got %s' % gen)",
    ".sympy.polys.polyclasses.py@@DMP.degree": "def degree(f, j=0):\n    if isinstance(j, int):\n        return dmp_degree_in(f.rep, j, f.lev)\n    else:\n        raise TypeError('``int`` expected, got %s' % type(j))",
    ".sympy.polys.densebasic.py@@dmp_degree_in": "def dmp_degree_in(f, j, u):\n    if not j:\n        return dmp_degree(f, u)\n    if j < 0 or j > u:\n        raise IndexError('0 <= j <= %s expected, got %s' % (u, j))\n    return _rec_degree_in(f, u, 0, j)",
    ".sympy.polys.polyroots.py@@roots_linear": "def roots_linear(f):\n    r = -f.nth(0) / f.nth(1)\n    dom = f.get_domain()\n    if not dom.is_Numerical:\n        if dom.is_Composite:\n            r = factor(r)\n        else:\n            r = simplify(r)\n    return [r]",
    ".sympy.polys.polytools.py@@Poly.nth": "def nth(f, *N):\n    if hasattr(f.rep, 'nth'):\n        if len(N) != len(f.gens):\n            raise ValueError('exponent of each generator must be specified')\n        result = f.rep.nth(*list(map(int, N)))\n    else:\n        raise OperationNotSupported(f, 'nth')\n    return f.rep.dom.to_sympy(result)",
    ".sympy.polys.polyclasses.py@@DMP.nth": "def nth(f, *N):\n    if all((isinstance(n, int) for n in N)):\n        return dmp_ground_nth(f.rep, N, f.lev, f.dom)\n    else:\n        raise TypeError('a sequence of integers expected')",
    ".sympy.polys.densebasic.py@@dmp_ground_nth": "def dmp_ground_nth(f, N, u, K):\n    v = u\n    for n in N:\n        if n < 0:\n            raise IndexError('`n` must be non-negative, got %i' % n)\n        elif n >= len(f):\n            return K.zero\n        else:\n            d = dmp_degree(f, v)\n            if d == -oo:\n                d = -1\n            f, v = (f[d - n], v - 1)\n    return f",
    ".sympy.polys.domains.pythonrationalfield.py@@PythonRationalField.to_sympy": "def to_sympy(self, a):\n    return SymPyRational(a.numerator, a.denominator)",
    ".sympy.core.numbers.py@@Rational.__new__": "def __new__(cls, p, q=None, gcd=None):\n    if q is None:\n        if isinstance(p, Rational):\n            return p\n        if isinstance(p, SYMPY_INTS):\n            pass\n        else:\n            if isinstance(p, (float, Float)):\n                return Rational(*_as_integer_ratio(p))\n            if not isinstance(p, string_types):\n                try:\n                    p = sympify(p)\n                except (SympifyError, SyntaxError):\n                    pass\n            else:\n                if p.count('/') > 1:\n                    raise TypeError('invalid input: %s' % p)\n                p = p.replace(' ', '')\n                pq = p.rsplit('/', 1)\n                if len(pq) == 2:\n                    p, q = pq\n                    fp = fractions.Fraction(p)\n                    fq = fractions.Fraction(q)\n                    p = fp / fq\n                try:\n                    p = fractions.Fraction(p)\n                except ValueError:\n                    pass\n                else:\n                    return Rational(p.numerator, p.denominator, 1)\n            if not isinstance(p, Rational):\n                raise TypeError('invalid input: %s' % p)\n        q = 1\n        gcd = 1\n    else:\n        p = Rational(p)\n        q = Rational(q)\n    if isinstance(q, Rational):\n        p *= q.q\n        q = q.p\n    if isinstance(p, Rational):\n        q *= p.q\n        p = p.p\n    if q == 0:\n        if p == 0:\n            if _errdict['divide']:\n                raise ValueError('Indeterminate 0/0')\n            else:\n                return S.NaN\n        return S.ComplexInfinity\n    if q < 0:\n        q = -q\n        p = -p\n    if not gcd:\n        gcd = igcd(abs(p), q)\n    if gcd > 1:\n        p //= gcd\n        q //= gcd\n    if q == 1:\n        return Integer(p)\n    if p == 1 and q == 2:\n        return S.Half\n    obj = Expr.__new__(cls)\n    obj.p = p\n    obj.q = q\n    return obj",
    ".sympy.core.numbers.py@@NegativeOne.__neg__": "def __neg__():\n    return S.One",
    ".sympy.core.numbers.py@@Rational.__div__": "def __div__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, Integer):\n            if self.p and other.p == S.Zero:\n                return S.ComplexInfinity\n            else:\n                return Rational(self.p, self.q * other.p, igcd(self.p, other.p))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q, self.q * other.p, igcd(self.p, other.p) * igcd(self.q, other.q))\n        elif isinstance(other, Float):\n            return self * (1 / other)\n        else:\n            return Number.__div__(self, other)\n    return Number.__div__(self, other)",
    ".sympy.simplify.radsimp.py@@rcollect": "def rcollect(expr, *vars):\n    if expr.is_Atom or not expr.has(*vars):\n        return expr\n    else:\n        expr = expr.__class__(*[rcollect(arg, *vars) for arg in expr.args])\n        if expr.is_Add:\n            return collect(expr, vars)\n        else:\n            return expr",
    ".sympy.polys.polytools.py@@Poly.ltrim": "def ltrim(f, gen):\n    rep = f.as_dict(native=True)\n    j = f._gen_to_level(gen)\n    terms = {}\n    for monom, coeff in rep.items():\n        if any((i for i in monom[:j])):\n            raise PolynomialError(\"can't left trim %s\" % f)\n        terms[monom[j:]] = coeff\n    gens = f.gens[j:]\n    return f.new(DMP.from_dict(terms, len(gens) - 1, f.rep.dom), *gens)",
    ".sympy.polys.monomials.py@@monomial_min": "def monomial_min(*monoms):\n    M = list(monoms[0])\n    for N in monoms[1:]:\n        for i, n in enumerate(N):\n            M[i] = min(M[i], n)\n    return tuple(M)",
    ".sympy.polys.monomials.py@@monomial_div": "def monomial_div(A, B):\n    C = monomial_ldiv(A, B)\n    if all((c >= 0 for c in C)):\n        return tuple(C)\n    else:\n        return None",
    ".sympy.polys.monomials.py@@monomial_ldiv": "def monomial_ldiv(A, B):\n    return tuple([a - b for a, b in zip(A, B)])",
    ".sympy.core.basic.py@@_aresame": "def _aresame(a, b):\n    from .function import AppliedUndef, UndefinedFunction as UndefFunc\n    for i, j in zip_longest(preorder_traversal(a), preorder_traversal(b)):\n        if i != j or type(i) != type(j):\n            if isinstance(i, UndefFunc) and isinstance(j, UndefFunc) or (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef)):\n                if i.class_key() != j.class_key():\n                    return False\n            else:\n                return False\n    else:\n        return True",
    ".sympy.core.basic.py@@Basic._subs": "def _subs(self, old, new, **hints):\n\n    def fallback(self, old, new):\n        hit = False\n        args = list(self.args)\n        for i, arg in enumerate(args):\n            if not hasattr(arg, '_eval_subs'):\n                continue\n            arg = arg._subs(old, new, **hints)\n            if not _aresame(arg, args[i]):\n                hit = True\n                args[i] = arg\n        if hit:\n            rv = self.func(*args)\n            hack2 = hints.get('hack2', False)\n            if hack2 and self.is_Mul and (not rv.is_Mul):\n                coeff = S.One\n                nonnumber = []\n                for i in args:\n                    if i.is_Number:\n                        coeff *= i\n                    else:\n                        nonnumber.append(i)\n                nonnumber = self.func(*nonnumber)\n                if coeff is S.One:\n                    return nonnumber\n                else:\n                    return self.func(coeff, nonnumber, evaluate=False)\n            return rv\n        return self\n    if _aresame(self, old):\n        return new\n    rv = self._eval_subs(old, new)\n    if rv is None:\n        rv = fallback(self, old, new)\n    return rv",
    ".sympy.core.numbers.py@@Integer.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.numbers.py@@Number._eval_subs": "def _eval_subs(self, old, new):\n    if old == -self:\n        return -new\n    return self",
    ".sympy.core.compatibility.py@@default_sort_key": "def default_sort_key(item, order=None):\n    from .singleton import S\n    from .basic import Basic\n    from .sympify import sympify, SympifyError\n    from .compatibility import iterable\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n    if iterable(item, exclude=string_types):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            args = list(item)\n            unordered = False\n        args = [default_sort_key(arg, order=order) for arg in args]\n        if unordered:\n            args = sorted(args)\n        cls_index, args = (10, (len(args), tuple(args)))\n    else:\n        if not isinstance(item, string_types):\n            try:\n                item = sympify(item)\n            except SympifyError:\n                pass\n            else:\n                if isinstance(item, Basic):\n                    return default_sort_key(item)\n        cls_index, args = (0, (1, (str(item),)))\n    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)",
    ".sympy.core.numbers.py@@Number.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (0, ()), (), self)",
    ".sympy.core.numbers.py@@Number.class_key": "def class_key(cls):\n    return (1, 0, 'Number')",
    ".sympy.solvers.solvers.py@@checksol": "def checksol(f, symbol, sol=None, **flags):\n    from sympy.physics.units import Unit\n    minimal = flags.get('minimal', False)\n    if sol is not None:\n        sol = {symbol: sol}\n    elif isinstance(symbol, dict):\n        sol = symbol\n    else:\n        msg = 'Expecting (sym, val) or ({sym: val}, None) but got (%s, %s)'\n        raise ValueError(msg % (symbol, sol))\n    if iterable(f):\n        if not f:\n            raise ValueError('no functions to check')\n        rv = True\n        for fi in f:\n            check = checksol(fi, sol, **flags)\n            if check:\n                continue\n            if check is False:\n                return False\n            rv = None\n        return rv\n    if isinstance(f, Poly):\n        f = f.as_expr()\n    elif isinstance(f, (Equality, Unequality)):\n        if f.rhs in (S.true, S.false):\n            f = f.reversed\n        B, E = f.args\n        if B in (S.true, S.false):\n            f = f.subs(sol)\n            if f not in (S.true, S.false):\n                return\n        else:\n            f = Add(f.lhs, -f.rhs, evaluate=False)\n    if isinstance(f, BooleanAtom):\n        return bool(f)\n    elif not f.is_Relational and (not f):\n        return True\n    if sol and (not f.free_symbols & set(sol.keys())):\n        return None\n    illegal = set([S.NaN, S.ComplexInfinity, S.Infinity, S.NegativeInfinity])\n    if any((sympify(v).atoms() & illegal for k, v in sol.items())):\n        return False\n    was = f\n    attempt = -1\n    numerical = flags.get('numerical', True)\n    while 1:\n        attempt += 1\n        if attempt == 0:\n            val = f.subs(sol)\n            if isinstance(val, Mul):\n                val = val.as_independent(Unit)[0]\n            if val.atoms() & illegal:\n                return False\n        elif attempt == 1:\n            if val.free_symbols:\n                if not val.is_constant(*list(sol.keys()), simplify=not minimal):\n                    return False\n                _, val = val.as_content_primitive()\n                val = _mexpand(val.as_numer_denom()[0], recursive=True)\n        elif attempt == 2:\n            if minimal:\n                return\n            if flags.get('simplify', True):\n                for k in sol:\n                    sol[k] = simplify(sol[k])\n            val = simplify(f.subs(sol))\n            if flags.get('force', True):\n                val, reps = posify(val)\n                exval = _mexpand(val, recursive=True)\n                if exval.is_number or not exval.free_symbols:\n                    val = exval\n        else:\n            pot = preorder_traversal(expand_mul(val))\n            seen = set()\n            saw_pow_func = False\n            for p in pot:\n                if p in seen:\n                    continue\n                seen.add(p)\n                if p.is_Pow and (not p.exp.is_Integer):\n                    saw_pow_func = True\n                elif p.is_Function:\n                    saw_pow_func = True\n                elif isinstance(p, UndefinedFunction):\n                    saw_pow_func = True\n                if saw_pow_func:\n                    break\n            if saw_pow_func is False:\n                return False\n            if flags.get('force', True):\n                val = val.subs(reps)\n            nz = fuzzy_not(val.is_zero)\n            if nz is not None:\n                if val.is_number and val.has(LambertW):\n                    return None\n                return not nz\n            break\n        if val == was:\n            continue\n        elif val.is_Rational:\n            return val == 0\n        if numerical and (not val.free_symbols):\n            if val in (S.true, S.false):\n                return bool(val)\n            return bool(abs(val.n(18).n(12, chop=True)) < 1e-09)\n        was = val\n    if flags.get('warn', False):\n        warnings.warn('\\n\\tWarning: could not verify solution %s.' % sol)",
    ".sympy.core.numbers.py@@NegativeInfinity.__hash__": "def __hash__(self):\n    return super(NegativeInfinity, self).__hash__()",
    ".sympy.core.symbol.py@@Dummy.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (2, (str(self), self.dummy_index)), S.One.sort_key(), S.One)",
    ".sympy.core.basic.py@@Atom.class_key": "def class_key(cls):\n    return (2, 0, cls.__name__)",
    ".sympy.core.basic.py@@Basic.__str__": "def __str__(self):\n    from sympy.printing import sstr\n    return sstr(self, order=None)",
    ".sympy.printing.str.py@@sstr": "def sstr(expr, **settings):\n    p = StrPrinter(settings)\n    s = p.doprint(expr)\n    return s",
    ".sympy.printing.printer.py@@Printer.__init__": "def __init__(self, settings=None):\n    self._str = str\n    self._settings = self._default_settings.copy()\n    self._context = dict()\n    for key, val in self._global_settings.items():\n        if key in self._default_settings:\n            self._settings[key] = val\n    if settings is not None:\n        self._settings.update(settings)\n        if len(self._settings) > len(self._default_settings):\n            for key in self._settings:\n                if key not in self._default_settings:\n                    raise TypeError(\"Unknown setting '%s'.\" % key)\n    self._print_level = 0",
    ".sympy.printing.printer.py@@Printer.doprint": "def doprint(self, expr):\n    return self._str(self._print(expr))",
    ".sympy.printing.printer.py@@Printer._print": "def _print(self, expr, **kwargs):\n    self._print_level += 1\n    try:\n        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):\n            return getattr(expr, self.printmethod)(self, **kwargs)\n        classes = type(expr).__mro__\n        if AppliedUndef in classes:\n            classes = classes[classes.index(AppliedUndef):]\n        if UndefinedFunction in classes:\n            classes = classes[classes.index(UndefinedFunction):]\n        if Function in classes:\n            i = classes.index(Function)\n            classes = tuple((c for c in classes[:i] if c.__name__ == classes[0].__name__ or c.__name__.endswith('Base'))) + classes[i:]\n        for cls in classes:\n            printmethod = '_print_' + cls.__name__\n            if hasattr(self, printmethod):\n                return getattr(self, printmethod)(expr, **kwargs)\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1",
    ".sympy.printing.str.py@@StrPrinter._print_Dummy": "def _print_Dummy(self, expr):\n    return '_' + expr.name",
    ".sympy.core.add.py@@Add._eval_subs": "def _eval_subs(self, old, new):\n    if not old.is_Add:\n        if old is S.Infinity and -old in self.args:\n            return self.xreplace({-old: -new})\n        return None\n    coeff_self, terms_self = self.as_coeff_Add()\n    coeff_old, terms_old = old.as_coeff_Add()\n    if coeff_self.is_Rational and coeff_old.is_Rational:\n        if terms_self == terms_old:\n            return self.func(new, coeff_self, -coeff_old)\n        if terms_self == -terms_old:\n            return self.func(-new, coeff_self, coeff_old)\n    if coeff_self.is_Rational and coeff_old.is_Rational or coeff_self == coeff_old:\n        args_old, args_self = (self.func.make_args(terms_old), self.func.make_args(terms_self))\n        if len(args_old) < len(args_self):\n            self_set = set(args_self)\n            old_set = set(args_old)\n            if old_set < self_set:\n                ret_set = self_set - old_set\n                return self.func(new, coeff_self, -coeff_old, *[s._subs(old, new) for s in ret_set])\n            args_old = self.func.make_args(-terms_old)\n            old_set = set(args_old)\n            if old_set < self_set:\n                ret_set = self_set - old_set\n                return self.func(-new, coeff_self, coeff_old, *[s._subs(old, new) for s in ret_set])",
    ".sympy.core.basic.py@@Basic.fallback": "def fallback(self, old, new):\n    hit = False\n    args = list(self.args)\n    for i, arg in enumerate(args):\n        if not hasattr(arg, '_eval_subs'):\n            continue\n        arg = arg._subs(old, new, **hints)\n        if not _aresame(arg, args[i]):\n            hit = True\n            args[i] = arg\n    if hit:\n        rv = self.func(*args)\n        hack2 = hints.get('hack2', False)\n        if hack2 and self.is_Mul and (not rv.is_Mul):\n            coeff = S.One\n            nonnumber = []\n            for i in args:\n                if i.is_Number:\n                    coeff *= i\n                else:\n                    nonnumber.append(i)\n            nonnumber = self.func(*nonnumber)\n            if coeff is S.One:\n                return nonnumber\n            else:\n                return self.func(coeff, nonnumber, evaluate=False)\n        return rv\n    return self",
    ".sympy.core.power.py@@Pow._eval_subs": "def _eval_subs(self, old, new):\n    from sympy import exp, log, Symbol\n\n    def _check(ct1, ct2, old):\n        coeff1, terms1 = ct1\n        coeff2, terms2 = ct2\n        if terms1 == terms2:\n            if old.is_commutative:\n                pow = coeff1 / coeff2\n                try:\n                    pow = as_int(pow)\n                    combines = True\n                except ValueError:\n                    combines = Pow._eval_power(Pow(*old.as_base_exp(), evaluate=False), pow) is not None\n                return (combines, pow, None)\n            else:\n                if not isinstance(terms1, tuple):\n                    terms1 = (terms1,)\n                if not all((term.is_integer for term in terms1)):\n                    return (False, None, None)\n                try:\n                    pow, remainder = divmod(as_int(coeff1), as_int(coeff2))\n                    if pow < 0 and remainder != 0:\n                        pow += 1\n                        remainder -= as_int(coeff2)\n                    if remainder == 0:\n                        remainder_pow = None\n                    else:\n                        remainder_pow = Mul(remainder, *terms1)\n                    return (True, pow, remainder_pow)\n                except ValueError:\n                    pass\n        return (False, None, None)\n    if old == self.base:\n        return new ** self.exp._subs(old, new)\n    if isinstance(old, self.func) and self.exp == old.exp:\n        l = log(self.base, old.base)\n        if l.is_Number:\n            return Pow(new, l)\n    if isinstance(old, self.func) and self.base == old.base:\n        if self.exp.is_Add is False:\n            ct1 = self.exp.as_independent(Symbol, as_Add=False)\n            ct2 = old.exp.as_independent(Symbol, as_Add=False)\n            ok, pow, remainder_pow = _check(ct1, ct2, old)\n            if ok:\n                result = self.func(new, pow)\n                if remainder_pow is not None:\n                    result = Mul(result, Pow(old.base, remainder_pow))\n                return result\n        else:\n            oarg = old.exp\n            new_l = []\n            o_al = []\n            ct2 = oarg.as_coeff_mul()\n            for a in self.exp.args:\n                newa = a._subs(old, new)\n                ct1 = newa.as_coeff_mul()\n                ok, pow, remainder_pow = _check(ct1, ct2, old)\n                if ok:\n                    new_l.append(new ** pow)\n                    if remainder_pow is not None:\n                        o_al.append(remainder_pow)\n                    continue\n                elif not old.is_commutative and (not newa.is_integer):\n                    return\n                o_al.append(newa)\n            if new_l:\n                expo = Add(*o_al)\n                new_l.append(Pow(self.base, expo, evaluate=False) if expo != 1 else self.base)\n                return Mul(*new_l)\n    if isinstance(old, exp) and self.exp.is_real and self.base.is_positive:\n        ct1 = old.args[0].as_independent(Symbol, as_Add=False)\n        ct2 = (self.exp * log(self.base)).as_independent(Symbol, as_Add=False)\n        ok, pow, remainder_pow = _check(ct1, ct2, old)\n        if ok:\n            result = self.func(new, pow)\n            if remainder_pow is not None:\n                result = Mul(result, Pow(old.base, remainder_pow))\n            return result",
    ".sympy.core.basic.py@@Basic._eval_subs": "def _eval_subs(self, old, new):\n    return None",
    ".sympy.core.numbers.py@@Zero._eval_power": "def _eval_power(self, expt):\n    if expt.is_positive:\n        return self\n    if expt.is_negative:\n        return S.ComplexInfinity\n    if expt.is_real is False:\n        return S.NaN\n    coeff, terms = expt.as_coeff_Mul()\n    if coeff.is_negative:\n        return S.ComplexInfinity ** terms\n    if coeff is not S.One:\n        return self ** terms",
    ".sympy.solvers.solvers.py@@check_assumptions": "def check_assumptions(expr, against=None, **assumptions):\n    expr = sympify(expr)\n    if against:\n        if not isinstance(against, Symbol):\n            raise TypeError('against should be of type Symbol')\n        if assumptions:\n            raise AssertionError('No assumptions should be specified')\n        assumptions = against.assumptions0\n\n    def _test(key):\n        v = getattr(expr, 'is_' + key, None)\n        if v is not None:\n            return assumptions[key] is v\n    return fuzzy_and((_test(key) for key in assumptions))",
    ".sympy.solvers.solvers.py@@_test": "def _test(key):\n    v = getattr(expr, 'is_' + key, None)\n    if v is not None:\n        return assumptions[key] is v",
    ".sympy.geometry.point.py@@Point.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_evaluate[0])\n    on_morph = kwargs.get('on_morph', 'ignore')\n    coords = args[0] if len(args) == 1 else args\n    if isinstance(coords, Point):\n        evaluate = False\n        if len(coords) == kwargs.get('dim', len(coords)):\n            return coords\n    if not is_sequence(coords):\n        raise TypeError(filldedent('\\n            Expecting sequence of coordinates, not `{}`'.format(func_name(coords))))\n    if len(coords) == 0 and kwargs.get('dim', None):\n        coords = (S.Zero,) * kwargs.get('dim')\n    coords = Tuple(*coords)\n    dim = kwargs.get('dim', len(coords))\n    if len(coords) < 2:\n        raise ValueError(filldedent('\\n            Point requires 2 or more coordinates or\\n            keyword `dim` > 1.'))\n    if len(coords) != dim:\n        message = 'Dimension of {} needs to be changedfrom {} to {}.'.format(coords, len(coords), dim)\n        if on_morph == 'ignore':\n            pass\n        elif on_morph == 'error':\n            raise ValueError(message)\n        elif on_morph == 'warn':\n            warnings.warn(message)\n        else:\n            raise ValueError(filldedent(\"\\n                    on_morph value should be 'error',\\n                    'warn' or 'ignore'.\"))\n    if any((i for i in coords[dim:])):\n        raise ValueError('Nonzero coordinates cannot be removed.')\n    if any((a.is_number and im(a) for a in coords)):\n        raise ValueError('Imaginary coordinates are not permitted.')\n    if not all((isinstance(a, Expr) for a in coords)):\n        raise TypeError('Coordinates must be valid SymPy expressions.')\n    coords = coords[:dim] + (S.Zero,) * (dim - len(coords))\n    if evaluate:\n        coords = coords.xreplace(dict([(f, simplify(nsimplify(f, rational=True))) for f in coords.atoms(Float)]))\n    if len(coords) == 2:\n        kwargs['_nocheck'] = True\n        return Point2D(*coords, **kwargs)\n    elif len(coords) == 3:\n        kwargs['_nocheck'] = True\n        return Point3D(*coords, **kwargs)\n    return GeometryEntity.__new__(cls, *coords)",
    ".sympy.core.containers.py@@Tuple.__len__": "def __len__(self):\n    return len(self.args)",
    ".sympy.core.containers.py@@Tuple.__getitem__": "def __getitem__(self, i):\n    if isinstance(i, slice):\n        indices = i.indices(len(self))\n        return Tuple(*(self.args[j] for j in range(*indices)))\n    return self.args[i]",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.containers.py@@Tuple.__add__": "def __add__(self, other):\n    if isinstance(other, Tuple):\n        return Tuple(*self.args + other.args)\n    elif isinstance(other, tuple):\n        return Tuple(*self.args + other)\n    else:\n        return NotImplemented",
    ".sympy.geometry.point.py@@Point2D.__new__": "def __new__(cls, *args, **kwargs):\n    if not kwargs.pop('_nocheck', False):\n        kwargs['dim'] = 2\n        args = Point(*args, **kwargs)\n    return GeometryEntity.__new__(cls, *args)",
    ".sympy.geometry.entity.py@@GeometryEntity.__new__": "def __new__(cls, *args, **kwargs):\n\n    def is_seq_and_not_point(a):\n        if hasattr(a, 'is_Point') and a.is_Point:\n            return False\n        return is_sequence(a)\n    args = [Tuple(*a) if is_seq_and_not_point(a) else sympify(a) for a in args]\n    return Basic.__new__(cls, *args)",
    ".sympy.geometry.entity.py@@GeometryEntity.is_seq_and_not_point": "def is_seq_and_not_point(a):\n    if hasattr(a, 'is_Point') and a.is_Point:\n        return False\n    return is_sequence(a)",
    ".sympy.geometry.polygon.py@@Polygon.sides": "def sides(self):\n    res = []\n    args = self.vertices\n    for i in range(-len(args), 0):\n        res.append(Segment(args[i], args[i + 1]))\n    return res",
    ".sympy.geometry.polygon.py@@Triangle.vertices": "def vertices(self):\n    return self.args",
    ".sympy.geometry.line.py@@Segment.__new__": "def __new__(cls, p1, p2, **kwargs):\n    p1, p2 = Point._normalize_dimension(Point(p1), Point(p2))\n    dim = len(p1)\n    if dim == 2:\n        return Segment2D(p1, p2, **kwargs)\n    elif dim == 3:\n        return Segment3D(p1, p2, **kwargs)\n    return LinearEntity.__new__(cls, p1, p2, **kwargs)",
    ".sympy.geometry.point.py@@Point.__len__": "def __len__(self):\n    return len(self.args)",
    ".sympy.geometry.point.py@@Point._normalize_dimension": "def _normalize_dimension(cls, *points, **kwargs):\n    dim = getattr(cls, '_ambient_dimension', None)\n    dim = kwargs.get('dim', dim)\n    if dim is None:\n        dim = max((i.ambient_dimension for i in points))\n    if all((i.ambient_dimension == dim for i in points)):\n        return list(points)\n    kwargs['dim'] = dim\n    kwargs['on_morph'] = kwargs.get('on_morph', 'warn')\n    return [Point(i, **kwargs) for i in points]",
    ".sympy.geometry.point.py@@Point.ambient_dimension": "def ambient_dimension(self):\n    return getattr(self, '_ambient_dimension', len(self))",
    ".sympy.geometry.line.py@@Segment2D.__new__": "def __new__(cls, p1, p2, **kwargs):\n    p1 = Point(p1, dim=2)\n    p2 = Point(p2, dim=2)\n    if p1 == p2:\n        return p1\n    return LinearEntity2D.__new__(cls, p1, p2, **kwargs)",
    ".sympy.geometry.line.py@@LinearEntity.__new__": "def __new__(cls, p1, p2=None, **kwargs):\n    p1, p2 = Point._normalize_dimension(p1, p2)\n    if p1 == p2:\n        raise ValueError('%s.__new__ requires two unique Points.' % cls.__name__)\n    if len(p1) != len(p2):\n        raise ValueError('%s.__new__ requires two Points of equal dimension.' % cls.__name__)\n    return GeometryEntity.__new__(cls, p1, p2, **kwargs)",
    ".sympy.geometry.point.py@@Point.__hash__": "def __hash__(self):\n    return hash(self.args)",
    ".sympy.geometry.line.py@@LinearEntity.points": "def points(self):\n    return (self.p1, self.p2)",
    ".sympy.geometry.line.py@@LinearEntity.p1": "def p1(self):\n    return self.args[0]",
    ".sympy.geometry.line.py@@LinearEntity.p2": "def p2(self):\n    return self.args[1]",
    ".sympy.geometry.line.py@@Line.__new__": "def __new__(cls, *args, **kwargs):\n    from sympy.geometry.util import find\n    if len(args) == 1 and isinstance(args[0], Expr):\n        x = kwargs.get('x', 'x')\n        y = kwargs.get('y', 'y')\n        equation = args[0]\n        if isinstance(equation, Eq):\n            equation = equation.lhs - equation.rhs\n        xin, yin = (x, y)\n        x = find(x, equation) or Dummy()\n        y = find(y, equation) or Dummy()\n        co = linear_coeffs(equation, x, y)\n        a, b, c = [co[i] for i in (x, y, 0)]\n        if b:\n            return Line((0, -c / b), slope=-a / b)\n        if a:\n            return Line((-c / a, 0), slope=oo)\n        raise ValueError('neither %s nor %s were found in the equation' % (xin, yin))\n    elif len(args) > 0:\n        p1 = args[0]\n        if len(args) > 1:\n            p2 = args[1]\n        else:\n            p2 = None\n        if isinstance(p1, LinearEntity):\n            if p2:\n                raise ValueError('If p1 is a LinearEntity, p2 must be None.')\n            dim = len(p1.p1)\n        else:\n            p1 = Point(p1)\n            dim = len(p1)\n            if p2 is not None or (isinstance(p2, Point) and p2.ambient_dimension != dim):\n                p2 = Point(p2)\n        if dim == 2:\n            return Line2D(p1, p2, **kwargs)\n        elif dim == 3:\n            return Line3D(p1, p2, **kwargs)\n        return LinearEntity.__new__(cls, p1, p2, **kwargs)",
    ".sympy.geometry.line.py@@Line2D.__new__": "def __new__(cls, p1, pt=None, slope=None, **kwargs):\n    if isinstance(p1, LinearEntity):\n        if pt is not None:\n            raise ValueError('When p1 is a LinearEntity, pt should be None')\n        p1, pt = Point._normalize_dimension(*p1.args, dim=2)\n    else:\n        p1 = Point(p1, dim=2)\n    if pt is not None and slope is None:\n        try:\n            p2 = Point(pt, dim=2)\n        except (NotImplementedError, TypeError, ValueError):\n            raise ValueError(filldedent('\\n                The 2nd argument was not a valid Point.\\n                If it was a slope, enter it with keyword \"slope\".\\n                '))\n    elif slope is not None and pt is None:\n        slope = sympify(slope)\n        if slope.is_finite is False:\n            dx = 0\n            dy = 1\n        else:\n            dx = 1\n            dy = slope\n        p2 = Point(p1.x + dx, p1.y + dy, evaluate=False)\n    else:\n        raise ValueError('A 2nd Point or keyword \"slope\" must be used.')\n    return LinearEntity2D.__new__(cls, p1, p2, **kwargs)",
    ".sympy.geometry.line.py@@Line2D.equation": "def equation(self, x='x', y='y'):\n    x = _symbol(x, real=True)\n    y = _symbol(y, real=True)\n    p1, p2 = self.points\n    if p1.x == p2.x:\n        return x - p1.x\n    elif p1.y == p2.y:\n        return y - p1.y\n    a, b, c = self.coefficients\n    return a * x + b * y + c",
    ".sympy.geometry.line.py@@LinearEntity.__contains__": "def __contains__(self, other):\n    result = self.contains(other)\n    if result is not None:\n        return result\n    else:\n        raise Undecidable(\"can't decide whether '%s' contains '%s'\" % (self, other))",
    ".sympy.geometry.line.py@@Segment.contains": "def contains(self, other):\n    if not isinstance(other, GeometryEntity):\n        other = Point(other, dim=self.ambient_dimension)\n    if isinstance(other, Point):\n        if Point.is_collinear(other, self.p1, self.p2):\n            d1, d2 = (other - self.p1, other - self.p2)\n            d = self.p2 - self.p1\n            try:\n                return bool(simplify(Eq(abs(d1) + abs(d2) - abs(d), 0)))\n            except TypeError:\n                raise Undecidable('Cannot determine if {} is in {}'.format(other, self))\n    if isinstance(other, Segment):\n        return other.p1 in self and other.p2 in self\n    return False",
    ".sympy.geometry.line.py@@LinearEntity.ambient_dimension": "def ambient_dimension(self):\n    return len(self.p1)",
    ".sympy.geometry.point.py@@Point.is_collinear": "def is_collinear(self, *args):\n    points = (self,) + args\n    points = Point._normalize_dimension(*[Point(i) for i in points])\n    points = list(uniq(points))\n    return Point.affine_rank(*points) <= 1",
    ".sympy.geometry.point.py@@Point.affine_rank": "def affine_rank(*args):\n    if len(args) == 0:\n        return -1\n    points = Point._normalize_dimension(*[Point(i) for i in args])\n    origin = points[0]\n    points = [i - origin for i in points[1:]]\n    m = Matrix([i.args for i in points])\n    return m.rank()",
    ".sympy.geometry.point.py@@Point.__sub__": "def __sub__(self, other):\n    return self + [-x for x in other]",
    ".sympy.geometry.point.py@@Point.__iter__": "def __iter__(self):\n    return self.args.__iter__()",
    ".sympy.geometry.point.py@@Point.__add__": "def __add__(self, other):\n    try:\n        s, o = Point._normalize_dimension(self, Point(other, evaluate=False))\n    except TypeError:\n        raise GeometryError(\"Don't know how to add {} and a Point object\".format(other))\n    coords = [simplify(a + b) for a, b in zip(s, o)]\n    return Point(coords, evaluate=False)",
    ".sympy.simplify.simplify.py@@simplify": "def simplify(expr, ratio=1.7, measure=count_ops, rational=False, inverse=False):\n    expr = sympify(expr)\n    try:\n        return expr._eval_simplify(ratio=ratio, measure=measure, rational=rational, inverse=inverse)\n    except AttributeError:\n        pass\n    original_expr = expr = signsimp(expr)\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.functions.special.bessel import BesselBase\n    from sympy import Sum, Product\n    if not isinstance(expr, Basic) or not expr.args:\n        return expr\n    if inverse and expr.has(Function):\n        expr = inversecombine(expr)\n        if not expr.args:\n            return expr\n    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n        return expr.func(*[simplify(x, ratio=ratio, measure=measure, rational=rational, inverse=inverse) for x in expr.args])\n    if not expr.is_commutative:\n        expr = nc_simplify(expr)\n\n    def shorter(*choices):\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n    floats = False\n    if rational is not False and expr.has(Float):\n        floats = True\n        expr = nsimplify(expr, rational=True)\n    expr = bottom_up(expr, lambda w: w.normal())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):\n        return expr\n    expr = factor_terms(expr, sign=False)\n    expr = hyperexpand(expr)\n    expr = piecewise_fold(expr)\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n    if expr.has(TrigonometricFunction, HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n    if expr.has(CombinatorialFunction, gamma):\n        expr = combsimp(expr)\n    if expr.has(Sum):\n        expr = sum_simplify(expr)\n    if expr.has(Product):\n        expr = product_simplify(expr)\n    from sympy.physics.units import Quantity\n    from sympy.physics.units.util import quantity_simplify\n    if expr.has(Quantity):\n        expr = quantity_simplify(expr)\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, cancel(short))\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n        short = exptrigsimp(short)\n    hollow_mul = Transform(lambda x: Mul(*x.args), lambda x: x.is_Mul and len(x.args) == 2 and x.args[0].is_Number and x.args[1].is_Add and x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1 / denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer * n).expand() / d\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n / -d)\n    if measure(expr) > ratio * measure(original_expr):\n        expr = original_expr\n    if floats and rational is None:\n        expr = nfloat(expr, exponent=False)\n    return expr",
    ".sympy.core.basic.py@@Atom._eval_simplify": "def _eval_simplify(self, ratio, measure, rational, inverse):\n    return self",
    ".sympy.matrices.dense.py@@MutableDenseMatrix.__new__": "def __new__(cls, *args, **kwargs):\n    return cls._new(*args, **kwargs)",
    ".sympy.matrices.dense.py@@MutableDenseMatrix._new": "def _new(cls, *args, **kwargs):\n    if kwargs.get('copy', True) is False:\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list)\n    self = object.__new__(cls)\n    self.rows = rows\n    self.cols = cols\n    self._mat = flat_list\n    return self",
    ".sympy.matrices.matrices.py@@MatrixBase._handle_creation_inputs": "def _handle_creation_inputs(cls, *args, **kwargs):\n    from sympy.matrices.sparse import SparseMatrix\n    flat_list = None\n    if len(args) == 1:\n        if isinstance(args[0], SparseMatrix):\n            return (args[0].rows, args[0].cols, flatten(args[0].tolist()))\n        elif isinstance(args[0], MatrixBase):\n            return (args[0].rows, args[0].cols, args[0]._mat)\n        elif isinstance(args[0], Basic) and args[0].is_Matrix:\n            return (args[0].rows, args[0].cols, args[0].as_explicit()._mat)\n        elif hasattr(args[0], '__array__'):\n            arr = args[0].__array__()\n            if len(arr.shape) == 2:\n                rows, cols = (arr.shape[0], arr.shape[1])\n                flat_list = [cls._sympify(i) for i in arr.ravel()]\n                return (rows, cols, flat_list)\n            elif len(arr.shape) == 1:\n                rows, cols = (arr.shape[0], 1)\n                flat_list = [S.Zero] * rows\n                for i in range(len(arr)):\n                    flat_list[i] = cls._sympify(arr[i])\n                return (rows, cols, flat_list)\n            else:\n                raise NotImplementedError('SymPy supports just 1D and 2D matrices')\n        elif is_sequence(args[0]) and (not isinstance(args[0], DeferredVector)):\n            in_mat = []\n            ncol = set()\n            for row in args[0]:\n                if isinstance(row, MatrixBase):\n                    in_mat.extend(row.tolist())\n                    if row.cols or row.rows:\n                        ncol.add(row.cols)\n                else:\n                    in_mat.append(row)\n                    try:\n                        ncol.add(len(row))\n                    except TypeError:\n                        ncol.add(1)\n            if len(ncol) > 1:\n                raise ValueError('Got rows of variable lengths: %s' % sorted(list(ncol)))\n            cols = ncol.pop() if ncol else 0\n            rows = len(in_mat) if cols else 0\n            if rows:\n                if not is_sequence(in_mat[0]):\n                    cols = 1\n                    flat_list = [cls._sympify(i) for i in in_mat]\n                    return (rows, cols, flat_list)\n            flat_list = []\n            for j in range(rows):\n                for i in range(cols):\n                    flat_list.append(cls._sympify(in_mat[j][i]))\n    elif len(args) == 3:\n        rows = as_int(args[0])\n        cols = as_int(args[1])\n        if rows < 0 or cols < 0:\n            raise ValueError('Cannot create a {} x {} matrix. Both dimensions must be positive'.format(rows, cols))\n        if len(args) == 3 and isinstance(args[2], Callable):\n            op = args[2]\n            flat_list = []\n            for i in range(rows):\n                flat_list.extend([cls._sympify(op(cls._sympify(i), cls._sympify(j))) for j in range(cols)])\n        elif len(args) == 3 and is_sequence(args[2]):\n            flat_list = args[2]\n            if len(flat_list) != rows * cols:\n                raise ValueError('List length should be equal to rows*columns')\n            flat_list = [cls._sympify(i) for i in flat_list]\n    elif len(args) == 0:\n        rows = cols = 0\n        flat_list = []\n    if flat_list is None:\n        raise TypeError('Data type not understood')\n    return (rows, cols, flat_list)",
    ".sympy.matrices.matrices.py@@MatrixReductions.rank": "def rank(self, iszerofunc=_iszero, simplify=False):\n    simpfunc = simplify if isinstance(simplify, FunctionType) else _simplify\n    if self.rows <= 0 or self.cols <= 0:\n        return 0\n    if self.rows <= 1 or self.cols <= 1:\n        zeros = [iszerofunc(x) for x in self]\n        if False in zeros:\n            return 1\n    if self.rows == 2 and self.cols == 2:\n        zeros = [iszerofunc(x) for x in self]\n        if not False in zeros and (not None in zeros):\n            return 0\n        det = self.det()\n        if iszerofunc(det) and False in zeros:\n            return 1\n        if iszerofunc(det) is False:\n            return 2\n    mat, _ = self._permute_complexity_right(iszerofunc=iszerofunc)\n    echelon_form, pivots, swaps = mat._eval_echelon_form(iszerofunc=iszerofunc, simpfunc=simpfunc)\n    return len(pivots)",
    ".sympy.matrices.dense.py@@DenseMatrix.__getitem__": "def __getitem__(self, key):\n    if isinstance(key, tuple):\n        i, j = key\n        try:\n            i, j = self.key2ij(key)\n            return self._mat[i * self.cols + j]\n        except (TypeError, IndexError):\n            if isinstance(i, Expr) and (not i.is_number) or (isinstance(j, Expr) and (not j.is_number)):\n                if (j < 0) is True or (j >= self.shape[1]) is True or (i < 0) is True or ((i >= self.shape[0]) is True):\n                    raise ValueError('index out of boundary')\n                from sympy.matrices.expressions.matexpr import MatrixElement\n                return MatrixElement(self, i, j)\n            if isinstance(i, slice):\n                i = list(range(self.rows))[i]\n            elif is_sequence(i):\n                pass\n            else:\n                i = [i]\n            if isinstance(j, slice):\n                j = list(range(self.cols))[j]\n            elif is_sequence(j):\n                pass\n            else:\n                j = [j]\n            return self.extract(i, j)\n    else:\n        if isinstance(key, slice):\n            return self._mat[key]\n        return self._mat[a2idx(key)]",
    ".sympy.matrices.common.py@@a2idx": "def a2idx(j, n=None):\n    if type(j) is not int:\n        try:\n            j = j.__index__()\n        except AttributeError:\n            raise IndexError('Invalid index a[%r]' % (j,))\n    if n is not None:\n        if j < 0:\n            j += n\n        if not (j >= 0 and j < n):\n            raise IndexError('Index out of range: a[%s]' % (j,))\n    return int(j)",
    ".sympy.matrices.matrices.py@@_iszero": "def _iszero(x):\n    try:\n        return x.is_zero\n    except AttributeError:\n        return None",
    ".sympy.matrices.matrices.py@@MatrixDeterminant.det": "def det(self, method='bareiss', iszerofunc=None):\n    method = method.lower()\n    if method == 'bareis':\n        method = 'bareiss'\n    if method == 'det_lu':\n        method = 'lu'\n    if method not in ('bareiss', 'berkowitz', 'lu'):\n        raise ValueError(\"Determinant method '%s' unrecognized\" % method)\n    if iszerofunc is None:\n        if method == 'bareiss':\n            iszerofunc = _is_zero_after_expand_mul\n        elif method == 'lu':\n            iszerofunc = _iszero\n    elif not isinstance(iszerofunc, FunctionType):\n        raise ValueError(\"Zero testing method '%s' unrecognized\" % iszerofunc)\n    if self.rows != self.cols:\n        raise NonSquareMatrixError()\n    n = self.rows\n    if n == 0:\n        return S.One\n    elif n == 1:\n        return self[0, 0]\n    elif n == 2:\n        return self[0, 0] * self[1, 1] - self[0, 1] * self[1, 0]\n    elif n == 3:\n        return self[0, 0] * self[1, 1] * self[2, 2] + self[0, 1] * self[1, 2] * self[2, 0] + self[0, 2] * self[1, 0] * self[2, 1] - self[0, 2] * self[1, 1] * self[2, 0] - self[0, 0] * self[1, 2] * self[2, 1] - self[0, 1] * self[1, 0] * self[2, 2]\n    if method == 'bareiss':\n        return self._eval_det_bareiss(iszerofunc=iszerofunc)\n    elif method == 'berkowitz':\n        return self._eval_det_berkowitz()\n    elif method == 'lu':\n        return self._eval_det_lu(iszerofunc=iszerofunc)",
    ".sympy.matrices.matrices.py@@MatrixBase.key2ij": "def key2ij(self, key):\n    from sympy.matrices.common import a2idx as a2idx_\n    if is_sequence(key):\n        if not len(key) == 2:\n            raise TypeError('key must be a sequence of length 2')\n        return [a2idx_(i, n) if not isinstance(i, slice) else i for i, n in zip(key, self.shape)]\n    elif isinstance(key, slice):\n        return key.indices(len(self))[:2]\n    else:\n        return divmod(a2idx_(key, len(self)), self.cols)",
    ".sympy.matrices.common.py@@MatrixShaping.shape": "def shape(self):\n    return (self.rows, self.cols)",
    ".sympy.geometry.point.py@@Point.__abs__": "def __abs__(self):\n    origin = Point([0] * len(self))\n    return Point.distance(origin, self)",
    ".sympy.geometry.point.py@@Point.distance": "def distance(self, p):\n    s, p = Point._normalize_dimension(self, Point(p))\n    return sqrt(Add(*((a - b) ** 2 for a, b in zip(s, p))))",
    ".sympy.functions.elementary.miscellaneous.py@@sqrt": "def sqrt(arg, evaluate=None):\n    return Pow(arg, S.Half, evaluate=evaluate)",
    ".sympy.core.numbers.py@@Rational.__hash__": "def __hash__(self):\n    return super(Rational, self).__hash__()",
    ".sympy.core.numbers.py@@Half.__abs__": "def __abs__():\n    return S.Half",
    ".sympy.simplify.simplify.py@@signsimp": "def signsimp(expr, evaluate=None):\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    expr = sympify(expr)\n    if not isinstance(expr, Expr) or expr.is_Atom:\n        return expr\n    e = sub_post(sub_pre(expr))\n    if not isinstance(e, Expr) or e.is_Atom:\n        return e\n    if e.is_Add:\n        return e.func(*[signsimp(a, evaluate) for a in e.args])\n    if evaluate:\n        e = e.xreplace({m: --m for m in e.atoms(Mul) if --m != m})\n    return e",
    ".sympy.geometry.point.py@@Point2D.__contains__": "def __contains__(self, item):\n    return item == self",
    ".sympy.simplify.trigsimp.py@@trigsimp": "def trigsimp(expr, **opts):\n    from sympy.simplify.fu import fu\n    expr = sympify(expr)\n    try:\n        return expr._eval_trigsimp(**opts)\n    except AttributeError:\n        pass\n    old = opts.pop('old', False)\n    if not old:\n        opts.pop('deep', None)\n        recursive = opts.pop('recursive', None)\n        method = opts.pop('method', 'matching')\n    else:\n        method = 'old'\n\n    def groebnersimp(ex, **opts):\n\n        def traverse(e):\n            if e.is_Atom:\n                return e\n            args = [traverse(x) for x in e.args]\n            if e.is_Function or e.is_Pow:\n                args = [trigsimp_groebner(x, **opts) for x in args]\n            return e.func(*args)\n        new = traverse(ex)\n        if not isinstance(new, Expr):\n            return new\n        return trigsimp_groebner(new, **opts)\n    trigsimpfunc = {'fu': lambda x: fu(x, **opts), 'matching': lambda x: futrig(x), 'groebner': lambda x: groebnersimp(x, **opts), 'combined': lambda x: futrig(groebnersimp(x, polynomial=True, hints=[2, tan])), 'old': lambda x: trigsimp_old(x, **opts)}[method]\n    return trigsimpfunc(expr)",
    ".sympy.simplify.trigsimp.py@@futrig": "def futrig(e, **kwargs):\n    from sympy.simplify.fu import hyper_as_trig\n    from sympy.simplify.simplify import bottom_up\n    e = sympify(e)\n    if not isinstance(e, Basic):\n        return e\n    if not e.args:\n        return e\n    old = e\n    e = bottom_up(e, lambda x: _futrig(x, **kwargs))\n    if kwargs.pop('hyper', True) and e.has(HyperbolicFunction):\n        e, f = hyper_as_trig(e)\n        e = f(_futrig(e))\n    if e != old and e.is_Mul and e.args[0].is_Rational:\n        e = Mul(*e.as_coeff_Mul())\n    return e",
    ".sympy.ntheory.factor_.py@@perfect_power": "def perfect_power(n, candidates=None, big=True, factor=True):\n    n = int(n)\n    if n < 3:\n        return False\n    logn = math.log(n, 2)\n    max_possible = int(logn) + 2\n    not_square = n % 10 in [2, 3, 7, 8]\n    if not candidates:\n        candidates = primerange(2 + not_square, max_possible)\n    afactor = 2 + n % 2\n    for e in candidates:\n        if e < 3:\n            if e == 1 or (e == 2 and not_square):\n                continue\n        if e > max_possible:\n            return False\n        if factor:\n            if n % afactor == 0:\n                if afactor == 2:\n                    e = trailing(n)\n                else:\n                    e = multiplicity(afactor, n)\n                if e == 1:\n                    return False\n                r, exact = integer_nthroot(n, e)\n                if not exact:\n                    n //= afactor ** e\n                    m = perfect_power(n, candidates=primefactors(e), big=big)\n                    if m is False:\n                        return False\n                    else:\n                        r, m = m\n                        g = igcd(m, e)\n                        if g == 1:\n                            return False\n                        m //= g\n                        e //= g\n                        r, e = (r ** m * afactor ** e, g)\n                if not big:\n                    e0 = primefactors(e)\n                    if len(e0) > 1 or e0[0] != e:\n                        e0 = e0[0]\n                        r, e = (r ** (e // e0), e0)\n                return (r, e)\n            else:\n                afactor = nextprime(afactor)\n        if logn / e < 40:\n            b = 2.0 ** (logn / e)\n            if abs(int(b + 0.5) - b) > 0.01:\n                continue\n        r, exact = integer_nthroot(n, e)\n        if exact:\n            if big:\n                m = perfect_power(r, big=big, factor=factor)\n                if m is not False:\n                    r, e = (m[0], e * m[1])\n            return (int(r), e)\n    else:\n        return False",
    ".sympy.core.numbers.py@@Rational.factors": "def factors(self, limit=None, use_trial=True, use_rho=False, use_pm1=False, verbose=False, visual=False):\n    from sympy.ntheory import factorrat\n    return factorrat(self, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()",
    ".sympy.ntheory.factor_.py@@factorrat": "def factorrat(rat, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False):\n    from collections import defaultdict\n    if multiple:\n        fac = factorrat(rat, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)\n        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S(1) / p] * -fac[p] for p, _ in sorted(fac.items(), key=lambda elem: elem[0] if elem[1] > 0 else 1 / elem[0])), [])\n        return factorlist\n    f = factorint(rat.p, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()\n    f = defaultdict(int, f)\n    for p, e in factorint(rat.q, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).items():\n        f[p] += -e\n    if len(f) > 1 and 1 in f:\n        del f[1]\n    if not visual:\n        return dict(f)\n    else:\n        if -1 in f:\n            f.pop(-1)\n            args = [S.NegativeOne]\n        else:\n            args = []\n        args.extend([Pow(*i, evaluate=False) for i in sorted(f.items())])\n        return Mul(*args, evaluate=False)",
    ".sympy.ntheory.factor_.py@@factorint": "def factorint(n, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False):\n    if multiple:\n        fac = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)\n        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S(1) / p] * -fac[p] for p in sorted(fac)), [])\n        return factorlist\n    factordict = {}\n    if visual and (not isinstance(n, Mul)) and (not isinstance(n, dict)):\n        factordict = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n    elif isinstance(n, Mul):\n        factordict = dict([(int(k), int(v)) for k, v in list(n.as_powers_dict().items())])\n    elif isinstance(n, dict):\n        factordict = n\n    if factordict and (isinstance(n, Mul) or isinstance(n, dict)):\n        for k in list(factordict.keys()):\n            if isprime(k):\n                continue\n            e = factordict.pop(k)\n            d = factorint(k, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n            for k, v in d.items():\n                if k in factordict:\n                    factordict[k] += v * e\n                else:\n                    factordict[k] = v * e\n    if visual or (type(n) is dict and visual is not True and (visual is not False)):\n        if factordict == {}:\n            return S.One\n        if -1 in factordict:\n            factordict.pop(-1)\n            args = [S.NegativeOne]\n        else:\n            args = []\n        args.extend([Pow(*i, evaluate=False) for i in sorted(factordict.items())])\n        return Mul(*args, evaluate=False)\n    elif isinstance(n, dict) or isinstance(n, Mul):\n        return factordict\n    assert use_trial or use_rho or use_pm1\n    from sympy.functions.combinatorial.factorials import factorial\n    if isinstance(n, factorial):\n        x = as_int(n.args[0])\n        if x >= 20:\n            factors = {}\n            m = 2\n            for p in sieve.primerange(2, x + 1):\n                if m > 1:\n                    m, q = (0, x // p)\n                    while q != 0:\n                        m += q\n                        q //= p\n                factors[p] = m\n            if factors and verbose:\n                for k in sorted(factors):\n                    print(factor_msg % (k, factors[k]))\n            if verbose:\n                print(complete_msg)\n            return factors\n        else:\n            n = n.func(x)\n    n = as_int(n)\n    if limit:\n        limit = int(limit)\n    if n < 0:\n        factors = factorint(-n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n        factors[-1] = 1\n        return factors\n    if limit and limit < 2:\n        if n == 1:\n            return {}\n        return {n: 1}\n    elif n < 10:\n        return [{0: 1}, {}, {2: 1}, {3: 1}, {2: 2}, {5: 1}, {2: 1, 3: 1}, {7: 1}, {2: 3}, {3: 2}][n]\n    factors = {}\n    if verbose:\n        sn = str(n)\n        if len(sn) > 50:\n            print('Factoring %s' % sn[:5] + '..(%i other digits)..' % (len(sn) - 10) + sn[-5:])\n        else:\n            print('Factoring', n)\n    if use_trial:\n        small = 2 ** 15\n        fail_max = 600\n        small = min(small, limit or small)\n        if verbose:\n            print(trial_int_msg % (2, small, fail_max))\n        n, next_p = _factorint_small(factors, n, small, fail_max)\n    else:\n        next_p = 2\n    if factors and verbose:\n        for k in sorted(factors):\n            print(factor_msg % (k, factors[k]))\n    if next_p == 0:\n        if n > 1:\n            factors[int(n)] = 1\n        if verbose:\n            print(complete_msg)\n        return factors\n    try:\n        if limit and next_p > limit:\n            if verbose:\n                print('Exceeded limit:', limit)\n            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n            if n > 1:\n                factors[int(n)] = 1\n            return factors\n        else:\n            sqrt_n = integer_nthroot(n, 2)[0]\n            a = sqrt_n + 1\n            a2 = a ** 2\n            b2 = a2 - n\n            for i in range(3):\n                b, fermat = integer_nthroot(b2, 2)\n                if fermat:\n                    break\n                b2 += 2 * a + 1\n                a += 1\n            if fermat:\n                if verbose:\n                    print(fermat_msg)\n                if limit:\n                    limit -= 1\n                for r in [a - b, a + b]:\n                    facs = factorint(r, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)\n                    factors.update(facs)\n                raise StopIteration\n            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n    except StopIteration:\n        if verbose:\n            print(complete_msg)\n        return factors\n    low, high = (next_p, 2 * next_p)\n    limit = limit or sqrt_n\n    limit += 1\n    while 1:\n        try:\n            high_ = high\n            if limit < high_:\n                high_ = limit\n            if use_trial:\n                if verbose:\n                    print(trial_msg % (low, high_))\n                ps = sieve.primerange(low, high_)\n                n, found_trial = _trial(factors, n, ps, verbose)\n                if found_trial:\n                    _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n            else:\n                found_trial = False\n            if high > limit:\n                if verbose:\n                    print('Exceeded limit:', limit)\n                if n > 1:\n                    factors[int(n)] = 1\n                raise StopIteration\n            if not found_trial:\n                if use_pm1 or use_rho:\n                    high_root = max(int(math.log(high_ ** 0.7)), low, 3)\n                    if use_pm1:\n                        if verbose:\n                            print(pm1_msg % (high_root, high_))\n                        c = pollard_pm1(n, B=high_root, seed=high_)\n                        if c:\n                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)\n                            n, _ = _trial(factors, n, ps, verbose=False)\n                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n                    if use_rho:\n                        max_steps = high_root\n                        if verbose:\n                            print(rho_msg % (1, max_steps, high_))\n                        c = pollard_rho(n, retries=1, max_steps=max_steps, seed=high_)\n                        if c:\n                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)\n                            n, _ = _trial(factors, n, ps, verbose=False)\n                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n        except StopIteration:\n            if verbose:\n                print(complete_msg)\n            return factors\n        low, high = (high, high * 2)",
    ".sympy.core.numbers.py@@Integer.__rmul__": "def __rmul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(other * self.p)\n        elif isinstance(other, Rational):\n            return Rational(other.p * self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    ".sympy.core.numbers.py@@Rational.__sub__": "def __sub__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, Integer):\n            return Rational(self.p - self.q * other.p, self.q, 1)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - self.q * other.p, self.q * other.q)\n        elif isinstance(other, Float):\n            return -other + self\n        else:\n            return Number.__sub__(self, other)\n    return Number.__sub__(self, other)",
    ".sympy.core.numbers.py@@Number.__sub__": "def __sub__(self, other):\n    if isinstance(other, Number) and global_evaluate[0]:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            return S.NegativeInfinity\n        elif other is S.NegativeInfinity:\n            return S.Infinity\n    return AtomicExpr.__sub__(self, other)",
    ".sympy.core.mul.py@@Mul._eval_is_real": "def _eval_is_real(self):\n    return self._eval_real_imag(True)",
    ".sympy.core.mul.py@@Mul._eval_real_imag": "def _eval_real_imag(self, real):\n    zero = False\n    t_not_re_im = None\n    for t in self.args:\n        if not t.is_complex:\n            return t.is_complex\n        elif t.is_imaginary:\n            real = not real\n        elif t.is_real:\n            if not zero:\n                z = t.is_zero\n                if not z and zero is False:\n                    zero = z\n                elif z:\n                    if all((a.is_finite for a in self.args)):\n                        return True\n                    return\n        elif t.is_real is False:\n            if t_not_re_im:\n                return\n            t_not_re_im = t\n        elif t.is_imaginary is False:\n            if t_not_re_im:\n                return\n            t_not_re_im = t\n        else:\n            return\n    if t_not_re_im:\n        if t_not_re_im.is_real is False:\n            if real:\n                return zero\n        if t_not_re_im.is_imaginary is False:\n            if not real:\n                return zero\n    elif zero is False:\n        return real\n    elif real:\n        return real",
    ".sympy.core.operations.py@@AssocOp._eval_evalf": "def _eval_evalf(self, prec):\n    from .add import Add\n    from .mul import Mul\n    from .symbol import Symbol\n    from .function import AppliedUndef\n    if isinstance(self, (Mul, Add)):\n        x, tail = self.as_independent(Symbol, AppliedUndef)\n        if not (tail is self.identity or (isinstance(x, AssocOp) and x.is_Function) or (x is self.identity and isinstance(tail, AssocOp))):\n            x = x._evalf(prec) if x is not self.identity else self.identity\n            args = []\n            tail_args = tuple(self.func.make_args(tail))\n            for a in tail_args:\n                newa = a._eval_evalf(prec)\n                if newa is None:\n                    args.append(a)\n                else:\n                    args.append(newa)\n            return self.func(x, *args)\n    args = []\n    for a in self.args:\n        newa = a._eval_evalf(prec)\n        if newa is None:\n            args.append(a)\n        else:\n            args.append(newa)\n    return self.func(*args)",
    ".sympy.core.mul.py@@Mul._eval_is_zero": "def _eval_is_zero(self):\n    zero = infinite = False\n    for a in self.args:\n        z = a.is_zero\n        if z:\n            if infinite:\n                return\n            zero = True\n        else:\n            if not a.is_finite:\n                if zero:\n                    return\n                infinite = True\n            if zero is False and z is None:\n                zero = None\n    return zero",
    ".sympy.core.mul.py@@Mul._eval_is_rational": "def _eval_is_rational(self):\n    r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        return self.is_zero",
    ".sympy.core.numbers.py@@Number._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Integer._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_int(self.p, prec, rnd)",
    ".sympy.core.numbers.py@@Float._new": "def _new(cls, _mpf_, _prec):\n    if _mpf_ == _mpf_zero:\n        return S.Zero\n    elif _mpf_ == _mpf_nan:\n        return S.NaN\n    obj = Expr.__new__(cls)\n    obj._mpf_ = mpf_norm(_mpf_, _prec)\n    obj._prec = _prec\n    return obj",
    ".sympy.core.numbers.py@@mpf_norm": "def mpf_norm(mpf, prec):\n    sign, man, expt, bc = mpf\n    if not man:\n        if not bc:\n            return _mpf_zero\n        else:\n            return mpf\n    from mpmath.libmp.backend import MPZ\n    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n    return rv",
    ".sympy.core.mul.py@@Mul._eval_evalf": "def _eval_evalf(self, prec):\n    c, m = self.as_coeff_Mul()\n    if c is S.NegativeOne:\n        if m.is_Mul:\n            rv = -AssocOp._eval_evalf(m, prec)\n        else:\n            mnew = m._eval_evalf(prec)\n            if mnew is not None:\n                m = mnew\n            rv = -m\n    else:\n        rv = AssocOp._eval_evalf(self, prec)\n    if rv.is_number:\n        return rv.expand()\n    return rv",
    ".sympy.core.expr.py@@Expr.args_cnc": "def args_cnc(self, cset=False, warn=True, split_1=True):\n    if self.is_Mul:\n        args = list(self.args)\n    else:\n        args = [self]\n    for i, mi in enumerate(args):\n        if not mi.is_commutative:\n            c = args[:i]\n            nc = args[i:]\n            break\n    else:\n        c = args\n        nc = []\n    if c and split_1 and (c[0].is_Number and c[0].is_negative and (c[0] is not S.NegativeOne)):\n        c[:1] = [S.NegativeOne, -c[0]]\n    if cset:\n        clen = len(c)\n        c = set(c)\n        if clen and warn and (len(c) != clen):\n            raise ValueError('repeated commutative arguments: %s' % [ci for ci in c if list(self.args).count(ci) > 1])\n    return [c, nc]",
    ".sympy.core.mul.py@@_unevaluated_Mul": "def _unevaluated_Mul(*args):\n    args = list(args)\n    newargs = []\n    ncargs = []\n    co = S.One\n    while args:\n        a = args.pop()\n        if a.is_Mul:\n            c, nc = a.args_cnc()\n            args.extend(c)\n            if nc:\n                ncargs.append(Mul._from_args(nc))\n        elif a.is_Number:\n            co *= a\n        else:\n            newargs.append(a)\n    _mulsort(newargs)\n    if co is not S.One:\n        newargs.insert(0, co)\n    if ncargs:\n        newargs.append(Mul._from_args(ncargs))\n    return Mul._from_args(newargs)",
    ".sympy.core.power.py@@Pow._eval_evalf": "def _eval_evalf(self, prec):\n    base, exp = self.as_base_exp()\n    base = base._evalf(prec)\n    if not exp.is_Integer:\n        exp = exp._evalf(prec)\n    if exp.is_negative and base.is_number and (base.is_real is False):\n        base = base.conjugate() / (base * base.conjugate())._evalf(prec)\n        exp = -exp\n        return self.func(base, exp).expand()\n    return self.func(base, exp)",
    ".sympy.core.evalf.py@@EvalfMixin._evalf": "def _evalf(self, prec):\n    r = self._eval_evalf(prec)\n    if r is None:\n        r = self\n    return r",
    ".sympy.core.numbers.py@@Rational._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_rational(self.p, self.q, prec, rnd)",
    ".sympy.core.assumptions.py@@StdFactKB.generator": "def generator(self):\n    return self._generator.copy()",
    ".sympy.core.numbers.py@@Float._eval_is_negative": "def _eval_is_negative(self):\n    if self._mpf_ == _mpf_ninf:\n        return True\n    if self._mpf_ == _mpf_inf:\n        return False\n    return self.num < 0",
    ".sympy.core.numbers.py@@Float.num": "def num(self):\n    return mpmath.mpf(self._mpf_)",
    ".sympy.core.numbers.py@@Float.__hash__": "def __hash__(self):\n    return super(Float, self).__hash__()",
    ".sympy.core.numbers.py@@Float._hashable_content": "def _hashable_content(self):\n    return (self._mpf_, self._prec)",
    ".sympy.core.numbers.py@@Float._eval_is_integer": "def _eval_is_integer(self):\n    return self._mpf_ == _mpf_zero",
    ".sympy.core.numbers.py@@Float.__eq__": "def __eq__(self, other):\n    if isinstance(other, float):\n        o = Float(other)\n        try:\n            ompf = o._as_mpf_val(self._prec)\n        except ValueError:\n            return False\n        return bool(mlib.mpf_eq(self._mpf_, ompf))\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Float:\n        return bool(mlib.mpf_eq(self._mpf_, other._mpf_))\n    if other.is_Number:\n        ompf = other._as_mpf_val(self._prec)\n        return bool(mlib.mpf_eq(self._mpf_, ompf))\n    return False",
    ".sympy.core.numbers.py@@NaN._as_mpf_val": "def _as_mpf_val(self, prec):\n    return _mpf_nan",
    ".sympy.core.numbers.py@@Float._eval_power": "def _eval_power(self, expt):\n    if self == 0:\n        if expt.is_positive:\n            return S.Zero\n        if expt.is_negative:\n            return Float('inf')\n    if isinstance(expt, Number):\n        if isinstance(expt, Integer):\n            prec = self._prec\n            return Float._new(mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)\n        elif isinstance(expt, Rational) and expt.p == 1 and expt.q % 2 and self.is_negative:\n            return Pow(S.NegativeOne, expt, evaluate=False) * (-self)._eval_power(expt)\n        expt, prec = expt._as_mpf_op(self._prec)\n        mpfself = self._mpf_\n        try:\n            y = mpf_pow(mpfself, expt, prec, rnd)\n            return Float._new(y, prec)\n        except mlib.ComplexResult:\n            re, im = mlib.mpc_pow((mpfself, _mpf_zero), (expt, _mpf_zero), prec, rnd)\n            return Float._new(re, prec) + Float._new(im, prec) * S.ImaginaryUnit",
    ".sympy.core.numbers.py@@Float._as_mpf_op": "def _as_mpf_op(self, prec):\n    return (self._mpf_, max(prec, self._prec))",
    ".sympy.core.numbers.py@@Float._eval_is_zero": "def _eval_is_zero(self):\n    return self._mpf_ == _mpf_zero",
    ".sympy.core.numbers.py@@Rational.__mul__": "def __mul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, Integer):\n            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))\n        elif isinstance(other, Float):\n            return other * self\n        else:\n            return Number.__mul__(self, other)\n    return Number.__mul__(self, other)",
    ".sympy.core.numbers.py@@Float.__mul__": "def __mul__(self, other):\n    if isinstance(other, Number) and global_evaluate[0]:\n        rhs, prec = other._as_mpf_op(self._prec)\n        return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)\n    return Number.__mul__(self, other)",
    ".sympy.core.numbers.py@@Number._as_mpf_op": "def _as_mpf_op(self, prec):\n    prec = max(prec, self._prec)\n    return (self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Rational.__add__": "def __add__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, Integer):\n            return Rational(self.p + self.q * other.p, self.q, 1)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + self.q * other.p, self.q * other.q)\n        elif isinstance(other, Float):\n            return other + self\n        else:\n            return Number.__add__(self, other)\n    return Number.__add__(self, other)",
    ".sympy.core.numbers.py@@Float.__add__": "def __add__(self, other):\n    if isinstance(other, Number) and global_evaluate[0]:\n        rhs, prec = other._as_mpf_op(self._prec)\n        return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)\n    return Number.__add__(self, other)",
    ".sympy.core.evalf.py@@EvalfMixin.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    from sympy import Float, Number\n    n = n if n is not None else 15\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n    if n == 1 and isinstance(self, Number):\n        from sympy.core.expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        try:\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            return v\n    re, im, re_acc, im_acc = result\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im * S.ImaginaryUnit\n    else:\n        return re",
    ".sympy.core.evalf.py@@evalf": "def evalf(x, prec, options):\n    from sympy import re as re_, im as im_\n    try:\n        rf = evalf_table[x.func]\n        r = rf(x, prec, options)\n    except KeyError:\n        try:\n            if 'subs' in options:\n                x = x.subs(evalf_subs(prec, options['subs']))\n            xe = x._eval_evalf(prec)\n            re, im = xe.as_real_imag()\n            if re.has(re_) or im.has(im_):\n                raise NotImplementedError\n            if re == 0:\n                re = None\n                reprec = None\n            elif re.is_number:\n                re = re._to_mpmath(prec, allow_ints=False)._mpf_\n                reprec = prec\n            else:\n                raise NotImplementedError\n            if im == 0:\n                im = None\n                imprec = None\n            elif im.is_number:\n                im = im._to_mpmath(prec, allow_ints=False)._mpf_\n                imprec = prec\n            else:\n                raise NotImplementedError\n            r = (re, im, reprec, imprec)\n        except AttributeError:\n            raise NotImplementedError\n    if options.get('verbose'):\n        print('### input', x)\n        print('### output', to_str(r[0] or fzero, 50))\n        print('### raw', r)\n        print()\n    chop = options.get('chop', False)\n    if chop:\n        if chop is True:\n            chop_prec = prec\n        else:\n            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))\n            if chop_prec == 3:\n                chop_prec -= 1\n        r = chop_parts(r, chop_prec)\n    if options.get('strict'):\n        check_target(x, r, prec)\n    return r",
    ".sympy.core.evalf.py@@evalf_add": "def evalf_add(v, prec, options):\n    res = pure_complex(v)\n    if res:\n        h, c = res\n        re, _, re_acc, _ = evalf(h, prec, options)\n        im, _, im_acc, _ = evalf(c, prec, options)\n        return (re, im, re_acc, im_acc)\n    oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)\n    i = 0\n    target_prec = prec\n    while 1:\n        options['maxprec'] = min(oldmaxprec, 2 * prec)\n        terms = [evalf(arg, prec + 10, options) for arg in v.args]\n        re, re_acc = add_terms([a[0::2] for a in terms if a[0]], prec, target_prec)\n        im, im_acc = add_terms([a[1::2] for a in terms if a[1]], prec, target_prec)\n        acc = complex_accuracy((re, im, re_acc, im_acc))\n        if acc >= target_prec:\n            if options.get('verbose'):\n                print('ADD: wanted', target_prec, 'accurate bits, got', re_acc, im_acc)\n            break\n        else:\n            if prec - target_prec > options['maxprec']:\n                break\n            prec = prec + max(10 + 2 ** i, target_prec - acc)\n            i += 1\n            if options.get('verbose'):\n                print('ADD: restarting with prec', prec)\n    options['maxprec'] = oldmaxprec\n    if iszero(re, scaled=True):\n        re = scaled_zero(re)\n    if iszero(im, scaled=True):\n        im = scaled_zero(im)\n    return (re, im, re_acc, im_acc)",
    ".sympy.core.evalf.py@@pure_complex": "def pure_complex(v, or_real=False):\n    h, t = v.as_coeff_Add()\n    if not t:\n        if or_real:\n            return (h, t)\n        return\n    c, i = t.as_coeff_Mul()\n    if i is S.ImaginaryUnit:\n        return (h, c)",
    ".sympy.core.evalf.py@@evalf_mul": "def evalf_mul(v, prec, options):\n    res = pure_complex(v)\n    if res:\n        _, h = res\n        im, _, im_acc, _ = evalf(h, prec, options)\n        return (None, im, None, im_acc)\n    args = list(v.args)\n    special = []\n    from sympy.core.numbers import Float\n    for arg in args:\n        arg = evalf(arg, prec, options)\n        if arg[0] is None:\n            continue\n        arg = Float._new(arg[0], 1)\n        if arg is S.NaN or arg.is_infinite:\n            special.append(arg)\n    if special:\n        from sympy.core.mul import Mul\n        special = Mul(*special)\n        return evalf(special, prec + 4, {})\n    acc = prec\n    working_prec = prec + len(args) + 5\n    start = man, exp, bc = (MPZ(1), 0, 1)\n    last = len(args)\n    direction = 0\n    args.append(S.One)\n    complex_factors = []\n    for i, arg in enumerate(args):\n        if i != last and pure_complex(arg):\n            args[-1] = (args[-1] * arg).expand()\n            continue\n        elif i == last and arg is S.One:\n            continue\n        re, im, re_acc, im_acc = evalf(arg, working_prec, options)\n        if re and im:\n            complex_factors.append((re, im, re_acc, im_acc))\n            continue\n        elif re:\n            (s, m, e, b), w_acc = (re, re_acc)\n        elif im:\n            (s, m, e, b), w_acc = (im, im_acc)\n            direction += 1\n        else:\n            return (None, None, None, None)\n        direction += 2 * s\n        man *= m\n        exp += e\n        bc += b\n        if bc > 3 * working_prec:\n            man >>= working_prec\n            exp += working_prec\n        acc = min(acc, w_acc)\n    sign = (direction & 2) >> 1\n    if not complex_factors:\n        v = normalize(sign, man, exp, bitcount(man), prec, rnd)\n        if direction & 1:\n            return (None, v, None, acc)\n        else:\n            return (v, None, acc, None)\n    else:\n        if (man, exp, bc) != start:\n            re, im = ((sign, man, exp, bitcount(man)), (0, MPZ(0), 0, 0))\n            i0 = 0\n        else:\n            wre, wim, wre_acc, wim_acc = complex_factors[0]\n            acc = min(acc, complex_accuracy((wre, wim, wre_acc, wim_acc)))\n            re = wre\n            im = wim\n            i0 = 1\n        for wre, wim, wre_acc, wim_acc in complex_factors[i0:]:\n            acc = min(acc, complex_accuracy((wre, wim, wre_acc, wim_acc)))\n            use_prec = working_prec\n            A = mpf_mul(re, wre, use_prec)\n            B = mpf_mul(mpf_neg(im), wim, use_prec)\n            C = mpf_mul(re, wim, use_prec)\n            D = mpf_mul(im, wre, use_prec)\n            re = mpf_add(A, B, use_prec)\n            im = mpf_add(C, D, use_prec)\n        if options.get('verbose'):\n            print('MUL: wanted', prec, 'accurate bits, got', acc)\n        if direction & 1:\n            re, im = (mpf_neg(im), re)\n        return (re, im, acc, acc)",
    ".sympy.core.expr.py@@Expr.as_coeff_Add": "def as_coeff_Add(self, rational=False):\n    return (S.Zero, self)",
    ".sympy.core.numbers.py@@Float._eval_is_infinite": "def _eval_is_infinite(self):\n    if self._mpf_ in (_mpf_inf, _mpf_ninf):\n        return True\n    return False",
    ".sympy.core.evalf.py@@evalf_pow": "def evalf_pow(v, prec, options):\n    target_prec = prec\n    base, exp = v.args\n    if exp.is_Integer:\n        p = exp.p\n        if not p:\n            return (fone, None, prec, None)\n        prec += int(math.log(abs(p), 2))\n        re, im, re_acc, im_acc = evalf(base, prec + 5, options)\n        if re and (not im):\n            return (mpf_pow_int(re, p, target_prec), None, target_prec, None)\n        if im and (not re):\n            z = mpf_pow_int(im, p, target_prec)\n            case = p % 4\n            if case == 0:\n                return (z, None, target_prec, None)\n            if case == 1:\n                return (None, z, None, target_prec)\n            if case == 2:\n                return (mpf_neg(z), None, target_prec, None)\n            if case == 3:\n                return (None, mpf_neg(z), None, target_prec)\n        if not re:\n            return (None, None, None, None)\n        re, im = libmp.mpc_pow_int((re, im), p, prec)\n        return finalize_complex(re, im, target_prec)\n    if exp is S.Half:\n        xre, xim, _, _ = evalf(base, prec + 5, options)\n        if xim:\n            re, im = libmp.mpc_sqrt((xre or fzero, xim), prec)\n            return finalize_complex(re, im, prec)\n        if not xre:\n            return (None, None, None, None)\n        if mpf_lt(xre, fzero):\n            return (None, mpf_sqrt(mpf_neg(xre), prec), None, prec)\n        return (mpf_sqrt(xre, prec), None, prec, None)\n    prec += 10\n    yre, yim, _, _ = evalf(exp, prec, options)\n    if not (yre or yim):\n        return (fone, None, prec, None)\n    ysize = fastlog(yre)\n    if ysize > 5:\n        prec += ysize\n        yre, yim, _, _ = evalf(exp, prec, options)\n    if base is S.Exp1:\n        if yim:\n            re, im = libmp.mpc_exp((yre or fzero, yim), prec)\n            return finalize_complex(re, im, target_prec)\n        return (mpf_exp(yre, target_prec), None, target_prec, None)\n    xre, xim, _, _ = evalf(base, prec + 5, options)\n    if not (xre or xim):\n        return (None, None, None, None)\n    if yim:\n        re, im = libmp.mpc_pow((xre or fzero, xim or fzero), (yre or fzero, yim), target_prec)\n        return finalize_complex(re, im, target_prec)\n    if xim:\n        re, im = libmp.mpc_pow_mpf((xre or fzero, xim), yre, target_prec)\n        return finalize_complex(re, im, target_prec)\n    elif mpf_lt(xre, fzero):\n        re, im = libmp.mpc_pow_mpf((xre, fzero), yre, target_prec)\n        return finalize_complex(re, im, target_prec)\n    else:\n        return (mpf_pow(xre, yre, target_prec), None, target_prec, None)",
    ".sympy.core.numbers.py@@Rational.as_coeff_Add": "def as_coeff_Add(self, rational=False):\n    return (self, S.Zero)",
    ".sympy.core.evalf.py@@bitcount": "def bitcount(n):\n    return mpmath_bitcount(abs(int(n)))",
    ".sympy.core.evalf.py@@add_terms": "def add_terms(terms, prec, target_prec):\n    terms = [t for t in terms if not iszero(t)]\n    if not terms:\n        return (None, None)\n    elif len(terms) == 1:\n        return terms[0]\n    special = []\n    from sympy.core.numbers import Float\n    for t in terms:\n        arg = Float._new(t[0], 1)\n        if arg is S.NaN or arg.is_infinite:\n            special.append(arg)\n    if special:\n        from sympy.core.add import Add\n        rv = evalf(Add(*special), prec + 4, {})\n        return (rv[0], rv[2])\n    working_prec = 2 * prec\n    sum_man, sum_exp, absolute_error = (0, 0, MINUS_INF)\n    for x, accuracy in terms:\n        sign, man, exp, bc = x\n        if sign:\n            man = -man\n        absolute_error = max(absolute_error, bc + exp - accuracy)\n        delta = exp - sum_exp\n        if exp >= sum_exp:\n            if delta > working_prec and (not sum_man or delta - bitcount(abs(sum_man)) > working_prec):\n                sum_man = man\n                sum_exp = exp\n            else:\n                sum_man += man << delta\n        else:\n            delta = -delta\n            if delta - bc > working_prec:\n                if not sum_man:\n                    sum_man, sum_exp = (man, exp)\n            else:\n                sum_man = (sum_man << delta) + man\n                sum_exp = exp\n    if not sum_man:\n        return scaled_zero(absolute_error)\n    if sum_man < 0:\n        sum_sign = 1\n        sum_man = -sum_man\n    else:\n        sum_sign = 0\n    sum_bc = bitcount(sum_man)\n    sum_accuracy = sum_exp + sum_bc - absolute_error\n    r = (normalize(sum_sign, sum_man, sum_exp, sum_bc, target_prec, rnd), sum_accuracy)\n    return r",
    ".sympy.core.evalf.py@@iszero": "def iszero(mpf, scaled=False):\n    if not scaled:\n        return not mpf or (not mpf[1] and (not mpf[-1]))\n    return mpf and type(mpf[0]) is list and (mpf[1] == mpf[-1] == 1)",
    ".sympy.core.evalf.py@@complex_accuracy": "def complex_accuracy(result):\n    re, im, re_acc, im_acc = result\n    if not im:\n        if not re:\n            return INF\n        return re_acc\n    if not re:\n        return im_acc\n    re_size = fastlog(re)\n    im_size = fastlog(im)\n    absolute_error = max(re_size - re_acc, im_size - im_acc)\n    relative_error = absolute_error - max(re_size, im_size)\n    return -relative_error",
    ".sympy.core.numbers.py@@Float.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s > %s' % (self, other))\n    if other.is_NumberSymbol:\n        return other.__lt__(self)\n    if other.is_Rational and (not other.is_Integer):\n        self *= other.q\n        other = _sympify(other.p)\n    elif other.is_comparable:\n        other = other.evalf()\n    if other.is_Number and other is not S.NaN:\n        return _sympify(bool(mlib.mpf_gt(self._mpf_, other._as_mpf_val(self._prec))))\n    return Expr.__gt__(self, other)",
    ".sympy.core.basic.py@@Basic.is_comparable": "def is_comparable(self):\n    is_real = self.is_real\n    if is_real is False:\n        return False\n    if not self.is_number:\n        return False\n    n, i = [p.evalf(2) if not p.is_Number else p for p in self.as_real_imag()]\n    if not (i.is_Number and n.is_Number):\n        return False\n    if i:\n        return False\n    else:\n        return n._prec != 1",
    ".sympy.core.numbers.py@@Float.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    if other.is_NumberSymbol:\n        return other.__gt__(self)\n    if other.is_Rational and (not other.is_Integer):\n        self *= other.q\n        other = _sympify(other.p)\n    elif other.is_comparable:\n        other = other.evalf()\n    if other.is_Number and other is not S.NaN:\n        return _sympify(bool(mlib.mpf_lt(self._mpf_, other._as_mpf_val(self._prec))))\n    return Expr.__lt__(self, other)",
    ".sympy.geometry.line.py@@Line2D.coefficients": "def coefficients(self):\n    p1, p2 = self.points\n    if p1.x == p2.x:\n        return (S.One, S.Zero, -p1.x)\n    elif p1.y == p2.y:\n        return (S.Zero, S.One, -p1.y)\n    return tuple([simplify(i) for i in (self.p1.y - self.p2.y, self.p2.x - self.p1.x, self.p1.x * self.p2.y - self.p1.y * self.p2.x)])",
    ".sympy.core.numbers.py@@Number.__mul__": "def __mul__(self, other):\n    if isinstance(other, Number) and global_evaluate[0]:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.Infinity\n            else:\n                return S.NegativeInfinity\n        elif other is S.NegativeInfinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.NegativeInfinity\n            else:\n                return S.Infinity\n    elif isinstance(other, Tuple):\n        return NotImplemented\n    return AtomicExpr.__mul__(self, other)",
    ".sympy.core.mul.py@@Mul.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy import Abs, expand_mul, im, re\n    other = []\n    coeffr = []\n    coeffi = []\n    addterms = S.One\n    for a in self.args:\n        r, i = a.as_real_imag()\n        if i.is_zero:\n            coeffr.append(r)\n        elif r.is_zero:\n            coeffi.append(i * S.ImaginaryUnit)\n        elif a.is_commutative:\n            for i, x in enumerate(other):\n                if x == a.conjugate():\n                    coeffr.append(Abs(x) ** 2)\n                    del other[i]\n                    break\n            else:\n                if a.is_Add:\n                    addterms *= a\n                else:\n                    other.append(a)\n        else:\n            other.append(a)\n    m = self.func(*other)\n    if hints.get('ignore') == m:\n        return\n    if len(coeffi) % 2:\n        imco = im(coeffi.pop(0))\n    else:\n        imco = S.Zero\n    reco = self.func(*coeffr + coeffi)\n    r, i = (reco * re(m), reco * im(m))\n    if addterms == 1:\n        if m == 1:\n            if imco is S.Zero:\n                return (reco, S.Zero)\n            else:\n                return (S.Zero, reco * imco)\n        if imco is S.Zero:\n            return (r, i)\n        return (-imco * i, imco * r)\n    addre, addim = expand_mul(addterms, deep=False).as_real_imag()\n    if imco is S.Zero:\n        return (r * addre - i * addim, i * addre + r * addim)\n    else:\n        r, i = (-imco * i, imco * r)\n        return (r * addre - i * addim, r * addim + i * addre)",
    ".sympy.core.mul.py@@Mul._eval_is_negative": "def _eval_is_negative(self):\n    if self.args[0] == -1:\n        return (-self).is_positive\n    return self._eval_pos_neg(-1)",
    ".sympy.core.mul.py@@Mul._eval_is_composite": "def _eval_is_composite(self):\n    if self.is_integer and self.is_positive:\n        '\\n        Here we count the number of arguments that have a minimum value\\n        greater than two.\\n        If there are more than one of such a symbol then the result is composite.\\n        Else, the result cannot be determined.\\n        '\n        number_of_args = 0\n        for arg in self.args:\n            if (arg - 1).is_positive:\n                number_of_args += 1\n        if number_of_args > 1:\n            return True",
    ".sympy.core.mul.py@@Mul._eval_is_integer": "def _eval_is_integer(self):\n    is_rational = self.is_rational\n    if is_rational:\n        n, d = self.as_numer_denom()\n        if d is S.One:\n            return True\n        elif d is S(2):\n            return n.is_even\n    elif is_rational is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all(((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others)):\n                return True\n            return\n        if a is None:\n            return\n    return False",
    ".sympy.core.mul.py@@Mul._eval_is_even": "def _eval_is_even(self):\n    is_integer = self.is_integer\n    if is_integer:\n        return fuzzy_not(self.is_odd)\n    elif is_integer is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_algebraic": "def _eval_is_algebraic(self):\n    r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        return self.is_zero",
    ".sympy.core.mul.py@@Mul._eval_is_odd": "def _eval_is_odd(self):\n    is_integer = self.is_integer\n    if is_integer:\n        r, acc = (True, 1)\n        for t in self.args:\n            if not t.is_integer:\n                return None\n            elif t.is_even:\n                r = False\n            elif t.is_integer:\n                if r is False:\n                    pass\n                elif acc != 1 and (acc + t).is_odd:\n                    r = False\n                elif t.is_odd is None:\n                    r = None\n            acc = t\n        return r\n    elif is_integer is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_positive": "def _eval_is_positive(self):\n    return self._eval_pos_neg(1)",
    ".sympy.core.mul.py@@Mul._eval_pos_neg": "def _eval_pos_neg(self, sign):\n    saw_NON = saw_NOT = False\n    for t in self.args:\n        if t.is_positive:\n            continue\n        elif t.is_negative:\n            sign = -sign\n        elif t.is_zero:\n            if all((a.is_finite for a in self.args)):\n                return False\n            return\n        elif t.is_nonpositive:\n            sign = -sign\n            saw_NON = True\n        elif t.is_nonnegative:\n            saw_NON = True\n        elif t.is_positive is False:\n            sign = -sign\n            if saw_NOT:\n                return\n            saw_NOT = True\n        elif t.is_negative is False:\n            if saw_NOT:\n                return\n            saw_NOT = True\n        else:\n            return\n    if sign == 1 and saw_NON is False and (saw_NOT is False):\n        return True\n    if sign < 0:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_infinite": "def _eval_is_infinite(self):\n    if any((a.is_infinite for a in self.args)):\n        if any((a.is_zero for a in self.args)):\n            return S.NaN.is_infinite\n        if any((a.is_zero is None for a in self.args)):\n            return None\n        return True",
    ".sympy.core.mul.py@@Mul._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    return all((term._eval_is_polynomial(syms) for term in self.args))",
    ".sympy.core.mul.py@@Mul.as_numer_denom": "def as_numer_denom(self):\n    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n    return (self.func(*numers), self.func(*denoms))",
    ".sympy.core.numbers.py@@Number.__add__": "def __add__(self, other):\n    if isinstance(other, Number) and global_evaluate[0]:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            return S.Infinity\n        elif other is S.NegativeInfinity:\n            return S.NegativeInfinity\n    return AtomicExpr.__add__(self, other)",
    ".sympy.polys.polyoptions.py@@Composite.default": "def default(cls):\n    return None",
    ".sympy.polys.constructor.py@@_construct_composite": "def _construct_composite(coeffs, opt):\n    numers, denoms = ([], [])\n    for coeff in coeffs:\n        numer, denom = coeff.as_numer_denom()\n        numers.append(numer)\n        denoms.append(denom)\n    polys, gens = parallel_dict_from_basic(numers + denoms)\n    if not gens:\n        return None\n    if opt.composite is None:\n        if any((gen.is_number and gen.is_algebraic for gen in gens)):\n            return None\n        all_symbols = set([])\n        for gen in gens:\n            symbols = gen.free_symbols\n            if all_symbols & symbols:\n                return None\n            else:\n                all_symbols |= symbols\n    n = len(gens)\n    k = len(polys) // 2\n    numers = polys[:k]\n    denoms = polys[k:]\n    if opt.field:\n        fractions = True\n    else:\n        fractions, zeros = (False, (0,) * n)\n        for denom in denoms:\n            if len(denom) > 1 or zeros not in denom:\n                fractions = True\n                break\n    coeffs = set([])\n    if not fractions:\n        for numer, denom in zip(numers, denoms):\n            denom = denom[zeros]\n            for monom, coeff in numer.items():\n                coeff /= denom\n                coeffs.add(coeff)\n                numer[monom] = coeff\n    else:\n        for numer, denom in zip(numers, denoms):\n            coeffs.update(list(numer.values()))\n            coeffs.update(list(denom.values()))\n    rationals, reals = (False, False)\n    for coeff in coeffs:\n        if coeff.is_Rational:\n            if not coeff.is_Integer:\n                rationals = True\n        elif coeff.is_Float:\n            reals = True\n            break\n    if reals:\n        max_prec = max([c._prec for c in coeffs])\n        ground = RealField(prec=max_prec)\n    elif rationals:\n        ground = QQ\n    else:\n        ground = ZZ\n    result = []\n    if not fractions:\n        domain = ground.poly_ring(*gens)\n        for numer in numers:\n            for monom, coeff in numer.items():\n                numer[monom] = ground.from_sympy(coeff)\n            result.append(domain(numer))\n    else:\n        domain = ground.frac_field(*gens)\n        for numer, denom in zip(numers, denoms):\n            for monom, coeff in numer.items():\n                numer[monom] = ground.from_sympy(coeff)\n            for monom, coeff in denom.items():\n                denom[monom] = ground.from_sympy(coeff)\n            result.append(domain((numer, denom)))\n    return (domain, result)",
    ".sympy.polys.polyutils.py@@parallel_dict_from_expr": "def parallel_dict_from_expr(exprs, **args):\n    reps, opt = _parallel_dict_from_expr(exprs, build_options(args))\n    return (reps, opt.gens)",
    ".sympy.polys.polyutils.py@@_parallel_dict_from_expr": "def _parallel_dict_from_expr(exprs, opt):\n    if opt.expand is not False:\n        exprs = [expr.expand() for expr in exprs]\n    if any((expr.is_commutative is False for expr in exprs)):\n        raise PolynomialError('non-commutative expressions are not supported')\n    if opt.gens:\n        reps, gens = _parallel_dict_from_expr_if_gens(exprs, opt)\n    else:\n        reps, gens = _parallel_dict_from_expr_no_gens(exprs, opt)\n    return (reps, opt.clone({'gens': gens}))",
    ".sympy.polys.polyutils.py@@_parallel_dict_from_expr_no_gens": "def _parallel_dict_from_expr_no_gens(exprs, opt):\n    if opt.domain is not None:\n\n        def _is_coeff(factor):\n            return factor in opt.domain\n    elif opt.extension is True:\n\n        def _is_coeff(factor):\n            return factor.is_algebraic\n    elif opt.greedy is not False:\n\n        def _is_coeff(factor):\n            return False\n    else:\n\n        def _is_coeff(factor):\n            return factor.is_number\n    gens, reprs = (set([]), [])\n    for expr in exprs:\n        terms = []\n        if expr.is_Equality:\n            expr = expr.lhs - expr.rhs\n        for term in Add.make_args(expr):\n            coeff, elements = ([], {})\n            for factor in Mul.make_args(term):\n                if not _not_a_coeff(factor) and (factor.is_Number or _is_coeff(factor)):\n                    coeff.append(factor)\n                else:\n                    if opt.series is False:\n                        base, exp = decompose_power(factor)\n                        if exp < 0:\n                            exp, base = (-exp, Pow(base, -S.One))\n                    else:\n                        base, exp = decompose_power_rat(factor)\n                    elements[base] = elements.setdefault(base, 0) + exp\n                    gens.add(base)\n            terms.append((coeff, elements))\n        reprs.append(terms)\n    gens = _sort_gens(gens, opt=opt)\n    k, indices = (len(gens), {})\n    for i, g in enumerate(gens):\n        indices[g] = i\n    polys = []\n    for terms in reprs:\n        poly = {}\n        for coeff, term in terms:\n            monom = [0] * k\n            for base, exp in term.items():\n                monom[indices[base]] = exp\n            monom = tuple(monom)\n            if monom in poly:\n                poly[monom] += Mul(*coeff)\n            else:\n                poly[monom] = Mul(*coeff)\n        polys.append(poly)\n    return (polys, tuple(gens))",
    ".sympy.polys.polyutils.py@@_is_coeff": "def _is_coeff(factor):\n    return factor.is_number",
    ".sympy.polys.polyutils.py@@_sort_gens": "def _sort_gens(gens, **args):\n    opt = build_options(args)\n    gens_order, wrt = ({}, None)\n    if opt is not None:\n        gens_order, wrt = ({}, opt.wrt)\n        for i, gen in enumerate(opt.sort):\n            gens_order[gen] = i + 1\n\n    def order_key(gen):\n        gen = str(gen)\n        if wrt is not None:\n            try:\n                return (-len(wrt) + wrt.index(gen), gen, 0)\n            except ValueError:\n                pass\n        name, index = _re_gen.match(gen).groups()\n        if index:\n            index = int(index)\n        else:\n            index = 0\n        try:\n            return (gens_order[name], name, index)\n        except KeyError:\n            pass\n        try:\n            return (_gens_order[name], name, index)\n        except KeyError:\n            pass\n        return (_max_order, name, index)\n    try:\n        gens = sorted(gens, key=order_key)\n    except TypeError:\n        pass\n    return tuple(gens)",
    ".sympy.polys.polyoptions.py@@Sort.default": "def default(cls):\n    return []",
    ".sympy.polys.polyutils.py@@order_key": "def order_key(gen):\n    gen = str(gen)\n    if wrt is not None:\n        try:\n            return (-len(wrt) + wrt.index(gen), gen, 0)\n        except ValueError:\n            pass\n    name, index = _re_gen.match(gen).groups()\n    if index:\n        index = int(index)\n    else:\n        index = 0\n    try:\n        return (gens_order[name], name, index)\n    except KeyError:\n        pass\n    try:\n        return (_gens_order[name], name, index)\n    except KeyError:\n        pass\n    return (_max_order, name, index)",
    ".sympy.polys.domains.domain.py@@Domain.poly_ring": "def poly_ring(self, *symbols, **kwargs):\n    from sympy.polys.domains.polynomialring import PolynomialRing\n    return PolynomialRing(self, symbols, kwargs.get('order', lex))",
    ".sympy.polys.domains.polynomialring.py@@PolynomialRing.__init__": "def __init__(self, domain_or_ring, symbols=None, order=None):\n    from sympy.polys.rings import PolyRing\n    if isinstance(domain_or_ring, PolyRing) and symbols is None and (order is None):\n        ring = domain_or_ring\n    else:\n        ring = PolyRing(symbols, domain_or_ring, order)\n    self.ring = ring\n    self.dtype = ring.dtype\n    self.gens = ring.gens\n    self.ngens = ring.ngens\n    self.symbols = ring.symbols\n    self.domain = ring.domain\n    if symbols:\n        if ring.domain.is_Field and ring.domain.is_Exact and (len(symbols) == 1):\n            self.is_PID = True\n    self.dom = self.domain",
    ".sympy.polys.domains.domain.py@@Domain.__call__": "def __call__(self, *args):\n    return self.new(*args)",
    ".sympy.polys.domains.polynomialring.py@@PolynomialRing.new": "def new(self, element):\n    return self.ring.ring_new(element)",
    ".sympy.polys.rings.py@@PolyRing.ring_new": "def ring_new(self, element):\n    if isinstance(element, PolyElement):\n        if self == element.ring:\n            return element\n        elif isinstance(self.domain, PolynomialRing) and self.domain.ring == element.ring:\n            return self.ground_new(element)\n        else:\n            raise NotImplementedError('conversion')\n    elif isinstance(element, string_types):\n        raise NotImplementedError('parsing')\n    elif isinstance(element, dict):\n        return self.from_dict(element)\n    elif isinstance(element, list):\n        try:\n            return self.from_terms(element)\n        except ValueError:\n            return self.from_list(element)\n    elif isinstance(element, Expr):\n        return self.from_expr(element)\n    else:\n        return self.ground_new(element)",
    ".sympy.polys.domains.polynomialring.py@@PolynomialRing.zero": "def zero(self):\n    return self.ring.zero",
    ".sympy.polys.domains.polynomialring.py@@PolynomialRing.__hash__": "def __hash__(self):\n    return hash((self.__class__.__name__, self.dtype.ring, self.domain, self.symbols))",
    ".sympy.polys.domains.polynomialring.py@@PolynomialRing.__eq__": "def __eq__(self, other):\n    return isinstance(other, PolynomialRing) and (self.dtype.ring, self.domain, self.symbols) == (other.dtype.ring, other.domain, other.symbols)",
    ".sympy.polys.domains.polynomialring.py@@PolynomialRing.gcd": "def gcd(self, a, b):\n    return a.gcd(b)",
    ".sympy.polys.rings.py@@PolyElement.gcd": "def gcd(f, g):\n    return f.cofactors(g)[0]",
    ".sympy.polys.rings.py@@PolyElement.cofactors": "def cofactors(f, g):\n    if not f and (not g):\n        zero = f.ring.zero\n        return (zero, zero, zero)\n    elif not f:\n        h, cff, cfg = f._gcd_zero(g)\n        return (h, cff, cfg)\n    elif not g:\n        h, cfg, cff = g._gcd_zero(f)\n        return (h, cff, cfg)\n    elif len(f) == 1:\n        h, cff, cfg = f._gcd_monom(g)\n        return (h, cff, cfg)\n    elif len(g) == 1:\n        h, cfg, cff = g._gcd_monom(f)\n        return (h, cff, cfg)\n    J, (f, g) = f.deflate(g)\n    h, cff, cfg = f._gcd(g)\n    return (h.inflate(J), cff.inflate(J), cfg.inflate(J))",
    ".sympy.polys.rings.py@@PolyElement._gcd_zero": "def _gcd_zero(f, g):\n    one, zero = (f.ring.one, f.ring.zero)\n    if g.is_nonnegative:\n        return (g, zero, one)\n    else:\n        return (-g, zero, -one)",
    ".sympy.polys.rings.py@@PolyRing.one": "def one(self):\n    return self.dtype(self._one)",
    ".sympy.polys.rings.py@@PolyElement.is_nonnegative": "def is_nonnegative(self):\n    return self.ring.domain.is_nonnegative(self.LC)",
    ".sympy.polys.domains.domain.py@@Domain.is_nonnegative": "def is_nonnegative(self, a):\n    return a >= 0",
    ".sympy.polys.domains.polynomialring.py@@PolynomialRing.one": "def one(self):\n    return self.ring.one",
    ".sympy.polys.domains.polynomialring.py@@PolynomialRing.to_sympy": "def to_sympy(self, a):\n    return a.as_expr()",
    ".sympy.polys.rings.py@@PolyElement.as_expr": "def as_expr(self, *symbols):\n    if symbols and len(symbols) != self.ring.ngens:\n        raise ValueError('not enough symbols, expected %s got %s' % (self.ring.ngens, len(symbols)))\n    else:\n        symbols = self.ring.symbols\n    return expr_from_dict(self.as_expr_dict(), *symbols)",
    ".sympy.polys.rings.py@@PolyElement.as_expr_dict": "def as_expr_dict(self):\n    to_sympy = self.ring.domain.to_sympy\n    return {monom: to_sympy(coeff) for monom, coeff in self.iterterms()}",
    ".sympy.polys.polyclasses.py@@DMP.coeffs": "def coeffs(f, order=None):\n    return [c for _, c in dmp_list_terms(f.rep, f.lev, f.dom, order=order)]",
    ".sympy.polys.rings.py@@PolyElement.is_term": "def is_term(self):\n    return len(self) <= 1",
    ".sympy.polys.domains.polynomialring.py@@PolynomialRing.get_field": "def get_field(self):\n    return self.ring.to_field().to_domain()",
    ".sympy.polys.rings.py@@PolyRing.to_field": "def to_field(self):\n    from sympy.polys.fields import FracField\n    return FracField(self.symbols, self.domain, self.order)",
    ".sympy.polys.fields.py@@FracField.__new__": "def __new__(cls, symbols, domain, order=lex):\n    from sympy.polys.rings import PolyRing\n    ring = PolyRing(symbols, domain, order)\n    symbols = ring.symbols\n    ngens = ring.ngens\n    domain = ring.domain\n    order = ring.order\n    _hash_tuple = (cls.__name__, symbols, ngens, domain, order)\n    obj = _field_cache.get(_hash_tuple)\n    if obj is None:\n        obj = object.__new__(cls)\n        obj._hash_tuple = _hash_tuple\n        obj._hash = hash(_hash_tuple)\n        obj.ring = ring\n        obj.dtype = type('FracElement', (FracElement,), {'field': obj})\n        obj.symbols = symbols\n        obj.ngens = ngens\n        obj.domain = domain\n        obj.order = order\n        obj.zero = obj.dtype(ring.zero)\n        obj.one = obj.dtype(ring.one)\n        obj.gens = obj._gens()\n        for symbol, generator in zip(obj.symbols, obj.gens):\n            if isinstance(symbol, Symbol):\n                name = symbol.name\n                if not hasattr(obj, name):\n                    setattr(obj, name, generator)\n        _field_cache[_hash_tuple] = obj\n    return obj",
    ".sympy.polys.fields.py@@FracElement.__init__": "def __init__(self, numer, denom=None):\n    if denom is None:\n        denom = self.field.ring.one\n    elif not denom:\n        raise ZeroDivisionError('zero denominator')\n    self.numer = numer\n    self.denom = denom",
    ".sympy.polys.fields.py@@FracField._gens": "def _gens(self):\n    return tuple([self.dtype(gen) for gen in self.ring.gens])",
    ".sympy.polys.fields.py@@FracField.to_domain": "def to_domain(self):\n    return FractionField(self)",
    ".sympy.polys.domains.fractionfield.py@@FractionField.__init__": "def __init__(self, domain_or_field, symbols=None, order=None):\n    from sympy.polys.fields import FracField\n    if isinstance(domain_or_field, FracField) and symbols is None and (order is None):\n        field = domain_or_field\n    else:\n        field = FracField(symbols, domain_or_field, order)\n    self.field = field\n    self.dtype = field.dtype\n    self.gens = field.gens\n    self.ngens = field.ngens\n    self.symbols = field.symbols\n    self.domain = field.domain\n    self.dom = self.domain",
    ".sympy.polys.domains.fractionfield.py@@FractionField.from_PolynomialRing": "def from_PolynomialRing(K1, a, K0):\n    try:\n        return K1.new(a)\n    except (CoercionFailed, GeneratorsError):\n        return None",
    ".sympy.polys.domains.fractionfield.py@@FractionField.new": "def new(self, element):\n    return self.field.field_new(element)",
    ".sympy.polys.fields.py@@FracField.field_new": "def field_new(self, element):\n    if isinstance(element, FracElement):\n        if self == element.field:\n            return element\n        else:\n            raise NotImplementedError('conversion')\n    elif isinstance(element, PolyElement):\n        denom, numer = element.clear_denoms()\n        numer = numer.set_ring(self.ring)\n        denom = self.ring.ground_new(denom)\n        return self.raw_new(numer, denom)\n    elif isinstance(element, tuple) and len(element) == 2:\n        numer, denom = list(map(self.ring.ring_new, element))\n        return self.new(numer, denom)\n    elif isinstance(element, string_types):\n        raise NotImplementedError('parsing')\n    elif isinstance(element, Expr):\n        return self.from_expr(element)\n    else:\n        return self.ground_new(element)",
    ".sympy.polys.rings.py@@PolyRing.ground_new": "def ground_new(self, coeff):\n    return self.term_new(self.zero_monom, coeff)",
    ".sympy.polys.rings.py@@PolyRing.term_new": "def term_new(self, monom, coeff):\n    coeff = self.domain_new(coeff)\n    poly = self.zero\n    if coeff:\n        poly[monom] = coeff\n    return poly",
    ".sympy.polys.fields.py@@FracField.raw_new": "def raw_new(self, numer, denom=None):\n    return self.dtype(numer, denom)",
    ".sympy.polys.fields.py@@FracElement.__nonzero__": "def __nonzero__(f):\n    return bool(f.numer)",
    ".sympy.polys.domains.fractionfield.py@@FractionField.to_sympy": "def to_sympy(self, a):\n    return a.as_expr()",
    ".sympy.polys.fields.py@@FracElement.as_expr": "def as_expr(self, *symbols):\n    return self.numer.as_expr(*symbols) / self.denom.as_expr(*symbols)",
    ".sympy.core.expr.py@@Expr.__div__": "def __div__(self, other):\n    return Mul(self, Pow(other, S.NegativeOne))",
    ".sympy.polys.polytools.py@@factor": "def factor(f, *gens, **args):\n    f = sympify(f)\n    if args.pop('deep', False):\n        partials = {}\n        muladd = f.atoms(Mul, Add)\n        for p in muladd:\n            fac = factor(p, *gens, **args)\n            if (fac.is_Mul or fac.is_Pow) and fac != p:\n                partials[p] = fac\n        return f.xreplace(partials)\n    try:\n        return _generic_factor(f, gens, args, method='factor')\n    except PolynomialError as msg:\n        if not f.is_commutative:\n            from sympy.core.exprtools import factor_nc\n            return factor_nc(f)\n        else:\n            raise PolynomialError(msg)",
    ".sympy.polys.polytools.py@@_generic_factor": "def _generic_factor(expr, gens, args, method):\n    options.allowed_flags(args, [])\n    opt = options.build_options(gens, args)\n    return _symbolic_factor(sympify(expr), opt, method)",
    ".sympy.polys.polytools.py@@_symbolic_factor": "def _symbolic_factor(expr, opt, method):\n    if isinstance(expr, Expr) and (not expr.is_Relational):\n        if hasattr(expr, '_eval_factor'):\n            return expr._eval_factor()\n        coeff, factors = _symbolic_factor_list(together(expr), opt, method)\n        return _keep_coeff(coeff, _factors_product(factors))\n    elif hasattr(expr, 'args'):\n        return expr.func(*[_symbolic_factor(arg, opt, method) for arg in expr.args])\n    elif hasattr(expr, '__iter__'):\n        return expr.__class__([_symbolic_factor(arg, opt, method) for arg in expr])\n    else:\n        return expr",
    ".sympy.polys.rationaltools.py@@together": "def together(expr, deep=False):\n\n    def _together(expr):\n        if isinstance(expr, Basic):\n            if expr.is_Atom or (expr.is_Function and (not deep)):\n                return expr\n            elif expr.is_Add:\n                return gcd_terms(list(map(_together, Add.make_args(expr))))\n            elif expr.is_Pow:\n                base = _together(expr.base)\n                if deep:\n                    exp = _together(expr.exp)\n                else:\n                    exp = expr.exp\n                return expr.__class__(base, exp)\n            else:\n                return expr.__class__(*[_together(arg) for arg in expr.args])\n        elif iterable(expr):\n            return expr.__class__([_together(ex) for ex in expr])\n        return expr\n    return _together(sympify(expr))",
    ".sympy.polys.rationaltools.py@@_together": "def _together(expr):\n    if isinstance(expr, Basic):\n        if expr.is_Atom or (expr.is_Function and (not deep)):\n            return expr\n        elif expr.is_Add:\n            return gcd_terms(list(map(_together, Add.make_args(expr))))\n        elif expr.is_Pow:\n            base = _together(expr.base)\n            if deep:\n                exp = _together(expr.exp)\n            else:\n                exp = expr.exp\n            return expr.__class__(base, exp)\n        else:\n            return expr.__class__(*[_together(arg) for arg in expr.args])\n    elif iterable(expr):\n        return expr.__class__([_together(ex) for ex in expr])\n    return expr",
    ".sympy.core.exprtools.py@@gcd_terms": "def gcd_terms(terms, isprimitive=False, clear=True, fraction=True):\n\n    def mask(terms):\n        args = [(a, []) if a.is_commutative else a.args_cnc() for a in terms]\n        reps = []\n        for i, (c, nc) in enumerate(args):\n            if nc:\n                nc = Mul._from_args(nc)\n                d = Dummy()\n                reps.append((d, nc))\n                c.append(d)\n                args[i] = Mul._from_args(c)\n            else:\n                args[i] = c\n        return (args, dict(reps))\n    isadd = isinstance(terms, Add)\n    addlike = isadd or (not isinstance(terms, Basic) and is_sequence(terms, include=set) and (not isinstance(terms, Dict)))\n    if addlike:\n        if isadd:\n            terms = list(terms.args)\n        else:\n            terms = sympify(terms)\n        terms, reps = mask(terms)\n        cont, numer, denom = _gcd_terms(terms, isprimitive, fraction)\n        numer = numer.xreplace(reps)\n        coeff, factors = cont.as_coeff_Mul()\n        if not clear:\n            c, _coeff = coeff.as_coeff_Mul()\n            if not c.is_Integer and (not clear) and numer.is_Add:\n                n, d = c.as_numer_denom()\n                _numer = numer / d\n                if any((a.as_coeff_Mul()[0].is_Integer for a in _numer.args)):\n                    numer = _numer\n                    coeff = n * _coeff\n        return _keep_coeff(coeff, factors * numer / denom, clear=clear)\n    if not isinstance(terms, Basic):\n        return terms\n    if terms.is_Atom:\n        return terms\n    if terms.is_Mul:\n        c, args = terms.as_coeff_mul()\n        return _keep_coeff(c, Mul(*[gcd_terms(i, isprimitive, clear, fraction) for i in args]), clear=clear)\n\n    def handle(a):\n        if not isinstance(a, Expr):\n            if isinstance(a, Basic):\n                return a.func(*[handle(i) for i in a.args])\n            return type(a)([handle(i) for i in a])\n        return gcd_terms(a, isprimitive, clear, fraction)\n    if isinstance(terms, Dict):\n        return Dict(*[(k, handle(v)) for k, v in terms.args])\n    return terms.func(*[handle(i) for i in terms.args])",
    ".sympy.core.exprtools.py@@mask": "def mask(terms):\n    args = [(a, []) if a.is_commutative else a.args_cnc() for a in terms]\n    reps = []\n    for i, (c, nc) in enumerate(args):\n        if nc:\n            nc = Mul._from_args(nc)\n            d = Dummy()\n            reps.append((d, nc))\n            c.append(d)\n            args[i] = Mul._from_args(c)\n        else:\n            args[i] = c\n    return (args, dict(reps))",
    ".sympy.core.exprtools.py@@_gcd_terms": "def _gcd_terms(terms, isprimitive=False, fraction=True):\n    if isinstance(terms, Basic) and (not isinstance(terms, Tuple)):\n        terms = Add.make_args(terms)\n    terms = list(map(Term, [t for t in terms if t]))\n    if len(terms) == 0:\n        return (S.Zero, S.Zero, S.One)\n    if len(terms) == 1:\n        cont = terms[0].coeff\n        numer = terms[0].numer.as_expr()\n        denom = terms[0].denom.as_expr()\n    else:\n        cont = terms[0]\n        for term in terms[1:]:\n            cont = cont.gcd(term)\n        for i, term in enumerate(terms):\n            terms[i] = term.quo(cont)\n        if fraction:\n            denom = terms[0].denom\n            for term in terms[1:]:\n                denom = denom.lcm(term.denom)\n            numers = []\n            for term in terms:\n                numer = term.numer.mul(denom.quo(term.denom))\n                numers.append(term.coeff * numer.as_expr())\n        else:\n            numers = [t.as_expr() for t in terms]\n            denom = Term(S(1)).numer\n        cont = cont.as_expr()\n        numer = Add(*numers)\n        denom = denom.as_expr()\n    if not isprimitive and numer.is_Add:\n        _cont, numer = numer.primitive()\n        cont *= _cont\n    return (cont, numer, denom)",
    ".sympy.core.exprtools.py@@Term.__init__": "def __init__(self, term, numer=None, denom=None):\n    if numer is None and denom is None:\n        if not term.is_commutative:\n            raise NonCommutativeExpression('commutative expression expected')\n        coeff, factors = term.as_coeff_mul()\n        numer, denom = (defaultdict(int), defaultdict(int))\n        for factor in factors:\n            base, exp = decompose_power(factor)\n            if base.is_Add:\n                cont, base = base.primitive()\n                coeff *= cont ** exp\n            if exp > 0:\n                numer[base] += exp\n            else:\n                denom[base] += -exp\n        numer = Factors(numer)\n        denom = Factors(denom)\n    else:\n        coeff = term\n        if numer is None:\n            numer = Factors()\n        if denom is None:\n            denom = Factors()\n    self.coeff = coeff\n    self.numer = numer\n    self.denom = denom",
    ".sympy.core.numbers.py@@Number.as_coeff_mul": "def as_coeff_mul(self, *deps, **kwargs):\n    if self.is_Rational or not kwargs.pop('rational', True):\n        return (self, tuple())\n    elif self.is_negative:\n        return (S.NegativeOne, (-self,))\n    return (S.One, (self,))",
    ".sympy.core.exprtools.py@@Factors.__init__": "def __init__(self, factors=None):\n    if isinstance(factors, (SYMPY_INTS, float)):\n        factors = S(factors)\n    if isinstance(factors, Factors):\n        factors = factors.factors.copy()\n    elif factors is None or factors is S.One:\n        factors = {}\n    elif factors is S.Zero or factors == 0:\n        factors = {S.Zero: S.One}\n    elif isinstance(factors, Number):\n        n = factors\n        factors = {}\n        if n < 0:\n            factors[S.NegativeOne] = S.One\n            n = -n\n        if n is not S.One:\n            if n.is_Float or n.is_Integer or n is S.Infinity:\n                factors[n] = S.One\n            elif n.is_Rational:\n                if n.p != 1:\n                    factors[Integer(n.p)] = S.One\n                factors[Integer(n.q)] = S.NegativeOne\n            else:\n                raise ValueError('Expected Float|Rational|Integer, not %s' % n)\n    elif isinstance(factors, Basic) and (not factors.args):\n        factors = {factors: S.One}\n    elif isinstance(factors, Expr):\n        c, nc = factors.args_cnc()\n        i = c.count(I)\n        for _ in range(i):\n            c.remove(I)\n        factors = dict(Mul._from_args(c).as_powers_dict())\n        if i:\n            factors[I] = S.One * i\n        if nc:\n            factors[Mul(*nc, evaluate=False)] = S.One\n    else:\n        factors = factors.copy()\n        handle = []\n        for k in factors:\n            if k is I or k in (-1, 1):\n                handle.append(k)\n        if handle:\n            i1 = S.One\n            for k in handle:\n                if not _isnumber(factors[k]):\n                    continue\n                i1 *= k ** factors.pop(k)\n            if i1 is not S.One:\n                for a in i1.args if i1.is_Mul else [i1]:\n                    if a is S.NegativeOne:\n                        factors[a] = S.One\n                    elif a is I:\n                        factors[I] = S.One\n                    elif a.is_Pow:\n                        if S.NegativeOne not in factors:\n                            factors[S.NegativeOne] = S.Zero\n                        factors[S.NegativeOne] += a.exp\n                    elif a == 1:\n                        factors[a] = S.One\n                    elif a == -1:\n                        factors[-a] = S.One\n                        factors[S.NegativeOne] = S.One\n                    else:\n                        raise ValueError('unexpected factor in i1: %s' % a)\n    self.factors = factors\n    try:\n        self.gens = frozenset(factors.keys())\n    except AttributeError:\n        raise TypeError('expecting Expr or dictionary')",
    ".sympy.core.expr.py@@Expr.as_coeff_mul": "def as_coeff_mul(self, *deps, **kwargs):\n    if deps:\n        if not self.has(*deps):\n            return (self, tuple())\n    return (S.One, (self,))",
    ".sympy.core.exprtools.py@@Term.gcd": "def gcd(self, other):\n    return Term(self.coeff.gcd(other.coeff), self.numer.gcd(other.numer), self.denom.gcd(other.denom))",
    ".sympy.core.numbers.py@@Rational.gcd": "def gcd(self, other):\n    if isinstance(other, Rational):\n        if other is S.Zero:\n            return other\n        return Rational(Integer(igcd(self.p, other.p)), Integer(ilcm(self.q, other.q)))\n    return Number.gcd(self, other)",
    ".sympy.core.exprtools.py@@Factors.gcd": "def gcd(self, other):\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if other.is_zero:\n            return Factors(self.factors)\n    factors = {}\n    for factor, exp in self.factors.items():\n        factor, exp = (sympify(factor), sympify(exp))\n        if factor in other.factors:\n            lt = (exp - other.factors[factor]).is_negative\n            if lt == True:\n                factors[factor] = exp\n            elif lt == False:\n                factors[factor] = other.factors[factor]\n    return Factors(factors)",
    ".sympy.core.exprtools.py@@Term.quo": "def quo(self, other):\n    return self.mul(other.inv())",
    ".sympy.core.exprtools.py@@Term.inv": "def inv(self):\n    return Term(1 / self.coeff, self.denom, self.numer)",
    ".sympy.core.expr.py@@Expr.__rdiv__": "def __rdiv__(self, other):\n    return Mul(other, Pow(self, S.NegativeOne))",
    ".sympy.core.exprtools.py@@Term.mul": "def mul(self, other):\n    coeff = self.coeff * other.coeff\n    numer = self.numer.mul(other.numer)\n    denom = self.denom.mul(other.denom)\n    numer, denom = numer.normal(denom)\n    return Term(coeff, numer, denom)",
    ".sympy.core.exprtools.py@@Factors.mul": "def mul(self, other):\n    if not isinstance(other, Factors):\n        other = Factors(other)\n    if any((f.is_zero for f in (self, other))):\n        return Factors(S.Zero)\n    factors = dict(self.factors)\n    for factor, exp in other.factors.items():\n        if factor in factors:\n            exp = factors[factor] + exp\n            if not exp:\n                del factors[factor]\n                continue\n        factors[factor] = exp\n    return Factors(factors)",
    ".sympy.core.exprtools.py@@Factors.is_zero": "def is_zero(self):\n    f = self.factors\n    return len(f) == 1 and S.Zero in f",
    ".sympy.core.exprtools.py@@Factors.normal": "def normal(self, other):\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if other.is_zero:\n            return (Factors(), Factors(S.Zero))\n        if self.is_zero:\n            return (Factors(S.Zero), Factors())\n    self_factors = dict(self.factors)\n    other_factors = dict(other.factors)\n    for factor, self_exp in self.factors.items():\n        try:\n            other_exp = other.factors[factor]\n        except KeyError:\n            continue\n        exp = self_exp - other_exp\n        if not exp:\n            del self_factors[factor]\n            del other_factors[factor]\n        elif _isnumber(exp):\n            if exp > 0:\n                self_factors[factor] = exp\n                del other_factors[factor]\n            else:\n                del self_factors[factor]\n                other_factors[factor] = -exp\n        else:\n            r = self_exp.extract_additively(other_exp)\n            if r is not None:\n                if r:\n                    self_factors[factor] = r\n                    del other_factors[factor]\n                else:\n                    del self_factors[factor]\n                    del other_factors[factor]\n            else:\n                sc, sa = self_exp.as_coeff_Add()\n                if sc:\n                    oc, oa = other_exp.as_coeff_Add()\n                    diff = sc - oc\n                    if diff > 0:\n                        self_factors[factor] -= oc\n                        other_exp = oa\n                    elif diff < 0:\n                        self_factors[factor] -= sc\n                        other_factors[factor] -= sc\n                        other_exp = oa - diff\n                    else:\n                        self_factors[factor] = sa\n                        other_exp = oa\n                if other_exp:\n                    other_factors[factor] = other_exp\n                else:\n                    del other_factors[factor]\n    return (Factors(self_factors), Factors(other_factors))",
    ".sympy.core.exprtools.py@@Factors.lcm": "def lcm(self, other):\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if any((f.is_zero for f in (self, other))):\n            return Factors(S.Zero)\n    factors = dict(self.factors)\n    for factor, exp in other.factors.items():\n        if factor in factors:\n            exp = max(exp, factors[factor])\n        factors[factor] = exp\n    return Factors(factors)",
    ".sympy.core.exprtools.py@@Factors.quo": "def quo(self, other):\n    return self.div(other)[0]",
    ".sympy.core.exprtools.py@@Factors.div": "def div(self, other):\n    quo, rem = (dict(self.factors), {})\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if other.is_zero:\n            raise ZeroDivisionError\n        if self.is_zero:\n            return (Factors(S.Zero), Factors())\n    for factor, exp in other.factors.items():\n        if factor in quo:\n            d = quo[factor] - exp\n            if _isnumber(d):\n                if d <= 0:\n                    del quo[factor]\n                if d >= 0:\n                    if d:\n                        quo[factor] = d\n                    continue\n                exp = -d\n            else:\n                r = quo[factor].extract_additively(exp)\n                if r is not None:\n                    if r:\n                        quo[factor] = r\n                    else:\n                        del quo[factor]\n                else:\n                    other_exp = exp\n                    sc, sa = quo[factor].as_coeff_Add()\n                    if sc:\n                        oc, oa = other_exp.as_coeff_Add()\n                        diff = sc - oc\n                        if diff > 0:\n                            quo[factor] -= oc\n                            other_exp = oa\n                        elif diff < 0:\n                            quo[factor] -= sc\n                            other_exp = oa - diff\n                        else:\n                            quo[factor] = sa\n                            other_exp = oa\n                    if other_exp:\n                        rem[factor] = other_exp\n                    else:\n                        assert factor not in rem\n                continue\n        rem[factor] = exp\n    return (Factors(quo), Factors(rem))",
    ".sympy.core.exprtools.py@@Factors.as_expr": "def as_expr(self):\n    args = []\n    for factor, exp in self.factors.items():\n        if exp != 1:\n            b, e = factor.as_base_exp()\n            if isinstance(exp, int):\n                e = _keep_coeff(Integer(exp), e)\n            elif isinstance(exp, Rational):\n                e = _keep_coeff(exp, e)\n            else:\n                e *= exp\n            args.append(b ** e)\n        else:\n            args.append(factor)\n    return Mul(*args)",
    ".sympy.core.exprtools.py@@Term.as_expr": "def as_expr(self):\n    return self.coeff * (self.numer.as_expr() / self.denom.as_expr())",
    ".sympy.polys.polytools.py@@_symbolic_factor_list": "def _symbolic_factor_list(expr, opt, method):\n    coeff, factors = (S.One, [])\n    args = [i._eval_factor() if hasattr(i, '_eval_factor') else i for i in Mul.make_args(expr)]\n    for arg in args:\n        if arg.is_Number:\n            coeff *= arg\n            continue\n        if arg.is_Mul:\n            args.extend(arg.args)\n            continue\n        if arg.is_Pow:\n            base, exp = arg.args\n            if base.is_Number and exp.is_Number:\n                coeff *= arg\n                continue\n            if base.is_Number:\n                factors.append((base, exp))\n                continue\n        else:\n            base, exp = (arg, S.One)\n        try:\n            poly, _ = _poly_from_expr(base, opt)\n        except PolificationFailed as exc:\n            factors.append((exc.expr, exp))\n        else:\n            func = getattr(poly, method + '_list')\n            _coeff, _factors = func()\n            if _coeff is not S.One:\n                if exp.is_Integer:\n                    coeff *= _coeff ** exp\n                elif _coeff.is_positive:\n                    factors.append((_coeff, exp))\n                else:\n                    _factors.append((_coeff, S.One))\n            if exp is S.One:\n                factors.extend(_factors)\n            elif exp.is_integer:\n                factors.extend([(f, k * exp) for f, k in _factors])\n            else:\n                other = []\n                for f, k in _factors:\n                    if f.as_expr().is_positive:\n                        factors.append((f, k * exp))\n                    else:\n                        other.append((f, k))\n                factors.append((_factors_product(other), exp))\n    return (coeff, factors)",
    ".sympy.polys.polytools.py@@_poly_from_expr": "def _poly_from_expr(expr, opt):\n    orig, expr = (expr, sympify(expr))\n    if not isinstance(expr, Basic):\n        raise PolificationFailed(opt, orig, expr)\n    elif expr.is_Poly:\n        poly = expr.__class__._from_poly(expr, opt)\n        opt.gens = poly.gens\n        opt.domain = poly.domain\n        if opt.polys is None:\n            opt.polys = True\n        return (poly, opt)\n    elif opt.expand:\n        expr = expr.expand()\n    rep, opt = _dict_from_expr(expr, opt)\n    if not opt.gens:\n        raise PolificationFailed(opt, orig, expr)\n    monoms, coeffs = list(zip(*list(rep.items())))\n    domain = opt.domain\n    if domain is None:\n        opt.domain, coeffs = construct_domain(coeffs, opt=opt)\n    else:\n        coeffs = list(map(domain.from_sympy, coeffs))\n    rep = dict(list(zip(monoms, coeffs)))\n    poly = Poly._from_dict(rep, opt)\n    if opt.polys is None:\n        opt.polys = False\n    return (poly, opt)",
    ".sympy.polys.polyutils.py@@_dict_from_expr_no_gens": "def _dict_from_expr_no_gens(expr, opt):\n    (poly,), gens = _parallel_dict_from_expr_no_gens((expr,), opt)\n    return (poly, gens)",
    ".sympy.polys.polytools.py@@Poly.factor_list": "def factor_list(f):\n    if hasattr(f.rep, 'factor_list'):\n        try:\n            coeff, factors = f.rep.factor_list()\n        except DomainError:\n            return (S.One, [(f, 1)])\n    else:\n        raise OperationNotSupported(f, 'factor_list')\n    return (f.rep.dom.to_sympy(coeff), [(f.per(g), k) for g, k in factors])",
    ".sympy.polys.polyclasses.py@@DMP.factor_list": "def factor_list(f):\n    coeff, factors = dmp_factor_list(f.rep, f.lev, f.dom)\n    return (coeff, [(f.per(g), k) for g, k in factors])",
    ".sympy.polys.factortools.py@@dmp_factor_list": "def dmp_factor_list(f, u, K0):\n    if not u:\n        return dup_factor_list(f, K0)\n    J, f = dmp_terms_gcd(f, u, K0)\n    cont, f = dmp_ground_primitive(f, u, K0)\n    if K0.is_FiniteField:\n        coeff, factors = dmp_gf_factor(f, u, K0)\n    elif K0.is_Algebraic:\n        coeff, factors = dmp_ext_factor(f, u, K0)\n    else:\n        if not K0.is_Exact:\n            K0_inexact, K0 = (K0, K0.get_exact())\n            f = dmp_convert(f, u, K0_inexact, K0)\n        else:\n            K0_inexact = None\n        if K0.is_Field:\n            K = K0.get_ring()\n            denom, f = dmp_clear_denoms(f, u, K0, K)\n            f = dmp_convert(f, u, K0, K)\n        else:\n            K = K0\n        if K.is_ZZ:\n            levels, f, v = dmp_exclude(f, u, K)\n            coeff, factors = dmp_zz_factor(f, v, K)\n            for i, (f, k) in enumerate(factors):\n                factors[i] = (dmp_include(f, levels, v, K), k)\n        elif K.is_Poly:\n            f, v = dmp_inject(f, u, K)\n            coeff, factors = dmp_factor_list(f, v, K.dom)\n            for i, (f, k) in enumerate(factors):\n                factors[i] = (dmp_eject(f, v, K), k)\n            coeff = K.convert(coeff, K.dom)\n        else:\n            raise DomainError('factorization not supported over %s' % K0)\n        if K0.is_Field:\n            for i, (f, k) in enumerate(factors):\n                factors[i] = (dmp_convert(f, u, K, K0), k)\n            coeff = K0.convert(coeff, K)\n            coeff = K0.quo(coeff, denom)\n            if K0_inexact:\n                for i, (f, k) in enumerate(factors):\n                    max_norm = dmp_max_norm(f, u, K0)\n                    f = dmp_quo_ground(f, max_norm, u, K0)\n                    f = dmp_convert(f, u, K0, K0_inexact)\n                    factors[i] = (f, k)\n                    coeff = K0.mul(coeff, K0.pow(max_norm, k))\n                coeff = K0_inexact.convert(coeff, K0)\n                K0 = K0_inexact\n    for i, j in enumerate(reversed(J)):\n        if not j:\n            continue\n        term = {(0,) * (u - i) + (1,) + (0,) * i: K0.one}\n        factors.insert(0, (dmp_from_dict(term, u, K0), j))\n    return (coeff * cont, _sort_factors(factors))",
    ".sympy.polys.factortools.py@@dup_factor_list": "def dup_factor_list(f, K0):\n    j, f = dup_terms_gcd(f, K0)\n    cont, f = dup_primitive(f, K0)\n    if K0.is_FiniteField:\n        coeff, factors = dup_gf_factor(f, K0)\n    elif K0.is_Algebraic:\n        coeff, factors = dup_ext_factor(f, K0)\n    else:\n        if not K0.is_Exact:\n            K0_inexact, K0 = (K0, K0.get_exact())\n            f = dup_convert(f, K0_inexact, K0)\n        else:\n            K0_inexact = None\n        if K0.is_Field:\n            K = K0.get_ring()\n            denom, f = dup_clear_denoms(f, K0, K)\n            f = dup_convert(f, K0, K)\n        else:\n            K = K0\n        if K.is_ZZ:\n            coeff, factors = dup_zz_factor(f, K)\n        elif K.is_Poly:\n            f, u = dmp_inject(f, 0, K)\n            coeff, factors = dmp_factor_list(f, u, K.dom)\n            for i, (f, k) in enumerate(factors):\n                factors[i] = (dmp_eject(f, u, K), k)\n            coeff = K.convert(coeff, K.dom)\n        else:\n            raise DomainError('factorization not supported over %s' % K0)\n        if K0.is_Field:\n            for i, (f, k) in enumerate(factors):\n                factors[i] = (dup_convert(f, K, K0), k)\n            coeff = K0.convert(coeff, K)\n            coeff = K0.quo(coeff, denom)\n            if K0_inexact:\n                for i, (f, k) in enumerate(factors):\n                    max_norm = dup_max_norm(f, K0)\n                    f = dup_quo_ground(f, max_norm, K0)\n                    f = dup_convert(f, K0, K0_inexact)\n                    factors[i] = (f, k)\n                    coeff = K0.mul(coeff, K0.pow(max_norm, k))\n                coeff = K0_inexact.convert(coeff, K0)\n                K0 = K0_inexact\n    if j:\n        factors.insert(0, ([K0.one, K0.zero], j))\n    return (coeff * cont, _sort_factors(factors))",
    ".sympy.polys.densebasic.py@@dup_terms_gcd": "def dup_terms_gcd(f, K):\n    if dup_TC(f, K) or not f:\n        return (0, f)\n    i = 0\n    for c in reversed(f):\n        if not c:\n            i += 1\n        else:\n            break\n    return (i, f[:-i])",
    ".sympy.polys.factortools.py@@dup_zz_factor": "def dup_zz_factor(f, K):\n    cont, g = dup_primitive(f, K)\n    n = dup_degree(g)\n    if dup_LC(g, K) < 0:\n        cont, g = (-cont, dup_neg(g, K))\n    if n <= 0:\n        return (cont, [])\n    elif n == 1:\n        return (cont, [(g, 1)])\n    if query('USE_IRREDUCIBLE_IN_FACTOR'):\n        if dup_zz_irreducible_p(g, K):\n            return (cont, [(g, 1)])\n    g = dup_sqf_part(g, K)\n    H = None\n    if query('USE_CYCLOTOMIC_FACTOR'):\n        H = dup_zz_cyclotomic_factor(g, K)\n    if H is None:\n        H = dup_zz_zassenhaus(g, K)\n    factors = dup_trial_division(f, H, K)\n    return (cont, factors)",
    ".sympy.polys.polyutils.py@@_sort_factors": "def _sort_factors(factors, **args):\n\n    def order_if_multiple_key(factor):\n        f, n = factor\n        return (len(f), n, f)\n\n    def order_no_multiple_key(f):\n        return (len(f), f)\n    if args.get('multiple', True):\n        return sorted(factors, key=order_if_multiple_key)\n    else:\n        return sorted(factors, key=order_no_multiple_key)",
    ".sympy.polys.polyutils.py@@order_if_multiple_key": "def order_if_multiple_key(factor):\n    f, n = factor\n    return (len(f), n, f)",
    ".sympy.polys.polytools.py@@_factors_product": "def _factors_product(factors):\n    return Mul(*[f.as_expr() ** k for f, k in factors])",
    ".sympy.simplify.radsimp.py@@collect": "def collect(expr, syms, func=None, evaluate=None, exact=False, distribute_order_term=True):\n    expr = sympify(expr)\n    syms = list(syms) if iterable(syms) else [syms]\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n\n    def make_expression(terms):\n        product = []\n        for term, rat, sym, deriv in terms:\n            if deriv is not None:\n                var, order = deriv\n                while order > 0:\n                    term, order = (Derivative(term, var), order - 1)\n            if sym is None:\n                if rat is S.One:\n                    product.append(term)\n                else:\n                    product.append(Pow(term, rat))\n            else:\n                product.append(Pow(term, rat * sym))\n        return Mul(*product)\n\n    def parse_derivative(deriv):\n        expr, sym, order = (deriv.expr, deriv.variables[0], 1)\n        for s in deriv.variables[1:]:\n            if s == sym:\n                order += 1\n            else:\n                raise NotImplementedError('Improve MV Derivative support in collect')\n        while isinstance(expr, Derivative):\n            s0 = expr.variables[0]\n            for s in expr.variables:\n                if s != s0:\n                    raise NotImplementedError('Improve MV Derivative support in collect')\n            if s0 == sym:\n                expr, order = (expr.expr, order + len(expr.variables))\n            else:\n                break\n        return (expr, (sym, Rational(order)))\n\n    def parse_term(expr):\n        rat_expo, sym_expo = (S.One, None)\n        sexpr, deriv = (expr, None)\n        if expr.is_Pow:\n            if isinstance(expr.base, Derivative):\n                sexpr, deriv = parse_derivative(expr.base)\n            else:\n                sexpr = expr.base\n            if expr.exp.is_Number:\n                rat_expo = expr.exp\n            else:\n                coeff, tail = expr.exp.as_coeff_Mul()\n                if coeff.is_Number:\n                    rat_expo, sym_expo = (coeff, tail)\n                else:\n                    sym_expo = expr.exp\n        elif isinstance(expr, exp):\n            arg = expr.args[0]\n            if arg.is_Rational:\n                sexpr, rat_expo = (S.Exp1, arg)\n            elif arg.is_Mul:\n                coeff, tail = arg.as_coeff_Mul(rational=True)\n                sexpr, rat_expo = (exp(tail), coeff)\n        elif isinstance(expr, Derivative):\n            sexpr, deriv = parse_derivative(expr)\n        return (sexpr, rat_expo, sym_expo, deriv)\n\n    def parse_expression(terms, pattern):\n        pattern = Mul.make_args(pattern)\n        if len(terms) < len(pattern):\n            return None\n        else:\n            pattern = [parse_term(elem) for elem in pattern]\n            terms = terms[:]\n            elems, common_expo, has_deriv = ([], None, False)\n            for elem, e_rat, e_sym, e_ord in pattern:\n                if elem.is_Number and e_rat == 1 and (e_sym is None):\n                    continue\n                for j in range(len(terms)):\n                    if terms[j] is None:\n                        continue\n                    term, t_rat, t_sym, t_ord = terms[j]\n                    if t_ord is not None:\n                        has_deriv = True\n                    if term.match(elem) is not None and (t_sym == e_sym or (t_sym is not None and e_sym is not None and (t_sym.match(e_sym) is not None))):\n                        if exact is False:\n                            expo = t_rat / e_rat\n                            if common_expo is None:\n                                common_expo = expo\n                            elif common_expo != expo:\n                                common_expo = 1\n                        elif e_rat != t_rat or e_ord != t_ord:\n                            continue\n                        elems.append(terms[j])\n                        terms[j] = None\n                        break\n                else:\n                    return None\n            return ([_f for _f in terms if _f], elems, common_expo, has_deriv)\n    if evaluate:\n        if expr.is_Mul:\n            return expr.func(*[collect(term, syms, func, True, exact, distribute_order_term) for term in expr.args])\n        elif expr.is_Pow:\n            b = collect(expr.base, syms, func, True, exact, distribute_order_term)\n            return Pow(b, expr.exp)\n    syms = [expand_power_base(i, deep=False) for i in syms]\n    order_term = None\n    if distribute_order_term:\n        order_term = expr.getO()\n        if order_term is not None:\n            if order_term.has(*syms):\n                order_term = None\n            else:\n                expr = expr.removeO()\n    summa = [expand_power_base(i, deep=False) for i in Add.make_args(expr)]\n    collected, disliked = (defaultdict(list), S.Zero)\n    for product in summa:\n        c, nc = product.args_cnc(split_1=False)\n        args = list(ordered(c)) + nc\n        terms = [parse_term(i) for i in args]\n        small_first = True\n        for symbol in syms:\n            if SYMPY_DEBUG:\n                print('DEBUG: parsing of expression %s with symbol %s ' % (str(terms), str(symbol)))\n            if isinstance(symbol, Derivative) and small_first:\n                terms = list(reversed(terms))\n                small_first = not small_first\n            result = parse_expression(terms, symbol)\n            if SYMPY_DEBUG:\n                print('DEBUG: returned %s' % str(result))\n            if result is not None:\n                terms, elems, common_expo, has_deriv = result\n                if not has_deriv:\n                    margs = []\n                    for elem in elems:\n                        if elem[2] is None:\n                            e = elem[1]\n                        else:\n                            e = elem[1] * elem[2]\n                        margs.append(Pow(elem[0], e))\n                    index = Mul(*margs)\n                else:\n                    index = make_expression(elems)\n                terms = expand_power_base(make_expression(terms), deep=False)\n                index = expand_power_base(index, deep=False)\n                collected[index].append(terms)\n                break\n        else:\n            disliked += product\n    collected = {k: Add(*v) for k, v in collected.items()}\n    if disliked is not S.Zero:\n        collected[S.One] = disliked\n    if order_term is not None:\n        for key, val in collected.items():\n            collected[key] = val + order_term\n    if func is not None:\n        collected = dict([(key, func(val)) for key, val in collected.items()])\n    if evaluate:\n        return Add(*[key * val for key, val in collected.items()])\n    else:\n        return collected",
    ".sympy.core.function.py@@expand_power_base": "def expand_power_base(expr, deep=True, force=False):\n    return sympify(expr).expand(deep=deep, log=False, mul=False, power_exp=False, power_base=True, multinomial=False, basic=False, force=force)",
    ".sympy.core.add.py@@Add.getO": "def getO(self):\n    args = [a for a in self.args if a.is_Order]\n    if args:\n        return self._new_rawargs(*args)",
    ".sympy.simplify.radsimp.py@@parse_term": "def parse_term(expr):\n    rat_expo, sym_expo = (S.One, None)\n    sexpr, deriv = (expr, None)\n    if expr.is_Pow:\n        if isinstance(expr.base, Derivative):\n            sexpr, deriv = parse_derivative(expr.base)\n        else:\n            sexpr = expr.base\n        if expr.exp.is_Number:\n            rat_expo = expr.exp\n        else:\n            coeff, tail = expr.exp.as_coeff_Mul()\n            if coeff.is_Number:\n                rat_expo, sym_expo = (coeff, tail)\n            else:\n                sym_expo = expr.exp\n    elif isinstance(expr, exp):\n        arg = expr.args[0]\n        if arg.is_Rational:\n            sexpr, rat_expo = (S.Exp1, arg)\n        elif arg.is_Mul:\n            coeff, tail = arg.as_coeff_Mul(rational=True)\n            sexpr, rat_expo = (exp(tail), coeff)\n    elif isinstance(expr, Derivative):\n        sexpr, deriv = parse_derivative(expr)\n    return (sexpr, rat_expo, sym_expo, deriv)",
    ".sympy.simplify.radsimp.py@@parse_expression": "def parse_expression(terms, pattern):\n    pattern = Mul.make_args(pattern)\n    if len(terms) < len(pattern):\n        return None\n    else:\n        pattern = [parse_term(elem) for elem in pattern]\n        terms = terms[:]\n        elems, common_expo, has_deriv = ([], None, False)\n        for elem, e_rat, e_sym, e_ord in pattern:\n            if elem.is_Number and e_rat == 1 and (e_sym is None):\n                continue\n            for j in range(len(terms)):\n                if terms[j] is None:\n                    continue\n                term, t_rat, t_sym, t_ord = terms[j]\n                if t_ord is not None:\n                    has_deriv = True\n                if term.match(elem) is not None and (t_sym == e_sym or (t_sym is not None and e_sym is not None and (t_sym.match(e_sym) is not None))):\n                    if exact is False:\n                        expo = t_rat / e_rat\n                        if common_expo is None:\n                            common_expo = expo\n                        elif common_expo != expo:\n                            common_expo = 1\n                    elif e_rat != t_rat or e_ord != t_ord:\n                        continue\n                    elems.append(terms[j])\n                    terms[j] = None\n                    break\n            else:\n                return None\n        return ([_f for _f in terms if _f], elems, common_expo, has_deriv)",
    ".sympy.core.basic.py@@Basic.match": "def match(self, pattern, old=False):\n    pattern = sympify(pattern)\n    return pattern.matches(self, old=old)",
    ".sympy.core.basic.py@@Atom.matches": "def matches(self, expr, repl_dict={}, old=False):\n    if self == expr:\n        return repl_dict",
    ".sympy.simplify.radsimp.py@@make_expression": "def make_expression(terms):\n    product = []\n    for term, rat, sym, deriv in terms:\n        if deriv is not None:\n            var, order = deriv\n            while order > 0:\n                term, order = (Derivative(term, var), order - 1)\n        if sym is None:\n            if rat is S.One:\n                product.append(term)\n            else:\n                product.append(Pow(term, rat))\n        else:\n            product.append(Pow(term, rat * sym))\n    return Mul(*product)",
    ".sympy.polys.polytools.py@@gcd_list": "def gcd_list(seq, *gens, **args):\n    seq = sympify(seq)\n\n    def try_non_polynomial_gcd(seq):\n        if not gens and (not args):\n            domain, numbers = construct_domain(seq)\n            if not numbers:\n                return domain.zero\n            elif domain.is_Numerical:\n                result, numbers = (numbers[0], numbers[1:])\n                for number in numbers:\n                    result = domain.gcd(result, number)\n                    if domain.is_one(result):\n                        break\n                return domain.to_sympy(result)\n        return None\n    result = try_non_polynomial_gcd(seq)\n    if result is not None:\n        return result\n    options.allowed_flags(args, ['polys'])\n    try:\n        polys, opt = parallel_poly_from_expr(seq, *gens, **args)\n        if len(seq) > 1 and all((elt.is_algebraic and elt.is_irrational for elt in seq)):\n            a = seq[-1]\n            lst = [(a / elt).ratsimp() for elt in seq[:-1]]\n            if all((frc.is_rational for frc in lst)):\n                lc = 1\n                for frc in lst:\n                    lc = lcm(lc, frc.as_numer_denom()[0])\n                return a / lc\n    except PolificationFailed as exc:\n        result = try_non_polynomial_gcd(exc.exprs)\n        if result is not None:\n            return result\n        else:\n            raise ComputationFailed('gcd_list', len(seq), exc)\n    if not polys:\n        if not opt.polys:\n            return S.Zero\n        else:\n            return Poly(0, opt=opt)\n    result, polys = (polys[0], polys[1:])\n    for poly in polys:\n        result = result.gcd(poly)\n        if result.is_one:\n            break\n    if not opt.polys:\n        return result.as_expr()\n    else:\n        return result",
    ".sympy.polys.polytools.py@@try_non_polynomial_gcd": "def try_non_polynomial_gcd(seq):\n    if not gens and (not args):\n        domain, numbers = construct_domain(seq)\n        if not numbers:\n            return domain.zero\n        elif domain.is_Numerical:\n            result, numbers = (numbers[0], numbers[1:])\n            for number in numbers:\n                result = domain.gcd(result, number)\n                if domain.is_one(result):\n                    break\n            return domain.to_sympy(result)\n    return None",
    ".sympy.ntheory.factor_.py@@divisors": "def divisors(n, generator=False):\n    n = as_int(abs(n))\n    if isprime(n):\n        return [1, n]\n    if n == 1:\n        return [1]\n    if n == 0:\n        return []\n    rv = _divisors(n)\n    if not generator:\n        return sorted(rv)\n    return rv",
    ".sympy.ntheory.primetest.py@@isprime": "def isprime(n):\n    if isinstance(n, (Float, float)):\n        return False\n    n = int(n)\n    if n in [2, 3, 5]:\n        return True\n    if n < 2 or n % 2 == 0 or n % 3 == 0 or (n % 5 == 0):\n        return False\n    if n < 49:\n        return True\n    if n % 7 == 0 or n % 11 == 0 or n % 13 == 0 or (n % 17 == 0) or (n % 19 == 0) or (n % 23 == 0) or (n % 29 == 0) or (n % 31 == 0) or (n % 37 == 0) or (n % 41 == 0) or (n % 43 == 0) or (n % 47 == 0):\n        return False\n    if n < 2809:\n        return True\n    if n <= 23001:\n        return pow(2, n, n) == 2 and n not in [7957, 8321, 13747, 18721, 19951]\n    from sympy.ntheory.generate import sieve as s\n    if n <= s._list[-1]:\n        l, u = s.search(n)\n        return l == u\n    from sympy.core.compatibility import HAS_GMPY\n    if HAS_GMPY == 2:\n        from gmpy2 import is_strong_prp, is_strong_selfridge_prp\n        return is_strong_prp(n, 2) and is_strong_selfridge_prp(n)\n    if n < 341531:\n        return mr(n, [9345883071009581737])\n    if n < 885594169:\n        return mr(n, [725270293939359937, 3569819667048198375])\n    if n < 350269456337:\n        return mr(n, [4230279247111683200, 14694767155120705706, 16641139526367750375])\n    if n < 55245642489451:\n        return mr(n, [2, 141889084524735, 1199124725622454117, 11096072698276303650])\n    if n < 7999252175582851:\n        return mr(n, [2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805])\n    if n < 585226005592931977:\n        return mr(n, [2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375])\n    if n < 18446744073709551616:\n        return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n    return mr(n, [2]) and is_strong_lucas_prp(n)",
    ".sympy.polys.polytools.py@@Poly.length": "def length(f):\n    return len(f.as_dict())",
    ".sympy.core.numbers.py@@Rational._hashable_content": "def _hashable_content(self):\n    return (self.p, self.q)",
    ".sympy.polys.sqfreetools.py@@dup_sqf_part": "def dup_sqf_part(f, K):\n    if K.is_FiniteField:\n        return dup_gf_sqf_part(f, K)\n    if not f:\n        return f\n    if K.is_negative(dup_LC(f, K)):\n        f = dup_neg(f, K)\n    gcd = dup_gcd(f, dup_diff(f, 1, K), K)\n    sqf = dup_quo(f, gcd, K)\n    if K.is_Field:\n        return dup_monic(sqf, K)\n    else:\n        return dup_primitive(sqf, K)[1]",
    ".sympy.polys.densetools.py@@dup_diff": "def dup_diff(f, m, K):\n    if m <= 0:\n        return f\n    n = dup_degree(f)\n    if n < m:\n        return []\n    deriv = []\n    if m == 1:\n        for coeff in f[:-m]:\n            deriv.append(K(n) * coeff)\n            n -= 1\n    else:\n        for coeff in f[:-m]:\n            k = n\n            for i in range(n - 1, n - m, -1):\n                k *= i\n            deriv.append(K(k) * coeff)\n            n -= 1\n    return dup_strip(deriv)",
    ".sympy.polys.domains.domain.py@@Domain.new": "def new(self, *args):\n    return self.dtype(*args)",
    ".sympy.polys.euclidtools.py@@dup_gcd": "def dup_gcd(f, g, K):\n    return dup_inner_gcd(f, g, K)[0]",
    ".sympy.polys.densearith.py@@dup_max_norm": "def dup_max_norm(f, K):\n    if not f:\n        return K.zero\n    else:\n        return max(dup_abs(f, K))",
    ".sympy.polys.densearith.py@@dup_abs": "def dup_abs(f, K):\n    return [K.abs(coeff) for coeff in f]",
    ".sympy.polys.domains.domain.py@@Domain.abs": "def abs(self, a):\n    return abs(a)",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.sqrt": "def sqrt(self, a):\n    return python_sqrt(a)",
    ".sympy.polys.domains.groundtypes.py@@python_sqrt": "def python_sqrt(n):\n    return int(mlib.isqrt(n))",
    ".sympy.polys.densetools.py@@dup_eval": "def dup_eval(f, a, K):\n    if not a:\n        return dup_TC(f, K)\n    result = K.zero\n    for c in f:\n        result *= a\n        result += c\n    return result",
    ".sympy.polys.euclidtools.py@@_dup_zz_gcd_interpolate": "def _dup_zz_gcd_interpolate(h, x, K):\n    f = []\n    while h:\n        g = h % x\n        if g > x // 2:\n            g -= x\n        f.insert(0, g)\n        h = (h - g) // x\n    return f",
    ".sympy.polys.densearith.py@@dup_div": "def dup_div(f, g, K):\n    if K.is_Field:\n        return dup_ff_div(f, g, K)\n    else:\n        return dup_rr_div(f, g, K)",
    ".sympy.polys.densearith.py@@dup_mul_ground": "def dup_mul_ground(f, c, K):\n    if not c or not f:\n        return []\n    else:\n        return [cf * c for cf in f]",
    ".sympy.polys.densearith.py@@dup_quo": "def dup_quo(f, g, K):\n    return dup_div(f, g, K)[0]",
    ".sympy.polys.factortools.py@@dup_zz_cyclotomic_factor": "def dup_zz_cyclotomic_factor(f, K):\n    lc_f, tc_f = (dup_LC(f, K), dup_TC(f, K))\n    if dup_degree(f) <= 0:\n        return None\n    if lc_f != 1 or tc_f not in [-1, 1]:\n        return None\n    if any((bool(cf) for cf in f[1:-1])):\n        return None\n    n = dup_degree(f)\n    F = _dup_cyclotomic_decompose(n, K)\n    if not K.is_one(tc_f):\n        return F\n    else:\n        H = []\n        for h in _dup_cyclotomic_decompose(2 * n, K):\n            if h not in F:\n                H.append(h)\n        return H",
    ".sympy.polys.factortools.py@@dup_zz_zassenhaus": "def dup_zz_zassenhaus(f, K):\n    n = dup_degree(f)\n    if n == 1:\n        return [f]\n    fc = f[-1]\n    A = dup_max_norm(f, K)\n    b = dup_LC(f, K)\n    B = int(abs(K.sqrt(K(n + 1)) * 2 ** n * A * b))\n    C = int((n + 1) ** (2 * n) * A ** (2 * n - 1))\n    gamma = int(_ceil(2 * _log(C, 2)))\n    bound = int(2 * gamma * _log(gamma))\n    a = []\n    for px in range(3, bound + 1):\n        if not isprime(px) or b % px == 0:\n            continue\n        px = K.convert(px)\n        F = gf_from_int_poly(f, px)\n        if not gf_sqf_p(F, px, K):\n            continue\n        fsqfx = gf_factor_sqf(F, px, K)[1]\n        a.append((px, fsqfx))\n        if len(fsqfx) < 15 or len(a) > 4:\n            break\n    p, fsqf = min(a, key=lambda x: len(x[1]))\n    l = int(_ceil(_log(2 * B + 1, p)))\n    modular = [gf_to_int_poly(ff, p) for ff in fsqf]\n    g = dup_zz_hensel_lift(p, f, modular, l, K)\n    sorted_T = range(len(g))\n    T = set(sorted_T)\n    factors, s = ([], 1)\n    pl = p ** l\n    while 2 * s <= len(T):\n        for S in subsets(sorted_T, s):\n            if b == 1:\n                q = 1\n                for i in S:\n                    q = q * g[i][-1]\n                q = q % pl\n                if not _test_pl(fc, q, pl):\n                    continue\n            else:\n                G = [b]\n                for i in S:\n                    G = dup_mul(G, g[i], K)\n                G = dup_trunc(G, pl, K)\n                G = dup_primitive(G, K)[1]\n                q = G[-1]\n                if q and fc % q != 0:\n                    continue\n            H = [b]\n            S = set(S)\n            T_S = T - S\n            if b == 1:\n                G = [b]\n                for i in S:\n                    G = dup_mul(G, g[i], K)\n                G = dup_trunc(G, pl, K)\n            for i in T_S:\n                H = dup_mul(H, g[i], K)\n            H = dup_trunc(H, pl, K)\n            G_norm = dup_l1_norm(G, K)\n            H_norm = dup_l1_norm(H, K)\n            if G_norm * H_norm <= B:\n                T = T_S\n                sorted_T = [i for i in sorted_T if i not in S]\n                G = dup_primitive(G, K)[1]\n                f = dup_primitive(H, K)[1]\n                factors.append(G)\n                b = dup_LC(f, K)\n                break\n        else:\n            s += 1\n    return factors + [f]",
    ".sympy.polys.galoistools.py@@gf_from_int_poly": "def gf_from_int_poly(f, p):\n    return gf_trunc(f, p)",
    ".sympy.polys.galoistools.py@@gf_trunc": "def gf_trunc(f, p):\n    return gf_strip([a % p for a in f])",
    ".sympy.polys.galoistools.py@@gf_strip": "def gf_strip(f):\n    if not f or f[0]:\n        return f\n    k = 0\n    for coeff in f:\n        if coeff:\n            break\n        else:\n            k += 1\n    return f[k:]",
    ".sympy.polys.galoistools.py@@gf_sqf_p": "def gf_sqf_p(f, p, K):\n    _, f = gf_monic(f, p, K)\n    if not f:\n        return True\n    else:\n        return gf_gcd(f, gf_diff(f, p, K), p, K) == [K.one]",
    ".sympy.polys.galoistools.py@@gf_monic": "def gf_monic(f, p, K):\n    if not f:\n        return (K.zero, [])\n    else:\n        lc = f[0]\n        if K.is_one(lc):\n            return (lc, list(f))\n        else:\n            return (lc, gf_quo_ground(f, lc, p, K))",
    ".sympy.polys.galoistools.py@@gf_quo_ground": "def gf_quo_ground(f, a, p, K):\n    return gf_mul_ground(f, K.invert(a, p), p, K)",
    ".sympy.polys.domains.ring.py@@Ring.invert": "def invert(self, a, b):\n    s, t, h = self.gcdex(a, b)\n    if self.is_one(h):\n        return s % b\n    else:\n        raise NotInvertible('zero divisor')",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.gcdex": "def gcdex(self, a, b):\n    return python_gcdex(a, b)",
    ".sympy.core.numbers.py@@igcdex": "def igcdex(a, b):\n    if not a and (not b):\n        return (0, 1, 0)\n    if not a:\n        return (0, b // abs(b), abs(b))\n    if not b:\n        return (a // abs(a), 0, abs(a))\n    if a < 0:\n        a, x_sign = (-a, -1)\n    else:\n        x_sign = 1\n    if b < 0:\n        b, y_sign = (-b, -1)\n    else:\n        y_sign = 1\n    x, y, r, s = (1, 0, 0, 1)\n    while b:\n        c, q = (a % b, a // b)\n        a, b, r, s, x, y = (b, c, x - q * r, y - q * s, r, s)\n    return (x * x_sign, y * y_sign, a)",
    ".sympy.polys.galoistools.py@@gf_mul_ground": "def gf_mul_ground(f, a, p, K):\n    if not a:\n        return []\n    else:\n        return [a * b % p for b in f]",
    ".sympy.polys.galoistools.py@@gf_diff": "def gf_diff(f, p, K):\n    df = gf_degree(f)\n    h, n = ([K.zero] * df, df)\n    for coeff in f[:-1]:\n        coeff *= K(n)\n        coeff %= p\n        if coeff:\n            h[df - n] = coeff\n        n -= 1\n    return gf_strip(h)",
    ".sympy.polys.galoistools.py@@gf_degree": "def gf_degree(f):\n    return len(f) - 1",
    ".sympy.polys.galoistools.py@@gf_gcd": "def gf_gcd(f, g, p, K):\n    while g:\n        f, g = (g, gf_rem(f, g, p, K))\n    return gf_monic(f, p, K)[1]",
    ".sympy.polys.galoistools.py@@gf_rem": "def gf_rem(f, g, p, K):\n    return gf_div(f, g, p, K)[1]",
    ".sympy.polys.galoistools.py@@gf_div": "def gf_div(f, g, p, K):\n    df = gf_degree(f)\n    dg = gf_degree(g)\n    if not g:\n        raise ZeroDivisionError('polynomial division')\n    elif df < dg:\n        return ([], f)\n    inv = K.invert(g[0], p)\n    h, dq, dr = (list(f), df - dg, dg - 1)\n    for i in range(0, df + 1):\n        coeff = h[i]\n        for j in range(max(0, dg - i), min(df - i, dr) + 1):\n            coeff -= h[i + j - dg] * g[dg - j]\n        if i <= dq:\n            coeff *= inv\n        h[i] = coeff % p\n    return (h[:dq + 1], gf_strip(h[dq + 1:]))",
    ".sympy.polys.galoistools.py@@gf_factor_sqf": "def gf_factor_sqf(f, p, K, method=None):\n    lc, f = gf_monic(f, p, K)\n    if gf_degree(f) < 1:\n        return (lc, [])\n    method = method or query('GF_FACTOR_METHOD')\n    if method is not None:\n        factors = _factor_methods[method](f, p, K)\n    else:\n        factors = gf_zassenhaus(f, p, K)\n    return (lc, factors)",
    ".sympy.polys.galoistools.py@@gf_zassenhaus": "def gf_zassenhaus(f, p, K):\n    factors = []\n    for factor, n in gf_ddf_zassenhaus(f, p, K):\n        factors += gf_edf_zassenhaus(factor, n, p, K)\n    return _sort_factors(factors, multiple=False)",
    ".sympy.polys.galoistools.py@@gf_ddf_zassenhaus": "def gf_ddf_zassenhaus(f, p, K):\n    i, g, factors = (1, [K.one, K.zero], [])\n    b = gf_frobenius_monomial_base(f, p, K)\n    while 2 * i <= gf_degree(f):\n        g = gf_frobenius_map(g, f, b, p, K)\n        h = gf_gcd(f, gf_sub(g, [K.one, K.zero], p, K), p, K)\n        if h != [K.one]:\n            factors.append((h, i))\n            f = gf_quo(f, h, p, K)\n            g = gf_rem(g, f, p, K)\n            b = gf_frobenius_monomial_base(f, p, K)\n        i += 1\n    if f != [K.one]:\n        return factors + [(f, gf_degree(f))]\n    else:\n        return factors",
    ".sympy.polys.galoistools.py@@gf_frobenius_monomial_base": "def gf_frobenius_monomial_base(g, p, K):\n    n = gf_degree(g)\n    if n == 0:\n        return []\n    b = [0] * n\n    b[0] = [1]\n    if p < n:\n        for i in range(1, n):\n            mon = gf_lshift(b[i - 1], p, K)\n            b[i] = gf_rem(mon, g, p, K)\n    elif n > 1:\n        b[1] = gf_pow_mod([K.one, K.zero], p, g, p, K)\n        for i in range(2, n):\n            b[i] = gf_mul(b[i - 1], b[1], p, K)\n            b[i] = gf_rem(b[i], g, p, K)\n    return b",
    ".sympy.polys.galoistools.py@@gf_pow_mod": "def gf_pow_mod(f, n, g, p, K):\n    if not n:\n        return [K.one]\n    elif n == 1:\n        return gf_rem(f, g, p, K)\n    elif n == 2:\n        return gf_rem(gf_sqr(f, p, K), g, p, K)\n    h = [K.one]\n    while True:\n        if n & 1:\n            h = gf_mul(h, f, p, K)\n            h = gf_rem(h, g, p, K)\n            n -= 1\n        n >>= 1\n        if not n:\n            break\n        f = gf_sqr(f, p, K)\n        f = gf_rem(f, g, p, K)\n    return h",
    ".sympy.polys.galoistools.py@@gf_mul": "def gf_mul(f, g, p, K):\n    df = gf_degree(f)\n    dg = gf_degree(g)\n    dh = df + dg\n    h = [0] * (dh + 1)\n    for i in range(0, dh + 1):\n        coeff = K.zero\n        for j in range(max(0, i - dg), min(i, df) + 1):\n            coeff += f[j] * g[i - j]\n        h[i] = coeff % p\n    return gf_strip(h)",
    ".sympy.polys.galoistools.py@@gf_sqr": "def gf_sqr(f, p, K):\n    df = gf_degree(f)\n    dh = 2 * df\n    h = [0] * (dh + 1)\n    for i in range(0, dh + 1):\n        coeff = K.zero\n        jmin = max(0, i - df)\n        jmax = min(i, df)\n        n = jmax - jmin + 1\n        jmax = jmin + n // 2 - 1\n        for j in range(jmin, jmax + 1):\n            coeff += f[j] * f[i - j]\n        coeff += coeff\n        if n & 1:\n            elem = f[jmax + 1]\n            coeff += elem ** 2\n        h[i] = coeff % p\n    return gf_strip(h)",
    ".sympy.polys.galoistools.py@@gf_frobenius_map": "def gf_frobenius_map(f, g, b, p, K):\n    m = gf_degree(g)\n    if gf_degree(f) >= m:\n        f = gf_rem(f, g, p, K)\n    if not f:\n        return []\n    n = gf_degree(f)\n    sf = [f[-1]]\n    for i in range(1, n + 1):\n        v = gf_mul_ground(b[i], f[n - i], p, K)\n        sf = gf_add(sf, v, p, K)\n    return sf",
    ".sympy.polys.galoistools.py@@gf_add": "def gf_add(f, g, p, K):\n    if not f:\n        return g\n    if not g:\n        return f\n    df = gf_degree(f)\n    dg = gf_degree(g)\n    if df == dg:\n        return gf_strip([(a + b) % p for a, b in zip(f, g)])\n    else:\n        k = abs(df - dg)\n        if df > dg:\n            h, f = (f[:k], f[k:])\n        else:\n            h, g = (g[:k], g[k:])\n        return h + [(a + b) % p for a, b in zip(f, g)]",
    ".sympy.polys.galoistools.py@@gf_sub": "def gf_sub(f, g, p, K):\n    if not g:\n        return f\n    if not f:\n        return gf_neg(g, p, K)\n    df = gf_degree(f)\n    dg = gf_degree(g)\n    if df == dg:\n        return gf_strip([(a - b) % p for a, b in zip(f, g)])\n    else:\n        k = abs(df - dg)\n        if df > dg:\n            h, f = (f[:k], f[k:])\n        else:\n            h, g = (gf_neg(g[:k], p, K), g[k:])\n        return h + [(a - b) % p for a, b in zip(f, g)]",
    ".sympy.polys.galoistools.py@@gf_quo": "def gf_quo(f, g, p, K):\n    df = gf_degree(f)\n    dg = gf_degree(g)\n    if not g:\n        raise ZeroDivisionError('polynomial division')\n    elif df < dg:\n        return []\n    inv = K.invert(g[0], p)\n    h, dq, dr = (f[:], df - dg, dg - 1)\n    for i in range(0, dq + 1):\n        coeff = h[i]\n        for j in range(max(0, dg - i), min(df - i, dr) + 1):\n            coeff -= h[i + j - dg] * g[dg - j]\n        h[i] = coeff * inv % p\n    return h[:dq + 1]",
    ".sympy.polys.galoistools.py@@gf_edf_zassenhaus": "def gf_edf_zassenhaus(f, n, p, K):\n    factors, q = ([f], int(p))\n    if gf_degree(f) <= n:\n        return factors\n    N = gf_degree(f) // n\n    if p != 2:\n        b = gf_frobenius_monomial_base(f, p, K)\n    while len(factors) < N:\n        r = gf_random(2 * n - 1, p, K)\n        if p == 2:\n            h = r\n            for i in range(0, 2 ** (n * N - 1)):\n                r = gf_pow_mod(r, 2, f, p, K)\n                h = gf_add(h, r, p, K)\n            g = gf_gcd(f, h, p, K)\n        else:\n            h = _gf_pow_pnm1d2(r, n, f, b, p, K)\n            g = gf_gcd(f, gf_sub_ground(h, K.one, p, K), p, K)\n        if g != [K.one] and g != f:\n            factors = gf_edf_zassenhaus(g, n, p, K) + gf_edf_zassenhaus(gf_quo(f, g, p, K), n, p, K)\n    return _sort_factors(factors, multiple=False)",
    ".sympy.polys.galoistools.py@@gf_random": "def gf_random(n, p, K):\n    return [K.one] + [K(int(uniform(0, p))) for i in range(0, n)]",
    ".sympy.polys.galoistools.py@@_gf_pow_pnm1d2": "def _gf_pow_pnm1d2(f, n, g, b, p, K):\n    f = gf_rem(f, g, p, K)\n    h = f\n    r = f\n    for i in range(1, n):\n        h = gf_frobenius_map(h, g, b, p, K)\n        r = gf_mul(r, h, p, K)\n        r = gf_rem(r, g, p, K)\n    res = gf_pow_mod(r, (p - 1) // 2, g, p, K)\n    return res",
    ".sympy.polys.galoistools.py@@gf_sub_ground": "def gf_sub_ground(f, a, p, K):\n    if not f:\n        a = -a % p\n    else:\n        a = (f[-1] - a) % p\n        if len(f) > 1:\n            return f[:-1] + [a]\n    if not a:\n        return []\n    else:\n        return [a]",
    ".sympy.polys.polyutils.py@@order_no_multiple_key": "def order_no_multiple_key(f):\n    return (len(f), f)",
    ".sympy.polys.galoistools.py@@gf_to_int_poly": "def gf_to_int_poly(f, p, symmetric=True):\n    if symmetric:\n        return [gf_int(c, p) for c in f]\n    else:\n        return f",
    ".sympy.polys.galoistools.py@@gf_int": "def gf_int(a, p):\n    if a <= p // 2:\n        return a\n    else:\n        return a - p",
    ".sympy.polys.factortools.py@@dup_zz_hensel_lift": "def dup_zz_hensel_lift(p, f, f_list, l, K):\n    r = len(f_list)\n    lc = dup_LC(f, K)\n    if r == 1:\n        F = dup_mul_ground(f, K.gcdex(lc, p ** l)[0], K)\n        return [dup_trunc(F, p ** l, K)]\n    m = p\n    k = r // 2\n    d = int(_ceil(_log(l, 2)))\n    g = gf_from_int_poly([lc], p)\n    for f_i in f_list[:k]:\n        g = gf_mul(g, gf_from_int_poly(f_i, p), p, K)\n    h = gf_from_int_poly(f_list[k], p)\n    for f_i in f_list[k + 1:]:\n        h = gf_mul(h, gf_from_int_poly(f_i, p), p, K)\n    s, t, _ = gf_gcdex(g, h, p, K)\n    g = gf_to_int_poly(g, p)\n    h = gf_to_int_poly(h, p)\n    s = gf_to_int_poly(s, p)\n    t = gf_to_int_poly(t, p)\n    for _ in range(1, d + 1):\n        (g, h, s, t), m = (dup_zz_hensel_step(m, f, g, h, s, t, K), m ** 2)\n    return dup_zz_hensel_lift(p, g, f_list[:k], l, K) + dup_zz_hensel_lift(p, h, f_list[k:], l, K)",
    ".sympy.polys.galoistools.py@@gf_gcdex": "def gf_gcdex(f, g, p, K):\n    if not (f or g):\n        return ([K.one], [], [])\n    p0, r0 = gf_monic(f, p, K)\n    p1, r1 = gf_monic(g, p, K)\n    if not f:\n        return ([], [K.invert(p1, p)], r1)\n    if not g:\n        return ([K.invert(p0, p)], [], r0)\n    s0, s1 = ([K.invert(p0, p)], [])\n    t0, t1 = ([], [K.invert(p1, p)])\n    while True:\n        Q, R = gf_div(r0, r1, p, K)\n        if not R:\n            break\n        (lc, r1), r0 = (gf_monic(R, p, K), r1)\n        inv = K.invert(lc, p)\n        s = gf_sub_mul(s0, s1, Q, p, K)\n        t = gf_sub_mul(t0, t1, Q, p, K)\n        s1, s0 = (gf_mul_ground(s, inv, p, K), s1)\n        t1, t0 = (gf_mul_ground(t, inv, p, K), t1)\n    return (s1, t1, r1)",
    ".sympy.polys.galoistools.py@@gf_sub_mul": "def gf_sub_mul(f, g, h, p, K):\n    return gf_sub(f, gf_mul(g, h, p, K), p, K)",
    ".sympy.polys.galoistools.py@@gf_neg": "def gf_neg(f, p, K):\n    return [-coeff % p for coeff in f]",
    ".sympy.polys.factortools.py@@dup_zz_hensel_step": "def dup_zz_hensel_step(m, f, g, h, s, t, K):\n    M = m ** 2\n    e = dup_sub_mul(f, g, h, K)\n    e = dup_trunc(e, M, K)\n    q, r = dup_div(dup_mul(s, e, K), h, K)\n    q = dup_trunc(q, M, K)\n    r = dup_trunc(r, M, K)\n    u = dup_add(dup_mul(t, e, K), dup_mul(q, g, K), K)\n    G = dup_trunc(dup_add(g, u, K), M, K)\n    H = dup_trunc(dup_add(h, r, K), M, K)\n    u = dup_add(dup_mul(s, G, K), dup_mul(t, H, K), K)\n    b = dup_trunc(dup_sub(u, [K.one], K), M, K)\n    c, d = dup_div(dup_mul(s, b, K), H, K)\n    c = dup_trunc(c, M, K)\n    d = dup_trunc(d, M, K)\n    u = dup_add(dup_mul(t, b, K), dup_mul(c, G, K), K)\n    S = dup_trunc(dup_sub(s, d, K), M, K)\n    T = dup_trunc(dup_sub(t, u, K), M, K)\n    return (G, H, S, T)",
    ".sympy.polys.densearith.py@@dup_sub_mul": "def dup_sub_mul(f, g, h, K):\n    return dup_sub(f, dup_mul(g, h, K), K)",
    ".sympy.polys.densearith.py@@dup_mul": "def dup_mul(f, g, K):\n    if f == g:\n        return dup_sqr(f, K)\n    if not (f and g):\n        return []\n    df = dup_degree(f)\n    dg = dup_degree(g)\n    n = max(df, dg) + 1\n    if n < 100:\n        h = []\n        for i in range(0, df + dg + 1):\n            coeff = K.zero\n            for j in range(max(0, i - dg), min(df, i) + 1):\n                coeff += f[j] * g[i - j]\n            h.append(coeff)\n        return dup_strip(h)\n    else:\n        n2 = n // 2\n        fl, gl = (dup_slice(f, 0, n2, K), dup_slice(g, 0, n2, K))\n        fh = dup_rshift(dup_slice(f, n2, n, K), n2, K)\n        gh = dup_rshift(dup_slice(g, n2, n, K), n2, K)\n        lo, hi = (dup_mul(fl, gl, K), dup_mul(fh, gh, K))\n        mid = dup_mul(dup_add(fl, fh, K), dup_add(gl, gh, K), K)\n        mid = dup_sub(mid, dup_add(lo, hi, K), K)\n        return dup_add(dup_add(lo, dup_lshift(mid, n2, K), K), dup_lshift(hi, 2 * n2, K), K)",
    ".sympy.polys.densetools.py@@dup_trunc": "def dup_trunc(f, p, K):\n    if K.is_ZZ:\n        g = []\n        for c in f:\n            c = c % p\n            if c > p // 2:\n                g.append(c - p)\n            else:\n                g.append(c)\n    else:\n        g = [c % p for c in f]\n    return dup_strip(g)",
    ".sympy.polys.densearith.py@@dup_add": "def dup_add(f, g, K):\n    if not f:\n        return g\n    if not g:\n        return f\n    df = dup_degree(f)\n    dg = dup_degree(g)\n    if df == dg:\n        return dup_strip([a + b for a, b in zip(f, g)])\n    else:\n        k = abs(df - dg)\n        if df > dg:\n            h, f = (f[:k], f[k:])\n        else:\n            h, g = (g[:k], g[k:])\n        return h + [a + b for a, b in zip(f, g)]",
    ".sympy.polys.densearith.py@@dup_neg": "def dup_neg(f, K):\n    return [-coeff for coeff in f]",
    ".sympy.utilities.iterables.py@@subsets": "def subsets(seq, k=None, repetition=False):\n    if k is None:\n        for k in range(len(seq) + 1):\n            for i in subsets(seq, k, repetition):\n                yield i\n    elif not repetition:\n        for i in combinations(seq, k):\n            yield i\n    else:\n        for i in combinations_with_replacement(seq, k):\n            yield i",
    ".sympy.polys.densearith.py@@dup_quo_ground": "def dup_quo_ground(f, c, K):\n    if not c:\n        raise ZeroDivisionError('polynomial division')\n    if not f:\n        return f\n    if K.is_Field:\n        return [K.quo(cf, c) for cf in f]\n    else:\n        return [cf // c for cf in f]",
    ".sympy.polys.factortools.py@@dup_trial_division": "def dup_trial_division(f, factors, K):\n    result = []\n    for factor in factors:\n        k = 0\n        while True:\n            q, r = dup_div(f, factor, K)\n            if not r:\n                f, k = (q, k + 1)\n            else:\n                break\n        result.append((factor, k))\n    return _sort_factors(result)",
    ".sympy.polys.polyroots.py@@roots_quadratic": "def roots_quadratic(f):\n    a, b, c = f.all_coeffs()\n    dom = f.get_domain()\n\n    def _sqrt(d):\n        co = []\n        other = []\n        for di in Mul.make_args(d):\n            if di.is_Pow and di.exp.is_Integer and (di.exp % 2 == 0):\n                co.append(Pow(di.base, di.exp // 2))\n            else:\n                other.append(di)\n        if co:\n            d = Mul(*other)\n            co = Mul(*co)\n            return co * sqrt(d)\n        return sqrt(d)\n\n    def _simplify(expr):\n        if dom.is_Composite:\n            return factor(expr)\n        else:\n            return simplify(expr)\n    if c is S.Zero:\n        r0, r1 = (S.Zero, -b / a)\n        if not dom.is_Numerical:\n            r1 = _simplify(r1)\n        elif r1.is_negative:\n            r0, r1 = (r1, r0)\n    elif b is S.Zero:\n        r = -c / a\n        if not dom.is_Numerical:\n            r = _simplify(r)\n        R = _sqrt(r)\n        r0 = -R\n        r1 = R\n    else:\n        d = b ** 2 - 4 * a * c\n        A = 2 * a\n        B = -b / A\n        if not dom.is_Numerical:\n            d = _simplify(d)\n            B = _simplify(B)\n        D = factor_terms(_sqrt(d) / A)\n        r0 = B - D\n        r1 = B + D\n        if a.is_negative:\n            r0, r1 = (r1, r0)\n        elif not dom.is_Numerical:\n            r0, r1 = [expand_2arg(i) for i in (r0, r1)]\n    return [r0, r1]",
    ".sympy.polys.polytools.py@@Poly.all_coeffs": "def all_coeffs(f):\n    return [f.rep.dom.to_sympy(c) for c in f.rep.all_coeffs()]",
    ".sympy.polys.polyclasses.py@@DMP.all_coeffs": "def all_coeffs(f):\n    if not f.lev:\n        if not f:\n            return [f.dom.zero]\n        else:\n            return [c for c in f.rep]\n    else:\n        raise PolynomialError('multivariate polynomials not supported')",
    ".sympy.polys.polyclasses.py@@DMP.__nonzero__": "def __nonzero__(f):\n    return not dmp_zero_p(f.rep, f.lev)",
    ".sympy.polys.polyroots.py@@_sqrt": "def _sqrt(d):\n    co = []\n    other = []\n    for di in Mul.make_args(d):\n        if di.is_Pow and di.exp.is_Integer and (di.exp % 2 == 0):\n            co.append(Pow(di.base, di.exp // 2))\n        else:\n            other.append(di)\n    if co:\n        d = Mul(*other)\n        co = Mul(*co)\n        return co * sqrt(d)\n    return sqrt(d)",
    ".sympy.ntheory.generate.py@@primerange": "def primerange(a, b):\n    from sympy.functions.elementary.integers import ceiling\n    if a >= b:\n        return\n    if b <= sieve._list[-1]:\n        for i in sieve.primerange(a, b):\n            yield i\n        return\n    a = as_int(ceiling(a)) - 1\n    b = as_int(ceiling(b))\n    while 1:\n        a = nextprime(a)\n        if a < b:\n            yield a\n        else:\n            return",
    ".sympy.ntheory.generate.py@@Sieve.primerange": "def primerange(self, a, b):\n    from sympy.functions.elementary.integers import ceiling\n    a = max(2, as_int(ceiling(a)))\n    b = as_int(ceiling(b))\n    if a >= b:\n        return\n    self.extend(b)\n    i = self.search(a)[1]\n    maxi = len(self._list) + 1\n    while i < maxi:\n        p = self._list[i - 1]\n        if p < b:\n            yield p\n            i += 1\n        else:\n            return",
    ".sympy.functions.elementary.integers.py@@RoundFunction.eval": "def eval(cls, arg):\n    from sympy import im\n    if arg.is_integer or arg.is_finite is False:\n        return arg\n    if arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        i = im(arg)\n        if not i.has(S.ImaginaryUnit):\n            return cls(i) * S.ImaginaryUnit\n        return cls(arg, evaluate=False)\n    v = cls._eval_number(arg)\n    if v is not None:\n        return v\n    ipart = npart = spart = S.Zero\n    terms = Add.make_args(arg)\n    for t in terms:\n        if t.is_integer or (t.is_imaginary and im(t).is_integer):\n            ipart += t\n        elif t.has(Symbol):\n            spart += t\n        else:\n            npart += t\n    if not (npart or spart):\n        return ipart\n    if npart and (not spart or (npart.is_real and (spart.is_imaginary or (S.ImaginaryUnit * spart).is_real)) or (npart.is_imaginary and spart.is_real)):\n        try:\n            r, i = get_integer_part(npart, cls._dir, {}, return_ints=True)\n            ipart += Integer(r) + Integer(i) * S.ImaginaryUnit\n            npart = S.Zero\n        except (PrecisionExhausted, NotImplementedError):\n            pass\n    spart += npart\n    if not spart:\n        return ipart\n    elif spart.is_imaginary or (S.ImaginaryUnit * spart).is_real:\n        return ipart + cls(im(spart), evaluate=False) * S.ImaginaryUnit\n    else:\n        return ipart + cls(spart, evaluate=False)",
    ".sympy.ntheory.generate.py@@Sieve.extend": "def extend(self, n):\n    n = int(n)\n    if n <= self._list[-1]:\n        return\n    maxbase = int(n ** 0.5) + 1\n    self.extend(maxbase)\n    begin = self._list[-1] + 1\n    newsieve = _arange(begin, n + 1)\n    for p in self.primerange(2, maxbase):\n        startindex = -begin % p\n        for i in range(startindex, len(newsieve), p):\n            newsieve[i] = 0\n    self._list += _array('l', [x for x in newsieve if x])",
    ".sympy.ntheory.generate.py@@Sieve.search": "def search(self, n):\n    from sympy.functions.elementary.integers import ceiling\n    test = as_int(ceiling(n))\n    n = as_int(n)\n    if n < 2:\n        raise ValueError('n should be >= 2 but got: %s' % n)\n    if n > self._list[-1]:\n        self.extend(n)\n    b = bisect(self._list, n)\n    if self._list[b - 1] == test:\n        return (b, b)\n    else:\n        return (b, b + 1)",
    ".sympy.ntheory.factor_.py@@trailing": "def trailing(n):\n    n = abs(int(n))\n    if not n:\n        return 0\n    low_byte = n & 255\n    if low_byte:\n        return small_trailing[low_byte]\n    z = bitcount(n) - 1\n    if isinstance(z, SYMPY_INTS):\n        if n == 1 << z:\n            return z\n    t = 0\n    p = 8\n    while not n & 1:\n        while not n & (1 << p) - 1:\n            n >>= p\n            t += p\n            p *= 2\n        p //= 2\n    return t",
    ".sympy.core.expr.py@@Expr.__rmul__": "def __rmul__(self, other):\n    return Mul(other, self)",
    ".sympy.core.numbers.py@@Rational.as_numer_denom": "def as_numer_denom(self):\n    return (Integer(self.p), Integer(self.q))",
    ".sympy.core.numbers.py@@Integer.__divmod__": "def __divmod__(self, other):\n    from .containers import Tuple\n    if isinstance(other, Integer) and global_evaluate[0]:\n        return Tuple(*divmod(self.p, other.p))\n    else:\n        return Number.__divmod__(self, other)",
    ".sympy.core.numbers.py@@Integer.__mod__": "def __mod__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p % other)\n        elif isinstance(other, Integer):\n            return Integer(self.p % other.p)\n        return Rational.__mod__(self, other)\n    return Rational.__mod__(self, other)",
    ".sympy.core.exprtools.py@@factor_terms": "def factor_terms(expr, radical=False, clear=False, fraction=False, sign=True):\n\n    def do(expr):\n        from sympy.concrete.summations import Sum\n        from sympy.simplify.simplify import factor_sum\n        is_iterable = iterable(expr)\n        if not isinstance(expr, Basic) or expr.is_Atom:\n            if is_iterable:\n                return type(expr)([do(i) for i in expr])\n            return expr\n        if expr.is_Pow or expr.is_Function or is_iterable or (not hasattr(expr, 'args_cnc')):\n            args = expr.args\n            newargs = tuple([do(i) for i in args])\n            if newargs == args:\n                return expr\n            return expr.func(*newargs)\n        if isinstance(expr, Sum):\n            return factor_sum(expr, radical=radical, clear=clear, fraction=fraction, sign=sign)\n        cont, p = expr.as_content_primitive(radical=radical, clear=clear)\n        if p.is_Add:\n            list_args = [do(a) for a in Add.make_args(p)]\n            if all((a.as_coeff_Mul()[0].extract_multiplicatively(-1) is not None for a in list_args)):\n                cont = -cont\n                list_args = [-a for a in list_args]\n            special = {}\n            for i, a in enumerate(list_args):\n                b, e = a.as_base_exp()\n                if e.is_Mul and e != Mul(*e.args):\n                    list_args[i] = Dummy()\n                    special[list_args[i]] = a\n            p = Add._from_args(list_args)\n            p = gcd_terms(p, isprimitive=True, clear=clear, fraction=fraction).xreplace(special)\n        elif p.args:\n            p = p.func(*[do(a) for a in p.args])\n        rv = _keep_coeff(cont, p, clear=clear, sign=sign)\n        return rv\n    expr = sympify(expr)\n    return do(expr)",
    ".sympy.core.exprtools.py@@do": "def do(expr):\n    from sympy.concrete.summations import Sum\n    from sympy.simplify.simplify import factor_sum\n    is_iterable = iterable(expr)\n    if not isinstance(expr, Basic) or expr.is_Atom:\n        if is_iterable:\n            return type(expr)([do(i) for i in expr])\n        return expr\n    if expr.is_Pow or expr.is_Function or is_iterable or (not hasattr(expr, 'args_cnc')):\n        args = expr.args\n        newargs = tuple([do(i) for i in args])\n        if newargs == args:\n            return expr\n        return expr.func(*newargs)\n    if isinstance(expr, Sum):\n        return factor_sum(expr, radical=radical, clear=clear, fraction=fraction, sign=sign)\n    cont, p = expr.as_content_primitive(radical=radical, clear=clear)\n    if p.is_Add:\n        list_args = [do(a) for a in Add.make_args(p)]\n        if all((a.as_coeff_Mul()[0].extract_multiplicatively(-1) is not None for a in list_args)):\n            cont = -cont\n            list_args = [-a for a in list_args]\n        special = {}\n        for i, a in enumerate(list_args):\n            b, e = a.as_base_exp()\n            if e.is_Mul and e != Mul(*e.args):\n                list_args[i] = Dummy()\n                special[list_args[i]] = a\n        p = Add._from_args(list_args)\n        p = gcd_terms(p, isprimitive=True, clear=clear, fraction=fraction).xreplace(special)\n    elif p.args:\n        p = p.func(*[do(a) for a in p.args])\n    rv = _keep_coeff(cont, p, clear=clear, sign=sign)\n    return rv",
    ".sympy.core.mul.py@@Mul.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    coef = S.One\n    args = []\n    for i, a in enumerate(self.args):\n        c, p = a.as_content_primitive(radical=radical, clear=clear)\n        coef *= c\n        if p is not S.One:\n            args.append(p)\n    return (coef, self.func(*args))",
    ".sympy.core.numbers.py@@Rational.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    if self:\n        if self.is_positive:\n            return (self, S.One)\n        return (-self, S.NegativeOne)\n    return (S.One, self)",
    ".sympy.core.expr.py@@Expr.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    return (S.One, self)",
    ".sympy.core.power.py@@Pow.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    b, e = self.as_base_exp()\n    b = _keep_coeff(*b.as_content_primitive(radical=radical, clear=clear))\n    ce, pe = e.as_content_primitive(radical=radical, clear=clear)\n    if b.is_Rational:\n        h, t = pe.as_coeff_Add()\n        if h.is_Rational:\n            ceh = ce * h\n            c = self.func(b, ceh)\n            r = S.Zero\n            if not c.is_Rational:\n                iceh, r = divmod(ceh.p, ceh.q)\n                c = self.func(b, iceh)\n            return (c, self.func(b, _keep_coeff(ce, t + r / ce / ceh.q)))\n    e = _keep_coeff(ce, pe)\n    if e.is_Rational and b.is_Mul:\n        h, t = b.as_content_primitive(radical=radical, clear=clear)\n        c, m = self.func(h, e).as_coeff_Mul()\n        m, me = m.as_base_exp()\n        if m is S.One or me == e:\n            return (c, self.func(_keep_coeff(m, t), e))\n    return (S.One, self.func(b, e))",
    ".sympy.core.numbers.py@@Rational._eval_power": "def _eval_power(self, expt):\n    if isinstance(expt, Number):\n        if isinstance(expt, Float):\n            return self._eval_evalf(expt._prec) ** expt\n        if expt.is_negative:\n            ne = -expt\n            if ne is S.One:\n                return Rational(self.q, self.p)\n            if self.is_negative:\n                return S.NegativeOne ** expt * Rational(self.q, -self.p) ** ne\n            else:\n                return Rational(self.q, self.p) ** ne\n        if expt is S.Infinity:\n            if self.p > self.q:\n                return S.Infinity\n            if self.p < -self.q:\n                return S.Infinity + S.Infinity * S.ImaginaryUnit\n            return S.Zero\n        if isinstance(expt, Integer):\n            return Rational(self.p ** expt.p, self.q ** expt.p, 1)\n        if isinstance(expt, Rational):\n            if self.p != 1:\n                return Integer(self.p) ** expt * Integer(self.q) ** (-expt)\n            return Integer(self.q) ** Rational(expt.p * (expt.q - 1), expt.q) / Integer(self.q) ** Integer(expt.p)\n    if self.is_negative and expt.is_even:\n        return (-self) ** expt\n    return",
    ".sympy.polys.polyroots.py@@_update_dict": "def _update_dict(result, root, k):\n    if root in result:\n        result[root] += k\n    else:\n        result[root] = k",
    ".sympy.core.expr.py@@Expr.sort_key": "def sort_key(self, order=None):\n    coeff, expr = self.as_coeff_Mul()\n    if expr.is_Pow:\n        expr, exp = expr.args\n    else:\n        expr, exp = (expr, S.One)\n    if expr.is_Dummy:\n        args = (expr.sort_key(),)\n    elif expr.is_Atom:\n        args = (str(expr),)\n    else:\n        if expr.is_Add:\n            args = expr.as_ordered_terms(order=order)\n        elif expr.is_Mul:\n            args = expr.as_ordered_factors(order=order)\n        else:\n            args = expr.args\n        args = tuple([default_sort_key(arg, order=order) for arg in args])\n    args = (len(args), tuple(args))\n    exp = exp.sort_key(order=order)\n    return (expr.class_key(), args, exp, coeff)",
    ".sympy.core.expr.py@@Expr.as_ordered_terms": "def as_ordered_terms(self, order=None, data=False):\n    key, reverse = self._parse_order(order)\n    terms, gens = self.as_terms()\n    if not any((term.is_Order for term, _ in terms)):\n        ordered = sorted(terms, key=key, reverse=reverse)\n    else:\n        _terms, _order = ([], [])\n        for term, repr in terms:\n            if not term.is_Order:\n                _terms.append((term, repr))\n            else:\n                _order.append((term, repr))\n        ordered = sorted(_terms, key=key, reverse=True) + sorted(_order, key=key, reverse=True)\n    if data:\n        return (ordered, gens)\n    else:\n        return [term for term, _ in ordered]",
    ".sympy.core.expr.py@@Expr._parse_order": "def _parse_order(cls, order):\n    from sympy.polys.orderings import monomial_key\n    try:\n        reverse = order.startswith('rev-')\n    except AttributeError:\n        reverse = False\n    else:\n        if reverse:\n            order = order[4:]\n    monom_key = monomial_key(order)\n\n    def neg(monom):\n        result = []\n        for m in monom:\n            if isinstance(m, tuple):\n                result.append(neg(m))\n            else:\n                result.append(-m)\n        return tuple(result)\n\n    def key(term):\n        _, ((re, im), monom, ncpart) = term\n        monom = neg(monom_key(monom))\n        ncpart = tuple([e.sort_key(order=order) for e in ncpart])\n        coeff = ((bool(im), im), (re, im))\n        return (monom, ncpart, coeff)\n    return (key, reverse)",
    ".sympy.core.expr.py@@Expr.as_terms": "def as_terms(self):\n    from .add import Add\n    from .mul import Mul\n    from .exprtools import decompose_power\n    gens, terms = (set([]), [])\n    for term in Add.make_args(self):\n        coeff, _term = term.as_coeff_Mul()\n        coeff = complex(coeff)\n        cpart, ncpart = ({}, [])\n        if _term is not S.One:\n            for factor in Mul.make_args(_term):\n                if factor.is_number:\n                    try:\n                        coeff *= complex(factor)\n                    except TypeError:\n                        pass\n                    else:\n                        continue\n                if factor.is_commutative:\n                    base, exp = decompose_power(factor)\n                    cpart[base] = exp\n                    gens.add(base)\n                else:\n                    ncpart.append(factor)\n        coeff = (coeff.real, coeff.imag)\n        ncpart = tuple(ncpart)\n        terms.append((term, (coeff, cpart, ncpart)))\n    gens = sorted(gens, key=default_sort_key)\n    k, indices = (len(gens), {})\n    for i, g in enumerate(gens):\n        indices[g] = i\n    result = []\n    for term, (coeff, cpart, ncpart) in terms:\n        monom = [0] * k\n        for base, exp in cpart.items():\n            monom[indices[base]] = exp\n        result.append((term, (coeff, tuple(monom), ncpart)))\n    return (result, gens)",
    ".sympy.core.expr.py@@Expr.__complex__": "def __complex__(self):\n    result = self.evalf()\n    re, im = result.as_real_imag()\n    return complex(float(re), float(im))",
    ".sympy.core.numbers.py@@Number.__float__": "def __float__(self):\n    return mlib.to_float(self._as_mpf_val(53))",
    ".sympy.core.numbers.py@@Float._as_mpf_val": "def _as_mpf_val(self, prec):\n    rv = mpf_norm(self._mpf_, prec)\n    if rv != self._mpf_ and self._prec == prec:\n        debug(self._mpf_, rv)\n    return rv",
    ".sympy.core.numbers.py@@Float._eval_is_finite": "def _eval_is_finite(self):\n    if self._mpf_ in (_mpf_inf, _mpf_ninf):\n        return False\n    return True",
    ".sympy.core.expr.py@@Expr.key": "def key(term):\n    _, ((re, im), monom, ncpart) = term\n    monom = neg(monom_key(monom))\n    ncpart = tuple([e.sort_key(order=order) for e in ncpart])\n    coeff = ((bool(im), im), (re, im))\n    return (monom, ncpart, coeff)",
    ".sympy.core.expr.py@@Expr.neg": "def neg(monom):\n    result = []\n    for m in monom:\n        if isinstance(m, tuple):\n            result.append(neg(m))\n        else:\n            result.append(-m)\n    return tuple(result)",
    ".sympy.core.mul.py@@Mul.as_ordered_factors": "def as_ordered_factors(self, order=None):\n    cpart, ncpart = self.args_cnc()\n    cpart.sort(key=lambda expr: expr.sort_key(order=order))\n    return cpart + ncpart",
    ".sympy.core.basic.py@@Atom.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One)",
    ".sympy.printing.str.py@@StrPrinter._print_ImaginaryUnit": "def _print_ImaginaryUnit(self, expr):\n    return 'I'",
    ".sympy.printing.str.py@@StrPrinter._print_Integer": "def _print_Integer(self, expr):\n    if self._settings.get('sympy_integers', False):\n        return 'S(%s)' % expr\n    return str(expr.p)",
    ".sympy.core.mul.py@@Mul.class_key": "def class_key(cls):\n    return (3, 0, cls.__name__)",
    ".sympy.core.add.py@@Add.class_key": "def class_key(cls):\n    return (3, 1, cls.__name__)",
    ".sympy.core.numbers.py@@Rational.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    if other.is_NumberSymbol:\n        return other.__gt__(self)\n    expr = self\n    if other.is_Number:\n        if other.is_Rational:\n            return _sympify(bool(self.p * other.q < self.q * other.p))\n        if other.is_Float:\n            return _sympify(bool(mlib.mpf_lt(self._as_mpf_val(other._prec), other._mpf_)))\n    elif other.is_number and other.is_real:\n        expr, other = (Integer(self.p), self.q * other)\n    return Expr.__lt__(expr, other)",
    ".sympy.core.mul.py@@Mul._eval_subs": "def _eval_subs(self, old, new):\n    from sympy.functions.elementary.complexes import sign\n    from sympy.ntheory.factor_ import multiplicity\n    from sympy.simplify.powsimp import powdenest\n    from sympy.simplify.radsimp import fraction\n    if not old.is_Mul:\n        return None\n    if old.args[0].is_Number and old.args[0] < 0:\n        if self.args[0].is_Number:\n            if self.args[0] < 0:\n                return self._subs(-old, -new)\n            return None\n\n    def base_exp(a):\n        from sympy import exp\n        if a.is_Pow or isinstance(a, exp):\n            return a.as_base_exp()\n        return (a, S.One)\n\n    def breakup(eq):\n        c, nc = (defaultdict(int), list())\n        for a in Mul.make_args(eq):\n            a = powdenest(a)\n            b, e = base_exp(a)\n            if e is not S.One:\n                co, _ = e.as_coeff_mul()\n                b = Pow(b, e / co)\n                e = co\n            if a.is_commutative:\n                c[b] += e\n            else:\n                nc.append([b, e])\n        return (c, nc)\n\n    def rejoin(b, co):\n        b, e = base_exp(b)\n        return Pow(b, e * co)\n\n    def ndiv(a, b):\n        if not b.q % a.q or not a.q % b.q:\n            return int(a / b)\n        return 0\n    rv = None\n    n, d = fraction(self)\n    self2 = self\n    if d is not S.One:\n        self2 = n._subs(old, new) / d._subs(old, new)\n        if not self2.is_Mul:\n            return self2._subs(old, new)\n        if self2 != self:\n            rv = self2\n    co_self = self2.args[0]\n    co_old = old.args[0]\n    co_xmul = None\n    if co_old.is_Rational and co_self.is_Rational:\n        if co_old != co_self:\n            co_xmul = co_self.extract_multiplicatively(co_old)\n    elif co_old.is_Rational:\n        return rv\n    c, nc = breakup(self2)\n    old_c, old_nc = breakup(old)\n    if co_xmul and co_xmul.is_Rational and (abs(co_old) != 1):\n        mult = S(multiplicity(abs(co_old), co_self))\n        c.pop(co_self)\n        if co_old in c:\n            c[co_old] += mult\n        else:\n            c[co_old] = mult\n        co_residual = co_self / co_old ** mult\n    else:\n        co_residual = 1\n    ok = True\n    if len(old_nc) > len(nc):\n        ok = False\n    elif len(old_c) > len(c):\n        ok = False\n    elif set((i[0] for i in old_nc)).difference(set((i[0] for i in nc))):\n        ok = False\n    elif set(old_c).difference(set(c)):\n        ok = False\n    elif any((sign(c[b]) != sign(old_c[b]) for b in old_c)):\n        ok = False\n    if not ok:\n        return rv\n    if not old_c:\n        cdid = None\n    else:\n        rat = []\n        for b, old_e in old_c.items():\n            c_e = c[b]\n            rat.append(ndiv(c_e, old_e))\n            if not rat[-1]:\n                return rv\n        cdid = min(rat)\n    if not old_nc:\n        ncdid = None\n        for i in range(len(nc)):\n            nc[i] = rejoin(*nc[i])\n    else:\n        ncdid = 0\n        take = len(old_nc)\n        limit = cdid or S.Infinity\n        failed = []\n        i = 0\n        while limit and i + take <= len(nc):\n            hit = False\n            rat = []\n            for j in range(take):\n                if nc[i + j][0] != old_nc[j][0]:\n                    break\n                elif j == 0:\n                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n                elif j == take - 1:\n                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n                elif nc[i + j][1] != old_nc[j][1]:\n                    break\n                else:\n                    rat.append(1)\n                j += 1\n            else:\n                ndo = min(rat)\n                if ndo:\n                    if take == 1:\n                        if cdid:\n                            ndo = min(cdid, ndo)\n                        nc[i] = Pow(new, ndo) * rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])\n                    else:\n                        ndo = 1\n                        l = rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])\n                        mid = new\n                        ir = i + take - 1\n                        r = (nc[ir][0], nc[ir][1] - ndo * old_nc[-1][1])\n                        if r[1]:\n                            if i + take < len(nc):\n                                nc[i:i + take] = [l * mid, r]\n                            else:\n                                r = rejoin(*r)\n                                nc[i:i + take] = [l * mid * r]\n                        else:\n                            nc[i:i + take] = [l * mid]\n                    limit -= ndo\n                    ncdid += ndo\n                    hit = True\n            if not hit:\n                failed.append(i)\n            i += 1\n        else:\n            if not ncdid:\n                return rv\n            failed.extend(range(i, len(nc)))\n            for i in failed:\n                nc[i] = rejoin(*nc[i]).subs(old, new)\n    if cdid is None:\n        do = ncdid\n    elif ncdid is None:\n        do = cdid\n    else:\n        do = min(ncdid, cdid)\n    margs = []\n    for b in c:\n        if b in old_c:\n            e = c[b] - old_c[b] * do\n            margs.append(rejoin(b, e))\n        else:\n            margs.append(rejoin(b.subs(old, new), c[b]))\n    if cdid and (not ncdid):\n        margs = [Pow(new, cdid)] + margs\n    return co_residual * self2.func(*margs) * self2.func(*nc)",
    ".sympy.core.numbers.py@@Rational.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.numbers.py@@Rational.__neg__": "def __neg__(self):\n    return Rational(-self.p, self.q)",
    ".sympy.core.evalf.py@@fastlog": "def fastlog(x):\n    if not x or x == fzero:\n        return MINUS_INF\n    return x[2] + x[3]",
    ".sympy.core.evalf.py@@finalize_complex": "def finalize_complex(re, im, prec):\n    if re == fzero and im == fzero:\n        raise ValueError('got complex zero with unknown accuracy')\n    elif re == fzero:\n        return (None, im, None, prec)\n    elif im == fzero:\n        return (re, None, prec, None)\n    size_re = fastlog(re)\n    size_im = fastlog(im)\n    if size_re > size_im:\n        re_acc = prec\n        im_acc = prec + min(-(size_re - size_im), 0)\n    else:\n        im_acc = prec\n        re_acc = prec + min(-(size_im - size_re), 0)\n    return (re, im, re_acc, im_acc)",
    ".sympy.core.evalf.py@@scaled_zero": "def scaled_zero(mag, sign=1):\n    if type(mag) is tuple and len(mag) == 4 and iszero(mag, scaled=True):\n        return (mag[0][0],) + mag[1:]\n    elif isinstance(mag, SYMPY_INTS):\n        if sign not in [-1, 1]:\n            raise ValueError('sign must be +/-1')\n        rv, p = (mpf_shift(fone, mag), -1)\n        s = 0 if sign == 1 else 1\n        rv = ([s],) + rv[1:]\n        return (rv, p)\n    else:\n        raise ValueError('scaled zero expects int or scaled_zero tuple.')",
    ".sympy.core.evalf.py@@chop_parts": "def chop_parts(value, prec):\n    re, im, re_acc, im_acc = value\n    if re and re not in _infs_nan and (fastlog(re) < -prec + 4):\n        re, re_acc = (None, None)\n    if im and im not in _infs_nan and (fastlog(im) < -prec + 4):\n        im, im_acc = (None, None)\n    if re and im:\n        delta = fastlog(re) - fastlog(im)\n        if re_acc < 2 and delta - re_acc <= -prec + 4:\n            re, re_acc = (None, None)\n        if im_acc < 2 and delta - im_acc >= prec - 4:\n            im, im_acc = (None, None)\n    return (re, im, re_acc, im_acc)",
    ".sympy.core.numbers.py@@Zero.__abs__": "def __abs__():\n    return S.Zero",
    ".sympy.core.numbers.py@@Float.__new__": "def __new__(cls, num, dps=None, prec=None, precision=None):\n    if prec is not None:\n        SymPyDeprecationWarning(feature=\"Using 'prec=XX' to denote decimal precision\", useinstead=\"'dps=XX' for decimal precision and 'precision=XX' for binary precision\", issue=12820, deprecated_since_version='1.1').warn()\n        dps = prec\n    del prec\n    if dps is not None and precision is not None:\n        raise ValueError('Both decimal and binary precision supplied. Supply only one. ')\n    if isinstance(num, string_types):\n        num = num.replace(' ', '')\n        if num.startswith('.') and len(num) > 1:\n            num = '0' + num\n        elif num.startswith('-.') and len(num) > 2:\n            num = '-0.' + num[2:]\n    elif isinstance(num, float) and num == 0:\n        num = '0'\n    elif isinstance(num, (SYMPY_INTS, Integer)):\n        num = str(num)\n    elif num is S.Infinity:\n        num = '+inf'\n    elif num is S.NegativeInfinity:\n        num = '-inf'\n    elif type(num).__module__ == 'numpy':\n        num = _convert_numpy_types(num)\n    elif isinstance(num, mpmath.mpf):\n        if precision is None:\n            if dps is None:\n                precision = num.context.prec\n        num = num._mpf_\n    if dps is None and precision is None:\n        dps = 15\n        if isinstance(num, Float):\n            return num\n        if isinstance(num, string_types) and _literal_float(num):\n            try:\n                Num = decimal.Decimal(num)\n            except decimal.InvalidOperation:\n                pass\n            else:\n                isint = '.' not in num\n                num, dps = _decimal_to_Rational_prec(Num)\n                if num.is_Integer and isint:\n                    dps = max(dps, len(str(num).lstrip('-')))\n                dps = max(15, dps)\n                precision = mlib.libmpf.dps_to_prec(dps)\n    elif precision == '' and dps is None or (precision is None and dps == ''):\n        if not isinstance(num, string_types):\n            raise ValueError('The null string can only be used when the number to Float is passed as a string or an integer.')\n        ok = None\n        if _literal_float(num):\n            try:\n                Num = decimal.Decimal(num)\n            except decimal.InvalidOperation:\n                pass\n            else:\n                isint = '.' not in num\n                num, dps = _decimal_to_Rational_prec(Num)\n                if num.is_Integer and isint:\n                    dps = max(dps, len(str(num).lstrip('-')))\n                    precision = mlib.libmpf.dps_to_prec(dps)\n                ok = True\n        if ok is None:\n            raise ValueError('string-float not recognized: %s' % num)\n    if precision is None or precision == '':\n        precision = mlib.libmpf.dps_to_prec(dps)\n    precision = int(precision)\n    if isinstance(num, float):\n        _mpf_ = mlib.from_float(num, precision, rnd)\n    elif isinstance(num, string_types):\n        _mpf_ = mlib.from_str(num, precision, rnd)\n    elif isinstance(num, decimal.Decimal):\n        if num.is_finite():\n            _mpf_ = mlib.from_str(str(num), precision, rnd)\n        elif num.is_nan():\n            _mpf_ = _mpf_nan\n        elif num.is_infinite():\n            if num > 0:\n                _mpf_ = _mpf_inf\n            else:\n                _mpf_ = _mpf_ninf\n        else:\n            raise ValueError('unexpected decimal value %s' % str(num))\n    elif isinstance(num, tuple) and len(num) in (3, 4):\n        if type(num[1]) is str:\n            num = list(num)\n            if num[1].endswith('L'):\n                num[1] = num[1][:-1]\n            num[1] = MPZ(num[1], 16)\n            _mpf_ = tuple(num)\n        elif len(num) == 4:\n            return Float._new(num, precision)\n        else:\n            return (S.NegativeOne ** num[0] * num[1] * S(2) ** num[2]).evalf(precision)\n    else:\n        try:\n            _mpf_ = num._as_mpf_val(precision)\n        except (NotImplementedError, AttributeError):\n            _mpf_ = mpmath.mpf(num, prec=precision)._mpf_\n    if _mpf_ == _mpf_zero:\n        pass\n    elif _mpf_ == _mpf_nan:\n        return S.NaN\n    obj = Expr.__new__(cls)\n    obj._mpf_ = _mpf_\n    obj._prec = precision\n    return obj",
    ".sympy.core.numbers.py@@Number._eval_is_finite": "def _eval_is_finite(self):\n    return True",
    ".sympy.core.numbers.py@@Integer._eval_is_odd": "def _eval_is_odd(self):\n    return bool(self.p % 2)",
    ".sympy.core.numbers.py@@Rational._eval_is_zero": "def _eval_is_zero(self):\n    return self.p == 0",
    ".sympy.polys.polytools.py@@Poly.termwise": "def termwise(f, func, *gens, **args):\n    terms = {}\n    for monom, coeff in f.terms():\n        result = func(monom, coeff)\n        if isinstance(result, tuple):\n            monom, coeff = result\n        else:\n            coeff = result\n        if coeff:\n            if monom not in terms:\n                terms[monom] = coeff\n            else:\n                raise PolynomialError('%s monomial was generated twice' % monom)\n    return f.from_dict(terms, *(gens or f.gens), **args)",
    ".sympy.polys.polyroots.py@@func": "def func(k, coeff):\n    return coeff // basis ** (n - k[0])",
    ".sympy.core.numbers.py@@Integer.__floordiv__": "def __floordiv__(self, other):\n    return Integer(self.p // Integer(other).p)",
    ".sympy.ntheory.generate.py@@nextprime": "def nextprime(n, ith=1):\n    n = int(n)\n    i = as_int(ith)\n    if i > 1:\n        pr = n\n        j = 1\n        while 1:\n            pr = nextprime(pr)\n            j += 1\n            if j > i:\n                break\n        return pr\n    if n < 2:\n        return 2\n    if n < 7:\n        return {2: 3, 3: 5, 4: 5, 5: 7, 6: 7}[n]\n    if n <= sieve._list[-2]:\n        l, u = sieve.search(n)\n        if l == u:\n            return sieve[u + 1]\n        else:\n            return sieve[u]\n    nn = 6 * (n // 6)\n    if nn == n:\n        n += 1\n        if isprime(n):\n            return n\n        n += 4\n    elif n - nn == 5:\n        n += 2\n        if isprime(n):\n            return n\n        n += 4\n    else:\n        n = nn + 5\n    while 1:\n        if isprime(n):\n            return n\n        n += 2\n        if isprime(n):\n            return n\n        n += 4",
    ".sympy.ntheory.factor_.py@@primefactors": "def primefactors(n, limit=None, verbose=False):\n    n = int(n)\n    factors = sorted(factorint(n, limit=limit, verbose=verbose).keys())\n    s = [f for f in factors[:-1] if f not in [-1, 0, 1]]\n    if factors and isprime(factors[-1]):\n        s += [factors[-1]]\n    return s",
    ".sympy.ntheory.factor_.py@@multiplicity": "def multiplicity(p, n):\n    try:\n        p, n = (as_int(p), as_int(n))\n    except ValueError:\n        if all((isinstance(i, (SYMPY_INTS, Rational)) for i in (p, n))):\n            try:\n                p = Rational(p)\n                n = Rational(n)\n                if p.q == 1:\n                    if n.p == 1:\n                        return -multiplicity(p.p, n.q)\n                    return S.Zero\n                elif p.p == 1:\n                    return multiplicity(p.q, n.q)\n                else:\n                    like = min(multiplicity(p.p, n.p), multiplicity(p.q, n.q))\n                    cross = min(multiplicity(p.q, n.p), multiplicity(p.p, n.q))\n                    return like - cross\n            except AttributeError:\n                pass\n        raise ValueError('expecting ints or fractions, got %s and %s' % (p, n))\n    if n == 0:\n        raise ValueError('no such integer exists: multiplicity of %s is not-defined' % n)\n    if p == 2:\n        return trailing(n)\n    if p < 2:\n        raise ValueError('p must be an integer, 2 or larger, but got %s' % p)\n    if p == n:\n        return 1\n    m = 0\n    n, rem = divmod(n, p)\n    while not rem:\n        m += 1\n        if m > 5:\n            e = 2\n            while 1:\n                ppow = p ** e\n                if ppow < n:\n                    nnew, rem = divmod(n, ppow)\n                    if not rem:\n                        m += e\n                        e *= 2\n                        n = nnew\n                        continue\n                return m + multiplicity(p, n)\n        n, rem = divmod(n, p)\n    return m",
    ".sympy.ntheory.factor_.py@@_factorint_small": "def _factorint_small(factors, n, limit, fail_max):\n\n    def done(n, d):\n        if d * d <= n:\n            return (n, d)\n        return (n, 0)\n    d = 2\n    m = trailing(n)\n    if m:\n        factors[d] = m\n        n >>= m\n    d = 3\n    if limit < d:\n        if n > 1:\n            factors[n] = 1\n        return done(n, d)\n    m = 0\n    while n % d == 0:\n        n //= d\n        m += 1\n        if m == 20:\n            mm = multiplicity(d, n)\n            m += mm\n            n //= d ** mm\n            break\n    if m:\n        factors[d] = m\n    if limit * limit > n:\n        maxx = 0\n    else:\n        maxx = limit * limit\n    dd = maxx or n\n    d = 5\n    fails = 0\n    while fails < fail_max:\n        if d * d > dd:\n            break\n        m = 0\n        while n % d == 0:\n            n //= d\n            m += 1\n            if m == 20:\n                mm = multiplicity(d, n)\n                m += mm\n                n //= d ** mm\n                break\n        if m:\n            factors[d] = m\n            dd = maxx or n\n            fails = 0\n        else:\n            fails += 1\n        d += 2\n        if d * d > dd:\n            break\n        m = 0\n        while n % d == 0:\n            n //= d\n            m += 1\n            if m == 20:\n                mm = multiplicity(d, n)\n                m += mm\n                n //= d ** mm\n                break\n        if m:\n            factors[d] = m\n            dd = maxx or n\n            fails = 0\n        else:\n            fails += 1\n        d += 4\n    return done(n, d)",
    ".sympy.ntheory.factor_.py@@done": "def done(n, d):\n    if d * d <= n:\n        return (n, d)\n    return (n, 0)",
    ".sympy.core.numbers.py@@Rational._eval_is_positive": "def _eval_is_positive(self):\n    return self.p > 0",
    ".sympy.core.mul.py@@Mul._eval_power": "def _eval_power(b, e):\n    cargs, nc = b.args_cnc(split_1=False)\n    if e.is_Integer:\n        return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * Pow(Mul._from_args(nc), e, evaluate=False)\n    if e.is_Rational and e.q == 2:\n        from sympy.core.power import integer_nthroot\n        from sympy.functions.elementary.complexes import sign\n        if b.is_imaginary:\n            a = b.as_real_imag()[1]\n            if a.is_Rational:\n                n, d = abs(a / 2).as_numer_denom()\n                n, t = integer_nthroot(n, 2)\n                if t:\n                    d, t = integer_nthroot(d, 2)\n                    if t:\n                        r = sympify(n) / d\n                        return _unevaluated_Mul(r ** e.p, (1 + sign(a) * S.ImaginaryUnit) ** e.p)\n    p = Pow(b, e, evaluate=False)\n    if e.is_Rational or e.is_Float:\n        return p._eval_expand_power_base()\n    return p",
    ".sympy.core.power.py@@Pow._eval_power": "def _eval_power(self, other):\n    from sympy import Abs, arg, exp, floor, im, log, re, sign\n    b, e = self.as_base_exp()\n    if b is S.NaN:\n        return (b ** e) ** other\n    s = None\n    if other.is_integer:\n        s = 1\n    elif b.is_polar:\n        s = 1\n    elif e.is_real is not None:\n\n        def _half(e):\n            if getattr(e, 'q', None) == 2:\n                return True\n            n, d = e.as_numer_denom()\n            if n.is_integer and d == 2:\n                return True\n\n        def _n2(e):\n            try:\n                rv = e.evalf(2, strict=True)\n                if rv.is_Number:\n                    return rv\n            except PrecisionExhausted:\n                pass\n        if e.is_real:\n            if e == -1:\n                if _half(other):\n                    if b.is_negative is True:\n                        return S.NegativeOne ** other * Pow(-b, e * other)\n                    if b.is_real is False:\n                        return Pow(b.conjugate() / Abs(b) ** 2, other)\n            elif e.is_even:\n                if b.is_real:\n                    b = abs(b)\n                if b.is_imaginary:\n                    b = abs(im(b)) * S.ImaginaryUnit\n            if (abs(e) < 1) == True or e == 1:\n                s = 1\n            elif b.is_nonnegative:\n                s = 1\n            elif re(b).is_nonnegative and (abs(e) < 2) == True:\n                s = 1\n            elif fuzzy_not(im(b).is_zero) and abs(e) == 2:\n                s = 1\n            elif _half(other):\n                s = exp(2 * S.Pi * S.ImaginaryUnit * other * floor(S.Half - e * arg(b) / (2 * S.Pi)))\n                if s.is_real and _n2(sign(s) - s) == 0:\n                    s = sign(s)\n                else:\n                    s = None\n        else:\n            try:\n                s = exp(2 * S.ImaginaryUnit * S.Pi * other * floor(S.Half - im(e * log(b)) / 2 / S.Pi))\n                if s.is_real and _n2(sign(s) - s) == 0:\n                    s = sign(s)\n                else:\n                    s = None\n            except PrecisionExhausted:\n                s = None\n    if s is not None:\n        return s * Pow(b, e * other)"
}