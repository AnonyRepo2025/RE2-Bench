{
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self) -> int:\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.expr.py@@Expr._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.decorators.py@@__sympifyit_wrapper": "def __sympifyit_wrapper(a, b):\n    try:\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    cls = getattr(a, '__class__', None)\n    for superclass in getmro(cls):\n        conv = _external_converter.get(superclass)\n        if conv is None:\n            conv = _sympy_converter.get(superclass)\n        if conv is not None:\n            return conv(a)\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from sympy.tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(), locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        else:\n            for coerce in (float, int):\n                try:\n                    return sympify(coerce(a))\n                except (TypeError, ValueError, AttributeError, SympifyError):\n                    continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational, evaluate=evaluate) for x in a])\n        except TypeError:\n            pass\n    if not isinstance(a, str):\n        try:\n            a = str(a)\n        except Exception as exc:\n            raise SympifyError(a, exc)\n        SymPyDeprecationWarning(feature='String fallback in sympify', useinstead='sympify(str(obj)) or ' + 'sympy.core.sympify.converter or obj._sympy_', issue=18066, deprecated_since_version='1.6').warn()\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, str):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    if ival == 1:\n        return S.One\n    if ival == -1:\n        return S.NegativeOne\n    if ival == 0:\n        return S.Zero\n    obj = Expr.__new__(cls)\n    obj.p = ival\n    return obj",
    ".sympy.core.numbers.py@@Rational.__rtruediv__": "def __rtruediv__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(other.p * self.q, self.p, igcd(self.p, other.p))\n        elif isinstance(other, Rational):\n            return Rational(other.p * self.q, other.q * self.p, igcd(self.p, other.p) * igcd(self.q, other.q))\n        elif isinstance(other, Float):\n            return other * (1 / self)\n        else:\n            return Number.__rtruediv__(self, other)\n    return Number.__rtruediv__(self, other)",
    ".sympy.core.numbers.py@@Rational.__new__": "def __new__(cls, p, q=None, gcd=None):\n    if q is None:\n        if isinstance(p, Rational):\n            return p\n        if isinstance(p, SYMPY_INTS):\n            pass\n        else:\n            if isinstance(p, (float, Float)):\n                return Rational(*_as_integer_ratio(p))\n            if not isinstance(p, str):\n                try:\n                    p = sympify(p)\n                except (SympifyError, SyntaxError):\n                    pass\n            else:\n                if p.count('/') > 1:\n                    raise TypeError('invalid input: %s' % p)\n                p = p.replace(' ', '')\n                pq = p.rsplit('/', 1)\n                if len(pq) == 2:\n                    p, q = pq\n                    fp = fractions.Fraction(p)\n                    fq = fractions.Fraction(q)\n                    p = fp / fq\n                try:\n                    p = fractions.Fraction(p)\n                except ValueError:\n                    pass\n                else:\n                    return Rational(p.numerator, p.denominator, 1)\n            if not isinstance(p, Rational):\n                raise TypeError('invalid input: %s' % p)\n        q = 1\n        gcd = 1\n    if not isinstance(p, SYMPY_INTS):\n        p = Rational(p)\n        q *= p.q\n        p = p.p\n    else:\n        p = int(p)\n    if not isinstance(q, SYMPY_INTS):\n        q = Rational(q)\n        p *= q.q\n        q = q.p\n    else:\n        q = int(q)\n    if q == 0:\n        if p == 0:\n            if _errdict['divide']:\n                raise ValueError('Indeterminate 0/0')\n            else:\n                return S.NaN\n        return S.ComplexInfinity\n    if q < 0:\n        q = -q\n        p = -p\n    if not gcd:\n        gcd = igcd(abs(p), q)\n    if gcd > 1:\n        p //= gcd\n        q //= gcd\n    if q == 1:\n        return Integer(p)\n    if p == 1 and q == 2:\n        return S.Half\n    obj = Expr.__new__(cls)\n    obj.p = p\n    obj.q = q\n    return obj",
    ".sympy.core.power.py@@Pow.as_base_exp": "def as_base_exp(self):\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and (b.q != 1):\n        return (Integer(b.q), -e)\n    return (b, e)",
    ".sympy.core.basic.py@@Basic.args": "def args(self) -> 'Tuple[Basic, ...]':\n    return self._args",
    ".sympy.core.numbers.py@@Rational.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.numbers.py@@Rational._hashable_content": "def _hashable_content(self):\n    return (self.p, self.q)",
    ".sympy.core.numbers.py@@igcd": "def igcd(*args):\n    if len(args) < 2:\n        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))\n    args_temp = [abs(as_int(i)) for i in args]\n    if 1 in args_temp:\n        return 1\n    a = args_temp.pop()\n    if HAS_GMPY:\n        for b in args_temp:\n            a = gmpy.gcd(a, b) if b else a\n        return as_int(a)\n    for b in args_temp:\n        a = math.gcd(a, b)\n    return a",
    ".sympy.utilities.misc.py@@as_int": "def as_int(n, strict=True):\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n != result:\n            raise ValueError('%s is not an integer' % (n,))\n        return result",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.decorators.py@@_SympifyWrapper._func": "def _func(self, other):\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    ".sympy.core.decorators.py@@binary_op_wrapper": "def binary_op_wrapper(self, other):\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:\n            f = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    ".sympy.core.expr.py@@Expr.__rtruediv__": "def __rtruediv__(self, other):\n    denom = Pow(self, S.NegativeOne)\n    if other is S.One:\n        return denom\n    else:\n        return Mul(other, denom)",
    ".sympy.core.power.py@@Pow.__new__": "def __new__(cls, b, e, evaluate=None):\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    from sympy.functions.elementary.exponential import exp_polar\n    b = _sympify(b)\n    e = _sympify(e)\n    from .relational import Relational\n    if isinstance(b, Relational) or isinstance(e, Relational):\n        raise TypeError('Relational cannot be used in Pow')\n    if not (isinstance(b, Expr) and isinstance(e, Expr)):\n        SymPyDeprecationWarning(feature='Pow with non-Expr args', useinstead='Expr args', issue=19445, deprecated_since_version='1.7').warn()\n    if evaluate:\n        if e is S.ComplexInfinity:\n            return S.NaN\n        if e is S.Infinity:\n            if is_gt(b, S.One):\n                return S.Infinity\n            if is_gt(b, S.NegativeOne) and is_lt(b, S.One):\n                return S.Zero\n            if is_lt(b, S.NegativeOne):\n                if b.is_finite:\n                    return S.ComplexInfinity\n                if b.is_finite is False:\n                    return S.NaN\n        if e is S.Zero:\n            return S.One\n        elif e is S.One:\n            return b\n        elif e == -1 and (not b):\n            return S.ComplexInfinity\n        elif e.__class__.__name__ == 'AccumulationBounds':\n            if b == S.Exp1:\n                from sympy.calculus.accumulationbounds import AccumBounds\n                return AccumBounds(Pow(b, e.min), Pow(b, e.max))\n        elif (e.is_Symbol and e.is_integer or e.is_Integer) and (b.is_number and b.is_Mul or b.is_Number) and b.could_extract_minus_sign():\n            if e.is_even:\n                b = -b\n            elif e.is_odd:\n                return -Pow(-b, e)\n        if S.NaN in (b, e):\n            return S.NaN\n        elif b is S.One:\n            if abs(e).is_infinite:\n                return S.NaN\n            return S.One\n        else:\n            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):\n                from .exprtools import factor_terms\n                from sympy.functions.elementary.exponential import log\n                from sympy.simplify.radsimp import fraction\n                c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n                num, den = fraction(ex)\n                if isinstance(den, log) and den.args[0] == b:\n                    return S.Exp1 ** (c * num)\n                elif den.is_Add:\n                    from sympy.functions.elementary.complexes import sign, im\n                    s = sign(im(b))\n                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):\n                        return S.Exp1 ** (c * num)\n            obj = b._eval_power(e)\n            if obj is not None:\n                return obj\n    obj = Expr.__new__(cls, b, e)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if not isinstance(obj, Pow):\n        return obj\n    obj.is_commutative = b.is_commutative and e.is_commutative\n    return obj",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n    if not (self.is_Number and other.is_Number) and type(self) != type(other):\n        return False\n    a, b = (self._hashable_content(), other._hashable_content())\n    if a != b:\n        return False\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if not isinstance(other, Number):\n        return False\n    if not self:\n        return not other\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Rational:\n        return self.p == other.p and self.q == other.q\n    if other.is_Float:\n        if self.q & self.q - 1:\n            return False\n        s, m, t = other._mpf_[:3]\n        if s:\n            m = -m\n        if not t:\n            if not self.is_Integer or self.is_even:\n                return False\n            return m == self.p\n        from .power import integer_log\n        if t > 0:\n            if not self.is_Integer:\n                return False\n            return self.p and (not self.p % m) and (integer_log(self.p // m, 2) == (t, True))\n        if self.is_Integer:\n            return False\n        return m == self.p and integer_log(self.q, 2) == (-t, True)\n    return False",
    ".sympy.core.expr.py@@Expr._eval_power": "def _eval_power(self, other):\n    return None",
    ".sympy.core.basic.py@@Basic._exec_constructor_postprocessors": "def _exec_constructor_postprocessors(cls, obj):\n    clsname = obj.__class__.__name__\n    postprocessors = defaultdict(list)\n    for i in obj.args:\n        try:\n            postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)\n            for k, v in chain.from_iterable(postprocessor_mappings):\n                postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n        except TypeError:\n            pass\n    for f in postprocessors.get(clsname, []):\n        obj = f(obj)\n    return obj",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.function.py@@Function.__new__": "def __new__(cls, *args, **options):\n    if cls is Function:\n        return UndefinedFunction(*args, **options)\n    n = len(args)\n    if n not in cls.nargs:\n        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'\n        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})\n    evaluate = options.get('evaluate', global_parameters.evaluate)\n    result = super().__new__(cls, *args, **options)\n    if evaluate and isinstance(result, cls) and result.args:\n        pr2 = min((cls._should_evalf(a) for a in result.args))\n        if pr2 > 0:\n            pr = max((cls._should_evalf(a) for a in result.args))\n            result = result.evalf(prec_to_dps(pr))\n    return result",
    ".sympy.core.function.py@@FunctionClass.nargs": "def nargs(self):\n    from sympy.sets.sets import FiniteSet\n    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0",
    ".sympy.sets.sets.py@@FiniteSet.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n    if evaluate:\n        args = list(map(sympify, args))\n        if len(args) == 0:\n            return S.EmptySet\n    else:\n        args = list(map(sympify, args))\n    dargs = {}\n    for i in reversed(list(ordered(args))):\n        if i.is_Symbol:\n            dargs[i] = i\n        else:\n            try:\n                dargs[i.as_dummy()] = i\n            except TypeError:\n                dargs[i] = i\n    _args_set = set(dargs.values())\n    args = list(ordered(_args_set, Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._args_set = _args_set\n    return obj",
    ".sympy.core.sorting.py@@ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    d = defaultdict(list)\n    if keys:\n        if not isinstance(keys, (list, tuple)):\n            keys = [keys]\n        keys = list(keys)\n        f = keys.pop(0)\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n    for k in sorted(d.keys()):\n        if len(d[k]) > 1:\n            if keys:\n                d[k] = ordered(d[k], keys, default, warn)\n            elif default:\n                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)\n            elif warn:\n                u = list(uniq(d[k]))\n                if len(u) > 1:\n                    raise ValueError('not enough keys to break ties: %s' % u)\n        yield from d[k]\n        d.pop(k)",
    ".sympy.core.basic.py@@Basic.as_dummy": "def as_dummy(self):\n    from .symbol import Dummy, Symbol\n\n    def can(x):\n        free = x.free_symbols\n        bound = set(x.bound_symbols)\n        d = {i: Dummy() for i in bound & free}\n        x = x.subs(d)\n        x = x.xreplace(x.canonical_variables)\n        return x.xreplace({v: k for k, v in d.items()})\n    if not self.has(Symbol):\n        return self\n    return self.replace(lambda x: hasattr(x, 'bound_symbols'), can, simultaneous=False)",
    ".sympy.core.basic.py@@Basic.has": "def has(self, *patterns):\n    return self._has(iterargs, *patterns)",
    ".sympy.core.basic.py@@Basic._has": "def _has(self, iterargs, *patterns):\n    type_set = set()\n    p_set = set()\n    for p in patterns:\n        if isinstance(p, BasicMeta):\n            type_set.add(p)\n            continue\n        if not isinstance(p, Basic):\n            try:\n                p = _sympify(p)\n            except SympifyError:\n                continue\n        p_set.add(p)\n    types = tuple(type_set)\n    for i in iterargs(self):\n        if i in p_set:\n            return True\n        if isinstance(i, types):\n            return True\n    for i in p_set - type_set:\n        if not hasattr(i, '_has_matcher'):\n            continue\n        match = i._has_matcher()\n        if any((match(arg) for arg in iterargs(self))):\n            return True\n    return False",
    ".sympy.core.traversal.py@@iterargs": "def iterargs(expr):\n    args = [expr]\n    for i in args:\n        yield i\n        try:\n            args.extend(i.args)\n        except TypeError:\n            pass",
    ".sympy.sets.sets.py@@Set._infimum_key": "def _infimum_key(expr):\n    try:\n        infimum = expr.inf\n        assert infimum.is_comparable\n        infimum = infimum.evalf()\n    except (NotImplementedError, AttributeError, AssertionError, ValueError):\n        infimum = S.Infinity\n    return infimum",
    ".sympy.core.numbers.py@@Infinity.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.sets.sets.py@@Set.__contains__": "def __contains__(self, other):\n    other = _sympify(other)\n    c = self._contains(other)\n    b = tfn[c]\n    if b is None:\n        raise TypeError('did not evaluate to a bool: %r' % c)\n    return b",
    ".sympy.sets.sets.py@@FiniteSet._contains": "def _contains(self, other):\n    if other in self._args_set:\n        return True\n    else:\n        return fuzzy_or((fuzzy_bool(Eq(e, other, evaluate=True)) for e in self.args))",
    ".sympy.logic.boolalg.py@@BooleanTrue.__bool__": "def __bool__(self):\n    return True",
    ".sympy.core.function.py@@Application.__new__": "def __new__(cls, *args, **options):\n    from sympy.sets.fancysets import Naturals0\n    from sympy.sets.sets import FiniteSet\n    args = list(map(sympify, args))\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    options.pop('nargs', None)\n    if options:\n        raise ValueError('Unknown options: %s' % options)\n    if evaluate:\n        evaluated = cls.eval(*args)\n        if evaluated is not None:\n            return evaluated\n    obj = super().__new__(cls, *args, **options)\n    sentinel = object()\n    objnargs = getattr(obj, 'nargs', sentinel)\n    if objnargs is not sentinel:\n        if is_sequence(objnargs):\n            nargs = tuple(ordered(set(objnargs)))\n        elif objnargs is not None:\n            nargs = (as_int(objnargs),)\n        else:\n            nargs = None\n    else:\n        nargs = obj._nargs\n    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()\n    return obj",
    ".sympy.core.mod.py@@Mod.eval": "def eval(cls, p, q):\n\n    def doit(p, q):\n        if q.is_zero:\n            raise ZeroDivisionError('Modulo by zero')\n        if p is S.NaN or q is S.NaN or p.is_finite is False or (q.is_finite is False):\n            return S.NaN\n        if p is S.Zero or p in (q, -q) or (p.is_integer and q == 1):\n            return S.Zero\n        if q.is_Number:\n            if p.is_Number:\n                return p % q\n            if q == 2:\n                if p.is_even:\n                    return S.Zero\n                elif p.is_odd:\n                    return S.One\n        if hasattr(p, '_eval_Mod'):\n            rv = getattr(p, '_eval_Mod')(q)\n            if rv is not None:\n                return rv\n        r = p / q\n        if r.is_integer:\n            return S.Zero\n        try:\n            d = int(r)\n        except TypeError:\n            pass\n        else:\n            if isinstance(d, int):\n                rv = p - d * q\n                if (rv * q < 0) == True:\n                    rv += q\n                return rv\n        d = abs(p)\n        for _ in range(2):\n            d -= abs(q)\n            if d.is_negative:\n                if q.is_positive:\n                    if p.is_positive:\n                        return d + q\n                    elif p.is_negative:\n                        return -d\n                elif q.is_negative:\n                    if p.is_positive:\n                        return d\n                    elif p.is_negative:\n                        return -d + q\n                break\n    rv = doit(p, q)\n    if rv is not None:\n        return rv\n    if isinstance(p, cls):\n        qinner = p.args[1]\n        if qinner % q == 0:\n            return cls(p.args[0], q)\n        elif (qinner * (q - qinner)).is_nonnegative:\n            return p\n    elif isinstance(-p, cls):\n        qinner = (-p).args[1]\n        if qinner % q == 0:\n            return cls(-(-p).args[0], q)\n        elif (qinner * (q + qinner)).is_nonpositive:\n            return p\n    elif isinstance(p, Add):\n        both_l = non_mod_l, mod_l = ([], [])\n        for arg in p.args:\n            both_l[isinstance(arg, cls)].append(arg)\n        if mod_l and all((inner.args[1] == q for inner in mod_l)):\n            net = Add(*non_mod_l) + Add(*[i.args[0] for i in mod_l])\n            return cls(net, q)\n    elif isinstance(p, Mul):\n        both_l = non_mod_l, mod_l = ([], [])\n        for arg in p.args:\n            both_l[isinstance(arg, cls)].append(arg)\n        if mod_l and all((inner.args[1] == q for inner in mod_l)):\n            non_mod_l = [cls(x, q) for x in non_mod_l]\n            mod = []\n            non_mod = []\n            for j in non_mod_l:\n                if isinstance(j, cls):\n                    mod.append(j.args[0])\n                else:\n                    non_mod.append(j)\n            prod_mod = Mul(*mod)\n            prod_non_mod = Mul(*non_mod)\n            prod_mod1 = Mul(*[i.args[0] for i in mod_l])\n            net = prod_mod1 * prod_mod\n            return prod_non_mod * cls(net, q)\n        if q.is_Integer and q is not S.One:\n            _ = []\n            for i in non_mod_l:\n                if i.is_Integer and i % q is not S.Zero:\n                    _.append(i % q)\n                else:\n                    _.append(i)\n            non_mod_l = _\n        p = Mul(*non_mod_l + mod_l)\n    from sympy.polys.polyerrors import PolynomialError\n    from sympy.polys.polytools import gcd\n    try:\n        G = gcd(p, q)\n        if G != 1:\n            p, q = [gcd_terms(i / G, clear=False, fraction=False) for i in (p, q)]\n    except PolynomialError:\n        G = S.One\n    pwas, qwas = (p, q)\n    if p.is_Add:\n        args = []\n        for i in p.args:\n            a = cls(i, q)\n            if a.count(cls) > i.count(cls):\n                args.append(i)\n            else:\n                args.append(a)\n        if args != list(p.args):\n            p = Add(*args)\n    else:\n        cp, p = p.as_coeff_Mul()\n        cq, q = q.as_coeff_Mul()\n        ok = False\n        if not cp.is_Rational or not cq.is_Rational:\n            r = cp % cq\n            if r == 0:\n                G *= cq\n                p *= int(cp / cq)\n                ok = True\n        if not ok:\n            p = cp * p\n            q = cq * q\n    if p.could_extract_minus_sign() and q.could_extract_minus_sign():\n        G, p, q = [-i for i in (G, p, q)]\n    rv = doit(p, q)\n    if rv is not None:\n        return rv * G\n    if G.is_Float and G == 1:\n        p *= G\n        return cls(p, q, evaluate=False)\n    elif G.is_Mul and G.args[0].is_Float and (G.args[0] == 1):\n        p = G.args[0] * p\n        G = Mul._from_args(G.args[1:])\n    return G * cls(p, q, evaluate=(p, q) != (pwas, qwas))",
    ".sympy.core.mod.py@@Mod.doit": "def doit(p, q):\n    if q.is_zero:\n        raise ZeroDivisionError('Modulo by zero')\n    if p is S.NaN or q is S.NaN or p.is_finite is False or (q.is_finite is False):\n        return S.NaN\n    if p is S.Zero or p in (q, -q) or (p.is_integer and q == 1):\n        return S.Zero\n    if q.is_Number:\n        if p.is_Number:\n            return p % q\n        if q == 2:\n            if p.is_even:\n                return S.Zero\n            elif p.is_odd:\n                return S.One\n    if hasattr(p, '_eval_Mod'):\n        rv = getattr(p, '_eval_Mod')(q)\n        if rv is not None:\n            return rv\n    r = p / q\n    if r.is_integer:\n        return S.Zero\n    try:\n        d = int(r)\n    except TypeError:\n        pass\n    else:\n        if isinstance(d, int):\n            rv = p - d * q\n            if (rv * q < 0) == True:\n                rv += q\n            return rv\n    d = abs(p)\n    for _ in range(2):\n        d -= abs(q)\n        if d.is_negative:\n            if q.is_positive:\n                if p.is_positive:\n                    return d + q\n                elif p.is_negative:\n                    return -d\n            elif q.is_negative:\n                if p.is_positive:\n                    return d\n                elif p.is_negative:\n                    return -d + q\n            break",
    ".sympy.core.numbers.py@@NegativeOne.__neg__": "def __neg__():\n    return S.One",
    ".sympy.core.numbers.py@@Integer.__mod__": "def __mod__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p % other)\n        elif isinstance(other, Integer):\n            return Integer(self.p % other.p)\n        return Rational.__mod__(self, other)\n    return Rational.__mod__(self, other)",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return {key: value for key, value in self._assumptions.items() if value is not None}"
}