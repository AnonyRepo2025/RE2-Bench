{
    ".sympy.core.basic.py@@Basic.args": "def args(self) -> tuple[Basic, ...]:\n    return self._args",
    ".sympy.tensor.tensor.py@@Tensor.component": "def component(self):\n    return self._component",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n    if not (self.is_Number and other.is_Number) and type(self) != type(other):\n        return False\n    a, b = (self._hashable_content(), other._hashable_content())\n    if a != b:\n        return False\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    ".sympy.core.numbers.py@@Integer.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p * other)\n        elif isinstance(other, Integer):\n            return Integer(self.p * other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, str):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    if ival == 1:\n        return S.One\n    if ival == -1:\n        return S.NegativeOne\n    if ival == 0:\n        return S.Zero\n    obj = Expr.__new__(cls)\n    obj.p = ival\n    return obj",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.tensor.tensor.py@@TensorHead.__call__": "def __call__(self, *indices, **kw_args):\n    updated_indices = []\n    for idx, typ in zip(indices, self.index_types):\n        if isinstance(idx, str):\n            idx = idx.strip().replace(' ', '')\n            if idx.startswith('-'):\n                updated_indices.append(TensorIndex(idx[1:], typ, is_up=False))\n            else:\n                updated_indices.append(TensorIndex(idx, typ))\n        else:\n            updated_indices.append(idx)\n    updated_indices += indices[len(updated_indices):]\n    tensor = Tensor(self, updated_indices, **kw_args)\n    return tensor.doit()",
    ".sympy.tensor.tensor.py@@TensorHead.index_types": "def index_types(self):\n    return list(self.args[1])",
    ".sympy.core.containers.py@@Tuple.__len__": "def __len__(self):\n    return len(self.args)",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.tensor.tensor.py@@Tensor.__new__": "def __new__(cls, tensor_head, indices, *, is_canon_bp=False, **kw_args):\n    indices = cls._parse_indices(tensor_head, indices)\n    obj = Basic.__new__(cls, tensor_head, Tuple(*indices), **kw_args)\n    obj._index_structure = _IndexStructure.from_indices(*indices)\n    obj._free = obj._index_structure.free[:]\n    obj._dum = obj._index_structure.dum[:]\n    obj._ext_rank = obj._index_structure._ext_rank\n    obj._coeff = S.One\n    obj._nocoeff = obj\n    obj._component = tensor_head\n    obj._components = [tensor_head]\n    if tensor_head.rank != len(indices):\n        raise ValueError('wrong number of indices')\n    obj.is_canon_bp = is_canon_bp\n    obj._index_map = Tensor._build_index_map(indices, obj._index_structure)\n    return obj",
    ".sympy.tensor.tensor.py@@Tensor._parse_indices": "def _parse_indices(tensor_head, indices):\n    if not isinstance(indices, (tuple, list, Tuple)):\n        raise TypeError('indices should be an array, got %s' % type(indices))\n    indices = list(indices)\n    for i, index in enumerate(indices):\n        if isinstance(index, Symbol):\n            indices[i] = TensorIndex(index, tensor_head.index_types[i], True)\n        elif isinstance(index, Mul):\n            c, e = index.as_coeff_Mul()\n            if c == -1 and isinstance(e, Symbol):\n                indices[i] = TensorIndex(e, tensor_head.index_types[i], False)\n            else:\n                raise ValueError('index not understood: %s' % index)\n        elif not isinstance(index, TensorIndex):\n            raise TypeError('wrong type for index: %s is %s' % (index, type(index)))\n    return indices",
    ".sympy.core.containers.py@@Tuple.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    cls = getattr(a, '__class__', None)\n    for superclass in getmro(cls):\n        conv = _external_converter.get(superclass)\n        if conv is None:\n            conv = _sympy_converter.get(superclass)\n        if conv is not None:\n            return conv(a)\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from sympy.tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(), locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        else:\n            for coerce in (float, int):\n                try:\n                    return sympify(coerce(a))\n                except (TypeError, ValueError, AttributeError, SympifyError):\n                    continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational, evaluate=evaluate) for x in a])\n        except TypeError:\n            pass\n    if not isinstance(a, str):\n        try:\n            a = str(a)\n        except Exception as exc:\n            raise SympifyError(a, exc)\n        sympy_deprecation_warning(f'\\nThe string fallback in sympify() is deprecated.\\n\\nTo explicitly convert the string form of an object, use\\nsympify(str(obj)). To add define sympify behavior on custom\\nobjects, use sympy.core.sympify.converter or define obj._sympy_\\n(see the sympify() docstring).\\n\\nsympify() performed the string fallback resulting in the following string:\\n\\n{a!r}\\n            ', deprecated_since_version='1.6', active_deprecations_target='deprecated-sympify-string-fallback')\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.tensor.tensor.py@@_IndexStructure.from_indices": "def from_indices(*indices):\n    free, dum = _IndexStructure._free_dum_from_indices(*indices)\n    index_types = [i.tensor_index_type for i in indices]\n    indices = _IndexStructure._replace_dummy_names(indices, free, dum)\n    return _IndexStructure(free, dum, index_types, indices)",
    ".sympy.tensor.tensor.py@@_IndexStructure._free_dum_from_indices": "def _free_dum_from_indices(*indices):\n    n = len(indices)\n    if n == 1:\n        return ([(indices[0], 0)], [])\n    free = [True] * len(indices)\n    index_dict = {}\n    dum = []\n    for i, index in enumerate(indices):\n        name = index.name\n        typ = index.tensor_index_type\n        contr = index.is_up\n        if (name, typ) in index_dict:\n            is_contr, pos = index_dict[name, typ]\n            if is_contr:\n                if contr:\n                    raise ValueError('two equal contravariant indices in slots %d and %d' % (pos, i))\n                else:\n                    free[pos] = False\n                    free[i] = False\n            elif contr:\n                free[pos] = False\n                free[i] = False\n            else:\n                raise ValueError('two equal covariant indices in slots %d and %d' % (pos, i))\n            if contr:\n                dum.append((i, pos))\n            else:\n                dum.append((pos, i))\n        else:\n            index_dict[name, typ] = (index.is_up, i)\n    free = [(index, i) for i, index in enumerate(indices) if free[i]]\n    free.sort()\n    return (free, dum)",
    ".sympy.tensor.tensor.py@@TensorIndex.tensor_index_type": "def tensor_index_type(self):\n    return self.args[1]",
    ".sympy.tensor.tensor.py@@_IndexStructure._replace_dummy_names": "def _replace_dummy_names(indices, free, dum):\n    dum.sort(key=lambda x: x[0])\n    new_indices = [ind for ind in indices]\n    assert len(indices) == len(free) + 2 * len(dum)\n    generate_dummy_name = _IndexStructure._get_generator_for_dummy_indices(free)\n    for ipos1, ipos2 in dum:\n        typ1 = new_indices[ipos1].tensor_index_type\n        indname = generate_dummy_name(typ1)\n        new_indices[ipos1] = TensorIndex(indname, typ1, True)\n        new_indices[ipos2] = TensorIndex(indname, typ1, False)\n    return new_indices",
    ".sympy.tensor.tensor.py@@_IndexStructure._get_generator_for_dummy_indices": "def _get_generator_for_dummy_indices(free):\n    cdt = defaultdict(int)\n    for indx, ipos in free:\n        if indx.name.split('_')[0] == indx.tensor_index_type.dummy_name:\n            cdt[indx.tensor_index_type] = max(cdt[indx.tensor_index_type], int(indx.name.split('_')[1]) + 1)\n\n    def dummy_name_gen(tensor_index_type):\n        nd = str(cdt[tensor_index_type])\n        cdt[tensor_index_type] += 1\n        return tensor_index_type.dummy_name + '_' + nd\n    return dummy_name_gen",
    ".sympy.tensor.tensor.py@@TensorIndex.name": "def name(self):\n    return self.args[0].name",
    ".sympy.tensor.tensor.py@@TensorIndexType.dummy_name": "def dummy_name(self):\n    return self.args[1].name",
    ".sympy.tensor.tensor.py@@_IndexStructure.__init__": "def __init__(self, free, dum, index_types, indices, canon_bp=False):\n    self.free = free\n    self.dum = dum\n    self.index_types = index_types\n    self.indices = indices\n    self._ext_rank = len(self.free) + 2 * len(self.dum)\n    self.dum.sort(key=lambda x: x[0])",
    ".sympy.tensor.tensor.py@@TensorHead.rank": "def rank(self):\n    return len(self.index_types)",
    ".sympy.tensor.tensor.py@@Tensor._build_index_map": "def _build_index_map(indices, index_structure):\n    index_map = {}\n    for idx in indices:\n        index_map[idx] = (indices.index(idx),)\n    return index_map",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self) -> int:\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.tensor.tensor.py@@Tensor.doit": "def doit(self, **hints):\n    args, indices, free, dum = TensMul._tensMul_contract_indices([self])\n    return args[0]",
    ".sympy.tensor.tensor.py@@TensMul._tensMul_contract_indices": "def _tensMul_contract_indices(args, replace_indices=True):\n    replacements = [{} for _ in args]\n    args_indices = [get_indices(arg) for arg in args]\n    indices, free, free_names, dummy_data = TensMul._indices_to_free_dum(args_indices)\n    cdt = defaultdict(int)\n\n    def dummy_name_gen(tensor_index_type):\n        nd = str(cdt[tensor_index_type])\n        cdt[tensor_index_type] += 1\n        return tensor_index_type.dummy_name + '_' + nd\n    if replace_indices:\n        for old_index, pos1cov, pos1contra, pos2cov, pos2contra in dummy_data:\n            index_type = old_index.tensor_index_type\n            while True:\n                dummy_name = dummy_name_gen(index_type)\n                if dummy_name not in free_names:\n                    break\n            dummy = TensorIndex(dummy_name, index_type, True)\n            replacements[pos1cov][old_index] = dummy\n            replacements[pos1contra][-old_index] = -dummy\n            indices[pos2cov] = dummy\n            indices[pos2contra] = -dummy\n        args = [arg._replace_indices(repl) if isinstance(arg, TensExpr) else arg for arg, repl in zip(args, replacements)]\n    dum = TensMul._dummy_data_to_dum(dummy_data)\n    return (args, indices, free, dum)",
    ".sympy.tensor.tensor.py@@get_indices": "def get_indices(t):\n    if not isinstance(t, TensExpr):\n        return ()\n    return t.get_indices()",
    ".sympy.tensor.tensor.py@@Tensor.get_indices": "def get_indices(self):\n    return list(self.args[1])",
    ".sympy.tensor.tensor.py@@TensMul._indices_to_free_dum": "def _indices_to_free_dum(args_indices):\n    free2pos1 = {}\n    free2pos2 = {}\n    dummy_data = []\n    indices = []\n    pos2 = 0\n    for pos1, arg_indices in enumerate(args_indices):\n        for index_pos, index in enumerate(arg_indices):\n            if not isinstance(index, TensorIndex):\n                raise TypeError('expected TensorIndex')\n            if -index in free2pos1:\n                other_pos1 = free2pos1.pop(-index)\n                other_pos2 = free2pos2.pop(-index)\n                if index.is_up:\n                    dummy_data.append((index, pos1, other_pos1, pos2, other_pos2))\n                else:\n                    dummy_data.append((-index, other_pos1, pos1, other_pos2, pos2))\n                indices.append(index)\n            elif index in free2pos1:\n                raise ValueError('Repeated index: %s' % index)\n            else:\n                free2pos1[index] = pos1\n                free2pos2[index] = pos2\n                indices.append(index)\n            pos2 += 1\n    free = [(i, p) for i, p in free2pos2.items()]\n    free_names = [i.name for i in free2pos2.keys()]\n    dummy_data.sort(key=lambda x: x[3])\n    return (indices, free, free_names, dummy_data)",
    ".sympy.tensor.tensor.py@@TensorIndex.__neg__": "def __neg__(self):\n    t1 = TensorIndex(self.name, self.tensor_index_type, not self.is_up)\n    return t1",
    ".sympy.tensor.tensor.py@@TensorIndex.is_up": "def is_up(self):\n    return self.args[2]",
    ".sympy.logic.boolalg.py@@BooleanTrue.__bool__": "def __bool__(self):\n    return True",
    ".sympy.tensor.tensor.py@@TensorIndex.__new__": "def __new__(cls, name, tensor_index_type, is_up=True):\n    if isinstance(name, str):\n        name_symbol = Symbol(name)\n    elif isinstance(name, Symbol):\n        name_symbol = name\n    elif name is True:\n        name = '_i{}'.format(len(tensor_index_type._autogenerated))\n        name_symbol = Symbol(name)\n        tensor_index_type._autogenerated.append(name_symbol)\n    else:\n        raise ValueError('invalid name')\n    is_up = sympify(is_up)\n    return Basic.__new__(cls, name_symbol, tensor_index_type, is_up)",
    ".sympy.core.symbol.py@@Symbol.__new__": "def __new__(cls, name, **assumptions):\n    cls._sanitize(assumptions, cls)\n    return Symbol.__xnew_cached_(cls, name, **assumptions)",
    ".sympy.core.symbol.py@@Symbol._sanitize": "def _sanitize(assumptions, obj=None):\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    if is_commutative is None:\n        whose = '%s ' % obj.__name__ if obj else ''\n        raise ValueError('%scommutativity must be True or False.' % whose)\n    for key in list(assumptions.keys()):\n        v = assumptions[key]\n        if v is None:\n            assumptions.pop(key)\n            continue\n        assumptions[key] = bool(v)",
    ".sympy.core.logic.py@@fuzzy_bool": "def fuzzy_bool(x):\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    ".sympy.core.symbol.py@@Symbol.__xnew_cached_": "def __xnew_cached_(cls, name, **assumptions):\n    return Symbol.__xnew__(cls, name, **assumptions)",
    ".sympy.core.symbol.py@@Symbol.__xnew__": "def __xnew__(cls, name, **assumptions):\n    if not isinstance(name, str):\n        raise TypeError('name should be a string, not %s' % repr(type(name)))\n    obj = Expr.__new__(cls)\n    obj.name = name\n    tmp_asm_copy = assumptions.copy()\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    assumptions['commutative'] = is_commutative\n    obj._assumptions = StdFactKB(assumptions)\n    obj._assumptions._generator = tmp_asm_copy\n    return obj",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    super().__init__(_assume_rules)\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.__init__": "def __init__(self, rules):\n    self.rules = rules",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.basic.py@@Basic._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return {key: value for key, value in self._assumptions.items() if value is not None}",
    ".sympy.logic.boolalg.py@@BooleanFalse.__hash__": "def __hash__(self):\n    return hash(False)",
    ".sympy.tensor.tensor.py@@Tensor._replace_indices": "def _replace_indices(self, repl):\n    return self.xreplace(repl)",
    ".sympy.core.basic.py@@Basic.xreplace": "def xreplace(self, rule):\n    value, _ = self._xreplace(rule)\n    return value",
    ".sympy.core.basic.py@@Basic._xreplace": "def _xreplace(self, rule):\n    if self in rule:\n        return (rule[self], True)\n    elif rule:\n        args = []\n        changed = False\n        for a in self.args:\n            _xreplace = getattr(a, '_xreplace', None)\n            if _xreplace is not None:\n                a_xr = _xreplace(rule)\n                args.append(a_xr[0])\n                changed |= a_xr[1]\n            else:\n                args.append(a)\n        args = tuple(args)\n        if changed:\n            return (self.func(*args), True)\n    return (self, False)",
    ".sympy.core.expr.py@@Expr._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.containers.py@@Tuple.__hash__": "def __hash__(self):\n    return hash(self.args)",
    ".sympy.tensor.tensor.py@@TensMul._dummy_data_to_dum": "def _dummy_data_to_dum(dummy_data):\n    return [(p2a, p2b) for i, p1a, p1b, p2a, p2b in dummy_data]",
    ".sympy.core.decorators.py@@__sympifyit_wrapper": "def __sympifyit_wrapper(a, b):\n    try:\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    ".sympy.core.numbers.py@@Rational.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))\n        elif isinstance(other, Float):\n            return other * self\n        else:\n            return Number.__mul__(self, other)\n    return Number.__mul__(self, other)",
    ".sympy.core.numbers.py@@Number.__mul__": "def __mul__(self, other):\n    if isinstance(other, Number) and global_parameters.evaluate:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.Infinity\n            else:\n                return S.NegativeInfinity\n        elif other is S.NegativeInfinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.NegativeInfinity\n            else:\n                return S.Infinity\n    elif isinstance(other, Tuple):\n        return NotImplemented\n    return AtomicExpr.__mul__(self, other)",
    ".sympy.core.decorators.py@@_SympifyWrapper._func": "def _func(self, other):\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    ".sympy.core.decorators.py@@binary_op_wrapper": "def binary_op_wrapper(self, other):\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:\n            f = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    ".sympy.tensor.tensor.py@@TensExpr.__rmul__": "def __rmul__(self, other):\n    return TensMul(other, self).doit()",
    ".sympy.tensor.tensor.py@@TensMul.__new__": "def __new__(cls, *args, **kw_args):\n    is_canon_bp = kw_args.get('is_canon_bp', False)\n    args = list(map(_sympify, args))\n    args = [i for arg in args for i in (arg.args if isinstance(arg, (TensMul, Mul)) else [arg])]\n    args, indices, free, dum = TensMul._tensMul_contract_indices(args, replace_indices=False)\n    index_types = [i.tensor_index_type for i in indices]\n    index_structure = _IndexStructure(free, dum, index_types, indices, canon_bp=is_canon_bp)\n    obj = TensExpr.__new__(cls, *args)\n    obj._indices = indices\n    obj._index_types = index_types[:]\n    obj._index_structure = index_structure\n    obj._free = index_structure.free[:]\n    obj._dum = index_structure.dum[:]\n    obj._free_indices = {x[0] for x in obj.free}\n    obj._rank = len(obj.free)\n    obj._ext_rank = len(obj._index_structure.free) + 2 * len(obj._index_structure.dum)\n    obj._coeff = S.One\n    obj._is_canon_bp = is_canon_bp\n    return obj",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.tensor.tensor.py@@TensMul.doit": "def doit(self, **hints):\n    is_canon_bp = self._is_canon_bp\n    deep = hints.get('deep', True)\n    if deep:\n        args = [arg.doit(**hints) for arg in self.args]\n    else:\n        args = self.args\n    args = [arg for arg in args if arg != self.identity]\n    coeff = reduce(lambda a, b: a * b, [arg for arg in args if not isinstance(arg, TensExpr)], S.One)\n    args = [arg for arg in args if isinstance(arg, TensExpr)]\n    if len(args) == 0:\n        return coeff\n    if coeff != self.identity:\n        args = [coeff] + args\n    if coeff == 0:\n        return S.Zero\n    if len(args) == 1:\n        return args[0]\n    args, indices, free, dum = TensMul._tensMul_contract_indices(args)\n    index_types = [i.tensor_index_type for i in indices]\n    index_structure = _IndexStructure(free, dum, index_types, indices, canon_bp=is_canon_bp)\n    obj = self.func(*args)\n    obj._index_types = index_types\n    obj._index_structure = index_structure\n    obj._ext_rank = len(obj._index_structure.free) + 2 * len(obj._index_structure.dum)\n    obj._coeff = coeff\n    obj._is_canon_bp = is_canon_bp\n    return obj",
    ".sympy.core.basic.py@@Atom.doit": "def doit(self, **hints):\n    return self",
    ".sympy.core.numbers.py@@Integer.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.tensor.tensor.py@@TensExpr.__mul__": "def __mul__(self, other):\n    return TensMul(self, other).doit()",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.core.numbers.py@@Integer.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    ".sympy.core.numbers.py@@Rational.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(self.p + self.q * other.p, self.q, 1)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + self.q * other.p, self.q * other.q)\n        elif isinstance(other, Float):\n            return other + self\n        else:\n            return Number.__add__(self, other)\n    return Number.__add__(self, other)",
    ".sympy.core.numbers.py@@Number.__add__": "def __add__(self, other):\n    if isinstance(other, Number) and global_parameters.evaluate:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            return S.Infinity\n        elif other is S.NegativeInfinity:\n            return S.NegativeInfinity\n    return AtomicExpr.__add__(self, other)",
    ".sympy.tensor.tensor.py@@TensExpr.__radd__": "def __radd__(self, other):\n    return TensAdd(other, self).doit()",
    ".sympy.tensor.tensor.py@@TensAdd.__new__": "def __new__(cls, *args, **kw_args):\n    args = [_sympify(x) for x in args if x]\n    args = TensAdd._tensAdd_flatten(args)\n    args.sort(key=default_sort_key)\n    if not args:\n        return S.Zero\n    if len(args) == 1:\n        return args[0]\n    return Basic.__new__(cls, *args, **kw_args)",
    ".sympy.core.numbers.py@@Zero.__bool__": "def __bool__(self):\n    return False",
    ".sympy.tensor.tensor.py@@TensAdd._tensAdd_flatten": "def _tensAdd_flatten(args):\n    a = []\n    for x in args:\n        if isinstance(x, (Add, TensAdd)):\n            a.extend(list(x.args))\n        else:\n            a.append(x)\n    args = [x for x in a if x.coeff]\n    return args",
    ".sympy.tensor.tensor.py@@TensMul.coeff": "def coeff(self):\n    return self._coeff",
    ".sympy.core.sorting.py@@default_sort_key": "def default_sort_key(item, order=None):\n    from .basic import Basic\n    from .singleton import S\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n    if iterable(item, exclude=str):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            args = list(item)\n            unordered = False\n        args = [default_sort_key(arg, order=order) for arg in args]\n        if unordered:\n            args = sorted(args)\n        cls_index, args = (10, (len(args), tuple(args)))\n    else:\n        if not isinstance(item, str):\n            try:\n                item = sympify(item, strict=True)\n            except SympifyError:\n                pass\n            else:\n                if isinstance(item, Basic):\n                    return default_sort_key(item)\n        cls_index, args = (0, (1, (str(item),)))\n    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)",
    ".sympy.core.expr.py@@Expr.sort_key": "def sort_key(self, order=None):\n    coeff, expr = self.as_coeff_Mul()\n    if expr.is_Pow:\n        if expr.base is S.Exp1:\n            expr, exp = (Function('exp')(expr.exp), S.One)\n        else:\n            expr, exp = expr.args\n    else:\n        exp = S.One\n    if expr.is_Dummy:\n        args = (expr.sort_key(),)\n    elif expr.is_Atom:\n        args = (str(expr),)\n    else:\n        if expr.is_Add:\n            args = expr.as_ordered_terms(order=order)\n        elif expr.is_Mul:\n            args = expr.as_ordered_factors(order=order)\n        else:\n            args = expr.args\n        args = tuple([default_sort_key(arg, order=order) for arg in args])\n    args = (len(args), tuple(args))\n    exp = exp.sort_key(order=order)\n    return (expr.class_key(), args, exp, coeff)",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational: bool=False) -> tuple['Number', Expr]:\n    return (S.One, self)",
    ".sympy.core.basic.py@@Basic.sort_key": "def sort_key(self, order=None):\n\n    def inner_key(arg):\n        if isinstance(arg, Basic):\n            return arg.sort_key(order)\n        else:\n            return arg\n    args = self._sorted_args\n    args = (len(args), tuple([inner_key(arg) for arg in args]))\n    return (self.class_key(), args, S.One.sort_key(), S.One)",
    ".sympy.core.basic.py@@Basic._sorted_args": "def _sorted_args(self):\n    return self.args",
    ".sympy.core.basic.py@@Basic.inner_key": "def inner_key(arg):\n    if isinstance(arg, Basic):\n        return arg.sort_key(order)\n    else:\n        return arg",
    ".sympy.core.symbol.py@@Symbol.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (1, (self.name,)), S.One.sort_key(), S.One)",
    ".sympy.core.basic.py@@Atom.class_key": "def class_key(cls):\n    return (2, 0, cls.__name__)",
    ".sympy.core.numbers.py@@Number.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (0, ()), (), self)",
    ".sympy.core.numbers.py@@Number.class_key": "def class_key(cls):\n    return (1, 0, 'Number')",
    ".sympy.core.basic.py@@Basic.class_key": "def class_key(cls):\n    return (5, 0, cls.__name__)",
    ".sympy.core.basic.py@@Atom.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One)",
    ".sympy.core._print_helpers.py@@Printable.__str__": "def __str__(self):\n    from sympy.printing.str import sstr\n    return sstr(self, order=None)",
    ".sympy.printing.printer.py@@_PrintFunction.__call__": "def __call__(self, *args, **kwargs):\n    return self.__wrapped__(*args, **kwargs)",
    ".sympy.printing.str.py@@sstr": "def sstr(expr, **settings):\n    p = StrPrinter(settings)\n    s = p.doprint(expr)\n    return s",
    ".sympy.printing.printer.py@@Printer.__init__": "def __init__(self, settings=None):\n    self._str = str\n    self._settings = self._get_initial_settings()\n    self._context = {}\n    if settings is not None:\n        self._settings.update(settings)\n        if len(self._settings) > len(self._default_settings):\n            for key in self._settings:\n                if key not in self._default_settings:\n                    raise TypeError(\"Unknown setting '%s'.\" % key)\n    self._print_level = 0",
    ".sympy.printing.printer.py@@Printer._get_initial_settings": "def _get_initial_settings(cls):\n    settings = cls._default_settings.copy()\n    for key, val in cls._global_settings.items():\n        if key in cls._default_settings:\n            settings[key] = val\n    return settings",
    ".sympy.printing.printer.py@@Printer.doprint": "def doprint(self, expr):\n    return self._str(self._print(expr))",
    ".sympy.printing.printer.py@@Printer._print": "def _print(self, expr, **kwargs) -> str:\n    self._print_level += 1\n    try:\n        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):\n            return getattr(expr, self.printmethod)(self, **kwargs)\n        classes = type(expr).__mro__\n        if AppliedUndef in classes:\n            classes = classes[classes.index(AppliedUndef):]\n        if UndefinedFunction in classes:\n            classes = classes[classes.index(UndefinedFunction):]\n        if Function in classes:\n            i = classes.index(Function)\n            classes = tuple((c for c in classes[:i] if c.__name__ == classes[0].__name__ or c.__name__.endswith('Base'))) + classes[i:]\n        for cls in classes:\n            printmethodname = '_print_' + cls.__name__\n            printmethod = getattr(self, printmethodname, None)\n            if printmethod is not None:\n                return printmethod(expr, **kwargs)\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1",
    ".sympy.printing.str.py@@StrPrinter._print_Permutation": "def _print_Permutation(self, expr):\n    from sympy.combinatorics.permutations import Permutation, Cycle\n    from sympy.utilities.exceptions import sympy_deprecation_warning\n    perm_cyclic = Permutation.print_cyclic\n    if perm_cyclic is not None:\n        sympy_deprecation_warning(f'\\n            Setting Permutation.print_cyclic is deprecated. Instead use\\n            init_printing(perm_cyclic={perm_cyclic}).\\n            ', deprecated_since_version='1.6', active_deprecations_target='deprecated-permutation-print_cyclic', stacklevel=7)\n    else:\n        perm_cyclic = self._settings.get('perm_cyclic', True)\n    if perm_cyclic:\n        if not expr.size:\n            return '()'\n        s = Cycle(expr)(expr.size - 1).__repr__()[len('Cycle'):]\n        last = s.rfind('(')\n        if not last == 0 and ',' not in s[last:]:\n            s = s[last:] + s[:last]\n        s = s.replace(',', '')\n        return s\n    else:\n        s = expr.support()\n        if not s:\n            if expr.size < 5:\n                return 'Permutation(%s)' % self._print(expr.array_form)\n            return 'Permutation([], size=%s)' % self._print(expr.size)\n        trim = self._print(expr.array_form[:s[-1] + 1]) + ', size=%s' % self._print(expr.size)\n        use = full = self._print(expr.array_form)\n        if len(trim) < len(full):\n            use = trim\n        return 'Permutation(%s)' % use",
    ".sympy.combinatorics.permutations.py@@Permutation.size": "def size(self):\n    return self._size",
    ".sympy.combinatorics.permutations.py@@Cycle.__init__": "def __init__(self, *args):\n    if not args:\n        return\n    if len(args) == 1:\n        if isinstance(args[0], Permutation):\n            for c in args[0].cyclic_form:\n                self.update(self(*c))\n            return\n        elif isinstance(args[0], Cycle):\n            for k, v in args[0].items():\n                self[k] = v\n            return\n    args = [as_int(a) for a in args]\n    if any((i < 0 for i in args)):\n        raise ValueError('negative integers are not allowed in a cycle.')\n    if has_dups(args):\n        raise ValueError('All elements must be unique in a cycle.')\n    for i in range(-len(args), 0):\n        self[args[i]] = args[i + 1]",
    ".sympy.combinatorics.permutations.py@@Permutation.cyclic_form": "def cyclic_form(self):\n    if self._cyclic_form is not None:\n        return list(self._cyclic_form)\n    array_form = self.array_form\n    unchecked = [True] * len(array_form)\n    cyclic_form = []\n    for i in range(len(array_form)):\n        if unchecked[i]:\n            cycle = []\n            cycle.append(i)\n            unchecked[i] = False\n            j = i\n            while unchecked[array_form[j]]:\n                j = array_form[j]\n                cycle.append(j)\n                unchecked[j] = False\n            if len(cycle) > 1:\n                cyclic_form.append(cycle)\n                assert cycle == list(minlex(cycle))\n    cyclic_form.sort()\n    self._cyclic_form = cyclic_form[:]\n    return cyclic_form",
    ".sympy.combinatorics.permutations.py@@Permutation.array_form": "def array_form(self):\n    return self._array_form[:]",
    ".sympy.combinatorics.permutations.py@@Cycle.__call__": "def __call__(self, *other):\n    rv = Cycle(*other)\n    for k, v in zip(list(self.keys()), [rv[self[k]] for k in self.keys()]):\n        rv[k] = v\n    return rv",
    ".sympy.utilities.misc.py@@as_int": "def as_int(n, strict=True):\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n != result:\n            raise ValueError('%s is not an integer' % (n,))\n        return result",
    ".sympy.utilities.iterables.py@@has_dups": "def has_dups(seq):\n    from sympy.core.containers import Dict\n    from sympy.sets.sets import Set\n    if isinstance(seq, (dict, set, Dict, Set)):\n        return False\n    unique = set()\n    try:\n        return any((True for s in seq if s in unique or unique.add(s)))\n    except TypeError:\n        return len(seq) != len(list(uniq(seq)))",
    ".sympy.combinatorics.permutations.py@@Cycle.__repr__": "def __repr__(self):\n    if not self:\n        return 'Cycle()'\n    cycles = Permutation(self).cyclic_form\n    s = ''.join((str(tuple(c)) for c in cycles))\n    big = self.size - 1\n    if not any((i == big for c in cycles for i in c)):\n        s += '(%s)' % big\n    return 'Cycle%s' % s",
    ".sympy.combinatorics.permutations.py@@Permutation.__new__": "def __new__(cls, *args, size=None, **kwargs):\n    if size is not None:\n        size = int(size)\n    ok = True\n    if not args:\n        return cls._af_new(list(range(size or 0)))\n    elif len(args) > 1:\n        return cls._af_new(Cycle(*args).list(size))\n    if len(args) == 1:\n        a = args[0]\n        if isinstance(a, cls):\n            if size is None or size == a.size:\n                return a\n            return cls(a.array_form, size=size)\n        if isinstance(a, Cycle):\n            return cls._af_new(a.list(size))\n        if not is_sequence(a):\n            if size is not None and a + 1 > size:\n                raise ValueError('size is too small when max is %s' % a)\n            return cls._af_new(list(range(a + 1)))\n        if has_variety((is_sequence(ai) for ai in a)):\n            ok = False\n    else:\n        ok = False\n    if not ok:\n        raise ValueError('Permutation argument must be a list of ints, a list of lists, Permutation or Cycle.')\n    args = list(args[0])\n    is_cycle = args and is_sequence(args[0])\n    if is_cycle:\n        args = [[int(i) for i in c] for c in args]\n    else:\n        args = [int(i) for i in args]\n    temp = flatten(args)\n    if has_dups(temp) and (not is_cycle):\n        raise ValueError('there were repeated elements.')\n    temp = set(temp)\n    if not is_cycle:\n        if temp != set(range(len(temp))):\n            raise ValueError('Integers 0 through %s must be present.' % max(temp))\n        if size is not None and temp and (max(temp) + 1 > size):\n            raise ValueError('max element should not exceed %s' % (size - 1))\n    if is_cycle:\n        c = Cycle()\n        for ci in args:\n            c = c(*ci)\n        aform = c.list()\n    else:\n        aform = list(args)\n    if size and size > len(aform):\n        aform.extend(list(range(len(aform), size)))\n    return cls._af_new(aform)",
    ".sympy.combinatorics.permutations.py@@Cycle.list": "def list(self, size=None):\n    if not self and size is None:\n        raise ValueError('must give size for empty Cycle')\n    if size is not None:\n        big = max([i for i in self.keys() if self[i] != i] + [0])\n        size = max(size, big + 1)\n    else:\n        size = self.size\n    return [self[i] for i in range(size)]",
    ".sympy.combinatorics.permutations.py@@Cycle.size": "def size(self):\n    if not self:\n        return 0\n    return max(self.keys()) + 1",
    ".sympy.combinatorics.permutations.py@@Cycle.__missing__": "def __missing__(self, arg):\n    return as_int(arg)",
    ".sympy.combinatorics.permutations.py@@Permutation._af_new": "def _af_new(cls, perm):\n    p = super().__new__(cls)\n    p._array_form = perm\n    p._size = len(perm)\n    return p",
    ".sympy.tensor.tensor.py@@TensExpr.__add__": "def __add__(self, other):\n    return TensAdd(self, other).doit()",
    ".sympy.tensor.tensor.py@@TensAdd.doit": "def doit(self, **hints):\n    deep = hints.get('deep', True)\n    if deep:\n        args = [arg.doit(**hints) for arg in self.args]\n    else:\n        args = self.args\n    if not args:\n        return S.Zero\n    if len(args) == 1 and (not isinstance(args[0], TensExpr)):\n        return args[0]\n    TensAdd._tensAdd_check(args)\n    if len(args) == 1:\n        return args[0]\n    args = [x for x in args if x]\n    if not args:\n        return S.Zero\n    if len(args) == 1:\n        return args[0]\n    args = TensAdd._tensAdd_collect_terms(args)\n\n    def sort_key(t):\n        if not isinstance(t, TensExpr):\n            return ([], [], [])\n        if hasattr(t, '_index_structure') and hasattr(t, 'components'):\n            x = get_index_structure(t)\n            return (t.components, x.free, x.dum)\n        return ([], [], [])\n    args.sort(key=sort_key)\n    if not args:\n        return S.Zero\n    if len(args) == 1:\n        return args[0]\n    obj = self.func(*args)\n    return obj",
    ".sympy.tensor.tensor.py@@TensAdd._tensAdd_check": "def _tensAdd_check(args):\n\n    def get_indices_set(x):\n        if isinstance(x, TensExpr):\n            return set(x.get_free_indices())\n        return set()\n    indices0 = get_indices_set(args[0])\n    list_indices = [get_indices_set(arg) for arg in args[1:]]\n    if not all((x == indices0 for x in list_indices)):\n        raise ValueError('all tensors must have the same indices')",
    ".sympy.tensor.tensor.py@@TensAdd.get_indices_set": "def get_indices_set(x):\n    if isinstance(x, TensExpr):\n        return set(x.get_free_indices())\n    return set()",
    ".sympy.tensor.tensor.py@@TensMul.get_free_indices": "def get_free_indices(self):\n    return self._index_structure.get_free_indices()",
    ".sympy.tensor.tensor.py@@_IndexStructure.get_free_indices": "def get_free_indices(self):\n    free = sorted(self.free, key=lambda x: x[1])\n    return [i[0] for i in free]",
    ".sympy.tensor.tensor.py@@TensAdd._tensAdd_collect_terms": "def _tensAdd_collect_terms(args):\n    terms_dict = defaultdict(list)\n    scalars = S.Zero\n    if isinstance(args[0], TensExpr):\n        free_indices = set(args[0].get_free_indices())\n    else:\n        free_indices = set()\n    for arg in args:\n        if not isinstance(arg, TensExpr):\n            if free_indices != set():\n                raise ValueError('wrong valence')\n            scalars += arg\n            continue\n        if free_indices != set(arg.get_free_indices()):\n            raise ValueError('wrong valence')\n        terms_dict[arg.nocoeff].append(arg.coeff)\n    new_args = [TensMul(Add(*coeff), t).doit() for t, coeff in terms_dict.items() if Add(*coeff) != 0]\n    if isinstance(scalars, Add):\n        new_args = list(scalars.args) + new_args\n    elif scalars != 0:\n        new_args = [scalars] + new_args\n    return new_args",
    ".sympy.tensor.tensor.py@@TensMul.nocoeff": "def nocoeff(self):\n    return self.func(*[t for t in self.args if isinstance(t, TensExpr)]).doit()",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, evaluate=None, _sympify=True):\n    if _sympify:\n        args = list(map(_sympify_, args))\n    typ = cls._args_type\n    if typ is not None:\n        from .relational import Relational\n        if any((isinstance(arg, Relational) for arg in args)):\n            raise TypeError('Relational cannot be used in %s' % cls.__name__)\n        for arg in args:\n            if not isinstance(arg, typ):\n                sympy_deprecation_warning(f'\\n\\nUsing non-Expr arguments in {cls.__name__} is deprecated (in this case, one of\\nthe arguments has type {type(arg).__name__!r}).\\n\\nIf you really did intend to use a multiplication or addition operation with\\nthis object, use the * or + operator instead.\\n\\n                        ', deprecated_since_version='1.7', active_deprecations_target='non-expr-args-deprecated', stacklevel=4)\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if not evaluate:\n        obj = cls._from_args(args)\n        obj = cls._exec_constructor_postprocessors(obj)\n        return obj\n    args = [a for a in args if a is not cls.identity]\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if order_symbols is not None:\n        from sympy.series.order import Order\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.tensor.tensor.py@@TensAdd.sort_key": "def sort_key(t):\n    if not isinstance(t, TensExpr):\n        return ([], [], [])\n    if hasattr(t, '_index_structure') and hasattr(t, 'components'):\n        x = get_index_structure(t)\n        return (t.components, x.free, x.dum)\n    return ([], [], [])",
    ".sympy.tensor.tensor.py@@TensMul.components": "def components(self):\n    return self._get_components_from_args(self.args)",
    ".sympy.tensor.tensor.py@@TensMul._get_components_from_args": "def _get_components_from_args(args):\n    components = []\n    for arg in args:\n        if not isinstance(arg, TensExpr):\n            continue\n        if isinstance(arg, TensAdd):\n            continue\n        components.extend(arg.components)\n    return components",
    ".sympy.tensor.tensor.py@@Tensor.components": "def components(self):\n    return self._components",
    ".sympy.tensor.tensor.py@@get_index_structure": "def get_index_structure(t):\n    if isinstance(t, TensExpr):\n        return t._index_structure\n    return _IndexStructure([], [], [], [])",
    ".sympy.tensor.tensor.py@@TensorIndex.__lt__": "def __lt__(self, other):\n    return (self.tensor_index_type, self.name) < (other.tensor_index_type, other.name)",
    ".sympy.tensor.tensor.py@@TensAdd.get_indices": "def get_indices(self):\n    indices = []\n    for arg in self.args:\n        indices.extend([i for i in get_indices(arg) if i not in indices])\n    return indices",
    ".sympy.tensor.tensor.py@@TensMul.get_indices": "def get_indices(self):\n    return self._indices",
    ".sympy.tensor.tensor.py@@TensAdd._replace_indices": "def _replace_indices(self, repl):\n    newargs = [arg._replace_indices(repl) if isinstance(arg, TensExpr) else arg for arg in self.args]\n    return self.func(*newargs)",
    ".sympy.tensor.tensor.py@@TensMul._replace_indices": "def _replace_indices(self, repl):\n    return self.func(*[arg._replace_indices(repl) if isinstance(arg, TensExpr) else arg for arg in self.args])",
    ".sympy.matrices.dense.py@@eye": "def eye(*args, **kwargs):\n    return Matrix.eye(*args, **kwargs)",
    ".sympy.matrices.common.py@@MatrixSpecial.eye": "def eye(kls, rows, cols=None, **kwargs):\n    if cols is None:\n        cols = rows\n    if rows < 0 or cols < 0:\n        raise ValueError('Cannot create a {} x {} matrix. Both dimensions must be positive'.format(rows, cols))\n    klass = kwargs.get('cls', kls)\n    rows, cols = (as_int(rows), as_int(cols))\n    return klass._eval_eye(rows, cols)",
    ".sympy.matrices.repmatrix.py@@RepMatrix._eval_eye": "def _eval_eye(cls, rows, cols):\n    rep = DomainMatrix.eye((rows, cols), ZZ)\n    return cls._fromrep(rep)",
    ".sympy.polys.matrices.domainmatrix.py@@DomainMatrix.eye": "def eye(cls, shape, domain):\n    if isinstance(shape, int):\n        shape = (shape, shape)\n    return cls.from_rep(SDM.eye(shape, domain))",
    ".sympy.polys.matrices.sdm.py@@SDM.eye": "def eye(cls, shape, domain):\n    rows, cols = shape\n    one = domain.one\n    sdm = {i: {i: one} for i in range(min(rows, cols))}\n    return cls(sdm, shape, domain)",
    ".sympy.polys.matrices.sdm.py@@SDM.__init__": "def __init__(self, elemsdict, shape, domain):\n    super().__init__(elemsdict)\n    self.shape = self.rows, self.cols = m, n = shape\n    self.domain = domain\n    if not all((0 <= r < m for r in self)):\n        raise DMBadInputError('Row out of range')\n    if not all((0 <= c < n for row in self.values() for c in row)):\n        raise DMBadInputError('Column out of range')",
    ".sympy.polys.matrices.domainmatrix.py@@DomainMatrix.from_rep": "def from_rep(cls, rep):\n    if not isinstance(rep, (DDM, SDM)):\n        raise TypeError('rep should be of type DDM or SDM')\n    self = super().__new__(cls)\n    self.rep = rep\n    self.shape = rep.shape\n    self.domain = rep.domain\n    return self",
    ".sympy.matrices.repmatrix.py@@MutableRepMatrix._fromrep": "def _fromrep(cls, rep):\n    obj = super().__new__(cls)\n    obj.rows, obj.cols = rep.shape\n    obj._rep = rep\n    return obj",
    ".sympy.matrices.common.py@@MatrixArithmetic.__mul__": "def __mul__(self, other):\n    return self.multiply(other)",
    ".sympy.matrices.common.py@@MatrixArithmetic.multiply": "def multiply(self, other, dotprodsimp=None):\n    isimpbool = _get_intermediate_simp_bool(False, dotprodsimp)\n    other = _matrixify(other)\n    if hasattr(other, 'shape') and len(other.shape) == 2 and (getattr(other, 'is_Matrix', True) or getattr(other, 'is_MatrixLike', True)):\n        if self.shape[1] != other.shape[0]:\n            raise ShapeError('Matrix size mismatch: %s * %s.' % (self.shape, other.shape))\n    if getattr(other, 'is_Matrix', False):\n        m = self._eval_matrix_mul(other)\n        if isimpbool:\n            return m._new(m.rows, m.cols, [_dotprodsimp(e) for e in m])\n        return m\n    if getattr(other, 'is_MatrixLike', False):\n        return MatrixArithmetic._eval_matrix_mul(self, other)\n    if not isinstance(other, Iterable):\n        try:\n            return self._eval_scalar_mul(other)\n        except TypeError:\n            pass\n    return NotImplemented",
    ".sympy.matrices.utilities.py@@_get_intermediate_simp_bool": "def _get_intermediate_simp_bool(default=False, dotprodsimp=None):\n    return _get_intermediate_simp(default, False, True, dotprodsimp)",
    ".sympy.matrices.utilities.py@@_get_intermediate_simp": "def _get_intermediate_simp(deffunc=lambda x: x, offfunc=lambda x: x, onfunc=_dotprodsimp, dotprodsimp=None):\n    if dotprodsimp is False or _dotprodsimp_state.state is False:\n        return offfunc\n    if dotprodsimp is True or _dotprodsimp_state.state is True:\n        return onfunc\n    return deffunc",
    ".sympy.matrices.common.py@@_matrixify": "def _matrixify(mat):\n    if getattr(mat, 'is_Matrix', False) or getattr(mat, 'is_MatrixLike', False):\n        return mat\n    if not (getattr(mat, 'is_Matrix', True) or getattr(mat, 'is_MatrixLike', True)):\n        return mat\n    shape = None\n    if hasattr(mat, 'shape'):\n        if len(mat.shape) == 2:\n            shape = mat.shape\n    elif hasattr(mat, 'rows') and hasattr(mat, 'cols'):\n        shape = (mat.rows, mat.cols)\n    if shape:\n        return _MatrixWrapper(mat, shape)\n    return mat",
    ".sympy.matrices.repmatrix.py@@RepMatrix._eval_scalar_mul": "def _eval_scalar_mul(self, other):\n    rep, other = self._unify_element_sympy(self._rep, other)\n    return self._fromrep(rep.scalarmul(other))",
    ".sympy.matrices.repmatrix.py@@RepMatrix._unify_element_sympy": "def _unify_element_sympy(cls, rep, element):\n    domain = rep.domain\n    element = _sympify(element)\n    if domain != EXRAW:\n        if element.is_Integer:\n            new_domain = domain\n        elif element.is_Rational:\n            new_domain = QQ\n        else:\n            new_domain = EXRAW\n        if new_domain != domain:\n            rep = rep.convert_to(new_domain)\n            domain = new_domain\n        if domain != EXRAW:\n            element = new_domain.from_sympy(element)\n    if domain == EXRAW and (not isinstance(element, Expr)):\n        sympy_deprecation_warning('\\n            non-Expr objects in a Matrix is deprecated. Matrix represents\\n            a mathematical matrix. To represent a container of non-numeric\\n            entities, Use a list of lists, TableForm, NumPy array, or some\\n            other data structure instead.\\n            ', deprecated_since_version='1.9', active_deprecations_target='deprecated-non-expr-in-matrix', stacklevel=4)\n    return (rep, element)",
    ".sympy.polys.domains.domain.py@@Domain.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.polys.domains.domain.py@@Domain.__eq__": "def __eq__(self, other):\n    return isinstance(other, Domain) and self.dtype == other.dtype",
    ".sympy.polys.domains.integerring.py@@IntegerRing.from_sympy": "def from_sympy(self, a):\n    if a.is_Integer:\n        return MPZ(a.p)\n    elif a.is_Float and int(a) == a:\n        return MPZ(int(a))\n    else:\n        raise CoercionFailed('expected an integer, got %s' % a)",
    ".sympy.polys.matrices.domainmatrix.py@@DomainMatrix.scalarmul": "def scalarmul(A, lamda):\n    return A._scalarmul(lamda, reverse=False)",
    ".sympy.polys.matrices.domainmatrix.py@@DomainMatrix._scalarmul": "def _scalarmul(A, lamda, reverse):\n    if lamda == A.domain.zero:\n        return DomainMatrix.zeros(A.shape, A.domain)\n    elif lamda == A.domain.one:\n        return A.copy()\n    elif reverse:\n        return A.rmul(lamda)\n    else:\n        return A.mul(lamda)",
    ".sympy.polys.matrices.domainmatrix.py@@DomainMatrix.mul": "def mul(A, b):\n    return A.from_rep(A.rep.mul(b))",
    ".sympy.polys.matrices.sdm.py@@SDM.mul": "def mul(A, b):\n    Csdm = unop_dict(A, lambda aij: aij * b)\n    return A.new(Csdm, A.shape, A.domain)",
    ".sympy.polys.matrices.sdm.py@@unop_dict": "def unop_dict(A, f):\n    B = {}\n    for i, Ai in A.items():\n        Bi = {}\n        for j, Aij in Ai.items():\n            Bij = f(Aij)\n            if Bij:\n                Bi[j] = Bij\n        if Bi:\n            B[i] = Bi\n    return B",
    ".sympy.polys.matrices.sdm.py@@SDM.new": "def new(cls, sdm, shape, domain):\n    return cls(sdm, shape, domain)",
    ".sympy.tensor.tensor.py@@Tensor.coeff": "def coeff(self):\n    return self._coeff"
}