{
    ".xarray.core.pdcompat.py@@count_not_none": "def count_not_none(*args) -> int:\n    return sum((arg is not None for arg in args))",
    ".xarray.coding.cftime_offsets.py@@to_cftime_datetime": "def to_cftime_datetime(date_str_or_date, calendar=None):\n    import cftime\n    if isinstance(date_str_or_date, str):\n        if calendar is None:\n            raise ValueError('If converting a string to a cftime.datetime object, a calendar type must be provided')\n        date, _ = _parse_iso8601_with_reso(get_date_type(calendar), date_str_or_date)\n        return date\n    elif isinstance(date_str_or_date, cftime.datetime):\n        return date_str_or_date\n    else:\n        raise TypeError('date_str_or_date must be a string or a subclass of cftime.datetime. Instead got {!r}.'.format(date_str_or_date))",
    ".xarray.coding.cftime_offsets.py@@get_date_type": "def get_date_type(calendar):\n    try:\n        import cftime\n    except ImportError:\n        raise ImportError('cftime is required for dates with non-standard calendars')\n    else:\n        calendars = {'noleap': cftime.DatetimeNoLeap, '360_day': cftime.Datetime360Day, '365_day': cftime.DatetimeNoLeap, '366_day': cftime.DatetimeAllLeap, 'gregorian': cftime.DatetimeGregorian, 'proleptic_gregorian': cftime.DatetimeProlepticGregorian, 'julian': cftime.DatetimeJulian, 'all_leap': cftime.DatetimeAllLeap, 'standard': cftime.DatetimeGregorian}\n        return calendars[calendar]",
    ".xarray.coding.cftimeindex.py@@_parse_iso8601_with_reso": "def _parse_iso8601_with_reso(date_type, timestr):\n    import cftime\n    default = date_type(1, 1, 1)\n    result = parse_iso8601_like(timestr)\n    replace = {}\n    for attr in ['year', 'month', 'day', 'hour', 'minute', 'second']:\n        value = result.get(attr, None)\n        if value is not None:\n            replace[attr] = int(value)\n            resolution = attr\n    if LooseVersion(cftime.__version__) < LooseVersion('1.0.4'):\n        replace['dayofwk'] = -1\n    return (default.replace(**replace), resolution)",
    ".xarray.coding.cftimeindex.py@@parse_iso8601_like": "def parse_iso8601_like(datetime_string):\n    for pattern in _PATTERNS:\n        match = re.match(pattern, datetime_string)\n        if match:\n            return match.groupdict()\n    raise ValueError(f'no ISO-8601 or cftime-string-like match for string: {datetime_string}')",
    ".xarray.coding.cftime_offsets.py@@_maybe_normalize_date": "def _maybe_normalize_date(date, normalize):\n    if normalize:\n        return normalize_date(date)\n    else:\n        return date",
    ".xarray.coding.cftime_offsets.py@@to_offset": "def to_offset(freq):\n    if isinstance(freq, BaseCFTimeOffset):\n        return freq\n    else:\n        try:\n            freq_data = re.match(_PATTERN, freq).groupdict()\n        except AttributeError:\n            raise ValueError('Invalid frequency string provided')\n    freq = freq_data['freq']\n    multiples = freq_data['multiple']\n    if multiples is None:\n        multiples = 1\n    else:\n        multiples = int(multiples)\n    return _FREQUENCIES[freq](n=multiples)",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.__init__": "def __init__(self, n=1):\n    if not isinstance(n, int):\n        raise TypeError(\"The provided multiple 'n' must be an integer. Instead a value of type {!r} was provided.\".format(type(n)))\n    self.n = n",
    ".xarray.coding.cftime_offsets.py@@_generate_range": "def _generate_range(start, end, periods, offset):\n    if start:\n        start = offset.rollforward(start)\n    if end:\n        end = offset.rollback(end)\n    if periods is None and end < start:\n        end = None\n        periods = 0\n    if end is None:\n        end = start + (periods - 1) * offset\n    if start is None:\n        start = end - (periods - 1) * offset\n    current = start\n    if offset.n >= 0:\n        while current <= end:\n            yield current\n            next_date = current + offset\n            if next_date <= current:\n                raise ValueError(f'Offset {offset} did not increment date')\n            current = next_date\n    else:\n        while current >= end:\n            yield current\n            next_date = current + offset\n            if next_date >= current:\n                raise ValueError(f'Offset {offset} did not decrement date')\n            current = next_date",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.rollforward": "def rollforward(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date + type(self)()",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.onOffset": "def onOffset(self, date):\n    test_date = self + date - self\n    return date == test_date",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.__add__": "def __add__(self, other):\n    return self.__apply__(other)",
    ".xarray.coding.cftime_offsets.py@@Day.__apply__": "def __apply__(self, other):\n    return other + self.as_timedelta()",
    ".xarray.coding.cftime_offsets.py@@Day.as_timedelta": "def as_timedelta(self):\n    return timedelta(days=self.n)",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.__rsub__": "def __rsub__(self, other):\n    if isinstance(other, BaseCFTimeOffset) and type(self) != type(other):\n        raise TypeError('Cannot subtract cftime offsets of differing types')\n    return -self + other",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.__neg__": "def __neg__(self):\n    return self * -1",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.__mul__": "def __mul__(self, other):\n    return type(self)(n=other * self.n)",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.rollback": "def rollback(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date - type(self)()",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.__radd__": "def __radd__(self, other):\n    return self.__add__(other)",
    ".xarray.coding.cftime_offsets.py@@normalize_date": "def normalize_date(date):\n    return date.replace(hour=0, minute=0, second=0, microsecond=0)",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset.__rmul__": "def __rmul__(self, other):\n    return self.__mul__(other)",
    ".xarray.coding.cftime_offsets.py@@YearOffset.__init__": "def __init__(self, n=1, month=None):\n    BaseCFTimeOffset.__init__(self, n)\n    self.month = _validate_month(month, self._default_month)",
    ".xarray.coding.cftime_offsets.py@@_validate_month": "def _validate_month(month, default_month):\n    if month is None:\n        result_month = default_month\n    else:\n        result_month = month\n    if not isinstance(result_month, int):\n        raise TypeError(\"'self.month' must be an integer value between 1 and 12.  Instead, it was set to a value of {!r}\".format(result_month))\n    elif not 1 <= result_month <= 12:\n        raise ValueError(\"'self.month' must be an integer value between 1 and 12.  Instead, it was set to a value of {!r}\".format(result_month))\n    return result_month",
    ".xarray.coding.cftime_offsets.py@@YearBegin.rollforward": "def rollforward(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date + YearBegin(month=self.month)",
    ".xarray.coding.cftime_offsets.py@@YearBegin.onOffset": "def onOffset(self, date):\n    return date.day == 1 and date.month == self.month",
    ".xarray.coding.cftime_offsets.py@@YearOffset.__apply__": "def __apply__(self, other):\n    reference_day = _get_day_of_month(other, self._day_option)\n    years = _adjust_n_years(other, self.n, self.month, reference_day)\n    months = years * 12 + (self.month - other.month)\n    return _shift_month(other, months, self._day_option)",
    ".xarray.coding.cftime_offsets.py@@_get_day_of_month": "def _get_day_of_month(other, day_option):\n    if day_option == 'start':\n        return 1\n    elif day_option == 'end':\n        days_in_month = _days_in_month(other)\n        return days_in_month\n    elif day_option is None:\n        raise NotImplementedError()\n    else:\n        raise ValueError(day_option)",
    ".xarray.coding.cftime_offsets.py@@_adjust_n_years": "def _adjust_n_years(other, n, month, reference_day):\n    if n > 0:\n        if other.month < month or (other.month == month and other.day < reference_day):\n            n -= 1\n    elif other.month > month or (other.month == month and other.day > reference_day):\n        n += 1\n    return n",
    ".xarray.coding.cftime_offsets.py@@_shift_month": "def _shift_month(date, months, day_option='start'):\n    import cftime\n    delta_year = (date.month + months) // 12\n    month = (date.month + months) % 12\n    if month == 0:\n        month = 12\n        delta_year = delta_year - 1\n    year = date.year + delta_year\n    if day_option == 'start':\n        day = 1\n    elif day_option == 'end':\n        reference = type(date)(year, month, 1)\n        day = _days_in_month(reference)\n    else:\n        raise ValueError(day_option)\n    if LooseVersion(cftime.__version__) < LooseVersion('1.0.4'):\n        return date.replace(year=year, month=month, day=day, dayofwk=-1)\n    else:\n        return date.replace(year=year, month=month, day=day)",
    ".xarray.coding.cftime_offsets.py@@YearBegin.rollback": "def rollback(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date - YearBegin(month=self.month)",
    ".xarray.coding.cftime_offsets.py@@YearOffset.__mul__": "def __mul__(self, other):\n    return type(self)(n=other * self.n, month=self.month)",
    ".xarray.coding.cftime_offsets.py@@_generate_linear_range": "def _generate_linear_range(start, end, periods):\n    import cftime\n    total_seconds = (end - start).total_seconds()\n    values = np.linspace(0.0, total_seconds, periods, endpoint=True)\n    units = 'seconds since {}'.format(format_cftime_datetime(start))\n    calendar = start.calendar\n    return cftime.num2date(values, units=units, calendar=calendar, only_use_cftime_datetimes=True)",
    ".xarray.coding.times.py@@format_cftime_datetime": "def format_cftime_datetime(date):\n    return '{:04d}-{:02d}-{:02d} {:02d}:{:02d}:{:02d}.{:06d}'.format(date.year, date.month, date.day, date.hour, date.minute, date.second, date.microsecond)",
    ".xarray.coding.cftime_offsets.py@@QuarterOffset.__init__": "def __init__(self, n=1, month=None):\n    BaseCFTimeOffset.__init__(self, n)\n    self.month = _validate_month(month, self._default_month)",
    ".xarray.coding.cftime_offsets.py@@QuarterBegin.rollforward": "def rollforward(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date + QuarterBegin(month=self.month)",
    ".xarray.coding.cftime_offsets.py@@QuarterOffset.onOffset": "def onOffset(self, date):\n    mod_month = (date.month - self.month) % 3\n    return mod_month == 0 and date.day == self._get_offset_day(date)",
    ".xarray.coding.cftime_offsets.py@@BaseCFTimeOffset._get_offset_day": "def _get_offset_day(self, other):\n    return _get_day_of_month(other, self._day_option)",
    ".xarray.coding.cftime_offsets.py@@QuarterOffset.__mul__": "def __mul__(self, other):\n    return type(self)(n=other * self.n, month=self.month)",
    ".xarray.coding.cftime_offsets.py@@QuarterOffset.__apply__": "def __apply__(self, other):\n    months_since = other.month % 3 - self.month % 3\n    qtrs = roll_qtrday(other, self.n, self.month, day_option=self._day_option, modby=3)\n    months = qtrs * 3 - months_since\n    return _shift_month(other, months, self._day_option)",
    ".xarray.coding.cftime_offsets.py@@roll_qtrday": "def roll_qtrday(other, n, month, day_option, modby=3):\n    months_since = other.month % modby - month % modby\n    if n > 0:\n        if months_since < 0 or (months_since == 0 and other.day < _get_day_of_month(other, day_option)):\n            n -= 1\n    elif months_since > 0 or (months_since == 0 and other.day > _get_day_of_month(other, day_option)):\n        n += 1\n    return n",
    ".xarray.coding.cftime_offsets.py@@MonthEnd.onOffset": "def onOffset(self, date):\n    return date.day == _days_in_month(date)",
    ".xarray.coding.cftime_offsets.py@@_days_in_month": "def _days_in_month(date):\n    if date.month == 12:\n        reference = type(date)(date.year + 1, 1, 1)\n    else:\n        reference = type(date)(date.year, date.month + 1, 1)\n    return (reference - timedelta(days=1)).day",
    ".xarray.coding.cftime_offsets.py@@MonthEnd.__apply__": "def __apply__(self, other):\n    n = _adjust_n_months(other.day, self.n, _days_in_month(other))\n    return _shift_month(other, n, 'end')",
    ".xarray.coding.cftime_offsets.py@@_adjust_n_months": "def _adjust_n_months(other_day, n, reference_day):\n    if n > 0 and other_day < reference_day:\n        n = n - 1\n    elif n <= 0 and other_day > reference_day:\n        n = n + 1\n    return n",
    ".xarray.coding.cftime_offsets.py@@YearEnd.rollforward": "def rollforward(self, date):\n    if self.onOffset(date):\n        return date\n    else:\n        return date + YearEnd(month=self.month)",
    ".xarray.coding.cftime_offsets.py@@YearEnd.onOffset": "def onOffset(self, date):\n    return date.day == _days_in_month(date) and date.month == self.month",
    ".xarray.coding.cftime_offsets.py@@Microsecond.__apply__": "def __apply__(self, other):\n    return other + self.as_timedelta()",
    ".xarray.coding.cftime_offsets.py@@Microsecond.as_timedelta": "def as_timedelta(self):\n    return timedelta(microseconds=self.n)",
    ".xarray.coding.cftime_offsets.py@@Millisecond.__apply__": "def __apply__(self, other):\n    return other + self.as_timedelta()",
    ".xarray.coding.cftime_offsets.py@@Millisecond.as_timedelta": "def as_timedelta(self):\n    return timedelta(milliseconds=self.n)",
    ".xarray.coding.cftime_offsets.py@@Second.__apply__": "def __apply__(self, other):\n    return other + self.as_timedelta()",
    ".xarray.coding.cftime_offsets.py@@Second.as_timedelta": "def as_timedelta(self):\n    return timedelta(seconds=self.n)",
    ".xarray.coding.cftime_offsets.py@@Minute.__apply__": "def __apply__(self, other):\n    return other + self.as_timedelta()",
    ".xarray.coding.cftime_offsets.py@@Minute.as_timedelta": "def as_timedelta(self):\n    return timedelta(minutes=self.n)",
    ".xarray.coding.cftime_offsets.py@@Hour.__apply__": "def __apply__(self, other):\n    return other + self.as_timedelta()",
    ".xarray.coding.cftime_offsets.py@@Hour.as_timedelta": "def as_timedelta(self):\n    return timedelta(hours=self.n)"
}