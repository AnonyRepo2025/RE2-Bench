{
    ".xarray.core.utils.py@@SortedKeysDict.__init__": "def __init__(self, mapping: MutableMapping[K, V]=None):\n    self.mapping = {} if mapping is None else mapping",
    ".xarray.core.utils.py@@Frozen.__init__": "def __init__(self, mapping: Mapping[K, V]):\n    self.mapping = mapping",
    ".xarray.core.utils.py@@Frozen.__iter__": "def __iter__(self) -> Iterator[K]:\n    return iter(self.mapping)",
    ".xarray.core.utils.py@@SortedKeysDict.__iter__": "def __iter__(self) -> Iterator[K]:\n    return iter(sorted(self.mapping))",
    ".xarray.core.utils.py@@Frozen.__contains__": "def __contains__(self, key: object) -> bool:\n    return key in self.mapping",
    ".xarray.core.utils.py@@SortedKeysDict.__contains__": "def __contains__(self, key: object) -> bool:\n    return key in self.mapping",
    ".xarray.core.options.py@@_get_keep_attrs": "def _get_keep_attrs(default):\n    global_choice = OPTIONS['keep_attrs']\n    if global_choice == 'default':\n        return default\n    elif global_choice in [True, False]:\n        return global_choice\n    else:\n        raise ValueError(\"The global option keep_attrs must be one of True, False or 'default'.\")",
    ".xarray.core.variable.py@@Variable.dims": "def dims(self):\n    return self._dims",
    ".xarray.core.coordinates.py@@DatasetCoordinates.__init__": "def __init__(self, dataset: 'Dataset'):\n    self._data = dataset",
    ".xarray.core.coordinates.py@@Coordinates.__contains__": "def __contains__(self, key: Hashable) -> bool:\n    return key in self._names",
    ".xarray.core.coordinates.py@@DatasetCoordinates._names": "def _names(self) -> Set[Hashable]:\n    return self._data._coord_names",
    ".xarray.core.variable.py@@Variable.dtype": "def dtype(self):\n    return self._data.dtype",
    ".xarray.core.variable.py@@Variable.reduce": "def reduce(self, func, dim=None, axis=None, keep_attrs=None, keepdims=False, **kwargs):\n    if dim == ...:\n        dim = None\n    if dim is not None and axis is not None:\n        raise ValueError(\"cannot supply both 'axis' and 'dim' arguments\")\n    if dim is not None:\n        axis = self.get_axis_num(dim)\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', 'Mean of empty slice', category=RuntimeWarning)\n        if axis is not None:\n            data = func(self.data, axis=axis, **kwargs)\n        else:\n            data = func(self.data, **kwargs)\n    if getattr(data, 'shape', ()) == self.shape:\n        dims = self.dims\n    else:\n        removed_axes = range(self.ndim) if axis is None else np.atleast_1d(axis) % self.ndim\n        if keepdims:\n            slices = tuple((np.newaxis if i in removed_axes else slice(None, None) for i in range(self.ndim)))\n            if getattr(data, 'shape', None) is None:\n                data = np.asanyarray(data)[slices]\n            else:\n                data = data[slices]\n            dims = self.dims\n        else:\n            dims = [adim for n, adim in enumerate(self.dims) if n not in removed_axes]\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=False)\n    attrs = self._attrs if keep_attrs else None\n    return Variable(dims, data, attrs=attrs)",
    ".xarray.core.common.py@@AbstractArray.get_axis_num": "def get_axis_num(self, dim: Union[Hashable, Iterable[Hashable]]) -> Union[int, Tuple[int, ...]]:\n    if isinstance(dim, Iterable) and (not isinstance(dim, str)):\n        return tuple((self._get_axis_num(d) for d in dim))\n    else:\n        return self._get_axis_num(dim)",
    ".xarray.core.common.py@@AbstractArray._get_axis_num": "def _get_axis_num(self: Any, dim: Hashable) -> int:\n    try:\n        return self.dims.index(dim)\n    except ValueError:\n        raise ValueError(f'{dim!r} not found in array dimensions {self.dims!r}')",
    ".xarray.core.variable.py@@Variable.data": "def data(self):\n    if is_duck_array(self._data):\n        return self._data\n    else:\n        return self.values",
    ".xarray.core.utils.py@@is_duck_array": "def is_duck_array(value: Any) -> bool:\n    if isinstance(value, np.ndarray):\n        return True\n    return hasattr(value, 'ndim') and hasattr(value, 'shape') and hasattr(value, 'dtype') and hasattr(value, '__array_function__') and hasattr(value, '__array_ufunc__')",
    ".xarray.core.duck_array_ops.py@@mean": "def mean(array, axis=None, skipna=None, **kwargs):\n    from .common import _contains_cftime_datetimes\n    array = asarray(array)\n    if array.dtype.kind in 'Mm':\n        offset = _datetime_nanmin(array)\n        dtype = 'timedelta64[ns]'\n        return _mean(datetime_to_numeric(array, offset), axis=axis, skipna=skipna, **kwargs).astype(dtype) + offset\n    elif _contains_cftime_datetimes(array):\n        if is_duck_dask_array(array):\n            raise NotImplementedError('Computing the mean of an array containing cftime.datetime objects is not yet implemented on dask arrays.')\n        offset = min(array)\n        timedeltas = datetime_to_numeric(array, offset, datetime_unit='us')\n        mean_timedeltas = _mean(timedeltas, axis=axis, skipna=skipna, **kwargs)\n        return _to_pytimedelta(mean_timedeltas, unit='us') + offset\n    else:\n        return _mean(array, axis=axis, skipna=skipna, **kwargs)",
    ".xarray.core.duck_array_ops.py@@asarray": "def asarray(data, xp=np):\n    return data if is_duck_array(data) else xp.asarray(data)",
    ".xarray.core.common.py@@_contains_cftime_datetimes": "def _contains_cftime_datetimes(array) -> bool:\n    try:\n        from cftime import datetime as cftime_datetime\n    except ImportError:\n        return False\n    else:\n        if array.dtype == np.dtype('O') and array.size > 0:\n            sample = array.ravel()[0]\n            if is_duck_dask_array(sample):\n                sample = sample.compute()\n                if isinstance(sample, np.ndarray):\n                    sample = sample.item()\n            return isinstance(sample, cftime_datetime)\n        else:\n            return False",
    ".xarray.core.duck_array_ops.py@@f": "def f(values, axis=None, skipna=None, **kwargs):\n    if kwargs.pop('out', None) is not None:\n        raise TypeError(f'`out` is not valid for {name}')\n    values = asarray(values)\n    if coerce_strings and values.dtype.kind in 'SU':\n        values = values.astype(object)\n    func = None\n    if skipna or (skipna is None and values.dtype.kind in 'cfO'):\n        nanname = 'nan' + name\n        func = getattr(nanops, nanname)\n    else:\n        if name in ['sum', 'prod']:\n            kwargs.pop('min_count', None)\n        func = _dask_or_eager_func(name, dask_module=dask_module)\n    try:\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore', 'All-NaN slice encountered')\n            return func(values, axis=axis, **kwargs)\n    except AttributeError:\n        if not is_duck_dask_array(values):\n            raise\n        try:\n            return func(values, axis=axis, dtype=values.dtype, **kwargs)\n        except (AttributeError, TypeError):\n            raise NotImplementedError(f'{name} is not yet implemented on dask arrays')",
    ".xarray.core.nanops.py@@nanmean": "def nanmean(a, axis=None, dtype=None, out=None):\n    if a.dtype.kind == 'O':\n        return _nanmean_ddof_object(0, a, axis=axis, dtype=dtype)\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', 'Mean of empty slice', category=RuntimeWarning)\n        if isinstance(a, dask_array_type):\n            return dask_array.nanmean(a, axis=axis, dtype=dtype)\n        return np.nanmean(a, axis=axis, dtype=dtype)",
    ".xarray.core.variable.py@@Variable.shape": "def shape(self):\n    return self._data.shape",
    ".xarray.core.utils.py@@NdimSizeLenMixin.ndim": "def ndim(self: Any) -> int:\n    return len(self.shape)",
    ".xarray.core.variable.py@@Variable.__init__": "def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):\n    self._data = as_compatible_data(data, fastpath=fastpath)\n    self._dims = self._parse_dimensions(dims)\n    self._attrs = None\n    self._encoding = None\n    if attrs is not None:\n        self.attrs = attrs\n    if encoding is not None:\n        self.encoding = encoding",
    ".xarray.core.variable.py@@as_compatible_data": "def as_compatible_data(data, fastpath=False):\n    if fastpath and getattr(data, 'ndim', 0) > 0:\n        return _maybe_wrap_data(data)\n    if isinstance(data, Variable):\n        return data.data\n    if isinstance(data, NON_NUMPY_SUPPORTED_ARRAY_TYPES):\n        return _maybe_wrap_data(data)\n    if isinstance(data, tuple):\n        data = utils.to_0d_object_array(data)\n    if isinstance(data, pd.Timestamp):\n        data = np.datetime64(data.value, 'ns')\n    if isinstance(data, timedelta):\n        data = np.timedelta64(getattr(data, 'value', data), 'ns')\n    if isinstance(data, (pd.Series, pd.Index, pd.DataFrame)):\n        data = data.values\n    if isinstance(data, np.ma.MaskedArray):\n        mask = np.ma.getmaskarray(data)\n        if mask.any():\n            dtype, fill_value = dtypes.maybe_promote(data.dtype)\n            data = np.asarray(data, dtype=dtype)\n            data[mask] = fill_value\n        else:\n            data = np.asarray(data)\n    if not isinstance(data, np.ndarray):\n        if hasattr(data, '__array_function__'):\n            if IS_NEP18_ACTIVE:\n                return data\n            else:\n                raise TypeError('Got an NumPy-like array type providing the __array_function__ protocol but NEP18 is not enabled. Check that numpy >= v1.16 and that the environment variable \"NUMPY_EXPERIMENTAL_ARRAY_FUNCTION\" is set to \"1\"')\n    data = np.asarray(data)\n    if isinstance(data, np.ndarray):\n        if data.dtype.kind == 'O':\n            data = _possibly_convert_objects(data)\n        elif data.dtype.kind == 'M':\n            data = _possibly_convert_objects(data)\n        elif data.dtype.kind == 'm':\n            data = _possibly_convert_objects(data)\n    return _maybe_wrap_data(data)",
    ".xarray.core.variable.py@@_maybe_wrap_data": "def _maybe_wrap_data(data):\n    if isinstance(data, pd.Index):\n        return PandasIndexAdapter(data)\n    return data",
    ".xarray.core.variable.py@@Variable._parse_dimensions": "def _parse_dimensions(self, dims):\n    if isinstance(dims, str):\n        dims = (dims,)\n    dims = tuple(dims)\n    if len(dims) != self.ndim:\n        raise ValueError('dimensions %s must have the same length as the number of data dimensions, ndim=%s' % (dims, self.ndim))\n    return dims",
    ".xarray.core.coordinates.py@@Coordinates.__iter__": "def __iter__(self) -> Iterator['Hashable']:\n    for k in self.variables:\n        if k in self._names:\n            yield k",
    ".xarray.core.coordinates.py@@DatasetCoordinates.variables": "def variables(self) -> Mapping[Hashable, Variable]:\n    return Frozen({k: v for k, v in self._data.variables.items() if k in self._names})",
    ".xarray.core.utils.py@@Frozen.__getitem__": "def __getitem__(self, key: K) -> V:\n    return self.mapping[key]",
    ".xarray.core.indexes.py@@Indexes.__init__": "def __init__(self, indexes):\n    self._indexes = indexes",
    ".xarray.core.indexes.py@@Indexes.__iter__": "def __iter__(self):\n    return iter(self._indexes)",
    ".xarray.core.indexes.py@@Indexes.__getitem__": "def __getitem__(self, key):\n    return self._indexes[key]",
    ".xarray.core.duck_array_ops.py@@_dask_or_eager_func": "def _dask_or_eager_func(name, eager_module=np, dask_module=dask_array, list_of_args=False, array_args=slice(1), requires_dask=None):\n    if dask_module is not None:\n\n        def f(*args, **kwargs):\n            if list_of_args:\n                dispatch_args = args[0]\n            else:\n                dispatch_args = args[array_args]\n            if any((is_duck_dask_array(a) for a in dispatch_args)):\n                try:\n                    wrapped = getattr(dask_module, name)\n                except AttributeError as e:\n                    raise AttributeError(f'{e}: requires dask >={requires_dask}')\n            else:\n                wrapped = getattr(eager_module, name)\n            return wrapped(*args, **kwargs)\n    else:\n\n        def f(*args, **kwargs):\n            return getattr(eager_module, name)(*args, **kwargs)\n    return f",
    ".xarray.core.pycompat.py@@is_duck_dask_array": "def is_duck_dask_array(x):\n    return is_duck_array(x) and is_dask_collection(x)",
    ".xarray.core.indexes.py@@default_indexes": "def default_indexes(coords: Mapping[Any, Variable], dims: Iterable) -> Dict[Hashable, pd.Index]:\n    return {key: coords[key].to_index() for key in dims if key in coords}",
    ".xarray.core.common.py@@AttrAccessMixin.__setattr__": "def __setattr__(self, name: str, value: Any) -> None:\n    try:\n        object.__setattr__(self, name, value)\n    except AttributeError as e:\n        if str(e) != '{!r} object has no attribute {!r}'.format(type(self).__name__, name):\n            raise\n        raise AttributeError(\"cannot set attribute %r on a %r object. Use __setitem__ styleassignment (e.g., `ds['name'] = ...`) instead of assigning variables.\" % (name, type(self).__name__)) from e",
    ".xarray.core.duck_array_ops.py@@first": "def first(values, axis, skipna=None):\n    if (skipna or skipna is None) and values.dtype.kind not in 'iSU':\n        _fail_on_dask_array_input_skipna(values)\n        return nanfirst(values, axis)\n    return take(values, 0, axis=axis)",
    ".xarray.core.duck_array_ops.py@@fail_on_dask_array_input": "def fail_on_dask_array_input(values, msg=None, func_name=None):\n    if is_duck_dask_array(values):\n        if msg is None:\n            msg = '%r is not yet a valid method on dask arrays'\n        if func_name is None:\n            func_name = inspect.stack()[1][3]\n        raise NotImplementedError(msg % func_name)",
    ".xarray.core.nputils.py@@nanfirst": "def nanfirst(values, axis):\n    axis = normalize_axis_index(axis, values.ndim)\n    idx_first = np.argmax(~pd.isnull(values), axis=axis)\n    return _select_along_axis(values, idx_first, axis)",
    ".xarray.core.nputils.py@@_select_along_axis": "def _select_along_axis(values, idx, axis):\n    other_ind = np.ix_(*[np.arange(s) for s in idx.shape])\n    sl = other_ind[:axis] + (idx,) + other_ind[axis:]\n    return values[sl]",
    ".xarray.core.variable.py@@Variable.attrs": "def attrs(self) -> Dict[Hashable, Any]:\n    if self._attrs is None:\n        self._attrs = {}\n    return self._attrs",
    ".xarray.core.dataset.py@@Dataset.attrs": "def attrs(self) -> Dict[Hashable, Any]:\n    if self._attrs is None:\n        self._attrs = {}\n    return self._attrs",
    ".xarray.core.nanops.py@@nansum": "def nansum(a, axis=None, dtype=None, out=None, min_count=None):\n    a, mask = _replace_nan(a, 0)\n    result = _dask_or_eager_func('sum')(a, axis=axis, dtype=dtype)\n    if min_count is not None:\n        return _maybe_null_out(result, axis, mask, min_count)\n    else:\n        return result",
    ".xarray.core.nanops.py@@_replace_nan": "def _replace_nan(a, val):\n    mask = isnull(a)\n    return (where_method(val, mask, a), mask)",
    ".xarray.core.duck_array_ops.py@@isnull": "def isnull(data):\n    data = asarray(data)\n    scalar_type = data.dtype.type\n    if issubclass(scalar_type, (np.datetime64, np.timedelta64)):\n        return isnat(data)\n    elif issubclass(scalar_type, np.inexact):\n        return isnan(data)\n    elif issubclass(scalar_type, (np.bool_, np.integer, np.character, np.void)):\n        return zeros_like(data, dtype=bool)\n    elif isinstance(data, (np.ndarray, dask_array_type)):\n        return pandas_isnull(data)\n    else:\n        return data != data",
    ".xarray.core.duck_array_ops.py@@where_method": "def where_method(data, cond, other=dtypes.NA):\n    if other is dtypes.NA:\n        other = dtypes.get_fill_value(data.dtype)\n    return where(cond, data, other)",
    ".xarray.core.duck_array_ops.py@@where": "def where(condition, x, y):\n    return _where(condition, *as_shared_dtype([x, y]))",
    ".xarray.core.duck_array_ops.py@@as_shared_dtype": "def as_shared_dtype(scalars_or_arrays):\n    if any([isinstance(x, cupy_array_type) for x in scalars_or_arrays]):\n        import cupy as cp\n        arrays = [asarray(x, xp=cp) for x in scalars_or_arrays]\n    else:\n        arrays = [asarray(x) for x in scalars_or_arrays]\n    out_type = dtypes.result_type(*arrays)\n    return [x.astype(out_type, copy=False) for x in arrays]",
    ".xarray.core.dtypes.py@@result_type": "def result_type(*arrays_and_dtypes):\n    types = {np.result_type(t).type for t in arrays_and_dtypes}\n    for left, right in PROMOTE_TO_OBJECT:\n        if any((issubclass(t, left) for t in types)) and any((issubclass(t, right) for t in types)):\n            return np.dtype(object)\n    return np.result_type(*arrays_and_dtypes)",
    ".xarray.core.duck_array_ops.py@@last": "def last(values, axis, skipna=None):\n    if (skipna or skipna is None) and values.dtype.kind not in 'iSU':\n        _fail_on_dask_array_input_skipna(values)\n        return nanlast(values, axis)\n    return take(values, -1, axis=axis)",
    ".xarray.core.nputils.py@@nanlast": "def nanlast(values, axis):\n    axis = normalize_axis_index(axis, values.ndim)\n    rev = (slice(None),) * axis + (slice(None, None, -1),)\n    idx_last = -1 - np.argmax(~pd.isnull(values)[rev], axis=axis)\n    return _select_along_axis(values, idx_last, axis)",
    ".xarray.core.nanops.py@@_maybe_null_out": "def _maybe_null_out(result, axis, mask, min_count=1):\n    if axis is not None and getattr(result, 'ndim', False):\n        null_mask = np.take(mask.shape, axis).prod() - mask.sum(axis) - min_count < 0\n        dtype, fill_value = dtypes.maybe_promote(result.dtype)\n        result = where(null_mask, fill_value, result.astype(dtype))\n    elif getattr(result, 'dtype', None) not in dtypes.NAT_TYPES:\n        null_mask = mask.size - mask.sum()\n        result = where(null_mask < min_count, np.nan, result)\n    return result",
    ".xarray.core.dtypes.py@@maybe_promote": "def maybe_promote(dtype):\n    if np.issubdtype(dtype, np.floating):\n        fill_value = np.nan\n    elif np.issubdtype(dtype, np.timedelta64):\n        fill_value = np.timedelta64('NaT')\n    elif np.issubdtype(dtype, np.integer):\n        if dtype.itemsize <= 2:\n            dtype = np.float32\n        else:\n            dtype = np.float64\n        fill_value = np.nan\n    elif np.issubdtype(dtype, np.complexfloating):\n        fill_value = np.nan + np.nan * 1j\n    elif np.issubdtype(dtype, np.datetime64):\n        fill_value = np.datetime64('NaT')\n    else:\n        dtype = object\n        fill_value = np.nan\n    return (np.dtype(dtype), fill_value)",
    ".xarray.core.nanops.py@@nanmax": "def nanmax(a, axis=None, out=None):\n    if a.dtype.kind == 'O':\n        return _nan_minmax_object('max', dtypes.get_neg_infinity(a.dtype), a, axis)\n    module = dask_array if isinstance(a, dask_array_type) else nputils\n    return module.nanmax(a, axis=axis)",
    ".xarray.core.nputils.py@@f": "def f(values, axis=None, **kwargs):\n    dtype = kwargs.get('dtype', None)\n    bn_func = getattr(bn, name, None)\n    if _USE_BOTTLENECK and isinstance(values, np.ndarray) and (bn_func is not None) and (not isinstance(axis, tuple)) and (values.dtype.kind in 'uifc') and values.dtype.isnative and (dtype is None or np.dtype(dtype) == values.dtype):\n        kwargs.pop('dtype', None)\n        result = bn_func(values, axis=axis, **kwargs)\n    else:\n        result = getattr(npmodule, name)(values, axis=axis, **kwargs)\n    return result",
    ".xarray.core.nanops.py@@nanmin": "def nanmin(a, axis=None, out=None):\n    if a.dtype.kind == 'O':\n        return _nan_minmax_object('min', dtypes.get_pos_infinity(a.dtype), a, axis)\n    module = dask_array if isinstance(a, dask_array_type) else nputils\n    return module.nanmin(a, axis=axis)",
    ".xarray.core.duck_array_ops.py@@cumsum": "def cumsum(array, axis=None, **kwargs):\n    return _nd_cum_func(cumsum_1d, array, axis, **kwargs)",
    ".xarray.core.duck_array_ops.py@@_nd_cum_func": "def _nd_cum_func(cum_func, array, axis, **kwargs):\n    array = asarray(array)\n    if axis is None:\n        axis = tuple(range(array.ndim))\n    if isinstance(axis, int):\n        axis = (axis,)\n    out = array\n    for ax in axis:\n        out = cum_func(out, axis=ax, **kwargs)\n    return out",
    ".xarray.core.nanops.py@@nancumsum": "def nancumsum(a, axis=None, dtype=None, out=None):\n    return _dask_or_eager_func('nancumsum', eager_module=nputils)(a, axis=axis, dtype=dtype)",
    ".xarray.core.duck_array_ops.py@@cumprod": "def cumprod(array, axis=None, **kwargs):\n    return _nd_cum_func(cumprod_1d, array, axis, **kwargs)",
    ".xarray.core.nanops.py@@nancumprod": "def nancumprod(a, axis=None, dtype=None, out=None):\n    return _dask_or_eager_func('nancumprod', eager_module=nputils)(a, axis=axis, dtype=dtype)",
    ".xarray.core.dtypes.py@@get_pos_infinity": "def get_pos_infinity(dtype, max_for_int=False):\n    if issubclass(dtype.type, np.floating):\n        return np.inf\n    if issubclass(dtype.type, np.integer):\n        if max_for_int:\n            return np.iinfo(dtype).max\n        else:\n            return np.inf\n    if issubclass(dtype.type, np.complexfloating):\n        return np.inf + 1j * np.inf\n    return INF",
    ".xarray.core.nanops.py@@_nan_minmax_object": "def _nan_minmax_object(func, fill_value, value, axis=None, **kwargs):\n    valid_count = count(value, axis=axis)\n    filled_value = fillna(value, fill_value)\n    data = getattr(np, func)(filled_value, axis=axis, **kwargs)\n    if not hasattr(data, 'dtype'):\n        data = fill_value if valid_count == 0 else data\n        return utils.to_0d_object_array(data)\n    return where_method(data, valid_count != 0)",
    ".xarray.core.duck_array_ops.py@@count": "def count(data, axis=None):\n    return np.sum(np.logical_not(isnull(data)), axis=axis)",
    ".xarray.core.duck_array_ops.py@@fillna": "def fillna(data, other):\n    return where(notnull(data), data, other)",
    ".xarray.core.duck_array_ops.py@@notnull": "def notnull(data):\n    return ~isnull(data)",
    ".xarray.core.utils.py@@to_0d_object_array": "def to_0d_object_array(value: Any) -> np.ndarray:\n    result = np.empty((), dtype=object)\n    result[()] = value\n    return result",
    ".xarray.core.variable.py@@_possibly_convert_objects": "def _possibly_convert_objects(values):\n    return np.asarray(pd.Series(values.ravel())).reshape(values.shape)",
    ".xarray.core.dtypes.py@@get_neg_infinity": "def get_neg_infinity(dtype, min_for_int=False):\n    if issubclass(dtype.type, np.floating):\n        return -np.inf\n    if issubclass(dtype.type, np.integer):\n        if min_for_int:\n            return np.iinfo(dtype).min\n        else:\n            return -np.inf\n    if issubclass(dtype.type, np.complexfloating):\n        return -np.inf - 1j * np.inf\n    return NINF",
    ".xarray.core.nanops.py@@nanargmin": "def nanargmin(a, axis=None):\n    if a.dtype.kind == 'O':\n        fill_value = dtypes.get_pos_infinity(a.dtype)\n        return _nan_argminmax_object('argmin', fill_value, a, axis=axis)\n    module = dask_array if isinstance(a, dask_array_type) else nputils\n    return module.nanargmin(a, axis=axis)",
    ".xarray.core.nanops.py@@_nan_argminmax_object": "def _nan_argminmax_object(func, fill_value, value, axis=None, **kwargs):\n    valid_count = count(value, axis=axis)\n    value = fillna(value, fill_value)\n    data = _dask_or_eager_func(func)(value, axis=axis, **kwargs)\n    if (valid_count == 0).any():\n        raise ValueError('All-NaN slice encountered')\n    return data",
    ".xarray.core.nanops.py@@nanargmax": "def nanargmax(a, axis=None):\n    if a.dtype.kind == 'O':\n        fill_value = dtypes.get_neg_infinity(a.dtype)\n        return _nan_argminmax_object('argmax', fill_value, a, axis=axis)\n    module = dask_array if isinstance(a, dask_array_type) else nputils\n    return module.nanargmax(a, axis=axis)",
    ".xarray.core.variable.py@@IndexVariable.to_index": "def to_index(self):\n    assert self.ndim == 1\n    index = self._data.array\n    if isinstance(index, pd.MultiIndex):\n        valid_level_names = [name or '{}_level_{}'.format(self.dims[0], i) for i, name in enumerate(index.names)]\n        index = index.set_names(valid_level_names)\n    else:\n        index = index.set_names(self.name)\n    return index",
    ".xarray.core.indexing.py@@PandasIndexAdapter.shape": "def shape(self) -> Tuple[int]:\n    return (len(self.array),)",
    ".xarray.core.variable.py@@IndexVariable.name": "def name(self):\n    return self.dims[0]"
}