{
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.assumptions.py@@_ask": "def _ask(fact, obj):\n    assumptions = obj._assumptions\n    handler_map = obj._prop_handler\n    assumptions._tell(fact, None)\n    try:\n        evaluate = handler_map[fact]\n    except KeyError:\n        pass\n    else:\n        a = evaluate(obj)\n        if a is not None:\n            assumptions.deduce_all_facts(((fact, a),))\n            return a\n    prereq = list(_assume_rules.prereq[fact])\n    shuffle(prereq)\n    for pk in prereq:\n        if pk in assumptions:\n            continue\n        if pk in handler_map:\n            _ask(pk, obj)\n            ret_val = assumptions.get(fact)\n            if ret_val is not None:\n                return ret_val\n    return None",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, integer_types):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.assumptions.py@@StdFactKB.copy": "def copy(self):\n    return self.__class__(self)",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    super(StdFactKB, self).__init__(_assume_rules)\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.__init__": "def __init__(self, rules):\n    self.rules = rules",
    ".sympy.core.assumptions.py@@StdFactKB.generator": "def generator(self):\n    return self._generator.copy()",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.numbers.py@@Rational._eval_is_zero": "def _eval_is_zero(self):\n    return self.p == 0",
    ".sympy.core.numbers.py@@Integer._eval_is_odd": "def _eval_is_odd(self):\n    return bool(self.p % 2)",
    ".sympy.core.expr.py@@Expr.__abs__": "def __abs__(self):\n    from sympy import Abs\n    return Abs(self)",
    ".sympy.core.function.py@@Function.__new__": "def __new__(cls, *args, **options):\n    if cls is Function:\n        return UndefinedFunction(*args, **options)\n    n = len(args)\n    if n not in cls.nargs:\n        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'\n        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})\n    evaluate = options.get('evaluate', global_evaluate[0])\n    result = super(Function, cls).__new__(cls, *args, **options)\n    if evaluate and isinstance(result, cls) and result.args:\n        pr2 = min((cls._should_evalf(a) for a in result.args))\n        if pr2 > 0:\n            pr = max((cls._should_evalf(a) for a in result.args))\n            result = result.evalf(mlib.libmpf.prec_to_dps(pr))\n    return result",
    ".sympy.core.function.py@@FunctionClass.nargs": "def nargs(self):\n    from sympy.sets.sets import FiniteSet\n    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0",
    ".sympy.sets.sets.py@@FiniteSet.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_evaluate[0])\n    if evaluate:\n        args = list(map(sympify, args))\n        if len(args) == 0:\n            return S.EmptySet\n    else:\n        args = list(map(sympify, args))\n    _args_set = set(args)\n    args = list(ordered(_args_set, Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._args_set = _args_set\n    return obj",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is not None:\n        return a\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    cls = getattr(a, '__class__', None)\n    if cls is None:\n        cls = type(a)\n    conv = converter.get(cls, None)\n    if conv is not None:\n        return conv(a)\n    for superclass in getmro(cls):\n        try:\n            return converter[superclass](a)\n        except KeyError:\n            continue\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if evaluate is None:\n        if global_evaluate[0] is False:\n            evaluate = global_evaluate[0]\n        else:\n            evaluate = True\n    if type(a).__module__ == 'numpy':\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from ..tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                coerced = coerce(a)\n            except (TypeError, ValueError):\n                continue\n            except AttributeError:\n                continue\n            try:\n                return sympify(coerced)\n            except SympifyError:\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, string_types):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    if ival == 1:\n        return S.One\n    if ival == -1:\n        return S.NegativeOne\n    if ival == 0:\n        return S.Zero\n    obj = Expr.__new__(cls)\n    obj.p = ival\n    return obj",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.compatibility.py@@ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    d = defaultdict(list)\n    if keys:\n        if not isinstance(keys, (list, tuple)):\n            keys = [keys]\n        keys = list(keys)\n        f = keys.pop(0)\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n    for k in sorted(d.keys()):\n        if len(d[k]) > 1:\n            if keys:\n                d[k] = ordered(d[k], keys, default, warn)\n            elif default:\n                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)\n            elif warn:\n                from sympy.utilities.iterables import uniq\n                u = list(uniq(d[k]))\n                if len(u) > 1:\n                    raise ValueError('not enough keys to break ties: %s' % u)\n        for v in d[k]:\n            yield v\n        d.pop(k)",
    ".sympy.sets.sets.py@@Set._infimum_key": "def _infimum_key(expr):\n    try:\n        infimum = expr.inf\n        assert infimum.is_comparable\n    except (NotImplementedError, AttributeError, AssertionError, ValueError):\n        infimum = S.Infinity\n    return infimum",
    ".sympy.core.numbers.py@@Infinity.__hash__": "def __hash__(self):\n    return super(Infinity, self).__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super(Number, self).__hash__()",
    ".sympy.core.expr.py@@Expr.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.sets.sets.py@@Set.__contains__": "def __contains__(self, other):\n    other = _sympify(other)\n    c = self._contains(other)\n    b = tfn[c]\n    if b is None:\n        raise TypeError('did not evaluate to a bool: %r' % c)\n    return b",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.sets.sets.py@@FiniteSet._contains": "def _contains(self, other):\n    if other in self._args_set:\n        return True\n    else:\n        return fuzzy_or((fuzzy_bool(Eq(e, other, evaluate=True)) for e in self.args))",
    ".sympy.logic.boolalg.py@@BooleanTrue.__nonzero__": "def __nonzero__(self):\n    return True",
    ".sympy.core.function.py@@Application.__new__": "def __new__(cls, *args, **options):\n    from sympy.sets.fancysets import Naturals0\n    from sympy.sets.sets import FiniteSet\n    args = list(map(sympify, args))\n    evaluate = options.pop('evaluate', global_evaluate[0])\n    options.pop('nargs', None)\n    if options:\n        raise ValueError('Unknown options: %s' % options)\n    if evaluate:\n        evaluated = cls.eval(*args)\n        if evaluated is not None:\n            return evaluated\n    obj = super(Application, cls).__new__(cls, *args, **options)\n    sentinel = object()\n    objnargs = getattr(obj, 'nargs', sentinel)\n    if objnargs is not sentinel:\n        if is_sequence(objnargs):\n            nargs = tuple(ordered(set(objnargs)))\n        elif objnargs is not None:\n            nargs = (as_int(objnargs),)\n        else:\n            nargs = None\n    else:\n        nargs = obj._nargs\n    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()\n    return obj",
    ".sympy.functions.elementary.complexes.py@@Abs.eval": "def eval(cls, arg):\n    from sympy.simplify.simplify import signsimp\n    from sympy.core.function import expand_mul\n    from sympy.core.power import Pow\n    if hasattr(arg, '_eval_Abs'):\n        obj = arg._eval_Abs()\n        if obj is not None:\n            return obj\n    if not isinstance(arg, Expr):\n        raise TypeError('Bad argument type for Abs(): %s' % type(arg))\n    arg = signsimp(arg, evaluate=False)\n    n, d = arg.as_numer_denom()\n    if d.free_symbols and (not n.free_symbols):\n        return cls(n) / cls(d)\n    if arg.is_Mul:\n        known = []\n        unk = []\n        for t in arg.args:\n            if t.is_Pow and t.exp.is_integer and t.exp.is_negative:\n                bnew = cls(t.base)\n                if isinstance(bnew, cls):\n                    unk.append(t)\n                else:\n                    known.append(Pow(bnew, t.exp))\n            else:\n                tnew = cls(t)\n                if isinstance(tnew, cls):\n                    unk.append(t)\n                else:\n                    known.append(tnew)\n        known = Mul(*known)\n        unk = cls(Mul(*unk), evaluate=False) if unk else S.One\n        return known * unk\n    if arg is S.NaN:\n        return S.NaN\n    if arg is S.ComplexInfinity:\n        return S.Infinity\n    if arg.is_Pow:\n        base, exponent = arg.as_base_exp()\n        if base.is_extended_real:\n            if exponent.is_integer:\n                if exponent.is_even:\n                    return arg\n                if base is S.NegativeOne:\n                    return S.One\n                return Abs(base) ** exponent\n            if base.is_extended_nonnegative:\n                return base ** re(exponent)\n            if base.is_extended_negative:\n                return (-base) ** re(exponent) * exp(-S.Pi * im(exponent))\n            return\n        elif not base.has(Symbol):\n            a, b = log(base).as_real_imag()\n            z = a + I * b\n            return exp(re(exponent * z))\n    if isinstance(arg, exp):\n        return exp(re(arg.args[0]))\n    if isinstance(arg, AppliedUndef):\n        return\n    if arg.is_Add and arg.has(S.Infinity, S.NegativeInfinity):\n        if any((a.is_infinite for a in arg.as_real_imag())):\n            return S.Infinity\n    if arg.is_zero:\n        return S.Zero\n    if arg.is_extended_nonnegative:\n        return arg\n    if arg.is_extended_nonpositive:\n        return -arg\n    if arg.is_imaginary:\n        arg2 = -S.ImaginaryUnit * arg\n        if arg2.is_extended_nonnegative:\n            return arg2\n    conj = signsimp(arg.conjugate(), evaluate=False)\n    new_conj = conj.atoms(conjugate) - arg.atoms(conjugate)\n    if new_conj and all((arg.has(i.args[0]) for i in new_conj)):\n        return\n    if arg != conj and arg != -conj:\n        ignore = arg.atoms(Abs)\n        abs_free_arg = arg.xreplace({i: Dummy(real=True) for i in ignore})\n        unk = [a for a in abs_free_arg.free_symbols if a.is_extended_real is None]\n        if not unk or not all((conj.has(conjugate(u)) for u in unk)):\n            return sqrt(expand_mul(arg * conj))",
    ".sympy.simplify.simplify.py@@signsimp": "def signsimp(expr, evaluate=None):\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    expr = sympify(expr)\n    if not isinstance(expr, Expr) or expr.is_Atom:\n        return expr\n    e = sub_post(sub_pre(expr))\n    if not isinstance(e, Expr) or e.is_Atom:\n        return e\n    if e.is_Add:\n        return e.func(*[signsimp(a, evaluate) for a in e.args])\n    if evaluate:\n        e = e.xreplace({m: --m for m in e.atoms(Mul) if --m != m})\n    return e",
    ".sympy.core.expr.py@@Expr.as_numer_denom": "def as_numer_denom(self):\n    return (self, S.One)",
    ".sympy.core.basic.py@@Basic.free_symbols": "def free_symbols(self):\n    return set().union(*[a.free_symbols for a in self.args])",
    ".sympy.core.expr.py@@Expr._eval_is_negative": "def _eval_is_negative(self):\n    finite = self.is_finite\n    if finite is False:\n        return False\n    extended_negative = self.is_extended_negative\n    if finite is True:\n        return extended_negative\n    if extended_negative is False:\n        return False",
    ".sympy.core.expr.py@@Expr._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    return self._eval_is_extended_positive_negative(positive=False)",
    ".sympy.core.expr.py@@Expr._eval_is_extended_positive_negative": "def _eval_is_extended_positive_negative(self, positive):\n    from sympy.polys.numberfields import minimal_polynomial\n    from sympy.polys.polyerrors import NotAlgebraic\n    if self.is_number:\n        if self.is_extended_real is False:\n            return False\n        try:\n            n2 = self._eval_evalf(2)\n        except ValueError:\n            return None\n        if n2 is None:\n            return None\n        if getattr(n2, '_prec', 1) == 1:\n            return None\n        if n2 is S.NaN:\n            return None\n        r, i = self.evalf(2).as_real_imag()\n        if not i.is_Number or not r.is_Number:\n            return False\n        if r._prec != 1 and i._prec != 1:\n            return bool(not i and (r > 0 if positive else r < 0))\n        elif r._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):\n            try:\n                if minimal_polynomial(self).is_Symbol:\n                    return False\n            except (NotAlgebraic, NotImplementedError):\n                pass",
    ".sympy.core.expr.py@@Expr._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    return self._eval_is_extended_positive_negative(positive=True)",
    ".sympy.core.expr.py@@Expr._eval_is_positive": "def _eval_is_positive(self):\n    finite = self.is_finite\n    if finite is False:\n        return False\n    extended_positive = self.is_extended_positive\n    if finite is True:\n        return extended_positive\n    if extended_positive is False:\n        return False",
    ".sympy.core.expr.py@@Expr.conjugate": "def conjugate(self):\n    from sympy.functions.elementary.complexes import conjugate as c\n    return c(self)",
    ".sympy.functions.elementary.complexes.py@@conjugate.eval": "def eval(cls, arg):\n    obj = arg._eval_conjugate()\n    if obj is not None:\n        return obj",
    ".sympy.core.expr.py@@Expr._eval_conjugate": "def _eval_conjugate(self):\n    if self.is_extended_real:\n        return self\n    elif self.is_imaginary:\n        return -self",
    ".sympy.core.basic.py@@Basic.atoms": "def atoms(self, *types):\n    if types:\n        types = tuple([t if isinstance(t, type) else type(t) for t in types])\n    else:\n        types = (Atom,)\n    result = set()\n    for expr in preorder_traversal(self):\n        if isinstance(expr, types):\n            result.add(expr)\n    return result",
    ".sympy.core.basic.py@@preorder_traversal.__init__": "def __init__(self, node, keys=None):\n    self._skip_flag = False\n    self._pt = self._preorder_traversal(node, keys)",
    ".sympy.core.basic.py@@preorder_traversal.__iter__": "def __iter__(self):\n    return self",
    ".sympy.core.basic.py@@preorder_traversal.__next__": "def __next__(self):\n    return next(self._pt)",
    ".sympy.core.basic.py@@preorder_traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            for subtree in self._preorder_traversal(arg, keys):\n                yield subtree\n    elif iterable(node):\n        for item in node:\n            for subtree in self._preorder_traversal(item, keys):\n                yield subtree",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.expr.py@@Expr.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n        if not isinstance(other, Expr):\n            return False\n    except (SympifyError, SyntaxError):\n        return False\n    if not (self.is_Number and other.is_Number) and type(self) != type(other):\n        return False\n    a, b = (self._hashable_content(), other._hashable_content())\n    if a != b:\n        return False\n    for a, b in zip(a, b):\n        if not isinstance(a, Expr):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return dict(((key, value) for key, value in self._assumptions.items() if value is not None))",
    ".sympy.core.function.py@@Function._should_evalf": "def _should_evalf(cls, arg):\n    from sympy.core.evalf import pure_complex\n    if arg.is_Float:\n        return arg._prec\n    if not arg.is_Add:\n        return -1\n    m = pure_complex(arg)\n    if m is None or not (m[0].is_Float or m[1].is_Float):\n        return -1\n    l = [i._prec for i in m if i.is_Float]\n    l.append(-1)\n    return max(l)",
    ".sympy.core.numbers.py@@Integer.__abs__": "def __abs__(self):\n    if self.p >= 0:\n        return self\n    else:\n        return Integer(-self.p)",
    ".sympy.core.numbers.py@@Integer.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    tself = type(self)\n    tother = type(other)\n    if tself is not tother:\n        try:\n            other = _sympify(other)\n            tother = type(other)\n        except SympifyError:\n            return NotImplemented\n        if PY3 or type(tself).__ne__ is not type.__ne__:\n            if tself != tother:\n                return False\n        elif tself is not tother:\n            return False\n    return self._hashable_content() == other._hashable_content()",
    ".sympy.core.numbers.py@@Float.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if not self:\n        return not other\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Float:\n        return self._mpf_ == other._mpf_\n    if other.is_Rational:\n        return other.__eq__(self)\n    if other.is_Number:\n        ompf = other._as_mpf_val(self._prec)\n        return bool(mlib.mpf_eq(self._mpf_, ompf))\n    return False",
    ".sympy.core.numbers.py@@Float.__nonzero__": "def __nonzero__(self):\n    return self._mpf_ != fzero",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    from sympy.core.power import integer_log\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if not isinstance(other, Number):\n        return False\n    if not self:\n        return not other\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Rational:\n        return self.p == other.p and self.q == other.q\n    if other.is_Float:\n        if self.q & self.q - 1:\n            return False\n        s, m, t = other._mpf_[:3]\n        if s:\n            m = -m\n        if not t:\n            if not self.is_Integer or self.is_even:\n                return False\n            return m == self.p\n        if t > 0:\n            if not self.is_Integer:\n                return False\n            return self.p and (not self.p % m) and (integer_log(self.p // m, 2) == (t, True))\n        if self.is_Integer:\n            return False\n        return m == self.p and integer_log(self.q, 2) == (-t, True)\n    return False",
    ".sympy.core.numbers.py@@Float.__abs__": "def __abs__(self):\n    return Float._new(mlib.mpf_abs(self._mpf_), self._prec)",
    ".sympy.core.numbers.py@@Float._new": "def _new(cls, _mpf_, _prec, zero=True):\n    if zero and _mpf_ == fzero:\n        return S.Zero\n    elif _mpf_ == _mpf_nan:\n        return S.NaN\n    elif _mpf_ == _mpf_inf:\n        return S.Infinity\n    elif _mpf_ == _mpf_ninf:\n        return S.NegativeInfinity\n    obj = Expr.__new__(cls)\n    obj._mpf_ = mpf_norm(_mpf_, _prec)\n    obj._prec = _prec\n    return obj",
    ".sympy.core.numbers.py@@mpf_norm": "def mpf_norm(mpf, prec):\n    sign, man, expt, bc = mpf\n    if not man:\n        if not bc:\n            return fzero\n        else:\n            return mpf\n    from mpmath.libmp.backend import MPZ\n    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n    return rv",
    ".sympy.core.numbers.py@@Float.__lt__": "def __lt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__gt__(self)\n    rv = self._Frel(other, mlib.mpf_lt)\n    if rv is None:\n        return Expr.__lt__(self, other)\n    return rv",
    ".sympy.core.numbers.py@@Float._Frel": "def _Frel(self, other, op):\n    from sympy.core.evalf import evalf\n    from sympy.core.numbers import prec_to_dps\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Rational:\n        '\\n        >>> f = Float(.1,2)\\n        >>> i = 1234567890\\n        >>> (f*i)._mpf_\\n        (0, 471, 18, 9)\\n        >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))\\n        (0, 505555550955, -12, 39)\\n        '\n        smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))\n        ompf = mlib.from_int(other.p)\n        return _sympify(bool(op(smpf, ompf)))\n    elif other.is_Float:\n        return _sympify(bool(op(self._mpf_, other._mpf_)))\n    elif other.is_comparable and other not in (S.Infinity, S.NegativeInfinity):\n        other = other.evalf(prec_to_dps(self._prec))\n        if other._prec > 1:\n            if other.is_Number:\n                return _sympify(bool(op(self._mpf_, other._as_mpf_val(self._prec))))",
    ".sympy.core.basic.py@@Basic._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.numbers.py@@Float._eval_is_integer": "def _eval_is_integer(self):\n    return self._mpf_ == fzero",
    ".sympy.core.numbers.py@@Rational.__abs__": "def __abs__(self):\n    return Rational(abs(self.p), self.q)",
    ".sympy.core.numbers.py@@Rational.__new__": "def __new__(cls, p, q=None, gcd=None):\n    if q is None:\n        if isinstance(p, Rational):\n            return p\n        if isinstance(p, SYMPY_INTS):\n            pass\n        else:\n            if isinstance(p, (float, Float)):\n                return Rational(*_as_integer_ratio(p))\n            if not isinstance(p, string_types):\n                try:\n                    p = sympify(p)\n                except (SympifyError, SyntaxError):\n                    pass\n            else:\n                if p.count('/') > 1:\n                    raise TypeError('invalid input: %s' % p)\n                p = p.replace(' ', '')\n                pq = p.rsplit('/', 1)\n                if len(pq) == 2:\n                    p, q = pq\n                    fp = fractions.Fraction(p)\n                    fq = fractions.Fraction(q)\n                    p = fp / fq\n                try:\n                    p = fractions.Fraction(p)\n                except ValueError:\n                    pass\n                else:\n                    return Rational(p.numerator, p.denominator, 1)\n            if not isinstance(p, Rational):\n                raise TypeError('invalid input: %s' % p)\n        q = 1\n        gcd = 1\n    else:\n        p = Rational(p)\n        q = Rational(q)\n    if isinstance(q, Rational):\n        p *= q.q\n        q = q.p\n    if isinstance(p, Rational):\n        q *= p.q\n        p = p.p\n    if q == 0:\n        if p == 0:\n            if _errdict['divide']:\n                raise ValueError('Indeterminate 0/0')\n            else:\n                return S.NaN\n        return S.ComplexInfinity\n    if q < 0:\n        q = -q\n        p = -p\n    if not gcd:\n        gcd = igcd(abs(p), q)\n    if gcd > 1:\n        p //= gcd\n        q //= gcd\n    if q == 1:\n        return Integer(p)\n    if p == 1 and q == 2:\n        return S.Half\n    obj = Expr.__new__(cls)\n    obj.p = p\n    obj.q = q\n    return obj",
    ".sympy.core.numbers.py@@Integer.__mul__": "def __mul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p * other)\n        elif isinstance(other, Integer):\n            return Integer(self.p * other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    ".sympy.core.numbers.py@@Rational.__lt__": "def __lt__(self, other):\n    rv = self._Rrel(other, '__gt__')\n    if rv is None:\n        rv = (self, other)\n    elif not type(rv) is tuple:\n        return rv\n    return Expr.__lt__(*rv)",
    ".sympy.core.numbers.py@@Rational._Rrel": "def _Rrel(self, other, attr):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Number:\n        op = None\n        s, o = (self, other)\n        if other.is_NumberSymbol:\n            op = getattr(o, attr)\n        elif other.is_Float:\n            op = getattr(o, attr)\n        elif other.is_Rational:\n            s, o = (Integer(s.p * o.q), Integer(s.q * o.p))\n            op = getattr(o, attr)\n        if op:\n            return op(s)\n        if o.is_number and o.is_extended_real:\n            return (Integer(s.p), s.q * o)",
    ".sympy.core.numbers.py@@Integer.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    ".sympy.core.mul.py@@Mul._eval_is_integer": "def _eval_is_integer(self):\n    is_rational = self.is_rational\n    if is_rational:\n        n, d = self.as_numer_denom()\n        if d is S.One:\n            return True\n        elif d == S(2):\n            return n.is_even\n    elif is_rational is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_rational": "def _eval_is_rational(self):\n    r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        return self.is_zero",
    ".sympy.core.logic.py@@_fuzzy_group": "def _fuzzy_group(args, quick_exit=False):\n    saw_other = False\n    for a in args:\n        if a is True:\n            continue\n        if a is None:\n            return\n        if quick_exit and saw_other:\n            return\n        saw_other = True\n    return not saw_other",
    ".sympy.core.mul.py@@Mul._eval_is_odd": "def _eval_is_odd(self):\n    is_integer = self.is_integer\n    if is_integer:\n        r, acc = (True, 1)\n        for t in self.args:\n            if not t.is_integer:\n                return None\n            elif t.is_even:\n                r = False\n            elif t.is_integer:\n                if r is False:\n                    pass\n                elif acc != 1 and (acc + t).is_odd:\n                    r = False\n                elif t.is_odd is None:\n                    r = None\n            acc = t\n        return r\n    elif is_integer is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all(((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others)):\n                return True\n            return\n        if a is None:\n            return\n    return False",
    ".sympy.core.mul.py@@Mul._eval_is_hermitian": "def _eval_is_hermitian(self):\n    return self._eval_herm_antiherm(True)",
    ".sympy.core.mul.py@@Mul._eval_herm_antiherm": "def _eval_herm_antiherm(self, real):\n    one_nc = zero = one_neither = False\n    for t in self.args:\n        if not t.is_commutative:\n            if one_nc:\n                return\n            one_nc = True\n        if t.is_antihermitian:\n            real = not real\n        elif t.is_hermitian:\n            if not zero:\n                z = t.is_zero\n                if not z and zero is False:\n                    zero = z\n                elif z:\n                    if all((a.is_finite for a in self.args)):\n                        return True\n                    return\n        elif t.is_hermitian is False:\n            if one_neither:\n                return\n            one_neither = True\n        else:\n            return\n    if one_neither:\n        if real:\n            return zero\n    elif zero is False or real:\n        return real",
    ".sympy.core.mul.py@@Mul._eval_is_finite": "def _eval_is_finite(self):\n    if all((a.is_finite for a in self.args)):\n        return True\n    if any((a.is_infinite for a in self.args)):\n        if all((a.is_zero is False for a in self.args)):\n            return False",
    ".sympy.core.mul.py@@Mul._eval_is_zero": "def _eval_is_zero(self):\n    zero = infinite = False\n    for a in self.args:\n        z = a.is_zero\n        if z:\n            if infinite:\n                return\n            zero = True\n        else:\n            if not a.is_finite:\n                if zero:\n                    return\n                infinite = True\n            if zero is False and z is None:\n                zero = None\n    return zero",
    ".sympy.core.mul.py@@Mul._eval_is_imaginary": "def _eval_is_imaginary(self):\n    z = self.is_zero\n    if z:\n        return False\n    elif z is False:\n        return self._eval_real_imag(False)",
    ".sympy.core.mul.py@@Mul._eval_is_composite": "def _eval_is_composite(self):\n    number_of_args = 0\n    for arg in self.args:\n        if not (arg.is_integer and arg.is_positive):\n            return None\n        if (arg - 1).is_positive:\n            number_of_args += 1\n    if number_of_args > 1:\n        return True",
    ".sympy.core.numbers.py@@Integer.__sub__": "def __sub__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    ".sympy.core.mul.py@@Mul._eval_is_infinite": "def _eval_is_infinite(self):\n    if any((a.is_infinite for a in self.args)):\n        if any((a.is_zero for a in self.args)):\n            return S.NaN.is_infinite\n        if any((a.is_zero is None for a in self.args)):\n            return None\n        return True",
    ".sympy.core.mul.py@@Mul._eval_is_complex": "def _eval_is_complex(self):\n    comp = _fuzzy_group((a.is_complex for a in self.args))\n    if comp is False:\n        if any((a.is_infinite for a in self.args)):\n            if any((a.is_zero is not False for a in self.args)):\n                return None\n            return False\n    return comp",
    ".sympy.core.mul.py@@Mul._eval_is_even": "def _eval_is_even(self):\n    is_integer = self.is_integer\n    if is_integer:\n        return fuzzy_not(self.is_odd)\n    elif is_integer is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_algebraic": "def _eval_is_algebraic(self):\n    r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        return self.is_zero",
    ".sympy.core.mul.py@@Mul._eval_is_extended_real": "def _eval_is_extended_real(self):\n    return self._eval_real_imag(True)",
    ".sympy.core.mul.py@@Mul._eval_real_imag": "def _eval_real_imag(self, real):\n    zero = False\n    t_not_re_im = None\n    for t in self.args:\n        if (t.is_complex or t.is_infinite) is False and t.is_extended_real is False:\n            return False\n        elif t.is_imaginary:\n            real = not real\n        elif t.is_extended_real:\n            if not zero:\n                z = t.is_zero\n                if not z and zero is False:\n                    zero = z\n                elif z:\n                    if all((a.is_finite for a in self.args)):\n                        return True\n                    return\n        elif t.is_extended_real is False:\n            if t_not_re_im:\n                return\n            t_not_re_im = t\n        elif t.is_imaginary is False:\n            if t_not_re_im:\n                return\n            t_not_re_im = t\n        else:\n            return\n    if t_not_re_im:\n        if t_not_re_im.is_extended_real is False:\n            if real:\n                return zero\n        if t_not_re_im.is_imaginary is False:\n            if not real:\n                return zero\n    elif zero is False:\n        return real\n    elif real:\n        return real",
    ".sympy.core.mul.py@@Mul._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    return self._eval_pos_neg(1)",
    ".sympy.core.mul.py@@Mul._eval_pos_neg": "def _eval_pos_neg(self, sign):\n    saw_NON = saw_NOT = False\n    for t in self.args:\n        if t.is_extended_positive:\n            continue\n        elif t.is_extended_negative:\n            sign = -sign\n        elif t.is_zero:\n            if all((a.is_finite for a in self.args)):\n                return False\n            return\n        elif t.is_extended_nonpositive:\n            sign = -sign\n            saw_NON = True\n        elif t.is_extended_nonnegative:\n            saw_NON = True\n        elif t.is_positive is False:\n            sign = -sign\n            if saw_NOT:\n                return\n            saw_NOT = True\n        elif t.is_negative is False:\n            if saw_NOT:\n                return\n            saw_NOT = True\n        else:\n            return\n    if sign == 1 and saw_NON is False and (saw_NOT is False):\n        return True\n    if sign < 0:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    return self._eval_pos_neg(-1)",
    ".sympy.core.mul.py@@Mul._eval_is_antihermitian": "def _eval_is_antihermitian(self):\n    z = self.is_zero\n    if z:\n        return False\n    elif z is False:\n        return self._eval_herm_antiherm(False)",
    ".sympy.core.mul.py@@Mul.as_numer_denom": "def as_numer_denom(self):\n    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n    return (self.func(*numers), self.func(*denoms))",
    ".sympy.core.numbers.py@@Integer.as_numer_denom": "def as_numer_denom(self):\n    return (self, S.One)",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, **options):\n    from sympy import Order\n    args = list(map(_sympify, args))\n    args = [a for a in args if a is not cls.identity]\n    evaluate = options.get('evaluate')\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    if not evaluate:\n        obj = cls._from_args(args)\n        obj = cls._exec_constructor_postprocessors(obj)\n        return obj\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if order_symbols is not None:\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.core.mul.py@@Mul.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n            seq = [a, b]\n        assert not a is S.One\n        if not a.is_zero and a.is_Rational:\n            r, b = b.as_coeff_Mul()\n            if b.is_Add:\n                if r is not S.One:\n                    rv = ([cls(a * r, b, evaluate=False)], [], None)\n                elif global_distribute[0] and b.is_commutative:\n                    r, b = b.as_coeff_Add()\n                    bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n                    _addsort(bargs)\n                    ar = a * r\n                    if ar:\n                        bargs.insert(0, ar)\n                    bargs = [Add._from_args(bargs)]\n                    rv = (bargs, [], None)\n        if rv:\n            return rv\n    c_part = []\n    nc_part = []\n    nc_seq = []\n    coeff = S.One\n    c_powers = []\n    num_exp = []\n    neg1e = S.Zero\n    pnum_rat = {}\n    order_symbols = None\n    for o in seq:\n        if o.is_Order:\n            o, order_symbols = o.as_expr_variables(order_symbols)\n        if o.is_Mul:\n            if o.is_commutative:\n                seq.extend(o.args)\n            else:\n                for q in o.args:\n                    if q.is_commutative:\n                        seq.append(q)\n                    else:\n                        nc_seq.append(q)\n                seq.append(NC_Marker)\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_zero):\n                return ([S.NaN], [], None)\n            elif coeff.is_Number or isinstance(coeff, AccumBounds):\n                coeff *= o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__mul__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if not coeff:\n                return ([S.NaN], [], None)\n            if coeff is S.ComplexInfinity:\n                return ([S.ComplexInfinity], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o is S.ImaginaryUnit:\n            neg1e += S.Half\n            continue\n        elif o.is_commutative:\n            b, e = o.as_base_exp()\n            if o.is_Pow:\n                if b.is_Number:\n                    if e.is_Rational:\n                        if e.is_Integer:\n                            coeff *= Pow(b, e)\n                            continue\n                        elif e.is_negative:\n                            seq.append(Pow(b, e))\n                            continue\n                        elif b.is_negative:\n                            neg1e += e\n                            b = -b\n                        if b is not S.One:\n                            pnum_rat.setdefault(b, []).append(e)\n                        continue\n                    elif b.is_positive or e.is_integer:\n                        num_exp.append((b, e))\n                        continue\n            c_powers.append((b, e))\n        else:\n            if o is not NC_Marker:\n                nc_seq.append(o)\n            while nc_seq:\n                o = nc_seq.pop(0)\n                if not nc_part:\n                    nc_part.append(o)\n                    continue\n                o1 = nc_part.pop()\n                b1, e1 = o1.as_base_exp()\n                b2, e2 = o.as_base_exp()\n                new_exp = e1 + e2\n                if b1 == b2 and (not new_exp.is_Add):\n                    o12 = b1 ** new_exp\n                    if o12.is_commutative:\n                        seq.append(o12)\n                        continue\n                    else:\n                        nc_seq.insert(0, o12)\n                else:\n                    nc_part.append(o1)\n                    nc_part.append(o)\n\n    def _gather(c_powers):\n        common_b = {}\n        for b, e in c_powers:\n            co = e.as_coeff_Mul()\n            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n        for b, d in common_b.items():\n            for di, li in d.items():\n                d[di] = Add(*li)\n        new_c_powers = []\n        for b, e in common_b.items():\n            new_c_powers.extend([(b, c * t) for t, c in e.items()])\n        return new_c_powers\n    c_powers = _gather(c_powers)\n    num_exp = _gather(num_exp)\n    for i in range(2):\n        new_c_powers = []\n        changed = False\n        for b, e in c_powers:\n            if e.is_zero:\n                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):\n                    return ([S.NaN], [], None)\n                continue\n            if e is S.One:\n                if b.is_Number:\n                    coeff *= b\n                    continue\n                p = b\n            if e is not S.One:\n                p = Pow(b, e)\n                if p.is_Pow and (not b.is_Pow):\n                    bi = b\n                    b, e = p.as_base_exp()\n                    if b != bi:\n                        changed = True\n            c_part.append(p)\n            new_c_powers.append((b, e))\n        if changed and len(set((b for b, e in new_c_powers))) != len(new_c_powers):\n            c_part = []\n            c_powers = _gather(new_c_powers)\n        else:\n            break\n    inv_exp_dict = {}\n    for b, e in num_exp:\n        inv_exp_dict.setdefault(e, []).append(b)\n    for e, b in inv_exp_dict.items():\n        inv_exp_dict[e] = cls(*b)\n    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n    comb_e = {}\n    for b, e in pnum_rat.items():\n        comb_e.setdefault(Add(*e), []).append(b)\n    del pnum_rat\n    num_rat = []\n    for e, b in comb_e.items():\n        b = cls(*b)\n        if e.q == 1:\n            coeff *= Pow(b, e)\n            continue\n        if e.p > e.q:\n            e_i, ep = divmod(e.p, e.q)\n            coeff *= Pow(b, e_i)\n            e = Rational(ep, e.q)\n        num_rat.append((b, e))\n    del comb_e\n    pnew = defaultdict(list)\n    i = 0\n    while i < len(num_rat):\n        bi, ei = num_rat[i]\n        grow = []\n        for j in range(i + 1, len(num_rat)):\n            bj, ej = num_rat[j]\n            g = bi.gcd(bj)\n            if g is not S.One:\n                e = ei + ej\n                if e.q == 1:\n                    coeff *= Pow(g, e)\n                else:\n                    if e.p > e.q:\n                        e_i, ep = divmod(e.p, e.q)\n                        coeff *= Pow(g, e_i)\n                        e = Rational(ep, e.q)\n                    grow.append((g, e))\n                num_rat[j] = (bj / g, ej)\n                bi = bi / g\n                if bi is S.One:\n                    break\n        if bi is not S.One:\n            obj = Pow(bi, ei)\n            if obj.is_Number:\n                coeff *= obj\n            else:\n                for obj in Mul.make_args(obj):\n                    if obj.is_Number:\n                        coeff *= obj\n                    else:\n                        assert obj.is_Pow\n                        bi, ei = obj.args\n                        pnew[ei].append(bi)\n        num_rat.extend(grow)\n        i += 1\n    for e, b in pnew.items():\n        pnew[e] = cls(*b)\n    if neg1e:\n        p, q = neg1e.as_numer_denom()\n        n, p = divmod(p, q)\n        if n % 2:\n            coeff = -coeff\n        if q == 2:\n            c_part.append(S.ImaginaryUnit)\n        elif p:\n            neg1e = Rational(p, q)\n            for e, b in pnew.items():\n                if e == neg1e and b.is_positive:\n                    pnew[e] = -b\n                    break\n            else:\n                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n    c_part.extend([Pow(b, e) for e, b in pnew.items()])\n    if coeff is S.Infinity or coeff is S.NegativeInfinity:\n\n        def _handle_for_oo(c_part, coeff_sign):\n            new_c_part = []\n            for t in c_part:\n                if t.is_extended_positive:\n                    continue\n                if t.is_extended_negative:\n                    coeff_sign *= -1\n                    continue\n                new_c_part.append(t)\n            return (new_c_part, coeff_sign)\n        c_part, coeff_sign = _handle_for_oo(c_part, 1)\n        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n        coeff *= coeff_sign\n    if coeff is S.ComplexInfinity:\n        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]\n        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]\n    elif coeff.is_zero:\n        if any((isinstance(c, MatrixExpr) for c in nc_part)):\n            return ([coeff], nc_part, order_symbols)\n        if any((c.is_finite == False for c in c_part)):\n            return ([S.NaN], [], order_symbols)\n        return ([coeff], [], order_symbols)\n    _new = []\n    for i in c_part:\n        if i.is_Number:\n            coeff *= i\n        else:\n            _new.append(i)\n    c_part = _new\n    _mulsort(c_part)\n    if coeff is not S.One:\n        c_part.insert(0, coeff)\n    if global_distribute[0] and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add:\n        coeff = c_part[0]\n        c_part = [Add(*[coeff * f for f in c_part[1].args])]\n    return (c_part, nc_part, order_symbols)",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (S.One, self)",
    ".sympy.core.expr.py@@Expr.as_base_exp": "def as_base_exp(self):\n    return (self, S.One)",
    ".sympy.core.mul.py@@Mul._gather": "def _gather(c_powers):\n    common_b = {}\n    for b, e in c_powers:\n        co = e.as_coeff_Mul()\n        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n    for b, d in common_b.items():\n        for di, li in d.items():\n            d[di] = Add(*li)\n    new_c_powers = []\n    for b, e in common_b.items():\n        new_c_powers.extend([(b, c * t) for t, c in e.items()])\n    return new_c_powers",
    ".sympy.core.numbers.py@@Rational.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (self, S.One)",
    ".sympy.core.numbers.py@@Zero.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.core.mul.py@@_mulsort": "def _mulsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.operations.py@@AssocOp._from_args": "def _from_args(cls, args, is_commutative=None):\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n    obj = super(AssocOp, cls).__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and((a.is_commutative for a in args))\n    obj.is_commutative = is_commutative\n    return obj",
    ".sympy.core.basic.py@@Basic._exec_constructor_postprocessors": "def _exec_constructor_postprocessors(cls, obj):\n    clsname = obj.__class__.__name__\n    postprocessors = defaultdict(list)\n    for i in obj.args:\n        try:\n            postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)\n            for k, v in chain.from_iterable(postprocessor_mappings):\n                postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n        except TypeError:\n            pass\n    for f in postprocessors.get(clsname, []):\n        obj = f(obj)\n    return obj",
    ".sympy.core.numbers.py@@Rational._eval_is_positive": "def _eval_is_positive(self):\n    return self.p > 0",
    ".sympy.core.numbers.py@@NegativeOne.__abs__": "def __abs__():\n    return S.One",
    ".sympy.core.numbers.py@@Number._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Integer._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_int(self.p, prec, rnd)",
    ".sympy.core.evalf.py@@EvalfMixin.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    from sympy import Float, Number\n    n = n if n is not None else 15\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n    if n == 1 and isinstance(self, Number):\n        from sympy.core.expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        elif not v.is_number:\n            return v\n        try:\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            return v\n    re, im, re_acc, im_acc = result\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im * S.ImaginaryUnit\n    else:\n        return re",
    ".sympy.core.evalf.py@@evalf": "def evalf(x, prec, options):\n    from sympy import re as re_, im as im_\n    try:\n        rf = evalf_table[x.func]\n        r = rf(x, prec, options)\n    except KeyError:\n        if 'subs' in options:\n            x = x.subs(evalf_subs(prec, options['subs']))\n        xe = x._eval_evalf(prec)\n        if xe is None:\n            raise NotImplementedError\n        as_real_imag = getattr(xe, 'as_real_imag', None)\n        if as_real_imag is None:\n            raise NotImplementedError\n        re, im = as_real_imag()\n        if re.has(re_) or im.has(im_):\n            raise NotImplementedError\n        if re == 0:\n            re = None\n            reprec = None\n        elif re.is_number:\n            re = re._to_mpmath(prec, allow_ints=False)._mpf_\n            reprec = prec\n        else:\n            raise NotImplementedError\n        if im == 0:\n            im = None\n            imprec = None\n        elif im.is_number:\n            im = im._to_mpmath(prec, allow_ints=False)._mpf_\n            imprec = prec\n        else:\n            raise NotImplementedError\n        r = (re, im, reprec, imprec)\n    if options.get('verbose'):\n        print('### input', x)\n        print('### output', to_str(r[0] or fzero, 50))\n        print('### raw', r)\n        print()\n    chop = options.get('chop', False)\n    if chop:\n        if chop is True:\n            chop_prec = prec\n        else:\n            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))\n            if chop_prec == 3:\n                chop_prec -= 1\n        r = chop_parts(r, chop_prec)\n    if options.get('strict'):\n        check_target(x, r, prec)\n    return r",
    ".sympy.core.expr.py@@Expr.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy import im, re\n    if hints.get('ignore') == self:\n        return None\n    else:\n        return (re(self), im(self))",
    ".sympy.core.sympify.py@@SympifyError.__init__": "def __init__(self, expr, base_exc=None):\n    self.expr = expr\n    self.base_exc = base_exc",
    ".sympy.functions.elementary.complexes.py@@re.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_extended_real:\n        return arg\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_extended_real:\n        return S.Zero\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[0]\n    elif arg.is_Function and isinstance(arg, conjugate):\n        return re(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_extended_real:\n                    reverted.append(coeff)\n            elif not term.has(S.ImaginaryUnit) and term.is_extended_real:\n                excluded.append(term)\n            else:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[0])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) - im(b) + c",
    ".sympy.functions.elementary.complexes.py@@im.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_extended_real:\n        return S.Zero\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_extended_real:\n        return -S.ImaginaryUnit * arg\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[1]\n    elif arg.is_Function and isinstance(arg, conjugate):\n        return -im(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_extended_real:\n                    reverted.append(coeff)\n                else:\n                    excluded.append(coeff)\n            elif term.has(S.ImaginaryUnit) or not term.is_extended_real:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[1])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) + re(b) + c",
    ".sympy.core.decorators.py@@_SympifyWrapper._func": "def _func(self, other):\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    ".sympy.core.decorators.py@@binary_op_wrapper": "def binary_op_wrapper(self, other):\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:\n            f = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    ".sympy.core.expr.py@@Expr.__rmul__": "def __rmul__(self, other):\n    return Mul(other, self)",
    ".sympy.core.numbers.py@@Integer.__add__": "def __add__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    ".sympy.core.numbers.py@@Rational.as_numer_denom": "def as_numer_denom(self):\n    return (Integer(self.p), Integer(self.q))",
    ".sympy.core.numbers.py@@Integer.__divmod__": "def __divmod__(self, other):\n    from .containers import Tuple\n    if isinstance(other, Integer) and global_evaluate[0]:\n        return Tuple(*divmod(self.p, other.p))\n    else:\n        return Number.__divmod__(self, other)",
    ".sympy.core.containers.py@@Tuple.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.numbers.py@@Integer.__mod__": "def __mod__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p % other)\n        elif isinstance(other, Integer):\n            return Integer(self.p % other.p)\n        return Rational.__mod__(self, other)\n    return Rational.__mod__(self, other)",
    ".sympy.core.expr.py@@Expr.__mul__": "def __mul__(self, other):\n    return Mul(self, other)",
    ".sympy.core.numbers.py@@NumberSymbol.__hash__": "def __hash__(self):\n    return super(NumberSymbol, self).__hash__()",
    ".sympy.core.basic.py@@Basic.compare": "def compare(self, other):\n    if self is other:\n        return 0\n    n1 = self.__class__\n    n2 = other.__class__\n    c = (n1 > n2) - (n1 < n2)\n    if c:\n        return c\n    st = self._hashable_content()\n    ot = other._hashable_content()\n    c = (len(st) > len(ot)) - (len(st) < len(ot))\n    if c:\n        return c\n    for l, r in zip(st, ot):\n        l = Basic(*l) if isinstance(l, frozenset) else l\n        r = Basic(*r) if isinstance(r, frozenset) else r\n        if isinstance(l, Basic):\n            c = l.compare(r)\n        else:\n            c = (l > r) - (l < r)\n        if c:\n            return c\n    return 0",
    ".sympy.core.core.py@@BasicMeta.__gt__": "def __gt__(cls, other):\n    if cls.__cmp__(other) == 1:\n        return True\n    return False",
    ".sympy.core.core.py@@BasicMeta.__cmp__": "def __cmp__(cls, other):\n    if not isinstance(other, BasicMeta):\n        return -1\n    n1 = cls.__name__\n    n2 = other.__name__\n    if n1 == n2:\n        return 0\n    UNKNOWN = len(ordering_of_classes) + 1\n    try:\n        i1 = ordering_of_classes.index(n1)\n    except ValueError:\n        i1 = UNKNOWN\n    try:\n        i2 = ordering_of_classes.index(n2)\n    except ValueError:\n        i2 = UNKNOWN\n    if i1 == UNKNOWN and i2 == UNKNOWN:\n        return (n1 > n2) - (n1 < n2)\n    return (i1 > i2) - (i1 < i2)",
    ".sympy.core.core.py@@BasicMeta.__lt__": "def __lt__(cls, other):\n    if cls.__cmp__(other) == -1:\n        return True\n    return False",
    ".sympy.core.mul.py@@Mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return (coeff, args[0])\n            else:\n                return (coeff, self._new_rawargs(*args))\n        elif coeff.is_extended_negative:\n            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))\n    return (S.One, self)",
    ".sympy.core.operations.py@@AssocOp._new_rawargs": "def _new_rawargs(self, *args, **kwargs):\n    if kwargs.pop('reeval', True) and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)",
    ".sympy.core.decorators.py@@__sympifyit_wrapper": "def __sympifyit_wrapper(a, b):\n    try:\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    ".sympy.core.numbers.py@@Rational.__mul__": "def __mul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, Integer):\n            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))\n        elif isinstance(other, Float):\n            return other * self\n        else:\n            return Number.__mul__(self, other)\n    return Number.__mul__(self, other)",
    ".sympy.core.compatibility.py@@_nodes": "def _nodes(e):\n    from .basic import Basic\n    if isinstance(e, Basic):\n        return e.count(Basic)\n    elif iterable(e):\n        return 1 + sum((_nodes(ei) for ei in e))\n    elif isinstance(e, dict):\n        return 1 + sum((_nodes(k) + _nodes(v) for k, v in e.items()))\n    else:\n        return 1",
    ".sympy.core.basic.py@@Basic.count": "def count(self, query):\n    query = _make_find_query(query)\n    return sum((bool(query(sub)) for sub in preorder_traversal(self)))",
    ".sympy.core.basic.py@@_make_find_query": "def _make_find_query(query):\n    try:\n        query = sympify(query)\n    except SympifyError:\n        pass\n    if isinstance(query, type):\n        return lambda expr: isinstance(expr, query)\n    elif isinstance(query, Basic):\n        return lambda expr: expr.match(query) is not None\n    return query",
    ".sympy.core.compatibility.py@@default_sort_key": "def default_sort_key(item, order=None):\n    from .singleton import S\n    from .basic import Basic\n    from .sympify import sympify, SympifyError\n    from .compatibility import iterable\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n    if iterable(item, exclude=string_types):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            args = list(item)\n            unordered = False\n        args = [default_sort_key(arg, order=order) for arg in args]\n        if unordered:\n            args = sorted(args)\n        cls_index, args = (10, (len(args), tuple(args)))\n    else:\n        if not isinstance(item, string_types):\n            try:\n                item = sympify(item)\n            except SympifyError:\n                pass\n            else:\n                if isinstance(item, Basic):\n                    return default_sort_key(item)\n        cls_index, args = (0, (1, (str(item),)))\n    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)",
    ".sympy.core.numbers.py@@Number.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (0, ()), (), self)",
    ".sympy.core.numbers.py@@Number.class_key": "def class_key(cls):\n    return (1, 0, 'Number')",
    ".sympy.logic.boolalg.py@@BooleanFalse.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.functions.elementary.exponential.py@@log.eval": "def eval(cls, arg, base=None):\n    from sympy import unpolarify\n    from sympy.calculus import AccumBounds\n    from sympy.sets.setexpr import SetExpr\n    from sympy.functions.elementary.complexes import Abs\n    arg = sympify(arg)\n    if base is not None:\n        base = sympify(base)\n        if base == 1:\n            if arg == 1:\n                return S.NaN\n            else:\n                return S.ComplexInfinity\n        try:\n            n = multiplicity(base, arg)\n            if n:\n                return n + log(arg / base ** n) / log(base)\n            else:\n                return log(arg) / log(base)\n        except ValueError:\n            pass\n        if base is not S.Exp1:\n            return cls(arg) / cls(base)\n        else:\n            return cls(arg)\n    if arg.is_Number:\n        if arg.is_zero:\n            return S.ComplexInfinity\n        elif arg is S.One:\n            return S.Zero\n        elif arg is S.Infinity:\n            return S.Infinity\n        elif arg is S.NegativeInfinity:\n            return S.Infinity\n        elif arg is S.NaN:\n            return S.NaN\n        elif arg.is_Rational and arg.p == 1:\n            return -cls(arg.q)\n    I = S.ImaginaryUnit\n    if isinstance(arg, exp) and arg.args[0].is_extended_real:\n        return arg.args[0]\n    elif isinstance(arg, exp) and arg.args[0].is_number:\n        r_, i_ = match_real_imag(arg.args[0])\n        if i_ and i_.is_comparable:\n            i_ %= 2 * S.Pi\n            if i_ > S.Pi:\n                i_ -= 2 * S.Pi\n            return r_ + expand_mul(i_ * I, deep=False)\n    elif isinstance(arg, exp_polar):\n        return unpolarify(arg.exp)\n    elif isinstance(arg, AccumBounds):\n        if arg.min.is_positive:\n            return AccumBounds(log(arg.min), log(arg.max))\n        else:\n            return\n    elif isinstance(arg, SetExpr):\n        return arg._eval_func(cls)\n    if arg.is_number:\n        if arg.is_negative:\n            return S.Pi * I + cls(-arg)\n        elif arg is S.ComplexInfinity:\n            return S.ComplexInfinity\n        elif arg is S.Exp1:\n            return S.One\n    if arg.is_zero:\n        return S.ComplexInfinity\n    if not arg.is_Add:\n        coeff = arg.as_coefficient(I)\n        if coeff is not None:\n            if coeff is S.Infinity:\n                return S.Infinity\n            elif coeff is S.NegativeInfinity:\n                return S.Infinity\n            elif coeff.is_Rational:\n                if coeff.is_nonnegative:\n                    return S.Pi * I * S.Half + cls(coeff)\n                else:\n                    return -S.Pi * I * S.Half + cls(-coeff)\n    if arg.is_number and arg.is_algebraic:\n        coeff, arg_ = arg.as_independent(I, as_Add=False)\n        if coeff.is_negative:\n            coeff *= -1\n            arg_ *= -1\n        arg_ = expand_mul(arg_, deep=False)\n        r_, i_ = arg_.as_independent(I, as_Add=True)\n        i_ = i_.as_coefficient(I)\n        if coeff.is_real and i_ and i_.is_real and r_.is_real:\n            if r_.is_zero:\n                if i_.is_positive:\n                    return S.Pi * I * S.Half + cls(coeff * i_)\n                elif i_.is_negative:\n                    return -S.Pi * I * S.Half + cls(coeff * -i_)\n            else:\n                from sympy.simplify import ratsimp\n                t = (i_ / r_).cancel()\n                atan_table = {sqrt(3): S.Pi / 3, 1: S.Pi / 4, sqrt(5 - 2 * sqrt(5)): S.Pi / 5, sqrt(2) * sqrt(5 - sqrt(5)) / (1 + sqrt(5)): S.Pi / 5, sqrt(5 + 2 * sqrt(5)): S.Pi * Rational(2, 5), sqrt(2) * sqrt(sqrt(5) + 5) / (-1 + sqrt(5)): S.Pi * Rational(2, 5), sqrt(3) / 3: S.Pi / 6, sqrt(2) - 1: S.Pi / 8, sqrt(2 - sqrt(2)) / sqrt(sqrt(2) + 2): S.Pi / 8, sqrt(2) + 1: S.Pi * Rational(3, 8), sqrt(sqrt(2) + 2) / sqrt(2 - sqrt(2)): S.Pi * Rational(3, 8), sqrt(1 - 2 * sqrt(5) / 5): S.Pi / 10, (-sqrt(2) + sqrt(10)) / (2 * sqrt(sqrt(5) + 5)): S.Pi / 10, sqrt(1 + 2 * sqrt(5) / 5): S.Pi * Rational(3, 10), (sqrt(2) + sqrt(10)) / (2 * sqrt(5 - sqrt(5))): S.Pi * Rational(3, 10), 2 - sqrt(3): S.Pi / 12, (-1 + sqrt(3)) / (1 + sqrt(3)): S.Pi / 12, 2 + sqrt(3): S.Pi * Rational(5, 12), (1 + sqrt(3)) / (-1 + sqrt(3)): S.Pi * Rational(5, 12)}\n                if t in atan_table:\n                    modulus = ratsimp(coeff * Abs(arg_))\n                    if r_.is_positive:\n                        return cls(modulus) + I * atan_table[t]\n                    else:\n                        return cls(modulus) + I * (atan_table[t] - S.Pi)\n                elif -t in atan_table:\n                    modulus = ratsimp(coeff * Abs(arg_))\n                    if r_.is_positive:\n                        return cls(modulus) + I * -atan_table[-t]\n                    else:\n                        return cls(modulus) + I * (S.Pi - atan_table[-t])",
    ".sympy.core.expr.py@@Expr.as_coefficient": "def as_coefficient(self, expr):\n    r = self.extract_multiplicatively(expr)\n    if r and (not r.has(expr)):\n        return r",
    ".sympy.core.expr.py@@Expr.extract_multiplicatively": "def extract_multiplicatively(self, c):\n    from .add import _unevaluated_Add\n    c = sympify(c)\n    if self is S.NaN:\n        return None\n    if c is S.One:\n        return self\n    elif c == self:\n        return S.One\n    if c.is_Add:\n        cc, pc = c.primitive()\n        if cc is not S.One:\n            c = Mul(cc, pc, evaluate=False)\n    if c.is_Mul:\n        a, b = c.as_two_terms()\n        x = self.extract_multiplicatively(a)\n        if x is not None:\n            return x.extract_multiplicatively(b)\n        else:\n            return x\n    quotient = self / c\n    if self.is_Number:\n        if self is S.Infinity:\n            if c.is_positive:\n                return S.Infinity\n        elif self is S.NegativeInfinity:\n            if c.is_negative:\n                return S.Infinity\n            elif c.is_positive:\n                return S.NegativeInfinity\n        elif self is S.ComplexInfinity:\n            if not c.is_zero:\n                return S.ComplexInfinity\n        elif self.is_Integer:\n            if not quotient.is_Integer:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n        elif self.is_Rational:\n            if not quotient.is_Rational:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n        elif self.is_Float:\n            if not quotient.is_Float:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n    elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:\n        if quotient.is_Mul and len(quotient.args) == 2:\n            if quotient.args[0].is_Integer and quotient.args[0].is_positive and (quotient.args[1] == self):\n                return quotient\n        elif quotient.is_Integer and c.is_Number:\n            return quotient\n    elif self.is_Add:\n        cs, ps = self.primitive()\n        if c.is_Number and c is not S.NegativeOne:\n            if cs is not S.One:\n                if c.is_negative:\n                    xc = -cs.extract_multiplicatively(-c)\n                else:\n                    xc = cs.extract_multiplicatively(c)\n                if xc is not None:\n                    return xc * ps\n            return\n        if c == ps:\n            return cs\n        newargs = []\n        for arg in ps.args:\n            newarg = arg.extract_multiplicatively(c)\n            if newarg is None:\n                return\n            newargs.append(newarg)\n        if cs is not S.One:\n            args = [cs * t for t in newargs]\n            return _unevaluated_Add(*args)\n        else:\n            return Add._from_args(newargs)\n    elif self.is_Mul:\n        args = list(self.args)\n        for i, arg in enumerate(args):\n            newarg = arg.extract_multiplicatively(c)\n            if newarg is not None:\n                args[i] = newarg\n                return Mul(*args)\n    elif self.is_Pow:\n        if c.is_Pow and c.base == self.base:\n            new_exp = self.exp.extract_additively(c.exp)\n            if new_exp is not None:\n                return self.base ** new_exp\n        elif c == self.base:\n            new_exp = self.exp.extract_additively(1)\n            if new_exp is not None:\n                return self.base ** new_exp",
    ".sympy.core.numbers.py@@Rational.__div__": "def __div__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, Integer):\n            if self.p and other.p == S.Zero:\n                return S.ComplexInfinity\n            else:\n                return Rational(self.p, self.q * other.p, igcd(self.p, other.p))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q, self.q * other.p, igcd(self.p, other.p) * igcd(self.q, other.q))\n        elif isinstance(other, Float):\n            return self * (1 / other)\n        else:\n            return Number.__div__(self, other)\n    return Number.__div__(self, other)",
    ".sympy.core.numbers.py@@Number.__div__": "def __div__(self, other):\n    if isinstance(other, Number) and global_evaluate[0]:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity or other is S.NegativeInfinity:\n            return S.Zero\n    return AtomicExpr.__div__(self, other)",
    ".sympy.core.expr.py@@Expr.__div__": "def __div__(self, other):\n    return Mul(self, Pow(other, S.NegativeOne))",
    ".sympy.core.function.py@@_coeff_isneg": "def _coeff_isneg(a):\n    if a.is_MatMul:\n        a = a.args[0]\n    if a.is_Mul:\n        a = a.args[0]\n    return a.is_Number and a.is_extended_negative",
    ".sympy.core.numbers.py@@ImaginaryUnit._eval_power": "def _eval_power(self, expt):\n    if isinstance(expt, Number):\n        if isinstance(expt, Integer):\n            expt = expt.p % 4\n            if expt == 0:\n                return S.One\n            if expt == 1:\n                return S.ImaginaryUnit\n            if expt == 2:\n                return -S.One\n            return -S.ImaginaryUnit\n    return",
    ".sympy.core.expr.py@@Expr.__neg__": "def __neg__(self):\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    ".sympy.core.expr.py@@Expr.as_independent": "def as_independent(self, *deps, **hint):\n    from .symbol import Symbol\n    from .add import _unevaluated_Add\n    from .mul import _unevaluated_Mul\n    from sympy.utilities.iterables import sift\n    if self.is_zero:\n        return (S.Zero, S.Zero)\n    func = self.func\n    if hint.get('as_Add', isinstance(self, Add)):\n        want = Add\n    else:\n        want = Mul\n    sym = set()\n    other = []\n    for d in deps:\n        if isinstance(d, Symbol):\n            sym.add(d)\n        else:\n            other.append(d)\n\n    def has(e):\n        has_other = e.has(*other)\n        if not sym:\n            return has_other\n        return has_other or e.has(*e.free_symbols & sym)\n    if want is not func or (func is not Add and func is not Mul):\n        if has(self):\n            return (want.identity, self)\n        else:\n            return (self, want.identity)\n    elif func is Add:\n        args = list(self.args)\n    else:\n        args, nc = self.args_cnc()\n    d = sift(args, lambda x: has(x))\n    depend = d[True]\n    indep = d[False]\n    if func is Add:\n        return (Add(*indep), _unevaluated_Add(*depend))\n    else:\n        for i, n in enumerate(nc):\n            if has(n):\n                depend.extend(nc[i:])\n                break\n            indep.append(n)\n        return (Mul(*indep), Mul(*depend, evaluate=False) if nc else _unevaluated_Mul(*depend))",
    ".sympy.core.expr.py@@Expr.has": "def has(e):\n    has_other = e.has(*other)\n    if not sym:\n        return has_other\n    return has_other or e.has(*e.free_symbols & sym)",
    ".sympy.core.basic.py@@Basic.has": "def has(self, *patterns):\n    return any((self._has(pattern) for pattern in patterns))",
    ".sympy.core.basic.py@@Basic._has": "def _has(self, pattern):\n    from sympy.core.function import UndefinedFunction, Function\n    if isinstance(pattern, UndefinedFunction):\n        return any((f.func == pattern or f == pattern for f in self.atoms(Function, UndefinedFunction)))\n    pattern = sympify(pattern)\n    if isinstance(pattern, BasicMeta):\n        return any((isinstance(arg, pattern) for arg in preorder_traversal(self)))\n    _has_matcher = getattr(pattern, '_has_matcher', None)\n    if _has_matcher is not None:\n        match = _has_matcher()\n        return any((match(arg) for arg in preorder_traversal(self)))\n    else:\n        return any((arg == pattern for arg in preorder_traversal(self)))",
    ".sympy.core.basic.py@@Basic._has_matcher": "def _has_matcher(self):\n    return lambda other: self == other",
    ".sympy.core.function.py@@expand_mul": "def expand_mul(expr, deep=True):\n    return sympify(expr).expand(deep=deep, mul=True, power_exp=False, power_base=False, basic=False, multinomial=False, log=False)",
    ".sympy.core.expr.py@@Expr.expand": "def expand(self, deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints):\n    from sympy.simplify.radsimp import fraction\n    hints.update(power_base=power_base, power_exp=power_exp, mul=mul, log=log, multinomial=multinomial, basic=basic)\n    expr = self\n    if hints.pop('frac', False):\n        n, d = [a.expand(deep=deep, modulus=modulus, **hints) for a in fraction(self)]\n        return n / d\n    elif hints.pop('denom', False):\n        n, d = fraction(self)\n        return n / d.expand(deep=deep, modulus=modulus, **hints)\n    elif hints.pop('numer', False):\n        n, d = fraction(self)\n        return n.expand(deep=deep, modulus=modulus, **hints) / d\n\n    def _expand_hint_key(hint):\n        if hint == 'mul':\n            return 'mulz'\n        return hint\n    for hint in sorted(hints.keys(), key=_expand_hint_key):\n        use_hint = hints[hint]\n        if use_hint:\n            hint = '_eval_expand_' + hint\n            expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)\n    while True:\n        was = expr\n        if hints.get('multinomial', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_multinomial', deep=deep, **hints)\n        if hints.get('mul', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_mul', deep=deep, **hints)\n        if hints.get('log', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_log', deep=deep, **hints)\n        if expr == was:\n            break\n    if modulus is not None:\n        modulus = sympify(modulus)\n        if not modulus.is_Integer or modulus <= 0:\n            raise ValueError('modulus must be a positive integer, got %s' % modulus)\n        terms = []\n        for term in Add.make_args(expr):\n            coeff, tail = term.as_coeff_Mul(rational=True)\n            coeff %= modulus\n            if coeff:\n                terms.append(coeff * tail)\n        expr = Add(*terms)\n    return expr",
    ".sympy.core.expr.py@@Expr._expand_hint_key": "def _expand_hint_key(hint):\n    if hint == 'mul':\n        return 'mulz'\n    return hint",
    ".sympy.core.expr.py@@Expr._expand_hint": "def _expand_hint(expr, hint, deep=True, **hints):\n    hit = False\n    if deep and getattr(expr, 'args', ()) and (not expr.is_Atom):\n        sargs = []\n        for arg in expr.args:\n            arg, arghit = Expr._expand_hint(arg, hint, **hints)\n            hit |= arghit\n            sargs.append(arg)\n        if hit:\n            expr = expr.func(*sargs)\n    if hasattr(expr, hint):\n        newexpr = getattr(expr, hint)(**hints)\n        if newexpr != expr:\n            return (newexpr, True)\n    return (expr, hit)",
    ".sympy.core.function.py@@Function.is_commutative": "def is_commutative(self):\n    if all((getattr(t, 'is_commutative') for t in self.args)):\n        return True\n    else:\n        return False",
    ".sympy.functions.elementary.exponential.py@@log.as_base_exp": "def as_base_exp(self):\n    return (self, S.One)",
    ".sympy.core.expr.py@@Expr._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_complex": "def _eval_is_complex(self):\n    z = self.args[0]\n    return fuzzy_and([z.is_complex, fuzzy_not(z.is_zero)])",
    ".sympy.core.logic.py@@fuzzy_not": "def fuzzy_not(v):\n    if v is None:\n        return v\n    else:\n        return not v",
    ".sympy.core.logic.py@@fuzzy_and": "def fuzzy_and(args):\n    rv = True\n    for ai in args:\n        ai = fuzzy_bool(ai)\n        if ai is False:\n            return False\n        if rv:\n            rv = ai\n    return rv",
    ".sympy.core.logic.py@@fuzzy_bool": "def fuzzy_bool(x):\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_extended_nonnegative": "def _eval_is_extended_nonnegative(self):\n    return (self.args[0] - 1).is_extended_nonnegative",
    ".sympy.core.numbers.py@@Integer._eval_is_prime": "def _eval_is_prime(self):\n    from sympy.ntheory import isprime\n    return isprime(self)",
    ".sympy.ntheory.primetest.py@@isprime": "def isprime(n):\n    try:\n        n = as_int(n)\n    except ValueError:\n        return False\n    if n in [2, 3, 5]:\n        return True\n    if n < 2 or n % 2 == 0 or n % 3 == 0 or (n % 5 == 0):\n        return False\n    if n < 49:\n        return True\n    if n % 7 == 0 or n % 11 == 0 or n % 13 == 0 or (n % 17 == 0) or (n % 19 == 0) or (n % 23 == 0) or (n % 29 == 0) or (n % 31 == 0) or (n % 37 == 0) or (n % 41 == 0) or (n % 43 == 0) or (n % 47 == 0):\n        return False\n    if n < 2809:\n        return True\n    if n <= 23001:\n        return pow(2, n, n) == 2 and n not in [7957, 8321, 13747, 18721, 19951]\n    from sympy.ntheory.generate import sieve as s\n    if n <= s._list[-1]:\n        l, u = s.search(n)\n        return l == u\n    from sympy.core.compatibility import HAS_GMPY\n    if HAS_GMPY == 2:\n        from gmpy2 import is_strong_prp, is_strong_selfridge_prp\n        return is_strong_prp(n, 2) and is_strong_selfridge_prp(n)\n    if n < 341531:\n        return mr(n, [9345883071009581737])\n    if n < 885594169:\n        return mr(n, [725270293939359937, 3569819667048198375])\n    if n < 350269456337:\n        return mr(n, [4230279247111683200, 14694767155120705706, 16641139526367750375])\n    if n < 55245642489451:\n        return mr(n, [2, 141889084524735, 1199124725622454117, 11096072698276303650])\n    if n < 7999252175582851:\n        return mr(n, [2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805])\n    if n < 585226005592931977:\n        return mr(n, [2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375])\n    if n < 18446744073709551616:\n        return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n    return mr(n, [2]) and is_strong_lucas_prp(n)",
    ".sympy.core.compatibility.py@@as_int": "def as_int(n, strict=True):\n    from sympy.core.numbers import Integer\n    try:\n        if strict and (not isinstance(n, SYMPY_INTS + (Integer,))):\n            raise TypeError\n        result = int(n)\n        if result != n:\n            raise TypeError\n        return result\n    except TypeError:\n        raise ValueError('%s is not an integer' % (n,))",
    ".sympy.core.numbers.py@@Integer.__int__": "def __int__(self):\n    return self.p",
    ".sympy.core.numbers.py@@Integer.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_zero": "def _eval_is_zero(self):\n    return (self.args[0] - 1).is_zero",
    ".sympy.core.numbers.py@@igcd": "def igcd(*args):\n    if len(args) < 2:\n        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))\n    args_temp = [abs(as_int(i)) for i in args]\n    if 1 in args_temp:\n        return 1\n    a = args_temp.pop()\n    for b in args_temp:\n        a = igcd2(a, b) if b else a\n    return a",
    ".sympy.core.numbers.py@@Rational.__add__": "def __add__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, Integer):\n            return Rational(self.p + self.q * other.p, self.q, 1)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + self.q * other.p, self.q * other.q)\n        elif isinstance(other, Float):\n            return other + self\n        else:\n            return Number.__add__(self, other)\n    return Number.__add__(self, other)",
    ".sympy.core.numbers.py@@Rational.__neg__": "def __neg__(self):\n    return Rational(-self.p, self.q)",
    ".sympy.core.numbers.py@@Integer._eval_power": "def _eval_power(self, expt):\n    from sympy.ntheory.factor_ import perfect_power\n    if expt is S.Infinity:\n        if self.p > S.One:\n            return S.Infinity\n        return S.Infinity + S.ImaginaryUnit * S.Infinity\n    if expt is S.NegativeInfinity:\n        return Rational(1, self) ** S.Infinity\n    if not isinstance(expt, Number):\n        if self.is_negative and expt.is_even:\n            return (-self) ** expt\n    if isinstance(expt, Float):\n        return super(Integer, self)._eval_power(expt)\n    if not isinstance(expt, Rational):\n        return\n    if expt is S.Half and self.is_negative:\n        return S.ImaginaryUnit * Pow(-self, expt)\n    if expt.is_negative:\n        ne = -expt\n        if self.is_negative:\n            return S.NegativeOne ** expt * Rational(1, -self) ** ne\n        else:\n            return Rational(1, self.p) ** ne\n    x, xexact = integer_nthroot(abs(self.p), expt.q)\n    if xexact:\n        result = Integer(x ** abs(expt.p))\n        if self.is_negative:\n            result *= S.NegativeOne ** expt\n        return result\n    b_pos = int(abs(self.p))\n    p = perfect_power(b_pos)\n    if p is not False:\n        dict = {p[0]: p[1]}\n    else:\n        dict = Integer(b_pos).factors(limit=2 ** 15)\n    out_int = 1\n    out_rad = 1\n    sqr_int = 1\n    sqr_gcd = 0\n    sqr_dict = {}\n    for prime, exponent in dict.items():\n        exponent *= expt.p\n        div_e, div_m = divmod(exponent, expt.q)\n        if div_e > 0:\n            out_int *= prime ** div_e\n        if div_m > 0:\n            g = igcd(div_m, expt.q)\n            if g != 1:\n                out_rad *= Pow(prime, Rational(div_m // g, expt.q // g))\n            else:\n                sqr_dict[prime] = div_m\n    for p, ex in sqr_dict.items():\n        if sqr_gcd == 0:\n            sqr_gcd = ex\n        else:\n            sqr_gcd = igcd(sqr_gcd, ex)\n            if sqr_gcd == 1:\n                break\n    for k, v in sqr_dict.items():\n        sqr_int *= k ** (v // sqr_gcd)\n    if sqr_int == b_pos and out_int == 1 and (out_rad == 1):\n        result = None\n    else:\n        result = out_int * out_rad * Pow(sqr_int, Rational(sqr_gcd, expt.q))\n        if self.is_negative:\n            result *= Pow(S.NegativeOne, expt)\n    return result",
    ".sympy.core.numbers.py@@NegativeOne.__neg__": "def __neg__():\n    return S.One",
    ".sympy.core.expr.py@@Expr.__pow__": "def __pow__(self, other, mod=None):\n    if mod is None:\n        return self._pow(other)\n    try:\n        _self, other, mod = (as_int(self), as_int(other), as_int(mod))\n        if other >= 0:\n            return pow(_self, other, mod)\n        else:\n            from sympy.core.numbers import mod_inverse\n            return mod_inverse(pow(_self, -other, mod), mod)\n    except ValueError:\n        power = self._pow(other)\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    ".sympy.core.expr.py@@Expr._pow": "def _pow(self, other):\n    return Pow(self, other)",
    ".sympy.core.numbers.py@@NumberSymbol.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if self is other:\n        return True\n    if other.is_Number and self.is_irrational:\n        return False\n    return False",
    ".sympy.core.expr.py@@Expr._eval_power": "def _eval_power(self, other):\n    return None",
    ".sympy.core.numbers.py@@NumberSymbol.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.numbers.py@@Rational.__sub__": "def __sub__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, Integer):\n            return Rational(self.p - self.q * other.p, self.q, 1)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - self.q * other.p, self.q * other.q)\n        elif isinstance(other, Float):\n            return -other + self\n        else:\n            return Number.__sub__(self, other)\n    return Number.__sub__(self, other)",
    ".sympy.core.numbers.py@@Number.__sub__": "def __sub__(self, other):\n    if isinstance(other, Number) and global_evaluate[0]:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            return S.NegativeInfinity\n        elif other is S.NegativeInfinity:\n            return S.Infinity\n    return AtomicExpr.__sub__(self, other)",
    ".sympy.core.expr.py@@Expr.__sub__": "def __sub__(self, other):\n    return Add(self, -other)",
    ".sympy.core.mul.py@@Mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    ".sympy.core.mul.py@@Mul.as_coeff_mul": "def as_coeff_mul(self, *deps, **kwargs):\n    if deps:\n        from sympy.utilities.iterables import sift\n        l1, l2 = sift(self.args, lambda x: x.has(*deps), binary=True)\n        return (self._new_rawargs(*l2), tuple(l1))\n    rational = kwargs.pop('rational', True)\n    args = self.args\n    if args[0].is_Number:\n        if not rational or args[0].is_Rational:\n            return (args[0], args[1:])\n        elif args[0].is_extended_negative:\n            return (S.NegativeOne, (-args[0],) + args[1:])\n    return (S.One, args)",
    ".sympy.core.add.py@@Add.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    from sympy.tensor.tensor import TensExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        if a.is_Rational:\n            if b.is_Mul:\n                rv = ([a, b], [], None)\n        if rv:\n            if all((s.is_commutative for s in rv[0])):\n                return rv\n            return ([], rv[0], None)\n    terms = {}\n    coeff = S.Zero\n    order_factors = []\n    extra = []\n    for o in seq:\n        if o.is_Order:\n            for o1 in order_factors:\n                if o1.contains(o):\n                    o = None\n                    break\n            if o is None:\n                continue\n            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]\n            continue\n        elif o.is_Number:\n            if (o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False)) and (not extra):\n                return ([S.NaN], [], None)\n            if coeff.is_Number:\n                coeff += o\n                if coeff is S.NaN and (not extra):\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__add__(coeff)\n            continue\n        elif isinstance(o, MatrixExpr):\n            extra.append(o)\n            continue\n        elif isinstance(o, TensExpr):\n            coeff = o.__add__(coeff) if coeff else o\n            continue\n        elif o is S.ComplexInfinity:\n            if coeff.is_finite is False and (not extra):\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o.is_Add:\n            seq.extend(o.args)\n            continue\n        elif o.is_Mul:\n            c, s = o.as_coeff_Mul()\n        elif o.is_Pow:\n            b, e = o.as_base_exp()\n            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):\n                seq.append(b ** e)\n                continue\n            c, s = (S.One, o)\n        else:\n            c = S.One\n            s = o\n        if s in terms:\n            terms[s] += c\n            if terms[s] is S.NaN and (not extra):\n                return ([S.NaN], [], None)\n        else:\n            terms[s] = c\n    newseq = []\n    noncommutative = False\n    for s, c in terms.items():\n        if c.is_zero:\n            continue\n        elif c is S.One:\n            newseq.append(s)\n        elif s.is_Mul:\n            cs = s._new_rawargs(*(c,) + s.args)\n            newseq.append(cs)\n        elif s.is_Add:\n            newseq.append(Mul(c, s, evaluate=False))\n        else:\n            newseq.append(Mul(c, s))\n        noncommutative = noncommutative or not s.is_commutative\n    if coeff is S.Infinity:\n        newseq = [f for f in newseq if not (f.is_extended_nonnegative or f.is_real)]\n    elif coeff is S.NegativeInfinity:\n        newseq = [f for f in newseq if not (f.is_extended_nonpositive or f.is_real)]\n    if coeff is S.ComplexInfinity:\n        newseq = [c for c in newseq if not (c.is_finite and c.is_extended_real is not None)]\n    if order_factors:\n        newseq2 = []\n        for t in newseq:\n            for o in order_factors:\n                if o.contains(t):\n                    t = None\n                    break\n            if t is not None:\n                newseq2.append(t)\n        newseq = newseq2 + order_factors\n        for o in order_factors:\n            if o.contains(coeff):\n                coeff = S.Zero\n                break\n    _addsort(newseq)\n    if coeff is not S.Zero:\n        newseq.insert(0, coeff)\n    if extra:\n        newseq += extra\n        noncommutative = True\n    if noncommutative:\n        return ([], newseq, None)\n    else:\n        return (newseq, [], None)",
    ".sympy.functions.elementary.integers.py@@RoundFunction.eval": "def eval(cls, arg):\n    from sympy import im\n    if arg.is_integer or arg.is_finite is False:\n        return arg\n    if arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        i = im(arg)\n        if not i.has(S.ImaginaryUnit):\n            return cls(i) * S.ImaginaryUnit\n        return cls(arg, evaluate=False)\n    v = cls._eval_number(arg)\n    if v is not None:\n        return v\n    ipart = npart = spart = S.Zero\n    terms = Add.make_args(arg)\n    for t in terms:\n        if t.is_integer or (t.is_imaginary and im(t).is_integer):\n            ipart += t\n        elif t.has(Symbol):\n            spart += t\n        else:\n            npart += t\n    if not (npart or spart):\n        return ipart\n    if npart and (not spart or (npart.is_real and (spart.is_imaginary or (S.ImaginaryUnit * spart).is_real)) or (npart.is_imaginary and spart.is_real)):\n        try:\n            r, i = get_integer_part(npart, cls._dir, {}, return_ints=True)\n            ipart += Integer(r) + Integer(i) * S.ImaginaryUnit\n            npart = S.Zero\n        except (PrecisionExhausted, NotImplementedError):\n            pass\n    spart += npart\n    if not spart:\n        return ipart\n    elif spart.is_imaginary or (S.ImaginaryUnit * spart).is_real:\n        return ipart + cls(im(spart), evaluate=False) * S.ImaginaryUnit\n    else:\n        return ipart + cls(spart, evaluate=False)",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_rational": "def _eval_is_rational(self):\n    s = self.func(*self.args)\n    if s.func == self.func:\n        if (self.args[0] - 1).is_zero:\n            return True\n        if s.args[0].is_rational and fuzzy_not((self.args[0] - 1).is_zero):\n            return False\n    else:\n        return s.is_rational",
    ".sympy.core.function.py@@Application.func": "def func(self):\n    return self.__class__",
    ".sympy.core.numbers.py@@One.__neg__": "def __neg__():\n    return S.NegativeOne",
    ".sympy.core.add.py@@_addsort": "def _addsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.add.py@@Add._eval_is_zero": "def _eval_is_zero(self):\n    if self.is_commutative is False:\n        return\n    nz = []\n    z = 0\n    im_or_z = False\n    im = False\n    for a in self.args:\n        if a.is_extended_real:\n            if a.is_zero:\n                z += 1\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im = True\n        elif (S.ImaginaryUnit * a).is_extended_real:\n            im_or_z = True\n        else:\n            return\n    if z == len(self.args):\n        return True\n    if len(nz) == 0 or len(nz) == len(self.args):\n        return None\n    b = self.func(*nz)\n    if b.is_zero:\n        if not im_or_z and (not im):\n            return True\n        if im and (not im_or_z):\n            return False\n    if b.is_zero is False:\n        return False",
    ".sympy.core.add.py@@Add._eval_is_extended_nonnegative": "def _eval_is_extended_nonnegative(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_extended_nonnegative:\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s != self and s.is_extended_nonnegative:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v != self and v.is_extended_nonnegative:\n                        return True",
    ".sympy.core.expr.py@@Expr.is_number": "def is_number(self):\n    return all((obj.is_number for obj in self.args))",
    ".sympy.core.add.py@@Add._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if self.is_number:\n        return super(Add, self)._eval_is_extended_positive()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s != self and s.is_extended_positive and a.is_extended_nonnegative:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v != self and v.is_extended_positive:\n                    return True\n    pos = nonneg = nonpos = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        ispos = a.is_extended_positive\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((ispos, a.is_extended_nonnegative)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if ispos:\n            pos = True\n            continue\n        elif a.is_extended_nonnegative:\n            nonneg = True\n            continue\n        elif a.is_extended_nonpositive:\n            nonpos = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonpos and (not nonneg) and pos:\n        return True\n    elif not nonpos and pos:\n        return True\n    elif not pos and (not nonneg):\n        return False",
    ".sympy.core.operations.py@@AssocOp._eval_evalf": "def _eval_evalf(self, prec):\n    from .add import Add\n    from .mul import Mul\n    from .symbol import Symbol\n    from .function import AppliedUndef\n    if isinstance(self, (Mul, Add)):\n        x, tail = self.as_independent(Symbol, AppliedUndef)\n        if not (tail is self.identity or (isinstance(x, AssocOp) and x.is_Function) or (x is self.identity and isinstance(tail, AssocOp))):\n            x = x._evalf(prec) if x is not self.identity else self.identity\n            args = []\n            tail_args = tuple(self.func.make_args(tail))\n            for a in tail_args:\n                newa = a._eval_evalf(prec)\n                if newa is None:\n                    args.append(a)\n                else:\n                    args.append(newa)\n            return self.func(x, *args)\n    args = []\n    for a in self.args:\n        newa = a._eval_evalf(prec)\n        if newa is None:\n            args.append(a)\n        else:\n            args.append(newa)\n    return self.func(*args)",
    ".sympy.utilities.iterables.py@@sift": "def sift(seq, keyfunc, binary=False):\n    if not binary:\n        m = defaultdict(list)\n        for i in seq:\n            m[keyfunc(i)].append(i)\n        return m\n    sift = F, T = ([], [])\n    for i in seq:\n        try:\n            sift[keyfunc(i)].append(i)\n        except (IndexError, TypeError):\n            raise ValueError('keyfunc gave non-binary output')\n    return (T, F)",
    ".sympy.core.add.py@@_unevaluated_Add": "def _unevaluated_Add(*args):\n    args = list(args)\n    newargs = []\n    co = S.Zero\n    while args:\n        a = args.pop()\n        if a.is_Add:\n            args.extend(a.args)\n        elif a.is_Number:\n            co += a\n        else:\n            newargs.append(a)\n    _addsort(newargs)\n    if co:\n        newargs.insert(0, co)\n    return Add._from_args(newargs)",
    ".sympy.core.numbers.py@@NumberSymbol._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Pi._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mpf_pi(prec)",
    ".sympy.core.numbers.py@@Float.__add__": "def __add__(self, other):\n    if isinstance(other, Number) and global_evaluate[0]:\n        rhs, prec = other._as_mpf_op(self._prec)\n        return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)\n    return Number.__add__(self, other)",
    ".sympy.core.numbers.py@@Number._as_mpf_op": "def _as_mpf_op(self, prec):\n    prec = max(prec, self._prec)\n    return (self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Float._as_mpf_op": "def _as_mpf_op(self, prec):\n    return (self._mpf_, max(prec, self._prec))",
    ".sympy.core.evalf.py@@evalf_add": "def evalf_add(v, prec, options):\n    res = pure_complex(v)\n    if res:\n        h, c = res\n        re, _, re_acc, _ = evalf(h, prec, options)\n        im, _, im_acc, _ = evalf(c, prec, options)\n        return (re, im, re_acc, im_acc)\n    oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)\n    i = 0\n    target_prec = prec\n    while 1:\n        options['maxprec'] = min(oldmaxprec, 2 * prec)\n        terms = [evalf(arg, prec + 10, options) for arg in v.args]\n        re, re_acc = add_terms([a[0::2] for a in terms if a[0]], prec, target_prec)\n        im, im_acc = add_terms([a[1::2] for a in terms if a[1]], prec, target_prec)\n        acc = complex_accuracy((re, im, re_acc, im_acc))\n        if acc >= target_prec:\n            if options.get('verbose'):\n                print('ADD: wanted', target_prec, 'accurate bits, got', re_acc, im_acc)\n            break\n        else:\n            if prec - target_prec > options['maxprec']:\n                break\n            prec = prec + max(10 + 2 ** i, target_prec - acc)\n            i += 1\n            if options.get('verbose'):\n                print('ADD: restarting with prec', prec)\n    options['maxprec'] = oldmaxprec\n    if iszero(re, scaled=True):\n        re = scaled_zero(re)\n    if iszero(im, scaled=True):\n        im = scaled_zero(im)\n    return (re, im, re_acc, im_acc)",
    ".sympy.core.evalf.py@@pure_complex": "def pure_complex(v, or_real=False):\n    h, t = v.as_coeff_Add()\n    if not t:\n        if or_real:\n            return (h, t)\n        return\n    c, i = t.as_coeff_Mul()\n    if i is S.ImaginaryUnit:\n        return (h, c)",
    ".sympy.core.add.py@@Add.as_coeff_Add": "def as_coeff_Add(self, rational=False, deps=None):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number and (not rational) or coeff.is_Rational:\n        return (coeff, self._new_rawargs(*args))\n    return (S.Zero, self)",
    ".sympy.core.evalf.py@@add_terms": "def add_terms(terms, prec, target_prec):\n    terms = [t for t in terms if not iszero(t[0])]\n    if not terms:\n        return (None, None)\n    elif len(terms) == 1:\n        return terms[0]\n    special = []\n    from sympy.core.numbers import Float\n    for t in terms:\n        arg = Float._new(t[0], 1)\n        if arg is S.NaN or arg.is_infinite:\n            special.append(arg)\n    if special:\n        from sympy.core.add import Add\n        rv = evalf(Add(*special), prec + 4, {})\n        return (rv[0], rv[2])\n    working_prec = 2 * prec\n    sum_man, sum_exp, absolute_error = (0, 0, MINUS_INF)\n    for x, accuracy in terms:\n        sign, man, exp, bc = x\n        if sign:\n            man = -man\n        absolute_error = max(absolute_error, bc + exp - accuracy)\n        delta = exp - sum_exp\n        if exp >= sum_exp:\n            if delta > working_prec and (not sum_man or delta - bitcount(abs(sum_man)) > working_prec):\n                sum_man = man\n                sum_exp = exp\n            else:\n                sum_man += man << delta\n        else:\n            delta = -delta\n            if delta - bc > working_prec:\n                if not sum_man:\n                    sum_man, sum_exp = (man, exp)\n            else:\n                sum_man = (sum_man << delta) + man\n                sum_exp = exp\n    if not sum_man:\n        return scaled_zero(absolute_error)\n    if sum_man < 0:\n        sum_sign = 1\n        sum_man = -sum_man\n    else:\n        sum_sign = 0\n    sum_bc = bitcount(sum_man)\n    sum_accuracy = sum_exp + sum_bc - absolute_error\n    r = (normalize(sum_sign, sum_man, sum_exp, sum_bc, target_prec, rnd), sum_accuracy)\n    return r",
    ".sympy.core.evalf.py@@iszero": "def iszero(mpf, scaled=False):\n    if not scaled:\n        return not mpf or (not mpf[1] and (not mpf[-1]))\n    return mpf and type(mpf[0]) is list and (mpf[1] == mpf[-1] == 1)",
    ".sympy.core.evalf.py@@bitcount": "def bitcount(n):\n    return mpmath_bitcount(abs(int(n)))",
    ".sympy.core.evalf.py@@complex_accuracy": "def complex_accuracy(result):\n    re, im, re_acc, im_acc = result\n    if not im:\n        if not re:\n            return INF\n        return re_acc\n    if not re:\n        return im_acc\n    re_size = fastlog(re)\n    im_size = fastlog(im)\n    absolute_error = max(re_size - re_acc, im_size - im_acc)\n    relative_error = absolute_error - max(re_size, im_size)\n    return -relative_error",
    ".sympy.core.numbers.py@@Float.__gt__": "def __gt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__lt__(self)\n    rv = self._Frel(other, mlib.mpf_gt)\n    if rv is None:\n        return Expr.__gt__(self, other)\n    return rv",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_algebraic": "def _eval_is_algebraic(self):\n    s = self.func(*self.args)\n    if s.func == self.func:\n        if (self.args[0] - 1).is_zero:\n            return True\n        elif fuzzy_not((self.args[0] - 1).is_zero):\n            if self.args[0].is_algebraic:\n                return False\n    else:\n        return s.is_algebraic",
    ".sympy.core.numbers.py@@Rational._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_rational(self.p, self.q, prec, rnd)",
    ".sympy.core.add.py@@Add._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if self.is_number:\n        return super(Add, self)._eval_is_extended_negative()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s != self and s.is_extended_negative and a.is_extended_nonpositive:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v != self and v.is_extended_negative:\n                    return True\n    neg = nonpos = nonneg = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        isneg = a.is_extended_negative\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((isneg, a.is_extended_nonpositive)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if isneg:\n            neg = True\n            continue\n        elif a.is_extended_nonpositive:\n            nonpos = True\n            continue\n        elif a.is_extended_nonnegative:\n            nonneg = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonneg and (not nonpos) and neg:\n        return True\n    elif not nonneg and neg:\n        return True\n    elif not neg and (not nonpos):\n        return False",
    ".sympy.core.mul.py@@Mul._eval_evalf": "def _eval_evalf(self, prec):\n    c, m = self.as_coeff_Mul()\n    if c is S.NegativeOne:\n        if m.is_Mul:\n            rv = -AssocOp._eval_evalf(m, prec)\n        else:\n            mnew = m._eval_evalf(prec)\n            if mnew is not None:\n                m = mnew\n            rv = -m\n    else:\n        rv = AssocOp._eval_evalf(self, prec)\n    if rv.is_number:\n        return rv.expand()\n    return rv",
    ".sympy.core.expr.py@@Expr.args_cnc": "def args_cnc(self, cset=False, warn=True, split_1=True):\n    if self.is_Mul:\n        args = list(self.args)\n    else:\n        args = [self]\n    for i, mi in enumerate(args):\n        if not mi.is_commutative:\n            c = args[:i]\n            nc = args[i:]\n            break\n    else:\n        c = args\n        nc = []\n    if c and split_1 and (c[0].is_Number and c[0].is_extended_negative and (c[0] is not S.NegativeOne)):\n        c[:1] = [S.NegativeOne, -c[0]]\n    if cset:\n        clen = len(c)\n        c = set(c)\n        if clen and warn and (len(c) != clen):\n            raise ValueError('repeated commutative arguments: %s' % [ci for ci in c if list(self.args).count(ci) > 1])\n    return [c, nc]",
    ".sympy.core.mul.py@@_unevaluated_Mul": "def _unevaluated_Mul(*args):\n    args = list(args)\n    newargs = []\n    ncargs = []\n    co = S.One\n    while args:\n        a = args.pop()\n        if a.is_Mul:\n            c, nc = a.args_cnc()\n            args.extend(c)\n            if nc:\n                ncargs.append(Mul._from_args(nc))\n        elif a.is_Number:\n            co *= a\n        else:\n            newargs.append(a)\n    _mulsort(newargs)\n    if co is not S.One:\n        newargs.insert(0, co)\n    if ncargs:\n        newargs.append(Mul._from_args(ncargs))\n    return Mul._from_args(newargs)",
    ".sympy.core.evalf.py@@EvalfMixin._evalf": "def _evalf(self, prec):\n    r = self._eval_evalf(prec)\n    if r is None:\n        r = self\n    return r",
    ".sympy.core.numbers.py@@Float._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    if self._mpf_ == _mpf_ninf:\n        return True\n    if self._mpf_ == _mpf_inf:\n        return False\n    return self.num < 0",
    ".sympy.core.numbers.py@@Float.num": "def num(self):\n    return mpmath.mpf(self._mpf_)",
    ".sympy.core.numbers.py@@NaN._as_mpf_val": "def _as_mpf_val(self, prec):\n    return _mpf_nan",
    ".sympy.core.numbers.py@@Float._eval_power": "def _eval_power(self, expt):\n    if self == 0:\n        if expt.is_positive:\n            return S.Zero\n        if expt.is_negative:\n            return S.Infinity\n    if isinstance(expt, Number):\n        if isinstance(expt, Integer):\n            prec = self._prec\n            return Float._new(mlib.mpf_pow_int(self._mpf_, expt.p, prec, rnd), prec)\n        elif isinstance(expt, Rational) and expt.p == 1 and expt.q % 2 and self.is_negative:\n            return Pow(S.NegativeOne, expt, evaluate=False) * (-self)._eval_power(expt)\n        expt, prec = expt._as_mpf_op(self._prec)\n        mpfself = self._mpf_\n        try:\n            y = mpf_pow(mpfself, expt, prec, rnd)\n            return Float._new(y, prec)\n        except mlib.ComplexResult:\n            re, im = mlib.mpc_pow((mpfself, fzero), (expt, fzero), prec, rnd)\n            return Float._new(re, prec) + Float._new(im, prec) * S.ImaginaryUnit",
    ".sympy.core.function.py@@Function._eval_evalf": "def _eval_evalf(self, prec):\n\n    def _get_mpmath_func(fname):\n        if isinstance(self, AppliedUndef):\n            return None\n        if not hasattr(mpmath, fname):\n            from sympy.utilities.lambdify import MPMATH_TRANSLATIONS\n            fname = MPMATH_TRANSLATIONS.get(fname, None)\n            if fname is None:\n                return None\n        return getattr(mpmath, fname)\n    func = _get_mpmath_func(self.func.__name__)\n    if func is None:\n        imp = getattr(self, '_imp_', None)\n        if imp is None:\n            return None\n        try:\n            return Float(imp(*[i.evalf(prec) for i in self.args]), prec)\n        except (TypeError, ValueError):\n            return None\n    try:\n        args = [arg._to_mpmath(prec + 5) for arg in self.args]\n\n        def bad(m):\n            from mpmath import mpf, mpc\n            if isinstance(m, mpf):\n                m = m._mpf_\n                return m[1] != 1 and m[-1] == 1\n            elif isinstance(m, mpc):\n                m, n = m._mpc_\n                return m[1] != 1 and m[-1] == 1 and (n[1] != 1) and (n[-1] == 1)\n            else:\n                return False\n        if any((bad(a) for a in args)):\n            raise ValueError\n    except ValueError:\n        return\n    with mpmath.workprec(prec):\n        v = func(*args)\n    return Expr._from_mpmath(v, prec)",
    ".sympy.core.function.py@@Function._get_mpmath_func": "def _get_mpmath_func(fname):\n    if isinstance(self, AppliedUndef):\n        return None\n    if not hasattr(mpmath, fname):\n        from sympy.utilities.lambdify import MPMATH_TRANSLATIONS\n        fname = MPMATH_TRANSLATIONS.get(fname, None)\n        if fname is None:\n            return None\n    return getattr(mpmath, fname)",
    ".sympy.core.evalf.py@@EvalfMixin._to_mpmath": "def _to_mpmath(self, prec, allow_ints=True):\n    errmsg = 'cannot convert to mpmath number'\n    if allow_ints and self.is_Integer:\n        return self.p\n    if hasattr(self, '_as_mpf_val'):\n        return make_mpf(self._as_mpf_val(prec))\n    try:\n        re, im, _, _ = evalf(self, prec, {})\n        if im:\n            if not re:\n                re = fzero\n            return make_mpc((re, im))\n        elif re:\n            return make_mpf(re)\n        else:\n            return make_mpf(fzero)\n    except NotImplementedError:\n        v = self._eval_evalf(prec)\n        if v is None:\n            raise ValueError(errmsg)\n        if v.is_Float:\n            return make_mpf(v._mpf_)\n        re, im = v.as_real_imag()\n        if allow_ints and re.is_Integer:\n            re = from_int(re.p)\n        elif re.is_Float:\n            re = re._mpf_\n        else:\n            raise ValueError(errmsg)\n        if allow_ints and im.is_Integer:\n            im = from_int(im.p)\n        elif im.is_Float:\n            im = im._mpf_\n        else:\n            raise ValueError(errmsg)\n        return make_mpc((re, im))",
    ".sympy.core.function.py@@Function.bad": "def bad(m):\n    from mpmath import mpf, mpc\n    if isinstance(m, mpf):\n        m = m._mpf_\n        return m[1] != 1 and m[-1] == 1\n    elif isinstance(m, mpc):\n        m, n = m._mpc_\n        return m[1] != 1 and m[-1] == 1 and (n[1] != 1) and (n[-1] == 1)\n    else:\n        return False",
    ".sympy.core.expr.py@@Expr._from_mpmath": "def _from_mpmath(x, prec):\n    from sympy import Float\n    if hasattr(x, '_mpf_'):\n        return Float._new(x._mpf_, prec)\n    elif hasattr(x, '_mpc_'):\n        re, im = x._mpc_\n        re = Float._new(re, prec)\n        im = Float._new(im, prec) * S.ImaginaryUnit\n        return re + im\n    else:\n        raise TypeError('expected mpmath number (mpf or mpc)')",
    ".sympy.core.numbers.py@@Float.__mul__": "def __mul__(self, other):\n    if isinstance(other, Number) and global_evaluate[0]:\n        rhs, prec = other._as_mpf_op(self._prec)\n        return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)\n    return Number.__mul__(self, other)",
    ".sympy.core.numbers.py@@Float._eval_is_zero": "def _eval_is_zero(self):\n    return self._mpf_ == fzero",
    ".sympy.core.evalf.py@@evalf_mul": "def evalf_mul(v, prec, options):\n    res = pure_complex(v)\n    if res:\n        _, h = res\n        im, _, im_acc, _ = evalf(h, prec, options)\n        return (None, im, None, im_acc)\n    args = list(v.args)\n    special = []\n    from sympy.core.numbers import Float\n    for arg in args:\n        arg = evalf(arg, prec, options)\n        if arg[0] is None:\n            continue\n        arg = Float._new(arg[0], 1)\n        if arg is S.NaN or arg.is_infinite:\n            special.append(arg)\n    if special:\n        from sympy.core.mul import Mul\n        special = Mul(*special)\n        return evalf(special, prec + 4, {})\n    acc = prec\n    working_prec = prec + len(args) + 5\n    start = man, exp, bc = (MPZ(1), 0, 1)\n    last = len(args)\n    direction = 0\n    args.append(S.One)\n    complex_factors = []\n    for i, arg in enumerate(args):\n        if i != last and pure_complex(arg):\n            args[-1] = (args[-1] * arg).expand()\n            continue\n        elif i == last and arg is S.One:\n            continue\n        re, im, re_acc, im_acc = evalf(arg, working_prec, options)\n        if re and im:\n            complex_factors.append((re, im, re_acc, im_acc))\n            continue\n        elif re:\n            (s, m, e, b), w_acc = (re, re_acc)\n        elif im:\n            (s, m, e, b), w_acc = (im, im_acc)\n            direction += 1\n        else:\n            return (None, None, None, None)\n        direction += 2 * s\n        man *= m\n        exp += e\n        bc += b\n        if bc > 3 * working_prec:\n            man >>= working_prec\n            exp += working_prec\n        acc = min(acc, w_acc)\n    sign = (direction & 2) >> 1\n    if not complex_factors:\n        v = normalize(sign, man, exp, bitcount(man), prec, rnd)\n        if direction & 1:\n            return (None, v, None, acc)\n        else:\n            return (v, None, acc, None)\n    else:\n        if (man, exp, bc) != start:\n            re, im = ((sign, man, exp, bitcount(man)), (0, MPZ(0), 0, 0))\n            i0 = 0\n        else:\n            wre, wim, wre_acc, wim_acc = complex_factors[0]\n            acc = min(acc, complex_accuracy((wre, wim, wre_acc, wim_acc)))\n            re = wre\n            im = wim\n            i0 = 1\n        for wre, wim, wre_acc, wim_acc in complex_factors[i0:]:\n            acc = min(acc, complex_accuracy((wre, wim, wre_acc, wim_acc)))\n            use_prec = working_prec\n            A = mpf_mul(re, wre, use_prec)\n            B = mpf_mul(mpf_neg(im), wim, use_prec)\n            C = mpf_mul(re, wim, use_prec)\n            D = mpf_mul(im, wre, use_prec)\n            re = mpf_add(A, B, use_prec)\n            im = mpf_add(C, D, use_prec)\n        if options.get('verbose'):\n            print('MUL: wanted', prec, 'accurate bits, got', acc)\n        if direction & 1:\n            re, im = (mpf_neg(im), re)\n        return (re, im, acc, acc)",
    ".sympy.core.expr.py@@Expr.as_coeff_Add": "def as_coeff_Add(self, rational=False):\n    return (S.Zero, self)",
    ".sympy.core.evalf.py@@evalf_pow": "def evalf_pow(v, prec, options):\n    target_prec = prec\n    base, exp = v.args\n    if exp.is_Integer:\n        p = exp.p\n        if not p:\n            return (fone, None, prec, None)\n        prec += int(math.log(abs(p), 2))\n        re, im, re_acc, im_acc = evalf(base, prec + 5, options)\n        if re and (not im):\n            return (mpf_pow_int(re, p, target_prec), None, target_prec, None)\n        if im and (not re):\n            z = mpf_pow_int(im, p, target_prec)\n            case = p % 4\n            if case == 0:\n                return (z, None, target_prec, None)\n            if case == 1:\n                return (None, z, None, target_prec)\n            if case == 2:\n                return (mpf_neg(z), None, target_prec, None)\n            if case == 3:\n                return (None, mpf_neg(z), None, target_prec)\n        if not re:\n            return (None, None, None, None)\n        re, im = libmp.mpc_pow_int((re, im), p, prec)\n        return finalize_complex(re, im, target_prec)\n    if exp is S.Half:\n        xre, xim, _, _ = evalf(base, prec + 5, options)\n        if xim:\n            re, im = libmp.mpc_sqrt((xre or fzero, xim), prec)\n            return finalize_complex(re, im, prec)\n        if not xre:\n            return (None, None, None, None)\n        if mpf_lt(xre, fzero):\n            return (None, mpf_sqrt(mpf_neg(xre), prec), None, prec)\n        return (mpf_sqrt(xre, prec), None, prec, None)\n    prec += 10\n    yre, yim, _, _ = evalf(exp, prec, options)\n    if not (yre or yim):\n        return (fone, None, prec, None)\n    ysize = fastlog(yre)\n    if ysize > 5:\n        prec += ysize\n        yre, yim, _, _ = evalf(exp, prec, options)\n    if base is S.Exp1:\n        if yim:\n            re, im = libmp.mpc_exp((yre or fzero, yim), prec)\n            return finalize_complex(re, im, target_prec)\n        return (mpf_exp(yre, target_prec), None, target_prec, None)\n    xre, xim, _, _ = evalf(base, prec + 5, options)\n    if not (xre or xim):\n        return (None, None, None, None)\n    if yim:\n        re, im = libmp.mpc_pow((xre or fzero, xim or fzero), (yre or fzero, yim), target_prec)\n        return finalize_complex(re, im, target_prec)\n    if xim:\n        re, im = libmp.mpc_pow_mpf((xre or fzero, xim), yre, target_prec)\n        return finalize_complex(re, im, target_prec)\n    elif mpf_lt(xre, fzero):\n        re, im = libmp.mpc_pow_mpf((xre, fzero), yre, target_prec)\n        return finalize_complex(re, im, target_prec)\n    else:\n        return (mpf_pow(xre, yre, target_prec), None, target_prec, None)",
    ".sympy.core.evalf.py@@evalf_log": "def evalf_log(expr, prec, options):\n    from sympy import Abs, Add, log\n    if len(expr.args) > 1:\n        expr = expr.doit()\n        return evalf(expr, prec, options)\n    arg = expr.args[0]\n    workprec = prec + 10\n    xre, xim, xacc, _ = evalf(arg, workprec, options)\n    if xim:\n        re = evalf_log(log(Abs(arg, evaluate=False), evaluate=False), prec, options)\n        im = mpf_atan2(xim, xre or fzero, prec)\n        return (re[0], im, re[2], prec)\n    imaginary_term = mpf_cmp(xre, fzero) < 0\n    re = mpf_log(mpf_abs(xre), prec, rnd)\n    size = fastlog(re)\n    if prec - size > workprec and re != fzero:\n        arg = Add(S.NegativeOne, arg, evaluate=False)\n        xre, xim, _, _ = evalf_add(arg, prec, options)\n        prec2 = workprec - fastlog(xre)\n        re = mpf_log(mpf_abs(mpf_add(xre, fone, prec2)), prec, rnd)\n    re_acc = prec\n    if imaginary_term:\n        return (re, mpf_pi(prec), re_acc, prec)\n    else:\n        return (re, None, re_acc, None)",
    ".sympy.core.evalf.py@@fastlog": "def fastlog(x):\n    if not x or x == fzero:\n        return MINUS_INF\n    return x[2] + x[3]",
    ".sympy.core.numbers.py@@Rational.as_coeff_Add": "def as_coeff_Add(self, rational=False):\n    return (self, S.Zero)",
    ".sympy.core.add.py@@Add._eval_is_odd": "def _eval_is_odd(self):\n    l = [f for f in self.args if not f.is_even is True]\n    if not l:\n        return False\n    if l[0].is_odd:\n        return self._new_rawargs(*l[1:]).is_even",
    ".sympy.core.add.py@@Add._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all((x.is_rational is True for x in others)):\n                return True\n            return None\n        if a is None:\n            return\n    return False",
    ".sympy.core.numbers.py@@Rational.__hash__": "def __hash__(self):\n    return super(Rational, self).__hash__()",
    ".sympy.core.numbers.py@@Rational._hashable_content": "def _hashable_content(self):\n    return (self.p, self.q)",
    ".sympy.functions.elementary.integers.py@@floor._eval_number": "def _eval_number(cls, arg):\n    if arg.is_Number:\n        return arg.floor()\n    elif any((isinstance(i, j) for i in (arg, -arg) for j in (floor, ceiling))):\n        return arg\n    if arg.is_NumberSymbol:\n        return arg.approximation_interval(Integer)[0]",
    ".sympy.core.add.py@@Add.__neg__": "def __neg__(self):\n    if not global_distribute[0]:\n        return super(Add, self).__neg__()\n    return Add(*[-i for i in self.args])",
    ".sympy.core.operations.py@@AssocOp.make_args": "def make_args(cls, expr):\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    ".sympy.core.numbers.py@@Number.__add__": "def __add__(self, other):\n    if isinstance(other, Number) and global_evaluate[0]:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            return S.Infinity\n        elif other is S.NegativeInfinity:\n            return S.NegativeInfinity\n    return AtomicExpr.__add__(self, other)",
    ".sympy.core.expr.py@@Expr.__add__": "def __add__(self, other):\n    return Add(self, other)",
    ".sympy.core.evalf.py@@get_integer_part": "def get_integer_part(expr, no, options, return_ints=False):\n    from sympy.functions.elementary.complexes import re, im\n    assumed_size = 30\n    ire, iim, ire_acc, iim_acc = evalf(expr, assumed_size, options)\n    if ire and iim:\n        gap = max(fastlog(ire) - ire_acc, fastlog(iim) - iim_acc)\n    elif ire:\n        gap = fastlog(ire) - ire_acc\n    elif iim:\n        gap = fastlog(iim) - iim_acc\n    elif return_ints:\n        return (0, 0)\n    else:\n        return (None, None, None, None)\n    margin = 10\n    if gap >= -margin:\n        prec = margin + assumed_size + gap\n        ire, iim, ire_acc, iim_acc = evalf(expr, prec, options)\n    else:\n        prec = assumed_size\n\n    def calc_part(re_im, nexpr):\n        from sympy.core.add import Add\n        n, c, p, b = nexpr\n        is_int = p == 0\n        nint = int(to_int(nexpr, rnd))\n        if is_int:\n            ire, iim, ire_acc, iim_acc = evalf(re_im - nint, 10, options)\n            assert not iim\n            size = -fastlog(ire) + 2\n            if size > prec:\n                ire, iim, ire_acc, iim_acc = evalf(re_im, size, options)\n                assert not iim\n                nexpr = ire\n                n, c, p, b = nexpr\n                is_int = p == 0\n                nint = int(to_int(nexpr, rnd))\n        if not is_int:\n            s = options.get('subs', False)\n            if s:\n                doit = True\n                from sympy.core.compatibility import as_int\n                for v in s.values():\n                    try:\n                        as_int(v, strict=False)\n                    except ValueError:\n                        try:\n                            [as_int(i, strict=False) for i in v.as_real_imag()]\n                            continue\n                        except (ValueError, AttributeError):\n                            doit = False\n                            break\n                if doit:\n                    re_im = re_im.subs(s)\n            re_im = Add(re_im, -nint, evaluate=False)\n            x, _, x_acc, _ = evalf(re_im, 10, options)\n            try:\n                check_target(re_im, (x, None, x_acc, None), 3)\n            except PrecisionExhausted:\n                if not re_im.equals(0):\n                    raise PrecisionExhausted\n                x = fzero\n            nint += int(no * (mpf_cmp(x or fzero, fzero) == no))\n        nint = from_int(nint)\n        return (nint, INF)\n    re_, im_, re_acc, im_acc = (None, None, None, None)\n    if ire:\n        re_, re_acc = calc_part(re(expr, evaluate=False), ire)\n    if iim:\n        im_, im_acc = calc_part(im(expr, evaluate=False), iim)\n    if return_ints:\n        return (int(to_int(re_ or fzero)), int(to_int(im_ or fzero)))\n    return (re_, im_, re_acc, im_acc)",
    ".sympy.core.evalf.py@@calc_part": "def calc_part(re_im, nexpr):\n    from sympy.core.add import Add\n    n, c, p, b = nexpr\n    is_int = p == 0\n    nint = int(to_int(nexpr, rnd))\n    if is_int:\n        ire, iim, ire_acc, iim_acc = evalf(re_im - nint, 10, options)\n        assert not iim\n        size = -fastlog(ire) + 2\n        if size > prec:\n            ire, iim, ire_acc, iim_acc = evalf(re_im, size, options)\n            assert not iim\n            nexpr = ire\n            n, c, p, b = nexpr\n            is_int = p == 0\n            nint = int(to_int(nexpr, rnd))\n    if not is_int:\n        s = options.get('subs', False)\n        if s:\n            doit = True\n            from sympy.core.compatibility import as_int\n            for v in s.values():\n                try:\n                    as_int(v, strict=False)\n                except ValueError:\n                    try:\n                        [as_int(i, strict=False) for i in v.as_real_imag()]\n                        continue\n                    except (ValueError, AttributeError):\n                        doit = False\n                        break\n            if doit:\n                re_im = re_im.subs(s)\n        re_im = Add(re_im, -nint, evaluate=False)\n        x, _, x_acc, _ = evalf(re_im, 10, options)\n        try:\n            check_target(re_im, (x, None, x_acc, None), 3)\n        except PrecisionExhausted:\n            if not re_im.equals(0):\n                raise PrecisionExhausted\n            x = fzero\n        nint += int(no * (mpf_cmp(x or fzero, fzero) == no))\n    nint = from_int(nint)\n    return (nint, INF)",
    ".sympy.core.evalf.py@@evalf_re": "def evalf_re(expr, prec, options):\n    return get_complex_part(expr.args[0], 0, prec, options)",
    ".sympy.core.evalf.py@@get_complex_part": "def get_complex_part(expr, no, prec, options):\n    workprec = prec\n    i = 0\n    while 1:\n        res = evalf(expr, workprec, options)\n        value, accuracy = res[no::2]\n        if not value or accuracy >= prec or -value[2] > prec:\n            return (value, None, accuracy, None)\n        workprec += max(30, 2 ** i)\n        i += 1",
    ".sympy.core.evalf.py@@check_target": "def check_target(expr, result, prec):\n    a = complex_accuracy(result)\n    if a < prec:\n        raise PrecisionExhausted('Failed to distinguish the expression: \\n\\n%s\\n\\nfrom zero. Try simplifying the input, using chop=True, or providing a higher maxn for evalf' % expr)",
    ".sympy.core.numbers.py@@Number.__mul__": "def __mul__(self, other):\n    if isinstance(other, Number) and global_evaluate[0]:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.Infinity\n            else:\n                return S.NegativeInfinity\n        elif other is S.NegativeInfinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.NegativeInfinity\n            else:\n                return S.Infinity\n    elif isinstance(other, Tuple):\n        return NotImplemented\n    return AtomicExpr.__mul__(self, other)",
    ".sympy.functions.elementary.exponential.py@@exp.eval": "def eval(cls, arg):\n    from sympy.calculus import AccumBounds\n    from sympy.sets.setexpr import SetExpr\n    from sympy.matrices.matrices import MatrixBase\n    from sympy import logcombine\n    if arg.is_Number:\n        if arg is S.NaN:\n            return S.NaN\n        elif arg.is_zero:\n            return S.One\n        elif arg is S.One:\n            return S.Exp1\n        elif arg is S.Infinity:\n            return S.Infinity\n        elif arg is S.NegativeInfinity:\n            return S.Zero\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif isinstance(arg, log):\n        return arg.args[0]\n    elif isinstance(arg, AccumBounds):\n        return AccumBounds(exp(arg.min), exp(arg.max))\n    elif isinstance(arg, SetExpr):\n        return arg._eval_func(cls)\n    elif arg.is_Mul:\n        coeff = arg.as_coefficient(S.Pi * S.ImaginaryUnit)\n        if coeff:\n            if (2 * coeff).is_integer:\n                if coeff.is_even:\n                    return S.One\n                elif coeff.is_odd:\n                    return S.NegativeOne\n                elif (coeff + S.Half).is_even:\n                    return -S.ImaginaryUnit\n                elif (coeff + S.Half).is_odd:\n                    return S.ImaginaryUnit\n            elif coeff.is_Rational:\n                ncoeff = coeff % 2\n                if ncoeff > 1:\n                    ncoeff -= 2\n                if ncoeff != coeff:\n                    return cls(ncoeff * S.Pi * S.ImaginaryUnit)\n        coeff, terms = arg.as_coeff_Mul()\n        if coeff in [S.NegativeInfinity, S.Infinity]:\n            return None\n        coeffs, log_term = ([coeff], None)\n        for term in Mul.make_args(terms):\n            term_ = logcombine(term)\n            if isinstance(term_, log):\n                if log_term is None:\n                    log_term = term_.args[0]\n                else:\n                    return None\n            elif term.is_comparable:\n                coeffs.append(term)\n            else:\n                return None\n        return log_term ** Mul(*coeffs) if log_term else None\n    elif arg.is_Add:\n        out = []\n        add = []\n        argchanged = False\n        for a in arg.args:\n            if a is S.One:\n                add.append(a)\n                continue\n            newa = cls(a)\n            if isinstance(newa, cls):\n                if newa.args[0] != a:\n                    add.append(newa.args[0])\n                    argchanged = True\n                else:\n                    add.append(a)\n            else:\n                out.append(newa)\n        if out or argchanged:\n            return Mul(*out) * cls(Add(*add), evaluate=False)\n    elif isinstance(arg, MatrixBase):\n        return arg.exp()\n    if arg.is_zero:\n        return S.One",
    ".sympy.core.mul.py@@Mul.as_two_terms": "def as_two_terms(self):\n    args = self.args\n    if len(args) == 1:\n        return (S.One, self)\n    elif len(args) == 2:\n        return args\n    else:\n        return (args[0], self._new_rawargs(*args[1:]))",
    ".sympy.core.operations.py@@AssocOp._has_matcher": "def _has_matcher(self):\n\n    def _ncsplit(expr):\n        cpart, ncpart = sift(expr.args, lambda arg: arg.is_commutative is True, binary=True)\n        return (set(cpart), ncpart)\n    c, nc = _ncsplit(self)\n    cls = self.__class__\n\n    def is_in(expr):\n        if expr == self:\n            return True\n        elif not isinstance(expr, Basic):\n            return False\n        elif isinstance(expr, cls):\n            _c, _nc = _ncsplit(expr)\n            if c & _c == c:\n                if not nc:\n                    return True\n                elif len(nc) <= len(_nc):\n                    for i in range(len(_nc) - len(nc) + 1):\n                        if _nc[i:i + len(nc)] == nc:\n                            return True\n        return False\n    return is_in",
    ".sympy.core.operations.py@@AssocOp._ncsplit": "def _ncsplit(expr):\n    cpart, ncpart = sift(expr.args, lambda arg: arg.is_commutative is True, binary=True)\n    return (set(cpart), ncpart)",
    ".sympy.core.operations.py@@AssocOp.is_in": "def is_in(expr):\n    if expr == self:\n        return True\n    elif not isinstance(expr, Basic):\n        return False\n    elif isinstance(expr, cls):\n        _c, _nc = _ncsplit(expr)\n        if c & _c == c:\n            if not nc:\n                return True\n            elif len(nc) <= len(_nc):\n                for i in range(len(_nc) - len(nc) + 1):\n                    if _nc[i:i + len(nc)] == nc:\n                        return True\n    return False",
    ".sympy.core.numbers.py@@Integer.__rmul__": "def __rmul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(other * self.p)\n        elif isinstance(other, Rational):\n            return Rational(other.p * self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    ".sympy.functions.elementary.complexes.py@@sign.eval": "def eval(cls, arg):\n    if arg.is_Mul:\n        c, args = arg.as_coeff_mul()\n        unk = []\n        s = sign(c)\n        for a in args:\n            if a.is_extended_negative:\n                s = -s\n            elif a.is_extended_positive:\n                pass\n            else:\n                ai = im(a)\n                if a.is_imaginary and ai.is_comparable:\n                    s *= S.ImaginaryUnit\n                    if ai.is_extended_negative:\n                        s = -s\n                else:\n                    unk.append(a)\n        if c is S.One and len(unk) == len(args):\n            return None\n        return s * cls(arg._new_rawargs(*unk))\n    if arg is S.NaN:\n        return S.NaN\n    if arg.is_zero:\n        return S.Zero\n    if arg.is_extended_positive:\n        return S.One\n    if arg.is_extended_negative:\n        return S.NegativeOne\n    if arg.is_Function:\n        if isinstance(arg, sign):\n            return arg\n    if arg.is_imaginary:\n        if arg.is_Pow and arg.exp is S.Half:\n            return S.ImaginaryUnit\n        arg2 = -S.ImaginaryUnit * arg\n        if arg2.is_extended_positive:\n            return S.ImaginaryUnit\n        if arg2.is_extended_negative:\n            return -S.ImaginaryUnit",
    ".sympy.core.mul.py@@Mul._eval_is_polar": "def _eval_is_polar(self):\n    has_polar = any((arg.is_polar for arg in self.args))\n    return has_polar and all((arg.is_polar or arg.is_positive for arg in self.args))",
    ".sympy.core.numbers.py@@Integer.__neg__": "def __neg__(self):\n    return Integer(-self.p)",
    ".sympy.core.add.py@@Add._eval_is_imaginary": "def _eval_is_imaginary(self):\n    nz = []\n    im_I = []\n    for a in self.args:\n        if a.is_extended_real:\n            if a.is_zero:\n                pass\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im_I.append(a * S.ImaginaryUnit)\n        elif (S.ImaginaryUnit * a).is_extended_real:\n            im_I.append(a * S.ImaginaryUnit)\n        else:\n            return\n    b = self.func(*nz)\n    if b.is_zero:\n        return fuzzy_not(self.func(*im_I).is_zero)\n    elif b.is_zero is False:\n        return False",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_extended_real": "def _eval_is_extended_real(self):\n    return self.args[0].is_extended_positive",
    ".sympy.core.mul.py@@_keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = (coeff, factors)\n        else:\n            return coeff * factors\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and (not sign):\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and (coeff.q != 1):\n            q = S(coeff.q)\n            for i in factors.args:\n                c, t = i.as_coeff_Mul()\n                r = c / q\n                if r == int(r):\n                    return coeff * factors\n        return Mul(coeff, factors, evaluate=False)\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        return coeff * factors",
    ".sympy.core.mul.py@@Mul.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy import Abs, expand_mul, im, re\n    other = []\n    coeffr = []\n    coeffi = []\n    addterms = S.One\n    for a in self.args:\n        r, i = a.as_real_imag()\n        if i.is_zero:\n            coeffr.append(r)\n        elif r.is_zero:\n            coeffi.append(i * S.ImaginaryUnit)\n        elif a.is_commutative:\n            for i, x in enumerate(other):\n                if x == a.conjugate():\n                    coeffr.append(Abs(x) ** 2)\n                    del other[i]\n                    break\n            else:\n                if a.is_Add:\n                    addterms *= a\n                else:\n                    other.append(a)\n        else:\n            other.append(a)\n    m = self.func(*other)\n    if hints.get('ignore') == m:\n        return\n    if len(coeffi) % 2:\n        imco = im(coeffi.pop(0))\n    else:\n        imco = S.Zero\n    reco = self.func(*coeffr + coeffi)\n    r, i = (reco * re(m), reco * im(m))\n    if addterms == 1:\n        if m == 1:\n            if imco.is_zero:\n                return (reco, S.Zero)\n            else:\n                return (S.Zero, reco * imco)\n        if imco is S.Zero:\n            return (r, i)\n        return (-imco * i, imco * r)\n    addre, addim = expand_mul(addterms, deep=False).as_real_imag()\n    if imco is S.Zero:\n        return (r * addre - i * addim, i * addre + r * addim)\n    else:\n        r, i = (-imco * i, imco * r)\n        return (r * addre - i * addim, r * addim + i * addre)",
    ".sympy.core.add.py@@Add.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    sargs = self.args\n    re_part, im_part = ([], [])\n    for term in sargs:\n        re, im = term.as_real_imag(deep=deep)\n        re_part.append(re)\n        im_part.append(im)\n    return (self.func(*re_part), self.func(*im_part))",
    ".sympy.functions.elementary.exponential.py@@log.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy import Abs, arg\n    sarg = self.args[0]\n    if deep:\n        sarg = self.args[0].expand(deep, **hints)\n    abs = Abs(sarg)\n    if abs == sarg:\n        return (self, S.Zero)\n    arg = arg(sarg)\n    if hints.get('log', False):\n        hints['complex'] = False\n        return (log(abs).expand(deep, **hints), arg)\n    else:\n        return (log(abs), arg)",
    ".sympy.functions.elementary.exponential.py@@log._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    return (self.args[0] - 1).is_extended_positive",
    ".sympy.core.add.py@@Add._eval_is_infinite": "def _eval_is_infinite(self):\n    sawinf = False\n    for a in self.args:\n        ainf = a.is_infinite\n        if ainf is None:\n            return None\n        elif ainf is True:\n            if sawinf is True:\n                return None\n            sawinf = True\n    return sawinf",
    ".sympy.core.add.py@@Add._eval_is_extended_nonpositive": "def _eval_is_extended_nonpositive(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_extended_nonpositive:\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s != self and s.is_extended_nonpositive:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v != self and v.is_extended_nonpositive:\n                        return True",
    ".sympy.core.numbers.py@@Half.__abs__": "def __abs__():\n    return S.Half"
}