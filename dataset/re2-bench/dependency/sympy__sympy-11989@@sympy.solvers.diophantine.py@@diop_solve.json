{
    ".sympy.solvers.diophantine.py@@classify_diop": "def classify_diop(eq, _dict=True):\n    try:\n        var = list(eq.free_symbols)\n        assert var\n    except (AttributeError, AssertionError):\n        raise ValueError('equation should have 1 or more free symbols')\n    var.sort(key=default_sort_key)\n    eq = eq.expand(force=True)\n    coeff = eq.as_coefficients_dict()\n    if not all((_is_int(c) for c in coeff.values())):\n        raise TypeError('Coefficients should be Integers')\n    diop_type = None\n    total_degree = Poly(eq).total_degree()\n    homogeneous = 1 not in coeff\n    if total_degree == 1:\n        diop_type = 'linear'\n    elif len(var) == 1:\n        diop_type = 'univariate'\n    elif total_degree == 2 and len(var) == 2:\n        diop_type = 'binary_quadratic'\n    elif total_degree == 2 and len(var) == 3 and homogeneous:\n        if set(coeff) & set(var):\n            diop_type = 'inhomogeneous_ternary_quadratic'\n        else:\n            nonzero = [k for k in coeff if coeff[k]]\n            if len(nonzero) == 3 and all((i ** 2 in nonzero for i in var)):\n                diop_type = 'homogeneous_ternary_quadratic_normal'\n            else:\n                diop_type = 'homogeneous_ternary_quadratic'\n    elif total_degree == 2 and len(var) >= 3:\n        if set(coeff) & set(var):\n            diop_type = 'inhomogeneous_general_quadratic'\n        elif any((k.is_Mul for k in coeff)):\n            if not homogeneous:\n                diop_type = 'inhomogeneous_general_quadratic'\n            else:\n                diop_type = 'homogeneous_general_quadratic'\n        elif all((coeff[k] == 1 for k in coeff if k != 1)):\n            diop_type = 'general_sum_of_squares'\n        elif all((is_square(abs(coeff[k])) for k in coeff)):\n            if abs(sum((sign(coeff[k]) for k in coeff))) == len(var) - 2:\n                diop_type = 'general_pythagorean'\n    elif total_degree == 3 and len(var) == 2:\n        diop_type = 'cubic_thue'\n    elif total_degree > 3 and total_degree % 2 == 0 and all((k.is_Pow and k.exp == total_degree for k in coeff if k != 1)):\n        if all((coeff[k] == 1 for k in coeff if k != 1)):\n            diop_type = 'general_sum_of_even_powers'\n    if diop_type is not None:\n        return (var, dict(coeff) if _dict else coeff, diop_type)\n    raise NotImplementedError(filldedent('\\n        This equation is not yet recognized or else has not been\\n        simplified sufficiently to put it in a form recognized by\\n        diop_classify().'))",
    ".sympy.core.basic.py@@Basic.free_symbols": "def free_symbols(self):\n    return set().union(*[a.free_symbols for a in self.args])",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.symbol.py@@Symbol.free_symbols": "def free_symbols(self):\n    return {self}",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.compatibility.py@@default_sort_key": "def default_sort_key(item, order=None):\n    from .singleton import S\n    from .basic import Basic\n    from .sympify import sympify, SympifyError\n    from .compatibility import iterable\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n    if iterable(item, exclude=string_types):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            args = list(item)\n            unordered = False\n        args = [default_sort_key(arg, order=order) for arg in args]\n        if unordered:\n            args = sorted(args)\n        cls_index, args = (10, (len(args), tuple(args)))\n    else:\n        if not isinstance(item, string_types):\n            try:\n                item = sympify(item)\n            except SympifyError:\n                pass\n            else:\n                if isinstance(item, Basic):\n                    return default_sort_key(item)\n        cls_index, args = (0, (1, (str(item),)))\n    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)",
    ".sympy.core.symbol.py@@Symbol.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One)",
    ".sympy.core.basic.py@@Atom.class_key": "def class_key(cls):\n    return (2, 0, cls.__name__)",
    ".sympy.core.basic.py@@Basic.__str__": "def __str__(self):\n    from sympy.printing import sstr\n    return sstr(self, order=None)",
    ".sympy.printing.str.py@@sstr": "def sstr(expr, **settings):\n    p = StrPrinter(settings)\n    s = p.doprint(expr)\n    return s",
    ".sympy.printing.printer.py@@Printer.__init__": "def __init__(self, settings=None):\n    self._str = str\n    self._settings = self._default_settings.copy()\n    for key, val in self._global_settings.items():\n        if key in self._default_settings:\n            self._settings[key] = val\n    if settings is not None:\n        self._settings.update(settings)\n        if len(self._settings) > len(self._default_settings):\n            for key in self._settings:\n                if key not in self._default_settings:\n                    raise TypeError(\"Unknown setting '%s'.\" % key)\n    self._print_level = 0",
    ".sympy.printing.printer.py@@Printer.doprint": "def doprint(self, expr):\n    return self._str(self._print(expr))",
    ".sympy.printing.printer.py@@Printer._print": "def _print(self, expr, *args, **kwargs):\n    self._print_level += 1\n    try:\n        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):\n            return getattr(expr, self.printmethod)(self, *args, **kwargs)\n        for cls in type(expr).__mro__:\n            printmethod = '_print_' + cls.__name__\n            if hasattr(self, printmethod):\n                return getattr(self, printmethod)(expr, *args, **kwargs)\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1",
    ".sympy.printing.str.py@@StrPrinter._print_Symbol": "def _print_Symbol(self, expr):\n    return expr.name",
    ".sympy.core.numbers.py@@Number.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (0, ()), (), self)",
    ".sympy.core.numbers.py@@Number.class_key": "def class_key(cls):\n    return (1, 0, 'Number')",
    ".sympy.core.expr.py@@Expr.expand": "def expand(self, deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints):\n    from sympy.simplify.radsimp import fraction\n    hints.update(power_base=power_base, power_exp=power_exp, mul=mul, log=log, multinomial=multinomial, basic=basic)\n    expr = self\n    if hints.pop('frac', False):\n        n, d = [a.expand(deep=deep, modulus=modulus, **hints) for a in fraction(self)]\n        return n / d\n    elif hints.pop('denom', False):\n        n, d = fraction(self)\n        return n / d.expand(deep=deep, modulus=modulus, **hints)\n    elif hints.pop('numer', False):\n        n, d = fraction(self)\n        return n.expand(deep=deep, modulus=modulus, **hints) / d\n\n    def _expand_hint_key(hint):\n        if hint == 'mul':\n            return 'mulz'\n        return hint\n    for hint in sorted(hints.keys(), key=_expand_hint_key):\n        use_hint = hints[hint]\n        if use_hint:\n            hint = '_eval_expand_' + hint\n            expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)\n    while True:\n        was = expr\n        if hints.get('multinomial', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_multinomial', deep=deep, **hints)\n        if hints.get('mul', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_mul', deep=deep, **hints)\n        if hints.get('log', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_log', deep=deep, **hints)\n        if expr == was:\n            break\n    if modulus is not None:\n        modulus = sympify(modulus)\n        if not modulus.is_Integer or modulus <= 0:\n            raise ValueError('modulus must be a positive integer, got %s' % modulus)\n        terms = []\n        for term in Add.make_args(expr):\n            coeff, tail = term.as_coeff_Mul(rational=True)\n            coeff %= modulus\n            if coeff:\n                terms.append(coeff * tail)\n        expr = Add(*terms)\n    return expr",
    ".sympy.core.expr.py@@Expr._expand_hint_key": "def _expand_hint_key(hint):\n    if hint == 'mul':\n        return 'mulz'\n    return hint",
    ".sympy.core.expr.py@@Expr._expand_hint": "def _expand_hint(expr, hint, deep=True, **hints):\n    hit = False\n    if deep and getattr(expr, 'args', ()) and (not expr.is_Atom):\n        sargs = []\n        for arg in expr.args:\n            arg, arghit = Expr._expand_hint(arg, hint, **hints)\n            hit |= arghit\n            sargs.append(arg)\n        if hit:\n            expr = expr.func(*sargs)\n    if hasattr(expr, hint):\n        newexpr = getattr(expr, hint)(**hints)\n        if newexpr != expr:\n            return (newexpr, True)\n    return (expr, hit)",
    ".sympy.core.power.py@@Pow._eval_expand_multinomial": "def _eval_expand_multinomial(self, **hints):\n    base, exp = self.args\n    result = self\n    if exp.is_Rational and exp.p > 0 and base.is_Add:\n        if not exp.is_Integer:\n            n = Integer(exp.p // exp.q)\n            if not n:\n                return result\n            else:\n                radical, result = (self.func(base, exp - n), [])\n                expanded_base_n = self.func(base, n)\n                if expanded_base_n.is_Pow:\n                    expanded_base_n = expanded_base_n._eval_expand_multinomial()\n                for term in Add.make_args(expanded_base_n):\n                    result.append(term * radical)\n                return Add(*result)\n        n = int(exp)\n        if base.is_commutative:\n            order_terms, other_terms = ([], [])\n            for b in base.args:\n                if b.is_Order:\n                    order_terms.append(b)\n                else:\n                    other_terms.append(b)\n            if order_terms:\n                f = Add(*other_terms)\n                o = Add(*order_terms)\n                if n == 2:\n                    return expand_multinomial(f ** n, deep=False) + n * f * o\n                else:\n                    g = expand_multinomial(f ** (n - 1), deep=False)\n                    return expand_mul(f * g, deep=False) + n * g * o\n            if base.is_number:\n                a, b = base.as_real_imag()\n                if a.is_Rational and b.is_Rational:\n                    if not a.is_Integer:\n                        if not b.is_Integer:\n                            k = self.func(a.q * b.q, n)\n                            a, b = (a.p * b.q, a.q * b.p)\n                        else:\n                            k = self.func(a.q, n)\n                            a, b = (a.p, a.q * b)\n                    elif not b.is_Integer:\n                        k = self.func(b.q, n)\n                        a, b = (a * b.q, b.p)\n                    else:\n                        k = 1\n                    a, b, c, d = (int(a), int(b), 1, 0)\n                    while n:\n                        if n & 1:\n                            c, d = (a * c - b * d, b * c + a * d)\n                            n -= 1\n                        a, b = (a * a - b * b, 2 * a * b)\n                        n //= 2\n                    I = S.ImaginaryUnit\n                    if k == 1:\n                        return c + I * d\n                    else:\n                        return Integer(c) / k + I * d / k\n            p = other_terms\n            from sympy import multinomial_coefficients\n            from sympy.polys.polyutils import basic_from_dict\n            expansion_dict = multinomial_coefficients(len(p), n)\n            return basic_from_dict(expansion_dict, *p)\n        elif n == 2:\n            return Add(*[f * g for f in base.args for g in base.args])\n        else:\n            multi = (base ** (n - 1))._eval_expand_multinomial()\n            if multi.is_Add:\n                return Add(*[f * g for f in base.args for g in multi.args])\n            else:\n                return Add(*[f * multi for f in base.args])\n    elif exp.is_Rational and exp.p < 0 and base.is_Add and (abs(exp.p) > exp.q):\n        return 1 / self.func(base, -exp)._eval_expand_multinomial()\n    elif exp.is_Add and base.is_Number:\n        coeff, tail = (S.One, S.Zero)\n        for term in exp.args:\n            if term.is_Number:\n                coeff *= self.func(base, term)\n            else:\n                tail += term\n        return coeff * self.func(base, tail)\n    else:\n        return result",
    ".sympy.core.numbers.py@@Integer.__int__": "def __int__(self):\n    return self.p",
    ".sympy.core.expr.py@@Expr.is_number": "def is_number(self):\n    return all((obj.is_number for obj in self.args))",
    ".sympy.ntheory.multinomial.py@@multinomial_coefficients": "def multinomial_coefficients(m, n):\n    if not m:\n        if n:\n            return {}\n        return {(): 1}\n    if m == 2:\n        return binomial_coefficients(n)\n    if m >= 2 * n and n > 1:\n        return dict(multinomial_coefficients_iterator(m, n))\n    t = [n] + [0] * (m - 1)\n    r = {tuple(t): 1}\n    if n:\n        j = 0\n    else:\n        j = m\n    while j < m - 1:\n        tj = t[j]\n        if j:\n            t[j] = 0\n            t[0] = tj\n        if tj > 1:\n            t[j + 1] += 1\n            j = 0\n            start = 1\n            v = 0\n        else:\n            j += 1\n            start = j + 1\n            v = r[tuple(t)]\n            t[j] += 1\n        for k in range(start, m):\n            if t[k]:\n                t[k] -= 1\n                v += r[tuple(t)]\n                t[k] += 1\n        t[0] -= 1\n        r[tuple(t)] = v * tj // (n - t[0])\n    return r",
    ".sympy.ntheory.multinomial.py@@binomial_coefficients": "def binomial_coefficients(n):\n    d = {(0, n): 1, (n, 0): 1}\n    a = 1\n    for k in range(1, n // 2 + 1):\n        a = a * (n - k + 1) // k\n        d[k, n - k] = d[n - k, k] = a\n    return d",
    ".sympy.polys.polyutils.py@@expr_from_dict": "def expr_from_dict(rep, *gens):\n    result = []\n    for monom, coeff in rep.items():\n        term = [coeff]\n        for g, m in zip(gens, monom):\n            if m:\n                term.append(Pow(g, m))\n        result.append(Mul(*term))\n    return Add(*result)",
    ".sympy.core.power.py@@Pow.__new__": "def __new__(cls, b, e, evaluate=None):\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    from sympy.functions.elementary.exponential import exp_polar\n    b = _sympify(b)\n    e = _sympify(e)\n    if evaluate:\n        if e is S.Zero:\n            return S.One\n        elif e is S.One:\n            return b\n        elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and e.is_integer and _coeff_isneg(b):\n            if e.is_even:\n                b = -b\n            elif e.is_odd:\n                return -Pow(-b, e)\n        if S.NaN in (b, e):\n            return S.NaN\n        elif b is S.One:\n            if abs(e).is_infinite:\n                return S.NaN\n            return S.One\n        else:\n            if not e.is_Atom and b is not S.Exp1 and (b.func is not exp_polar):\n                from sympy import numer, denom, log, sign, im, factor_terms\n                c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n                den = denom(ex)\n                if den.func is log and den.args[0] == b:\n                    return S.Exp1 ** (c * numer(ex))\n                elif den.is_Add:\n                    s = sign(im(b))\n                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):\n                        return S.Exp1 ** (c * numer(ex))\n            obj = b._eval_power(e)\n            if obj is not None:\n                return obj\n    obj = Expr.__new__(cls, b, e)\n    obj.is_commutative = b.is_commutative and e.is_commutative\n    return obj",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    if evaluate is None:\n        if global_evaluate[0] is False:\n            evaluate = global_evaluate[0]\n        else:\n            evaluate = True\n    try:\n        if a in sympy_classes:\n            return a\n    except TypeError:\n        pass\n    try:\n        cls = a.__class__\n    except AttributeError:\n        cls = type(a)\n    if cls in sympy_classes:\n        return a\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    try:\n        return converter[cls](a)\n    except KeyError:\n        for superclass in getmro(cls):\n            try:\n                return converter[superclass](a)\n            except KeyError:\n                continue\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    try:\n        return a._sympy_()\n    except AttributeError:\n        pass\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                return sympify(coerce(a))\n            except (TypeError, ValueError, AttributeError, SympifyError):\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, string_types):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Integer can only work with integer expressions.')\n    try:\n        return _intcache[ival]\n    except KeyError:\n        obj = Expr.__new__(cls)\n        obj.p = ival\n        _intcache[ival] = obj\n        return obj",
    ".sympy.core.function.py@@_coeff_isneg": "def _coeff_isneg(a):\n    if a.is_Mul:\n        a = a.args[0]\n    return a.is_Number and a.is_negative",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    from sympy import Pow\n    if self is other:\n        return True\n    from .function import AppliedUndef, UndefinedFunction as UndefFunc\n    if isinstance(self, UndefFunc) and isinstance(other, UndefFunc):\n        if self.class_key() == other.class_key():\n            return True\n        else:\n            return False\n    if type(self) is not type(other):\n        if isinstance(self, Pow) and self.exp == 1:\n            return self.base == other\n        if isinstance(other, Pow) and other.exp == 1:\n            return self == other.base\n        try:\n            other = _sympify(other)\n        except SympifyError:\n            return False\n        if isinstance(self, AppliedUndef) and isinstance(other, AppliedUndef):\n            if self.class_key() != other.class_key():\n                return False\n        elif type(self) is not type(other):\n            return False\n    return self._hashable_content() == other._hashable_content()",
    ".sympy.core.numbers.py@@NaN.__hash__": "def __hash__(self):\n    return super(NaN, self).__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super(Number, self).__hash__()",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, integer_types):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return False\n    if isinstance(other, NumberSymbol):\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if isinstance(other, Number):\n        if isinstance(other, Rational):\n            return self.p == other.p and self.q == other.q\n        if isinstance(other, Float):\n            return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)\n    return False",
    ".sympy.core.expr.py@@Expr._eval_power": "def _eval_power(self, other):\n    return None",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, **options):\n    from sympy import Order\n    args = list(map(_sympify, args))\n    args = [a for a in args if a is not cls.identity]\n    if not options.pop('evaluate', global_evaluate[0]):\n        return cls._from_args(args)\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    if order_symbols is not None:\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.core.basic.py@@Basic._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.assumptions.py@@StdFactKB.copy": "def copy(self):\n    return self.__class__(self)",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.assumptions.py@@StdFactKB.generator": "def generator(self):\n    return self._generator.copy()",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.assumptions.py@@_ask": "def _ask(fact, obj):\n    assumptions = obj._assumptions\n    handler_map = obj._prop_handler\n    assumptions._tell(fact, None)\n    try:\n        evaluate = handler_map[fact]\n    except KeyError:\n        pass\n    else:\n        a = evaluate(obj)\n        if a is not None:\n            assumptions.deduce_all_facts(((fact, a),))\n            return a\n    prereq = list(_assume_rules.prereq[fact])\n    shuffle(prereq)\n    for pk in prereq:\n        if pk in assumptions:\n            continue\n        if pk in handler_map:\n            _ask(pk, obj)\n            ret_val = assumptions.get(fact)\n            if ret_val is not None:\n                return ret_val\n    return None",
    ".sympy.core.expr.py@@Expr._eval_is_negative": "def _eval_is_negative(self):\n    from sympy.polys.numberfields import minimal_polynomial\n    from sympy.polys.polyerrors import NotAlgebraic\n    if self.is_number:\n        if self.is_real is False:\n            return False\n        try:\n            n2 = self._eval_evalf(2)\n            if n2 is None:\n                raise AttributeError\n            if n2._prec == 1:\n                raise AttributeError\n            if n2 == S.NaN:\n                raise AttributeError\n        except (AttributeError, ValueError):\n            return None\n        n, i = self.evalf(2).as_real_imag()\n        if not i.is_Number or not n.is_Number:\n            return False\n        if n._prec != 1 and i._prec != 1:\n            return bool(not i and n < 0)\n        elif n._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):\n            try:\n                if minimal_polynomial(self).is_Symbol:\n                    return False\n            except (NotAlgebraic, NotImplementedError):\n                pass",
    ".sympy.core.numbers.py@@Number._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Integer._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_int(self.p, prec)",
    ".sympy.core.numbers.py@@Float._new": "def _new(cls, _mpf_, _prec):\n    if _mpf_ == _mpf_zero:\n        return S.Zero\n    elif _mpf_ == _mpf_nan:\n        return S.NaN\n    obj = Expr.__new__(cls)\n    obj._mpf_ = mpf_norm(_mpf_, _prec)\n    obj._prec = _prec\n    return obj",
    ".sympy.core.numbers.py@@mpf_norm": "def mpf_norm(mpf, prec):\n    sign, man, expt, bc = mpf\n    if not man:\n        if not bc:\n            return _mpf_zero\n        else:\n            return mpf\n    from mpmath.libmp.backend import MPZ\n    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n    return rv",
    ".sympy.core.numbers.py@@Float.__eq__": "def __eq__(self, other):\n    if isinstance(other, float):\n        o = Float(other)\n        try:\n            ompf = o._as_mpf_val(self._prec)\n        except ValueError:\n            return False\n        return bool(mlib.mpf_eq(self._mpf_, ompf))\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return False\n    if isinstance(other, NumberSymbol):\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if isinstance(other, Float):\n        return bool(mlib.mpf_eq(self._mpf_, other._mpf_))\n    if isinstance(other, Number):\n        ompf = other._as_mpf_val(self._prec)\n        return bool(mlib.mpf_eq(self._mpf_, ompf))\n    return False",
    ".sympy.core.numbers.py@@NaN._as_mpf_val": "def _as_mpf_val(self, prec):\n    return _mpf_nan",
    ".sympy.core.evalf.py@@EvalfMixin.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    from sympy import Float, Number\n    n = n if n is not None else 15\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n    if n == 1 and isinstance(self, Number):\n        from sympy.core.expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        try:\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            return v\n    re, im, re_acc, im_acc = result\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im * S.ImaginaryUnit\n    else:\n        return re",
    ".sympy.core.evalf.py@@evalf": "def evalf(x, prec, options):\n    from sympy import re as re_, im as im_\n    try:\n        rf = evalf_table[x.func]\n        r = rf(x, prec, options)\n    except KeyError:\n        try:\n            if 'subs' in options:\n                x = x.subs(evalf_subs(prec, options['subs']))\n            xe = x._eval_evalf(prec)\n            re, im = xe.as_real_imag()\n            if re.has(re_) or im.has(im_):\n                raise NotImplementedError\n            if re == 0:\n                re = None\n                reprec = None\n            elif re.is_number:\n                re = re._to_mpmath(prec, allow_ints=False)._mpf_\n                reprec = prec\n            if im == 0:\n                im = None\n                imprec = None\n            elif im.is_number:\n                im = im._to_mpmath(prec, allow_ints=False)._mpf_\n                imprec = prec\n            r = (re, im, reprec, imprec)\n        except AttributeError:\n            raise NotImplementedError\n    if options.get('verbose'):\n        print('### input', x)\n        print('### output', to_str(r[0] or fzero, 50))\n        print('### raw', r)\n        print()\n    chop = options.get('chop', False)\n    if chop:\n        if chop is True:\n            chop_prec = prec\n        else:\n            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))\n            if chop_prec == 3:\n                chop_prec -= 1\n        r = chop_parts(r, chop_prec)\n    if options.get('strict'):\n        check_target(x, r, prec)\n    return r",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.core.expr.py@@Expr.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy import im, re\n    if hints.get('ignore') == self:\n        return None\n    else:\n        return (re(self), im(self))",
    ".sympy.core.sympify.py@@SympifyError.__init__": "def __init__(self, expr, base_exc=None):\n    self.expr = expr\n    self.base_exc = base_exc",
    ".sympy.core.function.py@@Function.__new__": "def __new__(cls, *args, **options):\n    if cls is Function:\n        return UndefinedFunction(*args, **options)\n    n = len(args)\n    if n not in cls.nargs:\n        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'\n        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})\n    evaluate = options.get('evaluate', global_evaluate[0])\n    result = super(Function, cls).__new__(cls, *args, **options)\n    if not evaluate or not isinstance(result, cls):\n        return result\n    pr = max((cls._should_evalf(a) for a in result.args))\n    pr2 = min((cls._should_evalf(a) for a in result.args))\n    if pr2 > 0:\n        return result.evalf(mlib.libmpf.prec_to_dps(pr))\n    return result",
    ".sympy.core.function.py@@FunctionClass.nargs": "def nargs(self):\n    from sympy.sets.sets import FiniteSet\n    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0",
    ".sympy.sets.sets.py@@FiniteSet.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_evaluate[0])\n    if evaluate:\n        args = list(map(sympify, args))\n        if len(args) == 0:\n            return EmptySet()\n    else:\n        args = list(map(sympify, args))\n    args = list(ordered(frozenset(tuple(args)), Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._elements = frozenset(args)\n    return obj",
    ".sympy.core.compatibility.py@@ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    d = defaultdict(list)\n    if keys:\n        if not isinstance(keys, (list, tuple)):\n            keys = [keys]\n        keys = list(keys)\n        f = keys.pop(0)\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n    for k in sorted(d.keys()):\n        if len(d[k]) > 1:\n            if keys:\n                d[k] = ordered(d[k], keys, default, warn)\n            elif default:\n                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)\n            elif warn:\n                from sympy.utilities.iterables import uniq\n                u = list(uniq(d[k]))\n                if len(u) > 1:\n                    raise ValueError('not enough keys to break ties: %s' % u)\n        for v in d[k]:\n            yield v\n        d.pop(k)",
    ".sympy.sets.sets.py@@Set._infimum_key": "def _infimum_key(expr):\n    try:\n        infimum = expr.inf\n        assert infimum.is_comparable\n    except (NotImplementedError, AttributeError, AssertionError, ValueError):\n        infimum = S.Infinity\n    return infimum",
    ".sympy.core.numbers.py@@Infinity.__hash__": "def __hash__(self):\n    return super(Infinity, self).__hash__()",
    ".sympy.sets.sets.py@@Set.__contains__": "def __contains__(self, other):\n    symb = sympify(self.contains(other))\n    if not (symb is S.true or symb is S.false):\n        raise TypeError('contains did not evaluate to a bool: %r' % symb)\n    return bool(symb)",
    ".sympy.sets.sets.py@@Set.contains": "def contains(self, other):\n    other = sympify(other, strict=True)\n    ret = sympify(self._contains(other))\n    if ret is None:\n        ret = Contains(other, self, evaluate=False)\n    return ret",
    ".sympy.sets.sets.py@@FiniteSet._contains": "def _contains(self, other):\n    r = false\n    for e in self._elements:\n        t = Eq(e, other, evaluate=True)\n        if isinstance(t, Eq):\n            t = t.simplify()\n        if t == true:\n            return t\n        elif t != false:\n            r = None\n    return r",
    ".sympy.core.relational.py@@Equality.__new__": "def __new__(cls, lhs, rhs=0, **options):\n    from sympy.core.add import Add\n    from sympy.core.logic import fuzzy_bool\n    from sympy.simplify.simplify import clear_coefficients\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    evaluate = options.pop('evaluate', global_evaluate[0])\n    if evaluate:\n        if hasattr(lhs, '_eval_Eq'):\n            r = lhs._eval_Eq(rhs)\n            if r is not None:\n                return r\n        if hasattr(rhs, '_eval_Eq'):\n            r = rhs._eval_Eq(lhs)\n            if r is not None:\n                return r\n        if lhs == rhs:\n            return S.true\n        elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):\n            return S.false\n        fin = L, R = [i.is_finite for i in (lhs, rhs)]\n        if None not in fin:\n            if L != R:\n                return S.false\n            if L is False:\n                return S.true\n        if all((isinstance(i, Expr) for i in (lhs, rhs))):\n            dif = lhs - rhs\n            z = dif.is_zero\n            if z is not None:\n                if z is False and dif.is_commutative:\n                    return S.false\n                if z:\n                    return S.true\n            n, d = dif.as_numer_denom()\n            rv = None\n            if n.is_zero:\n                rv = d.is_nonzero\n            elif n.is_finite:\n                if d.is_infinite:\n                    rv = S.true\n                elif n.is_zero is False:\n                    rv = d.is_infinite\n                    if rv is None:\n                        l, r = clear_coefficients(d, S.Infinity)\n                        args = [_.subs(l, r) for _ in (lhs, rhs)]\n                        if args != [lhs, rhs]:\n                            rv = fuzzy_bool(Eq(*args))\n                            if rv is True:\n                                rv = None\n            elif any((a.is_infinite for a in Add.make_args(n))):\n                rv = S.false\n            if rv is not None:\n                return _sympify(rv)\n    return Relational.__new__(cls, lhs, rhs, **options)",
    ".sympy.logic.boolalg.py@@BooleanTrue.__hash__": "def __hash__(self):\n    return hash(True)",
    ".sympy.logic.boolalg.py@@BooleanTrue.__nonzero__": "def __nonzero__(self):\n    return True",
    ".sympy.core.function.py@@Application.__new__": "def __new__(cls, *args, **options):\n    from sympy.sets.fancysets import Naturals0\n    from sympy.sets.sets import FiniteSet\n    args = list(map(sympify, args))\n    evaluate = options.pop('evaluate', global_evaluate[0])\n    options.pop('nargs', None)\n    if options:\n        raise ValueError('Unknown options: %s' % options)\n    if evaluate:\n        evaluated = cls.eval(*args)\n        if evaluated is not None:\n            return evaluated\n    obj = super(Application, cls).__new__(cls, *args, **options)\n    try:\n        if is_sequence(obj.nargs):\n            nargs = tuple(ordered(set(obj.nargs)))\n        elif obj.nargs is not None:\n            nargs = (as_int(obj.nargs),)\n        else:\n            nargs = None\n    except AttributeError:\n        nargs = obj._nargs\n    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()\n    return obj",
    ".sympy.core.numbers.py@@Float.__hash__": "def __hash__(self):\n    return super(Float, self).__hash__()",
    ".sympy.core.numbers.py@@Float._hashable_content": "def _hashable_content(self):\n    return (self._mpf_, self._prec)",
    ".sympy.functions.elementary.complexes.py@@re.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_real:\n        return arg\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        return S.Zero\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[0]\n    elif arg.is_Function and arg.func is conjugate:\n        return re(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_real:\n                    reverted.append(coeff)\n            elif not term.has(S.ImaginaryUnit) and term.is_real:\n                excluded.append(term)\n            else:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[0])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) - im(b) + c",
    ".sympy.functions.elementary.complexes.py@@im.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_real:\n        return S.Zero\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        return -S.ImaginaryUnit * arg\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[1]\n    elif arg.is_Function and arg.func is conjugate:\n        return -im(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_real:\n                    reverted.append(coeff)\n                else:\n                    excluded.append(coeff)\n            elif term.has(S.ImaginaryUnit) or not term.is_real:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[1])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) + re(b) + c",
    ".sympy.core.numbers.py@@Zero.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.core.numbers.py@@Float.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    if isinstance(other, NumberSymbol):\n        return other.__ge__(self)\n    if other.is_real and other.is_number:\n        other = other.evalf()\n    if isinstance(other, Number) and other is not S.NaN:\n        return _sympify(bool(mlib.mpf_lt(self._mpf_, other._as_mpf_val(self._prec))))\n    return Expr.__lt__(self, other)",
    ".sympy.core.numbers.py@@Integer._eval_is_odd": "def _eval_is_odd(self):\n    return bool(self.p % 2)",
    ".sympy.core.numbers.py@@Integer.__neg__": "def __neg__(self):\n    return Integer(-self.p)",
    ".sympy.core.numbers.py@@Integer._eval_power": "def _eval_power(self, expt):\n    from sympy import perfect_power\n    if expt is S.Infinity:\n        if self.p > S.One:\n            return S.Infinity\n        return S.Infinity + S.ImaginaryUnit * S.Infinity\n    if expt is S.NegativeInfinity:\n        return Rational(1, self) ** S.Infinity\n    if not isinstance(expt, Number):\n        if self.is_negative and expt.is_even:\n            return (-self) ** expt\n    if isinstance(expt, Float):\n        return super(Integer, self)._eval_power(expt)\n    if not isinstance(expt, Rational):\n        return\n    if expt is S.Half and self.is_negative:\n        return S.ImaginaryUnit * Pow(-self, expt)\n    if expt.is_negative:\n        ne = -expt\n        if self.is_negative:\n            if expt.q != 1:\n                return -S.NegativeOne ** (expt.p % expt.q / S(expt.q)) * Rational(1, -self) ** ne\n            else:\n                return S.NegativeOne ** ne * Rational(1, -self) ** ne\n        else:\n            return Rational(1, self.p) ** ne\n    x, xexact = integer_nthroot(abs(self.p), expt.q)\n    if xexact:\n        result = Integer(x ** abs(expt.p))\n        if self.is_negative:\n            result *= S.NegativeOne ** expt\n        return result\n    b_pos = int(abs(self.p))\n    p = perfect_power(b_pos)\n    if p is not False:\n        dict = {p[0]: p[1]}\n    else:\n        dict = Integer(self).factors(limit=2 ** 15)\n    if self.is_negative:\n        dict[-1] = 1\n    out_int = 1\n    out_rad = 1\n    sqr_int = 1\n    sqr_gcd = 0\n    sqr_dict = {}\n    for prime, exponent in dict.items():\n        exponent *= expt.p\n        div_e, div_m = divmod(exponent, expt.q)\n        if div_e > 0:\n            out_int *= prime ** div_e\n        if div_m > 0:\n            g = igcd(div_m, expt.q)\n            if g != 1:\n                out_rad *= Pow(prime, Rational(div_m // g, expt.q // g))\n            else:\n                sqr_dict[prime] = div_m\n    for p, ex in sqr_dict.items():\n        if sqr_gcd == 0:\n            sqr_gcd = ex\n        else:\n            sqr_gcd = igcd(sqr_gcd, ex)\n            if sqr_gcd == 1:\n                break\n    for k, v in sqr_dict.items():\n        sqr_int *= k ** (v // sqr_gcd)\n    if sqr_int == self and out_int == 1 and (out_rad == 1):\n        result = None\n    else:\n        result = out_int * out_rad * Pow(sqr_int, Rational(sqr_gcd, expt.q))\n    return result",
    ".sympy.logic.boolalg.py@@BooleanFalse.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.core.power.py@@integer_nthroot": "def integer_nthroot(y, n):\n    y, n = (as_int(y), as_int(n))\n    if y < 0:\n        raise ValueError('y must be nonnegative')\n    if n < 1:\n        raise ValueError('n must be positive')\n    if y in (0, 1):\n        return (y, True)\n    if n == 1:\n        return (y, True)\n    if n == 2:\n        x, rem = mpmath_sqrtrem(y)\n        return (int(x), not rem)\n    if n > y:\n        return (1, False)\n    try:\n        guess = int(y ** (1.0 / n) + 0.5)\n    except OverflowError:\n        exp = _log(y, 2) / n\n        if exp > 53:\n            shift = int(exp - 53)\n            guess = int(2.0 ** (exp - shift) + 1) << shift\n        else:\n            guess = int(2.0 ** exp)\n    if guess > 2 ** 50:\n        xprev, x = (-1, guess)\n        while 1:\n            t = x ** (n - 1)\n            xprev, x = (x, ((n - 1) * x + y // t) // n)\n            if abs(x - xprev) < 2:\n                break\n    else:\n        x = guess\n    t = x ** n\n    while t < y:\n        x += 1\n        t = x ** n\n    while t > y:\n        x -= 1\n        t = x ** n\n    return (int(x), t == y)",
    ".sympy.core.compatibility.py@@as_int": "def as_int(n):\n    try:\n        result = int(n)\n        if result != n:\n            raise TypeError\n    except TypeError:\n        raise ValueError('%s is not an integer' % (n,))\n    return result",
    ".sympy.core.mul.py@@Mul.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        assert not a is S.One\n        if not a.is_zero and a.is_Rational:\n            r, b = b.as_coeff_Mul()\n            if b.is_Add:\n                if r is not S.One:\n                    rv = ([cls(a * r, b, evaluate=False)], [], None)\n                elif b.is_commutative:\n                    if a is S.One:\n                        rv = ([b], [], None)\n                    else:\n                        r, b = b.as_coeff_Add()\n                        bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n                        _addsort(bargs)\n                        ar = a * r\n                        if ar:\n                            bargs.insert(0, ar)\n                        bargs = [Add._from_args(bargs)]\n                        rv = (bargs, [], None)\n        if rv:\n            return rv\n    c_part = []\n    nc_part = []\n    nc_seq = []\n    coeff = S.One\n    c_powers = []\n    num_exp = []\n    neg1e = S.Zero\n    pnum_rat = {}\n    order_symbols = None\n    for o in seq:\n        if o.is_Order:\n            o, order_symbols = o.as_expr_variables(order_symbols)\n        if o.is_Mul:\n            if o.is_commutative:\n                seq.extend(o.args)\n            else:\n                for q in o.args:\n                    if q.is_commutative:\n                        seq.append(q)\n                    else:\n                        nc_seq.append(q)\n                seq.append(NC_Marker)\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o is S.Zero):\n                return ([S.NaN], [], None)\n            elif coeff.is_Number:\n                coeff *= o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__mul__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if not coeff:\n                return ([S.NaN], [], None)\n            if coeff is S.ComplexInfinity:\n                return ([S.ComplexInfinity], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o is S.ImaginaryUnit:\n            neg1e += S.Half\n            continue\n        elif o.is_commutative:\n            b, e = o.as_base_exp()\n            if o.is_Pow:\n                if b.is_Number:\n                    if e.is_Rational:\n                        if e.is_Integer:\n                            coeff *= Pow(b, e)\n                            continue\n                        elif e.is_negative:\n                            seq.append(Pow(b, e))\n                            continue\n                        elif b.is_negative:\n                            neg1e += e\n                            b = -b\n                        if b is not S.One:\n                            pnum_rat.setdefault(b, []).append(e)\n                        continue\n                    elif b.is_positive or e.is_integer:\n                        num_exp.append((b, e))\n                        continue\n                elif b is S.ImaginaryUnit and e.is_Rational:\n                    neg1e += e / 2\n                    continue\n            c_powers.append((b, e))\n        else:\n            if o is not NC_Marker:\n                nc_seq.append(o)\n            while nc_seq:\n                o = nc_seq.pop(0)\n                if not nc_part:\n                    nc_part.append(o)\n                    continue\n                o1 = nc_part.pop()\n                b1, e1 = o1.as_base_exp()\n                b2, e2 = o.as_base_exp()\n                new_exp = e1 + e2\n                if b1 == b2 and (not new_exp.is_Add):\n                    o12 = b1 ** new_exp\n                    if o12.is_commutative:\n                        seq.append(o12)\n                        continue\n                    else:\n                        nc_seq.insert(0, o12)\n                else:\n                    nc_part.append(o1)\n                    nc_part.append(o)\n\n    def _gather(c_powers):\n        common_b = {}\n        for b, e in c_powers:\n            co = e.as_coeff_Mul()\n            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n        for b, d in common_b.items():\n            for di, li in d.items():\n                d[di] = Add(*li)\n        new_c_powers = []\n        for b, e in common_b.items():\n            new_c_powers.extend([(b, c * t) for t, c in e.items()])\n        return new_c_powers\n    c_powers = _gather(c_powers)\n    num_exp = _gather(num_exp)\n    for i in range(2):\n        new_c_powers = []\n        changed = False\n        for b, e in c_powers:\n            if e.is_zero:\n                continue\n            if e is S.One:\n                if b.is_Number:\n                    coeff *= b\n                    continue\n                p = b\n            if e is not S.One:\n                p = Pow(b, e)\n                if p.is_Pow and (not b.is_Pow):\n                    bi = b\n                    b, e = p.as_base_exp()\n                    if b != bi:\n                        changed = True\n            c_part.append(p)\n            new_c_powers.append((b, e))\n        if changed and len(set((b for b, e in new_c_powers))) != len(new_c_powers):\n            c_part = []\n            c_powers = _gather(new_c_powers)\n        else:\n            break\n    inv_exp_dict = {}\n    for b, e in num_exp:\n        inv_exp_dict.setdefault(e, []).append(b)\n    for e, b in inv_exp_dict.items():\n        inv_exp_dict[e] = cls(*b)\n    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n    comb_e = {}\n    for b, e in pnum_rat.items():\n        comb_e.setdefault(Add(*e), []).append(b)\n    del pnum_rat\n    num_rat = []\n    for e, b in comb_e.items():\n        b = cls(*b)\n        if e.q == 1:\n            coeff *= Pow(b, e)\n            continue\n        if e.p > e.q:\n            e_i, ep = divmod(e.p, e.q)\n            coeff *= Pow(b, e_i)\n            e = Rational(ep, e.q)\n        num_rat.append((b, e))\n    del comb_e\n    pnew = defaultdict(list)\n    i = 0\n    while i < len(num_rat):\n        bi, ei = num_rat[i]\n        grow = []\n        for j in range(i + 1, len(num_rat)):\n            bj, ej = num_rat[j]\n            g = bi.gcd(bj)\n            if g is not S.One:\n                e = ei + ej\n                if e.q == 1:\n                    coeff *= Pow(g, e)\n                else:\n                    if e.p > e.q:\n                        e_i, ep = divmod(e.p, e.q)\n                        coeff *= Pow(g, e_i)\n                        e = Rational(ep, e.q)\n                    grow.append((g, e))\n                num_rat[j] = (bj / g, ej)\n                bi = bi / g\n                if bi is S.One:\n                    break\n        if bi is not S.One:\n            obj = Pow(bi, ei)\n            if obj.is_Number:\n                coeff *= obj\n            else:\n                for obj in Mul.make_args(obj):\n                    if obj.is_Number:\n                        coeff *= obj\n                    else:\n                        assert obj.is_Pow\n                        bi, ei = obj.args\n                        pnew[ei].append(bi)\n        num_rat.extend(grow)\n        i += 1\n    for e, b in pnew.items():\n        pnew[e] = cls(*b)\n    if neg1e:\n        p, q = neg1e.as_numer_denom()\n        n, p = divmod(p, q)\n        if n % 2:\n            coeff = -coeff\n        if q == 2:\n            c_part.append(S.ImaginaryUnit)\n        elif p:\n            neg1e = Rational(p, q)\n            for e, b in pnew.items():\n                if e == neg1e and b.is_positive:\n                    pnew[e] = -b\n                    break\n            else:\n                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n    c_part.extend([Pow(b, e) for e, b in pnew.items()])\n    if coeff is S.Infinity or coeff is S.NegativeInfinity:\n\n        def _handle_for_oo(c_part, coeff_sign):\n            new_c_part = []\n            for t in c_part:\n                if t.is_positive:\n                    continue\n                if t.is_negative:\n                    coeff_sign *= -1\n                    continue\n                new_c_part.append(t)\n            return (new_c_part, coeff_sign)\n        c_part, coeff_sign = _handle_for_oo(c_part, 1)\n        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n        coeff *= coeff_sign\n    if coeff is S.ComplexInfinity:\n        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n    elif coeff is S.Zero:\n        if any((c.is_finite == False for c in c_part)):\n            return ([S.NaN], [], order_symbols)\n        return ([coeff], [], order_symbols)\n    _new = []\n    for i in c_part:\n        if i.is_Number:\n            coeff *= i\n        else:\n            _new.append(i)\n    c_part = _new\n    _mulsort(c_part)\n    if coeff is not S.One:\n        c_part.insert(0, coeff)\n    if not nc_part and len(c_part) == 2 and c_part[0].is_Number and c_part[1].is_Add:\n        coeff = c_part[0]\n        c_part = [Add(*[coeff * f for f in c_part[1].args])]\n    return (c_part, nc_part, order_symbols)",
    ".sympy.core.numbers.py@@Integer.__mul__": "def __mul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p * other)\n        elif isinstance(other, Integer):\n            return Integer(self.p * other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    ".sympy.core.expr.py@@Expr.as_base_exp": "def as_base_exp(self):\n    return (self, S.One)",
    ".sympy.core.mul.py@@Mul._gather": "def _gather(c_powers):\n    common_b = {}\n    for b, e in c_powers:\n        co = e.as_coeff_Mul()\n        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n    for b, d in common_b.items():\n        for di, li in d.items():\n            d[di] = Add(*li)\n    new_c_powers = []\n    for b, e in common_b.items():\n        new_c_powers.extend([(b, c * t) for t, c in e.items()])\n    return new_c_powers",
    ".sympy.core.numbers.py@@Rational.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (self, S.One)",
    ".sympy.core.mul.py@@_mulsort": "def _mulsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.operations.py@@AssocOp._from_args": "def _from_args(cls, args, is_commutative=None):\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n    obj = super(AssocOp, cls).__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and((a.is_commutative for a in args))\n    obj.is_commutative = is_commutative\n    return obj",
    ".sympy.core.add.py@@Add.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        if a.is_Rational:\n            if b.is_Mul:\n                rv = ([a, b], [], None)\n        if rv:\n            if all((s.is_commutative for s in rv[0])):\n                return rv\n            return ([], rv[0], None)\n    terms = {}\n    coeff = S.Zero\n    order_factors = []\n    for o in seq:\n        if o.is_Order:\n            for o1 in order_factors:\n                if o1.contains(o):\n                    o = None\n                    break\n            if o is None:\n                continue\n            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False):\n                return ([S.NaN], [], None)\n            if coeff.is_Number:\n                coeff += o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__add__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if coeff.is_finite is False:\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o.is_Add:\n            seq.extend(o.args)\n            continue\n        elif o.is_Mul:\n            c, s = o.as_coeff_Mul()\n        elif o.is_Pow:\n            b, e = o.as_base_exp()\n            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):\n                seq.append(b ** e)\n                continue\n            c, s = (S.One, o)\n        else:\n            c = S.One\n            s = o\n        if s in terms:\n            terms[s] += c\n            if terms[s] is S.NaN:\n                return ([S.NaN], [], None)\n        else:\n            terms[s] = c\n    newseq = []\n    noncommutative = False\n    for s, c in terms.items():\n        if c is S.Zero:\n            continue\n        elif c is S.One:\n            newseq.append(s)\n        elif s.is_Mul:\n            cs = s._new_rawargs(*(c,) + s.args)\n            newseq.append(cs)\n        elif s.is_Add:\n            newseq.append(Mul(c, s, evaluate=False))\n        else:\n            newseq.append(Mul(c, s))\n        noncommutative = noncommutative or not s.is_commutative\n    if coeff is S.Infinity:\n        newseq = [f for f in newseq if not (f.is_nonnegative or (f.is_real and f.is_finite))]\n    elif coeff is S.NegativeInfinity:\n        newseq = [f for f in newseq if not (f.is_nonpositive or (f.is_real and f.is_finite))]\n    if coeff is S.ComplexInfinity:\n        newseq = [c for c in newseq if not (c.is_finite and c.is_real is not None)]\n    if order_factors:\n        newseq2 = []\n        for t in newseq:\n            for o in order_factors:\n                if o.contains(t):\n                    t = None\n                    break\n            if t is not None:\n                newseq2.append(t)\n        newseq = newseq2 + order_factors\n        for o in order_factors:\n            if o.contains(coeff):\n                coeff = S.Zero\n                break\n    _addsort(newseq)\n    if coeff is not S.Zero:\n        newseq.insert(0, coeff)\n    if noncommutative:\n        return ([], newseq, None)\n    else:\n        return (newseq, [], None)",
    ".sympy.core.power.py@@Pow.as_base_exp": "def as_base_exp(self):\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and (b.q != 1):\n        return (Integer(b.q), -e)\n    return (b, e)",
    ".sympy.core.numbers.py@@Integer.__add__": "def __add__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    ".sympy.core.mul.py@@Mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return (coeff, args[0])\n            else:\n                return (coeff, self._new_rawargs(*args))\n        elif coeff.is_negative:\n            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))\n    return (S.One, self)",
    ".sympy.core.numbers.py@@Rational._eval_is_zero": "def _eval_is_zero(self):\n    return self.p == 0",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (S.One, self)",
    ".sympy.core.add.py@@_addsort": "def _addsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.basic.py@@Basic.compare": "def compare(self, other):\n    if self is other:\n        return 0\n    n1 = self.__class__\n    n2 = other.__class__\n    c = (n1 > n2) - (n1 < n2)\n    if c:\n        return c\n    st = self._hashable_content()\n    ot = other._hashable_content()\n    c = (len(st) > len(ot)) - (len(st) < len(ot))\n    if c:\n        return c\n    for l, r in zip(st, ot):\n        l = Basic(*l) if isinstance(l, frozenset) else l\n        r = Basic(*r) if isinstance(r, frozenset) else r\n        if isinstance(l, Basic):\n            c = l.compare(r)\n        else:\n            c = (l > r) - (l < r)\n        if c:\n            return c\n    return 0",
    ".sympy.core.core.py@@BasicMeta.__gt__": "def __gt__(cls, other):\n    if cls.__cmp__(other) == 1:\n        return True\n    return False",
    ".sympy.core.core.py@@BasicMeta.__cmp__": "def __cmp__(cls, other):\n    if not isinstance(other, BasicMeta):\n        return -1\n    n1 = cls.__name__\n    n2 = other.__name__\n    if n1 == n2:\n        return 0\n    UNKNOWN = len(ordering_of_classes) + 1\n    try:\n        i1 = ordering_of_classes.index(n1)\n    except ValueError:\n        i1 = UNKNOWN\n    try:\n        i2 = ordering_of_classes.index(n2)\n    except ValueError:\n        i2 = UNKNOWN\n    if i1 == UNKNOWN and i2 == UNKNOWN:\n        return (n1 > n2) - (n1 < n2)\n    return (i1 > i2) - (i1 < i2)",
    ".sympy.core.core.py@@BasicMeta.__lt__": "def __lt__(cls, other):\n    if cls.__cmp__(other) == -1:\n        return True\n    return False",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self.__eq__(other)",
    ".sympy.core.power.py@@Pow.exp": "def exp(self):\n    return self._args[1]",
    ".sympy.core.add.py@@Add._eval_is_zero": "def _eval_is_zero(self):\n    if self.is_commutative is False:\n        return\n    nz = []\n    z = 0\n    im_or_z = False\n    im = False\n    for a in self.args:\n        if a.is_real:\n            if a.is_zero:\n                z += 1\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im = True\n        elif (S.ImaginaryUnit * a).is_real:\n            im_or_z = True\n        else:\n            return\n    if z == len(self.args):\n        return True\n    if self.func(*nz).is_zero:\n        if not im_or_z and (not im):\n            return True\n        if im and (not im_or_z):\n            return False\n    if self.func(*nz).is_zero is False:\n        return False",
    ".sympy.core.power.py@@Pow._eval_is_real": "def _eval_is_real(self):\n    from sympy import arg, exp, log, Mul\n    real_b = self.base.is_real\n    if real_b is None:\n        if self.base.func == exp and self.base.args[0].is_imaginary:\n            return self.exp.is_imaginary\n        return\n    real_e = self.exp.is_real\n    if real_e is None:\n        return\n    if real_b and real_e:\n        if self.base.is_positive:\n            return True\n        elif self.base.is_nonnegative:\n            if self.exp.is_nonnegative:\n                return True\n        elif self.exp.is_integer:\n            return True\n        elif self.base.is_negative:\n            if self.exp.is_Rational:\n                return False\n    if real_e and self.exp.is_negative:\n        return Pow(self.base, -self.exp).is_real\n    im_b = self.base.is_imaginary\n    im_e = self.exp.is_imaginary\n    if im_b:\n        if self.exp.is_integer:\n            if self.exp.is_even:\n                return True\n            elif self.exp.is_odd:\n                return False\n        elif im_e and log(self.base).is_imaginary:\n            return True\n        elif self.exp.is_Add:\n            c, a = self.exp.as_coeff_Add()\n            if c and c.is_Integer:\n                return Mul(self.base ** c, self.base ** a, evaluate=False).is_real\n        elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):\n            if (self.exp / 2).is_integer is False:\n                return False\n    if real_b and im_e:\n        if self.base is S.NegativeOne:\n            return True\n        c = self.exp.coeff(S.ImaginaryUnit)\n        if c:\n            ok = (c * log(self.base) / S.Pi).is_Integer\n            if ok is not None:\n                return ok\n    if real_b is False:\n        i = arg(self.base) * self.exp / S.Pi\n        return i.is_integer",
    ".sympy.core.power.py@@Pow.base": "def base(self):\n    return self._args[0]",
    ".sympy.core.power.py@@Pow._eval_is_zero": "def _eval_is_zero(self):\n    if self.base.is_zero:\n        if self.exp.is_positive:\n            return True\n        elif self.exp.is_nonpositive:\n            return False\n    elif self.base.is_zero is False:\n        if self.exp.is_finite:\n            return False\n        elif self.exp.is_infinite:\n            if (1 - abs(self.base)).is_positive:\n                return self.exp.is_positive\n            elif (1 - abs(self.base)).is_negative:\n                return self.exp.is_negative\n    else:\n        return None",
    ".sympy.core.power.py@@Pow._eval_is_algebraic": "def _eval_is_algebraic(self):\n    if self.base.is_zero or (self.base - 1).is_zero:\n        return True\n    elif self.exp.is_rational:\n        if self.base.is_algebraic is False:\n            return self.exp.is_nonzero\n        return self.base.is_algebraic\n    elif self.base.is_algebraic and self.exp.is_algebraic:\n        if fuzzy_not(self.base.is_zero) and fuzzy_not((self.base - 1).is_zero) or self.base.is_integer is False or self.base.is_irrational:\n            return self.exp.is_rational",
    ".sympy.core.decorators.py@@__sympifyit_wrapper": "def __sympifyit_wrapper(a, b):\n    try:\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    ".sympy.core.decorators.py@@binary_op_wrapper": "def binary_op_wrapper(self, other):\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:\n            try:\n                f = getattr(other, method_name)\n            except AttributeError:\n                pass\n            else:\n                return f(self)\n    return func(self, other)",
    ".sympy.core.expr.py@@Expr.__sub__": "def __sub__(self, other):\n    return Add(self, -other)",
    ".sympy.core.numbers.py@@One.__neg__": "def __neg__():\n    return S.NegativeOne",
    ".sympy.core.logic.py@@_fuzzy_group": "def _fuzzy_group(args, quick_exit=False):\n    saw_other = False\n    for a in args:\n        if a is True:\n            continue\n        if a is None:\n            return\n        if quick_exit and saw_other:\n            return\n        saw_other = True\n    return not saw_other",
    ".sympy.core.add.py@@Add._eval_is_positive": "def _eval_is_positive(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if self.is_number:\n        return super(Add, self)._eval_is_positive()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s.is_positive and a.is_nonnegative:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v.is_positive:\n                    return True\n    pos = nonneg = nonpos = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        ispos = a.is_positive\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((ispos, a.is_nonnegative)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if ispos:\n            pos = True\n            continue\n        elif a.is_nonnegative:\n            nonneg = True\n            continue\n        elif a.is_nonpositive:\n            nonpos = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonpos and (not nonneg) and pos:\n        return True\n    elif not nonpos and pos:\n        return True\n    elif not pos and (not nonneg):\n        return False",
    ".sympy.core.add.py@@Add.as_coeff_Add": "def as_coeff_Add(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number and (not rational) or coeff.is_Rational:\n        return (coeff, self._new_rawargs(*args))\n    return (S.Zero, self)",
    ".sympy.core.operations.py@@AssocOp._new_rawargs": "def _new_rawargs(self, *args, **kwargs):\n    if kwargs.pop('reeval', True) and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)",
    ".sympy.core.exprtools.py@@_monotonic_sign": "def _monotonic_sign(self):\n    if not self.is_real:\n        return\n    if (-self).is_Symbol:\n        rv = _monotonic_sign(-self)\n        return rv if rv is None else -rv\n    if not self.is_Add and self.as_numer_denom()[1].is_number:\n        s = self\n        if s.is_prime:\n            if s.is_odd:\n                return S(3)\n            else:\n                return S(2)\n        elif s.is_positive:\n            if s.is_even:\n                return S(2)\n            elif s.is_integer:\n                return S.One\n            else:\n                return _eps\n        elif s.is_negative:\n            if s.is_even:\n                return S(-2)\n            elif s.is_integer:\n                return S.NegativeOne\n            else:\n                return -_eps\n        if s.is_zero or s.is_nonpositive or s.is_nonnegative:\n            return S.Zero\n        return None\n    free = self.free_symbols\n    if len(free) == 1:\n        if self.is_polynomial():\n            from sympy.polys.polytools import real_roots\n            from sympy.polys.polyroots import roots\n            from sympy.polys.polyerrors import PolynomialError\n            x = free.pop()\n            x0 = _monotonic_sign(x)\n            if x0 == _eps or x0 == -_eps:\n                x0 = S.Zero\n            if x0 is not None:\n                d = self.diff(x)\n                if d.is_number:\n                    roots = []\n                else:\n                    try:\n                        roots = real_roots(d)\n                    except (PolynomialError, NotImplementedError):\n                        roots = [r for r in roots(d, x) if r.is_real]\n                y = self.subs(x, x0)\n                if x.is_nonnegative and all((r <= x0 for r in roots)):\n                    if y.is_nonnegative and d.is_positive:\n                        if y:\n                            return y if y.is_positive else Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_negative:\n                        if y:\n                            return y if y.is_negative else Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n                elif x.is_nonpositive and all((r >= x0 for r in roots)):\n                    if y.is_nonnegative and d.is_negative:\n                        if y:\n                            return Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_positive:\n                        if y:\n                            return Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n        else:\n            n, d = self.as_numer_denom()\n            den = None\n            if n.is_number:\n                den = _monotonic_sign(d)\n            elif not d.is_number:\n                if _monotonic_sign(n) is not None:\n                    den = _monotonic_sign(d)\n            if den is not None and (den.is_positive or den.is_negative):\n                v = n * den\n                if v.is_positive:\n                    return Dummy('pos', positive=True)\n                elif v.is_nonnegative:\n                    return Dummy('nneg', nonnegative=True)\n                elif v.is_negative:\n                    return Dummy('neg', negative=True)\n                elif v.is_nonpositive:\n                    return Dummy('npos', nonpositive=True)\n        return None\n    c, a = self.as_coeff_Add()\n    v = None\n    if not a.is_polynomial():\n        n, d = a.as_numer_denom()\n        if not (n.is_number or d.is_number):\n            return\n        if (a.is_Mul or a.is_Pow) and a.is_rational and all((p.exp.is_Integer for p in a.atoms(Pow) if p.is_Pow)) and (a.is_positive or a.is_negative):\n            v = S(1)\n            for ai in Mul.make_args(a):\n                if ai.is_number:\n                    v *= ai\n                    continue\n                reps = {}\n                for x in ai.free_symbols:\n                    reps[x] = _monotonic_sign(x)\n                    if reps[x] is None:\n                        return\n                v *= ai.subs(reps)\n    elif c:\n        if not any((p for p in a.atoms(Pow) if not p.is_number)) and (a.is_nonpositive or a.is_nonnegative):\n            free = list(a.free_symbols)\n            p = {}\n            for i in free:\n                v = _monotonic_sign(i)\n                if v is None:\n                    return\n                p[i] = v or (_eps if i.is_nonnegative else -_eps)\n            v = a.xreplace(p)\n    if v is not None:\n        rv = v + c\n        if v.is_nonnegative and rv.is_positive:\n            return rv.subs(_eps, 0)\n        if v.is_nonpositive and rv.is_negative:\n            return rv.subs(_eps, 0)",
    ".sympy.core.expr.py@@Expr.__neg__": "def __neg__(self):\n    return Mul(S.NegativeOne, self)",
    ".sympy.core.expr.py@@Expr.as_numer_denom": "def as_numer_denom(self):\n    return (self, S.One)",
    ".sympy.core.add.py@@Add._eval_is_nonnegative": "def _eval_is_nonnegative(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_nonnegative:\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s.is_nonnegative:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v.is_nonnegative:\n                        return True",
    ".sympy.core.add.py@@Add._eval_is_negative": "def _eval_is_negative(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if self.is_number:\n        return super(Add, self)._eval_is_negative()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s.is_negative and a.is_nonpositive:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v.is_negative:\n                    return True\n    neg = nonpos = nonneg = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        isneg = a.is_negative\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((isneg, a.is_nonpositive)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if isneg:\n            neg = True\n            continue\n        elif a.is_nonpositive:\n            nonpos = True\n            continue\n        elif a.is_nonnegative:\n            nonneg = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonneg and (not nonpos) and neg:\n        return True\n    elif not nonneg and neg:\n        return True\n    elif not neg and (not nonpos):\n        return False",
    ".sympy.core.add.py@@Add._eval_is_nonpositive": "def _eval_is_nonpositive(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_nonpositive:\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s.is_nonpositive:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v.is_nonpositive:\n                        return True",
    ".sympy.core.add.py@@Add._eval_is_odd": "def _eval_is_odd(self):\n    l = [f for f in self.args if not f.is_even is True]\n    if not l:\n        return False\n    if l[0].is_odd:\n        return self._new_rawargs(*l[1:]).is_even",
    ".sympy.core.power.py@@Pow._eval_is_positive": "def _eval_is_positive(self):\n    from sympy import log\n    if self.base == self.exp:\n        if self.base.is_nonnegative:\n            return True\n    elif self.base.is_positive:\n        if self.exp.is_real:\n            return True\n    elif self.base.is_negative:\n        if self.exp.is_even:\n            return True\n        if self.exp.is_odd:\n            return False\n    elif self.base.is_nonpositive:\n        if self.exp.is_odd:\n            return False\n    elif self.base.is_imaginary:\n        if self.exp.is_integer:\n            m = self.exp % 4\n            if m.is_zero:\n                return True\n            if m.is_integer and m.is_zero is False:\n                return False\n        if self.exp.is_imaginary:\n            return log(self.base).is_imaginary",
    ".sympy.core.power.py@@Pow._eval_is_negative": "def _eval_is_negative(self):\n    if self.base.is_negative:\n        if self.exp.is_odd:\n            return True\n        if self.exp.is_even:\n            return False\n    elif self.base.is_positive:\n        if self.exp.is_real:\n            return False\n    elif self.base.is_nonnegative:\n        if self.exp.is_nonnegative:\n            return False\n    elif self.base.is_nonpositive:\n        if self.exp.is_even:\n            return False\n    elif self.base.is_real:\n        if self.exp.is_even:\n            return False",
    ".sympy.core.power.py@@Pow._eval_is_prime": "def _eval_is_prime(self):\n    if self.exp == S.One:\n        return self.base.is_prime\n    if self.is_number:\n        return self.doit().is_prime\n    if self.is_integer and self.is_positive:\n        '\\n        a Power will be non-prime only if both base and exponent\\n        are greater than 1\\n        '\n        if (self.base - 1).is_positive or (self.exp - 1).is_positive:\n            return False",
    ".sympy.core.power.py@@Pow._eval_is_integer": "def _eval_is_integer(self):\n    b, e = self.args\n    if b.is_rational:\n        if b.is_integer is False and e.is_positive:\n            return False\n    if b.is_integer and e.is_integer:\n        if b is S.NegativeOne:\n            return True\n        if e.is_nonnegative or e.is_positive:\n            return True\n    if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):\n        if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):\n            return False\n    if b.is_Number and e.is_Number:\n        check = self.func(*self.args)\n        return check.is_Integer",
    ".sympy.core.power.py@@Pow._eval_is_odd": "def _eval_is_odd(self):\n    if self.exp.is_integer:\n        if self.exp.is_positive:\n            return self.base.is_odd\n        elif self.exp.is_nonnegative and self.base.is_odd:\n            return True\n        elif self.base is S.NegativeOne:\n            return True",
    ".sympy.core.power.py@@Pow._eval_is_even": "def _eval_is_even(self):\n    if self.exp.is_integer and self.exp.is_positive:\n        return self.base.is_even",
    ".sympy.core.power.py@@Pow._eval_is_finite": "def _eval_is_finite(self):\n    if self.exp.is_negative:\n        if self.base.is_zero:\n            return False\n        if self.base.is_infinite:\n            return True\n    c1 = self.base.is_finite\n    if c1 is None:\n        return\n    c2 = self.exp.is_finite\n    if c2 is None:\n        return\n    if c1 and c2:\n        if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):\n            return True",
    ".sympy.core.add.py@@Add._eval_is_imaginary": "def _eval_is_imaginary(self):\n    nz = []\n    im_I = []\n    for a in self.args:\n        if a.is_real:\n            if a.is_zero:\n                pass\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im_I.append(a * S.ImaginaryUnit)\n        elif (S.ImaginaryUnit * a).is_real:\n            im_I.append(a * S.ImaginaryUnit)\n        else:\n            return\n    if self.func(*nz).is_zero:\n        return fuzzy_not(self.func(*im_I).is_zero)\n    elif self.func(*nz).is_zero is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_real": "def _eval_is_real(self):\n    return self._eval_real_imag(True)",
    ".sympy.core.mul.py@@Mul._eval_real_imag": "def _eval_real_imag(self, real):\n    zero = one_neither = False\n    for t in self.args:\n        if not t.is_complex:\n            return t.is_complex\n        elif t.is_imaginary:\n            real = not real\n        elif t.is_real:\n            if not zero:\n                z = t.is_zero\n                if not z and zero is False:\n                    zero = z\n                elif z:\n                    if all((a.is_finite for a in self.args)):\n                        return True\n                    return\n        elif t.is_real is False:\n            if one_neither:\n                return\n            one_neither = True\n        else:\n            return\n    if one_neither:\n        if real:\n            return zero\n    elif zero is False:\n        return real\n    elif real:\n        return real",
    ".sympy.core.add.py@@Add.__neg__": "def __neg__(self):\n    return self.func(*[-t for t in self.args])",
    ".sympy.core.expr.py@@Expr.is_polynomial": "def is_polynomial(self, *syms):\n    if syms:\n        syms = set(map(sympify, syms))\n    else:\n        syms = self.free_symbols\n    if syms.intersection(self.free_symbols) == set([]):\n        return True\n    else:\n        return self._eval_is_polynomial(syms)",
    ".sympy.core.add.py@@Add._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    return all((term._eval_is_polynomial(syms) for term in self.args))",
    ".sympy.core.power.py@@Pow._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    if self.exp.has(*syms):\n        return False\n    if self.base.has(*syms):\n        return bool(self.base._eval_is_polynomial(syms) and self.exp.is_Integer and (self.exp >= 0))\n    else:\n        return True",
    ".sympy.core.basic.py@@Basic.has": "def has(self, *patterns):\n    return any((self._has(pattern) for pattern in patterns))",
    ".sympy.core.basic.py@@Basic._has": "def _has(self, pattern):\n    from sympy.core.function import UndefinedFunction, Function\n    if isinstance(pattern, UndefinedFunction):\n        return any((f.func == pattern or f == pattern for f in self.atoms(Function, UndefinedFunction)))\n    pattern = sympify(pattern)\n    if isinstance(pattern, BasicMeta):\n        return any((isinstance(arg, pattern) for arg in preorder_traversal(self)))\n    try:\n        match = pattern._has_matcher()\n        return any((match(arg) for arg in preorder_traversal(self)))\n    except AttributeError:\n        return any((arg == pattern for arg in preorder_traversal(self)))",
    ".sympy.core.basic.py@@Basic._has_matcher": "def _has_matcher(self):\n    return self.__eq__",
    ".sympy.core.basic.py@@preorder_traversal.__init__": "def __init__(self, node, keys=None):\n    self._skip_flag = False\n    self._pt = self._preorder_traversal(node, keys)",
    ".sympy.core.basic.py@@preorder_traversal.__iter__": "def __iter__(self):\n    return self",
    ".sympy.core.basic.py@@preorder_traversal.__next__": "def __next__(self):\n    return next(self._pt)",
    ".sympy.core.basic.py@@preorder_traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            for subtree in self._preorder_traversal(arg, keys):\n                yield subtree\n    elif iterable(node):\n        for item in node:\n            for subtree in self._preorder_traversal(item, keys):\n                yield subtree",
    ".sympy.core.expr.py@@AtomicExpr._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    return True",
    ".sympy.core.numbers.py@@Integer.__ge__": "def __ge__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s >= %s' % (self, other))\n    if isinstance(other, Integer):\n        return _sympify(self.p >= other.p)\n    return Rational.__ge__(self, other)",
    ".sympy.core.mul.py@@Mul._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    return all((term._eval_is_polynomial(syms) for term in self.args))",
    ".sympy.core.symbol.py@@Dummy._hashable_content": "def _hashable_content(self):\n    return Symbol._hashable_content(self) + (self.dummy_index,)",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return dict(((key, value) for key, value in self._assumptions.items() if value is not None))",
    ".sympy.core.mul.py@@Mul._eval_is_zero": "def _eval_is_zero(self):\n    zero = infinite = False\n    for a in self.args:\n        z = a.is_zero\n        if z:\n            if infinite:\n                return\n            zero = True\n        else:\n            if not a.is_finite:\n                if zero:\n                    return\n                infinite = True\n            if zero is False and z is None:\n                zero = None\n    return zero",
    ".sympy.core.numbers.py@@Number._eval_is_finite": "def _eval_is_finite(self):\n    return True",
    ".sympy.core.mul.py@@Mul._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all(((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others)):\n                return True\n            return\n        if a is None:\n            return\n    return False",
    ".sympy.core.mul.py@@Mul._eval_is_positive": "def _eval_is_positive(self):\n    return self._eval_pos_neg(1)",
    ".sympy.core.mul.py@@Mul._eval_pos_neg": "def _eval_pos_neg(self, sign):\n    saw_NON = saw_NOT = False\n    for t in self.args:\n        if t.is_positive:\n            continue\n        elif t.is_negative:\n            sign = -sign\n        elif t.is_zero:\n            if all((a.is_finite for a in self.args)):\n                return False\n            return\n        elif t.is_nonpositive:\n            sign = -sign\n            saw_NON = True\n        elif t.is_nonnegative:\n            saw_NON = True\n        elif t.is_positive is False:\n            sign = -sign\n            if saw_NOT:\n                return\n            saw_NOT = True\n        elif t.is_negative is False:\n            if saw_NOT:\n                return\n            saw_NOT = True\n        else:\n            return\n    if sign == 1 and saw_NON is False and (saw_NOT is False):\n        return True\n    if sign < 0:\n        return False",
    ".sympy.core.numbers.py@@Rational._eval_is_positive": "def _eval_is_positive(self):\n    return self.p > 0",
    ".sympy.core.mul.py@@Mul._eval_is_negative": "def _eval_is_negative(self):\n    if self.args[0] == -1:\n        return (-self).is_positive\n    return self._eval_pos_neg(-1)",
    ".sympy.core.mul.py@@Mul._eval_is_prime": "def _eval_is_prime(self):\n    if self.is_number:\n        '\\n        If input is a number that is not completely simplified.\\n        e.g. Mul(sqrt(3), sqrt(3), evaluate=False)\\n        So we manually evaluate it and return whether that is prime or not.\\n        '\n        r = S.One\n        for arg in self.args:\n            r *= arg\n        return r.is_prime\n    if self.is_integer and self.is_positive:\n        '\\n        Here we count the number of arguments that have a minimum value\\n        greater than two.\\n        If there are more than one of such a symbol then the result is not prime.\\n        Else, the result cannot be determined.\\n        '\n        number_of_args = 0\n        for arg in self.args:\n            if (arg - 1).is_positive:\n                number_of_args += 1\n        if number_of_args > 1:\n            return False",
    ".sympy.core.mul.py@@Mul._eval_is_integer": "def _eval_is_integer(self):\n    is_rational = self.is_rational\n    if is_rational:\n        n, d = self.as_numer_denom()\n        if d is S.One:\n            return True\n        elif d is S(2):\n            return n.is_even\n    elif is_rational is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_rational": "def _eval_is_rational(self):\n    r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        return self.is_zero",
    ".sympy.core.mul.py@@Mul.as_numer_denom": "def as_numer_denom(self):\n    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n    return (self.func(*numers), self.func(*denoms))",
    ".sympy.core.numbers.py@@Integer.as_numer_denom": "def as_numer_denom(self):\n    return (self, S.One)",
    ".sympy.core.mul.py@@Mul._eval_is_infinite": "def _eval_is_infinite(self):\n    if any((a.is_infinite for a in self.args)):\n        if any((a.is_zero for a in self.args)):\n            return S.NaN.is_infinite\n        if any((a.is_zero is None for a in self.args)):\n            return None\n        return True",
    ".sympy.core.mul.py@@Mul._eval_is_odd": "def _eval_is_odd(self):\n    is_integer = self.is_integer\n    if is_integer:\n        r, acc = (True, 1)\n        for t in self.args:\n            if not t.is_integer:\n                return None\n            elif t.is_even:\n                r = False\n            elif t.is_integer:\n                if r is False:\n                    pass\n                elif acc != 1 and (acc + t).is_odd:\n                    r = False\n                elif t.is_odd is None:\n                    r = None\n            acc = t\n        return r\n    elif is_integer is False:\n        return False",
    ".sympy.core.add.py@@Add._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all((x.is_rational is True for x in others)):\n                return True\n            return None\n        if a is None:\n            return\n    return False",
    ".sympy.core.mul.py@@Mul._eval_expand_mul": "def _eval_expand_mul(self, **hints):\n    from sympy import fraction\n    expr = self\n    n, d = fraction(expr)\n    if d.is_Mul:\n        n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i for i in (n, d)]\n        expr = n / d\n        if not expr.is_Mul:\n            return expr\n    plain, sums, rewrite = ([], [], False)\n    for factor in expr.args:\n        if factor.is_Add:\n            sums.append(factor)\n            rewrite = True\n        elif factor.is_commutative:\n            plain.append(factor)\n        else:\n            sums.append(Basic(factor))\n    if not rewrite:\n        return expr\n    else:\n        plain = self.func(*plain)\n        if sums:\n            terms = self.func._expandsums(sums)\n            args = []\n            for term in terms:\n                t = self.func(plain, term)\n                if t.is_Mul and any((a.is_Add for a in t.args)):\n                    t = t._eval_expand_mul()\n                args.append(t)\n            return Add(*args)\n        else:\n            return plain",
    ".sympy.simplify.radsimp.py@@fraction": "def fraction(expr, exact=False):\n    expr = sympify(expr)\n    numer, denom = ([], [])\n    for term in Mul.make_args(expr):\n        if term.is_commutative and (term.is_Pow or term.func is exp):\n            b, ex = term.as_base_exp()\n            if ex.is_negative:\n                if ex is S.NegativeOne:\n                    denom.append(b)\n                elif exact:\n                    if ex.is_constant():\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n            elif ex.is_positive:\n                numer.append(term)\n            elif not exact and ex.is_Mul:\n                n, d = term.as_numer_denom()\n                numer.append(n)\n                denom.append(d)\n            else:\n                numer.append(term)\n        elif term.is_Rational:\n            n, d = term.as_numer_denom()\n            numer.append(n)\n            denom.append(d)\n        else:\n            numer.append(term)\n    if exact:\n        return (Mul(*numer, evaluate=False), Mul(*denom, evaluate=False))\n    else:\n        return (Mul(*numer), Mul(*denom))",
    ".sympy.core.operations.py@@AssocOp.make_args": "def make_args(cls, expr):\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    ".sympy.core.mul.py@@Mul._expandsums": "def _expandsums(sums):\n    L = len(sums)\n    if L == 1:\n        return sums[0].args\n    terms = []\n    left = Mul._expandsums(sums[:L // 2])\n    right = Mul._expandsums(sums[L // 2:])\n    terms = [Mul(a, b) for a in left for b in right]\n    added = Add(*terms)\n    return Add.make_args(added)",
    ".sympy.core.numbers.py@@Rational._hashable_content": "def _hashable_content(self):\n    return (self.p, self.q)",
    ".sympy.core.power.py@@Pow._eval_expand_power_base": "def _eval_expand_power_base(self, **hints):\n    force = hints.get('force', False)\n    b = self.base\n    e = self.exp\n    if not b.is_Mul:\n        return self\n    cargs, nc = b.args_cnc(split_1=False)\n    if nc:\n        nc = [i._eval_expand_power_base(**hints) if hasattr(i, '_eval_expand_power_base') else i for i in nc]\n        if e.is_Integer:\n            if e.is_positive:\n                rv = Mul(*nc * e)\n            else:\n                rv = 1 / Mul(*nc * -e)\n            if cargs:\n                rv *= Mul(*cargs) ** e\n            return rv\n        if not cargs:\n            return self.func(Mul(*nc), e, evaluate=False)\n        nc = [Mul(*nc)]\n\n    def pred(x):\n        if x is S.ImaginaryUnit:\n            return S.ImaginaryUnit\n        polar = x.is_polar\n        if polar:\n            return True\n        if polar is None:\n            return fuzzy_bool(x.is_nonnegative)\n    sifted = sift(cargs, pred)\n    nonneg = sifted[True]\n    other = sifted[None]\n    neg = sifted[False]\n    imag = sifted[S.ImaginaryUnit]\n    if imag:\n        I = S.ImaginaryUnit\n        i = len(imag) % 4\n        if i == 0:\n            pass\n        elif i == 1:\n            other.append(I)\n        elif i == 2:\n            if neg:\n                nonn = -neg.pop()\n                if nonn is not S.One:\n                    nonneg.append(nonn)\n            else:\n                neg.append(S.NegativeOne)\n        else:\n            if neg:\n                nonn = -neg.pop()\n                if nonn is not S.One:\n                    nonneg.append(nonn)\n            else:\n                neg.append(S.NegativeOne)\n            other.append(I)\n        del imag\n    if force or e.is_integer:\n        cargs = nonneg + neg + other\n        other = nc\n    else:\n        assert not e.is_Integer\n        if len(neg) > 1:\n            o = S.One\n            if not other and neg[0].is_Number:\n                o *= neg.pop(0)\n            if len(neg) % 2:\n                o = -o\n            for n in neg:\n                nonneg.append(-n)\n            if o is not S.One:\n                other.append(o)\n        elif neg and other:\n            if neg[0].is_Number and neg[0] is not S.NegativeOne:\n                other.append(S.NegativeOne)\n                nonneg.append(-neg[0])\n            else:\n                other.extend(neg)\n        else:\n            other.extend(neg)\n        del neg\n        cargs = nonneg\n        other += nc\n    rv = S.One\n    if cargs:\n        rv *= Mul(*[self.func(b, e, evaluate=False) for b in cargs])\n    if other:\n        rv *= self.func(Mul(*other), e, evaluate=False)\n    return rv",
    ".sympy.core.power.py@@Pow._eval_expand_power_exp": "def _eval_expand_power_exp(self, **hints):\n    b = self.base\n    e = self.exp\n    if e.is_Add and e.is_commutative:\n        expr = []\n        for x in e.args:\n            expr.append(self.func(self.base, x))\n        return Mul(*expr)\n    return self.func(b, e)",
    ".sympy.core.add.py@@Add.as_coefficients_dict": "def as_coefficients_dict(a):\n    d = defaultdict(list)\n    for ai in a.args:\n        c, m = ai.as_coeff_Mul()\n        d[m].append(c)\n    for k, v in d.items():\n        if len(v) == 1:\n            d[k] = v[0]\n        else:\n            d[k] = Add(*v)\n    di = defaultdict(int)\n    di.update(d)\n    return di",
    ".sympy.solvers.diophantine.py@@_is_int": "def _is_int(i):\n    try:\n        as_int(i)\n        return True\n    except ValueError:\n        pass",
    ".sympy.core.numbers.py@@Integer.__ne__": "def __ne__(self, other):\n    return not self.__eq__(other)",
    ".sympy.polys.polytools.py@@Poly.__new__": "def __new__(cls, rep, *gens, **args):\n    opt = options.build_options(gens, args)\n    if 'order' in opt:\n        raise NotImplementedError(\"'order' keyword is not implemented yet\")\n    if iterable(rep, exclude=str):\n        if isinstance(rep, dict):\n            return cls._from_dict(rep, opt)\n        else:\n            return cls._from_list(list(rep), opt)\n    else:\n        rep = sympify(rep)\n        if rep.is_Poly:\n            return cls._from_poly(rep, opt)\n        else:\n            return cls._from_expr(rep, opt)",
    ".sympy.polys.polyoptions.py@@build_options": "def build_options(gens, args=None):\n    if args is None:\n        gens, args = ((), gens)\n    if len(args) != 1 or 'opt' not in args or gens:\n        return Options(gens, args)\n    else:\n        return args['opt']",
    ".sympy.polys.polyoptions.py@@Options.__init__": "def __init__(self, gens, args, flags=None, strict=False):\n    dict.__init__(self)\n    if gens and args.get('gens', ()):\n        raise OptionError(\"both '*gens' and keyword argument 'gens' supplied\")\n    elif gens:\n        args = dict(args)\n        args['gens'] = gens\n    defaults = args.pop('defaults', {})\n\n    def preprocess_options(args):\n        for option, value in args.items():\n            try:\n                cls = self.__options__[option]\n            except KeyError:\n                raise OptionError(\"'%s' is not a valid option\" % option)\n            if issubclass(cls, Flag):\n                if flags is None or option not in flags:\n                    if strict:\n                        raise OptionError(\"'%s' flag is not allowed in this context\" % option)\n            if value is not None:\n                self[option] = cls.preprocess(value)\n    preprocess_options(args)\n    for key, value in dict(defaults).items():\n        if key in self:\n            del defaults[key]\n        else:\n            for option in self.keys():\n                cls = self.__options__[option]\n                if key in cls.excludes:\n                    del defaults[key]\n                    break\n    preprocess_options(defaults)\n    for option in self.keys():\n        cls = self.__options__[option]\n        for require_option in cls.requires:\n            if self.get(require_option) is None:\n                raise OptionError(\"'%s' option is only allowed together with '%s'\" % (option, require_option))\n        for exclude_option in cls.excludes:\n            if self.get(exclude_option) is not None:\n                raise OptionError(\"'%s' option is not allowed together with '%s'\" % (option, exclude_option))\n    for option in self.__order__:\n        self.__options__[option].postprocess(self)",
    ".sympy.polys.polyoptions.py@@Options.preprocess_options": "def preprocess_options(args):\n    for option, value in args.items():\n        try:\n            cls = self.__options__[option]\n        except KeyError:\n            raise OptionError(\"'%s' is not a valid option\" % option)\n        if issubclass(cls, Flag):\n            if flags is None or option not in flags:\n                if strict:\n                    raise OptionError(\"'%s' flag is not allowed in this context\" % option)\n        if value is not None:\n            self[option] = cls.preprocess(value)",
    ".sympy.polys.polyoptions.py@@Option.postprocess": "def postprocess(cls, options):\n    pass",
    ".sympy.polys.polyoptions.py@@Extension.postprocess": "def postprocess(cls, options):\n    if 'extension' in options and options['extension'] is not True:\n        options['domain'] = sympy.polys.domains.QQ.algebraic_field(*options['extension'])",
    ".sympy.polys.polyoptions.py@@Gaussian.postprocess": "def postprocess(cls, options):\n    if 'gaussian' in options and options['gaussian'] is True:\n        options['extension'] = set([S.ImaginaryUnit])\n        Extension.postprocess(options)",
    ".sympy.polys.polyoptions.py@@Domain.postprocess": "def postprocess(cls, options):\n    if 'gens' in options and 'domain' in options and options['domain'].is_Composite and set(options['domain'].symbols) & set(options['gens']):\n        raise GeneratorsError('ground domain and generators interfere together')\n    elif ('gens' not in options or not options['gens']) and 'domain' in options and (options['domain'] == sympy.polys.domains.EX):\n        raise GeneratorsError('you have to provide generators because EX domain was requested')",
    ".sympy.polys.polyoptions.py@@Auto.postprocess": "def postprocess(cls, options):\n    if ('domain' in options or 'field' in options) and 'auto' not in options:\n        options['auto'] = False",
    ".sympy.polys.polyoptions.py@@Modulus.postprocess": "def postprocess(cls, options):\n    if 'modulus' in options:\n        modulus = options['modulus']\n        symmetric = options.get('symmetric', True)\n        options['domain'] = sympy.polys.domains.FF(modulus, symmetric)",
    ".sympy.polys.polyoptions.py@@Split.postprocess": "def postprocess(cls, options):\n    if 'split' in options:\n        raise NotImplementedError(\"'split' option is not implemented yet\")",
    ".sympy.core.compatibility.py@@iterable": "def iterable(i, exclude=(string_types, dict, NotIterable)):\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    ".sympy.polys.polytools.py@@Poly._from_expr": "def _from_expr(cls, rep, opt):\n    rep, opt = _dict_from_expr(rep, opt)\n    return cls._from_dict(rep, opt)",
    ".sympy.polys.polyutils.py@@_dict_from_expr": "def _dict_from_expr(expr, opt):\n    if expr.is_commutative is False:\n        raise PolynomialError('non-commutative expressions are not supported')\n\n    def _is_expandable_pow(expr):\n        return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add\n    if opt.expand is not False:\n        try:\n            expr = expr.expand()\n        except AttributeError:\n            raise PolynomialError('expression must support expand method')\n        while any((_is_expandable_pow(i) or (i.is_Mul and any((_is_expandable_pow(j) for j in i.args))) for i in Add.make_args(expr))):\n            expr = expand_multinomial(expr)\n        while any((i.is_Mul and any((j.is_Add for j in i.args)) for i in Add.make_args(expr))):\n            expr = expand_mul(expr)\n    if opt.gens:\n        rep, gens = _dict_from_expr_if_gens(expr, opt)\n    else:\n        rep, gens = _dict_from_expr_no_gens(expr, opt)\n    return (rep, opt.clone({'gens': gens}))",
    ".sympy.polys.polyoptions.py@@OptionType.getter": "def getter(self):\n    try:\n        return self[cls.option]\n    except KeyError:\n        return cls.default()",
    ".sympy.polys.polyoptions.py@@Expand.default": "def default(cls):\n    return True",
    ".sympy.polys.polyutils.py@@_is_expandable_pow": "def _is_expandable_pow(expr):\n    return expr.is_Pow and expr.exp.is_positive and expr.exp.is_Integer and expr.base.is_Add",
    ".sympy.polys.polyoptions.py@@Gens.default": "def default(cls):\n    return ()",
    ".sympy.polys.polyutils.py@@_dict_from_expr_no_gens": "def _dict_from_expr_no_gens(expr, opt):\n    (poly,), gens = _parallel_dict_from_expr_no_gens((expr,), opt)\n    return (poly, gens)",
    ".sympy.polys.polyutils.py@@_parallel_dict_from_expr_no_gens": "def _parallel_dict_from_expr_no_gens(exprs, opt):\n    if opt.domain is not None:\n\n        def _is_coeff(factor):\n            return factor in opt.domain\n    elif opt.extension is True:\n\n        def _is_coeff(factor):\n            return factor.is_algebraic\n    elif opt.greedy is not False:\n\n        def _is_coeff(factor):\n            return False\n    else:\n\n        def _is_coeff(factor):\n            return factor.is_number\n    gens, reprs = (set([]), [])\n    for expr in exprs:\n        terms = []\n        if expr.is_Equality:\n            expr = expr.lhs - expr.rhs\n        for term in Add.make_args(expr):\n            coeff, elements = ([], {})\n            for factor in Mul.make_args(term):\n                if not _not_a_coeff(factor) and (factor.is_Number or _is_coeff(factor)):\n                    coeff.append(factor)\n                else:\n                    if opt.series is False:\n                        base, exp = decompose_power(factor)\n                        if exp < 0:\n                            exp, base = (-exp, Pow(base, -S.One))\n                    else:\n                        base, exp = decompose_power_rat(factor)\n                    elements[base] = elements.setdefault(base, 0) + exp\n                    gens.add(base)\n            terms.append((coeff, elements))\n        reprs.append(terms)\n    gens = _sort_gens(gens, opt=opt)\n    k, indices = (len(gens), {})\n    for i, g in enumerate(gens):\n        indices[g] = i\n    polys = []\n    for terms in reprs:\n        poly = {}\n        for coeff, term in terms:\n            monom = [0] * k\n            for base, exp in term.items():\n                monom[indices[base]] = exp\n            monom = tuple(monom)\n            if monom in poly:\n                poly[monom] += Mul(*coeff)\n            else:\n                poly[monom] = Mul(*coeff)\n        polys.append(poly)\n    return (polys, tuple(gens))",
    ".sympy.polys.polyoptions.py@@Option.default": "def default(cls):\n    return None",
    ".sympy.polys.polyutils.py@@_not_a_coeff": "def _not_a_coeff(expr):\n    return expr in [S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity]",
    ".sympy.core.numbers.py@@NaN.__eq__": "def __eq__(self, other):\n    return other is S.NaN",
    ".sympy.core.numbers.py@@Infinity.__eq__": "def __eq__(self, other):\n    return other is S.Infinity",
    ".sympy.core.numbers.py@@NegativeInfinity.__eq__": "def __eq__(self, other):\n    return other is S.NegativeInfinity",
    ".sympy.polys.polyutils.py@@_is_coeff": "def _is_coeff(factor):\n    return factor.is_number",
    ".sympy.polys.polyoptions.py@@Series.default": "def default(cls):\n    return False",
    ".sympy.core.exprtools.py@@decompose_power": "def decompose_power(expr):\n    base, exp = expr.as_base_exp()\n    if exp.is_Number:\n        if exp.is_Rational:\n            if not exp.is_Integer:\n                base = Pow(base, Rational(1, exp.q))\n            exp = exp.p\n        else:\n            base, exp = (expr, 1)\n    else:\n        exp, tail = exp.as_coeff_Mul(rational=True)\n        if exp is S.NegativeOne:\n            base, exp = (Pow(base, tail), -1)\n        elif exp is not S.One:\n            tail = _keep_coeff(Rational(1, exp.q), tail)\n            base, exp = (Pow(base, tail), exp.p)\n        else:\n            base, exp = (expr, 1)\n    return (base, exp)",
    ".sympy.polys.polyutils.py@@_sort_gens": "def _sort_gens(gens, **args):\n    opt = build_options(args)\n    gens_order, wrt = ({}, None)\n    if opt is not None:\n        gens_order, wrt = ({}, opt.wrt)\n        for i, gen in enumerate(opt.sort):\n            gens_order[gen] = i + 1\n\n    def order_key(gen):\n        gen = str(gen)\n        if wrt is not None:\n            try:\n                return (-len(wrt) + wrt.index(gen), gen, 0)\n            except ValueError:\n                pass\n        name, index = _re_gen.match(gen).groups()\n        if index:\n            index = int(index)\n        else:\n            index = 0\n        try:\n            return (gens_order[name], name, index)\n        except KeyError:\n            pass\n        try:\n            return (_gens_order[name], name, index)\n        except KeyError:\n            pass\n        return (_max_order, name, index)\n    try:\n        gens = sorted(gens, key=order_key)\n    except TypeError:\n        pass\n    return tuple(gens)",
    ".sympy.polys.polyoptions.py@@Sort.default": "def default(cls):\n    return []",
    ".sympy.polys.polyutils.py@@order_key": "def order_key(gen):\n    gen = str(gen)\n    if wrt is not None:\n        try:\n            return (-len(wrt) + wrt.index(gen), gen, 0)\n        except ValueError:\n            pass\n    name, index = _re_gen.match(gen).groups()\n    if index:\n        index = int(index)\n    else:\n        index = 0\n    try:\n        return (gens_order[name], name, index)\n    except KeyError:\n        pass\n    try:\n        return (_gens_order[name], name, index)\n    except KeyError:\n        pass\n    return (_max_order, name, index)",
    ".sympy.polys.polyoptions.py@@Options.clone": "def clone(self, updates={}):\n    obj = dict.__new__(self.__class__)\n    for option, value in self.items():\n        obj[option] = value\n    for option, value in updates.items():\n        obj[option] = value\n    return obj",
    ".sympy.polys.polytools.py@@Poly._from_dict": "def _from_dict(cls, rep, opt):\n    gens = opt.gens\n    if not gens:\n        raise GeneratorsNeeded(\"can't initialize from 'dict' without generators\")\n    level = len(gens) - 1\n    domain = opt.domain\n    if domain is None:\n        domain, rep = construct_domain(rep, opt=opt)\n    else:\n        for monom, coeff in rep.items():\n            rep[monom] = domain.convert(coeff)\n    return cls.new(DMP.from_dict(rep, level, domain), *gens)",
    ".sympy.polys.constructor.py@@construct_domain": "def construct_domain(obj, **args):\n    opt = build_options(args)\n    if hasattr(obj, '__iter__'):\n        if isinstance(obj, dict):\n            if not obj:\n                monoms, coeffs = ([], [])\n            else:\n                monoms, coeffs = list(zip(*list(obj.items())))\n        else:\n            coeffs = obj\n    else:\n        coeffs = [obj]\n    coeffs = list(map(sympify, coeffs))\n    result = _construct_simple(coeffs, opt)\n    if result is not None:\n        if result is not False:\n            domain, coeffs = result\n        else:\n            domain, coeffs = _construct_expression(coeffs, opt)\n    else:\n        if opt.composite is False:\n            result = None\n        else:\n            result = _construct_composite(coeffs, opt)\n        if result is not None:\n            domain, coeffs = result\n        else:\n            domain, coeffs = _construct_expression(coeffs, opt)\n    if hasattr(obj, '__iter__'):\n        if isinstance(obj, dict):\n            return (domain, dict(list(zip(monoms, coeffs))))\n        else:\n            return (domain, coeffs)\n    else:\n        return (domain, coeffs[0])",
    ".sympy.polys.constructor.py@@_construct_simple": "def _construct_simple(coeffs, opt):\n    result, rationals, reals, algebraics = ({}, False, False, False)\n    if opt.extension is True:\n        is_algebraic = lambda coeff: coeff.is_number and coeff.is_algebraic\n    else:\n        is_algebraic = lambda coeff: False\n    for coeff in coeffs:\n        if coeff.is_Rational:\n            if not coeff.is_Integer:\n                rationals = True\n        elif coeff.is_Float:\n            if not algebraics:\n                reals = True\n            else:\n                return False\n        elif is_algebraic(coeff):\n            if not reals:\n                algebraics = True\n            else:\n                return False\n        else:\n            return None\n    if algebraics:\n        domain, result = _construct_algebraic(coeffs, opt)\n    else:\n        if reals:\n            max_prec = max([c._prec for c in coeffs])\n            domain = RealField(prec=max_prec)\n        elif opt.field or rationals:\n            domain = QQ\n        else:\n            domain = ZZ\n        result = []\n        for coeff in coeffs:\n            result.append(domain.from_sympy(coeff))\n    return (domain, result)",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.from_sympy": "def from_sympy(self, a):\n    if a.is_Integer:\n        return PythonInteger(a.p)\n    elif a.is_Float and int(a) == a:\n        return PythonInteger(int(a))\n    else:\n        raise CoercionFailed('expected an integer, got %s' % a)",
    ".sympy.polys.polyclasses.py@@DMP.from_dict": "def from_dict(cls, rep, lev, dom):\n    return cls(dmp_from_dict(rep, lev, dom), dom, lev)",
    ".sympy.polys.densebasic.py@@dmp_from_dict": "def dmp_from_dict(f, u, K):\n    if not u:\n        return dup_from_dict(f, K)\n    if not f:\n        return dmp_zero(u)\n    coeffs = {}\n    for monom, coeff in f.items():\n        head, tail = (monom[0], monom[1:])\n        if head in coeffs:\n            coeffs[head][tail] = coeff\n        else:\n            coeffs[head] = {tail: coeff}\n    n, v, h = (max(coeffs.keys()), u - 1, [])\n    for k in range(n, -1, -1):\n        coeff = coeffs.get(k)\n        if coeff is not None:\n            h.append(dmp_from_dict(coeff, v, K))\n        else:\n            h.append(dmp_zero(v))\n    return dmp_strip(h, u)",
    ".sympy.polys.densebasic.py@@dup_from_dict": "def dup_from_dict(f, K):\n    if not f:\n        return []\n    n, h = (max(f.keys()), [])\n    if type(n) is int:\n        for k in range(n, -1, -1):\n            h.append(f.get(k, K.zero))\n    else:\n        n, = n\n        for k in range(n, -1, -1):\n            h.append(f.get((k,), K.zero))\n    return dup_strip(h)",
    ".sympy.polys.densebasic.py@@dup_strip": "def dup_strip(f):\n    if not f or f[0]:\n        return f\n    i = 0\n    for cf in f:\n        if cf:\n            break\n        else:\n            i += 1\n    return f[i:]",
    ".sympy.polys.polyclasses.py@@DMP.__init__": "def __init__(self, rep, dom, lev=None, ring=None):\n    if lev is not None:\n        if type(rep) is dict:\n            rep = dmp_from_dict(rep, lev, dom)\n        elif type(rep) is not list:\n            rep = dmp_ground(dom.convert(rep), lev)\n    else:\n        rep, lev = dmp_validate(rep)\n    self.rep = rep\n    self.lev = lev\n    self.dom = dom\n    self.ring = ring",
    ".sympy.polys.polytools.py@@Poly.new": "def new(cls, rep, *gens):\n    if not isinstance(rep, DMP):\n        raise PolynomialError('invalid polynomial representation: %s' % rep)\n    elif rep.lev != len(gens) - 1:\n        raise PolynomialError('invalid arguments: %s, %s' % (rep, gens))\n    obj = Basic.__new__(cls)\n    obj.rep = rep\n    obj.gens = gens\n    return obj",
    ".sympy.polys.polytools.py@@Poly.total_degree": "def total_degree(f):\n    if hasattr(f.rep, 'total_degree'):\n        return f.rep.total_degree()\n    else:\n        raise OperationNotSupported(f, 'total_degree')",
    ".sympy.polys.polyclasses.py@@DMP.total_degree": "def total_degree(f):\n    return max((sum(m) for m in f.monoms()))",
    ".sympy.polys.polyclasses.py@@DMP.monoms": "def monoms(f, order=None):\n    return [m for m, _ in dmp_list_terms(f.rep, f.lev, f.dom, order=order)]",
    ".sympy.polys.densebasic.py@@dmp_list_terms": "def dmp_list_terms(f, u, K, order=None):\n\n    def sort(terms, O):\n        return sorted(terms, key=lambda term: O(term[0]), reverse=True)\n    terms = _rec_list_terms(f, u, ())\n    if not terms:\n        return [((0,) * (u + 1), K.zero)]\n    if order is None:\n        return terms\n    else:\n        return sort(terms, monomial_key(order))",
    ".sympy.polys.densebasic.py@@_rec_list_terms": "def _rec_list_terms(g, v, monom):\n    d, terms = (dmp_degree(g, v), [])\n    if not v:\n        for i, c in enumerate(g):\n            if not c:\n                continue\n            terms.append((monom + (d - i,), c))\n    else:\n        w = v - 1\n        for i, c in enumerate(g):\n            terms.extend(_rec_list_terms(c, w, monom + (d - i,)))\n    return terms",
    ".sympy.polys.densebasic.py@@dmp_degree": "def dmp_degree(f, u):\n    if dmp_zero_p(f, u):\n        return -oo\n    else:\n        return len(f) - 1",
    ".sympy.polys.densebasic.py@@dmp_zero_p": "def dmp_zero_p(f, u):\n    while u:\n        if len(f) != 1:\n            return False\n        f = f[0]\n        u -= 1\n    return not f",
    ".sympy.core.expr.py@@Expr.as_coefficients_dict": "def as_coefficients_dict(self):\n    c, m = self.as_coeff_Mul()\n    if not c.is_Rational:\n        c = S.One\n        m = self\n    d = defaultdict(int)\n    d.update({m: c})\n    return d",
    ".sympy.core.mul.py@@Mul.as_coefficients_dict": "def as_coefficients_dict(self):\n    d = defaultdict(int)\n    args = self.args\n    if len(args) == 1 or not args[0].is_Number:\n        d[self] = S.One\n    else:\n        d[self._new_rawargs(*args[1:])] = args[0]\n    return d",
    ".sympy.polys.densebasic.py@@dmp_strip": "def dmp_strip(f, u):\n    if not u:\n        return dup_strip(f)\n    if dmp_zero_p(f, u):\n        return f\n    i, v = (0, u - 1)\n    for c in f:\n        if not dmp_zero_p(c, v):\n            break\n        else:\n            i += 1\n    if i == len(f):\n        return dmp_zero(u)\n    else:\n        return f[i:]",
    ".sympy.polys.densebasic.py@@dmp_zero": "def dmp_zero(u):\n    r = []\n    for i in range(u):\n        r = [r]\n    return r",
    ".sympy.core.numbers.py@@Infinity.__neg__": "def __neg__(self):\n    return S.NegativeInfinity",
    ".sympy.solvers.diophantine.py@@_diop_ternary_quadratic": "def _diop_ternary_quadratic(_var, coeff):\n    x, y, z = _var\n    var = [x, y, z]\n    if not any((coeff[i ** 2] for i in var)):\n        if coeff[x * z]:\n            sols = diophantine(coeff[x * y] * x + coeff[y * z] * z - x * z)\n            s = sols.pop()\n            min_sum = abs(s[0]) + abs(s[1])\n            for r in sols:\n                if abs(r[0]) + abs(r[1]) < min_sum:\n                    s = r\n                    min_sum = abs(s[0]) + abs(s[1])\n                x_0, y_0, z_0 = (s[0], -coeff[x * z], s[1])\n        else:\n            var[0], var[1] = (_var[1], _var[0])\n            y_0, x_0, z_0 = _diop_ternary_quadratic(var, coeff)\n        return _remove_gcd(x_0, y_0, z_0)\n    if coeff[x ** 2] == 0:\n        if coeff[y ** 2] == 0:\n            var[0], var[2] = (_var[2], _var[0])\n            z_0, y_0, x_0 = _diop_ternary_quadratic(var, coeff)\n        else:\n            var[0], var[1] = (_var[1], _var[0])\n            y_0, x_0, z_0 = _diop_ternary_quadratic(var, coeff)\n    elif coeff[x * y] or coeff[x * z]:\n        A = coeff[x ** 2]\n        B = coeff[x * y]\n        C = coeff[x * z]\n        D = coeff[y ** 2]\n        E = coeff[y * z]\n        F = coeff[z ** 2]\n        _coeff = dict()\n        _coeff[x ** 2] = 4 * A ** 2\n        _coeff[y ** 2] = 4 * A * D - B ** 2\n        _coeff[z ** 2] = 4 * A * F - C ** 2\n        _coeff[y * z] = 4 * A * E - 2 * B * C\n        _coeff[x * y] = 0\n        _coeff[x * z] = 0\n        x_0, y_0, z_0 = _diop_ternary_quadratic(var, _coeff)\n        if x_0 is None:\n            return (None, None, None)\n        p, q = _rational_pq(B * y_0 + C * z_0, 2 * A)\n        x_0, y_0, z_0 = (x_0 * q - p, y_0 * q, z_0 * q)\n    elif coeff[z * y] != 0:\n        if coeff[y ** 2] == 0:\n            if coeff[z ** 2] == 0:\n                A = coeff[x ** 2]\n                E = coeff[y * z]\n                b, a = _rational_pq(-E, A)\n                x_0, y_0, z_0 = (b, a, b)\n            else:\n                var[0], var[2] = (_var[2], _var[0])\n                z_0, y_0, x_0 = _diop_ternary_quadratic(var, coeff)\n        else:\n            var[0], var[1] = (_var[1], _var[0])\n            y_0, x_0, z_0 = _diop_ternary_quadratic(var, coeff)\n    else:\n        x_0, y_0, z_0 = _diop_ternary_quadratic_normal(var, coeff)\n    return _remove_gcd(x_0, y_0, z_0)",
    ".sympy.core.expr.py@@Expr.__pow__": "def __pow__(self, other):\n    return Pow(self, other)",
    ".sympy.core.expr.py@@Expr.__mul__": "def __mul__(self, other):\n    return Mul(self, other)",
    ".sympy.core.numbers.py@@Integer.__rmul__": "def __rmul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(other * self.p)\n        elif isinstance(other, Rational):\n            return Rational(other.p * self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    ".sympy.core.numbers.py@@Integer.__sub__": "def __sub__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    ".sympy.solvers.diophantine.py@@_diop_ternary_quadratic_normal": "def _diop_ternary_quadratic_normal(var, coeff):\n    x, y, z = var\n    a = coeff[x ** 2]\n    b = coeff[y ** 2]\n    c = coeff[z ** 2]\n    try:\n        assert len([k for k in coeff if coeff[k]]) == 3\n        assert all((coeff[i ** 2] for i in var))\n    except AssertionError:\n        raise ValueError(filldedent('\\n    coeff dict is not consistent with assumption of this routine:\\n    coefficients should be those of an expression in the form\\n    a*x**2 + b*y**2 + c*z**2 where a*b*c != 0.'))\n    (sqf_of_a, sqf_of_b, sqf_of_c), (a_1, b_1, c_1), (a_2, b_2, c_2) = sqf_normal(a, b, c, steps=True)\n    A = -a_2 * c_2\n    B = -b_2 * c_2\n    if A < 0 and B < 0:\n        return (None, None, None)\n    if sqrt_mod(-b_2 * c_2, a_2) is None or sqrt_mod(-c_2 * a_2, b_2) is None or sqrt_mod(-a_2 * b_2, c_2) is None:\n        return (None, None, None)\n    z_0, x_0, y_0 = descent(A, B)\n    z_0, q = _rational_pq(z_0, abs(c_2))\n    x_0 *= q\n    y_0 *= q\n    x_0, y_0, z_0 = _remove_gcd(x_0, y_0, z_0)\n    if sign(a) == sign(b):\n        x_0, y_0, z_0 = holzer(x_0, y_0, z_0, abs(a_2), abs(b_2), abs(c_2))\n    elif sign(a) == sign(c):\n        x_0, z_0, y_0 = holzer(x_0, z_0, y_0, abs(a_2), abs(c_2), abs(b_2))\n    else:\n        y_0, z_0, x_0 = holzer(y_0, z_0, x_0, abs(b_2), abs(c_2), abs(a_2))\n    x_0 = reconstruct(b_1, c_1, x_0)\n    y_0 = reconstruct(a_1, c_1, y_0)\n    z_0 = reconstruct(a_1, b_1, z_0)\n    sq_lcm = ilcm(sqf_of_a, sqf_of_b, sqf_of_c)\n    x_0 = abs(x_0 * sq_lcm // sqf_of_a)\n    y_0 = abs(y_0 * sq_lcm // sqf_of_b)\n    z_0 = abs(z_0 * sq_lcm // sqf_of_c)\n    return _remove_gcd(x_0, y_0, z_0)",
    ".sympy.solvers.diophantine.py@@sqf_normal": "def sqf_normal(a, b, c, steps=False):\n    ABC = A, B, C = _remove_gcd(a, b, c)\n    sq = tuple((square_factor(i) for i in ABC))\n    sqf = A, B, C = tuple([i // j ** 2 for i, j in zip(ABC, sq)])\n    pc = igcd(A, B)\n    A /= pc\n    B /= pc\n    pa = igcd(B, C)\n    B /= pa\n    C /= pa\n    pb = igcd(A, C)\n    A /= pb\n    B /= pb\n    A *= pa\n    B *= pb\n    C *= pc\n    if steps:\n        return (sq, sqf, (A, B, C))\n    else:\n        return (A, B, C)",
    ".sympy.solvers.diophantine.py@@_remove_gcd": "def _remove_gcd(*x):\n    try:\n        g = igcd(*x)\n        return tuple([i // g for i in x])\n    except ValueError:\n        return x\n    except TypeError:\n        raise TypeError('_remove_gcd(a,b,c) or _remove_gcd(*container)')",
    ".sympy.core.numbers.py@@igcd": "def igcd(*args):\n    if len(args) < 2:\n        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))\n    if 1 in args:\n        a = 1\n        k = 0\n    else:\n        a = abs(as_int(args[0]))\n        k = 1\n    if a != 1:\n        while k < len(args):\n            b = args[k]\n            k += 1\n            try:\n                a = _gcdcache[a, b]\n            except KeyError:\n                b = as_int(b)\n                if not b:\n                    continue\n                if b == 1:\n                    a = 1\n                    break\n                if b < 0:\n                    b = -b\n                t = (a, b)\n                while b:\n                    a, b = (b, a % b)\n                _gcdcache[t] = _gcdcache[t[1], t[0]] = a\n    while k < len(args):\n        ok = as_int(args[k])\n        k += 1\n    return a",
    ".sympy.core.numbers.py@@Integer.__floordiv__": "def __floordiv__(self, other):\n    return Integer(self.p // Integer(other).p)",
    ".sympy.solvers.diophantine.py@@square_factor": "def square_factor(a):\n    f = a if isinstance(a, dict) else factorint(a)\n    return Mul(*[p ** (e // 2) for p, e in f.items()])",
    ".sympy.ntheory.factor_.py@@factorint": "def factorint(n, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None):\n    factordict = {}\n    if visual and (not isinstance(n, Mul)) and (not isinstance(n, dict)):\n        factordict = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n    elif isinstance(n, Mul):\n        factordict = dict([(int(k), int(v)) for k, v in list(n.as_powers_dict().items())])\n    elif isinstance(n, dict):\n        factordict = n\n    if factordict and (isinstance(n, Mul) or isinstance(n, dict)):\n        for k in list(factordict.keys()):\n            if isprime(k):\n                continue\n            e = factordict.pop(k)\n            d = factorint(k, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n            for k, v in d.items():\n                if k in factordict:\n                    factordict[k] += v * e\n                else:\n                    factordict[k] = v * e\n    if visual or (type(n) is dict and visual is not True and (visual is not False)):\n        if factordict == {}:\n            return S.One\n        if -1 in factordict:\n            factordict.pop(-1)\n            args = [S.NegativeOne]\n        else:\n            args = []\n        args.extend([Pow(*i, evaluate=False) for i in sorted(factordict.items())])\n        return Mul(*args, evaluate=False)\n    elif isinstance(n, dict) or isinstance(n, Mul):\n        return factordict\n    assert use_trial or use_rho or use_pm1\n    n = as_int(n)\n    if limit:\n        limit = int(limit)\n    if n < 0:\n        factors = factorint(-n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n        factors[-1] = 1\n        return factors\n    if limit and limit < 2:\n        if n == 1:\n            return {}\n        return {n: 1}\n    elif n < 10:\n        return [{0: 1}, {}, {2: 1}, {3: 1}, {2: 2}, {5: 1}, {2: 1, 3: 1}, {7: 1}, {2: 3}, {3: 2}][n]\n    factors = {}\n    if verbose:\n        sn = str(n)\n        if len(sn) > 50:\n            print('Factoring %s' % sn[:5] + '..(%i other digits)..' % (len(sn) - 10) + sn[-5:])\n        else:\n            print('Factoring', n)\n    if use_trial:\n        small = 2 ** 15\n        fail_max = 600\n        small = min(small, limit or small)\n        if verbose:\n            print(trial_int_msg % (2, small, fail_max))\n        n, next_p = _factorint_small(factors, n, small, fail_max)\n    else:\n        next_p = 2\n    if factors and verbose:\n        for k in sorted(factors):\n            print(factor_msg % (k, factors[k]))\n    if next_p == 0:\n        if n > 1:\n            factors[int(n)] = 1\n        if verbose:\n            print(complete_msg)\n        return factors\n    try:\n        if limit and next_p > limit:\n            if verbose:\n                print('Exceeded limit:', limit)\n            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n            if n > 1:\n                factors[int(n)] = 1\n            return factors\n        else:\n            sqrt_n = integer_nthroot(n, 2)[0]\n            a = sqrt_n + 1\n            a2 = a ** 2\n            b2 = a2 - n\n            for i in range(3):\n                b, fermat = integer_nthroot(b2, 2)\n                if fermat:\n                    break\n                b2 += 2 * a + 1\n                a += 1\n            if fermat:\n                if verbose:\n                    print(fermat_msg)\n                if limit:\n                    limit -= 1\n                for r in [a - b, a + b]:\n                    facs = factorint(r, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)\n                    factors.update(facs)\n                raise StopIteration\n            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n    except StopIteration:\n        if verbose:\n            print(complete_msg)\n        return factors\n    low, high = (next_p, 2 * next_p)\n    limit = limit or sqrt_n\n    limit += 1\n    while 1:\n        try:\n            high_ = high\n            if limit < high_:\n                high_ = limit\n            if use_trial:\n                if verbose:\n                    print(trial_msg % (low, high_))\n                ps = sieve.primerange(low, high_)\n                n, found_trial = _trial(factors, n, ps, verbose)\n                if found_trial:\n                    _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n            else:\n                found_trial = False\n            if high > limit:\n                if verbose:\n                    print('Exceeded limit:', limit)\n                if n > 1:\n                    factors[int(n)] = 1\n                raise StopIteration\n            if not found_trial:\n                if use_pm1 or use_rho:\n                    high_root = max(int(math.log(high_ ** 0.7)), low, 3)\n                    if use_pm1:\n                        if verbose:\n                            print(pm1_msg % (high_root, high_))\n                        c = pollard_pm1(n, B=high_root, seed=high_)\n                        if c:\n                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)\n                            n, _ = _trial(factors, n, ps, verbose=False)\n                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n                    if use_rho:\n                        max_steps = high_root\n                        if verbose:\n                            print(rho_msg % (1, max_steps, high_))\n                        c = pollard_rho(n, retries=1, max_steps=max_steps, seed=high_)\n                        if c:\n                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)\n                            n, _ = _trial(factors, n, ps, verbose=False)\n                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n        except StopIteration:\n            if verbose:\n                print(complete_msg)\n            return factors\n        low, high = (high, high * 2)",
    ".sympy.core.numbers.py@@Integer.__abs__": "def __abs__(self):\n    if self.p >= 0:\n        return self\n    else:\n        return Integer(-self.p)",
    ".sympy.core.numbers.py@@Rational.__div__": "def __div__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, Integer):\n            if self.p and other.p == S.Zero:\n                return S.ComplexInfinity\n            else:\n                return Rational(self.p, self.q * other.p, igcd(self.p, other.p))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q, self.q * other.p, igcd(self.p, other.p) * igcd(self.q, other.q))\n        elif isinstance(other, Float):\n            return self * (1 / other)\n        else:\n            return Number.__div__(self, other)\n    return Number.__div__(self, other)",
    ".sympy.core.numbers.py@@Rational.__new__": "def __new__(cls, p, q=None, gcd=None):\n    if q is None:\n        if isinstance(p, Rational):\n            return p\n        if isinstance(p, string_types):\n            if p.count('/') > 1:\n                raise TypeError('invalid input: %s' % p)\n            pq = p.rsplit('/', 1)\n            if len(pq) == 2:\n                p, q = pq\n                fp = fractions.Fraction(p)\n                fq = fractions.Fraction(q)\n                f = fp / fq\n                return Rational(f.numerator, f.denominator, 1)\n            p = p.replace(' ', '')\n            try:\n                p = fractions.Fraction(p)\n            except ValueError:\n                pass\n        elif isinstance(p, float):\n            p = fractions.Fraction(p)\n        if not isinstance(p, string_types):\n            try:\n                if isinstance(p, fractions.Fraction):\n                    return Rational(p.numerator, p.denominator, 1)\n            except NameError:\n                pass\n            if isinstance(p, Float):\n                return Rational(*float(p).as_integer_ratio())\n        if not isinstance(p, SYMPY_INTS + (Rational,)):\n            raise TypeError('invalid input: %s' % p)\n        q = q or S.One\n        gcd = 1\n    else:\n        p = Rational(p)\n        q = Rational(q)\n    if isinstance(q, Rational):\n        p *= q.q\n        q = q.p\n    if isinstance(p, Rational):\n        q *= p.q\n        p = p.p\n    if q == 0:\n        if p == 0:\n            if _errdict['divide']:\n                raise ValueError('Indeterminate 0/0')\n            else:\n                return S.NaN\n        return S.ComplexInfinity\n    if q < 0:\n        q = -q\n        p = -p\n    if not gcd:\n        gcd = igcd(abs(p), q)\n    if gcd > 1:\n        p //= gcd\n        q //= gcd\n    if q == 1:\n        return Integer(p)\n    if p == 1 and q == 2:\n        return S.Half\n    obj = Expr.__new__(cls)\n    obj.p = p\n    obj.q = q\n    return obj",
    ".sympy.core.numbers.py@@NegativeOne.__neg__": "def __neg__():\n    return S.One",
    ".sympy.core.numbers.py@@Integer.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    if isinstance(other, Integer):\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    ".sympy.ntheory.residue_ntheory.py@@sqrt_mod": "def sqrt_mod(a, p, all_roots=False):\n    if all_roots:\n        return sorted(list(sqrt_mod_iter(a, p)))\n    try:\n        p = abs(as_int(p))\n        it = sqrt_mod_iter(a, p)\n        r = next(it)\n        if r > p // 2:\n            return p - r\n        elif r < p // 2:\n            return r\n        else:\n            try:\n                r = next(it)\n                if r > p // 2:\n                    return p - r\n            except StopIteration:\n                pass\n            return r\n    except StopIteration:\n        return None",
    ".sympy.ntheory.residue_ntheory.py@@sqrt_mod_iter": "def sqrt_mod_iter(a, p, domain=int):\n    from sympy.polys.galoistools import gf_crt1, gf_crt2\n    from sympy.polys.domains import ZZ\n    a, p = (as_int(a), abs(as_int(p)))\n    if isprime(p):\n        a = a % p\n        if a == 0:\n            res = _sqrt_mod1(a, p, 1)\n        else:\n            res = _sqrt_mod_prime_power(a, p, 1)\n        if res:\n            if domain is ZZ:\n                for x in res:\n                    yield x\n            else:\n                for x in res:\n                    yield domain(x)\n    else:\n        f = factorint(p)\n        v = []\n        pv = []\n        for px, ex in f.items():\n            if a % px == 0:\n                rx = _sqrt_mod1(a, px, ex)\n                if not rx:\n                    return\n            else:\n                rx = _sqrt_mod_prime_power(a, px, ex)\n                if not rx:\n                    return\n            v.append(rx)\n            pv.append(px ** ex)\n        mm, e, s = gf_crt1(pv, ZZ)\n        if domain is ZZ:\n            for vx in _product(*v):\n                r = gf_crt2(vx, pv, mm, e, s, ZZ)\n                yield r\n        else:\n            for vx in _product(*v):\n                r = gf_crt2(vx, pv, mm, e, s, ZZ)\n                yield domain(r)",
    ".sympy.ntheory.primetest.py@@isprime": "def isprime(n):\n    if isinstance(n, (Float, float)):\n        return False\n    n = int(n)\n    if n in [2, 3, 5]:\n        return True\n    if n < 2 or n % 2 == 0 or n % 3 == 0 or (n % 5 == 0):\n        return False\n    if n < 49:\n        return True\n    if n % 7 == 0 or n % 11 == 0 or n % 13 == 0 or (n % 17 == 0) or (n % 19 == 0) or (n % 23 == 0) or (n % 29 == 0) or (n % 31 == 0) or (n % 37 == 0) or (n % 41 == 0) or (n % 43 == 0) or (n % 47 == 0):\n        return False\n    if n < 2809:\n        return True\n    if n <= 23001:\n        return pow(2, n, n) == 2 and n not in [341, 561, 645, 1105, 1387, 1729, 1905, 2047, 2465, 2701, 2821, 3277, 4033, 4369, 4371, 4681, 5461, 6601, 7957, 8321, 8481, 8911, 10261, 10585, 11305, 12801, 13741, 13747, 13981, 14491, 15709, 15841, 16705, 18705, 18721, 19951, 23001]\n    from sympy.ntheory.generate import sieve as s\n    if n <= s._list[-1]:\n        l, u = s.search(n)\n        return l == u\n    from sympy.core.compatibility import HAS_GMPY\n    if HAS_GMPY == 2:\n        from gmpy2 import is_strong_prp, is_strong_selfridge_prp\n        return is_strong_prp(n, 2) and is_strong_selfridge_prp(n)\n    if n < 341531:\n        return mr(n, [9345883071009581737])\n    if n < 885594169:\n        return mr(n, [725270293939359937, 3569819667048198375])\n    if n < 350269456337:\n        return mr(n, [4230279247111683200, 14694767155120705706, 16641139526367750375])\n    if n < 55245642489451:\n        return mr(n, [2, 141889084524735, 1199124725622454117, 11096072698276303650])\n    if n < 7999252175582851:\n        return mr(n, [2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805])\n    if n < 585226005592931977:\n        return mr(n, [2, 123635709730000, 9233062284813009, 43835965440333360, 761179012939631437, 1263739024124850375])\n    if n < 18446744073709551616:\n        return mr(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022])\n    return mr(n, [2]) and is_strong_lucas_prp(n)",
    ".sympy.ntheory.residue_ntheory.py@@_sqrt_mod_prime_power": "def _sqrt_mod_prime_power(a, p, k):\n    from sympy.core.numbers import igcdex\n    from sympy.polys.domains import ZZ\n    pk = p ** k\n    a = a % pk\n    if k == 1:\n        if p == 2:\n            return [ZZ(a)]\n        if not is_quad_residue(a, p):\n            return None\n        if p % 4 == 3:\n            res = pow(a, (p + 1) // 4, p)\n        elif p % 8 == 5:\n            sign = pow(a, (p - 1) // 4, p)\n            if sign == 1:\n                res = pow(a, (p + 3) // 8, p)\n            else:\n                b = pow(4 * a, (p - 5) // 8, p)\n                x = 2 * a * b % p\n                if pow(x, 2, p) == a:\n                    res = x\n        else:\n            res = _sqrt_mod_tonelli_shanks(a, p)\n        return sorted([ZZ(res), ZZ(p - res)])\n    if k > 1:\n        if p == 2:\n            if a % 8 != 1:\n                return None\n            if k <= 3:\n                s = set()\n                for i in range(0, pk, 4):\n                    s.add(1 + i)\n                    s.add(-1 + i)\n                return list(s)\n            rv = [ZZ(1), ZZ(3), ZZ(5), ZZ(7)]\n            n = 3\n            res = []\n            for r in rv:\n                nx = n\n                while nx < k:\n                    r1 = r ** 2 - a >> nx\n                    if r1 % 2:\n                        r = r + (1 << nx - 1)\n                    nx += 1\n                if r not in res:\n                    res.append(r)\n                x = r + (1 << k - 1)\n                if x < 1 << nx and x not in res:\n                    if (x ** 2 - a) % pk == 0:\n                        res.append(x)\n            return res\n        rv = _sqrt_mod_prime_power(a, p, 1)\n        if not rv:\n            return None\n        r = rv[0]\n        fr = r ** 2 - a\n        n = 1\n        px = p\n        while 1:\n            n1 = n\n            n1 *= 2\n            if n1 > k:\n                break\n            n = n1\n            px = px ** 2\n            frinv = igcdex(2 * r, px)[0]\n            r = (r - fr * frinv) % px\n            fr = r ** 2 - a\n        if n < k:\n            px = p ** k\n            frinv = igcdex(2 * r, px)[0]\n            r = (r - fr * frinv) % px\n        return [r, px - r]",
    ".sympy.polys.domains.domain.py@@Domain.__call__": "def __call__(self, *args):\n    return self.new(*args)",
    ".sympy.polys.domains.domain.py@@Domain.new": "def new(self, *args):\n    return self.dtype(*args)",
    ".sympy.polys.galoistools.py@@gf_crt1": "def gf_crt1(M, K):\n    E, S = ([], [])\n    p = prod(M, start=K.one)\n    for m in M:\n        E.append(p // m)\n        S.append(K.gcdex(E[-1], m)[0] % m)\n    return (p, E, S)",
    ".sympy.core.mul.py@@prod": "def prod(a, start=1):\n    return reduce(operator.mul, a, start)",
    ".sympy.ntheory.residue_ntheory.py@@_product": "def _product(*iters):\n    import itertools\n    inf_iters = tuple((itertools.cycle(enumerate(it)) for it in iters))\n    num_iters = len(inf_iters)\n    cur_val = [None] * num_iters\n    first_v = True\n    while True:\n        i, p = (0, num_iters)\n        while p and (not i):\n            p -= 1\n            i, cur_val[p] = next(inf_iters[p])\n        if not p and (not i):\n            if first_v:\n                first_v = False\n            else:\n                break\n        yield cur_val",
    ".sympy.polys.galoistools.py@@gf_crt2": "def gf_crt2(U, M, p, E, S, K):\n    v = K.zero\n    for u, m, e, s in zip(U, M, E, S):\n        v += e * (u * s % m)\n    return v % p",
    ".sympy.solvers.diophantine.py@@descent": "def descent(A, B):\n    if abs(A) > abs(B):\n        x, y, z = descent(B, A)\n        return (x, z, y)\n    if B == 1:\n        return (1, 0, 1)\n    if A == 1:\n        return (1, 1, 0)\n    if B == -A:\n        return (0, 1, 1)\n    if B == A:\n        x, z, y = descent(-1, A)\n        return (A * y, z, x)\n    w = sqrt_mod(A, B)\n    x_0, z_0 = gaussian_reduce(w, A, B)\n    t = (x_0 ** 2 - A * z_0 ** 2) // B\n    t_2 = square_factor(t)\n    t_1 = t // t_2 ** 2\n    x_1, z_1, y_1 = descent(A, t_1)\n    return _remove_gcd(x_0 * x_1 + A * z_0 * z_1, z_0 * x_1 + x_0 * z_1, t_1 * t_2 * y_1)",
    ".sympy.core.numbers.py@@One.__abs__": "def __abs__():\n    return S.One",
    ".sympy.core.numbers.py@@Integer.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s > %s' % (self, other))\n    if isinstance(other, Integer):\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    ".sympy.solvers.diophantine.py@@_rational_pq": "def _rational_pq(a, b):\n    return _remove_gcd(sign(b) * a, abs(b))",
    ".sympy.functions.elementary.complexes.py@@sign.eval": "def eval(cls, arg):\n    if arg.is_Mul:\n        c, args = arg.as_coeff_mul()\n        unk = []\n        s = sign(c)\n        for a in args:\n            if a.is_negative:\n                s = -s\n            elif a.is_positive:\n                pass\n            else:\n                ai = im(a)\n                if a.is_imaginary and ai.is_comparable:\n                    s *= S.ImaginaryUnit\n                    if ai.is_negative:\n                        s = -s\n                else:\n                    unk.append(a)\n        if c is S.One and len(unk) == len(args):\n            return None\n        return s * cls(arg._new_rawargs(*unk))\n    if arg is S.NaN:\n        return S.NaN\n    if arg.is_zero:\n        return S.Zero\n    if arg.is_positive:\n        return S.One\n    if arg.is_negative:\n        return S.NegativeOne\n    if arg.is_Function:\n        if arg.func is sign:\n            return arg\n    if arg.is_imaginary:\n        if arg.is_Pow and arg.exp is S.Half:\n            return S.ImaginaryUnit\n        arg2 = -S.ImaginaryUnit * arg\n        if arg2.is_positive:\n            return S.ImaginaryUnit\n        if arg2.is_negative:\n            return -S.ImaginaryUnit",
    ".sympy.core.numbers.py@@NegativeOne.__abs__": "def __abs__():\n    return S.One",
    ".sympy.solvers.diophantine.py@@holzer": "def holzer(x, y, z, a, b, c):\n    if _odd(c):\n        k = 2 * c\n    else:\n        k = c // 2\n    small = a * b * c\n    step = 0\n    while True:\n        t1, t2, t3 = (a * x ** 2, b * y ** 2, c * z ** 2)\n        if t1 + t2 != t3:\n            if step == 0:\n                raise ValueError('bad starting solution')\n            break\n        x_0, y_0, z_0 = (x, y, z)\n        if max(t1, t2, t3) <= small:\n            break\n        uv = u, v = base_solution_linear(k, y_0, -x_0)\n        if None in uv:\n            break\n        p, q = (-(a * u * x_0 + b * v * y_0), c * z_0)\n        r = Rational(p, q)\n        if _even(c):\n            w = _nint_or_floor(p, q)\n            assert abs(w - r) <= S.Half\n        else:\n            w = p // q\n            if _odd(a * u + b * v + c * w):\n                w += 1\n            assert abs(w - r) <= S.One\n        A = a * u ** 2 + b * v ** 2 + c * w ** 2\n        B = a * u * x_0 + b * v * y_0 + c * w * z_0\n        x = Rational(x_0 * A - 2 * u * B, k)\n        y = Rational(y_0 * A - 2 * v * B, k)\n        z = Rational(z_0 * A - 2 * w * B, k)\n        assert all((i.is_Integer for i in (x, y, z)))\n        step += 1\n    return tuple([int(i) for i in (x_0, y_0, z_0)])",
    ".sympy.solvers.diophantine.py@@_odd": "def _odd(i):\n    return i % 2 != 0",
    ".sympy.core.numbers.py@@Integer.__mod__": "def __mod__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p % other)\n        elif isinstance(other, Integer):\n            return Integer(self.p % other.p)\n        return Rational.__mod__(self, other)\n    return Rational.__mod__(self, other)",
    ".sympy.core.numbers.py@@Zero._eval_power": "def _eval_power(self, expt):\n    if expt.is_positive:\n        return self\n    if expt.is_negative:\n        return S.ComplexInfinity\n    if expt.is_real is False:\n        return S.NaN\n    coeff, terms = expt.as_coeff_Mul()\n    if coeff.is_negative:\n        return S.ComplexInfinity ** terms\n    if coeff is not S.One:\n        return self ** terms",
    ".sympy.core.numbers.py@@Integer.__le__": "def __le__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s <= %s' % (self, other))\n    if isinstance(other, Integer):\n        return _sympify(self.p <= other.p)\n    return Rational.__le__(self, other)",
    ".sympy.solvers.diophantine.py@@reconstruct": "def reconstruct(A, B, z):\n    f = factorint(igcd(A, B))\n    for p, e in f.items():\n        if e != 1:\n            raise ValueError('a and b should be square-free')\n        z *= p\n    return z",
    ".sympy.core.numbers.py@@ilcm": "def ilcm(*args):\n    if len(args) < 2:\n        raise TypeError('ilcm() takes at least 2 arguments (%s given)' % len(args))\n    if 0 in args:\n        return 0\n    a = args[0]\n    for b in args[1:]:\n        a = a * b // igcd(a, b)\n    return a",
    ".sympy.core.numbers.py@@Zero.__abs__": "def __abs__():\n    return S.Zero",
    ".sympy.core.numbers.py@@NegativeInfinity.__sub__": "def __sub__(self, other):\n    if isinstance(other, Number):\n        if other is S.NegativeInfinity or other is S.NaN:\n            return S.NaN\n        elif other.is_Float:\n            if other == Float('-inf'):\n                return Float('nan')\n            else:\n                return Float('-inf')\n        else:\n            return S.NegativeInfinity\n    return NotImplemented"
}