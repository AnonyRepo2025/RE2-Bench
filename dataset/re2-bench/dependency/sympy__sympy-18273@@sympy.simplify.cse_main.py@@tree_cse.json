{
    ".sympy.core.compatibility.py@@iterable": "def iterable(i, exclude=(string_types, dict, NotIterable)):\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    ".sympy.core.expr.py@@Expr.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.expr.py@@Expr.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n        if not isinstance(other, Expr):\n            return False\n    except (SympifyError, SyntaxError):\n        return False\n    if not (self.is_Number and other.is_Number) and type(self) != type(other):\n        return False\n    a, b = (self._hashable_content(), other._hashable_content())\n    if a != b:\n        return False\n    for a, b in zip(a, b):\n        if not isinstance(a, Expr):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is not None:\n        return a\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    cls = getattr(a, '__class__', None)\n    if cls is None:\n        cls = type(a)\n    conv = converter.get(cls, None)\n    if conv is not None:\n        return conv(a)\n    for superclass in getmro(cls):\n        try:\n            return converter[superclass](a)\n        except KeyError:\n            continue\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if type(a).__module__ == 'numpy':\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from ..tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                coerced = coerce(a)\n            except (TypeError, ValueError):\n                continue\n            except AttributeError:\n                continue\n            try:\n                return sympify(coerced)\n            except SympifyError:\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.expr.py@@Expr._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.function.py@@Subs.__hash__": "def __hash__(self):\n    return super(Subs, self).__hash__()",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return dict(((key, value) for key, value in self._assumptions.items() if value is not None))",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.__iter__": "def __iter__(self):\n    yield self.expr\n    yield self.cond",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.expr": "def expr(self):\n    return self.args[0]"
}