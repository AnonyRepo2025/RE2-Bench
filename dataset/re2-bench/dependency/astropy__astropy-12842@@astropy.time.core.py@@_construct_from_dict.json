{
    ".astropy.time.core.py@@Time.__new__": "def __new__(cls, val, val2=None, format=None, scale=None, precision=None, in_subfmt=None, out_subfmt=None, location=None, copy=False):\n    if isinstance(val, Time):\n        self = val.replicate(format=format, copy=copy, cls=cls)\n    else:\n        self = super().__new__(cls)\n    return self",
    ".astropy.time.core.py@@Time.__init__": "def __init__(self, val, val2=None, format=None, scale=None, precision=None, in_subfmt=None, out_subfmt=None, location=None, copy=False):\n    if location is not None:\n        from astropy.coordinates import EarthLocation\n        if isinstance(location, EarthLocation):\n            self.location = location\n        else:\n            self.location = EarthLocation(*location)\n        if self.location.size == 1:\n            self.location = self.location.squeeze()\n    elif not hasattr(self, 'location'):\n        self.location = None\n    if isinstance(val, Time):\n        if precision is not None:\n            self._time.precision = precision\n        if in_subfmt is not None:\n            self._time.in_subfmt = in_subfmt\n        if out_subfmt is not None:\n            self._time.out_subfmt = out_subfmt\n        self.SCALES = TIME_TYPES[self.scale]\n        if scale is not None:\n            self._set_scale(scale)\n    else:\n        self._init_from_vals(val, val2, format, scale, copy, precision, in_subfmt, out_subfmt)\n        self.SCALES = TIME_TYPES[self.scale]\n    if self.location is not None and (self.location.size > 1 and self.location.shape != self.shape):\n        try:\n            self.location = np.broadcast_to(self.location, self.shape, subok=True)\n        except Exception as err:\n            raise ValueError('The location with shape {} cannot be broadcast against time with shape {}. Typically, either give a single location or one for each time.'.format(self.location.shape, self.shape)) from err",
    ".astropy.time.core.py@@TimeBase._init_from_vals": "def _init_from_vals(self, val, val2, format, scale, copy, precision=None, in_subfmt=None, out_subfmt=None):\n    if precision is None:\n        precision = 3\n    if in_subfmt is None:\n        in_subfmt = '*'\n    if out_subfmt is None:\n        out_subfmt = '*'\n    val = _make_array(val, copy)\n    if val2 is not None:\n        val2 = _make_array(val2, copy)\n        try:\n            np.broadcast(val, val2)\n        except ValueError:\n            raise ValueError('Input val and val2 have inconsistent shape; they cannot be broadcast together.')\n    if scale is not None:\n        if not (isinstance(scale, str) and scale.lower() in self.SCALES):\n            raise ScaleValueError('Scale {!r} is not in the allowed scales {}'.format(scale, sorted(self.SCALES)))\n    mask, val, val2 = _check_for_masked_and_fill(val, val2)\n    self._time = self._get_time_fmt(val, val2, format, scale, precision, in_subfmt, out_subfmt)\n    self._format = self._time.name\n    if hasattr(self._time, '_location'):\n        self.location = self._time._location\n        del self._time._location\n    if mask is not False:\n        mask = np.broadcast_to(mask, self._time.jd2.shape)\n        self._time.jd1[mask] = 2451544.5\n        self._time.jd2[mask] = np.nan",
    ".astropy.time.core.py@@_make_array": "def _make_array(val, copy=False):\n    if isinstance(val, (tuple, list)) and len(val) > 0 and isinstance(val[0], Time):\n        dtype = object\n    else:\n        dtype = None\n    val = np.array(val, copy=copy, subok=True, dtype=dtype)\n    if val.dtype.kind == 'f' and val.dtype.itemsize >= np.dtype(np.float64).itemsize:\n        pass\n    elif val.dtype.kind in 'OSUMaV':\n        pass\n    else:\n        val = np.asanyarray(val, dtype=np.float64)\n    return val",
    ".astropy.time.core.py@@_check_for_masked_and_fill": "def _check_for_masked_and_fill(val, val2):\n\n    def get_as_filled_ndarray(mask, val):\n        fill_value = None\n        if np.any(val.mask):\n            mask = mask | val.mask\n            val_unmasked = val.compressed()\n            if len(val_unmasked) > 0:\n                fill_value = val_unmasked[0]\n        val = val.filled(fill_value)\n        return (mask, val)\n    mask = False\n    if isinstance(val, np.ma.MaskedArray):\n        mask, val = get_as_filled_ndarray(mask, val)\n    if isinstance(val2, np.ma.MaskedArray):\n        mask, val2 = get_as_filled_ndarray(mask, val2)\n    return (mask, val, val2)",
    ".astropy.time.core.py@@TimeBase._get_time_fmt": "def _get_time_fmt(self, val, val2, format, scale, precision, in_subfmt, out_subfmt):\n    if format is None and (val.dtype.kind in ('S', 'U', 'O', 'M') or val.dtype.names):\n        formats = [(name, cls) for name, cls in self.FORMATS.items() if issubclass(cls, TimeUnique)]\n        formats.append(('astropy_time', TimeAstropyTime))\n    elif not (isinstance(format, str) and format.lower() in self.FORMATS):\n        if format is None:\n            raise ValueError('No time format was given, and the input is not unique')\n        else:\n            raise ValueError('Format {!r} is not one of the allowed formats {}'.format(format, sorted(self.FORMATS)))\n    else:\n        formats = [(format, self.FORMATS[format])]\n    assert formats\n    problems = {}\n    for name, cls in formats:\n        try:\n            return cls(val, val2, scale, precision, in_subfmt, out_subfmt)\n        except UnitConversionError:\n            raise\n        except (ValueError, TypeError) as err:\n            if len(formats) == 1:\n                raise ValueError(f'Input values did not match the format class {format}:' + os.linesep + f'{err.__class__.__name__}: {err}') from err\n            else:\n                problems[name] = err\n    else:\n        raise ValueError(f'Input values did not match any of the formats where the format keyword is optional: {problems}') from problems[formats[0][0]]",
    ".astropy.time.formats.py@@TimeFormat.__init__": "def __init__(self, val1, val2, scale, precision, in_subfmt, out_subfmt, from_jd=False):\n    self.scale = scale\n    self.precision = precision\n    self.in_subfmt = in_subfmt\n    self.out_subfmt = out_subfmt\n    self._jd1, self._jd2 = (None, None)\n    if from_jd:\n        self.jd1 = val1\n        self.jd2 = val2\n    else:\n        val1, val2 = self._check_val_type(val1, val2)\n        self.set_jds(val1, val2)",
    ".astropy.time.formats.py@@TimeFormat.scale": "def scale(self):\n    self._scale = self._check_scale(self._scale)\n    return self._scale",
    ".astropy.time.formats.py@@TimeFormat.in_subfmt": "def in_subfmt(self):\n    return self._in_subfmt",
    ".astropy.time.formats.py@@TimeFormat._select_subfmts": "def _select_subfmts(cls, pattern):\n    if not isinstance(pattern, str):\n        raise ValueError('subfmt attribute must be a string')\n    elif pattern == '*':\n        return cls.subfmts\n    subfmts = [x for x in cls.subfmts if fnmatch.fnmatchcase(x[0], pattern)]\n    if len(subfmts) == 0:\n        if len(cls.subfmts) == 0:\n            raise ValueError(f'subformat not allowed for format {cls.name}')\n        else:\n            subfmt_names = [x[0] for x in cls.subfmts]\n            raise ValueError(f'subformat {pattern!r} must match one of {subfmt_names} for format {cls.name}')\n    return subfmts",
    ".astropy.time.formats.py@@TimeFormat.out_subfmt": "def out_subfmt(self):\n    return self._out_subfmt",
    ".astropy.time.formats.py@@TimeNumeric._check_val_type": "def _check_val_type(self, val1, val2):\n    orig_val2_is_none = val2 is None\n    if val1.dtype.kind == 'f':\n        val1, val2 = super()._check_val_type(val1, val2)\n    elif not orig_val2_is_none or not (val1.dtype.kind in 'US' or (val1.dtype.kind == 'O' and all((isinstance(v, Decimal) for v in val1.flat)))):\n        raise TypeError('for {} class, input should be doubles, string, or Decimal, and second values are only allowed for doubles.'.format(self.name))\n    val_dtype = val1.dtype if orig_val2_is_none else np.result_type(val1.dtype, val2.dtype)\n    subfmts = self._select_subfmts(self.in_subfmt)\n    for subfmt, dtype, convert, _ in subfmts:\n        if np.issubdtype(val_dtype, dtype):\n            break\n    else:\n        raise ValueError('input type not among selected sub-formats.')\n    if convert is not None:\n        try:\n            val1, val2 = convert(val1, val2)\n        except Exception:\n            raise TypeError('for {} class, input should be (long) doubles, string, or Decimal, and second values are only allowed for (long) doubles.'.format(self.name))\n    return (val1, val2)",
    ".astropy.time.formats.py@@TimeFormat._check_val_type": "def _check_val_type(self, val1, val2):\n    isfinite1 = np.isfinite(val1)\n    if val1.size > 1:\n        isfinite1 = isfinite1.all()\n    elif val1.size == 0:\n        isfinite1 = False\n    ok1 = val1.dtype.kind == 'f' and val1.dtype.itemsize >= 8 and isfinite1 or val1.size == 0\n    ok2 = val2 is None or (val2.dtype.kind == 'f' and val2.dtype.itemsize >= 8 and (not np.any(np.isinf(val2)))) or val2.size == 0\n    if not (ok1 and ok2):\n        raise TypeError('Input values for {} class must be finite doubles'.format(self.name))\n    if getattr(val1, 'unit', None) is not None:\n        val1 = u.Quantity(val1, copy=False)\n        if val2 is not None:\n            val2 = u.Quantity(val2, copy=False)\n        try:\n            val1, val2 = quantity_day_frac(val1, val2)\n        except u.UnitsError:\n            raise u.UnitConversionError('only quantities with time units can be used to instantiate Time instances.')\n        factor = 1.0 / getattr(self, 'unit', 1.0)\n        if factor != 1.0:\n            val1, carry = two_product(val1, factor)\n            carry += val2 * factor\n            val1, val2 = two_sum(val1, carry)\n    elif getattr(val2, 'unit', None) is not None:\n        raise TypeError('Cannot mix float and Quantity inputs')\n    if val2 is None:\n        val2 = np.array(0, dtype=val1.dtype)\n\n    def asarray_or_scalar(val):\n        return np.asarray(val) if isinstance(val, np.ndarray) else val\n    return (asarray_or_scalar(val1), asarray_or_scalar(val2))",
    ".astropy.table.column.py@@BaseColumn.__array_finalize__": "def __array_finalize__(self, obj):\n    if obj is None:\n        return\n    if callable(super().__array_finalize__):\n        super().__array_finalize__(obj)\n    self.parent_table = None\n    if not hasattr(self, 'indices'):\n        self.indices = []\n    self._copy_attrs(obj)\n    if 'info' in getattr(obj, '__dict__', {}):\n        self.info = obj.info",
    ".astropy.table.column.py@@Column.__setattr__": "def __setattr__(self, item, value):\n    if not isinstance(self, MaskedColumn) and item == 'mask':\n        raise AttributeError('cannot set mask value to a column in non-masked Table')\n    super().__setattr__(item, value)\n    if item == 'unit' and issubclass(self.dtype.type, np.number):\n        try:\n            converted = self.parent_table._convert_col_for_table(self)\n        except AttributeError:\n            pass\n        else:\n            if converted is not self:\n                self.parent_table.replace_column(self.name, converted)",
    ".astropy.table.column.py@@BaseColumn.parent_table": "def parent_table(self):\n    if getattr(self, '_parent_table', None) is None:\n        return None\n    else:\n        return self._parent_table()",
    ".astropy.table.column.py@@BaseColumn._copy_attrs": "def _copy_attrs(self, obj):\n    for attr in ('name', 'unit', '_format', 'description'):\n        val = getattr(obj, attr, None)\n        setattr(self, attr, val)\n    obj_meta = getattr(obj, 'meta', None)\n    if obj_meta:\n        self.meta = obj_meta.copy()",
    ".astropy.table.column.py@@BaseColumn.name": "def name(self):\n    return self._name",
    ".astropy.table.column.py@@BaseColumn.unit": "def unit(self):\n    return self._unit",
    ".astropy.utils.metadata.py@@MetaData.__get__": "def __get__(self, instance, owner):\n    if instance is None:\n        return self\n    if not hasattr(instance, '_meta'):\n        instance._meta = OrderedDict()\n    return instance._meta",
    ".astropy.utils.data_info.py@@DataInfo.__get__": "def __get__(self, instance, owner_cls):\n    if instance is None:\n        self._parent_cls = owner_cls\n        return self\n    info = instance.__dict__.get('info')\n    if info is None:\n        info = instance.__dict__['info'] = self.__class__(bound=True)\n    info._parent_ref = weakref.ref(instance)\n    return info",
    ".astropy.utils.data_info.py@@BaseColumnInfo.__set__": "def __set__(self, instance, value):\n    try:\n        if not instance.shape:\n            return\n    except AttributeError:\n        pass\n    super().__set__(instance, value)",
    ".astropy.utils.data_info.py@@DataInfo.__set__": "def __set__(self, instance, value):\n    if instance is None:\n        raise ValueError('cannot set unbound descriptor')\n    if isinstance(value, DataInfo):\n        info = instance.__dict__['info'] = self.__class__(bound=True)\n        attr_names = info.attr_names\n        if value.__class__ is self.__class__:\n            attr_names = attr_names & set(value._attrs)\n        else:\n            attr_names = attr_names & value.attr_names - value._attrs_no_copy\n        for attr in attr_names - info.attrs_from_parent - info._attrs_no_copy:\n            info._attrs[attr] = deepcopy(getattr(value, attr))\n    else:\n        raise TypeError('info must be set with a DataInfo instance')",
    ".astropy.utils.data_info.py@@BaseColumnInfo.__init__": "def __init__(self, bound=False):\n    super().__init__(bound=bound)\n    if bound:\n        self._format_funcs = {}",
    ".astropy.utils.data_info.py@@DataInfo.__init__": "def __init__(self, bound=False):\n    if bound:\n        self._attrs = {}",
    ".astropy.table.column.py@@BaseColumn.__array_wrap__": "def __array_wrap__(self, out_arr, context=None):\n    out_arr = super().__array_wrap__(out_arr, context)\n    if self.shape != out_arr.shape or (isinstance(out_arr, BaseColumn) and (context is not None and context[0] in _comparison_functions)):\n        return out_arr.data[()]\n    else:\n        return out_arr",
    ".astropy.table.column.py@@BaseColumn.data": "def data(self):\n    return self.view(np.ndarray)",
    ".astropy.time.formats.py@@TimeFormat.asarray_or_scalar": "def asarray_or_scalar(val):\n    return np.asarray(val) if isinstance(val, np.ndarray) else val",
    ".astropy.time.formats.py@@TimeMJD.set_jds": "def set_jds(self, val1, val2):\n    self._check_scale(self._scale)\n    jd1, jd2 = day_frac(val1, val2)\n    jd1 += erfa.DJM0\n    self.jd1, self.jd2 = day_frac(jd1, jd2)",
    ".astropy.time.formats.py@@TimeFormat._check_scale": "def _check_scale(self, scale):\n    if scale is None:\n        scale = self._default_scale\n    if scale not in TIME_SCALES:\n        raise ScaleValueError(\"Scale value '{}' not in allowed values {}\".format(scale, TIME_SCALES))\n    return scale",
    ".astropy.time.utils.py@@day_frac": "def day_frac(val1, val2, factor=None, divisor=None):\n    sum12, err12 = two_sum(val1, val2)\n    if factor is not None:\n        sum12, carry = two_product(sum12, factor)\n        carry += err12 * factor\n        sum12, err12 = two_sum(sum12, carry)\n    if divisor is not None:\n        q1 = sum12 / divisor\n        p1, p2 = two_product(q1, divisor)\n        d1, d2 = two_sum(sum12, -p1)\n        d2 += err12\n        d2 -= p2\n        q2 = (d1 + d2) / divisor\n        sum12, err12 = two_sum(q1, q2)\n    day = np.round(sum12)\n    extra, frac = two_sum(sum12, -day)\n    frac += extra + err12\n    excess = np.round(frac)\n    day += excess\n    extra, frac = two_sum(sum12, -day)\n    frac += extra + err12\n    return (day, frac)",
    ".astropy.time.utils.py@@two_sum": "def two_sum(a, b):\n    x = a + b\n    eb = x - a\n    ea = x - eb\n    eb = b - eb\n    ea = a - ea\n    return (x, ea + eb)",
    ".astropy.time.formats.py@@TimeFormat.jd1": "def jd1(self):\n    return self._jd1",
    ".astropy.time.formats.py@@_validate_jd_for_storage": "def _validate_jd_for_storage(jd):\n    if isinstance(jd, (float, int)):\n        return np.array(jd, dtype=np.float_)\n    if isinstance(jd, np.generic) and (jd.dtype.kind == 'f' and jd.dtype.itemsize <= 8 or jd.dtype.kind in 'iu'):\n        return np.array(jd, dtype=np.float_)\n    elif isinstance(jd, np.ndarray) and jd.dtype.kind == 'f' and (jd.dtype.itemsize == 8):\n        return jd\n    else:\n        raise TypeError(f'JD values must be arrays (possibly zero-dimensional) of floats but we got {jd!r} of type {type(jd)}')",
    ".astropy.time.formats.py@@TimeFormat.jd2": "def jd2(self):\n    return self._jd2",
    ".astropy.time.formats.py@@_broadcast_writeable": "def _broadcast_writeable(jd1, jd2):\n    if jd1.shape == jd2.shape:\n        return (jd1, jd2)\n    shape = np.broadcast(jd1, jd2).shape\n    if jd1.shape == shape:\n        s_jd1 = jd1\n    else:\n        s_jd1 = np.require(np.broadcast_to(jd1, shape), requirements=['C', 'W'])\n    if jd2.shape == shape:\n        s_jd2 = jd2\n    else:\n        s_jd2 = np.require(np.broadcast_to(jd2, shape), requirements=['C', 'W'])\n    return (s_jd1, s_jd2)",
    ".astropy.time.core.py@@TimeBase.scale": "def scale(self):\n    return self._time.scale",
    ".astropy.time.formats.py@@TimeString._check_val_type": "def _check_val_type(self, val1, val2):\n    if val1.dtype.kind not in ('S', 'U') and val1.size:\n        raise TypeError(f'Input values for {self.name} class must be strings')\n    if val2 is not None:\n        raise ValueError(f'{self.name} objects do not accept a val2 but you provided {val2}')\n    return (val1, None)",
    ".astropy.time.formats.py@@TimeString.set_jds": "def set_jds(self, val1, val2):\n    if self.in_subfmt != '*' or '_fast_parser' not in self.__class__.__dict__ or conf.use_fast_parser == 'False':\n        jd1, jd2 = self.get_jds_python(val1, val2)\n    else:\n        try:\n            jd1, jd2 = self.get_jds_fast(val1, val2)\n        except Exception:\n            if conf.use_fast_parser == 'force':\n                raise\n            else:\n                jd1, jd2 = self.get_jds_python(val1, val2)\n    self.jd1 = jd1\n    self.jd2 = jd2",
    ".astropy.config.configuration.py@@ConfigItem.__get__": "def __get__(self, obj, objtype=None):\n    if obj is None:\n        return self\n    return self()",
    ".astropy.config.configuration.py@@ConfigItem.__call__": "def __call__(self):\n\n    def section_name(section):\n        if section == '':\n            return 'at the top-level'\n        else:\n            return f'in section [{section}]'\n    options = []\n    sec = get_config(self.module, rootname=self.rootname)\n    if self.name in sec:\n        options.append((sec[self.name], self.module, self.name))\n    for alias in self.aliases:\n        module, name = alias.rsplit('.', 1)\n        sec = get_config(module, rootname=self.rootname)\n        if '.' in module:\n            filename, module = module.split('.', 1)\n        else:\n            filename = module\n            module = ''\n        if name in sec:\n            if '.' in self.module:\n                new_module = self.module.split('.', 1)[1]\n            else:\n                new_module = ''\n            warn(\"Config parameter '{}' {} of the file '{}' is deprecated. Use '{}' {} instead.\".format(name, section_name(module), get_config_filename(filename, rootname=self.rootname), self.name, section_name(new_module)), AstropyDeprecationWarning)\n            options.append((sec[name], module, name))\n    if len(options) == 0:\n        self.set(self.defaultvalue)\n        options.append((self.defaultvalue, None, None))\n    if len(options) > 1:\n        filename, sec = self.module.split('.', 1)\n        warn(\"Config parameter '{}' {} of the file '{}' is given by more than one alias ({}). Using the first.\".format(self.name, section_name(sec), get_config_filename(filename, rootname=self.rootname), ', '.join(['.'.join(x[1:3]) for x in options if x[1] is not None])), AstropyDeprecationWarning)\n    val = options[0][0]\n    try:\n        return self._validate_val(val)\n    except validate.ValidateError as e:\n        raise TypeError('Configuration value not valid:' + e.args[0])",
    ".astropy.config.configuration.py@@get_config": "def get_config(packageormod=None, reload=False, rootname=None):\n    if packageormod is None:\n        packageormod = find_current_module(2)\n        if packageormod is None:\n            msg1 = 'Cannot automatically determine get_config module, '\n            msg2 = 'because it is not called from inside a valid module'\n            raise RuntimeError(msg1 + msg2)\n        else:\n            packageormod = packageormod.__name__\n        _autopkg = True\n    else:\n        _autopkg = False\n    packageormodspl = packageormod.split('.')\n    pkgname = packageormodspl[0]\n    secname = '.'.join(packageormodspl[1:])\n    if rootname is None:\n        if _autopkg:\n            rootname = pkgname\n        else:\n            rootname = 'astropy'\n    cobj = _cfgobjs.get(pkgname, None)\n    if cobj is None or reload:\n        cfgfn = None\n        try:\n            if _override_config_file is not None:\n                cfgfn = _override_config_file\n            else:\n                cfgfn = path.join(get_config_dir(rootname=rootname), pkgname + '.cfg')\n            cobj = configobj.ConfigObj(cfgfn, interpolation=False)\n        except OSError:\n            cobj = configobj.ConfigObj(interpolation=False)\n        _cfgobjs[pkgname] = cobj\n    if secname:\n        if secname not in cobj:\n            cobj[secname] = {}\n        return cobj[secname]\n    else:\n        return cobj",
    ".astropy.extern.configobj.configobj.py@@Section.__getitem__": "def __getitem__(self, key):\n    val = dict.__getitem__(self, key)\n    if self.main.interpolation:\n        if isinstance(val, str):\n            return self._interpolate(key, val)\n        if isinstance(val, list):\n\n            def _check(entry):\n                if isinstance(entry, str):\n                    return self._interpolate(key, entry)\n                return entry\n            new = [_check(entry) for entry in val]\n            if new != val:\n                return new\n    return val",
    ".astropy.config.configuration.py@@ConfigItem._validate_val": "def _validate_val(self, val):\n    return self._validator.check(self.cfgtype, val)",
    ".astropy.extern.configobj.validate.py@@Validator.check": "def check(self, check, value, missing=False):\n    fun_name, fun_args, fun_kwargs, default = self._parse_with_caching(check)\n    if missing:\n        if default is None:\n            raise VdtMissingValue()\n        value = self._handle_none(default)\n    if value is None:\n        return None\n    return self._check_value(value, fun_name, fun_args, fun_kwargs)",
    ".astropy.extern.configobj.validate.py@@Validator._parse_with_caching": "def _parse_with_caching(self, check):\n    if check in self._cache:\n        fun_name, fun_args, fun_kwargs, default = self._cache[check]\n        fun_args = list(fun_args)\n        fun_kwargs = dict(fun_kwargs)\n    else:\n        fun_name, fun_args, fun_kwargs, default = self._parse_check(check)\n        fun_kwargs = dict([(str(key), value) for key, value in list(fun_kwargs.items())])\n        self._cache[check] = (fun_name, list(fun_args), dict(fun_kwargs), default)\n    return (fun_name, fun_args, fun_kwargs, default)",
    ".astropy.extern.configobj.validate.py@@Validator._check_value": "def _check_value(self, value, fun_name, fun_args, fun_kwargs):\n    try:\n        fun = self.functions[fun_name]\n    except KeyError:\n        raise VdtUnknownCheckError(fun_name)\n    else:\n        return fun(value, *fun_args, **fun_kwargs)",
    ".astropy.extern.configobj.validate.py@@is_option": "def is_option(value, *options):\n    if not isinstance(value, string_type):\n        raise VdtTypeError(value)\n    if not value in options:\n        raise VdtValueError(value)\n    return value",
    ".astropy.time.formats.py@@TimeString.get_jds_fast": "def get_jds_fast(self, val1, val2):\n    if val1.dtype.kind == 'U':\n        val1_uint32 = val1.view((np.uint32, val1.dtype.itemsize // 4))\n        if np.any(val1_uint32 > 127):\n            raise ValueError('input is not pure ASCII')\n        chars = val1_uint32.astype(_parse_times.dt_u1)\n    else:\n        chars = val1.view((_parse_times.dt_u1, val1.dtype.itemsize))\n    time_struct = self._fast_parser(chars)\n    jd1, jd2 = erfa.dtf2d(self.scale.upper().encode('ascii'), time_struct['year'], time_struct['month'], time_struct['day'], time_struct['hour'], time_struct['minute'], time_struct['second'])\n    return day_frac(jd1, jd2)",
    ".astropy.table.column.py@@_compare": "def _compare(self, other):\n    op = oper\n    if isinstance(self, MaskedColumn) and self.dtype.kind == 'U' and isinstance(other, MaskedColumn) and (other.dtype.kind == 'S'):\n        self, other = (other, self)\n        op = swapped_oper\n    if self.dtype.char == 'S':\n        other = self._encode_str(other)\n    result = getattr(super(Column, self), op)(other)\n    return result.data if isinstance(result, Column) else result",
    ".astropy.time.formats.py@@TimeJD.set_jds": "def set_jds(self, val1, val2):\n    self._check_scale(self._scale)\n    self.jd1, self.jd2 = day_frac(val1, val2)",
    ".astropy.time.core.py@@TimeBase.shape": "def shape(self):\n    return self._time.jd1.shape",
    ".astropy.time.core.py@@TimeBase.format": "def format(self):\n    return self._format",
    ".astropy.time.core.py@@TimeBase.precision": "def precision(self):\n    return self._time.precision",
    ".astropy.time.core.py@@TimeBase.in_subfmt": "def in_subfmt(self):\n    return self._time.in_subfmt",
    ".astropy.time.formats.py@@TimeFormat._get_allowed_subfmt": "def _get_allowed_subfmt(cls, subfmt):\n    try:\n        cls._select_subfmts(subfmt)\n    except ValueError:\n        subfmt = '*'\n    return subfmt",
    ".astropy.time.core.py@@TimeBase.out_subfmt": "def out_subfmt(self):\n    return self._time.out_subfmt",
    ".astropy.time.core.py@@TimeBase.cache": "def cache(self):\n    return self._time.cache",
    ".astropy.utils.decorators.py@@lazyproperty.__delete__": "def __delete__(self, obj):\n    if self.fdel:\n        self.fdel(obj)\n    obj.__dict__.pop(self._key, None)",
    ".astropy.time.core.py@@TimeBase.__getattr__": "def __getattr__(self, attr):\n    if attr in self.SCALES and self.scale is not None:\n        cache = self.cache['scale']\n        if attr not in cache:\n            if attr == self.scale:\n                tm = self\n            else:\n                tm = self.replicate()\n                tm._set_scale(attr)\n                if tm.shape:\n                    tm.writeable = False\n            cache[attr] = tm\n        return cache[attr]\n    elif attr in self.FORMATS:\n        return self.to_value(attr, subfmt=None)\n    elif attr in TIME_SCALES:\n        if self.scale is None:\n            raise ScaleValueError('Cannot convert TimeDelta with undefined scale to any defined scale.')\n        else:\n            raise ScaleValueError(\"Cannot convert {} with scale '{}' to scale '{}'\".format(self.__class__.__name__, self.scale, attr))\n    else:\n        return self.__getattribute__(attr)",
    ".astropy.time.formats.py@@TimeEpochDateString.set_jds": "def set_jds(self, val1, val2):\n    epoch_prefix = self.epoch_prefix\n    to_string = str if val1.dtype.kind == 'U' else lambda x: str(x.item(), encoding='ascii')\n    iterator = np.nditer([val1, None], op_dtypes=[val1.dtype, np.double], flags=['zerosize_ok'])\n    for val, years in iterator:\n        try:\n            time_str = to_string(val)\n            epoch_type, year_str = (time_str[0], time_str[1:])\n            year = float(year_str)\n            if epoch_type.upper() != epoch_prefix:\n                raise ValueError\n        except (IndexError, ValueError, UnicodeEncodeError):\n            raise ValueError(f'Time {val} does not match {self.name} format')\n        else:\n            years[...] = year\n    self._check_scale(self._scale)\n    epoch_to_jd = getattr(erfa, self.epoch_to_jd)\n    jd1, jd2 = epoch_to_jd(iterator.operands[-1])\n    self.jd1, self.jd2 = day_frac(jd1, jd2)",
    ".astropy.time.formats.py@@TimeDecimalYear.set_jds": "def set_jds(self, val1, val2):\n    self._check_scale(self._scale)\n    sum12, err12 = two_sum(val1, val2)\n    iy_start = np.trunc(sum12).astype(int)\n    extra, y_frac = two_sum(sum12, -iy_start)\n    y_frac += extra + err12\n    val = (val1 + val2).astype(np.double)\n    iy_start = np.trunc(val).astype(int)\n    imon = np.ones_like(iy_start)\n    iday = np.ones_like(iy_start)\n    ihr = np.zeros_like(iy_start)\n    imin = np.zeros_like(iy_start)\n    isec = np.zeros_like(y_frac)\n    scale = self.scale.upper().encode('ascii')\n    jd1_start, jd2_start = erfa.dtf2d(scale, iy_start, imon, iday, ihr, imin, isec)\n    jd1_end, jd2_end = erfa.dtf2d(scale, iy_start + 1, imon, iday, ihr, imin, isec)\n    t_start = Time(jd1_start, jd2_start, scale=self.scale, format='jd')\n    t_end = Time(jd1_end, jd2_end, scale=self.scale, format='jd')\n    t_frac = t_start + (t_end - t_start) * y_frac\n    self.jd1, self.jd2 = day_frac(t_frac.jd1, t_frac.jd2)",
    ".astropy.time.core.py@@Time.__sub__": "def __sub__(self, other):\n    other_is_delta = not isinstance(other, Time)\n    if other_is_delta:\n        if not isinstance(other, TimeDelta):\n            try:\n                other = TimeDelta(other)\n            except Exception:\n                return NotImplemented\n        out = self.replicate()\n        if self.scale in other.SCALES:\n            if other.scale not in (out.scale, None):\n                other = getattr(other, out.scale)\n        elif other.scale is None:\n            out._set_scale('tai')\n        else:\n            if self.scale not in TIME_TYPES[other.scale]:\n                raise TypeError(\"Cannot subtract Time and TimeDelta instances with scales '{}' and '{}'\".format(self.scale, other.scale))\n            out._set_scale(other.scale)\n        for attr in ('_delta_ut1_utc', '_delta_tdb_tt'):\n            if hasattr(out, attr):\n                delattr(out, attr)\n    else:\n        if other.scale not in self.SCALES:\n            raise TypeError(\"Cannot subtract Time instances with scales '{}' and '{}'\".format(self.scale, other.scale))\n        self_time = self._time if self.scale in TIME_DELTA_SCALES else self.tai._time\n        out = TimeDelta(self_time.jd1, self_time.jd2, format='jd', scale=self_time.scale)\n        if other.scale != out.scale:\n            other = getattr(other, out.scale)\n    jd1 = out._time.jd1 - other._time.jd1\n    jd2 = out._time.jd2 - other._time.jd2\n    out._time.jd1, out._time.jd2 = day_frac(jd1, jd2)\n    if other_is_delta:\n        out._set_scale(self.scale)\n    return out",
    ".astropy.utils.decorators.py@@lazyproperty.__get__": "def __get__(self, obj, owner=None):\n    try:\n        obj_dict = obj.__dict__\n        val = obj_dict.get(self._key, _NotFound)\n        if val is _NotFound:\n            with self._lock:\n                val = obj_dict.get(self._key, _NotFound)\n                if val is _NotFound:\n                    val = self.fget(obj)\n                    obj_dict[self._key] = val\n        return val\n    except AttributeError:\n        if obj is None:\n            return self\n        raise",
    ".astropy.time.formats.py@@TimeFormat.cache": "def cache(self):\n    return defaultdict(dict)",
    ".astropy.time.core.py@@TimeBase.replicate": "def replicate(self, format=None, copy=False, cls=None):\n    return self._apply('copy' if copy else 'replicate', format=format, cls=cls)",
    ".astropy.time.core.py@@TimeBase._apply": "def _apply(self, method, *args, format=None, cls=None, **kwargs):\n    new_format = self.format if format is None else format\n    if callable(method):\n        apply_method = lambda array: method(array, *args, **kwargs)\n    elif method == 'replicate':\n        apply_method = None\n    else:\n        apply_method = operator.methodcaller(method, *args, **kwargs)\n    jd1, jd2 = (self._time.jd1, self._time.jd2)\n    if apply_method:\n        jd1 = apply_method(jd1)\n        jd2 = apply_method(jd2)\n    tm = super().__new__(cls or self.__class__)\n    tm._time = TimeJD(jd1, jd2, self.scale, precision=0, in_subfmt='*', out_subfmt='*', from_jd=True)\n    for attr in ('_delta_ut1_utc', '_delta_tdb_tt', 'location'):\n        try:\n            val = getattr(self, attr)\n        except AttributeError:\n            continue\n        if apply_method:\n            if getattr(val, 'shape', ()):\n                val = apply_method(val)\n            elif method == 'copy' or method == 'flatten':\n                val = copy.copy(val)\n        setattr(tm, attr, val)\n    if 'info' in self.__dict__:\n        tm.info = self.info\n    if new_format not in tm.FORMATS:\n        raise ValueError(f'format must be one of {list(tm.FORMATS)}')\n    NewFormat = tm.FORMATS[new_format]\n    tm._time = NewFormat(tm._time.jd1, tm._time.jd2, tm._time._scale, precision=self.precision, in_subfmt=NewFormat._get_allowed_subfmt(self.in_subfmt), out_subfmt=NewFormat._get_allowed_subfmt(self.out_subfmt), from_jd=True)\n    tm._format = new_format\n    tm.SCALES = self.SCALES\n    return tm",
    ".astropy.time.core.py@@TimeBase._set_scale": "def _set_scale(self, scale):\n    if scale == self.scale:\n        return\n    if scale not in self.SCALES:\n        raise ValueError('Scale {!r} is not in the allowed scales {}'.format(scale, sorted(self.SCALES)))\n    if scale == 'utc' or self.scale == 'utc':\n        _check_leapsec()\n    xform = (self.scale, scale)\n    xform_sort = tuple(sorted(xform))\n    multi = MULTI_HOPS.get(xform_sort, ())\n    xforms = xform_sort[:1] + multi + xform_sort[-1:]\n    if xform_sort != xform:\n        xforms = tuple(reversed(xforms))\n    jd1, jd2 = (self._time.jd1, self._time.jd2_filled)\n    for sys1, sys2 in zip(xforms[:-1], xforms[1:]):\n        args = [jd1, jd2]\n        for sys12 in ((sys1, sys2), (sys2, sys1)):\n            dt_method = '_get_delta_{}_{}'.format(*sys12)\n            try:\n                get_dt = getattr(self, dt_method)\n            except AttributeError:\n                pass\n            else:\n                args.append(get_dt(jd1, jd2))\n                break\n        conv_func = getattr(erfa, sys1 + sys2)\n        jd1, jd2 = conv_func(*args)\n    jd1, jd2 = day_frac(jd1, jd2)\n    if self.masked:\n        jd2[self.mask] = np.nan\n    self._time = self.FORMATS[self.format](jd1, jd2, scale, self.precision, self.in_subfmt, self.out_subfmt, from_jd=True)",
    ".astropy.time.core.py@@_check_leapsec": "def _check_leapsec():\n    global _LEAP_SECONDS_CHECK\n    if _LEAP_SECONDS_CHECK != _LeapSecondsCheck.DONE:\n        with _LEAP_SECONDS_LOCK:\n            if _LEAP_SECONDS_CHECK == _LeapSecondsCheck.NOT_STARTED:\n                _LEAP_SECONDS_CHECK = _LeapSecondsCheck.RUNNING\n                update_leap_seconds()\n                _LEAP_SECONDS_CHECK = _LeapSecondsCheck.DONE",
    ".astropy.time.formats.py@@TimeFormat.jd2_filled": "def jd2_filled(self):\n    return np.nan_to_num(self.jd2) if self.masked else self.jd2",
    ".astropy.time.formats.py@@TimeFormat.masked": "def masked(self):\n    if 'masked' not in self.cache:\n        self.cache['masked'] = bool(np.any(self.mask))\n    return self.cache['masked']",
    ".astropy.time.formats.py@@TimeFormat.mask": "def mask(self):\n    if 'mask' not in self.cache:\n        self.cache['mask'] = np.isnan(self.jd2)\n        if self.cache['mask'].shape:\n            self.cache['mask'].flags.writeable = False\n    return self.cache['mask']",
    ".astropy.time.core.py@@TimeBase.masked": "def masked(self):\n    return self._time.masked",
    ".astropy.time.core.py@@TimeBase.writeable": "def writeable(self):\n    return self._time.jd1.flags.writeable & self._time.jd2.flags.writeable",
    ".astropy.time.core.py@@TimeDelta.__new__": "def __new__(cls, val, val2=None, format=None, scale=None, precision=None, in_subfmt=None, out_subfmt=None, location=None, copy=False):\n    if isinstance(val, TimeDelta):\n        self = val.replicate(format=format, copy=copy, cls=cls)\n    else:\n        self = super().__new__(cls)\n    return self",
    ".astropy.time.core.py@@TimeDelta.__init__": "def __init__(self, val, val2=None, format=None, scale=None, copy=False):\n    if isinstance(val, TimeDelta):\n        if scale is not None:\n            self._set_scale(scale)\n    else:\n        format = format or self._get_format(val)\n        self._init_from_vals(val, val2, format, scale, copy)\n        if scale is not None:\n            self.SCALES = TIME_DELTA_TYPES[scale]",
    ".astropy.time.formats.py@@TimeDeltaNumeric.set_jds": "def set_jds(self, val1, val2):\n    self._check_scale(self._scale)\n    self.jd1, self.jd2 = day_frac(val1, val2, divisor=1.0 / self.unit)",
    ".astropy.time.formats.py@@TimeDeltaFormat._check_scale": "def _check_scale(self, scale):\n    if scale is not None and scale not in TIME_DELTA_SCALES:\n        raise ScaleValueError(\"Scale value '{}' not in allowed values {}\".format(scale, TIME_DELTA_SCALES))\n    return scale",
    ".astropy.time.utils.py@@two_product": "def two_product(a, b):\n    x = a * b\n    ah, al = split(a)\n    bh, bl = split(b)\n    y1 = ah * bh\n    y = x - y1\n    y2 = al * bh\n    y -= y2\n    y3 = ah * bl\n    y -= y3\n    y4 = al * bl\n    y = y4 - y\n    return (x, y)",
    ".astropy.time.utils.py@@split": "def split(a):\n    c = 134217729.0 * a\n    abig = c - a\n    ah = c - abig\n    al = a - ah\n    return (ah, al)",
    ".astropy.time.core.py@@TimeDelta.__mul__": "def __mul__(self, other):\n    if isinstance(other, Time):\n        raise OperandTypeError(self, other, '*')\n    elif isinstance(other, u.UnitBase) and other == u.dimensionless_unscaled or (isinstance(other, str) and other == ''):\n        return self.copy()\n    try:\n        other = u.Quantity(other, u.dimensionless_unscaled, copy=False)\n    except Exception:\n        try:\n            return self.to(u.day) * other\n        except Exception:\n            return NotImplemented\n    jd1, jd2 = day_frac(self.jd1, self.jd2, factor=other.value)\n    out = TimeDelta(jd1, jd2, format='jd', scale=self.scale)\n    if self.format != 'jd':\n        out = out.replicate(format=self.format)\n    return out",
    ".astropy.units.quantity.py@@Quantity.__new__": "def __new__(cls, value, unit=None, dtype=None, copy=True, order=None, subok=False, ndmin=0):\n    if unit is not None:\n        unit = Unit(unit)\n    if isinstance(value, Quantity):\n        if unit is not None and unit is not value.unit:\n            value = value.to(unit)\n            copy = False\n        if type(value) is not cls and (not (subok and isinstance(value, cls))):\n            value = value.view(cls)\n        if dtype is None and value.dtype.kind in 'iu':\n            dtype = float\n        return np.array(value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin)\n    value_unit = None\n    if not isinstance(value, np.ndarray):\n        if isinstance(value, str):\n            pattern = '\\\\s*[+-]?((\\\\d+\\\\.?\\\\d*)|(\\\\.\\\\d+)|([nN][aA][nN])|([iI][nN][fF]([iI][nN][iI][tT][yY]){0,1}))([eE][+-]?\\\\d+)?[.+-]?'\n            v = re.match(pattern, value)\n            unit_string = None\n            try:\n                value = float(v.group())\n            except Exception:\n                raise TypeError('Cannot parse \"{}\" as a {}. It does not start with a number.'.format(value, cls.__name__))\n            unit_string = v.string[v.end():].strip()\n            if unit_string:\n                value_unit = Unit(unit_string)\n                if unit is None:\n                    unit = value_unit\n        elif isiterable(value) and len(value) > 0:\n            if all((isinstance(v, Quantity) for v in value)):\n                if unit is None:\n                    unit = value[0].unit\n                value = [q.to_value(unit) for q in value]\n                value_unit = unit\n            elif dtype is None and (not hasattr(value, 'dtype')) and isinstance(unit, StructuredUnit):\n                dtype = unit._recursively_get_dtype(value)\n    if value_unit is None:\n        value_unit = getattr(value, 'unit', None)\n        if value_unit is None:\n            if unit is None:\n                unit = cls._default_unit\n            value_unit = unit\n        else:\n            try:\n                value_unit = Unit(value_unit)\n            except Exception as exc:\n                raise TypeError('The unit attribute {!r} of the input could not be parsed as an astropy Unit, raising the following exception:\\n{}'.format(value.unit, exc))\n            if unit is None:\n                unit = value_unit\n            elif unit is not value_unit:\n                copy = False\n    value = np.array(value, dtype=dtype, copy=copy, order=order, subok=True, ndmin=ndmin)\n    if value.dtype.kind in 'OSU' and (not (value.dtype.kind == 'O' and isinstance(value.item(0), numbers.Number))):\n        raise TypeError('The value must be a valid Python or Numpy numeric type.')\n    if dtype is None and value.dtype.kind in 'iuO':\n        value = value.astype(float)\n    if subok:\n        qcls = getattr(unit, '_quantity_class', cls)\n        if issubclass(qcls, cls):\n            cls = qcls\n    value = value.view(cls)\n    value._set_unit(value_unit)\n    if unit is value_unit:\n        return value\n    else:\n        return value.to(unit)",
    ".astropy.units.core.py@@_UnitMetaClass.__call__": "def __call__(self, s='', represents=None, format=None, namespace=None, doc=None, parse_strict='raise'):\n    if hasattr(s, '_get_physical_type_id'):\n        return s\n    from .quantity import Quantity\n    if isinstance(represents, Quantity):\n        if is_effectively_unity(represents.value):\n            represents = represents.unit\n        else:\n            represents = CompositeUnit(represents.value * represents.unit.scale, bases=represents.unit.bases, powers=represents.unit.powers, _error_check=False)\n    if isinstance(s, Quantity):\n        if is_effectively_unity(s.value):\n            s = s.unit\n        else:\n            s = CompositeUnit(s.value * s.unit.scale, bases=s.unit.bases, powers=s.unit.powers, _error_check=False)\n    if isinstance(represents, UnitBase):\n        return super().__call__(s, represents, format=format, namespace=namespace, doc=doc)\n    if isinstance(s, UnitBase):\n        return s\n    elif isinstance(s, (bytes, str)):\n        if len(s.strip()) == 0:\n            return dimensionless_unscaled\n        if format is None:\n            format = unit_format.Generic\n        f = unit_format.get_format(format)\n        if isinstance(s, bytes):\n            s = s.decode('ascii')\n        try:\n            return f.parse(s)\n        except NotImplementedError:\n            raise\n        except Exception as e:\n            if parse_strict == 'silent':\n                pass\n            else:\n                if f is not unit_format.Generic:\n                    format_clause = f.name + ' '\n                else:\n                    format_clause = ''\n                msg = \"'{}' did not parse as {}unit: {} If this is meant to be a custom unit, define it with 'u.def_unit'. To have it recognized inside a file reader or other code, enable it with 'u.add_enabled_units'. For details, see https://docs.astropy.org/en/latest/units/combining_and_defining.html\".format(s, format_clause, str(e))\n                if parse_strict == 'raise':\n                    raise ValueError(msg)\n                elif parse_strict == 'warn':\n                    warnings.warn(msg, UnitsWarning)\n                else:\n                    raise ValueError(\"'parse_strict' must be 'warn', 'raise' or 'silent'\")\n            return UnrecognizedUnit(s)\n    elif isinstance(s, (int, float, np.floating, np.integer)):\n        return CompositeUnit(s, [], [], _error_check=False)\n    elif isinstance(s, tuple):\n        from .structured import StructuredUnit\n        return StructuredUnit(s)\n    elif s is None:\n        raise TypeError('None is not a valid Unit')\n    else:\n        raise TypeError(f'{s} can not be converted to a Unit')",
    ".astropy.units.quantity.py@@Quantity.__array_finalize__": "def __array_finalize__(self, obj):\n    super_array_finalize = super().__array_finalize__\n    if super_array_finalize is not None:\n        super_array_finalize(obj)\n    if obj is None or obj.__class__ is np.ndarray:\n        return\n    if self._unit is None:\n        unit = getattr(obj, '_unit', None)\n        if unit is not None:\n            self._set_unit(unit)\n    if 'info' in obj.__dict__:\n        self.info = obj.info",
    ".astropy.units.quantity.py@@Quantity._set_unit": "def _set_unit(self, unit):\n    if not isinstance(unit, UnitBase):\n        if isinstance(self._unit, StructuredUnit) or isinstance(unit, StructuredUnit):\n            unit = StructuredUnit(unit, self.dtype)\n        else:\n            unit = Unit(str(unit), parse_strict='silent')\n            if not isinstance(unit, (UnitBase, StructuredUnit)):\n                raise UnitTypeError('{} instances require normal units, not {} instances.'.format(type(self).__name__, type(unit)))\n    self._unit = unit",
    ".astropy.time.core.py@@TimeBase.jd1": "def jd1(self):\n    jd1 = self._time.mask_if_needed(self._time.jd1)\n    return self._shaped_like_input(jd1)",
    ".astropy.time.formats.py@@TimeFormat.mask_if_needed": "def mask_if_needed(self, value):\n    if self.masked:\n        value = np.ma.array(value, mask=self.mask, copy=False)\n    return value",
    ".astropy.time.core.py@@TimeBase._shaped_like_input": "def _shaped_like_input(self, value):\n    if self._time.jd1.shape:\n        if isinstance(value, np.ndarray):\n            return value\n        else:\n            raise TypeError(f'JD is an array ({self._time.jd1!r}) but value is not ({value!r})')\n    elif isinstance(value, np.ndarray) and (not value.shape) and (not np.ma.is_masked(value)):\n        if value.dtype.kind == 'M':\n            return value[()]\n        elif value.dtype.fields:\n            return value[()]\n        else:\n            return value.item()\n    else:\n        return value",
    ".astropy.time.core.py@@TimeBase.jd2": "def jd2(self):\n    jd2 = self._time.mask_if_needed(self._time.jd2)\n    return self._shaped_like_input(jd2)",
    ".astropy.units.quantity.py@@Quantity.to_value": "def to_value(self, unit=None, equivalencies=[]):\n    if unit is None or unit is self.unit:\n        value = self.view(np.ndarray)\n    elif not self.dtype.names:\n        unit = Unit(unit)\n        try:\n            scale = self.unit._to(unit)\n        except Exception:\n            value = self._to_value(unit, equivalencies)\n        else:\n            value = self.view(np.ndarray)\n            if not is_effectively_unity(scale):\n                value = value * scale\n    else:\n        value = self._to_value(unit, equivalencies)\n    return value if value.shape else value[()]",
    ".astropy.time.core.py@@Time.__add__": "def __add__(self, other):\n    if isinstance(other, Time):\n        raise OperandTypeError(self, other, '+')\n    if not isinstance(other, TimeDelta):\n        try:\n            other = TimeDelta(other)\n        except Exception:\n            return NotImplemented\n    out = self.replicate()\n    if self.scale in other.SCALES:\n        if other.scale not in (out.scale, None):\n            other = getattr(other, out.scale)\n    elif other.scale is None:\n        out._set_scale('tai')\n    else:\n        if self.scale not in TIME_TYPES[other.scale]:\n            raise TypeError(\"Cannot add Time and TimeDelta instances with scales '{}' and '{}'\".format(self.scale, other.scale))\n        out._set_scale(other.scale)\n    for attr in ('_delta_ut1_utc', '_delta_tdb_tt'):\n        if hasattr(out, attr):\n            delattr(out, attr)\n    jd1 = out._time.jd1 + other._time.jd1\n    jd2 = out._time.jd2 + other._time.jd2\n    out._time.jd1, out._time.jd2 = day_frac(jd1, jd2)\n    out._set_scale(self.scale)\n    return out",
    ".astropy.time.formats.py@@TimeFromEpoch.set_jds": "def set_jds(self, val1, val2):\n    day, frac = day_frac(val1, val2, divisor=1.0 / self.unit)\n    jd1 = self.epoch.jd1 + day\n    jd2 = self.epoch.jd2 + frac\n    if self.epoch.scale == self.scale:\n        jd1_extra = np.round(jd2) if jd2.shape else round(jd2.item())\n        jd1 += jd1_extra\n        jd2 -= jd1_extra\n        self.jd1, self.jd2 = (jd1, jd2)\n        return\n    try:\n        tm = getattr(Time(jd1, jd2, scale=self.epoch_scale, format='jd'), self.scale)\n    except Exception as err:\n        raise ScaleValueError(\"Cannot convert from '{}' epoch scale '{}'to specified scale '{}', got error:\\n{}\".format(self.name, self.epoch_scale, self.scale, err)) from err\n    self.jd1, self.jd2 = day_frac(tm._time.jd1, tm._time.jd2)",
    ".astropy.time.formats.py@@TimeFromEpoch.epoch": "def epoch(self):\n    return self._epoch",
    ".astropy.utils.decorators.py@@classproperty.__get__": "def __get__(self, obj, objtype):\n    if self._lazy:\n        val = self._cache.get(objtype, _NotFound)\n        if val is _NotFound:\n            with self._lock:\n                val = self._cache.get(objtype, _NotFound)\n                if val is _NotFound:\n                    val = self.fget.__wrapped__(objtype)\n                    self._cache[objtype] = val\n    else:\n        val = self.fget.__wrapped__(objtype)\n    return val",
    ".astropy.time.formats.py@@TimePlotDate.epoch": "def epoch(self):\n    try:\n        from matplotlib.dates import get_epoch\n    except ImportError:\n        _epoch = self._epoch\n    else:\n        epoch_utc = get_epoch()\n        from erfa import ErfaWarning\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore', category=ErfaWarning)\n            _epoch = Time(epoch_utc, scale='utc', format='isot')\n        _epoch.format = 'jd'\n    return _epoch",
    ".astropy.time.formats.py@@TimeDatetime._check_val_type": "def _check_val_type(self, val1, val2):\n    if not all((isinstance(val, datetime.datetime) for val in val1.flat)):\n        raise TypeError('Input values for {} class must be datetime objects'.format(self.name))\n    if val2 is not None:\n        raise ValueError(f'{self.name} objects do not accept a val2 but you provided {val2}')\n    return (val1, None)",
    ".astropy.time.formats.py@@TimeDatetime.set_jds": "def set_jds(self, val1, val2):\n    iterator = np.nditer([val1, None, None, None, None, None, None], flags=['refs_ok', 'zerosize_ok'], op_dtypes=[None] + 5 * [np.intc] + [np.double])\n    for val, iy, im, id, ihr, imin, dsec in iterator:\n        dt = val.item()\n        if dt.tzinfo is not None:\n            dt = (dt - dt.utcoffset()).replace(tzinfo=None)\n        iy[...] = dt.year\n        im[...] = dt.month\n        id[...] = dt.day\n        ihr[...] = dt.hour\n        imin[...] = dt.minute\n        dsec[...] = dt.second + dt.microsecond / 1000000.0\n    jd1, jd2 = erfa.dtf2d(self.scale.upper().encode('ascii'), *iterator.operands[1:])\n    self.jd1, self.jd2 = day_frac(jd1, jd2)",
    ".astropy.time.formats.py@@TimeYMDHMS._check_val_type": "def _check_val_type(self, val1, val2):\n    if val2 is not None:\n        raise ValueError('val2 must be None for ymdhms format')\n    ymdhms = ['year', 'month', 'day', 'hour', 'minute', 'second']\n    if val1.dtype.names:\n        val1_as_dict = {name: val1[name] for name in val1.dtype.names}\n    elif val1.shape == (0,):\n        return (None, None)\n    elif val1.dtype.kind == 'O' and val1.shape == () and isinstance(val1.item(), dict):\n        names = val1.item().keys()\n        values = val1.item().values()\n        val1_as_dict = {name: value for name, value in zip(names, np.broadcast_arrays(*values))}\n    else:\n        raise ValueError('input must be dict or table-like')\n    names = val1_as_dict.keys()\n    required_names = ymdhms[:len(names)]\n\n    def comma_repr(vals):\n        return ', '.join((repr(val) for val in vals))\n    bad_names = set(names) - set(ymdhms)\n    if bad_names:\n        raise ValueError(f'{comma_repr(bad_names)} not allowed as YMDHMS key name(s)')\n    if set(names) != set(required_names):\n        raise ValueError(f'for {len(names)} input key names you must supply {comma_repr(required_names)}')\n    return (val1_as_dict, val2)",
    ".astropy.time.formats.py@@TimeYMDHMS.set_jds": "def set_jds(self, val1, val2):\n    if val1 is None:\n        jd1 = np.array([], dtype=np.float64)\n        jd2 = np.array([], dtype=np.float64)\n    else:\n        jd1, jd2 = erfa.dtf2d(self.scale.upper().encode('ascii'), val1['year'], val1.get('month', 1), val1.get('day', 1), val1.get('hour', 0), val1.get('minute', 0), val1.get('second', 0))\n    self.jd1, self.jd2 = day_frac(jd1, jd2)",
    ".astropy.time.formats.py@@TimeDatetime64._check_val_type": "def _check_val_type(self, val1, val2):\n    if not val1.dtype.kind == 'M':\n        if val1.size > 0:\n            raise TypeError('Input values for {} class must be datetime64 objects'.format(self.name))\n        else:\n            val1 = np.array([], 'datetime64[D]')\n    if val2 is not None:\n        raise ValueError(f'{self.name} objects do not accept a val2 but you provided {val2}')\n    return (val1, None)",
    ".astropy.time.formats.py@@TimeDatetime64.set_jds": "def set_jds(self, val1, val2):\n    mask = np.isnat(val1)\n    masked = np.any(mask)\n    if masked:\n        val1 = val1.copy()\n        val1[mask] = '2000'\n    if val1.dtype.name in ['datetime64[M]', 'datetime64[Y]']:\n        val1 = val1.astype('datetime64[D]')\n    val1 = val1.astype('S')\n    super().set_jds(val1, val2)\n    if masked:\n        self.jd2[mask] = np.nan",
    ".astropy.time.formats.py@@TimeString.get_jds_python": "def get_jds_python(self, val1, val2):\n    subfmts = self._select_subfmts(self.in_subfmt)\n    to_string = str if val1.dtype.kind == 'U' else lambda x: str(x.item(), encoding='ascii')\n    iterator = np.nditer([val1, None, None, None, None, None, None], flags=['zerosize_ok'], op_dtypes=[None] + 5 * [np.intc] + [np.double])\n    for val, iy, im, id, ihr, imin, dsec in iterator:\n        val = to_string(val)\n        iy[...], im[...], id[...], ihr[...], imin[...], dsec[...] = self.parse_string(val, subfmts)\n    jd1, jd2 = erfa.dtf2d(self.scale.upper().encode('ascii'), *iterator.operands[1:])\n    jd1, jd2 = day_frac(jd1, jd2)\n    return (jd1, jd2)",
    ".astropy.time.formats.py@@TimeISO.parse_string": "def parse_string(self, timestr, subfmts):\n    if timestr.endswith('Z'):\n        if self.scale != 'utc':\n            raise ValueError(\"Time input terminating in 'Z' must have scale='UTC'\")\n        timestr = timestr[:-1]\n    return super().parse_string(timestr, subfmts)",
    ".astropy.time.formats.py@@TimeString.parse_string": "def parse_string(self, timestr, subfmts):\n    components = ('year', 'mon', 'mday', 'hour', 'min', 'sec')\n    defaults = (None, 1, 1, 0, 0, 0)\n    try:\n        idot = timestr.rindex('.')\n    except Exception:\n        fracsec = 0.0\n    else:\n        timestr, fracsec = (timestr[:idot], timestr[idot:])\n        fracsec = float(fracsec)\n    for _, strptime_fmt_or_regex, _ in subfmts:\n        if isinstance(strptime_fmt_or_regex, str):\n            try:\n                tm = time.strptime(timestr, strptime_fmt_or_regex)\n            except ValueError:\n                continue\n            else:\n                vals = [getattr(tm, 'tm_' + component) for component in components]\n        else:\n            tm = re.match(strptime_fmt_or_regex, timestr)\n            if tm is None:\n                continue\n            tm = tm.groupdict()\n            vals = [int(tm.get(component, default)) for component, default in zip(components, defaults)]\n        vals[-1] = vals[-1] + fracsec\n        return vals\n    else:\n        raise ValueError(f'Time {timestr} does not match {self.name} format')",
    ".astropy.time.formats.py@@TimeFITS.parse_string": "def parse_string(self, timestr, subfmts):\n    for _, regex, _ in subfmts:\n        tm = re.match(regex, timestr)\n        if tm:\n            break\n    else:\n        raise ValueError(f'Time {timestr} does not match {self.name} format')\n    tm = tm.groupdict()\n    if tm['scale'] is not None:\n        warnings.warn('FITS time strings should no longer have embedded time scale.', AstropyDeprecationWarning)\n        fits_scale = tm['scale'].upper()\n        scale = FITS_DEPRECATED_SCALES.get(fits_scale, fits_scale.lower())\n        if scale not in TIME_SCALES:\n            raise ValueError('Scale {!r} is not in the allowed scales {}'.format(scale, sorted(TIME_SCALES)))\n        if self._scale is None:\n            self._scale = scale\n        if scale != self.scale:\n            raise ValueError('Input strings for {} class must all have consistent time scales.'.format(self.name))\n    return [int(tm['year']), int(tm['mon']), int(tm['mday']), int(tm.get('hour', 0)), int(tm.get('min', 0)), float(tm.get('sec', 0.0))]",
    ".astropy.time.formats.py@@TimeBesselianEpoch._check_val_type": "def _check_val_type(self, val1, val2):\n    if hasattr(val1, 'to') and hasattr(val1, 'unit') and (val1.unit is not None):\n        raise ValueError(\"Cannot use Quantities for 'byear' format, as the interpretation would be ambiguous. Use float with Besselian year instead. \")\n    return super()._check_val_type(val1, val2)",
    ".astropy.time.formats.py@@TimeEpochDate.set_jds": "def set_jds(self, val1, val2):\n    self._check_scale(self._scale)\n    epoch_to_jd = getattr(erfa, self.epoch_to_jd)\n    jd1, jd2 = epoch_to_jd(val1 + val2)\n    self.jd1, self.jd2 = day_frac(jd1, jd2)"
}