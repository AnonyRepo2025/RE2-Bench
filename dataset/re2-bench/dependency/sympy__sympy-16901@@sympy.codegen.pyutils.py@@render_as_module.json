{
    ".sympy.printing.pycode.py@@AbstractPythonCodePrinter.__init__": "def __init__(self, settings=None):\n    super(AbstractPythonCodePrinter, self).__init__(settings)\n    std = self._settings['standard']\n    if std is None:\n        import sys\n        std = 'python{}'.format(sys.version_info.major)\n    if std not in ('python2', 'python3'):\n        raise ValueError('Unrecognized python standard : {}'.format(std))\n    self.standard = std\n    self.module_imports = defaultdict(set)\n    self.known_functions = dict(self._kf, **(settings or {}).get('user_functions', {}))\n    self.known_constants = dict(self._kc, **(settings or {}).get('user_constants', {}))",
    ".sympy.printing.codeprinter.py@@CodePrinter.__init__": "def __init__(self, settings=None):\n    super(CodePrinter, self).__init__(settings=settings)\n    if not hasattr(self, 'reserved_words'):\n        self.reserved_words = set()",
    ".sympy.printing.printer.py@@Printer.__init__": "def __init__(self, settings=None):\n    self._str = str\n    self._settings = self._default_settings.copy()\n    self._context = dict()\n    for key, val in self._global_settings.items():\n        if key in self._default_settings:\n            self._settings[key] = val\n    if settings is not None:\n        self._settings.update(settings)\n        if len(self._settings) > len(self._default_settings):\n            for key in self._settings:\n                if key not in self._default_settings:\n                    raise TypeError(\"Unknown setting '%s'.\" % key)\n    self._print_level = 0",
    ".sympy.printing.codeprinter.py@@CodePrinter.doprint": "def doprint(self, expr, assign_to=None):\n    from sympy.matrices.expressions.matexpr import MatrixSymbol\n    if isinstance(assign_to, string_types):\n        if expr.is_Matrix:\n            assign_to = MatrixSymbol(assign_to, *expr.shape)\n        else:\n            assign_to = Symbol(assign_to)\n    elif not isinstance(assign_to, (Basic, type(None))):\n        raise TypeError('{0} cannot assign to object of type {1}'.format(type(self).__name__, type(assign_to)))\n    if assign_to:\n        expr = Assignment(assign_to, expr)\n    else:\n        expr = sympify(expr)\n    self._not_supported = set()\n    self._number_symbols = set()\n    lines = self._print(expr).splitlines()\n    if self._settings['human']:\n        frontlines = []\n        if self._not_supported:\n            frontlines.append(self._get_comment('Not supported in {0}:'.format(self.language)))\n            for expr in sorted(self._not_supported, key=str):\n                frontlines.append(self._get_comment(type(expr).__name__))\n        for name, value in sorted(self._number_symbols, key=str):\n            frontlines.append(self._declare_number_const(name, value))\n        lines = frontlines + lines\n        lines = self._format_code(lines)\n        result = '\\n'.join(lines)\n    else:\n        lines = self._format_code(lines)\n        num_syms = set([(k, self._print(v)) for k, v in self._number_symbols])\n        result = (num_syms, self._not_supported, '\\n'.join(lines))\n    self._not_supported = set()\n    self._number_symbols = set()\n    return result",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    if evaluate is None:\n        if global_evaluate[0] is False:\n            evaluate = global_evaluate[0]\n        else:\n            evaluate = True\n    try:\n        if a in sympy_classes:\n            return a\n    except TypeError:\n        pass\n    cls = getattr(a, '__class__', None)\n    if cls is None:\n        cls = type(a)\n    if cls in sympy_classes:\n        return a\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if type(a).__module__ == 'numpy':\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    try:\n        return converter[cls](a)\n    except KeyError:\n        for superclass in getmro(cls):\n            try:\n                return converter[superclass](a)\n            except KeyError:\n                continue\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from ..tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                coerced = coerce(a)\n            except (TypeError, ValueError):\n                continue\n            except AttributeError:\n                continue\n            try:\n                return sympify(coerced)\n            except SympifyError:\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.codegen.ast.py@@Token.__hash__": "def __hash__(self):\n    return super(Token, self).__hash__()",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.codegen.ast.py@@Token._hashable_content": "def _hashable_content(self):\n    return tuple([getattr(self, attr) for attr in self.__slots__])",
    ".sympy.core.containers.py@@Tuple.__hash__": "def __hash__(self):\n    return hash(self.args)",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.codegen.ast.py@@NoneToken.__hash__": "def __hash__(self):\n    return super(NoneToken, self).__hash__()",
    ".sympy.codegen.ast.py@@NoneToken._hashable_content": "def _hashable_content(self):\n    return ()",
    ".sympy.printing.printer.py@@Printer._print": "def _print(self, expr, **kwargs):\n    self._print_level += 1\n    try:\n        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):\n            return getattr(expr, self.printmethod)(self, **kwargs)\n        classes = type(expr).__mro__\n        if AppliedUndef in classes:\n            classes = classes[classes.index(AppliedUndef):]\n        if UndefinedFunction in classes:\n            classes = classes[classes.index(UndefinedFunction):]\n        if Function in classes:\n            i = classes.index(Function)\n            classes = tuple((c for c in classes[:i] if c.__name__ == classes[0].__name__ or c.__name__.endswith('Base'))) + classes[i:]\n        for cls in classes:\n            printmethod = '_print_' + cls.__name__\n            if hasattr(self, printmethod):\n                return getattr(self, printmethod)(expr, **kwargs)\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1",
    ".sympy.printing.pycode.py@@AbstractPythonCodePrinter._print_Print": "def _print_Print(self, prnt):\n    print_args = ', '.join(map(lambda arg: self._print(arg), prnt.print_args))\n    if prnt.format_string != None:\n        print_args = '{0} % ({1})'.format(self._print(prnt.format_string), print_args)\n    if prnt.file != None:\n        print_args += ', file=%s' % self._print(prnt.file)\n    if self.standard == 'python2':\n        return 'print %s' % print_args\n    return 'print(%s)' % print_args",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.printing.codeprinter.py@@CodePrinter._print_String": "def _print_String(self, string):\n    return str(string)",
    ".sympy.core.basic.py@@Basic.__str__": "def __str__(self):\n    from sympy.printing import sstr\n    return sstr(self, order=None)",
    ".sympy.printing.str.py@@sstr": "def sstr(expr, **settings):\n    p = StrPrinter(settings)\n    s = p.doprint(expr)\n    return s",
    ".sympy.printing.printer.py@@Printer.doprint": "def doprint(self, expr):\n    return self._str(self._print(expr))",
    ".sympy.codegen.ast.py@@String._sympystr": "def _sympystr(self, printer, *args, **kwargs):\n    return self.text",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.codegen.ast.py@@Token.__eq__": "def __eq__(self, other):\n    if not isinstance(other, self.__class__):\n        return False\n    for attr in self.__slots__:\n        if getattr(self, attr) != getattr(other, attr):\n            return False\n    return True",
    ".sympy.printing.codeprinter.py@@CodePrinter._print_QuotedString": "def _print_QuotedString(self, arg):\n    return '\"%s\"' % arg.text",
    ".sympy.codegen.ast.py@@NoneToken.__eq__": "def __eq__(self, other):\n    return other is None or isinstance(other, NoneToken)",
    ".sympy.printing.pycode.py@@AbstractPythonCodePrinter._format_code": "def _format_code(self, lines):\n    return lines"
}