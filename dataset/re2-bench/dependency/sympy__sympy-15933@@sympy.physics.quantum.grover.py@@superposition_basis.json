{
    ".sympy.functions.elementary.miscellaneous.py@@sqrt": "def sqrt(arg, evaluate=None):\n    return Pow(arg, S.Half, evaluate=evaluate)",
    ".sympy.core.power.py@@Pow.__new__": "def __new__(cls, b, e, evaluate=None):\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    from sympy.functions.elementary.exponential import exp_polar\n    b = _sympify(b)\n    e = _sympify(e)\n    if evaluate:\n        if e is S.ComplexInfinity:\n            return S.NaN\n        if e is S.Zero:\n            return S.One\n        elif e is S.One:\n            return b\n        elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and e.is_integer and _coeff_isneg(b):\n            if e.is_even:\n                b = -b\n            elif e.is_odd:\n                return -Pow(-b, e)\n        if S.NaN in (b, e):\n            return S.NaN\n        elif b is S.One:\n            if abs(e).is_infinite:\n                return S.NaN\n            return S.One\n        else:\n            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):\n                from sympy import numer, denom, log, sign, im, factor_terms\n                c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n                den = denom(ex)\n                if isinstance(den, log) and den.args[0] == b:\n                    return S.Exp1 ** (c * numer(ex))\n                elif den.is_Add:\n                    s = sign(im(b))\n                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):\n                        return S.Exp1 ** (c * numer(ex))\n            obj = b._eval_power(e)\n            if obj is not None:\n                return obj\n    obj = Expr.__new__(cls, b, e)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if not isinstance(obj, Pow):\n        return obj\n    obj.is_commutative = b.is_commutative and e.is_commutative\n    return obj",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    if evaluate is None:\n        if global_evaluate[0] is False:\n            evaluate = global_evaluate[0]\n        else:\n            evaluate = True\n    try:\n        if a in sympy_classes:\n            return a\n    except TypeError:\n        pass\n    try:\n        cls = a.__class__\n    except AttributeError:\n        cls = type(a)\n    if cls in sympy_classes:\n        return a\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if type(a).__module__ == 'numpy':\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    try:\n        return converter[cls](a)\n    except KeyError:\n        for superclass in getmro(cls):\n            try:\n                return converter[superclass](a)\n            except KeyError:\n                continue\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    try:\n        return a._sympy_()\n    except AttributeError:\n        pass\n    if not strict:\n        try:\n            from ..tensor.array import Array\n            return Array(a.flat, a.shape)\n        except AttributeError:\n            pass\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                return sympify(coerce(a))\n            except (TypeError, ValueError, AttributeError, SympifyError):\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, string_types):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    try:\n        return _intcache[ival]\n    except KeyError:\n        obj = Expr.__new__(cls)\n        obj.p = ival\n        _intcache[ival] = obj\n        return obj",
    ".sympy.core.numbers.py@@Rational.__hash__": "def __hash__(self):\n    return super(Rational, self).__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super(Number, self).__hash__()",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, integer_types):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Number:\n        if other.is_Rational:\n            return self.p == other.p and self.q == other.q\n        if other.is_Float:\n            return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)\n    return False",
    ".sympy.core.numbers.py@@NaN.__hash__": "def __hash__(self):\n    return super(NaN, self).__hash__()",
    ".sympy.core.numbers.py@@Integer._eval_power": "def _eval_power(self, expt):\n    from sympy import perfect_power\n    if expt is S.Infinity:\n        if self.p > S.One:\n            return S.Infinity\n        return S.Infinity + S.ImaginaryUnit * S.Infinity\n    if expt is S.NegativeInfinity:\n        return Rational(1, self) ** S.Infinity\n    if not isinstance(expt, Number):\n        if self.is_negative and expt.is_even:\n            return (-self) ** expt\n    if isinstance(expt, Float):\n        return super(Integer, self)._eval_power(expt)\n    if not isinstance(expt, Rational):\n        return\n    if expt is S.Half and self.is_negative:\n        return S.ImaginaryUnit * Pow(-self, expt)\n    if expt.is_negative:\n        ne = -expt\n        if self.is_negative:\n            return S.NegativeOne ** expt * Rational(1, -self) ** ne\n        else:\n            return Rational(1, self.p) ** ne\n    x, xexact = integer_nthroot(abs(self.p), expt.q)\n    if xexact:\n        result = Integer(x ** abs(expt.p))\n        if self.is_negative:\n            result *= S.NegativeOne ** expt\n        return result\n    b_pos = int(abs(self.p))\n    p = perfect_power(b_pos)\n    if p is not False:\n        dict = {p[0]: p[1]}\n    else:\n        dict = Integer(b_pos).factors(limit=2 ** 15)\n    out_int = 1\n    out_rad = 1\n    sqr_int = 1\n    sqr_gcd = 0\n    sqr_dict = {}\n    for prime, exponent in dict.items():\n        exponent *= expt.p\n        div_e, div_m = divmod(exponent, expt.q)\n        if div_e > 0:\n            out_int *= prime ** div_e\n        if div_m > 0:\n            g = igcd(div_m, expt.q)\n            if g != 1:\n                out_rad *= Pow(prime, Rational(div_m // g, expt.q // g))\n            else:\n                sqr_dict[prime] = div_m\n    for p, ex in sqr_dict.items():\n        if sqr_gcd == 0:\n            sqr_gcd = ex\n        else:\n            sqr_gcd = igcd(sqr_gcd, ex)\n            if sqr_gcd == 1:\n                break\n    for k, v in sqr_dict.items():\n        sqr_int *= k ** (v // sqr_gcd)\n    if sqr_int == b_pos and out_int == 1 and (out_rad == 1):\n        result = None\n    else:\n        result = out_int * out_rad * Pow(sqr_int, Rational(sqr_gcd, expt.q))\n        if self.is_negative:\n            result *= Pow(S.NegativeOne, expt)\n    return result",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.power.py@@integer_nthroot": "def integer_nthroot(y, n):\n    y, n = (as_int(y), as_int(n))\n    if y < 0:\n        raise ValueError('y must be nonnegative')\n    if n < 1:\n        raise ValueError('n must be positive')\n    if y in (0, 1):\n        return (y, True)\n    if n == 1:\n        return (y, True)\n    if n == 2:\n        x, rem = mpmath_sqrtrem(y)\n        return (int(x), not rem)\n    if n > y:\n        return (1, False)\n    try:\n        guess = int(y ** (1.0 / n) + 0.5)\n    except OverflowError:\n        exp = _log(y, 2) / n\n        if exp > 53:\n            shift = int(exp - 53)\n            guess = int(2.0 ** (exp - shift) + 1) << shift\n        else:\n            guess = int(2.0 ** exp)\n    if guess > 2 ** 50:\n        xprev, x = (-1, guess)\n        while 1:\n            t = x ** (n - 1)\n            xprev, x = (x, ((n - 1) * x + y // t) // n)\n            if abs(x - xprev) < 2:\n                break\n    else:\n        x = guess\n    t = x ** n\n    while t < y:\n        x += 1\n        t = x ** n\n    while t > y:\n        x -= 1\n        t = x ** n\n    return (int(x), t == y)",
    ".sympy.core.compatibility.py@@as_int": "def as_int(n):\n    try:\n        result = int(n)\n        if result != n:\n            raise TypeError\n    except TypeError:\n        raise ValueError('%s is not an integer' % (n,))\n    return result",
    ".sympy.core.decorators.py@@__sympifyit_wrapper": "def __sympifyit_wrapper(a, b):\n    try:\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    ".sympy.core.decorators.py@@binary_op_wrapper": "def binary_op_wrapper(self, other):\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:\n            try:\n                f = getattr(other, method_name)\n            except AttributeError:\n                pass\n            else:\n                return f(self)\n    return func(self, other)",
    ".sympy.core.expr.py@@Expr.__rdiv__": "def __rdiv__(self, other):\n    return Mul(other, Pow(self, S.NegativeOne))",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.function.py@@_coeff_isneg": "def _coeff_isneg(a):\n    if a.is_MatMul:\n        a = a.args[0]\n    if a.is_Mul:\n        a = a.args[0]\n    return a.is_Number and a.is_negative",
    ".sympy.core.numbers.py@@NegativeOne.__neg__": "def __neg__():\n    return S.One",
    ".sympy.core.numbers.py@@Rational.__new__": "def __new__(cls, p, q=None, gcd=None):\n    if q is None:\n        if isinstance(p, Rational):\n            return p\n        if isinstance(p, SYMPY_INTS):\n            pass\n        else:\n            if isinstance(p, (float, Float)):\n                return Rational(*_as_integer_ratio(p))\n            if not isinstance(p, string_types):\n                try:\n                    p = sympify(p)\n                except (SympifyError, SyntaxError):\n                    pass\n            else:\n                if p.count('/') > 1:\n                    raise TypeError('invalid input: %s' % p)\n                p = p.replace(' ', '')\n                pq = p.rsplit('/', 1)\n                if len(pq) == 2:\n                    p, q = pq\n                    fp = fractions.Fraction(p)\n                    fq = fractions.Fraction(q)\n                    p = fp / fq\n                try:\n                    p = fractions.Fraction(p)\n                except ValueError:\n                    pass\n                else:\n                    return Rational(p.numerator, p.denominator, 1)\n            if not isinstance(p, Rational):\n                raise TypeError('invalid input: %s' % p)\n        q = 1\n        gcd = 1\n    else:\n        p = Rational(p)\n        q = Rational(q)\n    if isinstance(q, Rational):\n        p *= q.q\n        q = q.p\n    if isinstance(p, Rational):\n        q *= p.q\n        p = p.p\n    if q == 0:\n        if p == 0:\n            if _errdict['divide']:\n                raise ValueError('Indeterminate 0/0')\n            else:\n                return S.NaN\n        return S.ComplexInfinity\n    if q < 0:\n        q = -q\n        p = -p\n    if not gcd:\n        gcd = igcd(abs(p), q)\n    if gcd > 1:\n        p //= gcd\n        q //= gcd\n    if q == 1:\n        return Integer(p)\n    if p == 1 and q == 2:\n        return S.Half\n    obj = Expr.__new__(cls)\n    obj.p = p\n    obj.q = q\n    return obj",
    ".sympy.core.numbers.py@@Integer.__mul__": "def __mul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p * other)\n        elif isinstance(other, Integer):\n            return Integer(self.p * other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    ".sympy.core.expr.py@@Expr.__pow__": "def __pow__(self, other, mod=None):\n    if mod is None:\n        return self._pow(other)\n    try:\n        _self, other, mod = (as_int(self), as_int(other), as_int(mod))\n        if other >= 0:\n            return pow(_self, other, mod)\n        else:\n            from sympy.core.numbers import mod_inverse\n            return mod_inverse(pow(_self, -other, mod), mod)\n    except ValueError:\n        power = self._pow(other)\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    ".sympy.core.expr.py@@Expr._pow": "def _pow(self, other):\n    return Pow(self, other)",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, **options):\n    from sympy import Order\n    args = list(map(_sympify, args))\n    args = [a for a in args if a is not cls.identity]\n    evaluate = options.get('evaluate')\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    if not evaluate:\n        return cls._from_args(args)\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if order_symbols is not None:\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.ntheory.factor_.py@@perfect_power": "def perfect_power(n, candidates=None, big=True, factor=True):\n    n = int(n)\n    if n < 3:\n        return False\n    logn = math.log(n, 2)\n    max_possible = int(logn) + 2\n    not_square = n % 10 in [2, 3, 7, 8]\n    if not candidates:\n        candidates = primerange(2 + not_square, max_possible)\n    afactor = 2 + n % 2\n    for e in candidates:\n        if e < 3:\n            if e == 1 or (e == 2 and not_square):\n                continue\n        if e > max_possible:\n            return False\n        if factor:\n            if n % afactor == 0:\n                if afactor == 2:\n                    e = trailing(n)\n                else:\n                    e = multiplicity(afactor, n)\n                if e == 1:\n                    return False\n                r, exact = integer_nthroot(n, e)\n                if not exact:\n                    n //= afactor ** e\n                    m = perfect_power(n, candidates=primefactors(e), big=big)\n                    if m is False:\n                        return False\n                    else:\n                        r, m = m\n                        g = igcd(m, e)\n                        if g == 1:\n                            return False\n                        m //= g\n                        e //= g\n                        r, e = (r ** m * afactor ** e, g)\n                if not big:\n                    e0 = primefactors(e)\n                    if len(e0) > 1 or e0[0] != e:\n                        e0 = e0[0]\n                        r, e = (r ** (e // e0), e0)\n                return (r, e)\n            else:\n                afactor = nextprime(afactor)\n        if logn / e < 40:\n            b = 2.0 ** (logn / e)\n            if abs(int(b + 0.5) - b) > 0.01:\n                continue\n        r, exact = integer_nthroot(n, e)\n        if exact:\n            if big:\n                m = perfect_power(r, big=big, factor=factor)\n                if m is not False:\n                    r, e = (m[0], e * m[1])\n            return (int(r), e)\n    else:\n        return False",
    ".sympy.ntheory.generate.py@@primerange": "def primerange(a, b):\n    from sympy.functions.elementary.integers import ceiling\n    if a >= b:\n        return\n    if b <= sieve._list[-1]:\n        for i in sieve.primerange(a, b):\n            yield i\n        return\n    a = as_int(ceiling(a)) - 1\n    b = as_int(ceiling(b))\n    while 1:\n        a = nextprime(a)\n        if a < b:\n            yield a\n        else:\n            return",
    ".sympy.ntheory.generate.py@@Sieve.primerange": "def primerange(self, a, b):\n    from sympy.functions.elementary.integers import ceiling\n    a = max(2, as_int(ceiling(a)))\n    b = as_int(ceiling(b))\n    if a >= b:\n        return\n    self.extend(b)\n    i = self.search(a)[1]\n    maxi = len(self._list) + 1\n    while i < maxi:\n        p = self._list[i - 1]\n        if p < b:\n            yield p\n            i += 1\n        else:\n            return",
    ".sympy.core.function.py@@Function.__new__": "def __new__(cls, *args, **options):\n    if cls is Function:\n        return UndefinedFunction(*args, **options)\n    n = len(args)\n    if n not in cls.nargs:\n        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'\n        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})\n    evaluate = options.get('evaluate', global_evaluate[0])\n    result = super(Function, cls).__new__(cls, *args, **options)\n    if evaluate and isinstance(result, cls) and result.args:\n        pr2 = min((cls._should_evalf(a) for a in result.args))\n        if pr2 > 0:\n            pr = max((cls._should_evalf(a) for a in result.args))\n            result = result.evalf(mlib.libmpf.prec_to_dps(pr))\n    return result",
    ".sympy.core.function.py@@FunctionClass.nargs": "def nargs(self):\n    from sympy.sets.sets import FiniteSet\n    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0",
    ".sympy.sets.sets.py@@FiniteSet.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_evaluate[0])\n    if evaluate:\n        args = list(map(sympify, args))\n        if len(args) == 0:\n            return EmptySet()\n    else:\n        args = list(map(sympify, args))\n    args = list(ordered(frozenset(tuple(args)), Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._elements = frozenset(args)\n    return obj",
    ".sympy.core.compatibility.py@@ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    d = defaultdict(list)\n    if keys:\n        if not isinstance(keys, (list, tuple)):\n            keys = [keys]\n        keys = list(keys)\n        f = keys.pop(0)\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n    for k in sorted(d.keys()):\n        if len(d[k]) > 1:\n            if keys:\n                d[k] = ordered(d[k], keys, default, warn)\n            elif default:\n                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)\n            elif warn:\n                from sympy.utilities.iterables import uniq\n                u = list(uniq(d[k]))\n                if len(u) > 1:\n                    raise ValueError('not enough keys to break ties: %s' % u)\n        for v in d[k]:\n            yield v\n        d.pop(k)",
    ".sympy.sets.sets.py@@Set._infimum_key": "def _infimum_key(expr):\n    try:\n        infimum = expr.inf\n        assert infimum.is_comparable\n    except (NotImplementedError, AttributeError, AssertionError, ValueError):\n        infimum = S.Infinity\n    return infimum",
    ".sympy.core.numbers.py@@Infinity.__hash__": "def __hash__(self):\n    return super(Infinity, self).__hash__()",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.sets.sets.py@@Set.__contains__": "def __contains__(self, other):\n    symb = sympify(self.contains(other))\n    if not (symb is S.true or symb is S.false):\n        raise TypeError('contains did not evaluate to a bool: %r' % symb)\n    return bool(symb)",
    ".sympy.sets.sets.py@@Set.contains": "def contains(self, other):\n    other = sympify(other, strict=True)\n    ret = sympify(self._contains(other))\n    if ret is None:\n        ret = Contains(other, self, evaluate=False)\n    return ret",
    ".sympy.sets.sets.py@@FiniteSet._contains": "def _contains(self, other):\n    r = false\n    for e in self._elements:\n        t = Eq(e, other, evaluate=True)\n        if t is true:\n            return t\n        elif t is not false:\n            r = None\n    return r",
    ".sympy.core.relational.py@@Equality.__new__": "def __new__(cls, lhs, rhs=0, **options):\n    from sympy.core.add import Add\n    from sympy.core.logic import fuzzy_bool\n    from sympy.core.expr import _n2\n    from sympy.simplify.simplify import clear_coefficients\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    evaluate = options.pop('evaluate', global_evaluate[0])\n    if evaluate:\n        if hasattr(lhs, '_eval_Eq'):\n            r = lhs._eval_Eq(rhs)\n            if r is not None:\n                return r\n        if hasattr(rhs, '_eval_Eq'):\n            r = rhs._eval_Eq(lhs)\n            if r is not None:\n                return r\n        if lhs == rhs:\n            return S.true\n        elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):\n            return S.false\n        elif not (lhs.is_Symbol or rhs.is_Symbol) and isinstance(lhs, Boolean) != isinstance(rhs, Boolean):\n            return S.false\n        fin = L, R = [i.is_finite for i in (lhs, rhs)]\n        if None not in fin:\n            if L != R:\n                return S.false\n            if L is False:\n                if lhs == -rhs:\n                    return S.false\n                return S.true\n        elif None in fin and False in fin:\n            return Relational.__new__(cls, lhs, rhs, **options)\n        if all((isinstance(i, Expr) for i in (lhs, rhs))):\n            dif = lhs - rhs\n            z = dif.is_zero\n            if z is not None:\n                if z is False and dif.is_commutative:\n                    return S.false\n                if z:\n                    return S.true\n            n2 = _n2(lhs, rhs)\n            if n2 is not None:\n                return _sympify(n2 == 0)\n            n, d = dif.as_numer_denom()\n            rv = None\n            if n.is_zero:\n                rv = d.is_nonzero\n            elif n.is_finite:\n                if d.is_infinite:\n                    rv = S.true\n                elif n.is_zero is False:\n                    rv = d.is_infinite\n                    if rv is None:\n                        l, r = clear_coefficients(d, S.Infinity)\n                        args = [_.subs(l, r) for _ in (lhs, rhs)]\n                        if args != [lhs, rhs]:\n                            rv = fuzzy_bool(Eq(*args))\n                            if rv is True:\n                                rv = None\n            elif any((a.is_infinite for a in Add.make_args(n))):\n                rv = S.false\n            if rv is not None:\n                return _sympify(rv)\n    return Relational.__new__(cls, lhs, rhs, **options)",
    ".sympy.logic.boolalg.py@@BooleanTrue.__hash__": "def __hash__(self):\n    return hash(True)",
    ".sympy.logic.boolalg.py@@BooleanTrue.__nonzero__": "def __nonzero__(self):\n    return True",
    ".sympy.core.function.py@@Application.__new__": "def __new__(cls, *args, **options):\n    from sympy.sets.fancysets import Naturals0\n    from sympy.sets.sets import FiniteSet\n    args = list(map(sympify, args))\n    evaluate = options.pop('evaluate', global_evaluate[0])\n    options.pop('nargs', None)\n    if options:\n        raise ValueError('Unknown options: %s' % options)\n    if evaluate:\n        evaluated = cls.eval(*args)\n        if evaluated is not None:\n            return evaluated\n    obj = super(Application, cls).__new__(cls, *args, **options)\n    try:\n        if is_sequence(obj.nargs):\n            nargs = tuple(ordered(set(obj.nargs)))\n        elif obj.nargs is not None:\n            nargs = (as_int(obj.nargs),)\n        else:\n            nargs = None\n    except AttributeError:\n        nargs = obj._nargs\n    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()\n    return obj",
    ".sympy.functions.elementary.integers.py@@RoundFunction.eval": "def eval(cls, arg):\n    from sympy import im\n    if arg.is_integer or arg.is_finite is False:\n        return arg\n    if arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        i = im(arg)\n        if not i.has(S.ImaginaryUnit):\n            return cls(i) * S.ImaginaryUnit\n        return cls(arg, evaluate=False)\n    v = cls._eval_number(arg)\n    if v is not None:\n        return v\n    ipart = npart = spart = S.Zero\n    terms = Add.make_args(arg)\n    for t in terms:\n        if t.is_integer or (t.is_imaginary and im(t).is_integer):\n            ipart += t\n        elif t.has(Symbol):\n            spart += t\n        else:\n            npart += t\n    if not (npart or spart):\n        return ipart\n    if npart and (not spart or (npart.is_real and (spart.is_imaginary or (S.ImaginaryUnit * spart).is_real)) or (npart.is_imaginary and spart.is_real)):\n        try:\n            r, i = get_integer_part(npart, cls._dir, {}, return_ints=True)\n            ipart += Integer(r) + Integer(i) * S.ImaginaryUnit\n            npart = S.Zero\n        except (PrecisionExhausted, NotImplementedError):\n            pass\n    spart += npart\n    if not spart:\n        return ipart\n    elif spart.is_imaginary or (S.ImaginaryUnit * spart).is_real:\n        return ipart + cls(im(spart), evaluate=False) * S.ImaginaryUnit\n    else:\n        return ipart + cls(spart, evaluate=False)",
    ".sympy.core.numbers.py@@Integer.__int__": "def __int__(self):\n    return self.p",
    ".sympy.core.numbers.py@@Integer.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.ntheory.generate.py@@Sieve.extend": "def extend(self, n):\n    n = int(n)\n    if n <= self._list[-1]:\n        return\n    maxbase = int(n ** 0.5) + 1\n    self.extend(maxbase)\n    begin = self._list[-1] + 1\n    newsieve = _arange(begin, n + 1)\n    for p in self.primerange(2, maxbase):\n        startindex = -begin % p\n        for i in range(startindex, len(newsieve), p):\n            newsieve[i] = 0\n    self._list += _array('l', [x for x in newsieve if x])",
    ".sympy.ntheory.generate.py@@Sieve.search": "def search(self, n):\n    from sympy.functions.elementary.integers import ceiling\n    test = as_int(ceiling(n))\n    n = as_int(n)\n    if n < 2:\n        raise ValueError('n should be >= 2 but got: %s' % n)\n    if n > self._list[-1]:\n        self.extend(n)\n    b = bisect(self._list, n)\n    if self._list[b - 1] == test:\n        return (b, b)\n    else:\n        return (b, b + 1)",
    ".sympy.ntheory.factor_.py@@trailing": "def trailing(n):\n    n = abs(int(n))\n    if not n:\n        return 0\n    low_byte = n & 255\n    if low_byte:\n        return small_trailing[low_byte]\n    z = bitcount(n) - 1\n    if isinstance(z, SYMPY_INTS):\n        if n == 1 << z:\n            return z\n    if z < 300:\n        t = 8\n        n >>= 8\n        while not n & 255:\n            n >>= 8\n            t += 8\n        return t + small_trailing[n & 255]\n    t = 0\n    p = 8\n    while not n & 1:\n        while not n & (1 << p) - 1:\n            n >>= p\n            t += p\n            p *= 2\n        p //= 2\n    return t",
    ".sympy.core.numbers.py@@Rational.factors": "def factors(self, limit=None, use_trial=True, use_rho=False, use_pm1=False, verbose=False, visual=False):\n    from sympy.ntheory import factorrat\n    return factorrat(self, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()",
    ".sympy.ntheory.factor_.py@@factorrat": "def factorrat(rat, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False):\n    from collections import defaultdict\n    if multiple:\n        fac = factorrat(rat, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)\n        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S(1) / p] * -fac[p] for p, _ in sorted(fac.items(), key=lambda elem: elem[0] if elem[1] > 0 else 1 / elem[0])), [])\n        return factorlist\n    f = factorint(rat.p, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).copy()\n    f = defaultdict(int, f)\n    for p, e in factorint(rat.q, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose).items():\n        f[p] += -e\n    if len(f) > 1 and 1 in f:\n        del f[1]\n    if not visual:\n        return dict(f)\n    else:\n        if -1 in f:\n            f.pop(-1)\n            args = [S.NegativeOne]\n        else:\n            args = []\n        args.extend([Pow(*i, evaluate=False) for i in sorted(f.items())])\n        return Mul(*args, evaluate=False)",
    ".sympy.ntheory.factor_.py@@factorint": "def factorint(n, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False):\n    if multiple:\n        fac = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False, multiple=False)\n        factorlist = sum(([p] * fac[p] if fac[p] > 0 else [S(1) / p] * -fac[p] for p in sorted(fac)), [])\n        return factorlist\n    factordict = {}\n    if visual and (not isinstance(n, Mul)) and (not isinstance(n, dict)):\n        factordict = factorint(n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n    elif isinstance(n, Mul):\n        factordict = dict([(int(k), int(v)) for k, v in list(n.as_powers_dict().items())])\n    elif isinstance(n, dict):\n        factordict = n\n    if factordict and (isinstance(n, Mul) or isinstance(n, dict)):\n        for k in list(factordict.keys()):\n            if isprime(k):\n                continue\n            e = factordict.pop(k)\n            d = factorint(k, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n            for k, v in d.items():\n                if k in factordict:\n                    factordict[k] += v * e\n                else:\n                    factordict[k] = v * e\n    if visual or (type(n) is dict and visual is not True and (visual is not False)):\n        if factordict == {}:\n            return S.One\n        if -1 in factordict:\n            factordict.pop(-1)\n            args = [S.NegativeOne]\n        else:\n            args = []\n        args.extend([Pow(*i, evaluate=False) for i in sorted(factordict.items())])\n        return Mul(*args, evaluate=False)\n    elif isinstance(n, dict) or isinstance(n, Mul):\n        return factordict\n    assert use_trial or use_rho or use_pm1\n    from sympy.functions.combinatorial.factorials import factorial\n    if isinstance(n, factorial):\n        x = as_int(n.args[0])\n        if x >= 20:\n            factors = {}\n            m = 2\n            for p in sieve.primerange(2, x + 1):\n                if m > 1:\n                    m, q = (0, x // p)\n                    while q != 0:\n                        m += q\n                        q //= p\n                factors[p] = m\n            if factors and verbose:\n                for k in sorted(factors):\n                    print(factor_msg % (k, factors[k]))\n            if verbose:\n                print(complete_msg)\n            return factors\n        else:\n            n = n.func(x)\n    n = as_int(n)\n    if limit:\n        limit = int(limit)\n    if n < 0:\n        factors = factorint(-n, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose, visual=False)\n        factors[-1] = 1\n        return factors\n    if limit and limit < 2:\n        if n == 1:\n            return {}\n        return {n: 1}\n    elif n < 10:\n        return [{0: 1}, {}, {2: 1}, {3: 1}, {2: 2}, {5: 1}, {2: 1, 3: 1}, {7: 1}, {2: 3}, {3: 2}][n]\n    factors = {}\n    if verbose:\n        sn = str(n)\n        if len(sn) > 50:\n            print('Factoring %s' % sn[:5] + '..(%i other digits)..' % (len(sn) - 10) + sn[-5:])\n        else:\n            print('Factoring', n)\n    if use_trial:\n        small = 2 ** 15\n        fail_max = 600\n        small = min(small, limit or small)\n        if verbose:\n            print(trial_int_msg % (2, small, fail_max))\n        n, next_p = _factorint_small(factors, n, small, fail_max)\n    else:\n        next_p = 2\n    if factors and verbose:\n        for k in sorted(factors):\n            print(factor_msg % (k, factors[k]))\n    if next_p == 0:\n        if n > 1:\n            factors[int(n)] = 1\n        if verbose:\n            print(complete_msg)\n        return factors\n    try:\n        if limit and next_p > limit:\n            if verbose:\n                print('Exceeded limit:', limit)\n            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n            if n > 1:\n                factors[int(n)] = 1\n            return factors\n        else:\n            sqrt_n = integer_nthroot(n, 2)[0]\n            a = sqrt_n + 1\n            a2 = a ** 2\n            b2 = a2 - n\n            for i in range(3):\n                b, fermat = integer_nthroot(b2, 2)\n                if fermat:\n                    break\n                b2 += 2 * a + 1\n                a += 1\n            if fermat:\n                if verbose:\n                    print(fermat_msg)\n                if limit:\n                    limit -= 1\n                for r in [a - b, a + b]:\n                    facs = factorint(r, limit=limit, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)\n                    factors.update(facs)\n                raise StopIteration\n            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n    except StopIteration:\n        if verbose:\n            print(complete_msg)\n        return factors\n    low, high = (next_p, 2 * next_p)\n    limit = limit or sqrt_n\n    limit += 1\n    while 1:\n        try:\n            high_ = high\n            if limit < high_:\n                high_ = limit\n            if use_trial:\n                if verbose:\n                    print(trial_msg % (low, high_))\n                ps = sieve.primerange(low, high_)\n                n, found_trial = _trial(factors, n, ps, verbose)\n                if found_trial:\n                    _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n            else:\n                found_trial = False\n            if high > limit:\n                if verbose:\n                    print('Exceeded limit:', limit)\n                if n > 1:\n                    factors[int(n)] = 1\n                raise StopIteration\n            if not found_trial:\n                if use_pm1 or use_rho:\n                    high_root = max(int(math.log(high_ ** 0.7)), low, 3)\n                    if use_pm1:\n                        if verbose:\n                            print(pm1_msg % (high_root, high_))\n                        c = pollard_pm1(n, B=high_root, seed=high_)\n                        if c:\n                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)\n                            n, _ = _trial(factors, n, ps, verbose=False)\n                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n                    if use_rho:\n                        max_steps = high_root\n                        if verbose:\n                            print(rho_msg % (1, max_steps, high_))\n                        c = pollard_rho(n, retries=1, max_steps=max_steps, seed=high_)\n                        if c:\n                            ps = factorint(c, limit=limit - 1, use_trial=use_trial, use_rho=use_rho, use_pm1=use_pm1, verbose=verbose)\n                            n, _ = _trial(factors, n, ps, verbose=False)\n                            _check_termination(factors, n, limit, use_trial, use_rho, use_pm1, verbose)\n        except StopIteration:\n            if verbose:\n                print(complete_msg)\n            return factors\n        low, high = (high, high * 2)",
    ".sympy.core.basic.py@@Basic._exec_constructor_postprocessors": "def _exec_constructor_postprocessors(cls, obj):\n    clsname = obj.__class__.__name__\n    postprocessors = defaultdict(list)\n    for i in obj.args:\n        try:\n            if i in Basic._constructor_postprocessor_mapping:\n                for k, v in Basic._constructor_postprocessor_mapping[i].items():\n                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n            else:\n                postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)\n                for k, v in chain.from_iterable(postprocessor_mappings):\n                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n        except TypeError:\n            pass\n    for f in postprocessors.get(clsname, []):\n        obj = f(obj)\n    if len(postprocessors) > 0 and obj not in Basic._constructor_postprocessor_mapping:\n        Basic._constructor_postprocessor_mapping[obj] = postprocessors\n    return obj",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.expr.py@@Expr.__rmul__": "def __rmul__(self, other):\n    return Mul(other, self)",
    ".sympy.core.basic.py@@Basic._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.mul.py@@Mul.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n            seq = [a, b]\n        assert not a is S.One\n        if not a.is_zero and a.is_Rational:\n            r, b = b.as_coeff_Mul()\n            if b.is_Add:\n                if r is not S.One:\n                    rv = ([cls(a * r, b, evaluate=False)], [], None)\n                elif global_distribute[0] and b.is_commutative:\n                    r, b = b.as_coeff_Add()\n                    bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n                    _addsort(bargs)\n                    ar = a * r\n                    if ar:\n                        bargs.insert(0, ar)\n                    bargs = [Add._from_args(bargs)]\n                    rv = (bargs, [], None)\n        if rv:\n            return rv\n    c_part = []\n    nc_part = []\n    nc_seq = []\n    coeff = S.One\n    c_powers = []\n    num_exp = []\n    neg1e = S.Zero\n    pnum_rat = {}\n    order_symbols = None\n    for o in seq:\n        if o.is_Order:\n            o, order_symbols = o.as_expr_variables(order_symbols)\n        if o.is_Mul:\n            if o.is_commutative:\n                seq.extend(o.args)\n            else:\n                for q in o.args:\n                    if q.is_commutative:\n                        seq.append(q)\n                    else:\n                        nc_seq.append(q)\n                seq.append(NC_Marker)\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o is S.Zero):\n                return ([S.NaN], [], None)\n            elif coeff.is_Number or isinstance(coeff, AccumBounds):\n                coeff *= o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__mul__(coeff)\n            continue\n        elif isinstance(o, MatrixExpr):\n            if isinstance(coeff, MatrixExpr):\n                coeff *= o\n            else:\n                coeff = o.__mul__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if not coeff:\n                return ([S.NaN], [], None)\n            if coeff is S.ComplexInfinity:\n                return ([S.ComplexInfinity], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o is S.ImaginaryUnit:\n            neg1e += S.Half\n            continue\n        elif o.is_commutative:\n            b, e = o.as_base_exp()\n            if o.is_Pow:\n                if b.is_Number:\n                    if e.is_Rational:\n                        if e.is_Integer:\n                            coeff *= Pow(b, e)\n                            continue\n                        elif e.is_negative:\n                            seq.append(Pow(b, e))\n                            continue\n                        elif b.is_negative:\n                            neg1e += e\n                            b = -b\n                        if b is not S.One:\n                            pnum_rat.setdefault(b, []).append(e)\n                        continue\n                    elif b.is_positive or e.is_integer:\n                        num_exp.append((b, e))\n                        continue\n            c_powers.append((b, e))\n        else:\n            if o is not NC_Marker:\n                nc_seq.append(o)\n            while nc_seq:\n                o = nc_seq.pop(0)\n                if not nc_part:\n                    nc_part.append(o)\n                    continue\n                o1 = nc_part.pop()\n                b1, e1 = o1.as_base_exp()\n                b2, e2 = o.as_base_exp()\n                new_exp = e1 + e2\n                if b1 == b2 and (not new_exp.is_Add):\n                    o12 = b1 ** new_exp\n                    if o12.is_commutative:\n                        seq.append(o12)\n                        continue\n                    else:\n                        nc_seq.insert(0, o12)\n                else:\n                    nc_part.append(o1)\n                    nc_part.append(o)\n\n    def _gather(c_powers):\n        common_b = {}\n        for b, e in c_powers:\n            co = e.as_coeff_Mul()\n            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n        for b, d in common_b.items():\n            for di, li in d.items():\n                d[di] = Add(*li)\n        new_c_powers = []\n        for b, e in common_b.items():\n            new_c_powers.extend([(b, c * t) for t, c in e.items()])\n        return new_c_powers\n    c_powers = _gather(c_powers)\n    num_exp = _gather(num_exp)\n    for i in range(2):\n        new_c_powers = []\n        changed = False\n        for b, e in c_powers:\n            if e.is_zero:\n                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):\n                    return ([S.NaN], [], None)\n                continue\n            if e is S.One:\n                if b.is_Number:\n                    coeff *= b\n                    continue\n                p = b\n            if e is not S.One:\n                p = Pow(b, e)\n                if p.is_Pow and (not b.is_Pow):\n                    bi = b\n                    b, e = p.as_base_exp()\n                    if b != bi:\n                        changed = True\n            c_part.append(p)\n            new_c_powers.append((b, e))\n        if changed and len(set((b for b, e in new_c_powers))) != len(new_c_powers):\n            c_part = []\n            c_powers = _gather(new_c_powers)\n        else:\n            break\n    inv_exp_dict = {}\n    for b, e in num_exp:\n        inv_exp_dict.setdefault(e, []).append(b)\n    for e, b in inv_exp_dict.items():\n        inv_exp_dict[e] = cls(*b)\n    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n    comb_e = {}\n    for b, e in pnum_rat.items():\n        comb_e.setdefault(Add(*e), []).append(b)\n    del pnum_rat\n    num_rat = []\n    for e, b in comb_e.items():\n        b = cls(*b)\n        if e.q == 1:\n            coeff *= Pow(b, e)\n            continue\n        if e.p > e.q:\n            e_i, ep = divmod(e.p, e.q)\n            coeff *= Pow(b, e_i)\n            e = Rational(ep, e.q)\n        num_rat.append((b, e))\n    del comb_e\n    pnew = defaultdict(list)\n    i = 0\n    while i < len(num_rat):\n        bi, ei = num_rat[i]\n        grow = []\n        for j in range(i + 1, len(num_rat)):\n            bj, ej = num_rat[j]\n            g = bi.gcd(bj)\n            if g is not S.One:\n                e = ei + ej\n                if e.q == 1:\n                    coeff *= Pow(g, e)\n                else:\n                    if e.p > e.q:\n                        e_i, ep = divmod(e.p, e.q)\n                        coeff *= Pow(g, e_i)\n                        e = Rational(ep, e.q)\n                    grow.append((g, e))\n                num_rat[j] = (bj / g, ej)\n                bi = bi / g\n                if bi is S.One:\n                    break\n        if bi is not S.One:\n            obj = Pow(bi, ei)\n            if obj.is_Number:\n                coeff *= obj\n            else:\n                for obj in Mul.make_args(obj):\n                    if obj.is_Number:\n                        coeff *= obj\n                    else:\n                        assert obj.is_Pow\n                        bi, ei = obj.args\n                        pnew[ei].append(bi)\n        num_rat.extend(grow)\n        i += 1\n    for e, b in pnew.items():\n        pnew[e] = cls(*b)\n    if neg1e:\n        p, q = neg1e.as_numer_denom()\n        n, p = divmod(p, q)\n        if n % 2:\n            coeff = -coeff\n        if q == 2:\n            c_part.append(S.ImaginaryUnit)\n        elif p:\n            neg1e = Rational(p, q)\n            for e, b in pnew.items():\n                if e == neg1e and b.is_positive:\n                    pnew[e] = -b\n                    break\n            else:\n                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n    c_part.extend([Pow(b, e) for e, b in pnew.items()])\n    if coeff is S.Infinity or coeff is S.NegativeInfinity:\n\n        def _handle_for_oo(c_part, coeff_sign):\n            new_c_part = []\n            for t in c_part:\n                if t.is_positive:\n                    continue\n                if t.is_negative:\n                    coeff_sign *= -1\n                    continue\n                new_c_part.append(t)\n            return (new_c_part, coeff_sign)\n        c_part, coeff_sign = _handle_for_oo(c_part, 1)\n        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n        coeff *= coeff_sign\n    if coeff is S.ComplexInfinity:\n        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n    elif coeff is S.Zero:\n        if any((c.is_finite == False for c in c_part)):\n            return ([S.NaN], [], order_symbols)\n        return ([coeff], [], order_symbols)\n    _new = []\n    for i in c_part:\n        if i.is_Number:\n            coeff *= i\n        else:\n            _new.append(i)\n    c_part = _new\n    _mulsort(c_part)\n    if coeff is not S.One:\n        c_part.insert(0, coeff)\n    if global_distribute[0] and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add:\n        coeff = c_part[0]\n        c_part = [Add(*[coeff * f for f in c_part[1].args])]\n    return (c_part, nc_part, order_symbols)",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (S.One, self)",
    ".sympy.core.power.py@@Pow.as_base_exp": "def as_base_exp(self):\n    b, e = self.args\n    if b.is_Rational and b.p == 1 and (b.q != 1):\n        return (Integer(b.q), -e)\n    return (b, e)",
    ".sympy.core.mul.py@@Mul._gather": "def _gather(c_powers):\n    common_b = {}\n    for b, e in c_powers:\n        co = e.as_coeff_Mul()\n        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n    for b, d in common_b.items():\n        for di, li in d.items():\n            d[di] = Add(*li)\n    new_c_powers = []\n    for b, e in common_b.items():\n        new_c_powers.extend([(b, c * t) for t, c in e.items()])\n    return new_c_powers",
    ".sympy.core.operations.py@@AssocOp.make_args": "def make_args(cls, expr):\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    ".sympy.core.numbers.py@@Zero.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.core.mul.py@@_mulsort": "def _mulsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.operations.py@@AssocOp._from_args": "def _from_args(cls, args, is_commutative=None):\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n    obj = super(AssocOp, cls).__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and((a.is_commutative for a in args))\n    obj.is_commutative = is_commutative\n    return obj",
    ".sympy.core.expr.py@@Expr.is_number": "def is_number(self):\n    return all((obj.is_number for obj in self.args))",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    tself = type(self)\n    tother = type(other)\n    if type(self) is not type(other):\n        try:\n            other = _sympify(other)\n            tother = type(other)\n        except SympifyError:\n            return NotImplemented\n        if PY3 or type(tself).__ne__ is not type.__ne__:\n            if tself != tother:\n                return False\n        elif tself is not tother:\n            return False\n    return self._hashable_content() == other._hashable_content()",
    ".sympy.core.mul.py@@Mul._eval_power": "def _eval_power(b, e):\n    cargs, nc = b.args_cnc(split_1=False)\n    if e.is_Integer:\n        return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * Pow(Mul._from_args(nc), e, evaluate=False)\n    if e.is_Rational and e.q == 2:\n        from sympy.core.power import integer_nthroot\n        from sympy.functions.elementary.complexes import sign\n        if b.is_imaginary:\n            a = b.as_real_imag()[1]\n            if a.is_Rational:\n                n, d = abs(a / 2).as_numer_denom()\n                n, t = integer_nthroot(n, 2)\n                if t:\n                    d, t = integer_nthroot(d, 2)\n                    if t:\n                        r = sympify(n) / d\n                        return _unevaluated_Mul(r ** e.p, (1 + sign(a) * S.ImaginaryUnit) ** e.p)\n    p = Pow(b, e, evaluate=False)\n    if e.is_Rational or e.is_Float:\n        return p._eval_expand_power_base()\n    return p",
    ".sympy.core.expr.py@@Expr.args_cnc": "def args_cnc(self, cset=False, warn=True, split_1=True):\n    if self.is_Mul:\n        args = list(self.args)\n    else:\n        args = [self]\n    for i, mi in enumerate(args):\n        if not mi.is_commutative:\n            c = args[:i]\n            nc = args[i:]\n            break\n    else:\n        c = args\n        nc = []\n    if c and split_1 and (c[0].is_Number and c[0].is_negative and (c[0] is not S.NegativeOne)):\n        c[:1] = [S.NegativeOne, -c[0]]\n    if cset:\n        clen = len(c)\n        c = set(c)\n        if clen and warn and (len(c) != clen):\n            raise ValueError('repeated commutative arguments: %s' % [ci for ci in c if list(self.args).count(ci) > 1])\n    return [c, nc]",
    ".sympy.core.assumptions.py@@StdFactKB.copy": "def copy(self):\n    return self.__class__(self)",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.assumptions.py@@_ask": "def _ask(fact, obj):\n    assumptions = obj._assumptions\n    handler_map = obj._prop_handler\n    assumptions._tell(fact, None)\n    try:\n        evaluate = handler_map[fact]\n    except KeyError:\n        pass\n    else:\n        a = evaluate(obj)\n        if a is not None:\n            assumptions.deduce_all_facts(((fact, a),))\n            return a\n    prereq = list(_assume_rules.prereq[fact])\n    shuffle(prereq)\n    for pk in prereq:\n        if pk in assumptions:\n            continue\n        if pk in handler_map:\n            _ask(pk, obj)\n            ret_val = assumptions.get(fact)\n            if ret_val is not None:\n                return ret_val\n    return None",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.power.py@@Pow._eval_is_zero": "def _eval_is_zero(self):\n    if self.base.is_zero:\n        if self.exp.is_positive:\n            return True\n        elif self.exp.is_nonpositive:\n            return False\n    elif self.base.is_zero is False:\n        if self.exp.is_finite:\n            return False\n        elif self.exp.is_infinite:\n            if (1 - abs(self.base)).is_positive:\n                return self.exp.is_positive\n            elif (1 - abs(self.base)).is_negative:\n                return self.exp.is_negative\n    else:\n        return None",
    ".sympy.core.power.py@@Pow.base": "def base(self):\n    return self._args[0]",
    ".sympy.core.power.py@@Pow.exp": "def exp(self):\n    return self._args[1]",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.numbers.py@@Rational.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (self, S.One)",
    ".sympy.core.power.py@@Pow._eval_power": "def _eval_power(self, other):\n    from sympy import Abs, arg, exp, floor, im, log, re, sign\n    b, e = self.as_base_exp()\n    if b is S.NaN:\n        return (b ** e) ** other\n    s = None\n    if other.is_integer:\n        s = 1\n    elif b.is_polar:\n        s = 1\n    elif e.is_real is not None:\n\n        def _half(e):\n            if getattr(e, 'q', None) == 2:\n                return True\n            n, d = e.as_numer_denom()\n            if n.is_integer and d == 2:\n                return True\n\n        def _n2(e):\n            try:\n                rv = e.evalf(2, strict=True)\n                if rv.is_Number:\n                    return rv\n            except PrecisionExhausted:\n                pass\n        if e.is_real:\n            if e == -1:\n                if _half(other):\n                    if b.is_negative is True:\n                        return S.NegativeOne ** other * Pow(-b, e * other)\n                    if b.is_real is False:\n                        return Pow(b.conjugate() / Abs(b) ** 2, other)\n            elif e.is_even:\n                if b.is_real:\n                    b = abs(b)\n                if b.is_imaginary:\n                    b = abs(im(b)) * S.ImaginaryUnit\n            if (abs(e) < 1) == True or e == 1:\n                s = 1\n            elif b.is_nonnegative:\n                s = 1\n            elif re(b).is_nonnegative and (abs(e) < 2) == True:\n                s = 1\n            elif fuzzy_not(im(b).is_zero) and abs(e) == 2:\n                s = 1\n            elif _half(other):\n                s = exp(2 * S.Pi * S.ImaginaryUnit * other * floor(S.Half - e * arg(b) / (2 * S.Pi)))\n                if s.is_real and _n2(sign(s) - s) == 0:\n                    s = sign(s)\n                else:\n                    s = None\n        else:\n            try:\n                s = exp(2 * S.ImaginaryUnit * S.Pi * other * floor(S.Half - im(e * log(b)) / 2 / S.Pi))\n                if s.is_real and _n2(sign(s) - s) == 0:\n                    s = sign(s)\n                else:\n                    s = None\n            except PrecisionExhausted:\n                s = None\n    if s is not None:\n        return s * Pow(b, e * other)",
    ".sympy.core.numbers.py@@Rational.__mul__": "def __mul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, Integer):\n            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))\n        elif isinstance(other, Float):\n            return other * self\n        else:\n            return Number.__mul__(self, other)\n    return Number.__mul__(self, other)",
    ".sympy.core.numbers.py@@Rational._hashable_content": "def _hashable_content(self):\n    return (self.p, self.q)",
    ".sympy.core.assumptions.py@@StdFactKB.generator": "def generator(self):\n    return self._generator.copy()",
    ".sympy.core.expr.py@@Expr._eval_is_negative": "def _eval_is_negative(self):\n    from sympy.polys.numberfields import minimal_polynomial\n    from sympy.polys.polyerrors import NotAlgebraic\n    if self.is_number:\n        if self.is_real is False:\n            return False\n        try:\n            n2 = self._eval_evalf(2)\n            if n2 is None:\n                raise AttributeError\n            if n2._prec == 1:\n                raise AttributeError\n            if n2 == S.NaN:\n                raise AttributeError\n        except (AttributeError, ValueError):\n            return None\n        n, i = self.evalf(2).as_real_imag()\n        if not i.is_Number or not n.is_Number:\n            return False\n        if n._prec != 1 and i._prec != 1:\n            return bool(not i and n < 0)\n        elif n._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):\n            try:\n                if minimal_polynomial(self).is_Symbol:\n                    return False\n            except (NotAlgebraic, NotImplementedError):\n                pass",
    ".sympy.core.numbers.py@@Number._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Rational._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_rational(self.p, self.q, prec, rnd)",
    ".sympy.core.numbers.py@@Float._new": "def _new(cls, _mpf_, _prec):\n    if _mpf_ == _mpf_zero:\n        return S.Zero\n    elif _mpf_ == _mpf_nan:\n        return S.NaN\n    obj = Expr.__new__(cls)\n    obj._mpf_ = mpf_norm(_mpf_, _prec)\n    obj._prec = _prec\n    return obj",
    ".sympy.core.numbers.py@@mpf_norm": "def mpf_norm(mpf, prec):\n    sign, man, expt, bc = mpf\n    if not man:\n        if not bc:\n            return _mpf_zero\n        else:\n            return mpf\n    from mpmath.libmp.backend import MPZ\n    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n    return rv",
    ".sympy.core.numbers.py@@Float.__eq__": "def __eq__(self, other):\n    if isinstance(other, float):\n        o = Float(other)\n        try:\n            ompf = o._as_mpf_val(self._prec)\n        except ValueError:\n            return False\n        return bool(mlib.mpf_eq(self._mpf_, ompf))\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Float:\n        return bool(mlib.mpf_eq(self._mpf_, other._mpf_))\n    if other.is_Number:\n        ompf = other._as_mpf_val(self._prec)\n        return bool(mlib.mpf_eq(self._mpf_, ompf))\n    return False",
    ".sympy.core.numbers.py@@NaN._as_mpf_val": "def _as_mpf_val(self, prec):\n    return _mpf_nan",
    ".sympy.core.evalf.py@@EvalfMixin.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    from sympy import Float, Number\n    n = n if n is not None else 15\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n    if n == 1 and isinstance(self, Number):\n        from sympy.core.expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        try:\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            return v\n    re, im, re_acc, im_acc = result\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im * S.ImaginaryUnit\n    else:\n        return re",
    ".sympy.core.evalf.py@@evalf": "def evalf(x, prec, options):\n    from sympy import re as re_, im as im_\n    try:\n        rf = evalf_table[x.func]\n        r = rf(x, prec, options)\n    except KeyError:\n        try:\n            if 'subs' in options:\n                x = x.subs(evalf_subs(prec, options['subs']))\n            xe = x._eval_evalf(prec)\n            re, im = xe.as_real_imag()\n            if re.has(re_) or im.has(im_):\n                raise NotImplementedError\n            if re == 0:\n                re = None\n                reprec = None\n            elif re.is_number:\n                re = re._to_mpmath(prec, allow_ints=False)._mpf_\n                reprec = prec\n            else:\n                raise NotImplementedError\n            if im == 0:\n                im = None\n                imprec = None\n            elif im.is_number:\n                im = im._to_mpmath(prec, allow_ints=False)._mpf_\n                imprec = prec\n            else:\n                raise NotImplementedError\n            r = (re, im, reprec, imprec)\n        except AttributeError:\n            raise NotImplementedError\n    if options.get('verbose'):\n        print('### input', x)\n        print('### output', to_str(r[0] or fzero, 50))\n        print('### raw', r)\n        print()\n    chop = options.get('chop', False)\n    if chop:\n        if chop is True:\n            chop_prec = prec\n        else:\n            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))\n            if chop_prec == 3:\n                chop_prec -= 1\n        r = chop_parts(r, chop_prec)\n    if options.get('strict'):\n        check_target(x, r, prec)\n    return r",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.core.expr.py@@Expr.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy import im, re\n    if hints.get('ignore') == self:\n        return None\n    else:\n        return (re(self), im(self))",
    ".sympy.core.sympify.py@@SympifyError.__init__": "def __init__(self, expr, base_exc=None):\n    self.expr = expr\n    self.base_exc = base_exc",
    ".sympy.core.numbers.py@@Float.__hash__": "def __hash__(self):\n    return super(Float, self).__hash__()",
    ".sympy.core.numbers.py@@Float._hashable_content": "def _hashable_content(self):\n    return (self._mpf_, self._prec)",
    ".sympy.functions.elementary.complexes.py@@re.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_real:\n        return arg\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        return S.Zero\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[0]\n    elif arg.is_Function and isinstance(arg, conjugate):\n        return re(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_real:\n                    reverted.append(coeff)\n            elif not term.has(S.ImaginaryUnit) and term.is_real:\n                excluded.append(term)\n            else:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[0])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) - im(b) + c",
    ".sympy.functions.elementary.complexes.py@@im.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_real:\n        return S.Zero\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        return -S.ImaginaryUnit * arg\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[1]\n    elif arg.is_Function and isinstance(arg, conjugate):\n        return -im(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_real:\n                    reverted.append(coeff)\n                else:\n                    excluded.append(coeff)\n            elif term.has(S.ImaginaryUnit) or not term.is_real:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[1])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) + re(b) + c",
    ".sympy.core.numbers.py@@Float.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    if other.is_NumberSymbol:\n        return other.__gt__(self)\n    if other.is_Rational and (not other.is_Integer):\n        self *= other.q\n        other = _sympify(other.p)\n    elif other.is_comparable:\n        other = other.evalf()\n    if other.is_Number and other is not S.NaN:\n        return _sympify(bool(mlib.mpf_lt(self._mpf_, other._as_mpf_val(self._prec))))\n    return Expr.__lt__(self, other)",
    ".sympy.core.basic.py@@Basic.is_comparable": "def is_comparable(self):\n    is_real = self.is_real\n    if is_real is False:\n        return False\n    if not self.is_number:\n        return False\n    n, i = [p.evalf(2) if not p.is_Number else p for p in self.as_real_imag()]\n    if not (i.is_Number and n.is_Number):\n        return False\n    if i:\n        return False\n    else:\n        return n._prec != 1",
    ".sympy.core.numbers.py@@Integer._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_int(self.p, prec, rnd)",
    ".sympy.core.numbers.py@@Rational.__neg__": "def __neg__(self):\n    return Rational(-self.p, self.q)",
    ".sympy.core.numbers.py@@Rational._eval_power": "def _eval_power(self, expt):\n    if isinstance(expt, Number):\n        if isinstance(expt, Float):\n            return self._eval_evalf(expt._prec) ** expt\n        if expt.is_negative:\n            ne = -expt\n            if ne is S.One:\n                return Rational(self.q, self.p)\n            if self.is_negative:\n                return S.NegativeOne ** expt * Rational(self.q, -self.p) ** ne\n            else:\n                return Rational(self.q, self.p) ** ne\n        if expt is S.Infinity:\n            if self.p > self.q:\n                return S.Infinity\n            if self.p < -self.q:\n                return S.Infinity + S.Infinity * S.ImaginaryUnit\n            return S.Zero\n        if isinstance(expt, Integer):\n            return Rational(self.p ** expt.p, self.q ** expt.p, 1)\n        if isinstance(expt, Rational):\n            if self.p != 1:\n                return Integer(self.p) ** expt * Integer(self.q) ** (-expt)\n            return Integer(self.q) ** Rational(expt.p * (expt.q - 1), expt.q) / Integer(self.q) ** Integer(expt.p)\n    if self.is_negative and expt.is_even:\n        return (-self) ** expt\n    return",
    ".sympy.core.expr.py@@Expr.__div__": "def __div__(self, other):\n    return Mul(self, Pow(other, S.NegativeOne))",
    ".sympy.core.expr.py@@Expr.__mul__": "def __mul__(self, other):\n    return Mul(self, other)",
    ".sympy.core.mul.py@@Mul._eval_is_zero": "def _eval_is_zero(self):\n    zero = infinite = False\n    for a in self.args:\n        z = a.is_zero\n        if z:\n            if infinite:\n                return\n            zero = True\n        else:\n            if not a.is_finite:\n                if zero:\n                    return\n                infinite = True\n            if zero is False and z is None:\n                zero = None\n    return zero",
    ".sympy.core.power.py@@Pow._eval_is_finite": "def _eval_is_finite(self):\n    if self.exp.is_negative:\n        if self.base.is_zero:\n            return False\n        if self.base.is_infinite:\n            return True\n    c1 = self.base.is_finite\n    if c1 is None:\n        return\n    c2 = self.exp.is_finite\n    if c2 is None:\n        return\n    if c1 and c2:\n        if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):\n            return True",
    ".sympy.core.logic.py@@_fuzzy_group": "def _fuzzy_group(args, quick_exit=False):\n    saw_other = False\n    for a in args:\n        if a is True:\n            continue\n        if a is None:\n            return\n        if quick_exit and saw_other:\n            return\n        saw_other = True\n    return not saw_other",
    ".sympy.core.numbers.py@@NegativeOne.__abs__": "def __abs__():\n    return S.One",
    ".sympy.core.numbers.py@@Number._eval_is_finite": "def _eval_is_finite(self):\n    return True",
    ".sympy.logic.boolalg.py@@BooleanFalse.__nonzero__": "def __nonzero__(self):\n    return False"
}