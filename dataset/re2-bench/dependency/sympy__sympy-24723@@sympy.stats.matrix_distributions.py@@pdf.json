{
    ".sympy.stats.rv.py@@NamedArgsMixin.__getattr__": "def __getattr__(self, attr):\n    try:\n        return self.args[self._argnames.index(attr)]\n    except ValueError:\n        raise AttributeError(\"'%s' object has no attribute '%s'\" % (type(self).__name__, attr))",
    ".sympy.core.basic.py@@Basic.args": "def args(self) -> tuple[Basic, ...]:\n    return self._args",
    ".sympy.matrices.immutable.py@@ImmutableRepMatrix.shape": "def shape(self):\n    return (self._rows, self._cols)",
    ".sympy.core.numbers.py@@Integer.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, str):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    if ival == 1:\n        return S.One\n    if ival == -1:\n        return S.NegativeOne\n    if ival == 0:\n        return S.Zero\n    obj = Expr.__new__(cls)\n    obj.p = ival\n    return obj",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.numbers.py@@Integer.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    ".sympy.core.decorators.py@@__sympifyit_wrapper": "def __sympifyit_wrapper(a, b):\n    try:\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    cls = getattr(a, '__class__', None)\n    for superclass in getmro(cls):\n        conv = _external_converter.get(superclass)\n        if conv is None:\n            conv = _sympy_converter.get(superclass)\n        if conv is not None:\n            return conv(a)\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from sympy.tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(), locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        else:\n            for coerce in (float, int):\n                try:\n                    return sympify(coerce(a))\n                except (TypeError, ValueError, AttributeError, SympifyError):\n                    continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational, evaluate=evaluate) for x in a])\n        except TypeError:\n            pass\n    if not isinstance(a, str):\n        try:\n            a = str(a)\n        except Exception as exc:\n            raise SympifyError(a, exc)\n        sympy_deprecation_warning(f'\\nThe string fallback in sympify() is deprecated.\\n\\nTo explicitly convert the string form of an object, use\\nsympify(str(obj)). To add define sympify behavior on custom\\nobjects, use sympy.core.sympify.converter or define obj._sympy_\\n(see the sympify() docstring).\\n\\nsympify() performed the string fallback resulting in the following string:\\n\\n{a!r}\\n            ', deprecated_since_version='1.6', active_deprecations_target='deprecated-sympify-string-fallback')\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.numbers.py@@Rational.__truediv__": "def __truediv__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            if self.p and other.p == S.Zero:\n                return S.ComplexInfinity\n            else:\n                return Rational(self.p, self.q * other.p, igcd(self.p, other.p))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q, self.q * other.p, igcd(self.p, other.p) * igcd(self.q, other.q))\n        elif isinstance(other, Float):\n            return self * (1 / other)\n        else:\n            return Number.__truediv__(self, other)\n    return Number.__truediv__(self, other)",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.numbers.py@@igcd": "def igcd(*args):\n    if len(args) < 2:\n        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))\n    args_temp = [abs(as_int(i)) for i in args]\n    if 1 in args_temp:\n        return 1\n    a = args_temp.pop()\n    if HAS_GMPY:\n        for b in args_temp:\n            a = gmpy.gcd(a, b) if b else a\n        return as_int(a)\n    for b in args_temp:\n        a = math.gcd(a, b)\n    return a",
    ".sympy.utilities.misc.py@@as_int": "def as_int(n, strict=True):\n    if strict:\n        try:\n            if isinstance(n, bool):\n                raise TypeError\n            return operator.index(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n != result:\n            raise ValueError('%s is not an integer' % (n,))\n        return result",
    ".sympy.core.numbers.py@@Rational.__new__": "def __new__(cls, p, q=None, gcd=None):\n    if q is None:\n        if isinstance(p, Rational):\n            return p\n        if isinstance(p, SYMPY_INTS):\n            pass\n        else:\n            if isinstance(p, (float, Float)):\n                return Rational(*_as_integer_ratio(p))\n            if not isinstance(p, str):\n                try:\n                    p = sympify(p)\n                except (SympifyError, SyntaxError):\n                    pass\n            else:\n                if p.count('/') > 1:\n                    raise TypeError('invalid input: %s' % p)\n                p = p.replace(' ', '')\n                pq = p.rsplit('/', 1)\n                if len(pq) == 2:\n                    p, q = pq\n                    fp = fractions.Fraction(p)\n                    fq = fractions.Fraction(q)\n                    p = fp / fq\n                try:\n                    p = fractions.Fraction(p)\n                except ValueError:\n                    pass\n                else:\n                    return Rational(p.numerator, p.denominator, 1)\n            if not isinstance(p, Rational):\n                raise TypeError('invalid input: %s' % p)\n        q = 1\n        gcd = 1\n    Q = 1\n    if not isinstance(p, SYMPY_INTS):\n        p = Rational(p)\n        Q *= p.q\n        p = p.p\n    else:\n        p = int(p)\n    if not isinstance(q, SYMPY_INTS):\n        q = Rational(q)\n        p *= q.q\n        Q *= q.p\n    else:\n        Q *= int(q)\n    q = Q\n    if q == 0:\n        if p == 0:\n            if _errdict['divide']:\n                raise ValueError('Indeterminate 0/0')\n            else:\n                return S.NaN\n        return S.ComplexInfinity\n    if q < 0:\n        q = -q\n        p = -p\n    if not gcd:\n        gcd = igcd(abs(p), q)\n    if gcd > 1:\n        p //= gcd\n        q //= gcd\n    if q == 1:\n        return Integer(p)\n    if p == 1 and q == 2:\n        return S.Half\n    obj = Expr.__new__(cls)\n    obj.p = p\n    obj.q = q\n    return obj",
    ".sympy.core.function.py@@Function.__new__": "def __new__(cls, *args, **options):\n    if cls is Function:\n        return UndefinedFunction(*args, **options)\n    n = len(args)\n    if not cls._valid_nargs(n):\n        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'\n        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})\n    evaluate = options.get('evaluate', global_parameters.evaluate)\n    result = super().__new__(cls, *args, **options)\n    if evaluate and isinstance(result, cls) and result.args:\n        _should_evalf = [cls._should_evalf(a) for a in result.args]\n        pr2 = min(_should_evalf)\n        if pr2 > 0:\n            pr = max(_should_evalf)\n            result = result.evalf(prec_to_dps(pr))\n    return _sympify(result)",
    ".sympy.core.function.py@@FunctionClass._valid_nargs": "def _valid_nargs(self, n: int) -> bool:\n    if self._nargs:\n        return n in self._nargs\n    nargs = self.nargs\n    return nargs is S.Naturals0 or n in nargs",
    ".sympy.core.function.py@@Application.__new__": "def __new__(cls, *args, **options):\n    from sympy.sets.fancysets import Naturals0\n    from sympy.sets.sets import FiniteSet\n    args = list(map(sympify, args))\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    options.pop('nargs', None)\n    if options:\n        raise ValueError('Unknown options: %s' % options)\n    if evaluate:\n        evaluated = cls.eval(*args)\n        if evaluated is not None:\n            return evaluated\n    obj = super().__new__(cls, *args, **options)\n    sentinel = object()\n    objnargs = getattr(obj, 'nargs', sentinel)\n    if objnargs is not sentinel:\n        if is_sequence(objnargs):\n            nargs = tuple(ordered(set(objnargs)))\n        elif objnargs is not None:\n            nargs = (as_int(objnargs),)\n        else:\n            nargs = None\n    else:\n        nargs = obj._nargs\n    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()\n    return obj",
    ".sympy.core.basic.py@@Basic.__sympy__": "def __sympy__(self):\n    return True",
    ".sympy.functions.special.gamma_functions.py@@multigamma.eval": "def eval(cls, x, p):\n    from sympy.concrete.products import Product\n    if p.is_positive is False or p.is_integer is False:\n        raise ValueError('Order parameter p must be positive integer.')\n    k = Dummy('k')\n    return (pi ** (p * (p - 1) / 4) * Product(gamma(x + (1 - k) / 2), (k, 1, p))).doit()",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.assumptions.py@@StdFactKB.copy": "def copy(self):\n    return self.__class__(self)",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    super().__init__(_assume_rules)\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.__init__": "def __init__(self, rules):\n    self.rules = rules",
    ".sympy.core.assumptions.py@@StdFactKB.generator": "def generator(self):\n    return self._generator.copy()",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.assumptions.py@@_ask": "def _ask(fact, obj):\n    assumptions = obj._assumptions\n    handler_map = obj._prop_handler\n    facts_to_check = [fact]\n    facts_queued = {fact}\n    for fact_i in facts_to_check:\n        if fact_i in assumptions:\n            continue\n        fact_i_value = None\n        handler_i = handler_map.get(fact_i)\n        if handler_i is not None:\n            fact_i_value = handler_i(obj)\n        if fact_i_value is not None:\n            assumptions.deduce_all_facts(((fact_i, fact_i_value),))\n        fact_value = assumptions.get(fact)\n        if fact_value is not None:\n            return fact_value\n        new_facts_to_check = list(_assume_rules.prereq[fact_i] - facts_queued)\n        shuffle(new_facts_to_check)\n        facts_to_check.extend(new_facts_to_check)\n        facts_queued.update(new_facts_to_check)\n    if fact in assumptions:\n        return assumptions[fact]\n    assumptions._tell(fact, None)\n    return None",
    ".sympy.core.numbers.py@@Rational._eval_is_positive": "def _eval_is_positive(self):\n    return self.p > 0",
    ".sympy.core.symbol.py@@Dummy.__new__": "def __new__(cls, name=None, dummy_index=None, **assumptions):\n    if dummy_index is not None:\n        assert name is not None, 'If you specify a dummy_index, you must also provide a name'\n    if name is None:\n        name = 'Dummy_' + str(Dummy._count)\n    if dummy_index is None:\n        dummy_index = Dummy._base_dummy_index + Dummy._count\n        Dummy._count += 1\n    cls._sanitize(assumptions, cls)\n    obj = Symbol.__xnew__(cls, name, **assumptions)\n    obj.dummy_index = dummy_index\n    return obj",
    ".sympy.core.symbol.py@@Symbol._sanitize": "def _sanitize(assumptions, obj=None):\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    if is_commutative is None:\n        whose = '%s ' % obj.__name__ if obj else ''\n        raise ValueError('%scommutativity must be True or False.' % whose)\n    for key in list(assumptions.keys()):\n        v = assumptions[key]\n        if v is None:\n            assumptions.pop(key)\n            continue\n        assumptions[key] = bool(v)",
    ".sympy.core.logic.py@@fuzzy_bool": "def fuzzy_bool(x):\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    ".sympy.core.symbol.py@@Symbol.__xnew__": "def __xnew__(cls, name, **assumptions):\n    if not isinstance(name, str):\n        raise TypeError('name should be a string, not %s' % repr(type(name)))\n    obj = Expr.__new__(cls)\n    obj.name = name\n    tmp_asm_copy = assumptions.copy()\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    assumptions['commutative'] = is_commutative\n    obj._assumptions = StdFactKB(assumptions)\n    obj._assumptions._generator = tmp_asm_copy\n    return obj",
    ".sympy.core.numbers.py@@Integer.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p * other)\n        elif isinstance(other, Integer):\n            return Integer(self.p * other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    ".sympy.core.expr.py@@Expr.__pow__": "def __pow__(self, other, mod=None) -> Expr:\n    if mod is None:\n        return self._pow(other)\n    try:\n        _self, other, mod = (as_int(self), as_int(other), as_int(mod))\n        if other >= 0:\n            return _sympify(pow(_self, other, mod))\n        else:\n            from .numbers import mod_inverse\n            return _sympify(mod_inverse(pow(_self, -other, mod), mod))\n    except ValueError:\n        power = self._pow(other)\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    ".sympy.core.decorators.py@@_SympifyWrapper._func": "def _func(self, other):\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    ".sympy.core.decorators.py@@binary_op_wrapper": "def binary_op_wrapper(self, other):\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:\n            f = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    ".sympy.core.expr.py@@Expr._pow": "def _pow(self, other):\n    return Pow(self, other)",
    ".sympy.core.power.py@@Pow.__new__": "def __new__(cls, b, e, evaluate=None):\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    b = _sympify(b)\n    e = _sympify(e)\n    from .relational import Relational\n    if isinstance(b, Relational) or isinstance(e, Relational):\n        raise TypeError('Relational cannot be used in Pow')\n    for arg in [b, e]:\n        if not isinstance(arg, Expr):\n            sympy_deprecation_warning(f'\\nUsing non-Expr arguments in Pow is deprecated (in this case, one of the\\narguments is of type {type(arg).__name__!r}).\\n\\nIf you really did intend to construct a power with this base, use the **\\noperator instead.', deprecated_since_version='1.7', active_deprecations_target='non-expr-args-deprecated', stacklevel=4)\n    if evaluate:\n        if e is S.ComplexInfinity:\n            return S.NaN\n        if e is S.Infinity:\n            if is_gt(b, S.One):\n                return S.Infinity\n            if is_gt(b, S.NegativeOne) and is_lt(b, S.One):\n                return S.Zero\n            if is_lt(b, S.NegativeOne):\n                if b.is_finite:\n                    return S.ComplexInfinity\n                if b.is_finite is False:\n                    return S.NaN\n        if e is S.Zero:\n            return S.One\n        elif e is S.One:\n            return b\n        elif e == -1 and (not b):\n            return S.ComplexInfinity\n        elif e.__class__.__name__ == 'AccumulationBounds':\n            if b == S.Exp1:\n                from sympy.calculus.accumulationbounds import AccumBounds\n                return AccumBounds(Pow(b, e.min), Pow(b, e.max))\n        elif (e.is_Symbol and e.is_integer or e.is_Integer) and (b.is_number and b.is_Mul or b.is_Number) and b.could_extract_minus_sign():\n            if e.is_even:\n                b = -b\n            elif e.is_odd:\n                return -Pow(-b, e)\n        if S.NaN in (b, e):\n            return S.NaN\n        elif b is S.One:\n            if abs(e).is_infinite:\n                return S.NaN\n            return S.One\n        else:\n            from sympy.functions.elementary.exponential import exp_polar\n            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):\n                from .exprtools import factor_terms\n                from sympy.functions.elementary.exponential import log\n                from sympy.simplify.radsimp import fraction\n                c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n                num, den = fraction(ex)\n                if isinstance(den, log) and den.args[0] == b:\n                    return S.Exp1 ** (c * num)\n                elif den.is_Add:\n                    from sympy.functions.elementary.complexes import sign, im\n                    s = sign(im(b))\n                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):\n                        return S.Exp1 ** (c * num)\n            obj = b._eval_power(e)\n            if obj is not None:\n                return obj\n    obj = Expr.__new__(cls, b, e)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if not isinstance(obj, Pow):\n        return obj\n    obj.is_commutative = b.is_commutative and e.is_commutative\n    return obj",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if not isinstance(other, Number):\n        return False\n    if not self:\n        return not other\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Rational:\n        return self.p == other.p and self.q == other.q\n    if other.is_Float:\n        if self.q & self.q - 1:\n            return False\n        s, m, t = other._mpf_[:3]\n        if s:\n            m = -m\n        if not t:\n            if not self.is_Integer or self.is_even:\n                return False\n            return m == self.p\n        from .power import integer_log\n        if t > 0:\n            if not self.is_Integer:\n                return False\n            return self.p and (not self.p % m) and (integer_log(self.p // m, 2) == (t, True))\n        if self.is_Integer:\n            return False\n        return m == self.p and integer_log(self.q, 2) == (-t, True)\n    return False",
    ".sympy.core.numbers.py@@NumberSymbol.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if self is other:\n        return True\n    if other.is_Number and self.is_irrational:\n        return False\n    return False",
    ".sympy.core.expr.py@@Expr._eval_power": "def _eval_power(self, other):\n    return None",
    ".sympy.core.basic.py@@Basic._exec_constructor_postprocessors": "def _exec_constructor_postprocessors(cls, obj):\n    clsname = obj.__class__.__name__\n    postprocessors = defaultdict(list)\n    for i in obj.args:\n        try:\n            postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)\n            for k, v in chain.from_iterable(postprocessor_mappings):\n                postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n        except TypeError:\n            pass\n    for f in postprocessors.get(clsname, []):\n        obj = f(obj)\n    return obj",
    ".sympy.core.expr.py@@Expr.__rsub__": "def __rsub__(self, other):\n    return Add(other, -self)",
    ".sympy.core.expr.py@@Expr.__neg__": "def __neg__(self):\n    c = self.is_commutative\n    return Mul._from_args((S.NegativeOne, self), c)",
    ".sympy.core.operations.py@@AssocOp._from_args": "def _from_args(cls, args, is_commutative=None):\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n    obj = super().__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and((a.is_commutative for a in args))\n    obj.is_commutative = is_commutative\n    return obj",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, evaluate=None, _sympify=True):\n    if _sympify:\n        args = list(map(_sympify_, args))\n    typ = cls._args_type\n    if typ is not None:\n        from .relational import Relational\n        if any((isinstance(arg, Relational) for arg in args)):\n            raise TypeError('Relational cannot be used in %s' % cls.__name__)\n        for arg in args:\n            if not isinstance(arg, typ):\n                sympy_deprecation_warning(f'\\n\\nUsing non-Expr arguments in {cls.__name__} is deprecated (in this case, one of\\nthe arguments has type {type(arg).__name__!r}).\\n\\nIf you really did intend to use a multiplication or addition operation with\\nthis object, use the * or + operator instead.\\n\\n                        ', deprecated_since_version='1.7', active_deprecations_target='non-expr-args-deprecated', stacklevel=4)\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if not evaluate:\n        obj = cls._from_args(args)\n        obj = cls._exec_constructor_postprocessors(obj)\n        return obj\n    args = [a for a in args if a is not cls.identity]\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if order_symbols is not None:\n        from sympy.series.order import Order\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.core.add.py@@Add.flatten": "def flatten(cls, seq):\n    from sympy.calculus.accumulationbounds import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    from sympy.tensor.tensor import TensExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        if a.is_Rational:\n            if b.is_Mul:\n                rv = ([a, b], [], None)\n        if rv:\n            if all((s.is_commutative for s in rv[0])):\n                return rv\n            return ([], rv[0], None)\n    terms = {}\n    coeff = S.Zero\n    order_factors = []\n    extra = []\n    for o in seq:\n        if o.is_Order:\n            if o.expr.is_zero:\n                continue\n            for o1 in order_factors:\n                if o1.contains(o):\n                    o = None\n                    break\n            if o is None:\n                continue\n            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]\n            continue\n        elif o.is_Number:\n            if (o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False)) and (not extra):\n                return ([S.NaN], [], None)\n            if coeff.is_Number or isinstance(coeff, AccumBounds):\n                coeff += o\n                if coeff is S.NaN and (not extra):\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__add__(coeff)\n            continue\n        elif isinstance(o, MatrixExpr):\n            extra.append(o)\n            continue\n        elif isinstance(o, TensExpr):\n            coeff = o.__add__(coeff) if coeff else o\n            continue\n        elif o is S.ComplexInfinity:\n            if coeff.is_finite is False and (not extra):\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o.is_Add:\n            seq.extend(o.args)\n            continue\n        elif o.is_Mul:\n            c, s = o.as_coeff_Mul()\n        elif o.is_Pow:\n            b, e = o.as_base_exp()\n            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):\n                seq.append(b ** e)\n                continue\n            c, s = (S.One, o)\n        else:\n            c = S.One\n            s = o\n        if s in terms:\n            terms[s] += c\n            if terms[s] is S.NaN and (not extra):\n                return ([S.NaN], [], None)\n        else:\n            terms[s] = c\n    newseq = []\n    noncommutative = False\n    for s, c in terms.items():\n        if c.is_zero:\n            continue\n        elif c is S.One:\n            newseq.append(s)\n        elif s.is_Mul:\n            cs = s._new_rawargs(*(c,) + s.args)\n            newseq.append(cs)\n        elif s.is_Add:\n            newseq.append(Mul(c, s, evaluate=False))\n        else:\n            newseq.append(Mul(c, s))\n        noncommutative = noncommutative or not s.is_commutative\n    if coeff is S.Infinity:\n        newseq = [f for f in newseq if not (f.is_extended_nonnegative or f.is_real)]\n    elif coeff is S.NegativeInfinity:\n        newseq = [f for f in newseq if not (f.is_extended_nonpositive or f.is_real)]\n    if coeff is S.ComplexInfinity:\n        newseq = [c for c in newseq if not (c.is_finite and c.is_extended_real is not None)]\n    if order_factors:\n        newseq2 = []\n        for t in newseq:\n            for o in order_factors:\n                if o.contains(t):\n                    t = None\n                    break\n            if t is not None:\n                newseq2.append(t)\n        newseq = newseq2 + order_factors\n        for o in order_factors:\n            if o.contains(coeff):\n                coeff = S.Zero\n                break\n    _addsort(newseq)\n    if coeff is not S.Zero:\n        newseq.insert(0, coeff)\n    if extra:\n        newseq += extra\n        noncommutative = True\n    if noncommutative:\n        return ([], newseq, None)\n    else:\n        return (newseq, [], None)",
    ".sympy.core.expr.py@@Expr.__truediv__": "def __truediv__(self, other):\n    denom = Pow(other, S.NegativeOne)\n    if self is S.One:\n        return denom\n    else:\n        return Mul(self, denom)",
    ".sympy.core.numbers.py@@Number.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    return bool(self.is_extended_negative)",
    ".sympy.core.expr.py@@Expr._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    return self._eval_is_extended_positive_negative(positive=False)",
    ".sympy.core.expr.py@@Expr._eval_is_extended_positive_negative": "def _eval_is_extended_positive_negative(self, positive):\n    from sympy.polys.numberfields import minimal_polynomial\n    from sympy.polys.polyerrors import NotAlgebraic\n    if self.is_number:\n        try:\n            n2 = self._eval_evalf(2)\n        except ValueError:\n            return None\n        if n2 is None:\n            return None\n        if getattr(n2, '_prec', 1) == 1:\n            return None\n        if n2 is S.NaN:\n            return None\n        f = self.evalf(2)\n        if f.is_Float:\n            match = (f, S.Zero)\n        else:\n            match = pure_complex(f)\n        if match is None:\n            return False\n        r, i = match\n        if not (i.is_Number and r.is_Number):\n            return False\n        if r._prec != 1 and i._prec != 1:\n            return bool(not i and (r > 0 if positive else r < 0))\n        elif r._prec == 1 and (not i or i._prec == 1) and self._eval_is_algebraic() and (not self.has(Function)):\n            try:\n                if minimal_polynomial(self).is_Symbol:\n                    return False\n            except (NotAlgebraic, NotImplementedError):\n                pass",
    ".sympy.core.numbers.py@@Number._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Integer._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_int(self.p, prec, rnd)",
    ".sympy.core.numbers.py@@Float._new": "def _new(cls, _mpf_, _prec, zero=True):\n    if zero and _mpf_ == fzero:\n        return S.Zero\n    elif _mpf_ == _mpf_nan:\n        return S.NaN\n    elif _mpf_ == _mpf_inf:\n        return S.Infinity\n    elif _mpf_ == _mpf_ninf:\n        return S.NegativeInfinity\n    obj = Expr.__new__(cls)\n    obj._mpf_ = mpf_norm(_mpf_, _prec)\n    obj._prec = _prec\n    return obj",
    ".sympy.core.numbers.py@@mpf_norm": "def mpf_norm(mpf, prec):\n    sign, man, expt, bc = mpf\n    if not man:\n        if not bc:\n            return fzero\n        else:\n            return mpf\n    from mpmath.libmp.backend import MPZ\n    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n    return rv",
    ".sympy.core.evalf.py@@EvalfMixin.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    from .numbers import Float, Number\n    n = n if n is not None else 15\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n    if n == 1 and isinstance(self, Number):\n        from .expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        if hasattr(self, 'subs') and subs is not None:\n            v = self.subs(subs)._eval_evalf(prec)\n        else:\n            v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        elif not v.is_number:\n            return v\n        try:\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            return v\n    if result is S.ComplexInfinity:\n        return result\n    re, im, re_acc, im_acc = result\n    if re is S.NaN or im is S.NaN:\n        return S.NaN\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im * S.ImaginaryUnit\n    else:\n        return re",
    ".sympy.core.evalf.py@@evalf": "def evalf(x: 'Expr', prec: int, options: OPT_DICT) -> TMP_RES:\n    from sympy.functions.elementary.complexes import re as re_, im as im_\n    try:\n        rf = evalf_table[type(x)]\n        r = rf(x, prec, options)\n    except KeyError:\n        if 'subs' in options:\n            x = x.subs(evalf_subs(prec, options['subs']))\n        xe = x._eval_evalf(prec)\n        if xe is None:\n            raise NotImplementedError\n        as_real_imag = getattr(xe, 'as_real_imag', None)\n        if as_real_imag is None:\n            raise NotImplementedError\n        re, im = as_real_imag()\n        if re.has(re_) or im.has(im_):\n            raise NotImplementedError\n        if re == 0.0:\n            re = None\n            reprec = None\n        elif re.is_number:\n            re = re._to_mpmath(prec, allow_ints=False)._mpf_\n            reprec = prec\n        else:\n            raise NotImplementedError\n        if im == 0.0:\n            im = None\n            imprec = None\n        elif im.is_number:\n            im = im._to_mpmath(prec, allow_ints=False)._mpf_\n            imprec = prec\n        else:\n            raise NotImplementedError\n        r = (re, im, reprec, imprec)\n    if options.get('verbose'):\n        print('### input', x)\n        print('### output', to_str(r[0] or fzero, 50) if isinstance(r, tuple) else r)\n        print('### raw', r)\n        print()\n    chop = options.get('chop', False)\n    if chop:\n        if chop is True:\n            chop_prec = prec\n        else:\n            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))\n            if chop_prec == 3:\n                chop_prec -= 1\n        r = chop_parts(r, chop_prec)\n    if options.get('strict'):\n        check_target(x, r, prec)\n    return r",
    ".sympy.core.evalf.py@@evalf_integer": "def evalf_integer(expr: 'Integer', prec: int, options: OPT_DICT) -> TMP_RES:\n    return (from_int(expr.p, prec), None, prec, None)",
    ".sympy.core.numbers.py@@Zero.__bool__": "def __bool__(self):\n    return False",
    ".sympy.core.numbers.py@@Float.__lt__": "def __lt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__gt__(self)\n    rv = self._Frel(other, mlib.mpf_lt)\n    if rv is None:\n        return Expr.__lt__(self, other)\n    return rv",
    ".sympy.core.numbers.py@@Float._Frel": "def _Frel(self, other, op):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Rational:\n        '\\n        >>> f = Float(.1,2)\\n        >>> i = 1234567890\\n        >>> (f*i)._mpf_\\n        (0, 471, 18, 9)\\n        >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))\\n        (0, 505555550955, -12, 39)\\n        '\n        smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))\n        ompf = mlib.from_int(other.p)\n        return _sympify(bool(op(smpf, ompf)))\n    elif other.is_Float:\n        return _sympify(bool(op(self._mpf_, other._mpf_)))\n    elif other.is_comparable and other not in (S.Infinity, S.NegativeInfinity):\n        other = other.evalf(prec_to_dps(self._prec))\n        if other._prec > 1:\n            if other.is_Number:\n                return _sympify(bool(op(self._mpf_, other._as_mpf_val(self._prec))))",
    ".sympy.logic.boolalg.py@@BooleanFalse.__bool__": "def __bool__(self):\n    return False",
    ".sympy.core.numbers.py@@Integer._eval_power": "def _eval_power(self, expt):\n    from sympy.ntheory.factor_ import perfect_power\n    if expt is S.Infinity:\n        if self.p > S.One:\n            return S.Infinity\n        return S.Infinity + S.ImaginaryUnit * S.Infinity\n    if expt is S.NegativeInfinity:\n        return Rational(1, self, 1) ** S.Infinity\n    if not isinstance(expt, Number):\n        if self.is_negative and expt.is_even:\n            return (-self) ** expt\n    if isinstance(expt, Float):\n        return super()._eval_power(expt)\n    if not isinstance(expt, Rational):\n        return\n    if expt is S.Half and self.is_negative:\n        return S.ImaginaryUnit * Pow(-self, expt)\n    if expt.is_negative:\n        ne = -expt\n        if self.is_negative:\n            return S.NegativeOne ** expt * Rational(1, -self, 1) ** ne\n        else:\n            return Rational(1, self.p, 1) ** ne\n    x, xexact = integer_nthroot(abs(self.p), expt.q)\n    if xexact:\n        result = Integer(x ** abs(expt.p))\n        if self.is_negative:\n            result *= S.NegativeOne ** expt\n        return result\n    b_pos = int(abs(self.p))\n    p = perfect_power(b_pos)\n    if p is not False:\n        dict = {p[0]: p[1]}\n    else:\n        dict = Integer(b_pos).factors(limit=2 ** 15)\n    out_int = 1\n    out_rad = 1\n    sqr_int = 1\n    sqr_gcd = 0\n    sqr_dict = {}\n    for prime, exponent in dict.items():\n        exponent *= expt.p\n        div_e, div_m = divmod(exponent, expt.q)\n        if div_e > 0:\n            out_int *= prime ** div_e\n        if div_m > 0:\n            g = igcd(div_m, expt.q)\n            if g != 1:\n                out_rad *= Pow(prime, Rational(div_m // g, expt.q // g, 1))\n            else:\n                sqr_dict[prime] = div_m\n    for p, ex in sqr_dict.items():\n        if sqr_gcd == 0:\n            sqr_gcd = ex\n        else:\n            sqr_gcd = igcd(sqr_gcd, ex)\n            if sqr_gcd == 1:\n                break\n    for k, v in sqr_dict.items():\n        sqr_int *= k ** (v // sqr_gcd)\n    if sqr_int == b_pos and out_int == 1 and (out_rad == 1):\n        result = None\n    else:\n        result = out_int * out_rad * Pow(sqr_int, Rational(sqr_gcd, expt.q))\n        if self.is_negative:\n            result *= Pow(S.NegativeOne, expt)\n    return result",
    ".sympy.core.numbers.py@@NegativeOne.__neg__": "def __neg__():\n    return S.One",
    ".sympy.core.mul.py@@Mul.flatten": "def flatten(cls, seq):\n    from sympy.calculus.accumulationbounds import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n            seq = [a, b]\n        assert a is not S.One\n        if not a.is_zero and a.is_Rational:\n            r, b = b.as_coeff_Mul()\n            if b.is_Add:\n                if r is not S.One:\n                    ar = a * r\n                    if ar is S.One:\n                        arb = b\n                    else:\n                        arb = cls(a * r, b, evaluate=False)\n                    rv = ([arb], [], None)\n                elif global_parameters.distribute and b.is_commutative:\n                    newb = Add(*[_keep_coeff(a, bi) for bi in b.args])\n                    rv = ([newb], [], None)\n        if rv:\n            return rv\n    c_part = []\n    nc_part = []\n    nc_seq = []\n    coeff = S.One\n    c_powers = []\n    num_exp = []\n    neg1e = S.Zero\n    pnum_rat = {}\n    order_symbols = None\n    for o in seq:\n        if o.is_Order:\n            o, order_symbols = o.as_expr_variables(order_symbols)\n        if o.is_Mul:\n            if o.is_commutative:\n                seq.extend(o.args)\n            else:\n                for q in o.args:\n                    if q.is_commutative:\n                        seq.append(q)\n                    else:\n                        nc_seq.append(q)\n                seq.append(NC_Marker)\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_zero):\n                return ([S.NaN], [], None)\n            elif coeff.is_Number or isinstance(coeff, AccumBounds):\n                coeff *= o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__mul__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if not coeff:\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o is S.ImaginaryUnit:\n            neg1e += S.Half\n            continue\n        elif o.is_commutative:\n            b, e = o.as_base_exp()\n            if o.is_Pow:\n                if b.is_Number:\n                    if e.is_Rational:\n                        if e.is_Integer:\n                            coeff *= Pow(b, e)\n                            continue\n                        elif e.is_negative:\n                            seq.append(Pow(b, e))\n                            continue\n                        elif b.is_negative:\n                            neg1e += e\n                            b = -b\n                        if b is not S.One:\n                            pnum_rat.setdefault(b, []).append(e)\n                        continue\n                    elif b.is_positive or e.is_integer:\n                        num_exp.append((b, e))\n                        continue\n            c_powers.append((b, e))\n        else:\n            if o is not NC_Marker:\n                nc_seq.append(o)\n            while nc_seq:\n                o = nc_seq.pop(0)\n                if not nc_part:\n                    nc_part.append(o)\n                    continue\n                o1 = nc_part.pop()\n                b1, e1 = o1.as_base_exp()\n                b2, e2 = o.as_base_exp()\n                new_exp = e1 + e2\n                if b1 == b2 and (not new_exp.is_Add):\n                    o12 = b1 ** new_exp\n                    if o12.is_commutative:\n                        seq.append(o12)\n                        continue\n                    else:\n                        nc_seq.insert(0, o12)\n                else:\n                    nc_part.extend([o1, o])\n\n    def _gather(c_powers):\n        common_b = {}\n        for b, e in c_powers:\n            co = e.as_coeff_Mul()\n            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n        for b, d in common_b.items():\n            for di, li in d.items():\n                d[di] = Add(*li)\n        new_c_powers = []\n        for b, e in common_b.items():\n            new_c_powers.extend([(b, c * t) for t, c in e.items()])\n        return new_c_powers\n    c_powers = _gather(c_powers)\n    num_exp = _gather(num_exp)\n    for i in range(2):\n        new_c_powers = []\n        changed = False\n        for b, e in c_powers:\n            if e.is_zero:\n                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):\n                    return ([S.NaN], [], None)\n                continue\n            if e is S.One:\n                if b.is_Number:\n                    coeff *= b\n                    continue\n                p = b\n            if e is not S.One:\n                p = Pow(b, e)\n                if p.is_Pow and (not b.is_Pow):\n                    bi = b\n                    b, e = p.as_base_exp()\n                    if b != bi:\n                        changed = True\n            c_part.append(p)\n            new_c_powers.append((b, e))\n        if changed and len({b for b, e in new_c_powers}) != len(new_c_powers):\n            c_part = []\n            c_powers = _gather(new_c_powers)\n        else:\n            break\n    inv_exp_dict = {}\n    for b, e in num_exp:\n        inv_exp_dict.setdefault(e, []).append(b)\n    for e, b in inv_exp_dict.items():\n        inv_exp_dict[e] = cls(*b)\n    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n    comb_e = {}\n    for b, e in pnum_rat.items():\n        comb_e.setdefault(Add(*e), []).append(b)\n    del pnum_rat\n    num_rat = []\n    for e, b in comb_e.items():\n        b = cls(*b)\n        if e.q == 1:\n            coeff *= Pow(b, e)\n            continue\n        if e.p > e.q:\n            e_i, ep = divmod(e.p, e.q)\n            coeff *= Pow(b, e_i)\n            e = Rational(ep, e.q)\n        num_rat.append((b, e))\n    del comb_e\n    pnew = defaultdict(list)\n    i = 0\n    while i < len(num_rat):\n        bi, ei = num_rat[i]\n        grow = []\n        for j in range(i + 1, len(num_rat)):\n            bj, ej = num_rat[j]\n            g = bi.gcd(bj)\n            if g is not S.One:\n                e = ei + ej\n                if e.q == 1:\n                    coeff *= Pow(g, e)\n                else:\n                    if e.p > e.q:\n                        e_i, ep = divmod(e.p, e.q)\n                        coeff *= Pow(g, e_i)\n                        e = Rational(ep, e.q)\n                    grow.append((g, e))\n                num_rat[j] = (bj / g, ej)\n                bi = bi / g\n                if bi is S.One:\n                    break\n        if bi is not S.One:\n            obj = Pow(bi, ei)\n            if obj.is_Number:\n                coeff *= obj\n            else:\n                for obj in Mul.make_args(obj):\n                    if obj.is_Number:\n                        coeff *= obj\n                    else:\n                        assert obj.is_Pow\n                        bi, ei = obj.args\n                        pnew[ei].append(bi)\n        num_rat.extend(grow)\n        i += 1\n    for e, b in pnew.items():\n        pnew[e] = cls(*b)\n    if neg1e:\n        p, q = neg1e.as_numer_denom()\n        n, p = divmod(p, q)\n        if n % 2:\n            coeff = -coeff\n        if q == 2:\n            c_part.append(S.ImaginaryUnit)\n        elif p:\n            neg1e = Rational(p, q)\n            for e, b in pnew.items():\n                if e == neg1e and b.is_positive:\n                    pnew[e] = -b\n                    break\n            else:\n                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n    c_part.extend([Pow(b, e) for e, b in pnew.items()])\n    if coeff in (S.Infinity, S.NegativeInfinity):\n\n        def _handle_for_oo(c_part, coeff_sign):\n            new_c_part = []\n            for t in c_part:\n                if t.is_extended_positive:\n                    continue\n                if t.is_extended_negative:\n                    coeff_sign *= -1\n                    continue\n                new_c_part.append(t)\n            return (new_c_part, coeff_sign)\n        c_part, coeff_sign = _handle_for_oo(c_part, 1)\n        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n        coeff *= coeff_sign\n    if coeff is S.ComplexInfinity:\n        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]\n        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]\n    elif coeff.is_zero:\n        if any((isinstance(c, MatrixExpr) for c in nc_part)):\n            return ([coeff], nc_part, order_symbols)\n        if any((c.is_finite == False for c in c_part)):\n            return ([S.NaN], [], order_symbols)\n        return ([coeff], [], order_symbols)\n    _new = []\n    for i in c_part:\n        if i.is_Number:\n            coeff *= i\n        else:\n            _new.append(i)\n    c_part = _new\n    _mulsort(c_part)\n    if coeff is not S.One:\n        c_part.insert(0, coeff)\n    if global_parameters.distribute and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add:\n        coeff = c_part[0]\n        c_part = [Add(*[coeff * f for f in c_part[1].args])]\n    return (c_part, nc_part, order_symbols)",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational: bool=False) -> tuple['Number', Expr]:\n    return (S.One, self)",
    ".sympy.core.mul.py@@_keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = (coeff, factors)\n        else:\n            return coeff * factors\n    if factors is S.One:\n        return coeff\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and (not sign):\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and (coeff.q != 1):\n            args = [i.as_coeff_Mul() for i in factors.args]\n            args = [(_keep_coeff(c, coeff), m) for c, m in args]\n            if any((c.is_Integer for c, _ in args)):\n                return Add._from_args([Mul._from_args(i[1:] if i[0] == 1 else i) for i in args])\n        return Mul(coeff, factors, evaluate=False)\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        m = coeff * factors\n        if m.is_Number and (not factors.is_Number):\n            m = Mul._from_args((coeff, factors))\n        return m",
    ".sympy.core.logic.py@@fuzzy_and": "def fuzzy_and(args):\n    rv = True\n    for ai in args:\n        ai = fuzzy_bool(ai)\n        if ai is False:\n            return False\n        if rv:\n            rv = ai\n    return rv",
    ".sympy.core.numbers.py@@Rational.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(self.p + self.q * other.p, self.q, 1)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + self.q * other.p, self.q * other.q)\n        elif isinstance(other, Float):\n            return other + self\n        else:\n            return Number.__add__(self, other)\n    return Number.__add__(self, other)",
    ".sympy.core.numbers.py@@Number.__add__": "def __add__(self, other):\n    if isinstance(other, Number) and global_parameters.evaluate:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            return S.Infinity\n        elif other is S.NegativeInfinity:\n            return S.NegativeInfinity\n    return AtomicExpr.__add__(self, other)",
    ".sympy.core.expr.py@@Expr.__add__": "def __add__(self, other):\n    return Add(self, other)",
    ".sympy.core.mul.py@@Mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return (coeff, args[0])\n            else:\n                return (coeff, self._new_rawargs(*args))\n        elif coeff.is_extended_negative:\n            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))\n    return (S.One, self)",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self) -> int:\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.symbol.py@@Dummy._hashable_content": "def _hashable_content(self):\n    return Symbol._hashable_content(self) + (self.dummy_index,)",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return {key: value for key, value in self._assumptions.items() if value is not None}",
    ".sympy.core.expr.py@@Expr.as_base_exp": "def as_base_exp(self) -> tuple[Expr, Expr]:\n    return (self, S.One)",
    ".sympy.core.mul.py@@Mul._gather": "def _gather(c_powers):\n    common_b = {}\n    for b, e in c_powers:\n        co = e.as_coeff_Mul()\n        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n    for b, d in common_b.items():\n        for di, li in d.items():\n            d[di] = Add(*li)\n    new_c_powers = []\n    for b, e in common_b.items():\n        new_c_powers.extend([(b, c * t) for t, c in e.items()])\n    return new_c_powers",
    ".sympy.core.numbers.py@@Rational.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (self, S.One)",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.numbers.py@@Infinity.__eq__": "def __eq__(self, other):\n    return other is S.Infinity or other == float('inf')",
    ".sympy.core.numbers.py@@Float.__new__": "def __new__(cls, num, dps=None, precision=None):\n    if dps is not None and precision is not None:\n        raise ValueError('Both decimal and binary precision supplied. Supply only one. ')\n    if isinstance(num, str):\n        num = num.replace(' ', '').lower()\n        if num.startswith('.') and len(num) > 1:\n            num = '0' + num\n        elif num.startswith('-.') and len(num) > 2:\n            num = '-0.' + num[2:]\n        elif num in ('inf', '+inf'):\n            return S.Infinity\n        elif num == '-inf':\n            return S.NegativeInfinity\n    elif isinstance(num, float) and num == 0:\n        num = '0'\n    elif isinstance(num, float) and num == float('inf'):\n        return S.Infinity\n    elif isinstance(num, float) and num == float('-inf'):\n        return S.NegativeInfinity\n    elif isinstance(num, float) and math.isnan(num):\n        return S.NaN\n    elif isinstance(num, (SYMPY_INTS, Integer)):\n        num = str(num)\n    elif num is S.Infinity:\n        return num\n    elif num is S.NegativeInfinity:\n        return num\n    elif num is S.NaN:\n        return num\n    elif _is_numpy_instance(num):\n        num = _convert_numpy_types(num)\n    elif isinstance(num, mpmath.mpf):\n        if precision is None:\n            if dps is None:\n                precision = num.context.prec\n        num = num._mpf_\n    if dps is None and precision is None:\n        dps = 15\n        if isinstance(num, Float):\n            return num\n        if isinstance(num, str) and _literal_float(num):\n            try:\n                Num = decimal.Decimal(num)\n            except decimal.InvalidOperation:\n                pass\n            else:\n                isint = '.' not in num\n                num, dps = _decimal_to_Rational_prec(Num)\n                if num.is_Integer and isint:\n                    dps = max(dps, len(str(num).lstrip('-')))\n                dps = max(15, dps)\n                precision = dps_to_prec(dps)\n    elif precision == '' and dps is None or (precision is None and dps == ''):\n        if not isinstance(num, str):\n            raise ValueError('The null string can only be used when the number to Float is passed as a string or an integer.')\n        ok = None\n        if _literal_float(num):\n            try:\n                Num = decimal.Decimal(num)\n            except decimal.InvalidOperation:\n                pass\n            else:\n                isint = '.' not in num\n                num, dps = _decimal_to_Rational_prec(Num)\n                if num.is_Integer and isint:\n                    dps = max(dps, len(str(num).lstrip('-')))\n                    precision = dps_to_prec(dps)\n                ok = True\n        if ok is None:\n            raise ValueError('string-float not recognized: %s' % num)\n    if precision is None or precision == '':\n        precision = dps_to_prec(dps)\n    precision = int(precision)\n    if isinstance(num, float):\n        _mpf_ = mlib.from_float(num, precision, rnd)\n    elif isinstance(num, str):\n        _mpf_ = mlib.from_str(num, precision, rnd)\n    elif isinstance(num, decimal.Decimal):\n        if num.is_finite():\n            _mpf_ = mlib.from_str(str(num), precision, rnd)\n        elif num.is_nan():\n            return S.NaN\n        elif num.is_infinite():\n            if num > 0:\n                return S.Infinity\n            return S.NegativeInfinity\n        else:\n            raise ValueError('unexpected decimal value %s' % str(num))\n    elif isinstance(num, tuple) and len(num) in (3, 4):\n        if isinstance(num[1], str):\n            num = list(num)\n            if num[1].endswith('L'):\n                num[1] = num[1][:-1]\n            if num[1].startswith('0x'):\n                num[1] = num[1][2:]\n            num[1] = MPZ(num[1], 16)\n            _mpf_ = tuple(num)\n        elif len(num) == 4:\n            return Float._new(num, precision)\n        else:\n            if not all((num[0] in (0, 1), num[1] >= 0, all((type(i) in (int, int) for i in num)))):\n                raise ValueError('malformed mpf: %s' % (num,))\n            return Float._new((num[0], num[1], num[2], bitcount(num[1])), precision)\n    else:\n        try:\n            _mpf_ = num._as_mpf_val(precision)\n        except (NotImplementedError, AttributeError):\n            _mpf_ = mpmath.mpf(num, prec=precision)._mpf_\n    return cls._new(_mpf_, precision, zero=False)",
    ".sympy.core.numbers.py@@NegativeInfinity.__eq__": "def __eq__(self, other):\n    return other is S.NegativeInfinity or other == float('-inf')",
    ".sympy.core.mul.py@@_mulsort": "def _mulsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.add.py@@_addsort": "def _addsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.functions.special.gamma_functions.py@@gamma.eval": "def eval(cls, arg):\n    if arg.is_Number:\n        if arg is S.NaN:\n            return S.NaN\n        elif arg is oo:\n            return oo\n        elif intlike(arg):\n            if arg.is_positive:\n                return factorial(arg - 1)\n            else:\n                return S.ComplexInfinity\n        elif arg.is_Rational:\n            if arg.q == 2:\n                n = abs(arg.p) // arg.q\n                if arg.is_positive:\n                    k, coeff = (n, S.One)\n                else:\n                    n = k = n + 1\n                    if n & 1 == 0:\n                        coeff = S.One\n                    else:\n                        coeff = S.NegativeOne\n                coeff *= prod(range(3, 2 * k, 2))\n                if arg.is_positive:\n                    return coeff * sqrt(pi) / 2 ** n\n                else:\n                    return 2 ** n * sqrt(pi) / coeff",
    ".sympy.sets.sets.py@@FiniteSet.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n    if evaluate:\n        args = list(map(sympify, args))\n        if len(args) == 0:\n            return S.EmptySet\n    else:\n        args = list(map(sympify, args))\n    dargs = {}\n    for i in reversed(list(ordered(args))):\n        if i.is_Symbol:\n            dargs[i] = i\n        else:\n            try:\n                dargs[i.as_dummy()] = i\n            except TypeError:\n                dargs[i] = i\n    _args_set = set(dargs.values())\n    args = list(ordered(_args_set, Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._args_set = _args_set\n    return obj",
    ".sympy.core.sorting.py@@ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    d = defaultdict(list)\n    if keys:\n        if isinstance(keys, (list, tuple)):\n            keys = list(keys)\n            f = keys.pop(0)\n        else:\n            f = keys\n            keys = []\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n    for k, value in sorted(d.items()):\n        if len(value) > 1:\n            if keys:\n                value = ordered(value, keys, default, warn)\n            elif default:\n                value = ordered(value, (_nodes, default_sort_key), default=False, warn=warn)\n            elif warn:\n                u = list(uniq(value))\n                if len(u) > 1:\n                    raise ValueError('not enough keys to break ties: %s' % u)\n        yield from value",
    ".sympy.core.basic.py@@Basic.as_dummy": "def as_dummy(self):\n    from .symbol import Dummy, Symbol\n\n    def can(x):\n        free = x.free_symbols\n        bound = set(x.bound_symbols)\n        d = {i: Dummy() for i in bound & free}\n        x = x.subs(d)\n        x = x.xreplace(x.canonical_variables)\n        return x.xreplace({v: k for k, v in d.items()})\n    if not self.has(Symbol):\n        return self\n    return self.replace(lambda x: hasattr(x, 'bound_symbols'), can, simultaneous=False)",
    ".sympy.core.basic.py@@Basic.has": "def has(self, *patterns):\n    return self._has(iterargs, *patterns)",
    ".sympy.core.basic.py@@Basic._has": "def _has(self, iterargs, *patterns):\n    type_set = set()\n    p_set = set()\n    for p in patterns:\n        if isinstance(p, type) and issubclass(p, Basic):\n            type_set.add(p)\n            continue\n        if not isinstance(p, Basic):\n            try:\n                p = _sympify(p)\n            except SympifyError:\n                continue\n        p_set.add(p)\n    types = tuple(type_set)\n    for i in iterargs(self):\n        if i in p_set:\n            return True\n        if isinstance(i, types):\n            return True\n    for i in p_set - type_set:\n        if not hasattr(i, '_has_matcher'):\n            continue\n        match = i._has_matcher()\n        if any((match(arg) for arg in iterargs(self))):\n            return True\n    return False",
    ".sympy.core.traversal.py@@iterargs": "def iterargs(expr):\n    args = [expr]\n    for i in args:\n        yield i\n        try:\n            args.extend(i.args)\n        except TypeError:\n            pass",
    ".sympy.sets.sets.py@@Set._infimum_key": "def _infimum_key(expr):\n    try:\n        infimum = expr.inf\n        assert infimum.is_comparable\n        infimum = infimum.evalf()\n    except (NotImplementedError, AttributeError, AssertionError, ValueError):\n        infimum = S.Infinity\n    return infimum",
    ".sympy.core.numbers.py@@Infinity.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.function.py@@Function._should_evalf": "def _should_evalf(cls, arg):\n    if arg.is_Float:\n        return arg._prec\n    if not arg.is_Add:\n        return -1\n    m = pure_complex(arg)\n    if m is None:\n        return -1\n    return max(m[0]._prec, m[1]._prec)",
    ".sympy.core.evalf.py@@pure_complex": "def pure_complex(v: 'Expr', or_real=False) -> tuple['Number', 'Number'] | None:\n    h, t = v.as_coeff_Add()\n    if t:\n        c, i = t.as_coeff_Mul()\n        if i is S.ImaginaryUnit:\n            return (h, c)\n    elif or_real:\n        return (h, S.Zero)\n    return None",
    ".sympy.core.add.py@@Add.as_coeff_Add": "def as_coeff_Add(self, rational=False, deps=None):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number and (not rational) or coeff.is_Rational:\n        return (coeff, self._new_rawargs(*args))\n    return (S.Zero, self)",
    ".sympy.core.operations.py@@AssocOp._new_rawargs": "def _new_rawargs(self, *args, reeval=True, **kwargs):\n    if reeval and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)",
    ".sympy.concrete.products.py@@Product.__new__": "def __new__(cls, function, *symbols, **assumptions):\n    obj = ExprWithIntLimits.__new__(cls, function, *symbols, **assumptions)\n    return obj",
    ".sympy.concrete.expr_with_limits.py@@ExprWithLimits.__new__": "def __new__(cls, function, *symbols, **assumptions):\n    from sympy.concrete.products import Product\n    pre = _common_new(cls, function, *symbols, discrete=issubclass(cls, Product), **assumptions)\n    if isinstance(pre, tuple):\n        function, limits, _ = pre\n    else:\n        return pre\n    if any((len(l) != 3 or None in l for l in limits)):\n        raise ValueError('ExprWithLimits requires values for lower and upper bounds.')\n    obj = Expr.__new__(cls, **assumptions)\n    arglist = [function]\n    arglist.extend(limits)\n    obj._args = tuple(arglist)\n    obj.is_commutative = function.is_commutative\n    return obj",
    ".sympy.concrete.expr_with_limits.py@@_common_new": "def _common_new(cls, function, *symbols, discrete, **assumptions):\n    function = sympify(function)\n    if isinstance(function, Equality):\n        limits, orientation = _process_limits(*symbols, discrete=discrete)\n        if not (limits and all((len(limit) == 3 for limit in limits))):\n            sympy_deprecation_warning('\\n                Creating a indefinite integral with an Eq() argument is\\n                deprecated.\\n\\n                This is because indefinite integrals do not preserve equality\\n                due to the arbitrary constants. If you want an equality of\\n                indefinite integrals, use Eq(Integral(a, x), Integral(b, x))\\n                explicitly.\\n                ', deprecated_since_version='1.6', active_deprecations_target='deprecated-indefinite-integral-eq', stacklevel=5)\n        lhs = function.lhs\n        rhs = function.rhs\n        return Equality(cls(lhs, *symbols, **assumptions), cls(rhs, *symbols, **assumptions))\n    if function is S.NaN:\n        return S.NaN\n    if symbols:\n        limits, orientation = _process_limits(*symbols, discrete=discrete)\n        for i, li in enumerate(limits):\n            if len(li) == 4:\n                function = function.subs(li[0], li[-1])\n                limits[i] = Tuple(*li[:-1])\n    else:\n        free = function.free_symbols\n        if len(free) != 1:\n            raise ValueError('specify dummy variables for %s' % function)\n        limits, orientation = ([Tuple(s) for s in free], 1)\n    while cls == type(function):\n        limits = list(function.limits) + limits\n        function = function.function\n    reps = {}\n    symbols_of_integration = {i[0] for i in limits}\n    for p in function.atoms(Piecewise):\n        if not p.has(*symbols_of_integration):\n            reps[p] = Dummy()\n    function = function.xreplace(reps)\n    function = piecewise_fold(function)\n    function = function.xreplace({v: k for k, v in reps.items()})\n    return (function, limits, orientation)",
    ".sympy.concrete.expr_with_limits.py@@_process_limits": "def _process_limits(*symbols, discrete=None):\n    limits = []\n    orientation = 1\n    if discrete is None:\n        err_msg = 'discrete must be True or False'\n    elif discrete:\n        err_msg = 'use Range, not Interval or Relational'\n    else:\n        err_msg = 'use Interval or Relational, not Range'\n    for V in symbols:\n        if isinstance(V, (Relational, BooleanFunction)):\n            if discrete:\n                raise TypeError(err_msg)\n            variable = V.atoms(Symbol).pop()\n            V = (variable, V.as_set())\n        elif isinstance(V, Symbol) or getattr(V, '_diff_wrt', False):\n            if isinstance(V, Idx):\n                if V.lower is None or V.upper is None:\n                    limits.append(Tuple(V))\n                else:\n                    limits.append(Tuple(V, V.lower, V.upper))\n            else:\n                limits.append(Tuple(V))\n            continue\n        if is_sequence(V) and (not isinstance(V, Set)):\n            if len(V) == 2 and isinstance(V[1], Set):\n                V = list(V)\n                if isinstance(V[1], Interval):\n                    if discrete:\n                        raise TypeError(err_msg)\n                    V[1:] = (V[1].inf, V[1].sup)\n                elif isinstance(V[1], Range):\n                    if not discrete:\n                        raise TypeError(err_msg)\n                    lo = V[1].inf\n                    hi = V[1].sup\n                    dx = abs(V[1].step)\n                    if dx == 1:\n                        V[1:] = [lo, hi]\n                    elif lo is not S.NegativeInfinity:\n                        V = [V[0]] + [0, (hi - lo) // dx, dx * V[0] + lo]\n                    else:\n                        V = [V[0]] + [0, S.Infinity, -dx * V[0] + hi]\n                else:\n                    raise NotImplementedError('expecting Range' if discrete else 'Relational or single Interval')\n            V = sympify(flatten(V))\n            if isinstance(V[0], (Symbol, Idx)) or getattr(V[0], '_diff_wrt', False):\n                newsymbol = V[0]\n                if len(V) == 3:\n                    if V[2] is None and V[1] is not None:\n                        orientation *= -1\n                    V = [newsymbol] + [i for i in V[1:] if i is not None]\n                lenV = len(V)\n                if not isinstance(newsymbol, Idx) or lenV == 3:\n                    if lenV == 4:\n                        limits.append(Tuple(*V))\n                        continue\n                    if lenV == 3:\n                        if isinstance(newsymbol, Idx):\n                            lo, hi = (newsymbol.lower, newsymbol.upper)\n                            try:\n                                if lo is not None and (not bool(V[1] >= lo)):\n                                    raise ValueError('Summation will set Idx value too low.')\n                            except TypeError:\n                                pass\n                            try:\n                                if hi is not None and (not bool(V[2] <= hi)):\n                                    raise ValueError('Summation will set Idx value too high.')\n                            except TypeError:\n                                pass\n                        limits.append(Tuple(*V))\n                        continue\n                    if lenV == 1 or (lenV == 2 and V[1] is None):\n                        limits.append(Tuple(newsymbol))\n                        continue\n                    elif lenV == 2:\n                        limits.append(Tuple(newsymbol, V[1]))\n                        continue\n        raise ValueError('Invalid limits given: %s' % str(symbols))\n    return (limits, orientation)",
    ".sympy.utilities.iterables.py@@is_sequence": "def is_sequence(i, include=None):\n    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))",
    ".sympy.utilities.iterables.py@@iterable": "def iterable(i, exclude=(str, dict, NotIterable)):\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    ".sympy.utilities.iterables.py@@flatten": "def flatten(iterable, levels=None, cls=None):\n    from sympy.tensor.array import NDimArray\n    if levels is not None:\n        if not levels:\n            return iterable\n        elif levels > 0:\n            levels -= 1\n        else:\n            raise ValueError('expected non-negative number of levels, got %s' % levels)\n    if cls is None:\n        reducible = lambda x: is_sequence(x, set)\n    else:\n        reducible = lambda x: isinstance(x, cls)\n    result = []\n    for el in iterable:\n        if reducible(el):\n            if hasattr(el, 'args') and (not isinstance(el, NDimArray)):\n                el = el.args\n            result.extend(flatten(el, levels=levels, cls=cls))\n        else:\n            result.append(el)\n    return result",
    ".sympy.core.sympify.py@@_is_numpy_instance": "def _is_numpy_instance(a):\n    return any((type_.__module__ == 'numpy' for type_ in type(a).__mro__))",
    ".sympy.core.containers.py@@Tuple.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    ".sympy.core.containers.py@@Tuple.__len__": "def __len__(self):\n    return len(self.args)",
    ".sympy.core.containers.py@@Tuple.__getitem__": "def __getitem__(self, i):\n    if isinstance(i, slice):\n        indices = i.indices(len(self))\n        return Tuple(*(self.args[j] for j in range(*indices)))\n    return self.args[i]",
    ".sympy.core.basic.py@@Basic.atoms": "def atoms(self, *types):\n    if types:\n        types = tuple([t if isinstance(t, type) else type(t) for t in types])\n    nodes = _preorder_traversal(self)\n    if types:\n        result = {node for node in nodes if isinstance(node, types)}\n    else:\n        result = {node for node in nodes if not node.args}\n    return result",
    ".sympy.core.traversal.py@@preorder_traversal.__init__": "def __init__(self, node, keys=None):\n    self._skip_flag = False\n    self._pt = self._preorder_traversal(node, keys)",
    ".sympy.core.traversal.py@@preorder_traversal.__iter__": "def __iter__(self):\n    return self",
    ".sympy.core.traversal.py@@preorder_traversal.__next__": "def __next__(self):\n    return next(self._pt)",
    ".sympy.core.traversal.py@@preorder_traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    ".sympy.core.basic.py@@Basic.xreplace": "def xreplace(self, rule):\n    value, _ = self._xreplace(rule)\n    return value",
    ".sympy.core.basic.py@@Basic._xreplace": "def _xreplace(self, rule):\n    if self in rule:\n        return (rule[self], True)\n    elif rule:\n        args = []\n        changed = False\n        for a in self.args:\n            _xreplace = getattr(a, '_xreplace', None)\n            if _xreplace is not None:\n                a_xr = _xreplace(rule)\n                args.append(a_xr[0])\n                changed |= a_xr[1]\n            else:\n                args.append(a)\n        args = tuple(args)\n        if changed:\n            return (self.func(*args), True)\n    return (self, False)",
    ".sympy.core.expr.py@@Expr._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.numbers.py@@Rational.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.numbers.py@@Rational._hashable_content": "def _hashable_content(self):\n    return (self.p, self.q)",
    ".sympy.functions.elementary.piecewise.py@@piecewise_fold": "def piecewise_fold(expr, evaluate=True):\n    if not isinstance(expr, Basic) or not expr.has(Piecewise):\n        return expr\n    new_args = []\n    if isinstance(expr, (ExprCondPair, Piecewise)):\n        for e, c in expr.args:\n            if not isinstance(e, Piecewise):\n                e = piecewise_fold(e)\n            assert not c.has(Piecewise)\n            if isinstance(c, ITE):\n                c = c.to_nnf()\n                c = simplify_logic(c, form='cnf')\n            if isinstance(e, Piecewise):\n                new_args.extend([(piecewise_fold(ei), And(ci, c)) for ei, ci in e.args])\n            else:\n                new_args.append((e, c))\n    else:\n        if expr.is_Add or (expr.is_Mul and expr.is_commutative):\n            p, args = sift(expr.args, lambda x: x.is_Piecewise, binary=True)\n            pc = sift(p, lambda x: tuple([c for e, c in x.args]))\n            for c in list(ordered(pc)):\n                if len(pc[c]) > 1:\n                    pargs = [list(i.args) for i in pc[c]]\n                    com = common_prefix(*[[i.cond for i in j] for j in pargs])\n                    n = len(com)\n                    collected = []\n                    for i in range(n):\n                        collected.append((expr.func(*[ai[i].expr for ai in pargs]), com[i]))\n                    remains = []\n                    for a in pargs:\n                        if n == len(a):\n                            continue\n                        if a[n].cond == True:\n                            remains.append(a[n].expr)\n                        else:\n                            remains.append(Piecewise(*a[n:], evaluate=False))\n                    if remains:\n                        collected.append((expr.func(*remains), True))\n                    args.append(Piecewise(*collected, evaluate=False))\n                    continue\n                args.extend(pc[c])\n        else:\n            args = expr.args\n        folded = list(map(piecewise_fold, args))\n        for ec in product(*[i.args if isinstance(i, Piecewise) else [(i, true)] for i in folded]):\n            e, c = zip(*ec)\n            new_args.append((expr.func(*e), And(*c)))\n    if evaluate is None:\n        new_args = list(reversed([(e, c) for c, e in {c: e for e, c in reversed(new_args)}.items()]))\n    rv = Piecewise(*new_args, evaluate=evaluate)\n    if evaluate is None and len(rv.args) == 1 and (rv.args[0].cond == True):\n        return rv.args[0].expr\n    if any((s.expr.has(Piecewise) for p in rv.atoms(Piecewise) for s in p.args)):\n        return piecewise_fold(rv)\n    return rv",
    ".sympy.core.containers.py@@Tuple.__contains__": "def __contains__(self, item):\n    return item in self.args",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    if not isinstance(other, Basic):\n        return self._do_eq_sympify(other)\n    if not (self.is_Number and other.is_Number) and type(self) != type(other):\n        return False\n    a, b = (self._hashable_content(), other._hashable_content())\n    if a != b:\n        return False\n    for a, b in zip(a, b):\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    ".sympy.core.basic.py@@Basic._do_eq_sympify": "def _do_eq_sympify(self, other):\n    for superclass in type(other).__mro__:\n        conv = _external_converter.get(superclass)\n        if conv is not None:\n            return self == conv(other)\n    if hasattr(other, '_sympy_'):\n        return self == other._sympy_()\n    return NotImplemented",
    ".sympy.core.sympify.py@@SympifyError.__init__": "def __init__(self, expr, base_exc=None):\n    self.expr = expr\n    self.base_exc = base_exc",
    ".sympy.core.function.py@@Function._eval_is_commutative": "def _eval_is_commutative(self):\n    return fuzzy_and((a.is_commutative for a in self.args))",
    ".sympy.core.expr.py@@Expr.__mul__": "def __mul__(self, other):\n    return Mul(self, other)",
    ".sympy.core.power.py@@Pow._eval_is_zero": "def _eval_is_zero(self):\n    if self.base.is_zero:\n        if self.exp.is_extended_positive:\n            return True\n        elif self.exp.is_extended_nonpositive:\n            return False\n    elif self.base == S.Exp1:\n        return self.exp is S.NegativeInfinity\n    elif self.base.is_zero is False:\n        if self.base.is_finite and self.exp.is_finite:\n            return False\n        elif self.exp.is_negative:\n            return self.base.is_infinite\n        elif self.exp.is_nonnegative:\n            return False\n        elif self.exp.is_infinite and self.exp.is_extended_real:\n            if (1 - abs(self.base)).is_extended_positive:\n                return self.exp.is_extended_positive\n            elif (1 - abs(self.base)).is_extended_negative:\n                return self.exp.is_extended_negative\n    elif self.base.is_finite and self.exp.is_negative:\n        return False",
    ".sympy.core.power.py@@Pow.base": "def base(self) -> Expr:\n    return self._args[0]",
    ".sympy.core.power.py@@Pow.exp": "def exp(self) -> Expr:\n    return self._args[1]",
    ".sympy.core.power.py@@Pow.as_base_exp": "def as_base_exp(self):\n    b, e = self.args\n    if b.is_Rational and b.p < b.q and (b.p > 0):\n        return (1 / b, -e)\n    return (b, e)",
    ".sympy.core.numbers.py@@NumberSymbol.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.containers.py@@Tuple.__hash__": "def __hash__(self):\n    return hash(self.args)",
    ".sympy.core.numbers.py@@Rational.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))\n        elif isinstance(other, Float):\n            return other * self\n        else:\n            return Number.__mul__(self, other)\n    return Number.__mul__(self, other)",
    ".sympy.core.numbers.py@@NumberSymbol.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.basic.py@@Basic.compare": "def compare(self, other):\n    if self is other:\n        return 0\n    n1 = self.__class__\n    n2 = other.__class__\n    c = _old_compare(n1, n2)\n    if c:\n        return c\n    st = self._hashable_content()\n    ot = other._hashable_content()\n    c = (len(st) > len(ot)) - (len(st) < len(ot))\n    if c:\n        return c\n    for l, r in zip(st, ot):\n        l = Basic(*l) if isinstance(l, frozenset) else l\n        r = Basic(*r) if isinstance(r, frozenset) else r\n        if isinstance(l, Basic):\n            c = l.compare(r)\n        else:\n            c = (l > r) - (l < r)\n        if c:\n            return c\n    return 0",
    ".sympy.core.basic.py@@_old_compare": "def _old_compare(x: type, y: type) -> int:\n    if not issubclass(y, Basic):\n        return -1\n    n1 = x.__name__\n    n2 = y.__name__\n    if n1 == n2:\n        return 0\n    UNKNOWN = len(ordering_of_classes) + 1\n    try:\n        i1 = ordering_of_classes.index(n1)\n    except ValueError:\n        i1 = UNKNOWN\n    try:\n        i2 = ordering_of_classes.index(n2)\n    except ValueError:\n        i2 = UNKNOWN\n    if i1 == UNKNOWN and i2 == UNKNOWN:\n        return (n1 > n2) - (n1 < n2)\n    return (i1 > i2) - (i1 < i2)",
    ".sympy.core.operations.py@@AssocOp.doit": "def doit(self, **hints):\n    if hints.get('deep', True):\n        terms = [term.doit(**hints) for term in self.args]\n    else:\n        terms = self.args\n    return self.func(*terms, evaluate=True)",
    ".sympy.core.basic.py@@Basic.doit": "def doit(self, **hints):\n    if hints.get('deep', True):\n        terms = [term.doit(**hints) if isinstance(term, Basic) else term for term in self.args]\n        return self.func(*terms)\n    else:\n        return self",
    ".sympy.core.basic.py@@Atom.doit": "def doit(self, **hints):\n    return self",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.concrete.products.py@@Product.doit": "def doit(self, **hints):\n    reps = {}\n    for xab in self.limits:\n        d = _dummy_with_inherited_properties_concrete(xab)\n        if d:\n            reps[xab[0]] = d\n    if reps:\n        undo = {v: k for k, v in reps.items()}\n        did = self.xreplace(reps).doit(**hints)\n        if isinstance(did, tuple):\n            did = tuple([i.xreplace(undo) for i in did])\n        else:\n            did = did.xreplace(undo)\n        return did\n    from sympy.simplify.powsimp import powsimp\n    f = self.function\n    for index, limit in enumerate(self.limits):\n        i, a, b = limit\n        dif = b - a\n        if dif.is_integer and dif.is_negative:\n            a, b = (b + 1, a - 1)\n            f = 1 / f\n        g = self._eval_product(f, (i, a, b))\n        if g in (None, S.NaN):\n            return self.func(powsimp(f), *self.limits[index:])\n        else:\n            f = g\n    if hints.get('deep', True):\n        return f.doit(**hints)\n    else:\n        return powsimp(f)",
    ".sympy.concrete.expr_with_limits.py@@ExprWithLimits.limits": "def limits(self):\n    return self._args[1:]",
    ".sympy.concrete.summations.py@@_dummy_with_inherited_properties_concrete": "def _dummy_with_inherited_properties_concrete(limits):\n    x, a, b = limits\n    l = [a, b]\n    assumptions_to_consider = ['extended_nonnegative', 'nonnegative', 'extended_nonpositive', 'nonpositive', 'extended_positive', 'positive', 'extended_negative', 'negative', 'integer', 'rational', 'finite', 'zero', 'real', 'extended_real']\n    assumptions_to_keep = {}\n    assumptions_to_add = {}\n    for assum in assumptions_to_consider:\n        assum_true = x._assumptions.get(assum, None)\n        if assum_true:\n            assumptions_to_keep[assum] = True\n        elif all((getattr(i, 'is_' + assum) for i in l)):\n            assumptions_to_add[assum] = True\n    if assumptions_to_add:\n        assumptions_to_keep.update(assumptions_to_add)\n        return Dummy('d', **assumptions_to_keep)",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.function.py@@Application.func": "def func(self):\n    return self.__class__",
    ".sympy.concrete.products.py@@Product.term": "def term(self):\n    return self._args[0]",
    ".sympy.concrete.products.py@@Product._eval_product": "def _eval_product(self, term, limits):\n    k, a, n = limits\n    if k not in term.free_symbols:\n        if (term - 1).is_zero:\n            return S.One\n        return term ** (n - a + 1)\n    if a == n:\n        return term.subs(k, a)\n    from .delta import deltaproduct, _has_simple_delta\n    if term.has(KroneckerDelta) and _has_simple_delta(term, limits[0]):\n        return deltaproduct(term, limits)\n    dif = n - a\n    definite = dif.is_Integer\n    if definite and dif < 100:\n        return self._eval_product_direct(term, limits)\n    elif term.is_polynomial(k):\n        poly = term.as_poly(k)\n        A = B = Q = S.One\n        all_roots = roots(poly)\n        M = 0\n        for r, m in all_roots.items():\n            M += m\n            A *= RisingFactorial(a - r, n - a + 1) ** m\n            Q *= (n - r) ** m\n        if M < poly.degree():\n            arg = quo(poly, Q.as_poly(k))\n            B = self.func(arg, (k, a, n)).doit()\n        return poly.LC() ** (n - a + 1) * A * B\n    elif term.is_Add:\n        factored = factor_terms(term, fraction=True)\n        if factored.is_Mul:\n            return self._eval_product(factored, (k, a, n))\n    elif term.is_Mul:\n        without_k, with_k = term.as_coeff_mul(k)\n        if len(with_k) >= 2:\n            exclude, include = ([], [])\n            for t in with_k:\n                p = self._eval_product(t, (k, a, n))\n                if p is not None:\n                    exclude.append(p)\n                else:\n                    include.append(t)\n            if not exclude:\n                return None\n            else:\n                arg = term._new_rawargs(*include)\n                A = Mul(*exclude)\n                B = self.func(arg, (k, a, n)).doit()\n                return without_k ** (n - a + 1) * A * B\n        else:\n            p = self._eval_product(with_k[0], (k, a, n))\n            if p is None:\n                p = self.func(with_k[0], (k, a, n)).doit()\n            return without_k ** (n - a + 1) * p\n    elif term.is_Pow:\n        if not term.base.has(k):\n            s = summation(term.exp, (k, a, n))\n            return term.base ** s\n        elif not term.exp.has(k):\n            p = self._eval_product(term.base, (k, a, n))\n            if p is not None:\n                return p ** term.exp\n    elif isinstance(term, Product):\n        evaluated = term.doit()\n        f = self._eval_product(evaluated, limits)\n        if f is None:\n            return self.func(evaluated, limits)\n        else:\n            return f\n    if definite:\n        return self._eval_product_direct(term, limits)",
    ".sympy.core.basic.py@@Basic.free_symbols": "def free_symbols(self) -> set[Basic]:\n    empty: set[Basic] = set()\n    return empty.union(*(a.free_symbols for a in self.args))",
    ".sympy.core.symbol.py@@Symbol.free_symbols": "def free_symbols(self):\n    return {self}",
    ".sympy.core.numbers.py@@Integer.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    ".sympy.logic.boolalg.py@@BooleanTrue.__bool__": "def __bool__(self):\n    return True",
    ".sympy.concrete.products.py@@Product._eval_product_direct": "def _eval_product_direct(self, term, limits):\n    k, a, n = limits\n    return Mul(*[term.subs(k, a + i) for i in range(n - a + 1)])",
    ".sympy.core.numbers.py@@Integer.__index__": "def __index__(self):\n    return self.p",
    ".sympy.core.basic.py@@Basic.subs": "def subs(self, *args, **kwargs):\n    from .containers import Dict\n    from .symbol import Dummy, Symbol\n    from .numbers import _illegal\n    unordered = False\n    if len(args) == 1:\n        sequence = args[0]\n        if isinstance(sequence, set):\n            unordered = True\n        elif isinstance(sequence, (Dict, Mapping)):\n            unordered = True\n            sequence = sequence.items()\n        elif not iterable(sequence):\n            raise ValueError(filldedent('\\n               When a single argument is passed to subs\\n               it should be a dictionary of old: new pairs or an iterable\\n               of (old, new) tuples.'))\n    elif len(args) == 2:\n        sequence = [args]\n    else:\n        raise ValueError('subs accepts either 1 or 2 arguments')\n\n    def sympify_old(old):\n        if isinstance(old, str):\n            return Symbol(old)\n        elif isinstance(old, type):\n            return sympify(old, strict=False)\n        else:\n            return sympify(old, strict=True)\n\n    def sympify_new(new):\n        if isinstance(new, (str, type)):\n            return sympify(new, strict=False)\n        else:\n            return sympify(new, strict=True)\n    sequence = [(sympify_old(s1), sympify_new(s2)) for s1, s2 in sequence]\n    sequence = [(s1, s2) for s1, s2 in sequence if not _aresame(s1, s2)]\n    simultaneous = kwargs.pop('simultaneous', False)\n    if unordered:\n        from .sorting import _nodes, default_sort_key\n        sequence = dict(sequence)\n        k = list(ordered(sequence, default=False, keys=(lambda x: -_nodes(x), default_sort_key)))\n        sequence = [(k, sequence[k]) for k in k]\n        if not simultaneous:\n            redo = [i for i, seq in enumerate(sequence) if seq[1] in _illegal]\n            for i in reversed(redo):\n                sequence.insert(0, sequence.pop(i))\n    if simultaneous:\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy('subs_m')\n        for old, new in sequence:\n            com = new.is_commutative\n            if com is None:\n                com = True\n            d = Dummy('subs_d', commutative=com)\n            rv = rv._subs(old, d * m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    ".sympy.core.basic.py@@Basic.sympify_old": "def sympify_old(old):\n    if isinstance(old, str):\n        return Symbol(old)\n    elif isinstance(old, type):\n        return sympify(old, strict=False)\n    else:\n        return sympify(old, strict=True)",
    ".sympy.core.basic.py@@Basic.sympify_new": "def sympify_new(new):\n    if isinstance(new, (str, type)):\n        return sympify(new, strict=False)\n    else:\n        return sympify(new, strict=True)",
    ".sympy.core.basic.py@@_aresame": "def _aresame(a, b):\n    from .numbers import Number\n    from .function import AppliedUndef, UndefinedFunction as UndefFunc\n    if isinstance(a, Number) and isinstance(b, Number):\n        return a == b and a.__class__ == b.__class__\n    for i, j in zip_longest(_preorder_traversal(a), _preorder_traversal(b)):\n        if i != j or type(i) != type(j):\n            if isinstance(i, UndefFunc) and isinstance(j, UndefFunc) or (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef)):\n                if i.class_key() != j.class_key():\n                    return False\n            else:\n                return False\n    return True",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.basic.py@@Basic._subs": "def _subs(self, old, new, **hints):\n\n    def fallback(self, old, new):\n        hit = False\n        args = list(self.args)\n        for i, arg in enumerate(args):\n            if not hasattr(arg, '_eval_subs'):\n                continue\n            arg = arg._subs(old, new, **hints)\n            if not _aresame(arg, args[i]):\n                hit = True\n                args[i] = arg\n        if hit:\n            rv = self.func(*args)\n            hack2 = hints.get('hack2', False)\n            if hack2 and self.is_Mul and (not rv.is_Mul):\n                coeff = S.One\n                nonnumber = []\n                for i in args:\n                    if i.is_Number:\n                        coeff *= i\n                    else:\n                        nonnumber.append(i)\n                nonnumber = self.func(*nonnumber)\n                if coeff is S.One:\n                    return nonnumber\n                else:\n                    return self.func(coeff, nonnumber, evaluate=False)\n            return rv\n        return self\n    if _aresame(self, old):\n        return new\n    rv = self._eval_subs(old, new)\n    if rv is None:\n        rv = fallback(self, old, new)\n    return rv",
    ".sympy.core.function.py@@Application._eval_subs": "def _eval_subs(self, old, new):\n    if old.is_Function and new.is_Function and callable(old) and callable(new) and (old == self.func) and (len(self.args) in new.nargs):\n        return new(*[i._subs(old, new) for i in self.args])",
    ".sympy.core.basic.py@@Basic.fallback": "def fallback(self, old, new):\n    hit = False\n    args = list(self.args)\n    for i, arg in enumerate(args):\n        if not hasattr(arg, '_eval_subs'):\n            continue\n        arg = arg._subs(old, new, **hints)\n        if not _aresame(arg, args[i]):\n            hit = True\n            args[i] = arg\n    if hit:\n        rv = self.func(*args)\n        hack2 = hints.get('hack2', False)\n        if hack2 and self.is_Mul and (not rv.is_Mul):\n            coeff = S.One\n            nonnumber = []\n            for i in args:\n                if i.is_Number:\n                    coeff *= i\n                else:\n                    nonnumber.append(i)\n            nonnumber = self.func(*nonnumber)\n            if coeff is S.One:\n                return nonnumber\n            else:\n                return self.func(coeff, nonnumber, evaluate=False)\n        return rv\n    return self",
    ".sympy.core.add.py@@Add._eval_subs": "def _eval_subs(self, old, new):\n    if not old.is_Add:\n        if old is S.Infinity and -old in self.args:\n            return self.xreplace({-old: -new})\n        return None\n    coeff_self, terms_self = self.as_coeff_Add()\n    coeff_old, terms_old = old.as_coeff_Add()\n    if coeff_self.is_Rational and coeff_old.is_Rational:\n        if terms_self == terms_old:\n            return self.func(new, coeff_self, -coeff_old)\n        if terms_self == -terms_old:\n            return self.func(-new, coeff_self, coeff_old)\n    if coeff_self.is_Rational and coeff_old.is_Rational or coeff_self == coeff_old:\n        args_old, args_self = (self.func.make_args(terms_old), self.func.make_args(terms_self))\n        if len(args_old) < len(args_self):\n            self_set = set(args_self)\n            old_set = set(args_old)\n            if old_set < self_set:\n                ret_set = self_set - old_set\n                return self.func(new, coeff_self, -coeff_old, *[s._subs(old, new) for s in ret_set])\n            args_old = self.func.make_args(-terms_old)\n            old_set = set(args_old)\n            if old_set < self_set:\n                ret_set = self_set - old_set\n                return self.func(-new, coeff_self, coeff_old, *[s._subs(old, new) for s in ret_set])",
    ".sympy.core.numbers.py@@Rational.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.numbers.py@@Number._eval_subs": "def _eval_subs(self, old, new):\n    if old == -self:\n        return -new\n    return self",
    ".sympy.core.numbers.py@@Rational.__neg__": "def __neg__(self):\n    return Rational(-self.p, self.q)",
    ".sympy.core.mul.py@@Mul._eval_subs": "def _eval_subs(self, old, new):\n    from sympy.functions.elementary.complexes import sign\n    from sympy.ntheory.factor_ import multiplicity\n    from sympy.simplify.powsimp import powdenest\n    from sympy.simplify.radsimp import fraction\n    if not old.is_Mul:\n        return None\n    if old.args[0].is_Number and old.args[0] < 0:\n        if self.args[0].is_Number:\n            if self.args[0] < 0:\n                return self._subs(-old, -new)\n            return None\n\n    def base_exp(a):\n        from sympy.functions.elementary.exponential import exp\n        if a.is_Pow or isinstance(a, exp):\n            return a.as_base_exp()\n        return (a, S.One)\n\n    def breakup(eq):\n        c, nc = (defaultdict(int), list())\n        for a in Mul.make_args(eq):\n            a = powdenest(a)\n            b, e = base_exp(a)\n            if e is not S.One:\n                co, _ = e.as_coeff_mul()\n                b = Pow(b, e / co)\n                e = co\n            if a.is_commutative:\n                c[b] += e\n            else:\n                nc.append([b, e])\n        return (c, nc)\n\n    def rejoin(b, co):\n        b, e = base_exp(b)\n        return Pow(b, e * co)\n\n    def ndiv(a, b):\n        if not b.q % a.q or not a.q % b.q:\n            return int(a / b)\n        return 0\n    rv = None\n    n, d = fraction(self)\n    self2 = self\n    if d is not S.One:\n        self2 = n._subs(old, new) / d._subs(old, new)\n        if not self2.is_Mul:\n            return self2._subs(old, new)\n        if self2 != self:\n            rv = self2\n    co_self = self2.args[0]\n    co_old = old.args[0]\n    co_xmul = None\n    if co_old.is_Rational and co_self.is_Rational:\n        if co_old != co_self:\n            co_xmul = co_self.extract_multiplicatively(co_old)\n    elif co_old.is_Rational:\n        return rv\n    c, nc = breakup(self2)\n    old_c, old_nc = breakup(old)\n    if co_xmul and co_xmul.is_Rational and (abs(co_old) != 1):\n        mult = S(multiplicity(abs(co_old), co_self))\n        c.pop(co_self)\n        if co_old in c:\n            c[co_old] += mult\n        else:\n            c[co_old] = mult\n        co_residual = co_self / co_old ** mult\n    else:\n        co_residual = 1\n    ok = True\n    if len(old_nc) > len(nc):\n        ok = False\n    elif len(old_c) > len(c):\n        ok = False\n    elif {i[0] for i in old_nc}.difference({i[0] for i in nc}):\n        ok = False\n    elif set(old_c).difference(set(c)):\n        ok = False\n    elif any((sign(c[b]) != sign(old_c[b]) for b in old_c)):\n        ok = False\n    if not ok:\n        return rv\n    if not old_c:\n        cdid = None\n    else:\n        rat = []\n        for b, old_e in old_c.items():\n            c_e = c[b]\n            rat.append(ndiv(c_e, old_e))\n            if not rat[-1]:\n                return rv\n        cdid = min(rat)\n    if not old_nc:\n        ncdid = None\n        for i in range(len(nc)):\n            nc[i] = rejoin(*nc[i])\n    else:\n        ncdid = 0\n        take = len(old_nc)\n        limit = cdid or S.Infinity\n        failed = []\n        i = 0\n        while limit and i + take <= len(nc):\n            hit = False\n            rat = []\n            for j in range(take):\n                if nc[i + j][0] != old_nc[j][0]:\n                    break\n                elif j == 0:\n                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n                elif j == take - 1:\n                    rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n                elif nc[i + j][1] != old_nc[j][1]:\n                    break\n                else:\n                    rat.append(1)\n                j += 1\n            else:\n                ndo = min(rat)\n                if ndo:\n                    if take == 1:\n                        if cdid:\n                            ndo = min(cdid, ndo)\n                        nc[i] = Pow(new, ndo) * rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])\n                    else:\n                        ndo = 1\n                        l = rejoin(nc[i][0], nc[i][1] - ndo * old_nc[0][1])\n                        mid = new\n                        ir = i + take - 1\n                        r = (nc[ir][0], nc[ir][1] - ndo * old_nc[-1][1])\n                        if r[1]:\n                            if i + take < len(nc):\n                                nc[i:i + take] = [l * mid, r]\n                            else:\n                                r = rejoin(*r)\n                                nc[i:i + take] = [l * mid * r]\n                        else:\n                            nc[i:i + take] = [l * mid]\n                    limit -= ndo\n                    ncdid += ndo\n                    hit = True\n            if not hit:\n                failed.append(i)\n            i += 1\n        else:\n            if not ncdid:\n                return rv\n            failed.extend(range(i, len(nc)))\n            for i in failed:\n                nc[i] = rejoin(*nc[i]).subs(old, new)\n    if cdid is None:\n        do = ncdid\n    elif ncdid is None:\n        do = cdid\n    else:\n        do = min(ncdid, cdid)\n    margs = []\n    for b in c:\n        if b in old_c:\n            e = c[b] - old_c[b] * do\n            margs.append(rejoin(b, e))\n        else:\n            margs.append(rejoin(b.subs(old, new), c[b]))\n    if cdid and (not ncdid):\n        margs = [Pow(new, cdid)] + margs\n    return co_residual * self2.func(*margs) * self2.func(*nc)",
    ".sympy.core.numbers.py@@Integer.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.functions.special.gamma_functions.py@@intlike": "def intlike(n):\n    try:\n        as_int(n, strict=False)\n        return True\n    except ValueError:\n        return False",
    ".sympy.core.numbers.py@@Integer.__int__": "def __int__(self):\n    return self.p",
    ".sympy.functions.combinatorial.factorials.py@@factorial.eval": "def eval(cls, n):\n    n = sympify(n)\n    if n.is_Number:\n        if n.is_zero:\n            return S.One\n        elif n is S.Infinity:\n            return S.Infinity\n        elif n.is_Integer:\n            if n.is_negative:\n                return S.ComplexInfinity\n            else:\n                n = n.p\n                if n < 20:\n                    if not cls._small_factorials:\n                        result = 1\n                        for i in range(1, 20):\n                            result *= i\n                            cls._small_factorials.append(result)\n                    result = cls._small_factorials[n - 1]\n                elif HAS_GMPY:\n                    result = gmpy.fac(n)\n                else:\n                    bits = bin(n).count('1')\n                    result = cls._recursive(n) * 2 ** (n - bits)\n                return Integer(result)",
    ".sympy.core.numbers.py@@Rational._eval_is_zero": "def _eval_is_zero(self):\n    return self.p == 0",
    ".sympy.core.numbers.py@@Integer.__radd__": "def __radd__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other + self.p)\n        elif isinstance(other, Rational):\n            return Rational(other.p + self.p * other.q, other.q, 1)\n        return Rational.__radd__(self, other)\n    return Rational.__radd__(self, other)",
    ".sympy.core.numbers.py@@Rational.__int__": "def __int__(self):\n    p, q = (self.p, self.q)\n    if p < 0:\n        return -int(-p // q)\n    return int(p // q)",
    ".sympy.core._print_helpers.py@@Printable.__str__": "def __str__(self):\n    from sympy.printing.str import sstr\n    return sstr(self, order=None)",
    ".sympy.printing.printer.py@@_PrintFunction.__call__": "def __call__(self, *args, **kwargs):\n    return self.__wrapped__(*args, **kwargs)",
    ".sympy.printing.str.py@@sstr": "def sstr(expr, **settings):\n    p = StrPrinter(settings)\n    s = p.doprint(expr)\n    return s",
    ".sympy.printing.printer.py@@Printer.__init__": "def __init__(self, settings=None):\n    self._str = str\n    self._settings = self._get_initial_settings()\n    self._context = {}\n    if settings is not None:\n        self._settings.update(settings)\n        if len(self._settings) > len(self._default_settings):\n            for key in self._settings:\n                if key not in self._default_settings:\n                    raise TypeError(\"Unknown setting '%s'.\" % key)\n    self._print_level = 0",
    ".sympy.printing.printer.py@@Printer._get_initial_settings": "def _get_initial_settings(cls):\n    settings = cls._default_settings.copy()\n    for key, val in cls._global_settings.items():\n        if key in cls._default_settings:\n            settings[key] = val\n    return settings",
    ".sympy.printing.printer.py@@Printer.doprint": "def doprint(self, expr):\n    return self._str(self._print(expr))",
    ".sympy.printing.printer.py@@Printer._print": "def _print(self, expr, **kwargs) -> str:\n    self._print_level += 1\n    try:\n        if self.printmethod and hasattr(expr, self.printmethod):\n            if not (isinstance(expr, type) and issubclass(expr, Basic)):\n                return getattr(expr, self.printmethod)(self, **kwargs)\n        classes = type(expr).__mro__\n        if AppliedUndef in classes:\n            classes = classes[classes.index(AppliedUndef):]\n        if UndefinedFunction in classes:\n            classes = classes[classes.index(UndefinedFunction):]\n        if Function in classes:\n            i = classes.index(Function)\n            classes = tuple((c for c in classes[:i] if c.__name__ == classes[0].__name__ or c.__name__.endswith('Base'))) + classes[i:]\n        for cls in classes:\n            printmethodname = '_print_' + cls.__name__\n            printmethod = getattr(self, printmethodname, None)\n            if printmethod is not None:\n                return printmethod(expr, **kwargs)\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1",
    ".sympy.printing.str.py@@StrPrinter._print_Rational": "def _print_Rational(self, expr):\n    if expr.q == 1:\n        return str(expr.p)\n    else:\n        if self._settings.get('sympy_integers', False):\n            return 'S(%s)/%s' % (expr.p, expr.q)\n        return '%s/%s' % (expr.p, expr.q)",
    ".sympy.functions.elementary.miscellaneous.py@@sqrt": "def sqrt(arg, evaluate=None):\n    return Pow(arg, S.Half, evaluate=evaluate)",
    ".sympy.core.numbers.py@@Number.__mul__": "def __mul__(self, other):\n    if isinstance(other, Number) and global_parameters.evaluate:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.Infinity\n            else:\n                return S.NegativeInfinity\n        elif other is S.NegativeInfinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.NegativeInfinity\n            else:\n                return S.Infinity\n    elif isinstance(other, Tuple):\n        return NotImplemented\n    return AtomicExpr.__mul__(self, other)",
    ".sympy.core.numbers.py@@NaN.__eq__": "def __eq__(self, other):\n    return other is S.NaN",
    ".sympy.matrices.expressions.determinant.py@@Determinant.__new__": "def __new__(cls, mat):\n    mat = sympify(mat)\n    if not mat.is_Matrix:\n        raise TypeError('Input to Determinant, %s, not a matrix' % str(mat))\n    if mat.is_square is False:\n        raise NonSquareMatrixError('Det of a non-square matrix')\n    return Basic.__new__(cls, mat)",
    ".sympy.matrices.common.py@@MatrixProperties.is_square": "def is_square(self):\n    return self.rows == self.cols",
    ".sympy.matrices.immutable.py@@ImmutableRepMatrix.rows": "def rows(self):\n    return self._rows",
    ".sympy.matrices.immutable.py@@ImmutableRepMatrix.cols": "def cols(self):\n    return self._cols",
    ".sympy.core.numbers.py@@Float.__eq__": "def __eq__(self, other):\n    from sympy.logic.boolalg import Boolean\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if isinstance(other, Boolean):\n        return False\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Float:\n        return self._mpf_ == other._mpf_\n    if other.is_Rational:\n        return other.__eq__(self)\n    if other.is_Number:\n        ompf = other._as_mpf_val(self._prec)\n        return bool(mlib.mpf_eq(self._mpf_, ompf))\n    if not self:\n        return not other\n    return False",
    ".sympy.core.numbers.py@@NaN._as_mpf_val": "def _as_mpf_val(self, prec):\n    return _mpf_nan",
    ".sympy.core.mul.py@@Mul._eval_is_zero": "def _eval_is_zero(self):\n    seen_zero, seen_infinite = self._eval_is_zero_infinite_helper()\n    if seen_zero is False:\n        return False\n    elif seen_zero is True and seen_infinite is False:\n        return True\n    else:\n        return None",
    ".sympy.core.mul.py@@Mul._eval_is_zero_infinite_helper": "def _eval_is_zero_infinite_helper(self):\n    seen_zero = seen_infinite = False\n    for a in self.args:\n        if a.is_zero:\n            if seen_infinite is not False:\n                return (None, None)\n            seen_zero = True\n        elif a.is_infinite:\n            if seen_zero is not False:\n                return (None, None)\n            seen_infinite = True\n        else:\n            if seen_zero is False and a.is_zero is None:\n                if seen_infinite is not False:\n                    return (None, None)\n                seen_zero = None\n            if seen_infinite is False and a.is_infinite is None:\n                if seen_zero is not False:\n                    return (None, None)\n                seen_infinite = None\n    return (seen_zero, seen_infinite)",
    ".sympy.core.numbers.py@@Number.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    if rational and (not self.is_Rational):\n        return (S.One, self)\n    return (self, S.One) if self else (S.One, self)",
    ".sympy.core.numbers.py@@Float.__bool__": "def __bool__(self):\n    return self._mpf_ != fzero",
    ".sympy.core.numbers.py@@Float.__mul__": "def __mul__(self, other):\n    if isinstance(other, Number) and global_parameters.evaluate:\n        rhs, prec = other._as_mpf_op(self._prec)\n        return Float._new(mlib.mpf_mul(self._mpf_, rhs, prec, rnd), prec)\n    return Number.__mul__(self, other)",
    ".sympy.core.numbers.py@@Number._as_mpf_op": "def _as_mpf_op(self, prec):\n    prec = max(prec, self._prec)\n    return (self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Float._eval_is_zero": "def _eval_is_zero(self):\n    return self._mpf_ == fzero",
    ".sympy.core.expr.py@@Expr._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    return self._eval_is_extended_positive_negative(positive=True)",
    ".sympy.core.expr.py@@Expr.is_number": "def is_number(self):\n    return all((obj.is_number for obj in self.args))",
    ".sympy.core.power.py@@Pow._eval_is_integer": "def _eval_is_integer(self):\n    b, e = self.args\n    if b.is_rational:\n        if b.is_integer is False and e.is_positive:\n            return False\n    if b.is_integer and e.is_integer:\n        if b is S.NegativeOne:\n            return True\n        if e.is_nonnegative or e.is_positive:\n            return True\n    if b.is_integer and e.is_negative and (e.is_finite or e.is_integer):\n        if fuzzy_not((b - 1).is_zero) and fuzzy_not((b + 1).is_zero):\n            return False\n    if b.is_Number and e.is_Number:\n        check = self.func(*self.args)\n        return check.is_Integer\n    if e.is_negative and b.is_positive and (b - 1).is_positive:\n        return False\n    if e.is_negative and b.is_negative and (b + 1).is_negative:\n        return False",
    ".sympy.core.numbers.py@@Float._eval_is_negative": "def _eval_is_negative(self):\n    if self._mpf_ in (_mpf_ninf, _mpf_inf):\n        return False\n    return self.num < 0",
    ".sympy.core.numbers.py@@Float.num": "def num(self):\n    return mpmath.mpf(self._mpf_)",
    ".sympy.core.power.py@@Pow._eval_is_odd": "def _eval_is_odd(self):\n    if self.exp.is_integer:\n        if self.exp.is_positive:\n            return self.base.is_odd\n        elif self.exp.is_nonnegative and self.base.is_odd:\n            return True\n        elif self.base is S.NegativeOne:\n            return True",
    ".sympy.core.numbers.py@@Float._eval_is_integer": "def _eval_is_integer(self):\n    return self._mpf_ == fzero",
    ".sympy.core.power.py@@Pow._eval_is_prime": "def _eval_is_prime(self):\n    if self.base.is_integer and self.exp.is_integer and (self.exp - 1).is_positive:\n        return False",
    ".sympy.core.power.py@@Pow._eval_is_imaginary": "def _eval_is_imaginary(self):\n    if self.base.is_commutative is False:\n        return False\n    if self.base.is_imaginary:\n        if self.exp.is_integer:\n            odd = self.exp.is_odd\n            if odd is not None:\n                return odd\n            return\n    if self.base == S.Exp1:\n        f = 2 * self.exp / (S.Pi * S.ImaginaryUnit)\n        if f.is_even:\n            return False\n        if f.is_odd:\n            return True\n        return None\n    if self.exp.is_imaginary:\n        from sympy.functions.elementary.exponential import log\n        imlog = log(self.base).is_imaginary\n        if imlog is not None:\n            return False\n    if self.base.is_extended_real and self.exp.is_extended_real:\n        if self.base.is_positive:\n            return False\n        else:\n            rat = self.exp.is_rational\n            if not rat:\n                return rat\n            if self.exp.is_integer:\n                return False\n            else:\n                half = (2 * self.exp).is_integer\n                if half:\n                    return self.base.is_negative\n                return half\n    if self.base.is_extended_real is False:\n        from sympy.functions.elementary.complexes import arg\n        i = arg(self.base) * self.exp / S.Pi\n        isodd = (2 * i).is_odd\n        if isodd is not None:\n            return isodd",
    ".sympy.core.power.py@@Pow._eval_is_rational": "def _eval_is_rational(self):\n    if self.exp.is_integer and self.base.is_rational and fuzzy_not(fuzzy_and([self.exp.is_negative, self.base.is_zero])):\n        return True\n    p = self.func(*self.as_base_exp())\n    if not p.is_Pow:\n        return p.is_rational\n    b, e = p.as_base_exp()\n    if e.is_Rational and b.is_Rational:\n        return False\n    if e.is_integer:\n        if b.is_rational:\n            if fuzzy_not(b.is_zero) or e.is_nonnegative:\n                return True\n            if b == e:\n                return True\n        elif b.is_irrational:\n            return e.is_zero\n    if b is S.Exp1:\n        if e.is_rational and e.is_nonzero:\n            return False",
    ".sympy.core.power.py@@Pow._eval_is_even": "def _eval_is_even(self):\n    if self.exp.is_integer and self.exp.is_positive:\n        return self.base.is_even",
    ".sympy.core.power.py@@Pow._eval_is_finite": "def _eval_is_finite(self):\n    if self.exp.is_negative:\n        if self.base.is_zero:\n            return False\n        if self.base.is_infinite or self.base.is_nonzero:\n            return True\n    c1 = self.base.is_finite\n    if c1 is None:\n        return\n    c2 = self.exp.is_finite\n    if c2 is None:\n        return\n    if c1 and c2:\n        if self.exp.is_nonnegative or fuzzy_not(self.base.is_zero):\n            return True",
    ".sympy.core.power.py@@Pow._eval_is_extended_real": "def _eval_is_extended_real(self):\n    if self.base is S.Exp1:\n        if self.exp.is_extended_real:\n            return True\n        elif self.exp.is_imaginary:\n            return (2 * S.ImaginaryUnit * self.exp / S.Pi).is_even\n    from sympy.functions.elementary.exponential import log, exp\n    real_b = self.base.is_extended_real\n    if real_b is None:\n        if self.base.func == exp and self.base.exp.is_imaginary:\n            return self.exp.is_imaginary\n        if self.base.func == Pow and self.base.base is S.Exp1 and self.base.exp.is_imaginary:\n            return self.exp.is_imaginary\n        return\n    real_e = self.exp.is_extended_real\n    if real_e is None:\n        return\n    if real_b and real_e:\n        if self.base.is_extended_positive:\n            return True\n        elif self.base.is_extended_nonnegative and self.exp.is_extended_nonnegative:\n            return True\n        elif self.exp.is_integer and self.base.is_extended_nonzero:\n            return True\n        elif self.exp.is_integer and self.exp.is_nonnegative:\n            return True\n        elif self.base.is_extended_negative:\n            if self.exp.is_Rational:\n                return False\n    if real_e and self.exp.is_extended_negative and (self.base.is_zero is False):\n        return Pow(self.base, -self.exp).is_extended_real\n    im_b = self.base.is_imaginary\n    im_e = self.exp.is_imaginary\n    if im_b:\n        if self.exp.is_integer:\n            if self.exp.is_even:\n                return True\n            elif self.exp.is_odd:\n                return False\n        elif im_e and log(self.base).is_imaginary:\n            return True\n        elif self.exp.is_Add:\n            c, a = self.exp.as_coeff_Add()\n            if c and c.is_Integer:\n                return Mul(self.base ** c, self.base ** a, evaluate=False).is_extended_real\n        elif self.base in (-S.ImaginaryUnit, S.ImaginaryUnit):\n            if (self.exp / 2).is_integer is False:\n                return False\n    if real_b and im_e:\n        if self.base is S.NegativeOne:\n            return True\n        c = self.exp.coeff(S.ImaginaryUnit)\n        if c:\n            if self.base.is_rational and c.is_rational:\n                if self.base.is_nonzero and (self.base - 1).is_nonzero and c.is_nonzero:\n                    return False\n            ok = (c * log(self.base) / S.Pi).is_integer\n            if ok is not None:\n                return ok\n    if real_b is False and real_e:\n        from sympy.functions.elementary.complexes import arg\n        i = arg(self.base) * self.exp / S.Pi\n        if i.is_complex:\n            return i.is_integer",
    ".sympy.core.power.py@@Pow._eval_is_composite": "def _eval_is_composite(self):\n    if self.base.is_integer and self.exp.is_integer and ((self.base - 1).is_positive and (self.exp - 1).is_positive or ((self.base + 1).is_negative and self.exp.is_positive and self.exp.is_even)):\n        return True",
    ".sympy.core.power.py@@Pow._eval_is_algebraic": "def _eval_is_algebraic(self):\n\n    def _is_one(expr):\n        try:\n            return (expr - 1).is_zero\n        except ValueError:\n            return False\n    if self.base.is_zero or _is_one(self.base):\n        return True\n    elif self.base is S.Exp1:\n        s = self.func(*self.args)\n        if s.func == self.func:\n            if self.exp.is_nonzero:\n                if self.exp.is_algebraic:\n                    return False\n                elif (self.exp / S.Pi).is_rational:\n                    return False\n                elif (self.exp / (S.ImaginaryUnit * S.Pi)).is_rational:\n                    return True\n        else:\n            return s.is_algebraic\n    elif self.exp.is_rational:\n        if self.base.is_algebraic is False:\n            return self.exp.is_zero\n        if self.base.is_zero is False:\n            if self.exp.is_nonzero:\n                return self.base.is_algebraic\n            elif self.base.is_algebraic:\n                return True\n        if self.exp.is_positive:\n            return self.base.is_algebraic\n    elif self.base.is_algebraic and self.exp.is_algebraic:\n        if fuzzy_not(self.base.is_zero) and fuzzy_not(_is_one(self.base)) or self.base.is_integer is False or self.base.is_irrational:\n            return self.exp.is_rational",
    ".sympy.core.power.py@@Pow._is_one": "def _is_one(expr):\n    try:\n        return (expr - 1).is_zero\n    except ValueError:\n        return False",
    ".sympy.core.expr.py@@Expr.__sub__": "def __sub__(self, other):\n    return Add(self, -other)",
    ".sympy.core.numbers.py@@One.__neg__": "def __neg__():\n    return S.NegativeOne",
    ".sympy.core.add.py@@Add._eval_is_zero": "def _eval_is_zero(self):\n    if self.is_commutative is False:\n        return\n    nz = []\n    z = 0\n    im_or_z = False\n    im = 0\n    for a in self.args:\n        if a.is_extended_real:\n            if a.is_zero:\n                z += 1\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im += 1\n        elif (S.ImaginaryUnit * a).is_extended_real:\n            im_or_z = True\n        else:\n            return\n    if z == len(self.args):\n        return True\n    if len(nz) in [0, len(self.args)]:\n        return None\n    b = self.func(*nz)\n    if b.is_zero:\n        if not im_or_z:\n            if im == 0:\n                return True\n            elif im == 1:\n                return False\n    if b.is_zero is False:\n        return False",
    ".sympy.core.numbers.py@@Rational.as_numer_denom": "def as_numer_denom(self):\n    return (Integer(self.p), Integer(self.q))",
    ".sympy.core.numbers.py@@Integer.__divmod__": "def __divmod__(self, other):\n    if isinstance(other, Integer) and global_parameters.evaluate:\n        return Tuple(*divmod(self.p, other.p))\n    else:\n        return Number.__divmod__(self, other)",
    ".sympy.core.numbers.py@@Integer.__mod__": "def __mod__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p % other)\n        elif isinstance(other, Integer):\n            return Integer(self.p % other.p)\n        return Rational.__mod__(self, other)\n    return Rational.__mod__(self, other)",
    ".sympy.core.mul.py@@Mul._eval_is_extended_real": "def _eval_is_extended_real(self):\n    return self._eval_real_imag(True)",
    ".sympy.core.mul.py@@Mul._eval_real_imag": "def _eval_real_imag(self, real):\n    zero = False\n    t_not_re_im = None\n    for t in self.args:\n        if (t.is_complex or t.is_infinite) is False and t.is_extended_real is False:\n            return False\n        elif t.is_imaginary:\n            real = not real\n        elif t.is_extended_real:\n            if not zero:\n                z = t.is_zero\n                if not z and zero is False:\n                    zero = z\n                elif z:\n                    if all((a.is_finite for a in self.args)):\n                        return True\n                    return\n        elif t.is_extended_real is False:\n            if t_not_re_im:\n                return\n            t_not_re_im = t\n        elif t.is_imaginary is False:\n            if t_not_re_im:\n                return\n            t_not_re_im = t\n        else:\n            return\n    if t_not_re_im:\n        if t_not_re_im.is_extended_real is False:\n            if real:\n                return zero\n        if t_not_re_im.is_imaginary is False:\n            if not real:\n                return zero\n    elif zero is False:\n        return real\n    elif real:\n        return real",
    ".sympy.core.mul.py@@Mul._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all(((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others)):\n                return True\n            return\n        if a is None:\n            return\n    if all((x.is_real for x in self.args)):\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_imaginary": "def _eval_is_imaginary(self):\n    if all((a.is_zero is False and a.is_finite for a in self.args)):\n        return self._eval_real_imag(False)",
    ".sympy.core.mul.py@@Mul._eval_is_odd": "def _eval_is_odd(self):\n    is_integer = self._eval_is_integer()\n    if is_integer is not True:\n        return is_integer\n    from sympy.simplify.radsimp import fraction\n    n, d = fraction(self)\n    if d.is_Integer and d.is_even:\n        from sympy.ntheory.factor_ import trailing\n        if (Add(*[i.as_base_exp()[1] for i in Mul.make_args(n) if i.is_even]) - trailing(d.p)).is_positive:\n            return False\n        return\n    r, acc = (True, 1)\n    for t in self.args:\n        if abs(t) is S.One:\n            continue\n        if t.is_even:\n            return False\n        if r is False:\n            pass\n        elif acc != 1 and (acc + t).is_odd:\n            r = False\n        elif t.is_even is None:\n            r = None\n        acc = t\n    return r",
    ".sympy.core.mul.py@@Mul._eval_is_integer": "def _eval_is_integer(self):\n    from sympy.ntheory.factor_ import trailing\n    is_rational = self._eval_is_rational()\n    if is_rational is False:\n        return False\n    numerators = []\n    denominators = []\n    unknown = False\n    for a in self.args:\n        hit = False\n        if a.is_integer:\n            if abs(a) is not S.One:\n                numerators.append(a)\n        elif a.is_Rational:\n            n, d = a.as_numer_denom()\n            if abs(n) is not S.One:\n                numerators.append(n)\n            if d is not S.One:\n                denominators.append(d)\n        elif a.is_Pow:\n            b, e = a.as_base_exp()\n            if not b.is_integer or not e.is_integer:\n                hit = unknown = True\n            if e.is_negative:\n                denominators.append(2 if a is S.Half else Pow(a, S.NegativeOne))\n            elif not hit:\n                assert not e.is_positive\n                assert not e.is_zero\n                return\n            else:\n                return\n        else:\n            return\n    if not denominators and (not unknown):\n        return True\n    allodd = lambda x: all((i.is_odd for i in x))\n    alleven = lambda x: all((i.is_even for i in x))\n    anyeven = lambda x: any((i.is_even for i in x))\n    from .relational import is_gt\n    if not numerators and denominators and all((is_gt(_, S.One) for _ in denominators)):\n        return False\n    elif unknown:\n        return\n    elif allodd(numerators) and anyeven(denominators):\n        return False\n    elif anyeven(numerators) and denominators == [2]:\n        return True\n    elif alleven(numerators) and allodd(denominators) and (Mul(*denominators, evaluate=False) - 1).is_positive:\n        return False\n    if len(denominators) == 1:\n        d = denominators[0]\n        if d.is_Integer and d.is_even:\n            if (Add(*[i.as_base_exp()[1] for i in numerators if i.is_even]) - trailing(d.p)).is_nonnegative:\n                return True\n    if len(numerators) == 1:\n        n = numerators[0]\n        if n.is_Integer and n.is_even:\n            if (Add(*[i.as_base_exp()[1] for i in denominators if i.is_even]) - trailing(n.p)).is_positive:\n                return False",
    ".sympy.core.mul.py@@Mul._eval_is_rational": "def _eval_is_rational(self):\n    r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        if all((a.is_zero is False for a in self.args)):\n            return False",
    ".sympy.core.logic.py@@_fuzzy_group": "def _fuzzy_group(args, quick_exit=False):\n    saw_other = False\n    for a in args:\n        if a is True:\n            continue\n        if a is None:\n            return\n        if quick_exit and saw_other:\n            return\n        saw_other = True\n    return not saw_other",
    ".sympy.core.mul.py@@Mul._eval_is_even": "def _eval_is_even(self):\n    from sympy.simplify.radsimp import fraction\n    n, d = fraction(self)\n    if n.is_Integer and n.is_even:\n        from sympy.ntheory.factor_ import trailing\n        if (Add(*[i.as_base_exp()[1] for i in Mul.make_args(d) if i.is_even]) - trailing(n.p)).is_nonnegative:\n            return False",
    ".sympy.simplify.radsimp.py@@fraction": "def fraction(expr, exact=False):\n    expr = sympify(expr)\n    numer, denom = ([], [])\n    for term in Mul.make_args(expr):\n        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):\n            b, ex = term.as_base_exp()\n            if ex.is_negative:\n                if ex is S.NegativeOne:\n                    denom.append(b)\n                elif exact:\n                    if ex.is_constant():\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n            elif ex.is_positive:\n                numer.append(term)\n            elif not exact and ex.is_Mul:\n                n, d = term.as_numer_denom()\n                if n != 1:\n                    numer.append(n)\n                denom.append(d)\n            else:\n                numer.append(term)\n        elif term.is_Rational and (not term.is_Integer):\n            if term.p != 1:\n                numer.append(term.p)\n            denom.append(term.q)\n        else:\n            numer.append(term)\n    return (Mul(*numer, evaluate=not exact), Mul(*denom, evaluate=not exact))",
    ".sympy.core.operations.py@@AssocOp.make_args": "def make_args(cls, expr):\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    ".sympy.functions.elementary.exponential.py@@ExpMeta.__instancecheck__": "def __instancecheck__(cls, instance):\n    if exp in instance.__class__.__mro__:\n        return True\n    return isinstance(instance, Pow) and instance.base is S.Exp1",
    ".sympy.core.mul.py@@Mul._eval_is_composite": "def _eval_is_composite(self):\n    number_of_args = 0\n    for arg in self.args:\n        if not (arg.is_integer and arg.is_positive):\n            return None\n        if (arg - 1).is_positive:\n            number_of_args += 1\n    if number_of_args > 1:\n        return True",
    ".sympy.core.mul.py@@Mul._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    return self._eval_pos_neg(1)",
    ".sympy.core.mul.py@@Mul._eval_pos_neg": "def _eval_pos_neg(self, sign):\n    saw_NON = saw_NOT = False\n    for t in self.args:\n        if t.is_extended_positive:\n            continue\n        elif t.is_extended_negative:\n            sign = -sign\n        elif t.is_zero:\n            if all((a.is_finite for a in self.args)):\n                return False\n            return\n        elif t.is_extended_nonpositive:\n            sign = -sign\n            saw_NON = True\n        elif t.is_extended_nonnegative:\n            saw_NON = True\n        elif t.is_positive is False:\n            sign = -sign\n            if saw_NOT:\n                return\n            saw_NOT = True\n        elif t.is_negative is False:\n            if saw_NOT:\n                return\n            saw_NOT = True\n        else:\n            return\n    if sign == 1 and saw_NON is False and (saw_NOT is False):\n        return True\n    if sign < 0:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    return self._eval_pos_neg(-1)",
    ".sympy.core.mul.py@@Mul._eval_is_hermitian": "def _eval_is_hermitian(self):\n    return self._eval_herm_antiherm(True)",
    ".sympy.core.mul.py@@Mul._eval_herm_antiherm": "def _eval_herm_antiherm(self, herm):\n    for t in self.args:\n        if t.is_hermitian is None or t.is_antihermitian is None:\n            return\n        if t.is_hermitian:\n            continue\n        elif t.is_antihermitian:\n            herm = not herm\n        else:\n            return\n    if herm is not False:\n        return herm\n    is_zero = self._eval_is_zero()\n    if is_zero:\n        return True\n    elif is_zero is False:\n        return herm",
    ".sympy.core.mul.py@@Mul._eval_is_infinite": "def _eval_is_infinite(self):\n    seen_zero, seen_infinite = self._eval_is_zero_infinite_helper()\n    if seen_infinite is True and seen_zero is False:\n        return True\n    elif seen_infinite is False:\n        return False\n    else:\n        return None",
    ".sympy.core.mul.py@@Mul._eval_is_complex": "def _eval_is_complex(self):\n    comp = _fuzzy_group((a.is_complex for a in self.args))\n    if comp is False:\n        if any((a.is_infinite for a in self.args)):\n            if any((a.is_zero is not False for a in self.args)):\n                return None\n            return False\n    return comp",
    ".sympy.core.mul.py@@Mul._eval_is_algebraic": "def _eval_is_algebraic(self):\n    r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        if all((a.is_zero is False for a in self.args)):\n            return False",
    ".sympy.core.mul.py@@Mul._eval_is_antihermitian": "def _eval_is_antihermitian(self):\n    return self._eval_herm_antiherm(False)",
    ".sympy.core.add.py@@Add._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    if self.is_number:\n        return super()._eval_is_extended_negative()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        from .exprtools import _monotonic_sign\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s != self and s.is_extended_negative and a.is_extended_nonpositive:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v != self and v.is_extended_negative:\n                    return True\n    neg = nonpos = nonneg = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        isneg = a.is_extended_negative\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((isneg, a.is_extended_nonpositive)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if isneg:\n            neg = True\n            continue\n        elif a.is_extended_nonpositive:\n            nonpos = True\n            continue\n        elif a.is_extended_nonnegative:\n            nonneg = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonneg and (not nonpos) and neg:\n        return True\n    elif not nonneg and neg:\n        return True\n    elif not neg and (not nonpos):\n        return False",
    ".sympy.core.exprtools.py@@_monotonic_sign": "def _monotonic_sign(self):\n    if not self.is_extended_real:\n        return\n    if (-self).is_Symbol:\n        rv = _monotonic_sign(-self)\n        return rv if rv is None else -rv\n    if not self.is_Add and self.as_numer_denom()[1].is_number:\n        s = self\n        if s.is_prime:\n            if s.is_odd:\n                return Integer(3)\n            else:\n                return Integer(2)\n        elif s.is_composite:\n            if s.is_odd:\n                return Integer(9)\n            else:\n                return Integer(4)\n        elif s.is_positive:\n            if s.is_even:\n                if s.is_prime is False:\n                    return Integer(4)\n                else:\n                    return Integer(2)\n            elif s.is_integer:\n                return S.One\n            else:\n                return _eps\n        elif s.is_extended_negative:\n            if s.is_even:\n                return Integer(-2)\n            elif s.is_integer:\n                return S.NegativeOne\n            else:\n                return -_eps\n        if s.is_zero or s.is_extended_nonpositive or s.is_extended_nonnegative:\n            return S.Zero\n        return None\n    free = self.free_symbols\n    if len(free) == 1:\n        if self.is_polynomial():\n            from sympy.polys.polytools import real_roots\n            from sympy.polys.polyroots import roots\n            from sympy.polys.polyerrors import PolynomialError\n            x = free.pop()\n            x0 = _monotonic_sign(x)\n            if x0 in (_eps, -_eps):\n                x0 = S.Zero\n            if x0 is not None:\n                d = self.diff(x)\n                if d.is_number:\n                    currentroots = []\n                else:\n                    try:\n                        currentroots = real_roots(d)\n                    except (PolynomialError, NotImplementedError):\n                        currentroots = [r for r in roots(d, x) if r.is_extended_real]\n                y = self.subs(x, x0)\n                if x.is_nonnegative and all(((r - x0).is_nonpositive for r in currentroots)):\n                    if y.is_nonnegative and d.is_positive:\n                        if y:\n                            return y if y.is_positive else Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_negative:\n                        if y:\n                            return y if y.is_negative else Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n                elif x.is_nonpositive and all(((r - x0).is_nonnegative for r in currentroots)):\n                    if y.is_nonnegative and d.is_negative:\n                        if y:\n                            return Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_positive:\n                        if y:\n                            return Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n        else:\n            n, d = self.as_numer_denom()\n            den = None\n            if n.is_number:\n                den = _monotonic_sign(d)\n            elif not d.is_number:\n                if _monotonic_sign(n) is not None:\n                    den = _monotonic_sign(d)\n            if den is not None and (den.is_positive or den.is_negative):\n                v = n * den\n                if v.is_positive:\n                    return Dummy('pos', positive=True)\n                elif v.is_nonnegative:\n                    return Dummy('nneg', nonnegative=True)\n                elif v.is_negative:\n                    return Dummy('neg', negative=True)\n                elif v.is_nonpositive:\n                    return Dummy('npos', nonpositive=True)\n        return None\n    c, a = self.as_coeff_Add()\n    v = None\n    if not a.is_polynomial():\n        n, d = a.as_numer_denom()\n        if not (n.is_number or d.is_number):\n            return\n        if (a.is_Mul or a.is_Pow) and a.is_rational and all((p.exp.is_Integer for p in a.atoms(Pow) if p.is_Pow)) and (a.is_positive or a.is_negative):\n            v = S.One\n            for ai in Mul.make_args(a):\n                if ai.is_number:\n                    v *= ai\n                    continue\n                reps = {}\n                for x in ai.free_symbols:\n                    reps[x] = _monotonic_sign(x)\n                    if reps[x] is None:\n                        return\n                v *= ai.subs(reps)\n    elif c:\n        if not any((p for p in a.atoms(Pow) if not p.is_number)) and (a.is_nonpositive or a.is_nonnegative):\n            free = list(a.free_symbols)\n            p = {}\n            for i in free:\n                v = _monotonic_sign(i)\n                if v is None:\n                    return\n                p[i] = v or (_eps if i.is_nonnegative else -_eps)\n            v = a.xreplace(p)\n    if v is not None:\n        rv = v + c\n        if v.is_nonnegative and rv.is_positive:\n            return rv.subs(_eps, 0)\n        if v.is_nonpositive and rv.is_negative:\n            return rv.subs(_eps, 0)",
    ".sympy.core.add.py@@Add._eval_is_extended_nonpositive": "def _eval_is_extended_nonpositive(self):\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_extended_nonpositive:\n            from .exprtools import _monotonic_sign\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s != self and s.is_extended_nonpositive:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v != self and v.is_extended_nonpositive:\n                        return True",
    ".sympy.core.add.py@@Add._eval_is_imaginary": "def _eval_is_imaginary(self):\n    nz = []\n    im_I = []\n    for a in self.args:\n        if a.is_extended_real:\n            if a.is_zero:\n                pass\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im_I.append(a * S.ImaginaryUnit)\n        elif (S.ImaginaryUnit * a).is_extended_real:\n            im_I.append(a * S.ImaginaryUnit)\n        else:\n            return\n    b = self.func(*nz)\n    if b != self:\n        if b.is_zero:\n            return fuzzy_not(self.func(*im_I).is_zero)\n        elif b.is_zero is False:\n            return False",
    ".sympy.core.add.py@@Add._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all((x.is_rational is True for x in others)):\n                return True\n            return None\n        if a is None:\n            return\n    return False",
    ".sympy.core.add.py@@Add._eval_is_odd": "def _eval_is_odd(self):\n    l = [f for f in self.args if not f.is_even is True]\n    if not l:\n        return False\n    if l[0].is_odd:\n        return self._new_rawargs(*l[1:]).is_even",
    ".sympy.core.add.py@@Add._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    if self.is_number:\n        return super()._eval_is_extended_positive()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        from .exprtools import _monotonic_sign\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s != self and s.is_extended_positive and a.is_extended_nonnegative:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v != self and v.is_extended_positive:\n                    return True\n    pos = nonneg = nonpos = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        ispos = a.is_extended_positive\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((ispos, a.is_extended_nonnegative)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if ispos:\n            pos = True\n            continue\n        elif a.is_extended_nonnegative:\n            nonneg = True\n            continue\n        elif a.is_extended_nonpositive:\n            nonpos = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonpos and (not nonneg) and pos:\n        return True\n    elif not nonpos and pos:\n        return True\n    elif not pos and (not nonneg):\n        return False",
    ".sympy.core.add.py@@Add._eval_is_infinite": "def _eval_is_infinite(self):\n    sawinf = False\n    for a in self.args:\n        ainf = a.is_infinite\n        if ainf is None:\n            return None\n        elif ainf is True:\n            if sawinf is True:\n                return None\n            sawinf = True\n    return sawinf",
    ".sympy.core.add.py@@Add._eval_is_extended_nonnegative": "def _eval_is_extended_nonnegative(self):\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_extended_nonnegative:\n            from .exprtools import _monotonic_sign\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s != self and s.is_extended_nonnegative:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v != self and v.is_extended_nonnegative:\n                        return True",
    ".sympy.core.power.py@@Pow._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    if self.exp is S.Half:\n        if self.base.is_complex or self.base.is_extended_real:\n            return False\n    if self.base.is_extended_negative:\n        if self.exp.is_odd and self.base.is_finite:\n            return True\n        if self.exp.is_even:\n            return False\n    elif self.base.is_extended_positive:\n        if self.exp.is_extended_real:\n            return False\n    elif self.base.is_zero:\n        if self.exp.is_extended_real:\n            return False\n    elif self.base.is_extended_nonnegative:\n        if self.exp.is_extended_nonnegative:\n            return False\n    elif self.base.is_extended_nonpositive:\n        if self.exp.is_even:\n            return False\n    elif self.base.is_extended_real:\n        if self.exp.is_even:\n            return False",
    ".sympy.core.power.py@@Pow._eval_is_complex": "def _eval_is_complex(self):\n    if self.base == S.Exp1:\n        return fuzzy_or([self.exp.is_complex, self.exp.is_extended_negative])\n    if all((a.is_complex for a in self.args)) and self._eval_is_finite():\n        return True",
    ".sympy.core.power.py@@Pow._eval_is_extended_positive": "def _eval_is_extended_positive(self):\n    if self.base == self.exp:\n        if self.base.is_extended_nonnegative:\n            return True\n    elif self.base.is_positive:\n        if self.exp.is_real:\n            return True\n    elif self.base.is_extended_negative:\n        if self.exp.is_even:\n            return True\n        if self.exp.is_odd:\n            return False\n    elif self.base.is_zero:\n        if self.exp.is_extended_real:\n            return self.exp.is_zero\n    elif self.base.is_extended_nonpositive:\n        if self.exp.is_odd:\n            return False\n    elif self.base.is_imaginary:\n        if self.exp.is_integer:\n            m = self.exp % 4\n            if m.is_zero:\n                return True\n            if m.is_integer and m.is_zero is False:\n                return False\n        if self.exp.is_imaginary:\n            from sympy.functions.elementary.exponential import log\n            return log(self.base).is_imaginary",
    ".sympy.core.power.py@@Pow._eval_is_negative": "def _eval_is_negative(self):\n    ext_neg = Pow._eval_is_extended_negative(self)\n    if ext_neg is True:\n        return self.is_finite\n    return ext_neg",
    ".sympy.core.logic.py@@fuzzy_not": "def fuzzy_not(v):\n    if v is None:\n        return v\n    else:\n        return not v",
    ".sympy.core.numbers.py@@Float.__neg__": "def __neg__(self):\n    if not self:\n        return self\n    return Float._new(mlib.mpf_neg(self._mpf_), self._prec)",
    ".sympy.core.numbers.py@@One.__abs__": "def __abs__():\n    return S.One",
    ".sympy.core.numbers.py@@Integer.__neg__": "def __neg__(self):\n    return Integer(-self.p)",
    ".sympy.core.numbers.py@@Float.__add__": "def __add__(self, other):\n    if isinstance(other, Number) and global_parameters.evaluate:\n        rhs, prec = other._as_mpf_op(self._prec)\n        return Float._new(mlib.mpf_add(self._mpf_, rhs, prec, rnd), prec)\n    return Number.__add__(self, other)",
    ".sympy.core.power.py@@integer_log": "def integer_log(y, x):\n    if x == 1:\n        raise ValueError('x cannot take value as 1')\n    if y == 0:\n        raise ValueError('y cannot take value as 0')\n    if x in (-2, 2):\n        x = int(x)\n        y = as_int(y)\n        e = y.bit_length() - 1\n        return (e, x ** e == y)\n    if x < 0:\n        n, b = integer_log(y if y > 0 else -y, -x)\n        return (n, b and bool(n % 2 if y < 0 else not n % 2))\n    x = as_int(x)\n    y = as_int(y)\n    r = e = 0\n    while y >= x:\n        d = x\n        m = 1\n        while y >= d:\n            y, rem = divmod(y, d)\n            r = r or rem\n            e += m\n            if y > d:\n                d *= d\n                m *= 2\n    return (e, r == 0 and y == 1)",
    ".sympy.core.mul.py@@Mul.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    if self == -self:\n        return False\n    c = self.args[0]\n    return c.is_Number and c.is_extended_negative",
    ".sympy.core.mul.py@@Mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    if args[0] is not S.ComplexInfinity:\n        c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    ".sympy.core.mul.py@@Mul.as_coeff_mul": "def as_coeff_mul(self, *deps, rational=True, **kwargs):\n    if deps:\n        l1, l2 = sift(self.args, lambda x: x.has(*deps), binary=True)\n        return (self._new_rawargs(*l2), tuple(l1))\n    args = self.args\n    if args[0].is_Number:\n        if not rational or args[0].is_Rational:\n            return (args[0], args[1:])\n        elif args[0].is_extended_negative:\n            return (S.NegativeOne, (-args[0],) + args[1:])\n    return (S.One, args)",
    ".sympy.core.mul.py@@Mul._eval_power": "def _eval_power(self, e):\n    cargs, nc = self.args_cnc(split_1=False)\n    if e.is_Integer:\n        return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * Pow(Mul._from_args(nc), e, evaluate=False)\n    if e.is_Rational and e.q == 2:\n        if self.is_imaginary:\n            a = self.as_real_imag()[1]\n            if a.is_Rational:\n                from .power import integer_nthroot\n                n, d = abs(a / 2).as_numer_denom()\n                n, t = integer_nthroot(n, 2)\n                if t:\n                    d, t = integer_nthroot(d, 2)\n                    if t:\n                        from sympy.functions.elementary.complexes import sign\n                        r = sympify(n) / d\n                        return _unevaluated_Mul(r ** e.p, (1 + sign(a) * S.ImaginaryUnit) ** e.p)\n    p = Pow(self, e, evaluate=False)\n    if e.is_Rational or e.is_Float:\n        return p._eval_expand_power_base()\n    return p",
    ".sympy.core.expr.py@@Expr.args_cnc": "def args_cnc(self, cset=False, warn=True, split_1=True):\n    if self.is_Mul:\n        args = list(self.args)\n    else:\n        args = [self]\n    for i, mi in enumerate(args):\n        if not mi.is_commutative:\n            c = args[:i]\n            nc = args[i:]\n            break\n    else:\n        c = args\n        nc = []\n    if c and split_1 and (c[0].is_Number and c[0].is_extended_negative and (c[0] is not S.NegativeOne)):\n        c[:1] = [S.NegativeOne, -c[0]]\n    if cset:\n        clen = len(c)\n        c = set(c)\n        if clen and warn and (len(c) != clen):\n            raise ValueError('repeated commutative arguments: %s' % [ci for ci in c if list(self.args).count(ci) > 1])\n    return [c, nc]",
    ".sympy.core.numbers.py@@Rational.__rtruediv__": "def __rtruediv__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(other.p * self.q, self.p, igcd(self.p, other.p))\n        elif isinstance(other, Rational):\n            return Rational(other.p * self.q, other.q * self.p, igcd(self.p, other.p) * igcd(self.q, other.q))\n        elif isinstance(other, Float):\n            return other * (1 / self)\n        else:\n            return Number.__rtruediv__(self, other)\n    return Number.__rtruediv__(self, other)",
    ".sympy.core.numbers.py@@Float.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.numbers.py@@Float._hashable_content": "def _hashable_content(self):\n    return (self._mpf_, self._prec)",
    ".sympy.core.power.py@@Pow._eval_power": "def _eval_power(self, other):\n    b, e = self.as_base_exp()\n    if b is S.NaN:\n        return (b ** e) ** other\n    s = None\n    if other.is_integer:\n        s = 1\n    elif b.is_polar:\n        s = 1\n    elif e.is_extended_real is not None:\n        from sympy.functions.elementary.complexes import arg, im, re, sign\n        from sympy.functions.elementary.exponential import exp, log\n        from sympy.functions.elementary.integers import floor\n\n        def _half(e):\n            if getattr(e, 'q', None) == 2:\n                return True\n            n, d = e.as_numer_denom()\n            if n.is_integer and d == 2:\n                return True\n\n        def _n2(e):\n            try:\n                rv = e.evalf(2, strict=True)\n                if rv.is_Number:\n                    return rv\n            except PrecisionExhausted:\n                pass\n        if e.is_extended_real:\n            if e == -1:\n                if _half(other):\n                    if b.is_negative is True:\n                        return S.NegativeOne ** other * Pow(-b, e * other)\n                    elif b.is_negative is False:\n                        return Pow(b, -other)\n            elif e.is_even:\n                if b.is_extended_real:\n                    b = abs(b)\n                if b.is_imaginary:\n                    b = abs(im(b)) * S.ImaginaryUnit\n            if (abs(e) < 1) == True or e == 1:\n                s = 1\n            elif b.is_extended_nonnegative:\n                s = 1\n            elif re(b).is_extended_nonnegative and (abs(e) < 2) == True:\n                s = 1\n            elif _half(other):\n                s = exp(2 * S.Pi * S.ImaginaryUnit * other * floor(S.Half - e * arg(b) / (2 * S.Pi)))\n                if s.is_extended_real and _n2(sign(s) - s) == 0:\n                    s = sign(s)\n                else:\n                    s = None\n        else:\n            try:\n                s = exp(2 * S.ImaginaryUnit * S.Pi * other * floor(S.Half - im(e * log(b)) / 2 / S.Pi))\n                if s.is_extended_real and _n2(sign(s) - s) == 0:\n                    s = sign(s)\n                else:\n                    s = None\n            except PrecisionExhausted:\n                s = None\n    if s is not None:\n        return s * Pow(b, e * other)",
    ".sympy.core.expr.py@@Expr.__rmul__": "def __rmul__(self, other):\n    return Mul(other, self)",
    ".sympy.core.numbers.py@@NegativeOne.__abs__": "def __abs__():\n    return S.One",
    ".sympy.matrices.expressions.matexpr.py@@MatrixSymbol.shape": "def shape(self):\n    return (self.args[1], self.args[2])",
    ".sympy.core.symbol.py@@Symbol._eval_subs": "def _eval_subs(self, old, new):\n    if old.is_Pow:\n        from sympy.core.power import Pow\n        return Pow(self, S.One, evaluate=False)._eval_subs(old, new)",
    ".sympy.functions.special.gamma_functions.py@@gamma._eval_is_real": "def _eval_is_real(self):\n    x = self.args[0]\n    if x.is_nonpositive and x.is_integer:\n        return False\n    if intlike(x) and x <= 0:\n        return False\n    if x.is_positive or x.is_noninteger:\n        return True",
    ".sympy.core.mul.py@@Mul.as_numer_denom": "def as_numer_denom(self):\n    numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n    return (self.func(*numers), self.func(*denoms))",
    ".sympy.core.expr.py@@Expr.as_numer_denom": "def as_numer_denom(self):\n    return (self, S.One)",
    ".sympy.core.add.py@@Add.__neg__": "def __neg__(self):\n    if not global_parameters.distribute:\n        return super().__neg__()\n    return Mul(S.NegativeOne, self)",
    ".sympy.core.expr.py@@Expr.is_polynomial": "def is_polynomial(self, *syms):\n    if syms:\n        syms = set(map(sympify, syms))\n    else:\n        syms = self.free_symbols\n        if not syms:\n            return True\n    return self._eval_is_polynomial(syms)",
    ".sympy.core.add.py@@Add._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    return all((term._eval_is_polynomial(syms) for term in self.args))",
    ".sympy.core.expr.py@@AtomicExpr._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    return True",
    ".sympy.core.expr.py@@Expr.diff": "def diff(self, *symbols, **assumptions):\n    assumptions.setdefault('evaluate', True)\n    return _derivative_dispatch(self, *symbols, **assumptions)",
    ".sympy.core.function.py@@_derivative_dispatch": "def _derivative_dispatch(expr, *variables, **kwargs):\n    from sympy.matrices.common import MatrixCommon\n    from sympy.matrices.expressions.matexpr import MatrixExpr\n    from sympy.tensor.array import NDimArray\n    array_types = (MatrixCommon, MatrixExpr, NDimArray, list, tuple, Tuple)\n    if isinstance(expr, array_types) or any((isinstance(i[0], array_types) if isinstance(i, (tuple, list, Tuple)) else isinstance(i, array_types) for i in variables)):\n        from sympy.tensor.array.array_derivatives import ArrayDerivative\n        return ArrayDerivative(expr, *variables, **kwargs)\n    return Derivative(expr, *variables, **kwargs)",
    ".sympy.core.function.py@@Derivative.__new__": "def __new__(cls, expr, *variables, **kwargs):\n    expr = sympify(expr)\n    symbols_or_none = getattr(expr, 'free_symbols', None)\n    has_symbol_set = isinstance(symbols_or_none, set)\n    if not has_symbol_set:\n        raise ValueError(filldedent('\\n            Since there are no variables in the expression %s,\\n            it cannot be differentiated.' % expr))\n    if not variables:\n        variables = expr.free_symbols\n        if len(variables) != 1:\n            if expr.is_number:\n                return S.Zero\n            if len(variables) == 0:\n                raise ValueError(filldedent('\\n                    Since there are no variables in the expression,\\n                    the variable(s) of differentiation must be supplied\\n                    to differentiate %s' % expr))\n            else:\n                raise ValueError(filldedent('\\n                    Since there is more than one variable in the\\n                    expression, the variable(s) of differentiation\\n                    must be supplied to differentiate %s' % expr))\n    variable_count = []\n    array_likes = (tuple, list, Tuple)\n    from sympy.tensor.array import Array, NDimArray\n    for i, v in enumerate(variables):\n        if isinstance(v, UndefinedFunction):\n            raise TypeError('cannot differentiate wrt UndefinedFunction: %s' % v)\n        if isinstance(v, array_likes):\n            if len(v) == 0:\n                continue\n            if isinstance(v[0], array_likes):\n                if len(v) == 1:\n                    v = Array(v[0])\n                    count = 1\n                else:\n                    v, count = v\n                    v = Array(v)\n            else:\n                v, count = v\n            if count == 0:\n                continue\n            variable_count.append(Tuple(v, count))\n            continue\n        v = sympify(v)\n        if isinstance(v, Integer):\n            if i == 0:\n                raise ValueError('First variable cannot be a number: %i' % v)\n            count = v\n            prev, prevcount = variable_count[-1]\n            if prevcount != 1:\n                raise TypeError('tuple {} followed by number {}'.format((prev, prevcount), v))\n            if count == 0:\n                variable_count.pop()\n            else:\n                variable_count[-1] = Tuple(prev, count)\n        else:\n            count = 1\n            variable_count.append(Tuple(v, count))\n    merged = []\n    for t in variable_count:\n        v, c = t\n        if c.is_negative:\n            raise ValueError('order of differentiation must be nonnegative')\n        if merged and merged[-1][0] == v:\n            c += merged[-1][1]\n            if not c:\n                merged.pop()\n            else:\n                merged[-1] = Tuple(v, c)\n        else:\n            merged.append(t)\n    variable_count = merged\n    for v, c in variable_count:\n        if not v._diff_wrt:\n            __ = ''\n            raise ValueError(filldedent(\"\\n                Can't calculate derivative wrt %s.%s\" % (v, __)))\n    if len(variable_count) == 0:\n        return expr\n    evaluate = kwargs.get('evaluate', False)\n    if evaluate:\n        if isinstance(expr, Derivative):\n            expr = expr.canonical\n        variable_count = [(v.canonical if isinstance(v, Derivative) else v, c) for v, c in variable_count]\n        zero = False\n        free = expr.free_symbols\n        from sympy.matrices.expressions.matexpr import MatrixExpr\n        for v, c in variable_count:\n            vfree = v.free_symbols\n            if c.is_positive and vfree:\n                if isinstance(v, AppliedUndef):\n                    D = Dummy()\n                    if not expr.xreplace({v: D}).has(D):\n                        zero = True\n                        break\n                elif isinstance(v, MatrixExpr):\n                    zero = False\n                    break\n                elif isinstance(v, Symbol) and v not in free:\n                    zero = True\n                    break\n                elif not free & vfree:\n                    zero = True\n                    break\n        if zero:\n            return cls._get_zero_with_shape_like(expr)\n        variable_count = cls._sort_variable_count(variable_count)\n    if isinstance(expr, Derivative):\n        variable_count = list(expr.variable_count) + variable_count\n        expr = expr.expr\n        return _derivative_dispatch(expr, *variable_count, **kwargs)\n    if not evaluate or not hasattr(expr, '_eval_derivative'):\n        if evaluate and variable_count == [(expr, 1)] and expr.is_scalar:\n            return S.One\n        return Expr.__new__(cls, expr, *variable_count)\n    nderivs = 0\n    unhandled = []\n    from sympy.matrices.common import MatrixCommon\n    for i, (v, count) in enumerate(variable_count):\n        old_expr = expr\n        old_v = None\n        is_symbol = v.is_symbol or isinstance(v, (Iterable, Tuple, MatrixCommon, NDimArray))\n        if not is_symbol:\n            old_v = v\n            v = Dummy('xi')\n            expr = expr.xreplace({old_v: v})\n            clashing = not (isinstance(old_v, Derivative) or isinstance(old_v, AppliedUndef))\n            if v not in expr.free_symbols and (not clashing):\n                return expr.diff(v)\n            if not old_v.is_scalar and (not hasattr(old_v, '_eval_derivative')):\n                expr *= old_v.diff(old_v)\n        obj = cls._dispatch_eval_derivative_n_times(expr, v, count)\n        if obj is not None and obj.is_zero:\n            return obj\n        nderivs += count\n        if old_v is not None:\n            if obj is not None:\n                obj = obj.subs(v, old_v)\n            expr = old_expr\n        if obj is None:\n            unhandled = variable_count[i:]\n            break\n        expr = obj\n    expr = expr.replace(lambda x: isinstance(x, Derivative), lambda x: x.canonical)\n    if unhandled:\n        if isinstance(expr, Derivative):\n            unhandled = list(expr.variable_count) + unhandled\n            expr = expr.expr\n        expr = Expr.__new__(cls, expr, *unhandled)\n    if (nderivs > 1) == True and kwargs.get('simplify', True):\n        from .exprtools import factor_terms\n        from sympy.simplify.simplify import signsimp\n        expr = factor_terms(signsimp(expr))\n    return expr",
    ".sympy.core.symbol.py@@Symbol._diff_wrt": "def _diff_wrt(self):\n    return True",
    ".sympy.core.function.py@@Derivative._sort_variable_count": "def _sort_variable_count(cls, vc):\n    if not vc:\n        return []\n    vc = list(vc)\n    if len(vc) == 1:\n        return [Tuple(*vc[0])]\n    V = list(range(len(vc)))\n    E = []\n    v = lambda i: vc[i][0]\n    D = Dummy()\n\n    def _block(d, v, wrt=False):\n        if d == v:\n            return wrt\n        if d.is_Symbol:\n            return False\n        if isinstance(d, Derivative):\n            if any((_block(k, v, wrt=True) for k in d._wrt_variables)):\n                return True\n            return False\n        if not wrt and isinstance(d, AppliedUndef):\n            return False\n        if v.is_Symbol:\n            return v in d.free_symbols\n        if isinstance(v, AppliedUndef):\n            return _block(d.xreplace({v: D}), D)\n        return d.free_symbols & v.free_symbols\n    for i in range(len(vc)):\n        for j in range(i):\n            if _block(v(j), v(i)):\n                E.append((j, i))\n    O = dict(zip(ordered(uniq([i for i, c in vc])), range(len(vc))))\n    ix = topological_sort((V, E), key=lambda i: O[v(i)])\n    merged = []\n    for v, c in [vc[i] for i in ix]:\n        if merged and merged[-1][0] == v:\n            merged[-1][1] += c\n        else:\n            merged.append([v, c])\n    return [Tuple(*i) for i in merged]",
    ".sympy.core.function.py@@Derivative._dispatch_eval_derivative_n_times": "def _dispatch_eval_derivative_n_times(cls, expr, v, count):\n    return expr._eval_derivative_n_times(v, count)",
    ".sympy.core.basic.py@@Basic._eval_derivative_n_times": "def _eval_derivative_n_times(self, s, n):\n    from .numbers import Integer\n    if isinstance(n, (int, Integer)):\n        obj = self\n        for i in range(n):\n            obj2 = obj._eval_derivative(s)\n            if obj == obj2 or obj2 is None:\n                break\n            obj = obj2\n        return obj2\n    else:\n        return None",
    ".sympy.core.add.py@@Add._eval_derivative": "def _eval_derivative(self, s):\n    return self.func(*[a.diff(s) for a in self.args])",
    ".sympy.core.function.py@@Derivative._get_zero_with_shape_like": "def _get_zero_with_shape_like(cls, expr):\n    return S.Zero",
    ".sympy.core.expr.py@@AtomicExpr._eval_derivative_n_times": "def _eval_derivative_n_times(self, s, n):\n    from .containers import Tuple\n    from sympy.matrices.expressions.matexpr import MatrixExpr\n    from sympy.matrices.common import MatrixCommon\n    if isinstance(s, (MatrixCommon, Tuple, Iterable, MatrixExpr)):\n        return super()._eval_derivative_n_times(s, n)\n    from .relational import Eq\n    from sympy.functions.elementary.piecewise import Piecewise\n    if self == s:\n        return Piecewise((self, Eq(n, 0)), (1, Eq(n, 1)), (0, True))\n    else:\n        return Piecewise((self, Eq(n, 0)), (0, True))",
    ".sympy.core.relational.py@@Equality.__new__": "def __new__(cls, lhs, rhs, **options):\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    if evaluate:\n        val = is_eq(lhs, rhs)\n        if val is None:\n            return cls(lhs, rhs, evaluate=False)\n        else:\n            return _sympify(val)\n    return Relational.__new__(cls, lhs, rhs)",
    ".sympy.core.relational.py@@is_eq": "def is_eq(lhs, rhs, assumptions=None):\n    for side1, side2 in ((lhs, rhs), (rhs, lhs)):\n        eval_func = getattr(side1, '_eval_Eq', None)\n        if eval_func is not None:\n            retval = eval_func(side2)\n            if retval is not None:\n                return retval\n    retval = _eval_is_eq(lhs, rhs)\n    if retval is not None:\n        return retval\n    if dispatch(type(lhs), type(rhs)) != dispatch(type(rhs), type(lhs)):\n        retval = _eval_is_eq(rhs, lhs)\n        if retval is not None:\n            return retval\n    if lhs == rhs:\n        return True\n    elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):\n        return False\n    elif not (lhs.is_Symbol or rhs.is_Symbol) and isinstance(lhs, Boolean) != isinstance(rhs, Boolean):\n        return False\n    from sympy.assumptions.wrapper import AssumptionsWrapper, is_infinite, is_extended_real\n    from .add import Add\n    _lhs = AssumptionsWrapper(lhs, assumptions)\n    _rhs = AssumptionsWrapper(rhs, assumptions)\n    if _lhs.is_infinite or _rhs.is_infinite:\n        if fuzzy_xor([_lhs.is_infinite, _rhs.is_infinite]):\n            return False\n        if fuzzy_xor([_lhs.is_extended_real, _rhs.is_extended_real]):\n            return False\n        if fuzzy_and([_lhs.is_extended_real, _rhs.is_extended_real]):\n            return fuzzy_xor([_lhs.is_extended_positive, fuzzy_not(_rhs.is_extended_positive)])\n        I = S.ImaginaryUnit\n\n        def split_real_imag(expr):\n            real_imag = lambda t: 'real' if is_extended_real(t, assumptions) else 'imag' if is_extended_real(I * t, assumptions) else None\n            return sift(Add.make_args(expr), real_imag)\n        lhs_ri = split_real_imag(lhs)\n        if not lhs_ri[None]:\n            rhs_ri = split_real_imag(rhs)\n            if not rhs_ri[None]:\n                eq_real = is_eq(Add(*lhs_ri['real']), Add(*rhs_ri['real']), assumptions)\n                eq_imag = is_eq(I * Add(*lhs_ri['imag']), I * Add(*rhs_ri['imag']), assumptions)\n                return fuzzy_and(map(fuzzy_bool, [eq_real, eq_imag]))\n        from sympy.functions.elementary.complexes import arg\n        arglhs = arg(lhs)\n        argrhs = arg(rhs)\n        if not (arglhs == S.NaN and argrhs == S.NaN):\n            return fuzzy_bool(is_eq(arglhs, argrhs, assumptions))\n    if all((isinstance(i, Expr) for i in (lhs, rhs))):\n        dif = lhs - rhs\n        _dif = AssumptionsWrapper(dif, assumptions)\n        z = _dif.is_zero\n        if z is not None:\n            if z is False and _dif.is_commutative:\n                return False\n            if z:\n                return True\n        n2 = _n2(lhs, rhs)\n        if n2 is not None:\n            return _sympify(n2 == 0)\n        n, d = dif.as_numer_denom()\n        rv = None\n        _n = AssumptionsWrapper(n, assumptions)\n        _d = AssumptionsWrapper(d, assumptions)\n        if _n.is_zero:\n            rv = _d.is_nonzero\n        elif _n.is_finite:\n            if _d.is_infinite:\n                rv = True\n            elif _n.is_zero is False:\n                rv = _d.is_infinite\n                if rv is None:\n                    from sympy.simplify.simplify import clear_coefficients\n                    l, r = clear_coefficients(d, S.Infinity)\n                    args = [_.subs(l, r) for _ in (lhs, rhs)]\n                    if args != [lhs, rhs]:\n                        rv = fuzzy_bool(is_eq(*args, assumptions))\n                        if rv is True:\n                            rv = None\n        elif any((is_infinite(a, assumptions) for a in Add.make_args(n))):\n            rv = False\n        if rv is not None:\n            return rv",
    ".sympy.multipledispatch.dispatcher.py@@Dispatcher.__call__": "def __call__(self, *args, **kwargs):\n    types = tuple([type(arg) for arg in args])\n    try:\n        func = self._cache[types]\n    except KeyError:\n        func = self.dispatch(*types)\n        if not func:\n            raise NotImplementedError('Could not find signature for %s: <%s>' % (self.name, str_signature(types)))\n        self._cache[types] = func\n    try:\n        return func(*args, **kwargs)\n    except MDNotImplementedError:\n        funcs = self.dispatch_iter(*types)\n        next(funcs)\n        for func in funcs:\n            try:\n                return func(*args, **kwargs)\n            except MDNotImplementedError:\n                pass\n        raise NotImplementedError('Matching functions for %s: <%s> found, but none completed successfully' % (self.name, str_signature(types)))",
    ".sympy.core.relational.py@@_eval_is_eq": "def _eval_is_eq(lhs, rhs):\n    return None",
    ".sympy.multipledispatch.core.py@@dispatch": "def dispatch(*types, namespace=global_namespace, on_ambiguity=ambiguity_warn):\n    types = tuple(types)\n\n    def _(func):\n        name = func.__name__\n        if ismethod(func):\n            dispatcher = inspect.currentframe().f_back.f_locals.get(name, MethodDispatcher(name))\n        else:\n            if name not in namespace:\n                namespace[name] = Dispatcher(name)\n            dispatcher = namespace[name]\n        dispatcher.add(types, func, on_ambiguity=on_ambiguity)\n        return dispatcher\n    return _",
    ".sympy.assumptions.wrapper.py@@AssumptionsWrapper.__new__": "def __new__(cls, expr, assumptions=None):\n    if assumptions is None:\n        return expr\n    obj = super().__new__(cls, expr, _sympify(assumptions))\n    obj.expr = expr\n    obj.assumptions = assumptions\n    return obj",
    ".sympy.functions.elementary.piecewise.py@@Piecewise.__new__": "def __new__(cls, *args, **options):\n    if len(args) == 0:\n        raise TypeError('At least one (expr, cond) pair expected.')\n    newargs = []\n    for ec in args:\n        pair = ExprCondPair(*getattr(ec, 'args', ec))\n        cond = pair.cond\n        if cond is false:\n            continue\n        newargs.append(pair)\n        if cond is true:\n            break\n    eval = options.pop('evaluate', global_parameters.evaluate)\n    if eval:\n        r = cls.eval(*newargs)\n        if r is not None:\n            return r\n    elif len(newargs) == 1 and newargs[0].cond == True:\n        return newargs[0].expr\n    return Basic.__new__(cls, *newargs, **options)",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.__new__": "def __new__(cls, expr, cond):\n    expr = as_Basic(expr)\n    if cond == True:\n        return Tuple.__new__(cls, expr, true)\n    elif cond == False:\n        return Tuple.__new__(cls, expr, false)\n    elif isinstance(cond, Basic) and cond.has(Piecewise):\n        cond = piecewise_fold(cond)\n        if isinstance(cond, Piecewise):\n            cond = cond.rewrite(ITE)\n    if not isinstance(cond, Boolean):\n        raise TypeError(filldedent('\\n            Second argument must be a Boolean,\\n            not `%s`' % func_name(cond)))\n    return Tuple.__new__(cls, expr, cond)",
    ".sympy.core.basic.py@@as_Basic": "def as_Basic(expr):\n    try:\n        return _sympify(expr)\n    except SympifyError:\n        raise TypeError('Argument must be a Basic object, not `%s`' % func_name(expr))",
    ".sympy.logic.boolalg.py@@BooleanFalse.__eq__": "def __eq__(self, other):\n    if other is True:\n        return False\n    if other is False:\n        return True\n    return super().__eq__(other)",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.cond": "def cond(self):\n    return self.args[1]",
    ".sympy.logic.boolalg.py@@BooleanTrue.__eq__": "def __eq__(self, other):\n    if other is True:\n        return True\n    if other is False:\n        return False\n    return super().__eq__(other)",
    ".sympy.functions.elementary.piecewise.py@@Piecewise.eval": "def eval(cls, *_args):\n    if not _args:\n        return Undefined\n    if len(_args) == 1 and _args[0][-1] == True:\n        return _args[0][0]\n    newargs = _piecewise_collapse_arguments(_args)\n    missing = len(newargs) != len(_args)\n    same = all((a == b for a, b in zip(newargs, _args)))\n    if not newargs:\n        raise ValueError(filldedent('\\n            There are no conditions (or none that\\n            are not trivially false) to define an\\n            expression.'))\n    if missing or not same:\n        return cls(*newargs)",
    ".sympy.core.basic.py@@Basic.replace": "def replace(self, query, value, map=False, simultaneous=True, exact=None):\n    try:\n        query = _sympify(query)\n    except SympifyError:\n        pass\n    try:\n        value = _sympify(value)\n    except SympifyError:\n        pass\n    if isinstance(query, type):\n        _query = lambda expr: isinstance(expr, query)\n        if isinstance(value, type):\n            _value = lambda expr, result: value(*expr.args)\n        elif callable(value):\n            _value = lambda expr, result: value(*expr.args)\n        else:\n            raise TypeError('given a type, replace() expects another type or a callable')\n    elif isinstance(query, Basic):\n        _query = lambda expr: expr.match(query)\n        if exact is None:\n            from .symbol import Wild\n            exact = len(query.atoms(Wild)) > 1\n        if isinstance(value, Basic):\n            if exact:\n                _value = lambda expr, result: value.subs(result) if all(result.values()) else expr\n            else:\n                _value = lambda expr, result: value.subs(result)\n        elif callable(value):\n            if exact:\n                _value = lambda expr, result: value(**{str(k)[:-1]: v for k, v in result.items()}) if all((val for val in result.values())) else expr\n            else:\n                _value = lambda expr, result: value(**{str(k)[:-1]: v for k, v in result.items()})\n        else:\n            raise TypeError('given an expression, replace() expects another expression or a callable')\n    elif callable(query):\n        _query = query\n        if callable(value):\n            _value = lambda expr, result: value(expr)\n        else:\n            raise TypeError('given a callable, replace() expects another callable')\n    else:\n        raise TypeError('first argument to replace() must be a type, an expression or a callable')\n\n    def walk(rv, F):\n        args = getattr(rv, 'args', None)\n        if args is not None:\n            if args:\n                newargs = tuple([walk(a, F) for a in args])\n                if args != newargs:\n                    rv = rv.func(*newargs)\n                    if simultaneous:\n                        for i, e in enumerate(args):\n                            if rv == e and e != newargs[i]:\n                                return rv\n            rv = F(rv)\n        return rv\n    mapping = {}\n\n    def rec_replace(expr):\n        result = _query(expr)\n        if result or result == {}:\n            v = _value(expr, result)\n            if v is not None and v != expr:\n                if map:\n                    mapping[expr] = v\n                expr = v\n        return expr\n    rv = walk(self, rec_replace)\n    return (rv, mapping) if map else rv",
    ".sympy.core.basic.py@@Basic.walk": "def walk(rv, F):\n    args = getattr(rv, 'args', None)\n    if args is not None:\n        if args:\n            newargs = tuple([walk(a, F) for a in args])\n            if args != newargs:\n                rv = rv.func(*newargs)\n                if simultaneous:\n                    for i, e in enumerate(args):\n                        if rv == e and e != newargs[i]:\n                            return rv\n        rv = F(rv)\n    return rv",
    ".sympy.core.basic.py@@Basic.rec_replace": "def rec_replace(expr):\n    result = _query(expr)\n    if result or result == {}:\n        v = _value(expr, result)\n        if v is not None and v != expr:\n            if map:\n                mapping[expr] = v\n            expr = v\n    return expr",
    ".sympy.core.numbers.py@@Integer.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    ".sympy.core.expr.py@@Expr.__int__": "def __int__(self):\n    from .symbol import Dummy\n    if not self.is_number:\n        raise TypeError('Cannot convert symbols to int')\n    r = self.round(2)\n    if not r.is_Number:\n        raise TypeError('Cannot convert complex to int')\n    if r in (S.NaN, S.Infinity, S.NegativeInfinity):\n        raise TypeError('Cannot convert %s to int' % r)\n    i = int(r)\n    if not i:\n        return 0\n    if i == r and (not (self - i).equals(0)):\n        isign = 1 if i > 0 else -1\n        x = Dummy()\n        diff_sign = 1 if (self - x).evalf(2, subs={x: i}) > 0 else -1\n        if diff_sign != isign:\n            i -= isign\n    return i",
    ".sympy.printing.str.py@@StrPrinter._print_Add": "def _print_Add(self, expr, order=None):\n    terms = self._as_ordered_terms(expr, order=order)\n    prec = precedence(expr)\n    l = []\n    for term in terms:\n        t = self._print(term)\n        if t.startswith('-') and (not term.is_Add):\n            sign = '-'\n            t = t[1:]\n        else:\n            sign = '+'\n        if precedence(term) < prec or term.is_Add:\n            l.extend([sign, '(%s)' % t])\n        else:\n            l.extend([sign, t])\n    sign = l.pop(0)\n    if sign == '+':\n        sign = ''\n    return sign + ' '.join(l)",
    ".sympy.printing.printer.py@@Printer._as_ordered_terms": "def _as_ordered_terms(self, expr, order=None):\n    order = order or self.order\n    if order == 'old':\n        return sorted(Add.make_args(expr), key=cmp_to_key(Basic._compare_pretty))\n    elif order == 'none':\n        return list(expr.args)\n    else:\n        return expr.as_ordered_terms(order=order)",
    ".sympy.printing.printer.py@@Printer.order": "def order(self):\n    if 'order' in self._settings:\n        return self._settings['order']\n    else:\n        raise AttributeError('No order defined.')",
    ".sympy.core.expr.py@@Expr.as_ordered_terms": "def as_ordered_terms(self, order=None, data=False):\n    from .numbers import Number, NumberSymbol\n    if order is None and self.is_Add:\n        key = lambda x: not isinstance(x, (Number, NumberSymbol))\n        add_args = sorted(Add.make_args(self), key=key)\n        if len(add_args) == 2 and isinstance(add_args[0], (Number, NumberSymbol)) and isinstance(add_args[1], Mul):\n            mul_args = sorted(Mul.make_args(add_args[1]), key=key)\n            if len(mul_args) == 2 and isinstance(mul_args[0], Number) and add_args[0].is_positive and mul_args[0].is_negative:\n                return add_args\n    key, reverse = self._parse_order(order)\n    terms, gens = self.as_terms()\n    if not any((term.is_Order for term, _ in terms)):\n        ordered = sorted(terms, key=key, reverse=reverse)\n    else:\n        _terms, _order = ([], [])\n        for term, repr in terms:\n            if not term.is_Order:\n                _terms.append((term, repr))\n            else:\n                _order.append((term, repr))\n        ordered = sorted(_terms, key=key, reverse=True) + sorted(_order, key=key, reverse=True)\n    if data:\n        return (ordered, gens)\n    else:\n        return [term for term, _ in ordered]",
    ".sympy.core.expr.py@@Expr._parse_order": "def _parse_order(cls, order):\n    from sympy.polys.orderings import monomial_key\n    startswith = getattr(order, 'startswith', None)\n    if startswith is None:\n        reverse = False\n    else:\n        reverse = startswith('rev-')\n        if reverse:\n            order = order[4:]\n    monom_key = monomial_key(order)\n\n    def neg(monom):\n        return tuple([neg(m) if isinstance(m, tuple) else -m for m in monom])\n\n    def key(term):\n        _, ((re, im), monom, ncpart) = term\n        monom = neg(monom_key(monom))\n        ncpart = tuple([e.sort_key(order=order) for e in ncpart])\n        coeff = ((bool(im), im), (re, im))\n        return (monom, ncpart, coeff)\n    return (key, reverse)",
    ".sympy.polys.orderings.py@@monomial_key": "def monomial_key(order=None, gens=None):\n    if order is None:\n        order = lex\n    if isinstance(order, Symbol):\n        order = str(order)\n    if isinstance(order, str):\n        try:\n            order = _monomial_key[order]\n        except KeyError:\n            raise ValueError(\"supported monomial orderings are 'lex', 'grlex' and 'grevlex', got %r\" % order)\n    if hasattr(order, '__call__'):\n        if gens is not None:\n\n            def _order(expr):\n                return order(expr.as_poly(*gens).degree_list())\n            return _order\n        return order\n    else:\n        raise ValueError('monomial ordering specification must be a string or a callable, got %s' % order)",
    ".sympy.core.expr.py@@Expr.as_terms": "def as_terms(self):\n    from .exprtools import decompose_power\n    gens, terms = (set(), [])\n    for term in Add.make_args(self):\n        coeff, _term = term.as_coeff_Mul()\n        coeff = complex(coeff)\n        cpart, ncpart = ({}, [])\n        if _term is not S.One:\n            for factor in Mul.make_args(_term):\n                if factor.is_number:\n                    try:\n                        coeff *= complex(factor)\n                    except (TypeError, ValueError):\n                        pass\n                    else:\n                        continue\n                if factor.is_commutative:\n                    base, exp = decompose_power(factor)\n                    cpart[base] = exp\n                    gens.add(base)\n                else:\n                    ncpart.append(factor)\n        coeff = (coeff.real, coeff.imag)\n        ncpart = tuple(ncpart)\n        terms.append((term, (coeff, cpart, ncpart)))\n    gens = sorted(gens, key=default_sort_key)\n    k, indices = (len(gens), {})\n    for i, g in enumerate(gens):\n        indices[g] = i\n    result = []\n    for term, (coeff, cpart, ncpart) in terms:\n        monom = [0] * k\n        for base, exp in cpart.items():\n            monom[indices[base]] = exp\n        result.append((term, (coeff, tuple(monom), ncpart)))\n    return (result, gens)",
    ".sympy.core.expr.py@@Expr.__complex__": "def __complex__(self):\n    result = self.evalf()\n    re, im = result.as_real_imag()\n    return complex(float(re), float(im))",
    ".sympy.core.expr.py@@Expr.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    if hints.get('ignore') == self:\n        return None\n    else:\n        from sympy.functions.elementary.complexes import im, re\n        return (re(self), im(self))",
    ".sympy.functions.elementary.complexes.py@@re.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_extended_real:\n        return arg\n    elif arg.is_imaginary or (I * arg).is_extended_real:\n        return S.Zero\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[0]\n    elif arg.is_Function and isinstance(arg, conjugate):\n        return re(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(I)\n            if coeff is not None:\n                if not coeff.is_extended_real:\n                    reverted.append(coeff)\n            elif not term.has(I) and term.is_extended_real:\n                excluded.append(term)\n            else:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[0])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) - im(b) + c",
    ".sympy.functions.elementary.complexes.py@@im.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_extended_real:\n        return S.Zero\n    elif arg.is_imaginary or (I * arg).is_extended_real:\n        return -I * arg\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[1]\n    elif arg.is_Function and isinstance(arg, conjugate):\n        return -im(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(I)\n            if coeff is not None:\n                if not coeff.is_extended_real:\n                    reverted.append(coeff)\n                else:\n                    excluded.append(coeff)\n            elif term.has(I) or not term.is_extended_real:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[1])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) + re(b) + c",
    ".sympy.core.numbers.py@@Number.__float__": "def __float__(self):\n    return mlib.to_float(self._as_mpf_val(53))",
    ".sympy.core.numbers.py@@Float._as_mpf_val": "def _as_mpf_val(self, prec):\n    rv = mpf_norm(self._mpf_, prec)\n    if rv != self._mpf_ and self._prec == prec:\n        debug(self._mpf_, rv)\n    return rv",
    ".sympy.core.exprtools.py@@decompose_power": "def decompose_power(expr: Expr) -> tTuple[Expr, int]:\n    base, exp = expr.as_base_exp()\n    if exp.is_Number:\n        if exp.is_Rational:\n            if not exp.is_Integer:\n                base = Pow(base, Rational(1, exp.q))\n            e = exp.p\n        else:\n            base, e = (expr, 1)\n    else:\n        exp, tail = exp.as_coeff_Mul(rational=True)\n        if exp is S.NegativeOne:\n            base, e = (Pow(base, tail), -1)\n        elif exp is not S.One:\n            tail = _keep_coeff(Rational(1, exp.q), tail)\n            base, e = (Pow(base, tail), exp.p)\n        else:\n            base, e = (expr, 1)\n    return (base, e)",
    ".sympy.core.sorting.py@@default_sort_key": "def default_sort_key(item, order=None):\n    from .basic import Basic\n    from .singleton import S\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n    if iterable(item, exclude=str):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            args = list(item)\n            unordered = False\n        args = [default_sort_key(arg, order=order) for arg in args]\n        if unordered:\n            args = sorted(args)\n        cls_index, args = (10, (len(args), tuple(args)))\n    else:\n        if not isinstance(item, str):\n            try:\n                item = sympify(item, strict=True)\n            except SympifyError:\n                pass\n            else:\n                if isinstance(item, Basic):\n                    return default_sort_key(item)\n        cls_index, args = (0, (1, (str(item),)))\n    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)",
    ".sympy.core.symbol.py@@Symbol.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (1, (self.name,)), S.One.sort_key(), S.One)",
    ".sympy.core.basic.py@@Atom.class_key": "def class_key(cls):\n    return (2, 0, cls.__name__)",
    ".sympy.core.numbers.py@@Number.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (0, ()), (), self)",
    ".sympy.core.numbers.py@@Number.class_key": "def class_key(cls):\n    return (1, 0, 'Number')",
    ".sympy.core.expr.py@@Expr.key": "def key(term):\n    _, ((re, im), monom, ncpart) = term\n    monom = neg(monom_key(monom))\n    ncpart = tuple([e.sort_key(order=order) for e in ncpart])\n    coeff = ((bool(im), im), (re, im))\n    return (monom, ncpart, coeff)",
    ".sympy.polys.orderings.py@@LexOrder.__call__": "def __call__(self, monomial):\n    return monomial",
    ".sympy.core.expr.py@@Expr.neg": "def neg(monom):\n    return tuple([neg(m) if isinstance(m, tuple) else -m for m in monom])",
    ".sympy.printing.precedence.py@@precedence": "def precedence(item):\n    if hasattr(item, 'precedence'):\n        return item.precedence\n    try:\n        mro = item.__class__.__mro__\n    except AttributeError:\n        return PRECEDENCE['Atom']\n    for i in mro:\n        n = i.__name__\n        if n in PRECEDENCE_FUNCTIONS:\n            return PRECEDENCE_FUNCTIONS[n](item)\n        elif n in PRECEDENCE_VALUES:\n            return PRECEDENCE_VALUES[n]\n    return PRECEDENCE['Atom']",
    ".sympy.printing.str.py@@StrPrinter._print_Mul": "def _print_Mul(self, expr):\n    prec = precedence(expr)\n    args = expr.args\n    if args[0] is S.One or any((isinstance(a, Number) or (a.is_Pow and all((ai.is_Integer for ai in a.args))) for a in args[1:])):\n        d, n = sift(args, lambda x: isinstance(x, Pow) and bool(x.exp.as_coeff_Mul()[0] < 0), binary=True)\n        for i, di in enumerate(d):\n            if di.exp.is_Number:\n                e = -di.exp\n            else:\n                dargs = list(di.exp.args)\n                dargs[0] = -dargs[0]\n                e = Mul._from_args(dargs)\n            d[i] = Pow(di.base, e, evaluate=False) if e - 1 else di.base\n        pre = []\n        if n and (not n[0].is_Add) and n[0].could_extract_minus_sign():\n            pre = [self._print(n.pop(0))]\n        nfactors = pre + [self.parenthesize(a, prec, strict=False) for a in n]\n        if not nfactors:\n            nfactors = ['1']\n        if len(d) > 1 and d[0].could_extract_minus_sign():\n            pre = [self._print(d.pop(0))]\n        else:\n            pre = []\n        dfactors = pre + [self.parenthesize(a, prec, strict=False) for a in d]\n        n = '*'.join(nfactors)\n        d = '*'.join(dfactors)\n        if len(dfactors) > 1:\n            return '%s/(%s)' % (n, d)\n        elif dfactors:\n            return '%s/%s' % (n, d)\n        return n\n    c, e = expr.as_coeff_Mul()\n    if c < 0:\n        expr = _keep_coeff(-c, e)\n        sign = '-'\n    else:\n        sign = ''\n    a = []\n    b = []\n    pow_paren = []\n    if self.order not in ('old', 'none'):\n        args = expr.as_ordered_factors()\n    else:\n        args = Mul.make_args(expr)\n\n    def apow(i):\n        b, e = i.as_base_exp()\n        eargs = list(Mul.make_args(e))\n        if eargs[0] is S.NegativeOne:\n            eargs = eargs[1:]\n        else:\n            eargs[0] = -eargs[0]\n        e = Mul._from_args(eargs)\n        if isinstance(i, Pow):\n            return i.func(b, e, evaluate=False)\n        return i.func(e, evaluate=False)\n    for item in args:\n        if item.is_commutative and isinstance(item, Pow) and bool(item.exp.as_coeff_Mul()[0] < 0):\n            if item.exp is not S.NegativeOne:\n                b.append(apow(item))\n            else:\n                if len(item.args[0].args) != 1 and isinstance(item.base, (Mul, Pow)):\n                    pow_paren.append(item)\n                b.append(item.base)\n        elif item.is_Rational and item is not S.Infinity:\n            if item.p != 1:\n                a.append(Rational(item.p))\n            if item.q != 1:\n                b.append(Rational(item.q))\n        else:\n            a.append(item)\n    a = a or [S.One]\n    a_str = [self.parenthesize(x, prec, strict=False) for x in a]\n    b_str = [self.parenthesize(x, prec, strict=False) for x in b]\n    for item in pow_paren:\n        if item.base in b:\n            b_str[b.index(item.base)] = '(%s)' % b_str[b.index(item.base)]\n    if not b:\n        return sign + '*'.join(a_str)\n    elif len(b) == 1:\n        return sign + '*'.join(a_str) + '/' + b_str[0]\n    else:\n        return sign + '*'.join(a_str) + '/(%s)' % '*'.join(b_str)",
    ".sympy.printing.precedence.py@@precedence_Mul": "def precedence_Mul(item):\n    if item.could_extract_minus_sign():\n        return PRECEDENCE['Add']\n    return PRECEDENCE['Mul']",
    ".sympy.core.numbers.py@@Rational.__lt__": "def __lt__(self, other):\n    rv = self._Rrel(other, '__gt__')\n    if rv is None:\n        rv = (self, other)\n    elif not isinstance(rv, tuple):\n        return rv\n    return Expr.__lt__(*rv)",
    ".sympy.core.numbers.py@@Rational._Rrel": "def _Rrel(self, other, attr):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Number:\n        op = None\n        s, o = (self, other)\n        if other.is_NumberSymbol:\n            op = getattr(o, attr)\n        elif other.is_Float:\n            op = getattr(o, attr)\n        elif other.is_Rational:\n            s, o = (Integer(s.p * o.q), Integer(s.q * o.p))\n            op = getattr(o, attr)\n        if op:\n            return op(s)\n        if o.is_number and o.is_extended_real:\n            return (Integer(s.p), s.q * o)",
    ".sympy.core.mul.py@@Mul.as_ordered_factors": "def as_ordered_factors(self, order=None):\n    cpart, ncpart = self.args_cnc()\n    cpart.sort(key=lambda expr: expr.sort_key(order=order))\n    return cpart + ncpart",
    ".sympy.printing.str.py@@StrPrinter.parenthesize": "def parenthesize(self, item, level, strict=False):\n    if precedence(item) < level or (not strict and precedence(item) <= level):\n        return '(%s)' % self._print(item)\n    else:\n        return self._print(item)",
    ".sympy.printing.str.py@@StrPrinter._print_Symbol": "def _print_Symbol(self, expr):\n    return expr.name",
    ".sympy.printing.precedence.py@@precedence_Integer": "def precedence_Integer(item):\n    if item.p < 0:\n        return PRECEDENCE['Add']\n    return PRECEDENCE['Atom']",
    ".sympy.printing.str.py@@StrPrinter._print_Integer": "def _print_Integer(self, expr):\n    if self._settings.get('sympy_integers', False):\n        return 'S(%s)' % expr\n    return str(expr.p)",
    ".sympy.functions.special.gamma_functions.py@@gamma._eval_is_positive": "def _eval_is_positive(self):\n    x = self.args[0]\n    if x.is_positive:\n        return True\n    elif x.is_noninteger:\n        return floor(x).is_even",
    ".sympy.core.function.py@@Function.as_base_exp": "def as_base_exp(self):\n    return (self, S.One)",
    ".sympy.matrices.expressions.matexpr.py@@MatrixExpr.is_square": "def is_square(self) -> bool | None:\n    rows, cols = self.shape\n    if isinstance(rows, Integer) and isinstance(cols, Integer):\n        return rows == cols\n    if rows == cols:\n        return True\n    return None",
    ".sympy.core.numbers.py@@Integer.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other * self.p)\n        elif isinstance(other, Rational):\n            return Rational(other.p * self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    ".sympy.core.numbers.py@@Rational._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_rational(self.p, self.q, prec, rnd)",
    ".sympy.core.evalf.py@@evalf_rational": "def evalf_rational(expr: 'Rational', prec: int, options: OPT_DICT) -> TMP_RES:\n    return (from_rational(expr.p, expr.q, prec), None, prec, None)",
    ".sympy.core.numbers.py@@Float.__gt__": "def __gt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__lt__(self)\n    rv = self._Frel(other, mlib.mpf_gt)\n    if rv is None:\n        return Expr.__gt__(self, other)\n    return rv",
    ".sympy.core.operations.py@@AssocOp._eval_evalf": "def _eval_evalf(self, prec):\n    from .add import Add\n    from .mul import Mul\n    from .symbol import Symbol\n    from .function import AppliedUndef\n    if isinstance(self, (Mul, Add)):\n        x, tail = self.as_independent(Symbol, AppliedUndef)\n        if not (tail is self.identity or (isinstance(x, AssocOp) and x.is_Function) or (x is self.identity and isinstance(tail, AssocOp))):\n            x = x._evalf(prec) if x is not self.identity else self.identity\n            args = []\n            tail_args = tuple(self.func.make_args(tail))\n            for a in tail_args:\n                newa = a._eval_evalf(prec)\n                if newa is None:\n                    args.append(a)\n                else:\n                    args.append(newa)\n            return self.func(x, *args)\n    args = []\n    for a in self.args:\n        newa = a._eval_evalf(prec)\n        if newa is None:\n            args.append(a)\n        else:\n            args.append(newa)\n    return self.func(*args)",
    ".sympy.core.expr.py@@Expr.as_independent": "def as_independent(self, *deps, **hint) -> tuple[Expr, Expr]:\n    from .symbol import Symbol\n    from .add import _unevaluated_Add\n    from .mul import _unevaluated_Mul\n    if self is S.Zero:\n        return (self, self)\n    func = self.func\n    if hint.get('as_Add', isinstance(self, Add)):\n        want = Add\n    else:\n        want = Mul\n    sym = set()\n    other = []\n    for d in deps:\n        if isinstance(d, Symbol):\n            sym.add(d)\n        else:\n            other.append(d)\n\n    def has(e):\n        has_other = e.has(*other)\n        if not sym:\n            return has_other\n        return has_other or e.has(*e.free_symbols & sym)\n    if want is not func or (func is not Add and func is not Mul):\n        if has(self):\n            return (want.identity, self)\n        else:\n            return (self, want.identity)\n    elif func is Add:\n        args = list(self.args)\n    else:\n        args, nc = self.args_cnc()\n    d = sift(args, has)\n    depend = d[True]\n    indep = d[False]\n    if func is Add:\n        return (Add(*indep), _unevaluated_Add(*depend))\n    else:\n        for i, n in enumerate(nc):\n            if has(n):\n                depend.extend(nc[i:])\n                break\n            indep.append(n)\n        return (Mul(*indep), Mul(*depend, evaluate=False) if nc else _unevaluated_Mul(*depend))",
    ".sympy.utilities.iterables.py@@sift": "def sift(seq, keyfunc, binary=False):\n    if not binary:\n        m = defaultdict(list)\n        for i in seq:\n            m[keyfunc(i)].append(i)\n        return m\n    sift = F, T = ([], [])\n    for i in seq:\n        try:\n            sift[keyfunc(i)].append(i)\n        except (IndexError, TypeError):\n            raise ValueError('keyfunc gave non-binary output')\n    return (T, F)",
    ".sympy.core.expr.py@@Expr.has": "def has(e):\n    has_other = e.has(*other)\n    if not sym:\n        return has_other\n    return has_other or e.has(*e.free_symbols & sym)",
    ".sympy.core.add.py@@_unevaluated_Add": "def _unevaluated_Add(*args):\n    args = list(args)\n    newargs = []\n    co = S.Zero\n    while args:\n        a = args.pop()\n        if a.is_Add:\n            args.extend(a.args)\n        elif a.is_Number:\n            co += a\n        else:\n            newargs.append(a)\n    _addsort(newargs)\n    if co:\n        newargs.insert(0, co)\n    return Add._from_args(newargs)",
    ".sympy.core.numbers.py@@NumberSymbol._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Pi._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mpf_pi(prec)",
    ".sympy.core.numbers.py@@Float._as_mpf_op": "def _as_mpf_op(self, prec):\n    return (self._mpf_, max(prec, self._prec))",
    ".sympy.core.evalf.py@@evalf_add": "def evalf_add(v: 'Add', prec: int, options: OPT_DICT) -> TMP_RES:\n    res = pure_complex(v)\n    if res:\n        h, c = res\n        re, _, re_acc, _ = evalf(h, prec, options)\n        im, _, im_acc, _ = evalf(c, prec, options)\n        return (re, im, re_acc, im_acc)\n    oldmaxprec = options.get('maxprec', DEFAULT_MAXPREC)\n    i = 0\n    target_prec = prec\n    while 1:\n        options['maxprec'] = min(oldmaxprec, 2 * prec)\n        terms = [evalf(arg, prec + 10, options) for arg in v.args]\n        n = terms.count(S.ComplexInfinity)\n        if n >= 2:\n            return (fnan, None, prec, None)\n        re, re_acc = add_terms([a[0::2] for a in terms if isinstance(a, tuple) and a[0]], prec, target_prec)\n        im, im_acc = add_terms([a[1::2] for a in terms if isinstance(a, tuple) and a[1]], prec, target_prec)\n        if n == 1:\n            if re in (finf, fninf, fnan) or im in (finf, fninf, fnan):\n                return (fnan, None, prec, None)\n            return S.ComplexInfinity\n        acc = complex_accuracy((re, im, re_acc, im_acc))\n        if acc >= target_prec:\n            if options.get('verbose'):\n                print('ADD: wanted', target_prec, 'accurate bits, got', re_acc, im_acc)\n            break\n        else:\n            if prec - target_prec > options['maxprec']:\n                break\n            prec = prec + max(10 + 2 ** i, target_prec - acc)\n            i += 1\n            if options.get('verbose'):\n                print('ADD: restarting with prec', prec)\n    options['maxprec'] = oldmaxprec\n    if iszero(re, scaled=True):\n        re = scaled_zero(re)\n    if iszero(im, scaled=True):\n        im = scaled_zero(im)\n    return (re, im, re_acc, im_acc)",
    ".sympy.core.evalf.py@@add_terms": "def add_terms(terms: list, prec: int, target_prec: int) -> tTuple[tUnion[MPF_TUP, SCALED_ZERO_TUP, None], Optional[int]]:\n    terms = [t for t in terms if not iszero(t[0])]\n    if not terms:\n        return (None, None)\n    elif len(terms) == 1:\n        return terms[0]\n    special = []\n    from .numbers import Float\n    for t in terms:\n        arg = Float._new(t[0], 1)\n        if arg is S.NaN or arg.is_infinite:\n            special.append(arg)\n    if special:\n        from .add import Add\n        rv = evalf(Add(*special), prec + 4, {})\n        return (rv[0], rv[2])\n    working_prec = 2 * prec\n    sum_man, sum_exp = (0, 0)\n    absolute_err: List[int] = []\n    for x, accuracy in terms:\n        sign, man, exp, bc = x\n        if sign:\n            man = -man\n        absolute_err.append(bc + exp - accuracy)\n        delta = exp - sum_exp\n        if exp >= sum_exp:\n            if delta > working_prec and (not sum_man or delta - bitcount(abs(sum_man)) > working_prec):\n                sum_man = man\n                sum_exp = exp\n            else:\n                sum_man += man << delta\n        else:\n            delta = -delta\n            if delta - bc > working_prec:\n                if not sum_man:\n                    sum_man, sum_exp = (man, exp)\n            else:\n                sum_man = (sum_man << delta) + man\n                sum_exp = exp\n    absolute_error = max(absolute_err)\n    if not sum_man:\n        return scaled_zero(absolute_error)\n    if sum_man < 0:\n        sum_sign = 1\n        sum_man = -sum_man\n    else:\n        sum_sign = 0\n    sum_bc = bitcount(sum_man)\n    sum_accuracy = sum_exp + sum_bc - absolute_error\n    r = (normalize(sum_sign, sum_man, sum_exp, sum_bc, target_prec, rnd), sum_accuracy)\n    return r",
    ".sympy.core.evalf.py@@iszero": "def iszero(mpf: tUnion[MPF_TUP, SCALED_ZERO_TUP, None], scaled=False) -> Optional[bool]:\n    if not scaled:\n        return not mpf or (not mpf[1] and (not mpf[-1]))\n    return mpf and isinstance(mpf[0], list) and (mpf[1] == mpf[-1] == 1)",
    ".sympy.core.evalf.py@@bitcount": "def bitcount(n):\n    return mpmath_bitcount(abs(int(n)))",
    ".sympy.core.evalf.py@@complex_accuracy": "def complex_accuracy(result: TMP_RES) -> tUnion[int, Any]:\n    if result is S.ComplexInfinity:\n        return INF\n    re, im, re_acc, im_acc = result\n    if not im:\n        if not re:\n            return INF\n        return re_acc\n    if not re:\n        return im_acc\n    re_size = fastlog(re)\n    im_size = fastlog(im)\n    absolute_error = max(re_size - re_acc, im_size - im_acc)\n    relative_error = absolute_error - max(re_size, im_size)\n    return -relative_error",
    ".sympy.core.symbol.py@@Str._hashable_content": "def _hashable_content(self):\n    return (self.name,)",
    ".sympy.printing.precedence.py@@precedence_Rational": "def precedence_Rational(item):\n    if item.p < 0:\n        return PRECEDENCE['Add']\n    return PRECEDENCE['Mul']",
    ".sympy.core.expr.py@@Expr._eval_is_polynomial": "def _eval_is_polynomial(self, syms):\n    if self in syms:\n        return True\n    if not self.has_free(*syms):\n        return True",
    ".sympy.core.basic.py@@Basic.has_free": "def has_free(self, *patterns):\n    if not patterns:\n        return False\n    p0 = patterns[0]\n    if len(patterns) == 1 and iterable(p0) and (not isinstance(p0, Basic)):\n        raise TypeError(filldedent(\"\\n            Expecting 1 or more Basic args, not a single\\n            non-Basic iterable. Don't forget to unpack\\n            iterables: `eq.has_free(*patterns)`\"))\n    s = set(patterns)\n    rv = self.has_xfree(s)\n    if rv:\n        return rv\n    return self._has(iterfreeargs, *patterns)",
    ".sympy.core.basic.py@@Basic.has_xfree": "def has_xfree(self, s: set[Basic]):\n    if type(s) is not set:\n        raise TypeError('expecting set argument')\n    return any((a in s for a in iterfreeargs(self)))",
    ".sympy.core.traversal.py@@iterfreeargs": "def iterfreeargs(expr, _first=True):\n    args = [expr]\n    for i in args:\n        yield i\n        if _first and hasattr(i, 'bound_symbols'):\n            void = i.canonical_variables.values()\n            for i in iterfreeargs(i.as_dummy(), _first=False):\n                if not i.has(*void):\n                    yield i\n        try:\n            args.extend(i.args)\n        except TypeError:\n            pass",
    ".sympy.core.add.py@@Add.as_numer_denom": "def as_numer_denom(self):\n    content, expr = self.primitive()\n    if not isinstance(expr, Add):\n        return Mul(content, expr, evaluate=False).as_numer_denom()\n    ncon, dcon = content.as_numer_denom()\n    nd = defaultdict(list)\n    for f in expr.args:\n        ni, di = f.as_numer_denom()\n        nd[di].append(ni)\n    if len(nd) == 1:\n        d, n = nd.popitem()\n        return (self.func(*[_keep_coeff(ncon, ni) for ni in n]), _keep_coeff(dcon, d))\n    for d, n in nd.items():\n        if len(n) == 1:\n            nd[d] = n[0]\n        else:\n            nd[d] = self.func(*n)\n    denoms, numers = [list(i) for i in zip(*iter(nd.items()))]\n    n, d = (self.func(*[Mul(*denoms[:i] + [numers[i]] + denoms[i + 1:]) for i in range(len(numers))]), Mul(*denoms))\n    return (_keep_coeff(ncon, n), _keep_coeff(dcon, d))",
    ".sympy.core.add.py@@Add.primitive": "def primitive(self):\n    terms = []\n    inf = False\n    for a in self.args:\n        c, m = a.as_coeff_Mul()\n        if not c.is_Rational:\n            c = S.One\n            m = a\n        inf = inf or m is S.ComplexInfinity\n        terms.append((c.p, c.q, m))\n    if not inf:\n        ngcd = reduce(igcd, [t[0] for t in terms], 0)\n        dlcm = reduce(ilcm, [t[1] for t in terms], 1)\n    else:\n        ngcd = reduce(igcd, [t[0] for t in terms if t[1]], 0)\n        dlcm = reduce(ilcm, [t[1] for t in terms if t[1]], 1)\n    if ngcd == dlcm == 1:\n        return (S.One, self)\n    if not inf:\n        for i, (p, q, term) in enumerate(terms):\n            terms[i] = _keep_coeff(Rational(p // ngcd * (dlcm // q)), term)\n    else:\n        for i, (p, q, term) in enumerate(terms):\n            if q:\n                terms[i] = _keep_coeff(Rational(p // ngcd * (dlcm // q)), term)\n            else:\n                terms[i] = _keep_coeff(Rational(p, q), term)\n    if terms[0].is_Number or terms[0] is S.ComplexInfinity:\n        c = terms.pop(0)\n    else:\n        c = None\n    _addsort(terms)\n    if c:\n        terms.insert(0, c)\n    return (Rational(ngcd, dlcm), self._new_rawargs(*terms))",
    ".sympy.core.numbers.py@@ilcm": "def ilcm(*args):\n    if len(args) < 2:\n        raise TypeError('ilcm() takes at least 2 arguments (%s given)' % len(args))\n    if 0 in args:\n        return 0\n    a = args[0]\n    for b in args[1:]:\n        a = a // igcd(a, b) * b\n    return a",
    ".sympy.core.numbers.py@@Integer.as_numer_denom": "def as_numer_denom(self):\n    return (self, S.One)"
}