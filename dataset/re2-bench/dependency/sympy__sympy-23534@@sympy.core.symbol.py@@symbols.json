{
    ".sympy.core.symbol.py@@Symbol.__new__": "def __new__(cls, name, **assumptions):\n    cls._sanitize(assumptions, cls)\n    return Symbol.__xnew_cached_(cls, name, **assumptions)",
    ".sympy.core.symbol.py@@Symbol._sanitize": "def _sanitize(assumptions, obj=None):\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    if is_commutative is None:\n        whose = '%s ' % obj.__name__ if obj else ''\n        raise ValueError('%scommutativity must be True or False.' % whose)\n    for key in list(assumptions.keys()):\n        v = assumptions[key]\n        if v is None:\n            assumptions.pop(key)\n            continue\n        assumptions[key] = bool(v)",
    ".sympy.core.logic.py@@fuzzy_bool": "def fuzzy_bool(x):\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    ".sympy.core.symbol.py@@Symbol.__xnew_cached_": "def __xnew_cached_(cls, name, **assumptions):\n    return Symbol.__xnew__(cls, name, **assumptions)",
    ".sympy.core.symbol.py@@Symbol.__xnew__": "def __xnew__(cls, name, **assumptions):\n    if not isinstance(name, str):\n        raise TypeError('name should be a string, not %s' % repr(type(name)))\n    obj = Expr.__new__(cls)\n    obj.name = name\n    tmp_asm_copy = assumptions.copy()\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    assumptions['commutative'] = is_commutative\n    obj._assumptions = StdFactKB(assumptions)\n    obj._assumptions._generator = tmp_asm_copy\n    return obj",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    super().__init__(_assume_rules)\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.__init__": "def __init__(self, rules):\n    self.rules = rules",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.function.py@@Function.__new__": "def __new__(cls, *args, **options):\n    if cls is Function:\n        return UndefinedFunction(*args, **options)\n    n = len(args)\n    if n not in cls.nargs:\n        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'\n        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})\n    evaluate = options.get('evaluate', global_parameters.evaluate)\n    result = super().__new__(cls, *args, **options)\n    if evaluate and isinstance(result, cls) and result.args:\n        pr2 = min((cls._should_evalf(a) for a in result.args))\n        if pr2 > 0:\n            pr = max((cls._should_evalf(a) for a in result.args))\n            result = result.evalf(prec_to_dps(pr))\n    return _sympify(result)",
    ".sympy.core.function.py@@UndefinedFunction.__new__": "def __new__(mcl, name, bases=(AppliedUndef,), __dict__=None, **kwargs):\n    from .symbol import _filter_assumptions\n    assumptions, kwargs = _filter_assumptions(kwargs)\n    if isinstance(name, Symbol):\n        assumptions = name._merge(assumptions)\n        name = name.name\n    elif not isinstance(name, str):\n        raise TypeError('expecting string or Symbol for name')\n    else:\n        commutative = assumptions.get('commutative', None)\n        assumptions = Symbol(name, **assumptions).assumptions0\n        if commutative is None:\n            assumptions.pop('commutative')\n    __dict__ = __dict__ or {}\n    __dict__.update({'is_%s' % k: v for k, v in assumptions.items()})\n    __dict__.update(kwargs)\n    kwargs.update(assumptions)\n    __dict__.update({'_kwargs': kwargs})\n    __dict__['__module__'] = None\n    obj = super().__new__(mcl, name, bases, __dict__)\n    obj.name = name\n    obj._sage_ = _undef_sage_helper\n    return obj",
    ".sympy.core.symbol.py@@_filter_assumptions": "def _filter_assumptions(kwargs):\n    assumptions, nonassumptions = map(dict, sift(kwargs.items(), lambda i: i[0] in _assume_defined, binary=True))\n    Symbol._sanitize(assumptions)\n    return (assumptions, nonassumptions)",
    ".sympy.utilities.iterables.py@@sift": "def sift(seq, keyfunc, binary=False):\n    if not binary:\n        m = defaultdict(list)\n        for i in seq:\n            m[keyfunc(i)].append(i)\n        return m\n    sift = F, T = ([], [])\n    for i in seq:\n        try:\n            sift[keyfunc(i)].append(i)\n        except (IndexError, TypeError):\n            raise ValueError('keyfunc gave non-binary output')\n    return (T, F)",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return {key: value for key, value in self._assumptions.items() if value is not None}",
    ".sympy.core.function.py@@FunctionClass.__init__": "def __init__(cls, *args, **kwargs):\n    nargs = kwargs.pop('nargs', cls.__dict__.get('nargs', arity(cls)))\n    if nargs is None and 'nargs' not in cls.__dict__:\n        for supcls in cls.__mro__:\n            if hasattr(supcls, '_nargs'):\n                nargs = supcls._nargs\n                break\n            else:\n                continue\n    if is_sequence(nargs):\n        if not nargs:\n            raise ValueError(filldedent('\\n                Incorrectly specified nargs as %s:\\n                if there are no arguments, it should be\\n                `nargs = 0`;\\n                if there are any number of arguments,\\n                it should be\\n                `nargs = None`' % str(nargs)))\n        nargs = tuple(ordered(set(nargs)))\n    elif nargs is not None:\n        nargs = (as_int(nargs),)\n    cls._nargs = nargs\n    if len(args) == 3:\n        namespace = args[2]\n        if 'eval' in namespace and (not isinstance(namespace['eval'], classmethod)):\n            raise TypeError('eval on Function subclasses should be a class method (defined with @classmethod)')\n    super().__init__(*args, **kwargs)",
    ".sympy.core.function.py@@arity": "def arity(cls):\n    eval_ = getattr(cls, 'eval', cls)\n    parameters = inspect.signature(eval_).parameters.items()\n    if [p for _, p in parameters if p.kind == p.VAR_POSITIONAL]:\n        return\n    p_or_k = [p for _, p in parameters if p.kind == p.POSITIONAL_OR_KEYWORD]\n    no, yes = map(len, sift(p_or_k, lambda p: p.default == p.empty, binary=True))\n    return no if not yes else tuple(range(no, no + yes + 1))",
    ".sympy.utilities.iterables.py@@is_sequence": "def is_sequence(i, include=None):\n    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))",
    ".sympy.core.assumptions.py@@ManagedProperties.__init__": "def __init__(cls, *args, **kws):\n    BasicMeta.__init__(cls, *args, **kws)\n    local_defs = {}\n    for k in _assume_defined:\n        attrname = as_property(k)\n        v = cls.__dict__.get(attrname, '')\n        if isinstance(v, (bool, int, type(None))):\n            if v is not None:\n                v = bool(v)\n            local_defs[k] = v\n    defs = {}\n    for base in reversed(cls.__bases__):\n        assumptions = getattr(base, '_explicit_class_assumptions', None)\n        if assumptions is not None:\n            defs.update(assumptions)\n    defs.update(local_defs)\n    cls._explicit_class_assumptions = defs\n    cls.default_assumptions = StdFactKB(defs)\n    cls._prop_handler = {}\n    for k in _assume_defined:\n        eval_is_meth = getattr(cls, '_eval_is_%s' % k, None)\n        if eval_is_meth is not None:\n            cls._prop_handler[k] = eval_is_meth\n    for k, v in cls.default_assumptions.items():\n        setattr(cls, as_property(k), v)\n    derived_from_bases = set()\n    for base in cls.__bases__:\n        default_assumptions = getattr(base, 'default_assumptions', None)\n        if default_assumptions is not None:\n            derived_from_bases.update(default_assumptions)\n    for fact in derived_from_bases - set(cls.default_assumptions):\n        pname = as_property(fact)\n        if pname not in cls.__dict__:\n            setattr(cls, pname, make_property(fact))\n    for fact in _assume_defined:\n        pname = as_property(fact)\n        if not hasattr(cls, pname):\n            setattr(cls, pname, make_property(fact))",
    ".sympy.core.core.py@@BasicMeta.__init__": "def __init__(cls, *args, **kws):\n    all_classes.add(cls)\n    cls.__sympy__ = property(lambda self: True)",
    ".sympy.core.function.py@@UndefinedFunction.__hash__": "def __hash__(self):\n    return hash((self.class_key(), frozenset(self._kwargs.items())))",
    ".sympy.core.function.py@@Function.class_key": "def class_key(cls):\n    from sympy.sets.fancysets import Naturals0\n    funcs = {'exp': 10, 'log': 11, 'sin': 20, 'cos': 21, 'tan': 22, 'cot': 23, 'sinh': 30, 'cosh': 31, 'tanh': 32, 'coth': 33, 'conjugate': 40, 're': 41, 'im': 42, 'arg': 43}\n    name = cls.__name__\n    try:\n        i = funcs[name]\n    except KeyError:\n        i = 0 if isinstance(cls.nargs, Naturals0) else 10000\n    return (4, i, name)",
    ".sympy.core.function.py@@FunctionClass.nargs": "def nargs(self):\n    from sympy.sets.sets import FiniteSet\n    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0",
    ".sympy.core.assumptions.py@@as_property": "def as_property(fact):\n    return 'is_%s' % fact"
}