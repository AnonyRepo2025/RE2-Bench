{
    ".sympy.printing.dot.py@@dotnode": "def dotnode(expr, styles=default_styles, labelfunc=str, pos=(), repeat=True):\n    style = styleof(expr, styles)\n    if isinstance(expr, Basic) and (not expr.is_Atom):\n        label = str(expr.__class__.__name__)\n    else:\n        label = labelfunc(expr)\n    style['label'] = label\n    expr_str = purestr(expr)\n    if repeat:\n        expr_str += '_%s' % str(pos)\n    return '\"%s\" [%s];' % (expr_str, attrprint(style))",
    ".sympy.printing.dot.py@@styleof": "def styleof(expr, styles=default_styles):\n    style = dict()\n    for typ, sty in styles:\n        if isinstance(expr, typ):\n            style.update(sty)\n    return style",
    ".sympy.printing.dot.py@@purestr": "def purestr(x, with_args=False):\n    sargs = ()\n    if not isinstance(x, Basic):\n        rv = str(x)\n    elif not x.args:\n        rv = srepr(x)\n    else:\n        args = x.args\n        if isinstance(x, Add) or (isinstance(x, Mul) and x.is_commutative):\n            args = sorted(args, key=default_sort_key)\n        sargs = tuple(map(purestr, args))\n        rv = '%s(%s)' % (type(x).__name__, ', '.join(sargs))\n    if with_args:\n        rv = (rv, sargs)\n    return rv",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.compatibility.py@@default_sort_key": "def default_sort_key(item, order=None):\n    from .singleton import S\n    from .basic import Basic\n    from .sympify import sympify, SympifyError\n    from .compatibility import iterable\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n    if iterable(item, exclude=string_types):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            args = list(item)\n            unordered = False\n        args = [default_sort_key(arg, order=order) for arg in args]\n        if unordered:\n            args = sorted(args)\n        cls_index, args = (10, (len(args), tuple(args)))\n    else:\n        if not isinstance(item, string_types):\n            try:\n                item = sympify(item)\n            except SympifyError:\n                pass\n            else:\n                if isinstance(item, Basic):\n                    return default_sort_key(item)\n        cls_index, args = (0, (1, (str(item),)))\n    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)",
    ".sympy.core.numbers.py@@Number.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (0, ()), (), self)",
    ".sympy.core.numbers.py@@Number.class_key": "def class_key(cls):\n    return (1, 0, 'Number')",
    ".sympy.core.symbol.py@@Symbol.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One)",
    ".sympy.core.basic.py@@Atom.class_key": "def class_key(cls):\n    return (2, 0, cls.__name__)",
    ".sympy.core.basic.py@@Basic.__str__": "def __str__(self):\n    from sympy.printing import sstr\n    return sstr(self, order=None)",
    ".sympy.printing.str.py@@sstr": "def sstr(expr, **settings):\n    p = StrPrinter(settings)\n    s = p.doprint(expr)\n    return s",
    ".sympy.printing.printer.py@@Printer.__init__": "def __init__(self, settings=None):\n    self._str = str\n    self._settings = self._default_settings.copy()\n    self._context = dict()\n    for key, val in self._global_settings.items():\n        if key in self._default_settings:\n            self._settings[key] = val\n    if settings is not None:\n        self._settings.update(settings)\n        if len(self._settings) > len(self._default_settings):\n            for key in self._settings:\n                if key not in self._default_settings:\n                    raise TypeError(\"Unknown setting '%s'.\" % key)\n    self._print_level = 0",
    ".sympy.printing.printer.py@@Printer.doprint": "def doprint(self, expr):\n    return self._str(self._print(expr))",
    ".sympy.printing.printer.py@@Printer._print": "def _print(self, expr, **kwargs):\n    self._print_level += 1\n    try:\n        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):\n            return getattr(expr, self.printmethod)(self, **kwargs)\n        classes = type(expr).__mro__\n        if AppliedUndef in classes:\n            classes = classes[classes.index(AppliedUndef):]\n        if UndefinedFunction in classes:\n            classes = classes[classes.index(UndefinedFunction):]\n        if Function in classes:\n            i = classes.index(Function)\n            classes = tuple((c for c in classes[:i] if c.__name__ == classes[0].__name__ or c.__name__.endswith('Base'))) + classes[i:]\n        for cls in classes:\n            printmethod = '_print_' + cls.__name__\n            if hasattr(self, printmethod):\n                return getattr(self, printmethod)(expr, **kwargs)\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1",
    ".sympy.printing.str.py@@StrPrinter._print_Symbol": "def _print_Symbol(self, expr):\n    return expr.name",
    ".sympy.printing.repr.py@@srepr": "def srepr(expr, **settings):\n    return ReprPrinter(settings).doprint(expr)",
    ".sympy.printing.repr.py@@ReprPrinter._print_Integer": "def _print_Integer(self, expr):\n    return 'Integer(%i)' % expr.p",
    ".sympy.printing.repr.py@@ReprPrinter._print_Symbol": "def _print_Symbol(self, expr):\n    d = expr._assumptions.generator\n    if expr.is_Dummy:\n        d['dummy_index'] = expr.dummy_index\n    if d == {}:\n        return '%s(%s)' % (expr.__class__.__name__, self._print(expr.name))\n    else:\n        attr = ['%s=%s' % (k, v) for k, v in d.items()]\n        return '%s(%s, %s)' % (expr.__class__.__name__, self._print(expr.name), ', '.join(attr))",
    ".sympy.core.assumptions.py@@StdFactKB.generator": "def generator(self):\n    return self._generator.copy()",
    ".sympy.printing.repr.py@@ReprPrinter._print_str": "def _print_str(self, expr):\n    return repr(expr)",
    ".sympy.printing.dot.py@@attrprint": "def attrprint(d, delimiter=', '):\n    return delimiter.join(('\"%s\"=\"%s\"' % item for item in sorted(d.items())))",
    ".sympy.printing.dot.py@@dotedges": "def dotedges(expr, atom=lambda x: not isinstance(x, Basic), pos=(), repeat=True):\n    from sympy.utilities.misc import func_name\n    if atom(expr):\n        return []\n    else:\n        expr_str, arg_strs = purestr(expr, with_args=True)\n        if repeat:\n            expr_str += '_%s' % str(pos)\n            arg_strs = ['%s_%s' % (a, str(pos + (i,))) for i, a in enumerate(arg_strs)]\n        return ['\"%s\" -> \"%s\";' % (expr_str, a) for a in arg_strs]",
    ".sympy.printing.str.py@@StrPrinter._print_Integer": "def _print_Integer(self, expr):\n    if self._settings.get('sympy_integers', False):\n        return 'S(%s)' % expr\n    return str(expr.p)",
    ".sympy.core.expr.py@@Expr.sort_key": "def sort_key(self, order=None):\n    coeff, expr = self.as_coeff_Mul()\n    if expr.is_Pow:\n        expr, exp = expr.args\n    else:\n        expr, exp = (expr, S.One)\n    if expr.is_Dummy:\n        args = (expr.sort_key(),)\n    elif expr.is_Atom:\n        args = (str(expr),)\n    else:\n        if expr.is_Add:\n            args = expr.as_ordered_terms(order=order)\n        elif expr.is_Mul:\n            args = expr.as_ordered_factors(order=order)\n        else:\n            args = expr.args\n        args = tuple([default_sort_key(arg, order=order) for arg in args])\n    args = (len(args), tuple(args))\n    exp = exp.sort_key(order=order)\n    return (expr.class_key(), args, exp, coeff)",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (S.One, self)",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, integer_types):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.numbers.py@@Integer.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s > %s' % (self, other))\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    if evaluate is None:\n        if global_evaluate[0] is False:\n            evaluate = global_evaluate[0]\n        else:\n            evaluate = True\n    try:\n        if a in sympy_classes:\n            return a\n    except TypeError:\n        pass\n    cls = getattr(a, '__class__', None)\n    if cls is None:\n        cls = type(a)\n    if cls in sympy_classes:\n        return a\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if type(a).__module__ == 'numpy':\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    try:\n        return converter[cls](a)\n    except KeyError:\n        for superclass in getmro(cls):\n            try:\n                return converter[superclass](a)\n            except KeyError:\n                continue\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from ..tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                coerced = coerce(a)\n            except (TypeError, ValueError):\n                continue\n            except AttributeError:\n                continue\n            try:\n                return sympify(coerced)\n            except SympifyError:\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.logic.boolalg.py@@BooleanFalse.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.core.mul.py@@Mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return (coeff, args[0])\n            else:\n                return (coeff, self._new_rawargs(*args))\n        elif coeff.is_negative:\n            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))\n    return (S.One, self)"
}