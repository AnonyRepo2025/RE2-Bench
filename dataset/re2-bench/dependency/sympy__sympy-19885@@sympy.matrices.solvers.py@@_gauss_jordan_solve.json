{
    ".sympy.matrices.matrices.py@@MatrixBase.copy": "def copy(self):\n    return self._new(self.rows, self.cols, self._mat)",
    ".sympy.matrices.dense.py@@MutableDenseMatrix._new": "def _new(cls, *args, **kwargs):\n    if kwargs.get('copy', True) is False:\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list)\n    self = object.__new__(cls)\n    self.rows = rows\n    self.cols = cols\n    self._mat = flat_list\n    return self",
    ".sympy.matrices.matrices.py@@MatrixBase._handle_creation_inputs": "def _handle_creation_inputs(cls, *args, **kwargs):\n    from sympy.matrices.sparse import SparseMatrix\n    from sympy.matrices.expressions.matexpr import MatrixSymbol\n    from sympy.matrices.expressions.blockmatrix import BlockMatrix\n    from sympy.utilities.iterables import reshape\n    flat_list = None\n    if len(args) == 1:\n        if isinstance(args[0], SparseMatrix):\n            return (args[0].rows, args[0].cols, flatten(args[0].tolist()))\n        elif isinstance(args[0], MatrixBase):\n            return (args[0].rows, args[0].cols, args[0]._mat)\n        elif isinstance(args[0], Basic) and args[0].is_Matrix:\n            return (args[0].rows, args[0].cols, args[0].as_explicit()._mat)\n        elif isinstance(args[0], mp.matrix):\n            M = args[0]\n            flat_list = [cls._sympify(x) for x in M]\n            return (M.rows, M.cols, flat_list)\n        elif hasattr(args[0], '__array__'):\n            return cls._handle_ndarray(args[0])\n        elif is_sequence(args[0]) and (not isinstance(args[0], DeferredVector)):\n            dat = list(args[0])\n            ismat = lambda i: isinstance(i, MatrixBase) and (evaluate or isinstance(i, BlockMatrix) or isinstance(i, MatrixSymbol))\n            raw = lambda i: is_sequence(i) and (not ismat(i))\n            evaluate = kwargs.get('evaluate', True)\n            if evaluate:\n\n                def do(x):\n                    if isinstance(x, (list, tuple)):\n                        return type(x)([do(i) for i in x])\n                    if isinstance(x, BlockMatrix) or (isinstance(x, MatrixSymbol) and all((_.is_Integer for _ in x.shape))):\n                        return x.as_explicit()\n                    return x\n                dat = do(dat)\n            if dat == [] or dat == [[]]:\n                rows = cols = 0\n                flat_list = []\n            elif not any((raw(i) or ismat(i) for i in dat)):\n                flat_list = [cls._sympify(i) for i in dat]\n                rows = len(flat_list)\n                cols = 1 if rows else 0\n            elif evaluate and all((ismat(i) for i in dat)):\n                ncol = {i.cols for i in dat if any(i.shape)}\n                if ncol:\n                    if len(ncol) != 1:\n                        raise ValueError('mismatched dimensions')\n                    flat_list = [_ for i in dat for r in i.tolist() for _ in r]\n                    cols = ncol.pop()\n                    rows = len(flat_list) // cols\n                else:\n                    rows = cols = 0\n                    flat_list = []\n            elif evaluate and any((ismat(i) for i in dat)):\n                ncol = set()\n                flat_list = []\n                for i in dat:\n                    if ismat(i):\n                        flat_list.extend([k for j in i.tolist() for k in j])\n                        if any(i.shape):\n                            ncol.add(i.cols)\n                    elif raw(i):\n                        if i:\n                            ncol.add(len(i))\n                            flat_list.extend(i)\n                    else:\n                        ncol.add(1)\n                        flat_list.append(i)\n                    if len(ncol) > 1:\n                        raise ValueError('mismatched dimensions')\n                cols = ncol.pop()\n                rows = len(flat_list) // cols\n            else:\n                flat_list = []\n                ncol = set()\n                rows = cols = 0\n                for row in dat:\n                    if not is_sequence(row) and (not getattr(row, 'is_Matrix', False)):\n                        raise ValueError('expecting list of lists')\n                    if hasattr(row, '__array__'):\n                        if 0 in row.shape:\n                            continue\n                    elif not row:\n                        continue\n                    if evaluate and all((ismat(i) for i in row)):\n                        r, c, flatT = cls._handle_creation_inputs([i.T for i in row])\n                        T = reshape(flatT, [c])\n                        flat = [T[i][j] for j in range(c) for i in range(r)]\n                        r, c = (c, r)\n                    else:\n                        r = 1\n                        if getattr(row, 'is_Matrix', False):\n                            c = 1\n                            flat = [row]\n                        else:\n                            c = len(row)\n                            flat = [cls._sympify(i) for i in row]\n                    ncol.add(c)\n                    if len(ncol) > 1:\n                        raise ValueError('mismatched dimensions')\n                    flat_list.extend(flat)\n                    rows += r\n                cols = ncol.pop() if ncol else 0\n    elif len(args) == 3:\n        rows = as_int(args[0])\n        cols = as_int(args[1])\n        if rows < 0 or cols < 0:\n            raise ValueError('Cannot create a {} x {} matrix. Both dimensions must be positive'.format(rows, cols))\n        if len(args) == 3 and isinstance(args[2], Callable):\n            op = args[2]\n            flat_list = []\n            for i in range(rows):\n                flat_list.extend([cls._sympify(op(cls._sympify(i), cls._sympify(j))) for j in range(cols)])\n        elif len(args) == 3 and is_sequence(args[2]):\n            flat_list = args[2]\n            if len(flat_list) != rows * cols:\n                raise ValueError('List length should be equal to rows*columns')\n            flat_list = [cls._sympify(i) for i in flat_list]\n    elif len(args) == 0:\n        rows = cols = 0\n        flat_list = []\n    if flat_list is None:\n        raise TypeError(filldedent('\\n            Data type not understood; expecting list of lists\\n            or lists of values.'))\n    return (rows, cols, flat_list)",
    ".sympy.core.compatibility.py@@as_int": "def as_int(n, strict=True):\n    if strict:\n        try:\n            if type(n) is bool:\n                raise TypeError\n            return operator.index(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n != result:\n            raise ValueError('%s is not an integer' % (n,))\n        return result",
    ".sympy.core.compatibility.py@@is_sequence": "def is_sequence(i, include=None):\n    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))",
    ".sympy.core.compatibility.py@@iterable": "def iterable(i, exclude=(str, dict, NotIterable)):\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is not None:\n        return a\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    cls = getattr(a, '__class__', None)\n    if cls is None:\n        cls = type(a)\n    conv = converter.get(cls, None)\n    if conv is not None:\n        return conv(a)\n    for superclass in getmro(cls):\n        try:\n            return converter[superclass](a)\n        except KeyError:\n            continue\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from ..tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(), locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        else:\n            for coerce in (float, int):\n                try:\n                    return sympify(coerce(a))\n                except (TypeError, ValueError, AttributeError, SympifyError):\n                    continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    if not isinstance(a, str):\n        try:\n            a = str(a)\n        except Exception as exc:\n            raise SympifyError(a, exc)\n        from sympy.utilities.exceptions import SymPyDeprecationWarning\n        SymPyDeprecationWarning(feature='String fallback in sympify', useinstead='sympify(str(obj)) or ' + 'sympy.core.sympify.converter or obj._sympy_', issue=18066, deprecated_since_version='1.6').warn()\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.matrices.common.py@@MatrixShaping.hstack": "def hstack(cls, *args):\n    if len(args) == 0:\n        return cls._new()\n    kls = type(args[0])\n    return reduce(kls.row_join, args)",
    ".sympy.matrices.common.py@@MatrixShaping.row_join": "def row_join(self, other):\n    if self.cols == 0 and self.rows != other.rows:\n        return self._new(other.rows, 0, []).row_join(other)\n    if self.rows != other.rows:\n        raise ShapeError('`self` and `rhs` must have the same number of rows.')\n    return self._eval_row_join(other)",
    ".sympy.matrices.common.py@@MatrixShaping._eval_row_join": "def _eval_row_join(self, other):\n    cols = self.cols\n\n    def entry(i, j):\n        if j < cols:\n            return self[i, j]\n        return other[i, j - cols]\n    return classof(self, other)._new(self.rows, self.cols + other.cols, lambda i, j: entry(i, j))",
    ".sympy.matrices.common.py@@classof": "def classof(A, B):\n    priority_A = getattr(A, '_class_priority', None)\n    priority_B = getattr(B, '_class_priority', None)\n    if None not in (priority_A, priority_B):\n        if A._class_priority > B._class_priority:\n            return A.__class__\n        else:\n            return B.__class__\n    try:\n        import numpy\n    except ImportError:\n        pass\n    else:\n        if isinstance(A, numpy.ndarray):\n            return B.__class__\n        if isinstance(B, numpy.ndarray):\n            return A.__class__\n    raise TypeError('Incompatible classes %s, %s' % (A.__class__, B.__class__))",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, str):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    if ival == 1:\n        return S.One\n    if ival == -1:\n        return S.NegativeOne\n    if ival == 0:\n        return S.Zero\n    obj = Expr.__new__(cls)\n    obj.p = ival\n    return obj",
    ".sympy.matrices.common.py@@MatrixShaping.entry": "def entry(n, _):\n    j = n // rows\n    i = n - j * rows\n    return self[i, j]",
    ".sympy.core.numbers.py@@Integer.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.logic.boolalg.py@@BooleanTrue.__nonzero__": "def __nonzero__(self):\n    return True",
    ".sympy.matrices.dense.py@@DenseMatrix.__getitem__": "def __getitem__(self, key):\n    if isinstance(key, tuple):\n        i, j = key\n        try:\n            i, j = self.key2ij(key)\n            return self._mat[i * self.cols + j]\n        except (TypeError, IndexError):\n            if isinstance(i, Expr) and (not i.is_number) or (isinstance(j, Expr) and (not j.is_number)):\n                if (j < 0) is True or (j >= self.shape[1]) is True or (i < 0) is True or ((i >= self.shape[0]) is True):\n                    raise ValueError('index out of boundary')\n                from sympy.matrices.expressions.matexpr import MatrixElement\n                return MatrixElement(self, i, j)\n            if isinstance(i, slice):\n                i = range(self.rows)[i]\n            elif is_sequence(i):\n                pass\n            else:\n                i = [i]\n            if isinstance(j, slice):\n                j = range(self.cols)[j]\n            elif is_sequence(j):\n                pass\n            else:\n                j = [j]\n            return self.extract(i, j)\n    else:\n        if isinstance(key, slice):\n            return self._mat[key]\n        return self._mat[a2idx(key)]",
    ".sympy.matrices.matrices.py@@MatrixBase.key2ij": "def key2ij(self, key):\n    from sympy.matrices.common import a2idx as a2idx_\n    if is_sequence(key):\n        if not len(key) == 2:\n            raise TypeError('key must be a sequence of length 2')\n        return [a2idx_(i, n) if not isinstance(i, slice) else i for i, n in zip(key, self.shape)]\n    elif isinstance(key, slice):\n        return key.indices(len(self))[:2]\n    else:\n        return divmod(a2idx_(key, len(self)), self.cols)",
    ".sympy.matrices.common.py@@MatrixShaping.shape": "def shape(self):\n    return (self.rows, self.cols)",
    ".sympy.matrices.common.py@@a2idx": "def a2idx(j, n=None):\n    if type(j) is not int:\n        jindex = getattr(j, '__index__', None)\n        if jindex is not None:\n            j = jindex()\n        else:\n            raise IndexError('Invalid index a[%r]' % (j,))\n    if n is not None:\n        if j < 0:\n            j += n\n        if not (j >= 0 and j < n):\n            raise IndexError('Index out of range: a[%s]' % (j,))\n    return int(j)",
    ".sympy.core.numbers.py@@Integer.__index__": "def __index__(self):\n    return self.p",
    ".sympy.logic.boolalg.py@@BooleanFalse.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.core.numbers.py@@Integer.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    ".sympy.matrices.common.py@@MatrixShaping.extract": "def extract(self, rowsList, colsList):\n    if not is_sequence(rowsList) or not is_sequence(colsList):\n        raise TypeError('rowsList and colsList must be iterable')\n    if rowsList and all((isinstance(i, bool) for i in rowsList)):\n        rowsList = [index for index, item in enumerate(rowsList) if item]\n    if colsList and all((isinstance(i, bool) for i in colsList)):\n        colsList = [index for index, item in enumerate(colsList) if item]\n    rowsList = [a2idx(k, self.rows) for k in rowsList]\n    colsList = [a2idx(k, self.cols) for k in colsList]\n    return self._eval_extract(rowsList, colsList)",
    ".sympy.matrices.dense.py@@DenseMatrix._eval_extract": "def _eval_extract(self, rowsList, colsList):\n    mat = self._mat\n    cols = self.cols\n    indices = (i * cols + j for i in rowsList for j in colsList)\n    return self._new(len(rowsList), len(colsList), list((mat[i] for i in indices)), copy=False)",
    ".sympy.matrices.matrices.py@@MatrixReductions.rref": "def rref(self, iszerofunc=_iszero, simplify=False, pivots=True, normalize_last=True):\n    return _rref(self, iszerofunc=iszerofunc, simplify=simplify, pivots=pivots, normalize_last=normalize_last)",
    ".sympy.matrices.reductions.py@@_rref": "def _rref(M, iszerofunc=_iszero, simplify=False, pivots=True, normalize_last=True):\n    simpfunc = simplify if isinstance(simplify, FunctionType) else _simplify\n    mat, pivot_cols, _ = _row_reduce(M, iszerofunc, simpfunc, normalize_last, normalize=True, zero_above=True)\n    if pivots:\n        mat = (mat, pivot_cols)\n    return mat",
    ".sympy.matrices.reductions.py@@_row_reduce": "def _row_reduce(M, iszerofunc, simpfunc, normalize_last=True, normalize=True, zero_above=True):\n    mat, pivot_cols, swaps = _row_reduce_list(list(M), M.rows, M.cols, M.one, iszerofunc, simpfunc, normalize_last=normalize_last, normalize=normalize, zero_above=zero_above)\n    return (M._new(M.rows, M.cols, mat), pivot_cols, swaps)",
    ".sympy.matrices.matrices.py@@MatrixBase.__len__": "def __len__(self):\n    return self.rows * self.cols",
    ".sympy.matrices.reductions.py@@_row_reduce_list": "def _row_reduce_list(mat, rows, cols, one, iszerofunc, simpfunc, normalize_last=True, normalize=True, zero_above=True):\n\n    def get_col(i):\n        return mat[i::cols]\n\n    def row_swap(i, j):\n        mat[i * cols:(i + 1) * cols], mat[j * cols:(j + 1) * cols] = (mat[j * cols:(j + 1) * cols], mat[i * cols:(i + 1) * cols])\n\n    def cross_cancel(a, i, b, j):\n        q = (j - i) * cols\n        for p in range(i * cols, (i + 1) * cols):\n            mat[p] = isimp(a * mat[p] - b * mat[p + q])\n    isimp = _get_intermediate_simp(_dotprodsimp)\n    piv_row, piv_col = (0, 0)\n    pivot_cols = []\n    swaps = []\n    while piv_col < cols and piv_row < rows:\n        pivot_offset, pivot_val, assumed_nonzero, newly_determined = _find_reasonable_pivot(get_col(piv_col)[piv_row:], iszerofunc, simpfunc)\n        for offset, val in newly_determined:\n            offset += piv_row\n            mat[offset * cols + piv_col] = val\n        if pivot_offset is None:\n            piv_col += 1\n            continue\n        pivot_cols.append(piv_col)\n        if pivot_offset != 0:\n            row_swap(piv_row, pivot_offset + piv_row)\n            swaps.append((piv_row, pivot_offset + piv_row))\n        if normalize_last is False:\n            i, j = (piv_row, piv_col)\n            mat[i * cols + j] = one\n            for p in range(i * cols + j + 1, (i + 1) * cols):\n                mat[p] = isimp(mat[p] / pivot_val)\n            pivot_val = one\n        for row in range(rows):\n            if row == piv_row:\n                continue\n            if zero_above is False and row < piv_row:\n                continue\n            val = mat[row * cols + piv_col]\n            if iszerofunc(val):\n                continue\n            cross_cancel(pivot_val, row, val, piv_row)\n        piv_row += 1\n    if normalize_last is True and normalize is True:\n        for piv_i, piv_j in enumerate(pivot_cols):\n            pivot_val = mat[piv_i * cols + piv_j]\n            mat[piv_i * cols + piv_j] = one\n            for p in range(piv_i * cols + piv_j + 1, (piv_i + 1) * cols):\n                mat[p] = isimp(mat[p] / pivot_val)\n    return (mat, tuple(pivot_cols), tuple(swaps))",
    ".sympy.matrices.utilities.py@@_get_intermediate_simp": "def _get_intermediate_simp(deffunc=lambda x: x, offfunc=lambda x: x, onfunc=_dotprodsimp, dotprodsimp=None):\n    if dotprodsimp is False or _dotprodsimp_state.state is False:\n        return offfunc\n    if dotprodsimp is True or _dotprodsimp_state.state is True:\n        return onfunc\n    return deffunc",
    ".sympy.matrices.reductions.py@@get_col": "def get_col(i):\n    return mat[i::cols]",
    ".sympy.matrices.determinant.py@@_find_reasonable_pivot": "def _find_reasonable_pivot(col, iszerofunc=_iszero, simpfunc=_simplify):\n    newly_determined = []\n    col = list(col)\n    if all((isinstance(x, (Float, Integer)) for x in col)) and any((isinstance(x, Float) for x in col)):\n        col_abs = [abs(x) for x in col]\n        max_value = max(col_abs)\n        if iszerofunc(max_value):\n            if max_value != 0:\n                newly_determined = [(i, 0) for i, x in enumerate(col) if x != 0]\n            return (None, None, False, newly_determined)\n        index = col_abs.index(max_value)\n        return (index, col[index], False, newly_determined)\n    possible_zeros = []\n    for i, x in enumerate(col):\n        is_zero = iszerofunc(x)\n        if is_zero == False:\n            return (i, x, False, newly_determined)\n        possible_zeros.append(is_zero)\n    if all(possible_zeros):\n        return (None, None, False, newly_determined)\n    for i, x in enumerate(col):\n        if possible_zeros[i] is not None:\n            continue\n        simped = simpfunc(x)\n        is_zero = iszerofunc(simped)\n        if is_zero == True or is_zero == False:\n            newly_determined.append((i, simped))\n        if is_zero == False:\n            return (i, simped, False, newly_determined)\n        possible_zeros[i] = is_zero\n    if all(possible_zeros):\n        return (None, None, False, newly_determined)\n    for i, x in enumerate(col):\n        if possible_zeros[i] is not None:\n            continue\n        if x.equals(S.Zero):\n            possible_zeros[i] = True\n            newly_determined.append((i, S.Zero))\n    if all(possible_zeros):\n        return (None, None, False, newly_determined)\n    i = possible_zeros.index(None)\n    return (i, col[i], True, newly_determined)",
    ".sympy.matrices.utilities.py@@_iszero": "def _iszero(x):\n    return getattr(x, 'is_zero', None)",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.assumptions.py@@StdFactKB.copy": "def copy(self):\n    return self.__class__(self)",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    super().__init__(_assume_rules)\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.__init__": "def __init__(self, rules):\n    self.rules = rules",
    ".sympy.core.assumptions.py@@_ask": "def _ask(fact, obj):\n    assumptions = obj._assumptions\n    handler_map = obj._prop_handler\n    assumptions._tell(fact, None)\n    try:\n        evaluate = handler_map[fact]\n    except KeyError:\n        pass\n    else:\n        a = evaluate(obj)\n        if a is not None:\n            assumptions.deduce_all_facts(((fact, a),))\n            return a\n    prereq = list(_assume_rules.prereq[fact])\n    shuffle(prereq)\n    for pk in prereq:\n        if pk in assumptions:\n            continue\n        if pk in handler_map:\n            _ask(pk, obj)\n            ret_val = assumptions.get(fact)\n            if ret_val is not None:\n                return ret_val\n    return None",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.add.py@@Add._eval_is_zero": "def _eval_is_zero(self):\n    if self.is_commutative is False:\n        return\n    nz = []\n    z = 0\n    im_or_z = False\n    im = False\n    for a in self.args:\n        if a.is_extended_real:\n            if a.is_zero:\n                z += 1\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im = True\n        elif (S.ImaginaryUnit * a).is_extended_real:\n            im_or_z = True\n        else:\n            return\n    if z == len(self.args):\n        return True\n    if len(nz) == 0 or len(nz) == len(self.args):\n        return None\n    b = self.func(*nz)\n    if b.is_zero:\n        if not im_or_z and (not im):\n            return True\n        if im and (not im_or_z):\n            return False\n    if b.is_zero is False:\n        return False",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.mul.py@@Mul._eval_is_extended_real": "def _eval_is_extended_real(self):\n    return self._eval_real_imag(True)",
    ".sympy.core.mul.py@@Mul._eval_real_imag": "def _eval_real_imag(self, real):\n    zero = False\n    t_not_re_im = None\n    for t in self.args:\n        if (t.is_complex or t.is_infinite) is False and t.is_extended_real is False:\n            return False\n        elif t.is_imaginary:\n            real = not real\n        elif t.is_extended_real:\n            if not zero:\n                z = t.is_zero\n                if not z and zero is False:\n                    zero = z\n                elif z:\n                    if all((a.is_finite for a in self.args)):\n                        return True\n                    return\n        elif t.is_extended_real is False:\n            if t_not_re_im:\n                return\n            t_not_re_im = t\n        elif t.is_imaginary is False:\n            if t_not_re_im:\n                return\n            t_not_re_im = t\n        else:\n            return\n    if t_not_re_im:\n        if t_not_re_im.is_extended_real is False:\n            if real:\n                return zero\n        if t_not_re_im.is_imaginary is False:\n            if not real:\n                return zero\n    elif zero is False:\n        return real\n    elif real:\n        return real",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.mul.py@@Mul._eval_is_imaginary": "def _eval_is_imaginary(self):\n    z = self.is_zero\n    if z:\n        return False\n    if self.is_finite is False:\n        return False\n    elif z is False and self.is_finite is True:\n        return self._eval_real_imag(False)",
    ".sympy.core.mul.py@@Mul._eval_is_finite": "def _eval_is_finite(self):\n    if all((a.is_finite for a in self.args)):\n        return True\n    if any((a.is_infinite for a in self.args)):\n        if all((a.is_zero is False for a in self.args)):\n            return False",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, **options):\n    from sympy import Order\n    args = list(map(_sympify, args))\n    typ = cls._args_type\n    if typ is not None:\n        from sympy.core.relational import Relational\n        if any((isinstance(arg, Relational) for arg in args)):\n            raise TypeError('Relational can not be used in %s' % cls.__name__)\n        if not all((isinstance(arg, typ) for arg in args)):\n            SymPyDeprecationWarning(feature='Add/Mul with non-Expr args', useinstead='Expr args', issue=19445, deprecated_since_version='1.7').warn()\n    evaluate = options.get('evaluate')\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if not evaluate:\n        obj = cls._from_args(args)\n        obj = cls._exec_constructor_postprocessors(obj)\n        return obj\n    args = [a for a in args if a is not cls.identity]\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if order_symbols is not None:\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.matrices.reductions.py@@cross_cancel": "def cross_cancel(a, i, b, j):\n    q = (j - i) * cols\n    for p in range(i * cols, (i + 1) * cols):\n        mat[p] = isimp(a * mat[p] - b * mat[p + q])",
    ".sympy.core.decorators.py@@__sympifyit_wrapper": "def __sympifyit_wrapper(a, b):\n    try:\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    ".sympy.core.numbers.py@@Rational.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))\n        elif isinstance(other, Float):\n            return other * self\n        else:\n            return Number.__mul__(self, other)\n    return Number.__mul__(self, other)",
    ".sympy.core.numbers.py@@Number.__mul__": "def __mul__(self, other):\n    if isinstance(other, Number) and global_parameters.evaluate:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.Infinity\n            else:\n                return S.NegativeInfinity\n        elif other is S.NegativeInfinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.NegativeInfinity\n            else:\n                return S.Infinity\n    elif isinstance(other, Tuple):\n        return NotImplemented\n    return AtomicExpr.__mul__(self, other)",
    ".sympy.core.decorators.py@@_SympifyWrapper._func": "def _func(self, other):\n    if not hasattr(other, '_op_priority'):\n        try:\n            other = sympify(other, strict=True)\n        except SympifyError:\n            return retval\n    if not isinstance(other, expectedcls):\n        return retval\n    return func(self, other)",
    ".sympy.core.decorators.py@@binary_op_wrapper": "def binary_op_wrapper(self, other):\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:\n            f = getattr(other, method_name, None)\n            if f is not None:\n                return f(self)\n    return func(self, other)",
    ".sympy.core.expr.py@@Expr.__mul__": "def __mul__(self, other):\n    return Mul(self, other)",
    ".sympy.core.mul.py@@Mul.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n            seq = [a, b]\n        assert not a is S.One\n        if not a.is_zero and a.is_Rational:\n            r, b = b.as_coeff_Mul()\n            if b.is_Add:\n                if r is not S.One:\n                    ar = a * r\n                    if ar is S.One:\n                        arb = b\n                    else:\n                        arb = cls(a * r, b, evaluate=False)\n                    rv = ([arb], [], None)\n                elif global_parameters.distribute and b.is_commutative:\n                    r, b = b.as_coeff_Add()\n                    bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n                    _addsort(bargs)\n                    ar = a * r\n                    if ar:\n                        bargs.insert(0, ar)\n                    bargs = [Add._from_args(bargs)]\n                    rv = (bargs, [], None)\n        if rv:\n            return rv\n    c_part = []\n    nc_part = []\n    nc_seq = []\n    coeff = S.One\n    c_powers = []\n    num_exp = []\n    neg1e = S.Zero\n    pnum_rat = {}\n    order_symbols = None\n    for o in seq:\n        if o.is_Order:\n            o, order_symbols = o.as_expr_variables(order_symbols)\n        if o.is_Mul:\n            if o.is_commutative:\n                seq.extend(o.args)\n            else:\n                for q in o.args:\n                    if q.is_commutative:\n                        seq.append(q)\n                    else:\n                        nc_seq.append(q)\n                seq.append(NC_Marker)\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_zero):\n                return ([S.NaN], [], None)\n            elif coeff.is_Number or isinstance(coeff, AccumBounds):\n                coeff *= o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__mul__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if not coeff:\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o is S.ImaginaryUnit:\n            neg1e += S.Half\n            continue\n        elif o.is_commutative:\n            b, e = o.as_base_exp()\n            if o.is_Pow:\n                if b.is_Number:\n                    if e.is_Rational:\n                        if e.is_Integer:\n                            coeff *= Pow(b, e)\n                            continue\n                        elif e.is_negative:\n                            seq.append(Pow(b, e))\n                            continue\n                        elif b.is_negative:\n                            neg1e += e\n                            b = -b\n                        if b is not S.One:\n                            pnum_rat.setdefault(b, []).append(e)\n                        continue\n                    elif b.is_positive or e.is_integer:\n                        num_exp.append((b, e))\n                        continue\n            c_powers.append((b, e))\n        else:\n            if o is not NC_Marker:\n                nc_seq.append(o)\n            while nc_seq:\n                o = nc_seq.pop(0)\n                if not nc_part:\n                    nc_part.append(o)\n                    continue\n                o1 = nc_part.pop()\n                b1, e1 = o1.as_base_exp()\n                b2, e2 = o.as_base_exp()\n                new_exp = e1 + e2\n                if b1 == b2 and (not new_exp.is_Add):\n                    o12 = b1 ** new_exp\n                    if o12.is_commutative:\n                        seq.append(o12)\n                        continue\n                    else:\n                        nc_seq.insert(0, o12)\n                else:\n                    nc_part.append(o1)\n                    nc_part.append(o)\n\n    def _gather(c_powers):\n        common_b = {}\n        for b, e in c_powers:\n            co = e.as_coeff_Mul()\n            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n        for b, d in common_b.items():\n            for di, li in d.items():\n                d[di] = Add(*li)\n        new_c_powers = []\n        for b, e in common_b.items():\n            new_c_powers.extend([(b, c * t) for t, c in e.items()])\n        return new_c_powers\n    c_powers = _gather(c_powers)\n    num_exp = _gather(num_exp)\n    for i in range(2):\n        new_c_powers = []\n        changed = False\n        for b, e in c_powers:\n            if e.is_zero:\n                if (b.is_Add or b.is_Mul) and any((infty in b.args for infty in (S.ComplexInfinity, S.Infinity, S.NegativeInfinity))):\n                    return ([S.NaN], [], None)\n                continue\n            if e is S.One:\n                if b.is_Number:\n                    coeff *= b\n                    continue\n                p = b\n            if e is not S.One:\n                p = Pow(b, e)\n                if p.is_Pow and (not b.is_Pow):\n                    bi = b\n                    b, e = p.as_base_exp()\n                    if b != bi:\n                        changed = True\n            c_part.append(p)\n            new_c_powers.append((b, e))\n        if changed and len({b for b, e in new_c_powers}) != len(new_c_powers):\n            c_part = []\n            c_powers = _gather(new_c_powers)\n        else:\n            break\n    inv_exp_dict = {}\n    for b, e in num_exp:\n        inv_exp_dict.setdefault(e, []).append(b)\n    for e, b in inv_exp_dict.items():\n        inv_exp_dict[e] = cls(*b)\n    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n    comb_e = {}\n    for b, e in pnum_rat.items():\n        comb_e.setdefault(Add(*e), []).append(b)\n    del pnum_rat\n    num_rat = []\n    for e, b in comb_e.items():\n        b = cls(*b)\n        if e.q == 1:\n            coeff *= Pow(b, e)\n            continue\n        if e.p > e.q:\n            e_i, ep = divmod(e.p, e.q)\n            coeff *= Pow(b, e_i)\n            e = Rational(ep, e.q)\n        num_rat.append((b, e))\n    del comb_e\n    pnew = defaultdict(list)\n    i = 0\n    while i < len(num_rat):\n        bi, ei = num_rat[i]\n        grow = []\n        for j in range(i + 1, len(num_rat)):\n            bj, ej = num_rat[j]\n            g = bi.gcd(bj)\n            if g is not S.One:\n                e = ei + ej\n                if e.q == 1:\n                    coeff *= Pow(g, e)\n                else:\n                    if e.p > e.q:\n                        e_i, ep = divmod(e.p, e.q)\n                        coeff *= Pow(g, e_i)\n                        e = Rational(ep, e.q)\n                    grow.append((g, e))\n                num_rat[j] = (bj / g, ej)\n                bi = bi / g\n                if bi is S.One:\n                    break\n        if bi is not S.One:\n            obj = Pow(bi, ei)\n            if obj.is_Number:\n                coeff *= obj\n            else:\n                for obj in Mul.make_args(obj):\n                    if obj.is_Number:\n                        coeff *= obj\n                    else:\n                        assert obj.is_Pow\n                        bi, ei = obj.args\n                        pnew[ei].append(bi)\n        num_rat.extend(grow)\n        i += 1\n    for e, b in pnew.items():\n        pnew[e] = cls(*b)\n    if neg1e:\n        p, q = neg1e.as_numer_denom()\n        n, p = divmod(p, q)\n        if n % 2:\n            coeff = -coeff\n        if q == 2:\n            c_part.append(S.ImaginaryUnit)\n        elif p:\n            neg1e = Rational(p, q)\n            for e, b in pnew.items():\n                if e == neg1e and b.is_positive:\n                    pnew[e] = -b\n                    break\n            else:\n                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n    c_part.extend([Pow(b, e) for e, b in pnew.items()])\n    if coeff is S.Infinity or coeff is S.NegativeInfinity:\n\n        def _handle_for_oo(c_part, coeff_sign):\n            new_c_part = []\n            for t in c_part:\n                if t.is_extended_positive:\n                    continue\n                if t.is_extended_negative:\n                    coeff_sign *= -1\n                    continue\n                new_c_part.append(t)\n            return (new_c_part, coeff_sign)\n        c_part, coeff_sign = _handle_for_oo(c_part, 1)\n        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n        coeff *= coeff_sign\n    if coeff is S.ComplexInfinity:\n        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]\n        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_extended_real is not None)]\n    elif coeff.is_zero:\n        if any((isinstance(c, MatrixExpr) for c in nc_part)):\n            return ([coeff], nc_part, order_symbols)\n        if any((c.is_finite == False for c in c_part)):\n            return ([S.NaN], [], order_symbols)\n        return ([coeff], [], order_symbols)\n    _new = []\n    for i in c_part:\n        if i.is_Number:\n            coeff *= i\n        else:\n            _new.append(i)\n    c_part = _new\n    _mulsort(c_part)\n    if coeff is not S.One:\n        c_part.insert(0, coeff)\n    if global_parameters.distribute and (not nc_part) and (len(c_part) == 2) and c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add:\n        coeff = c_part[0]\n        c_part = [Add(*[coeff * f for f in c_part[1].args])]\n    return (c_part, nc_part, order_symbols)",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (S.One, self)",
    ".sympy.core.add.py@@Add.as_coeff_Add": "def as_coeff_Add(self, rational=False, deps=None):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number and (not rational) or coeff.is_Rational:\n        return (coeff, self._new_rawargs(*args))\n    return (S.Zero, self)",
    ".sympy.core.operations.py@@AssocOp._new_rawargs": "def _new_rawargs(self, *args, **kwargs):\n    if kwargs.pop('reeval', True) and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)",
    ".sympy.core.operations.py@@AssocOp._from_args": "def _from_args(cls, args, is_commutative=None):\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n    obj = super().__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and((a.is_commutative for a in args))\n    obj.is_commutative = is_commutative\n    return obj",
    ".sympy.core.operations.py@@AssocOp.make_args": "def make_args(cls, expr):\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    ".sympy.core.mul.py@@_keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = (coeff, factors)\n        else:\n            return coeff * factors\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and (not sign):\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and (coeff.q != 1):\n            q = S(coeff.q)\n            for i in factors.args:\n                c, t = i.as_coeff_Mul()\n                r = c / q\n                if r == int(r):\n                    return coeff * factors\n        return Mul(coeff, factors, evaluate=False)\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        return coeff * factors",
    ".sympy.core.numbers.py@@igcd": "def igcd(*args):\n    if len(args) < 2:\n        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))\n    args_temp = [abs(as_int(i)) for i in args]\n    if 1 in args_temp:\n        return 1\n    a = args_temp.pop()\n    if HAS_GMPY:\n        for b in args_temp:\n            a = gmpy.gcd(a, b) if b else a\n        return as_int(a)\n    for b in args_temp:\n        a = igcd2(a, b) if b else a\n    return a",
    ".sympy.core.numbers.py@@Rational.__new__": "def __new__(cls, p, q=None, gcd=None):\n    if q is None:\n        if isinstance(p, Rational):\n            return p\n        if isinstance(p, SYMPY_INTS):\n            pass\n        else:\n            if isinstance(p, (float, Float)):\n                return Rational(*_as_integer_ratio(p))\n            if not isinstance(p, str):\n                try:\n                    p = sympify(p)\n                except (SympifyError, SyntaxError):\n                    pass\n            else:\n                if p.count('/') > 1:\n                    raise TypeError('invalid input: %s' % p)\n                p = p.replace(' ', '')\n                pq = p.rsplit('/', 1)\n                if len(pq) == 2:\n                    p, q = pq\n                    fp = fractions.Fraction(p)\n                    fq = fractions.Fraction(q)\n                    p = fp / fq\n                try:\n                    p = fractions.Fraction(p)\n                except ValueError:\n                    pass\n                else:\n                    return Rational(p.numerator, p.denominator, 1)\n            if not isinstance(p, Rational):\n                raise TypeError('invalid input: %s' % p)\n        q = 1\n        gcd = 1\n    else:\n        p = Rational(p)\n        q = Rational(q)\n    if isinstance(q, Rational):\n        p *= q.q\n        q = q.p\n    if isinstance(p, Rational):\n        q *= p.q\n        p = p.p\n    if q == 0:\n        if p == 0:\n            if _errdict['divide']:\n                raise ValueError('Indeterminate 0/0')\n            else:\n                return S.NaN\n        return S.ComplexInfinity\n    if q < 0:\n        q = -q\n        p = -p\n    if not gcd:\n        gcd = igcd(abs(p), q)\n    if gcd > 1:\n        p //= gcd\n        q //= gcd\n    if q == 1:\n        return Integer(p)\n    if p == 1 and q == 2:\n        return S.Half\n    obj = Expr.__new__(cls)\n    obj.p = p\n    obj.q = q\n    return obj",
    ".sympy.core.numbers.py@@Integer.__mul__": "def __mul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p * other)\n        elif isinstance(other, Integer):\n            return Integer(self.p * other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    from sympy.core.power import integer_log\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if not isinstance(other, Number):\n        return False\n    if not self:\n        return not other\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Rational:\n        return self.p == other.p and self.q == other.q\n    if other.is_Float:\n        if self.q & self.q - 1:\n            return False\n        s, m, t = other._mpf_[:3]\n        if s:\n            m = -m\n        if not t:\n            if not self.is_Integer or self.is_even:\n                return False\n            return m == self.p\n        if t > 0:\n            if not self.is_Integer:\n                return False\n            return self.p and (not self.p % m) and (integer_log(self.p // m, 2) == (t, True))\n        if self.is_Integer:\n            return False\n        return m == self.p and integer_log(self.q, 2) == (-t, True)\n    return False",
    ".sympy.core.logic.py@@fuzzy_and": "def fuzzy_and(args):\n    rv = True\n    for ai in args:\n        ai = fuzzy_bool(ai)\n        if ai is False:\n            return False\n        if rv:\n            rv = ai\n    return rv",
    ".sympy.core.logic.py@@fuzzy_bool": "def fuzzy_bool(x):\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    ".sympy.core.add.py@@_addsort": "def _addsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.basic.py@@Basic._exec_constructor_postprocessors": "def _exec_constructor_postprocessors(cls, obj):\n    clsname = obj.__class__.__name__\n    postprocessors = defaultdict(list)\n    for i in obj.args:\n        try:\n            postprocessor_mappings = (Basic._constructor_postprocessor_mapping[cls].items() for cls in type(i).mro() if cls in Basic._constructor_postprocessor_mapping)\n            for k, v in chain.from_iterable(postprocessor_mappings):\n                postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n        except TypeError:\n            pass\n    for f in postprocessors.get(clsname, []):\n        obj = f(obj)\n    return obj",
    ".sympy.core.expr.py@@Expr.__sub__": "def __sub__(self, other):\n    return Add(self, -other)",
    ".sympy.core.add.py@@Add.__neg__": "def __neg__(self):\n    if not global_parameters.distribute:\n        return super().__neg__()\n    return Add(*[-i for i in self.args])",
    ".sympy.core.numbers.py@@Rational.__neg__": "def __neg__(self):\n    return Rational(-self.p, self.q)",
    ".sympy.core.mul.py@@Mul.__neg__": "def __neg__(self):\n    c, args = self.as_coeff_mul()\n    c = -c\n    if c is not S.One:\n        if args[0].is_Number:\n            args = list(args)\n            if c is S.NegativeOne:\n                args[0] = -args[0]\n            else:\n                args[0] *= c\n        else:\n            args = (c,) + args\n    return self._from_args(args, self.is_commutative)",
    ".sympy.core.mul.py@@Mul.as_coeff_mul": "def as_coeff_mul(self, *deps, **kwargs):\n    if deps:\n        from sympy.utilities.iterables import sift\n        l1, l2 = sift(self.args, lambda x: x.has(*deps), binary=True)\n        return (self._new_rawargs(*l2), tuple(l1))\n    rational = kwargs.pop('rational', True)\n    args = self.args\n    if args[0].is_Number:\n        if not rational or args[0].is_Rational:\n            return (args[0], args[1:])\n        elif args[0].is_extended_negative:\n            return (S.NegativeOne, (-args[0],) + args[1:])\n    return (S.One, args)",
    ".sympy.core.add.py@@Add.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    from sympy.matrices.expressions import MatrixExpr\n    from sympy.tensor.tensor import TensExpr\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        if a.is_Rational:\n            if b.is_Mul:\n                rv = ([a, b], [], None)\n        if rv:\n            if all((s.is_commutative for s in rv[0])):\n                return rv\n            return ([], rv[0], None)\n    terms = {}\n    coeff = S.Zero\n    order_factors = []\n    extra = []\n    for o in seq:\n        if o.is_Order:\n            if o.expr.is_zero:\n                continue\n            for o1 in order_factors:\n                if o1.contains(o):\n                    o = None\n                    break\n            if o is None:\n                continue\n            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]\n            continue\n        elif o.is_Number:\n            if (o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False)) and (not extra):\n                return ([S.NaN], [], None)\n            if coeff.is_Number or isinstance(coeff, AccumBounds):\n                coeff += o\n                if coeff is S.NaN and (not extra):\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__add__(coeff)\n            continue\n        elif isinstance(o, MatrixExpr):\n            extra.append(o)\n            continue\n        elif isinstance(o, TensExpr):\n            coeff = o.__add__(coeff) if coeff else o\n            continue\n        elif o is S.ComplexInfinity:\n            if coeff.is_finite is False and (not extra):\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o.is_Add:\n            seq.extend(o.args)\n            continue\n        elif o.is_Mul:\n            c, s = o.as_coeff_Mul()\n        elif o.is_Pow:\n            b, e = o.as_base_exp()\n            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):\n                seq.append(b ** e)\n                continue\n            c, s = (S.One, o)\n        else:\n            c = S.One\n            s = o\n        if s in terms:\n            terms[s] += c\n            if terms[s] is S.NaN and (not extra):\n                return ([S.NaN], [], None)\n        else:\n            terms[s] = c\n    newseq = []\n    noncommutative = False\n    for s, c in terms.items():\n        if c.is_zero:\n            continue\n        elif c is S.One:\n            newseq.append(s)\n        elif s.is_Mul:\n            cs = s._new_rawargs(*(c,) + s.args)\n            newseq.append(cs)\n        elif s.is_Add:\n            newseq.append(Mul(c, s, evaluate=False))\n        else:\n            newseq.append(Mul(c, s))\n        noncommutative = noncommutative or not s.is_commutative\n    if coeff is S.Infinity:\n        newseq = [f for f in newseq if not (f.is_extended_nonnegative or f.is_real)]\n    elif coeff is S.NegativeInfinity:\n        newseq = [f for f in newseq if not (f.is_extended_nonpositive or f.is_real)]\n    if coeff is S.ComplexInfinity:\n        newseq = [c for c in newseq if not (c.is_finite and c.is_extended_real is not None)]\n    if order_factors:\n        newseq2 = []\n        for t in newseq:\n            for o in order_factors:\n                if o.contains(t):\n                    t = None\n                    break\n            if t is not None:\n                newseq2.append(t)\n        newseq = newseq2 + order_factors\n        for o in order_factors:\n            if o.contains(coeff):\n                coeff = S.Zero\n                break\n    _addsort(newseq)\n    if coeff is not S.Zero:\n        newseq.insert(0, coeff)\n    if extra:\n        newseq += extra\n        noncommutative = True\n    if noncommutative:\n        return ([], newseq, None)\n    else:\n        return (newseq, [], None)",
    ".sympy.core.numbers.py@@Integer.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    ".sympy.core.mul.py@@Mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return (coeff, args[0])\n            else:\n                return (coeff, self._new_rawargs(*args))\n        elif coeff.is_extended_negative:\n            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))\n    return (S.One, self)",
    ".sympy.core.expr.py@@Expr.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.expr.py@@Expr._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.numbers.py@@Rational.__add__": "def __add__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(self.p + self.q * other.p, self.q, 1)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + self.q * other.p, self.q * other.q)\n        elif isinstance(other, Float):\n            return other + self\n        else:\n            return Number.__add__(self, other)\n    return Number.__add__(self, other)",
    ".sympy.simplify.simplify.py@@dotprodsimp": "def dotprodsimp(expr, withsimp=False):\n\n    def count_ops_alg(expr):\n        ops = 0\n        args = [expr]\n        ratfunc = False\n        while args:\n            a = args.pop()\n            if not isinstance(a, Basic):\n                continue\n            if a.is_Rational:\n                if a is not S.One:\n                    ops += bool(a.p < 0) + bool(a.q != 1)\n            elif a.is_Mul:\n                if _coeff_isneg(a):\n                    ops += 1\n                    if a.args[0] is S.NegativeOne:\n                        a = a.as_two_terms()[1]\n                    else:\n                        a = -a\n                n, d = fraction(a)\n                if n.is_Integer:\n                    ops += 1 + bool(n < 0)\n                    args.append(d)\n                elif d is not S.One:\n                    if not d.is_Integer:\n                        args.append(d)\n                        ratfunc = True\n                    ops += 1\n                    args.append(n)\n                else:\n                    ops += len(a.args) - 1\n                    args.extend(a.args)\n            elif a.is_Add:\n                laargs = len(a.args)\n                negs = 0\n                for ai in a.args:\n                    if _coeff_isneg(ai):\n                        negs += 1\n                        ai = -ai\n                    args.append(ai)\n                ops += laargs - (negs != laargs)\n            elif a.is_Pow:\n                ops += 1\n                args.append(a.base)\n                if not ratfunc:\n                    ratfunc = a.exp.is_negative is not False\n        return (ops, ratfunc)\n\n    def nonalg_subs_dummies(expr, dummies):\n        if not expr.args:\n            return expr\n        if expr.is_Add or expr.is_Mul or expr.is_Pow:\n            args = None\n            for i, a in enumerate(expr.args):\n                c = nonalg_subs_dummies(a, dummies)\n                if c is a:\n                    continue\n                if args is None:\n                    args = list(expr.args)\n                args[i] = c\n            if args is None:\n                return expr\n            return expr.func(*args)\n        return dummies.setdefault(expr, Dummy())\n    simplified = False\n    if isinstance(expr, Basic) and (expr.is_Add or expr.is_Mul or expr.is_Pow):\n        expr2 = expr.expand(deep=True, modulus=None, power_base=False, power_exp=False, mul=True, log=False, multinomial=True, basic=False)\n        if expr2 != expr:\n            expr = expr2\n            simplified = True\n        exprops, ratfunc = count_ops_alg(expr)\n        if exprops >= 6:\n            if ratfunc:\n                dummies = {}\n                expr2 = nonalg_subs_dummies(expr, dummies)\n                if expr2 is expr or count_ops_alg(expr2)[0] >= 6:\n                    expr3 = cancel(expr2)\n                    if expr3 != expr2:\n                        expr = expr3.subs([(d, e) for e, d in dummies.items()])\n                        simplified = True\n        elif exprops == 5 and expr.is_Add and expr.args[0].is_Mul and expr.args[1].is_Mul and expr.args[0].args[-1].is_Pow and expr.args[1].args[-1].is_Pow and (expr.args[0].args[-1].exp is S.NegativeOne) and (expr.args[1].args[-1].exp is S.NegativeOne):\n            expr2 = together(expr)\n            expr2ops = count_ops_alg(expr2)[0]\n            if expr2ops < exprops:\n                expr = expr2\n                simplified = True\n        else:\n            simplified = True\n    return (expr, simplified) if withsimp else expr",
    ".sympy.core.expr.py@@Expr.as_base_exp": "def as_base_exp(self):\n    return (self, S.One)",
    ".sympy.core.mul.py@@Mul._gather": "def _gather(c_powers):\n    common_b = {}\n    for b, e in c_powers:\n        co = e.as_coeff_Mul()\n        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n    for b, d in common_b.items():\n        for di, li in d.items():\n            d[di] = Add(*li)\n    new_c_powers = []\n    for b, e in common_b.items():\n        new_c_powers.extend([(b, c * t) for t, c in e.items()])\n    return new_c_powers",
    ".sympy.core.numbers.py@@Rational.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (self, S.One)",
    ".sympy.core.numbers.py@@Rational.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.core.numbers.py@@Rational._hashable_content": "def _hashable_content(self):\n    return (self.p, self.q)",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.assumptions.py@@StdFactKB.generator": "def generator(self):\n    return self._generator.copy()",
    ".sympy.core.numbers.py@@Rational._eval_is_zero": "def _eval_is_zero(self):\n    return self.p == 0",
    ".sympy.core.numbers.py@@Zero.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.core.mul.py@@_mulsort": "def _mulsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.basic.py@@Basic.compare": "def compare(self, other):\n    if self is other:\n        return 0\n    n1 = self.__class__\n    n2 = other.__class__\n    c = (n1 > n2) - (n1 < n2)\n    if c:\n        return c\n    st = self._hashable_content()\n    ot = other._hashable_content()\n    c = (len(st) > len(ot)) - (len(st) < len(ot))\n    if c:\n        return c\n    for l, r in zip(st, ot):\n        l = Basic(*l) if isinstance(l, frozenset) else l\n        r = Basic(*r) if isinstance(r, frozenset) else r\n        if isinstance(l, Basic):\n            c = l.compare(r)\n        else:\n            c = (l > r) - (l < r)\n        if c:\n            return c\n    return 0",
    ".sympy.core.core.py@@BasicMeta.__gt__": "def __gt__(cls, other):\n    if cls.__cmp__(other) == 1:\n        return True\n    return False",
    ".sympy.core.core.py@@BasicMeta.__cmp__": "def __cmp__(cls, other):\n    if not isinstance(other, BasicMeta):\n        return -1\n    n1 = cls.__name__\n    n2 = other.__name__\n    if n1 == n2:\n        return 0\n    UNKNOWN = len(ordering_of_classes) + 1\n    try:\n        i1 = ordering_of_classes.index(n1)\n    except ValueError:\n        i1 = UNKNOWN\n    try:\n        i2 = ordering_of_classes.index(n2)\n    except ValueError:\n        i2 = UNKNOWN\n    if i1 == UNKNOWN and i2 == UNKNOWN:\n        return (n1 > n2) - (n1 < n2)\n    return (i1 > i2) - (i1 < i2)",
    ".sympy.core.core.py@@BasicMeta.__lt__": "def __lt__(cls, other):\n    if cls.__cmp__(other) == -1:\n        return True\n    return False",
    ".sympy.core.numbers.py@@One.__neg__": "def __neg__():\n    return S.NegativeOne",
    ".sympy.core.numbers.py@@Rational.as_numer_denom": "def as_numer_denom(self):\n    return (Integer(self.p), Integer(self.q))",
    ".sympy.core.numbers.py@@Integer.__divmod__": "def __divmod__(self, other):\n    from .containers import Tuple\n    if isinstance(other, Integer) and global_parameters.evaluate:\n        return Tuple(*divmod(self.p, other.p))\n    else:\n        return Number.__divmod__(self, other)",
    ".sympy.core.containers.py@@Tuple.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.numbers.py@@Integer.__mod__": "def __mod__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p % other)\n        elif isinstance(other, Integer):\n            return Integer(self.p % other.p)\n        return Rational.__mod__(self, other)\n    return Rational.__mod__(self, other)",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.expr.py@@Expr.expand": "def expand(self, deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints):\n    from sympy.simplify.radsimp import fraction\n    hints.update(power_base=power_base, power_exp=power_exp, mul=mul, log=log, multinomial=multinomial, basic=basic)\n    expr = self\n    if hints.pop('frac', False):\n        n, d = [a.expand(deep=deep, modulus=modulus, **hints) for a in fraction(self)]\n        return n / d\n    elif hints.pop('denom', False):\n        n, d = fraction(self)\n        return n / d.expand(deep=deep, modulus=modulus, **hints)\n    elif hints.pop('numer', False):\n        n, d = fraction(self)\n        return n.expand(deep=deep, modulus=modulus, **hints) / d\n\n    def _expand_hint_key(hint):\n        if hint == 'mul':\n            return 'mulz'\n        return hint\n    for hint in sorted(hints.keys(), key=_expand_hint_key):\n        use_hint = hints[hint]\n        if use_hint:\n            hint = '_eval_expand_' + hint\n            expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)\n    while True:\n        was = expr\n        if hints.get('multinomial', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_multinomial', deep=deep, **hints)\n        if hints.get('mul', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_mul', deep=deep, **hints)\n        if hints.get('log', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_log', deep=deep, **hints)\n        if expr == was:\n            break\n    if modulus is not None:\n        modulus = sympify(modulus)\n        if not modulus.is_Integer or modulus <= 0:\n            raise ValueError('modulus must be a positive integer, got %s' % modulus)\n        terms = []\n        for term in Add.make_args(expr):\n            coeff, tail = term.as_coeff_Mul(rational=True)\n            coeff %= modulus\n            if coeff:\n                terms.append(coeff * tail)\n        expr = Add(*terms)\n    return expr",
    ".sympy.core.expr.py@@Expr._expand_hint_key": "def _expand_hint_key(hint):\n    if hint == 'mul':\n        return 'mulz'\n    return hint",
    ".sympy.core.expr.py@@Expr._expand_hint": "def _expand_hint(expr, hint, deep=True, **hints):\n    hit = False\n    if deep and getattr(expr, 'args', ()) and (not expr.is_Atom):\n        sargs = []\n        for arg in expr.args:\n            arg, arghit = Expr._expand_hint(arg, hint, **hints)\n            hit |= arghit\n            sargs.append(arg)\n        if hit:\n            expr = expr.func(*sargs)\n    if hasattr(expr, hint):\n        newexpr = getattr(expr, hint)(**hints)\n        if newexpr != expr:\n            return (newexpr, True)\n    return (expr, hit)",
    ".sympy.core.mul.py@@Mul._eval_expand_mul": "def _eval_expand_mul(self, **hints):\n    from sympy import fraction\n    expr = self\n    n, d = fraction(expr)\n    if d.is_Mul:\n        n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i for i in (n, d)]\n        expr = n / d\n        if not expr.is_Mul:\n            return expr\n    plain, sums, rewrite = ([], [], False)\n    for factor in expr.args:\n        if factor.is_Add:\n            sums.append(factor)\n            rewrite = True\n        elif factor.is_commutative:\n            plain.append(factor)\n        else:\n            sums.append(Basic(factor))\n    if not rewrite:\n        return expr\n    else:\n        plain = self.func(*plain)\n        if sums:\n            deep = hints.get('deep', False)\n            terms = self.func._expandsums(sums)\n            args = []\n            for term in terms:\n                t = self.func(plain, term)\n                if t.is_Mul and any((a.is_Add for a in t.args)) and deep:\n                    t = t._eval_expand_mul()\n                args.append(t)\n            return Add(*args)\n        else:\n            return plain",
    ".sympy.simplify.radsimp.py@@fraction": "def fraction(expr, exact=False):\n    expr = sympify(expr)\n    numer, denom = ([], [])\n    for term in Mul.make_args(expr):\n        if term.is_commutative and (term.is_Pow or isinstance(term, exp)):\n            b, ex = term.as_base_exp()\n            if ex.is_negative:\n                if ex is S.NegativeOne:\n                    denom.append(b)\n                elif exact:\n                    if ex.is_constant():\n                        denom.append(Pow(b, -ex))\n                    else:\n                        numer.append(term)\n                else:\n                    denom.append(Pow(b, -ex))\n            elif ex.is_positive:\n                numer.append(term)\n            elif not exact and ex.is_Mul:\n                n, d = term.as_numer_denom()\n                if n != 1:\n                    numer.append(n)\n                denom.append(d)\n            else:\n                numer.append(term)\n        elif term.is_Rational and (not term.is_Integer):\n            if term.p != 1:\n                numer.append(term.p)\n            denom.append(term.q)\n        else:\n            numer.append(term)\n    return (Mul(*numer, evaluate=not exact), Mul(*denom, evaluate=not exact))",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.core.expr.py@@Expr.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n        if not isinstance(other, Expr):\n            return False\n    except (SympifyError, SyntaxError):\n        return False\n    if not (self.is_Number and other.is_Number) and type(self) != type(other):\n        return False\n    a, b = (self._hashable_content(), other._hashable_content())\n    if a != b:\n        return False\n    for a, b in zip(a, b):\n        if not isinstance(a, Expr):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    ".sympy.core.mul.py@@Mul._expandsums": "def _expandsums(sums):\n    L = len(sums)\n    if L == 1:\n        return sums[0].args\n    terms = []\n    left = Mul._expandsums(sums[:L // 2])\n    right = Mul._expandsums(sums[L // 2:])\n    terms = [Mul(a, b) for a in left for b in right]\n    added = Add(*terms)\n    return Add.make_args(added)",
    ".sympy.core.numbers.py@@Integer.as_numer_denom": "def as_numer_denom(self):\n    return (self, S.One)",
    ".sympy.core.numbers.py@@Integer.__rmul__": "def __rmul__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other * self.p)\n        elif isinstance(other, Rational):\n            return Rational(other.p * self.p, other.q, igcd(self.p, other.q))\n        return Rational.__rmul__(self, other)\n    return Rational.__rmul__(self, other)",
    ".sympy.simplify.simplify.py@@count_ops_alg": "def count_ops_alg(expr):\n    ops = 0\n    args = [expr]\n    ratfunc = False\n    while args:\n        a = args.pop()\n        if not isinstance(a, Basic):\n            continue\n        if a.is_Rational:\n            if a is not S.One:\n                ops += bool(a.p < 0) + bool(a.q != 1)\n        elif a.is_Mul:\n            if _coeff_isneg(a):\n                ops += 1\n                if a.args[0] is S.NegativeOne:\n                    a = a.as_two_terms()[1]\n                else:\n                    a = -a\n            n, d = fraction(a)\n            if n.is_Integer:\n                ops += 1 + bool(n < 0)\n                args.append(d)\n            elif d is not S.One:\n                if not d.is_Integer:\n                    args.append(d)\n                    ratfunc = True\n                ops += 1\n                args.append(n)\n            else:\n                ops += len(a.args) - 1\n                args.extend(a.args)\n        elif a.is_Add:\n            laargs = len(a.args)\n            negs = 0\n            for ai in a.args:\n                if _coeff_isneg(ai):\n                    negs += 1\n                    ai = -ai\n                args.append(ai)\n            ops += laargs - (negs != laargs)\n        elif a.is_Pow:\n            ops += 1\n            args.append(a.base)\n            if not ratfunc:\n                ratfunc = a.exp.is_negative is not False\n    return (ops, ratfunc)",
    ".sympy.core.function.py@@_coeff_isneg": "def _coeff_isneg(a):\n    if a.is_MatMul:\n        a = a.args[0]\n    if a.is_Mul:\n        a = a.args[0]\n    return a.is_Number and a.is_extended_negative",
    ".sympy.core.expr.py@@Expr._eval_is_extended_negative": "def _eval_is_extended_negative(self):\n    return self._eval_is_extended_positive_negative(positive=False)",
    ".sympy.core.expr.py@@Expr._eval_is_extended_positive_negative": "def _eval_is_extended_positive_negative(self, positive):\n    from sympy.polys.numberfields import minimal_polynomial\n    from sympy.polys.polyerrors import NotAlgebraic\n    if self.is_number:\n        if self.is_extended_real is False:\n            return False\n        try:\n            n2 = self._eval_evalf(2)\n        except ValueError:\n            return None\n        if n2 is None:\n            return None\n        if getattr(n2, '_prec', 1) == 1:\n            return None\n        if n2 is S.NaN:\n            return None\n        r, i = self.evalf(2).as_real_imag()\n        if not i.is_Number or not r.is_Number:\n            return False\n        if r._prec != 1 and i._prec != 1:\n            return bool(not i and (r > 0 if positive else r < 0))\n        elif r._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):\n            try:\n                if minimal_polynomial(self).is_Symbol:\n                    return False\n            except (NotAlgebraic, NotImplementedError):\n                pass",
    ".sympy.core.numbers.py@@Number._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Rational._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_rational(self.p, self.q, prec, rnd)",
    ".sympy.core.numbers.py@@Float._new": "def _new(cls, _mpf_, _prec, zero=True):\n    if zero and _mpf_ == fzero:\n        return S.Zero\n    elif _mpf_ == _mpf_nan:\n        return S.NaN\n    elif _mpf_ == _mpf_inf:\n        return S.Infinity\n    elif _mpf_ == _mpf_ninf:\n        return S.NegativeInfinity\n    obj = Expr.__new__(cls)\n    obj._mpf_ = mpf_norm(_mpf_, _prec)\n    obj._prec = _prec\n    return obj",
    ".sympy.core.numbers.py@@mpf_norm": "def mpf_norm(mpf, prec):\n    sign, man, expt, bc = mpf\n    if not man:\n        if not bc:\n            return fzero\n        else:\n            return mpf\n    from mpmath.libmp.backend import MPZ\n    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n    return rv",
    ".sympy.core.evalf.py@@EvalfMixin.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    from sympy import Float, Number\n    n = n if n is not None else 15\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n    if n == 1 and isinstance(self, Number):\n        from sympy.core.expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        elif not v.is_number:\n            return v\n        try:\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            return v\n    re, im, re_acc, im_acc = result\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im * S.ImaginaryUnit\n    else:\n        return re",
    ".sympy.core.evalf.py@@evalf": "def evalf(x, prec, options):\n    from sympy import re as re_, im as im_\n    try:\n        rf = evalf_table[x.func]\n        r = rf(x, prec, options)\n    except KeyError:\n        if 'subs' in options:\n            x = x.subs(evalf_subs(prec, options['subs']))\n        xe = x._eval_evalf(prec)\n        if xe is None:\n            raise NotImplementedError\n        as_real_imag = getattr(xe, 'as_real_imag', None)\n        if as_real_imag is None:\n            raise NotImplementedError\n        re, im = as_real_imag()\n        if re.has(re_) or im.has(im_):\n            raise NotImplementedError\n        if re == 0:\n            re = None\n            reprec = None\n        elif re.is_number:\n            re = re._to_mpmath(prec, allow_ints=False)._mpf_\n            reprec = prec\n        else:\n            raise NotImplementedError\n        if im == 0:\n            im = None\n            imprec = None\n        elif im.is_number:\n            im = im._to_mpmath(prec, allow_ints=False)._mpf_\n            imprec = prec\n        else:\n            raise NotImplementedError\n        r = (re, im, reprec, imprec)\n    if options.get('verbose'):\n        print('### input', x)\n        print('### output', to_str(r[0] or fzero, 50))\n        print('### raw', r)\n        print()\n    chop = options.get('chop', False)\n    if chop:\n        if chop is True:\n            chop_prec = prec\n        else:\n            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))\n            if chop_prec == 3:\n                chop_prec -= 1\n        r = chop_parts(r, chop_prec)\n    if options.get('strict'):\n        check_target(x, r, prec)\n    return r",
    ".sympy.core.expr.py@@Expr.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy import im, re\n    if hints.get('ignore') == self:\n        return None\n    else:\n        return (re(self), im(self))",
    ".sympy.core.numbers.py@@Float.__eq__": "def __eq__(self, other):\n    from sympy.logic.boolalg import Boolean\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if not self:\n        return not other\n    if isinstance(other, Boolean):\n        return False\n    if other.is_NumberSymbol:\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if other.is_Float:\n        return self._mpf_ == other._mpf_\n    if other.is_Rational:\n        return other.__eq__(self)\n    if other.is_Number:\n        ompf = other._as_mpf_val(self._prec)\n        return bool(mlib.mpf_eq(self._mpf_, ompf))\n    return False",
    ".sympy.core.sympify.py@@SympifyError.__init__": "def __init__(self, expr, base_exc=None):\n    self.expr = expr\n    self.base_exc = base_exc",
    ".sympy.core.function.py@@Function.__new__": "def __new__(cls, *args, **options):\n    if cls is Function:\n        return UndefinedFunction(*args, **options)\n    n = len(args)\n    if n not in cls.nargs:\n        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'\n        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})\n    evaluate = options.get('evaluate', global_parameters.evaluate)\n    result = super().__new__(cls, *args, **options)\n    if evaluate and isinstance(result, cls) and result.args:\n        pr2 = min((cls._should_evalf(a) for a in result.args))\n        if pr2 > 0:\n            pr = max((cls._should_evalf(a) for a in result.args))\n            result = result.evalf(mlib.libmpf.prec_to_dps(pr))\n    return result",
    ".sympy.core.function.py@@FunctionClass.nargs": "def nargs(self):\n    from sympy.sets.sets import FiniteSet\n    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0",
    ".sympy.sets.sets.py@@FiniteSet.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_parameters.evaluate)\n    if evaluate:\n        args = list(map(sympify, args))\n        if len(args) == 0:\n            return S.EmptySet\n    else:\n        args = list(map(sympify, args))\n    dargs = {}\n    for i in reversed(list(ordered(args))):\n        if i.is_Symbol:\n            dargs[i] = i\n        else:\n            try:\n                dargs[i.as_dummy()] = i\n            except TypeError:\n                dargs[i] = i\n    _args_set = set(dargs.values())\n    args = list(ordered(_args_set, Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._args_set = _args_set\n    return obj",
    ".sympy.core.compatibility.py@@ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    d = defaultdict(list)\n    if keys:\n        if not isinstance(keys, (list, tuple)):\n            keys = [keys]\n        keys = list(keys)\n        f = keys.pop(0)\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n    for k in sorted(d.keys()):\n        if len(d[k]) > 1:\n            if keys:\n                d[k] = ordered(d[k], keys, default, warn)\n            elif default:\n                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)\n            elif warn:\n                from sympy.utilities.iterables import uniq\n                u = list(uniq(d[k]))\n                if len(u) > 1:\n                    raise ValueError('not enough keys to break ties: %s' % u)\n        yield from d[k]\n        d.pop(k)",
    ".sympy.core.basic.py@@Basic.as_dummy": "def as_dummy(self):\n    from sympy.core.symbol import Dummy, Symbol\n\n    def can(x):\n        free = x.free_symbols\n        bound = set(x.bound_symbols)\n        d = {i: Dummy() for i in bound & free}\n        x = x.subs(d)\n        x = x.xreplace(x.canonical_variables)\n        return x.xreplace({v: k for k, v in d.items()})\n    if not self.has(Symbol):\n        return self\n    return self.replace(lambda x: hasattr(x, 'bound_symbols'), lambda x: can(x), simultaneous=False)",
    ".sympy.core.basic.py@@Basic.has": "def has(self, *patterns):\n    return any((self._has(pattern) for pattern in patterns))",
    ".sympy.core.basic.py@@Basic._has": "def _has(self, pattern):\n    from sympy.core.function import UndefinedFunction, Function\n    if isinstance(pattern, UndefinedFunction):\n        return any((f.func == pattern or f == pattern for f in self.atoms(Function, UndefinedFunction)))\n    pattern = _sympify(pattern)\n    if isinstance(pattern, BasicMeta):\n        return any((isinstance(arg, pattern) for arg in preorder_traversal(self)))\n    _has_matcher = getattr(pattern, '_has_matcher', None)\n    if _has_matcher is not None:\n        match = _has_matcher()\n        return any((match(arg) for arg in preorder_traversal(self)))\n    else:\n        return any((arg == pattern for arg in preorder_traversal(self)))",
    ".sympy.core.basic.py@@preorder_traversal.__init__": "def __init__(self, node, keys=None):\n    self._skip_flag = False\n    self._pt = self._preorder_traversal(node, keys)",
    ".sympy.core.basic.py@@preorder_traversal.__iter__": "def __iter__(self):\n    return self",
    ".sympy.core.basic.py@@preorder_traversal.__next__": "def __next__(self):\n    return next(self._pt)",
    ".sympy.core.basic.py@@preorder_traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            yield from self._preorder_traversal(arg, keys)\n    elif iterable(node):\n        for item in node:\n            yield from self._preorder_traversal(item, keys)",
    ".sympy.sets.sets.py@@Set._infimum_key": "def _infimum_key(expr):\n    try:\n        infimum = expr.inf\n        assert infimum.is_comparable\n        infimum = infimum.evalf()\n    except (NotImplementedError, AttributeError, AssertionError, ValueError):\n        infimum = S.Infinity\n    return infimum",
    ".sympy.core.numbers.py@@Infinity.__hash__": "def __hash__(self):\n    return super().__hash__()",
    ".sympy.sets.sets.py@@Set.__contains__": "def __contains__(self, other):\n    other = _sympify(other)\n    c = self._contains(other)\n    b = tfn[c]\n    if b is None:\n        raise TypeError('did not evaluate to a bool: %r' % c)\n    return b",
    ".sympy.sets.sets.py@@FiniteSet._contains": "def _contains(self, other):\n    if other in self._args_set:\n        return True\n    else:\n        return fuzzy_or((fuzzy_bool(Eq(e, other, evaluate=True)) for e in self.args))",
    ".sympy.core.function.py@@Application.__new__": "def __new__(cls, *args, **options):\n    from sympy.sets.fancysets import Naturals0\n    from sympy.sets.sets import FiniteSet\n    args = list(map(sympify, args))\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    options.pop('nargs', None)\n    if options:\n        raise ValueError('Unknown options: %s' % options)\n    if evaluate:\n        evaluated = cls.eval(*args)\n        if evaluated is not None:\n            return evaluated\n    obj = super().__new__(cls, *args, **options)\n    sentinel = object()\n    objnargs = getattr(obj, 'nargs', sentinel)\n    if objnargs is not sentinel:\n        if is_sequence(objnargs):\n            nargs = tuple(ordered(set(objnargs)))\n        elif objnargs is not None:\n            nargs = (as_int(objnargs),)\n        else:\n            nargs = None\n    else:\n        nargs = obj._nargs\n    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()\n    return obj",
    ".sympy.functions.elementary.complexes.py@@re.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_extended_real:\n        return arg\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_extended_real:\n        return S.Zero\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[0]\n    elif arg.is_Function and isinstance(arg, conjugate):\n        return re(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_extended_real:\n                    reverted.append(coeff)\n            elif not term.has(S.ImaginaryUnit) and term.is_extended_real:\n                excluded.append(term)\n            else:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[0])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) - im(b) + c",
    ".sympy.functions.elementary.complexes.py@@im.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_extended_real:\n        return S.Zero\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_extended_real:\n        return -S.ImaginaryUnit * arg\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[1]\n    elif arg.is_Function and isinstance(arg, conjugate):\n        return -im(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_extended_real:\n                    reverted.append(coeff)\n                else:\n                    excluded.append(coeff)\n            elif term.has(S.ImaginaryUnit) or not term.is_extended_real:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[1])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) + re(b) + c",
    ".sympy.core.numbers.py@@Float.__lt__": "def __lt__(self, other):\n    if isinstance(other, NumberSymbol):\n        return other.__gt__(self)\n    rv = self._Frel(other, mlib.mpf_lt)\n    if rv is None:\n        return Expr.__lt__(self, other)\n    return rv",
    ".sympy.core.numbers.py@@Float._Frel": "def _Frel(self, other, op):\n    from sympy.core.numbers import prec_to_dps\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Rational:\n        '\\n        >>> f = Float(.1,2)\\n        >>> i = 1234567890\\n        >>> (f*i)._mpf_\\n        (0, 471, 18, 9)\\n        >>> mlib.mpf_mul(f._mpf_, mlib.from_int(i))\\n        (0, 505555550955, -12, 39)\\n        '\n        smpf = mlib.mpf_mul(self._mpf_, mlib.from_int(other.q))\n        ompf = mlib.from_int(other.p)\n        return _sympify(bool(op(smpf, ompf)))\n    elif other.is_Float:\n        return _sympify(bool(op(self._mpf_, other._mpf_)))\n    elif other.is_comparable and other not in (S.Infinity, S.NegativeInfinity):\n        other = other.evalf(prec_to_dps(self._prec))\n        if other._prec > 1:\n            if other.is_Number:\n                return _sympify(bool(op(self._mpf_, other._as_mpf_val(self._prec))))",
    ".sympy.core.numbers.py@@Integer._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_int(self.p, prec, rnd)",
    ".sympy.core.logic.py@@_fuzzy_group": "def _fuzzy_group(args, quick_exit=False):\n    saw_other = False\n    for a in args:\n        if a is True:\n            continue\n        if a is None:\n            return\n        if quick_exit and saw_other:\n            return\n        saw_other = True\n    return not saw_other",
    ".sympy.core.numbers.py@@Zero.__neg__": "def __neg__():\n    return S.Zero",
    ".sympy.core.numbers.py@@Rational.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            return Rational(self.p - self.q * other.p, self.q, 1)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - self.q * other.p, self.q * other.q)\n        elif isinstance(other, Float):\n            return -other + self\n        else:\n            return Number.__sub__(self, other)\n    return Number.__sub__(self, other)",
    ".sympy.core.numbers.py@@Number.__sub__": "def __sub__(self, other):\n    if isinstance(other, Number) and global_parameters.evaluate:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            return S.NegativeInfinity\n        elif other is S.NegativeInfinity:\n            return S.Infinity\n    return AtomicExpr.__sub__(self, other)",
    ".sympy.core.numbers.py@@Rational.__div__": "def __div__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, Integer):\n            if self.p and other.p == S.Zero:\n                return S.ComplexInfinity\n            else:\n                return Rational(self.p, self.q * other.p, igcd(self.p, other.p))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q, self.q * other.p, igcd(self.p, other.p) * igcd(self.q, other.q))\n        elif isinstance(other, Float):\n            return self * (1 / other)\n        else:\n            return Number.__div__(self, other)\n    return Number.__div__(self, other)",
    ".sympy.core.numbers.py@@Number.__div__": "def __div__(self, other):\n    if isinstance(other, Number) and global_parameters.evaluate:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity or other is S.NegativeInfinity:\n            return S.Zero\n    return AtomicExpr.__div__(self, other)",
    ".sympy.core.expr.py@@Expr.__div__": "def __div__(self, other):\n    denom = Pow(other, S.NegativeOne)\n    if self is S.One:\n        return denom\n    else:\n        return Mul(self, denom)",
    ".sympy.core.power.py@@Pow.__new__": "def __new__(cls, b, e, evaluate=None):\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    from sympy.functions.elementary.exponential import exp_polar\n    b = _sympify(b)\n    e = _sympify(e)\n    from sympy.core.relational import Relational\n    if isinstance(b, Relational) or isinstance(e, Relational):\n        raise TypeError('Relational can not be used in Pow')\n    if not (isinstance(b, Expr) and isinstance(e, Expr)):\n        SymPyDeprecationWarning(feature='Pow with non-Expr args', useinstead='Expr args', issue=19445, deprecated_since_version='1.7').warn()\n    if evaluate:\n        if e is S.ComplexInfinity:\n            return S.NaN\n        if e is S.Zero:\n            return S.One\n        elif e is S.One:\n            return b\n        elif e == -1 and (not b):\n            return S.ComplexInfinity\n        elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and e.is_integer and _coeff_isneg(b):\n            if e.is_even:\n                b = -b\n            elif e.is_odd:\n                return -Pow(-b, e)\n        if S.NaN in (b, e):\n            return S.NaN\n        elif b is S.One:\n            if abs(e).is_infinite:\n                return S.NaN\n            return S.One\n        else:\n            if not e.is_Atom and b is not S.Exp1 and (not isinstance(b, exp_polar)):\n                from sympy import numer, denom, log, sign, im, factor_terms\n                c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n                den = denom(ex)\n                if isinstance(den, log) and den.args[0] == b:\n                    return S.Exp1 ** (c * numer(ex))\n                elif den.is_Add:\n                    s = sign(im(b))\n                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):\n                        return S.Exp1 ** (c * numer(ex))\n            obj = b._eval_power(e)\n            if obj is not None:\n                return obj\n    obj = Expr.__new__(cls, b, e)\n    obj = cls._exec_constructor_postprocessors(obj)\n    if not isinstance(obj, Pow):\n        return obj\n    obj.is_commutative = b.is_commutative and e.is_commutative\n    return obj",
    ".sympy.core.expr.py@@Expr.is_number": "def is_number(self):\n    return all((obj.is_number for obj in self.args))",
    ".sympy.core.add.py@@Add._eval_power": "def _eval_power(self, e):\n    if e.is_Rational and self.is_number:\n        from sympy.core.evalf import pure_complex\n        from sympy.core.mul import _unevaluated_Mul\n        from sympy.core.exprtools import factor_terms\n        from sympy.core.function import expand_multinomial\n        from sympy.functions.elementary.complexes import sign\n        from sympy.functions.elementary.miscellaneous import sqrt\n        ri = pure_complex(self)\n        if ri:\n            r, i = ri\n            if e.q == 2:\n                D = sqrt(r ** 2 + i ** 2)\n                if D.is_Rational:\n                    root = sqrt(factor_terms((D - r) / 2)) ** e.p\n                    return root * expand_multinomial(((D + r) / abs(i) + sign(i) * S.ImaginaryUnit) ** e.p)\n            elif e == -1:\n                return _unevaluated_Mul(r - i * S.ImaginaryUnit, 1 / (r ** 2 + i ** 2))\n    elif e.is_Number and abs(e) != 1:\n        c, m = zip(*[i.as_coeff_Mul() for i in self.args])\n        if any((i.is_Float for i in c)):\n            big = -1\n            for i in c:\n                if abs(i) >= big:\n                    big = abs(i)\n            if big > 0 and big != 1:\n                from sympy.functions.elementary.complexes import sign\n                bigs = (big, -big)\n                c = [sign(i) if i in bigs else i / big for i in c]\n                addpow = Add(*[c * m for c, m in zip(c, m)]) ** e\n                return big ** e * addpow",
    ".sympy.core.evalf.py@@pure_complex": "def pure_complex(v, or_real=False):\n    h, t = v.as_coeff_Add()\n    if not t:\n        if or_real:\n            return (h, t)\n        return\n    c, i = t.as_coeff_Mul()\n    if i is S.ImaginaryUnit:\n        return (h, c)",
    ".sympy.core.expr.py@@Expr.__pow__": "def __pow__(self, other, mod=None):\n    if mod is None:\n        return self._pow(other)\n    try:\n        _self, other, mod = (as_int(self), as_int(other), as_int(mod))\n        if other >= 0:\n            return pow(_self, other, mod)\n        else:\n            from sympy.core.numbers import mod_inverse\n            return mod_inverse(pow(_self, -other, mod), mod)\n    except ValueError:\n        power = self._pow(other)\n        try:\n            return power % mod\n        except TypeError:\n            return NotImplemented",
    ".sympy.core.expr.py@@Expr._pow": "def _pow(self, other):\n    return Pow(self, other)",
    ".sympy.core.numbers.py@@Integer._eval_is_odd": "def _eval_is_odd(self):\n    return bool(self.p % 2)",
    ".sympy.core.numbers.py@@Rational._eval_power": "def _eval_power(self, expt):\n    if isinstance(expt, Number):\n        if isinstance(expt, Float):\n            return self._eval_evalf(expt._prec) ** expt\n        if expt.is_extended_negative:\n            ne = -expt\n            if ne is S.One:\n                return Rational(self.q, self.p)\n            if self.is_negative:\n                return S.NegativeOne ** expt * Rational(self.q, -self.p) ** ne\n            else:\n                return Rational(self.q, self.p) ** ne\n        if expt is S.Infinity:\n            if self.p > self.q:\n                return S.Infinity\n            if self.p < -self.q:\n                return S.Infinity + S.Infinity * S.ImaginaryUnit\n            return S.Zero\n        if isinstance(expt, Integer):\n            return Rational(self.p ** expt.p, self.q ** expt.p, 1)\n        if isinstance(expt, Rational):\n            if self.p != 1:\n                return Integer(self.p) ** expt * Integer(self.q) ** (-expt)\n            return Integer(self.q) ** Rational(expt.p * (expt.q - 1), expt.q) / Integer(self.q) ** Integer(expt.p)\n    if self.is_extended_negative and expt.is_even:\n        return (-self) ** expt\n    return",
    ".sympy.core.expr.py@@Expr.__rdiv__": "def __rdiv__(self, other):\n    denom = Pow(self, S.NegativeOne)\n    if other is S.One:\n        return denom\n    else:\n        return Mul(other, denom)",
    ".sympy.core.numbers.py@@NegativeOne.__neg__": "def __neg__():\n    return S.One",
    ".sympy.core.mul.py@@_unevaluated_Mul": "def _unevaluated_Mul(*args):\n    args = list(args)\n    newargs = []\n    ncargs = []\n    co = S.One\n    while args:\n        a = args.pop()\n        if a.is_Mul:\n            c, nc = a.args_cnc()\n            args.extend(c)\n            if nc:\n                ncargs.append(Mul._from_args(nc))\n        elif a.is_Number:\n            co *= a\n        else:\n            newargs.append(a)\n    _mulsort(newargs)\n    if co is not S.One:\n        newargs.insert(0, co)\n    if ncargs:\n        newargs.append(Mul._from_args(ncargs))\n    return Mul._from_args(newargs)",
    ".sympy.core.mul.py@@Mul._eval_is_zero": "def _eval_is_zero(self):\n    zero = infinite = False\n    for a in self.args:\n        z = a.is_zero\n        if z:\n            if infinite:\n                return\n            zero = True\n        else:\n            if not a.is_finite:\n                if zero:\n                    return\n                infinite = True\n            if zero is False and z is None:\n                zero = None\n    return zero",
    ".sympy.matrices.dense.py@@MutableDenseMatrix.__new__": "def __new__(cls, *args, **kwargs):\n    return cls._new(*args, **kwargs)",
    ".sympy.matrices.matrices.py@@MatrixBase.do": "def do(x):\n    if isinstance(x, (list, tuple)):\n        return type(x)([do(i) for i in x])\n    if isinstance(x, BlockMatrix) or (isinstance(x, MatrixSymbol) and all((_.is_Integer for _ in x.shape))):\n        return x.as_explicit()\n    return x",
    ".sympy.matrices.common.py@@MatrixOperations.T": "def T(self):\n    return self.transpose()",
    ".sympy.matrices.common.py@@MatrixOperations.transpose": "def transpose(self):\n    return self._eval_transpose()",
    ".sympy.matrices.common.py@@MatrixOperations._eval_transpose": "def _eval_transpose(self):\n    return self._new(self.cols, self.rows, lambda i, j: self[j, i])",
    ".sympy.matrices.common.py@@MatrixProperties.is_zero_matrix": "def is_zero_matrix(self):\n    return self._eval_is_zero_matrix()",
    ".sympy.matrices.common.py@@MatrixProperties._eval_is_zero_matrix": "def _eval_is_zero_matrix(self):\n    if any((i.is_zero == False for i in self)):\n        return False\n    if any((i.is_zero is None for i in self)):\n        return None\n    return True",
    ".sympy.core.symbol.py@@uniquely_named_symbol": "def uniquely_named_symbol(xname, exprs=(), compare=str, modify=None, **assumptions):\n    from sympy.core.function import AppliedUndef\n\n    def numbered_string_incr(s, start=0):\n        if not s:\n            return str(start)\n        i = len(s) - 1\n        while i != -1:\n            if not s[i].isdigit():\n                break\n            i -= 1\n        n = str(int(s[i + 1:] or start - 1) + 1)\n        return s[:i + 1] + n\n    default = None\n    if is_sequence(xname):\n        xname, default = xname\n    x = str(xname)\n    if not exprs:\n        return _symbol(x, default, **assumptions)\n    if not is_sequence(exprs):\n        exprs = [exprs]\n    names = set().union([i.name for e in exprs for i in e.atoms(Symbol)] + [i.func.name for e in exprs for i in e.atoms(AppliedUndef)])\n    if modify is None:\n        modify = numbered_string_incr\n    while any((x == compare(s) for s in names)):\n        x = modify(x)\n    return _symbol(x, default, **assumptions)",
    ".sympy.core.basic.py@@Basic.atoms": "def atoms(self, *types):\n    if types:\n        types = tuple([t if isinstance(t, type) else type(t) for t in types])\n    nodes = preorder_traversal(self)\n    if types:\n        result = {node for node in nodes if isinstance(node, types)}\n    else:\n        result = {node for node in nodes if not node.args}\n    return result",
    ".sympy.core.symbol.py@@_symbol": "def _symbol(s, matching_symbol=None, **assumptions):\n    if isinstance(s, str):\n        if matching_symbol and matching_symbol.name == s:\n            return matching_symbol\n        return Symbol(s, **assumptions)\n    elif isinstance(s, Symbol):\n        return s\n    else:\n        raise ValueError('symbol must be string for symbol name or Symbol')",
    ".sympy.core.symbol.py@@Symbol.__new__": "def __new__(cls, name, **assumptions):\n    cls._sanitize(assumptions, cls)\n    return Symbol.__xnew_cached_(cls, name, **assumptions)",
    ".sympy.core.symbol.py@@Symbol._sanitize": "def _sanitize(assumptions, obj=None):\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    if is_commutative is None:\n        whose = '%s ' % obj.__name__ if obj else ''\n        raise ValueError('%scommutativity must be True or False.' % whose)\n    for key in list(assumptions.keys()):\n        v = assumptions[key]\n        if v is None:\n            assumptions.pop(key)\n            continue\n        assumptions[key] = bool(v)",
    ".sympy.core.symbol.py@@Symbol.__new_stage2__": "def __new_stage2__(cls, name, **assumptions):\n    if not isinstance(name, str):\n        raise TypeError('name should be a string, not %s' % repr(type(name)))\n    obj = Expr.__new__(cls)\n    obj.name = name\n    tmp_asm_copy = assumptions.copy()\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    assumptions['commutative'] = is_commutative\n    obj._assumptions = StdFactKB(assumptions)\n    obj._assumptions._generator = tmp_asm_copy\n    return obj",
    ".sympy.matrices.common.py@@MatrixShaping.reshape": "def reshape(self, rows, cols):\n    if self.rows * self.cols != rows * cols:\n        raise ValueError('Invalid reshape parameters %d %d' % (rows, cols))\n    return self._new(rows, cols, lambda i, j: self[i * cols + j])",
    ".sympy.matrices.common.py@@MatrixArithmetic.__mul__": "def __mul__(self, other):\n    return self.multiply(other)",
    ".sympy.matrices.common.py@@MatrixArithmetic.multiply": "def multiply(self, other, dotprodsimp=None):\n    isimpbool = _get_intermediate_simp_bool(False, dotprodsimp)\n    other = _matrixify(other)\n    if hasattr(other, 'shape') and len(other.shape) == 2 and (getattr(other, 'is_Matrix', True) or getattr(other, 'is_MatrixLike', True)):\n        if self.shape[1] != other.shape[0]:\n            raise ShapeError('Matrix size mismatch: %s * %s.' % (self.shape, other.shape))\n    if getattr(other, 'is_Matrix', False):\n        m = self._eval_matrix_mul(other)\n        if isimpbool:\n            return m._new(m.rows, m.cols, [_dotprodsimp(e) for e in m])\n        return m\n    if getattr(other, 'is_MatrixLike', False):\n        return MatrixArithmetic._eval_matrix_mul(self, other)\n    if not isinstance(other, Iterable):\n        try:\n            return self._eval_scalar_mul(other)\n        except TypeError:\n            pass\n    return NotImplemented",
    ".sympy.matrices.utilities.py@@_get_intermediate_simp_bool": "def _get_intermediate_simp_bool(default=False, dotprodsimp=None):\n    return _get_intermediate_simp(default, False, True, dotprodsimp)",
    ".sympy.matrices.common.py@@_matrixify": "def _matrixify(mat):\n    if getattr(mat, 'is_Matrix', False) or getattr(mat, 'is_MatrixLike', False):\n        return mat\n    if not (getattr(mat, 'is_Matrix', True) or getattr(mat, 'is_MatrixLike', True)):\n        return mat\n    shape = None\n    if hasattr(mat, 'shape'):\n        if len(mat.shape) == 2:\n            shape = mat.shape\n    elif hasattr(mat, 'rows') and hasattr(mat, 'cols'):\n        shape = (mat.rows, mat.cols)\n    if shape:\n        return _MatrixWrapper(mat, shape)\n    return mat",
    ".sympy.matrices.dense.py@@DenseMatrix._eval_matrix_mul": "def _eval_matrix_mul(self, other):\n    other_len = other.rows * other.cols\n    new_len = self.rows * other.cols\n    new_mat = [self.zero] * new_len\n    if self.cols != 0 and other.rows != 0:\n        self_cols = self.cols\n        mat = self._mat\n        other_mat = other._mat\n        for i in range(new_len):\n            row, col = (i // other.cols, i % other.cols)\n            row_indices = range(self_cols * row, self_cols * (row + 1))\n            col_indices = range(col, other_len, other.cols)\n            vec = [mat[a] * other_mat[b] for a, b in zip(row_indices, col_indices)]\n            try:\n                new_mat[i] = Add(*vec)\n            except (TypeError, SympifyError):\n                new_mat[i] = reduce(lambda a, b: a + b, vec)\n    return classof(self, other)._new(self.rows, other.cols, new_mat, copy=False)",
    ".sympy.matrices.common.py@@MatrixArithmetic.__sub__": "def __sub__(self, a):\n    return self + -a",
    ".sympy.matrices.common.py@@MatrixArithmetic.__neg__": "def __neg__(self):\n    return self._eval_scalar_mul(-1)",
    ".sympy.matrices.dense.py@@DenseMatrix._eval_scalar_mul": "def _eval_scalar_mul(self, other):\n    mat = [other * a for a in self._mat]\n    return self._new(self.rows, self.cols, mat, copy=False)",
    ".sympy.matrices.common.py@@MatrixArithmetic.__add__": "def __add__(self, other):\n    other = _matrixify(other)\n    if hasattr(other, 'shape'):\n        if self.shape != other.shape:\n            raise ShapeError('Matrix size mismatch: %s + %s' % (self.shape, other.shape))\n    if getattr(other, 'is_Matrix', False):\n        a, b = (self, other)\n        if a.__class__ != classof(a, b):\n            b, a = (a, b)\n        return a._eval_add(b)\n    if getattr(other, 'is_MatrixLike', False):\n        return MatrixArithmetic._eval_add(self, other)\n    raise TypeError('cannot add %s and %s' % (type(self), type(other)))",
    ".sympy.matrices.dense.py@@DenseMatrix._eval_add": "def _eval_add(self, other):\n    mat = [a + b for a, b in zip(self._mat, other._mat)]\n    return classof(self, other)._new(self.rows, self.cols, mat, copy=False)",
    ".sympy.core.expr.py@@Expr.__add__": "def __add__(self, other):\n    return Add(self, other)",
    ".sympy.matrices.common.py@@MatrixShaping.vstack": "def vstack(cls, *args):\n    if len(args) == 0:\n        return cls._new()\n    kls = type(args[0])\n    return reduce(kls.col_join, args)",
    ".sympy.matrices.common.py@@MatrixShaping.col_join": "def col_join(self, other):\n    if self.rows == 0 and self.cols != other.cols:\n        return self._new(0, other.cols, []).col_join(other)\n    if self.cols != other.cols:\n        raise ShapeError('`self` and `other` must have the same number of columns.')\n    return self._eval_col_join(other)",
    ".sympy.matrices.common.py@@MatrixShaping._eval_col_join": "def _eval_col_join(self, other):\n    rows = self.rows\n\n    def entry(i, j):\n        if i < rows:\n            return self[i, j]\n        return other[i - rows, j]\n    return classof(self, other)._new(self.rows + other.rows, self.cols, lambda i, j: entry(i, j))",
    ".sympy.matrices.dense.py@@zeros": "def zeros(*args, **kwargs):\n    if 'c' in kwargs:\n        kwargs['cols'] = kwargs.pop('c')\n    return Matrix.zeros(*args, **kwargs)",
    ".sympy.matrices.common.py@@MatrixSpecial.zeros": "def zeros(kls, rows, cols=None, **kwargs):\n    if cols is None:\n        cols = rows\n    klass = kwargs.get('cls', kls)\n    rows, cols = (as_int(rows), as_int(cols))\n    return klass._eval_zeros(rows, cols)",
    ".sympy.matrices.common.py@@MatrixSpecial._eval_zeros": "def _eval_zeros(cls, rows, cols):\n\n    def entry(i, j):\n        return cls.zero\n    return cls._new(rows, cols, entry)",
    ".sympy.matrices.common.py@@MatrixSpecial.entry": "def entry(i, j):\n    if j == size - 1:\n        return -coeffs[-1 - i]\n    elif i == j + 1:\n        return kls.one\n    return kls.zero",
    ".sympy.matrices.dense.py@@MutableDenseMatrix.__setitem__": "def __setitem__(self, key, value):\n    rv = self._setitem(key, value)\n    if rv is not None:\n        i, j, value = rv\n        self._mat[i * self.cols + j] = value",
    ".sympy.matrices.matrices.py@@MatrixBase._setitem": "def _setitem(self, key, value):\n    from .dense import Matrix\n    is_slice = isinstance(key, slice)\n    i, j = key = self.key2ij(key)\n    is_mat = isinstance(value, MatrixBase)\n    if type(i) is slice or type(j) is slice:\n        if is_mat:\n            self.copyin_matrix(key, value)\n            return\n        if not isinstance(value, Expr) and is_sequence(value):\n            self.copyin_list(key, value)\n            return\n        raise ValueError('unexpected value: %s' % value)\n    else:\n        if not is_mat and (not isinstance(value, Basic)) and is_sequence(value):\n            value = Matrix(value)\n            is_mat = True\n        if is_mat:\n            if is_slice:\n                key = (slice(*divmod(i, self.cols)), slice(*divmod(j, self.cols)))\n            else:\n                key = (slice(i, i + value.rows), slice(j, j + value.cols))\n            self.copyin_matrix(key, value)\n        else:\n            return (i, j, self._sympify(value))\n        return",
    ".sympy.matrices.dense.py@@MutableDenseMatrix.copyin_matrix": "def copyin_matrix(self, key, value):\n    rlo, rhi, clo, chi = self.key2bounds(key)\n    shape = value.shape\n    dr, dc = (rhi - rlo, chi - clo)\n    if shape != (dr, dc):\n        raise ShapeError(filldedent(\"The Matrix `value` doesn't have the same dimensions as the in sub-Matrix given by `key`.\"))\n    for i in range(value.rows):\n        for j in range(value.cols):\n            self[i + rlo, j + clo] = value[i, j]",
    ".sympy.matrices.matrices.py@@MatrixBase.key2bounds": "def key2bounds(self, keys):\n    from sympy.matrices.common import a2idx as a2idx_\n    islice, jslice = [isinstance(k, slice) for k in keys]\n    if islice:\n        if not self.rows:\n            rlo = rhi = 0\n        else:\n            rlo, rhi = keys[0].indices(self.rows)[:2]\n    else:\n        rlo = a2idx_(keys[0], self.rows)\n        rhi = rlo + 1\n    if jslice:\n        if not self.cols:\n            clo = chi = 0\n        else:\n            clo, chi = keys[1].indices(self.cols)[:2]\n    else:\n        clo = a2idx_(keys[1], self.cols)\n        chi = clo + 1\n    return (rlo, rhi, clo, chi)"
}