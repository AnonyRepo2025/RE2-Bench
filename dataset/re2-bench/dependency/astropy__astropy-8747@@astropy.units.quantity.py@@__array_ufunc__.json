{
    ".astropy.units.quantity_helper.converters.py@@converters_and_unit": "def converters_and_unit(function, method, *args):\n    ufunc_helper = UFUNC_HELPERS[function]\n    if method == '__call__' or (method == 'outer' and function.nin == 2):\n        units = [getattr(arg, 'unit', None) for arg in args]\n        converters, result_unit = ufunc_helper(function, *units)\n        if any((converter is False for converter in converters)):\n            try:\n                for i, converter in enumerate(converters):\n                    if converter is not False:\n                        continue\n                    if can_have_arbitrary_unit(args[i]):\n                        converters[i] = None\n                    else:\n                        raise UnitConversionError(\"Can only apply '{0}' function to dimensionless quantities when other argument is not a quantity (unless the latter is all zero/infinity/nan)\".format(function.__name__))\n            except TypeError:\n                raise TypeError(\"Unsupported operand type(s) for ufunc {0}: '{1}'\".format(function.__name__, ','.join([arg.__class__.__name__ for arg in args])))\n        if result_unit is False:\n            if units[0] is None or units[0] == dimensionless_unscaled:\n                result_unit = dimensionless_unscaled\n            else:\n                if units[1] is None:\n                    p = args[1]\n                else:\n                    p = args[1].to(dimensionless_unscaled).value\n                try:\n                    result_unit = units[0] ** p\n                except ValueError as exc:\n                    try:\n                        converters[0] = units[0]._get_converter(dimensionless_unscaled)\n                    except UnitConversionError:\n                        raise exc\n                    else:\n                        result_unit = dimensionless_unscaled\n    else:\n        nin = function.nin\n        unit = getattr(args[0], 'unit', None)\n        if method == 'at' and nin <= 2:\n            if nin == 1:\n                units = [unit]\n            else:\n                units = [unit, getattr(args[2], 'unit', None)]\n            converters, result_unit = ufunc_helper(function, *units)\n            converters.insert(1, None)\n        elif method in {'reduce', 'accumulate', 'reduceat'} and nin == 2:\n            converters, result_unit = ufunc_helper(function, unit, unit)\n            converters = converters[:1]\n            if method == 'reduceat':\n                converters += [None]\n        else:\n            if method in {'reduce', 'accumulate', 'reduceat', 'outer'} and nin != 2:\n                raise ValueError('{0} only supported for binary functions'.format(method))\n            raise TypeError('Unexpected ufunc method {0}.  If this should work, please raise an issue onhttps://github.com/astropy/astropy'.format(method))\n        if unit is not None and result_unit is None:\n            raise TypeError(\"Cannot use '{1}' method on ufunc {0} with a Quantity instance as the result is not a Quantity.\".format(function.__name__, method))\n        if converters[0] is not None or (unit is not None and unit is not result_unit and (not result_unit.is_equivalent(unit) or result_unit.to(unit) != 1.0)):\n            raise UnitsError(\"Cannot use '{1}' method on ufunc {0} with a Quantity instance as it would change the unit.\".format(function.__name__, method))\n    return (converters, result_unit)",
    ".astropy.units.quantity_helper.helpers.py@@helper_multiplication": "def helper_multiplication(f, unit1, unit2):\n    return ([None, None], _d(unit1) * _d(unit2))",
    ".astropy.units.quantity_helper.helpers.py@@_d": "def _d(unit):\n    if unit is None:\n        return dimensionless_unscaled\n    else:\n        return unit",
    ".astropy.units.core.py@@UnitBase.__mul__": "def __mul__(self, m):\n    if isinstance(m, (bytes, str)):\n        m = Unit(m)\n    if isinstance(m, UnitBase):\n        if m.is_unity():\n            return self\n        elif self.is_unity():\n            return m\n        return CompositeUnit(1, [self, m], [1, 1], _error_check=False)\n    try:\n        from .quantity import Quantity\n        return Quantity(1, self) * m\n    except TypeError:\n        return NotImplemented",
    ".astropy.units.core.py@@CompositeUnit.is_unity": "def is_unity(self):\n    unit = self.decompose()\n    return len(unit.bases) == 0 and unit.scale == 1.0",
    ".astropy.units.core.py@@CompositeUnit.decompose": "def decompose(self, bases=set()):\n    if len(bases) == 0 and self._decomposed_cache is not None:\n        return self._decomposed_cache\n    for base in self.bases:\n        if not isinstance(base, IrreducibleUnit) or (len(bases) and base not in bases):\n            break\n    else:\n        if len(bases) == 0:\n            self._decomposed_cache = self\n        return self\n    x = CompositeUnit(self.scale, self.bases, self.powers, decompose=True, decompose_bases=bases)\n    if len(bases) == 0:\n        self._decomposed_cache = x\n    return x",
    ".astropy.units.core.py@@CompositeUnit.bases": "def bases(self):\n    return self._bases",
    ".astropy.units.core.py@@CompositeUnit.scale": "def scale(self):\n    return self._scale"
}