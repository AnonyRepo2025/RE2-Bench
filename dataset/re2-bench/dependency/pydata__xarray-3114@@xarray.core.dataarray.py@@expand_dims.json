{
    ".xarray.core.utils.py@@either_dict_or_kwargs": "def either_dict_or_kwargs(pos_kwargs: Optional[Mapping[Hashable, T]], kw_kwargs: Mapping[str, T], func_name: str) -> Mapping[Hashable, T]:\n    if pos_kwargs is not None:\n        if not is_dict_like(pos_kwargs):\n            raise ValueError('the first argument to .%s must be a dictionary' % func_name)\n        if kw_kwargs:\n            raise ValueError('cannot specify both keyword and positional arguments to .%s' % func_name)\n        return pos_kwargs\n    else:\n        return cast(Mapping[Hashable, T], kw_kwargs)",
    ".xarray.core.utils.py@@is_dict_like": "def is_dict_like(value: Any) -> bool:\n    return hasattr(value, 'keys') and hasattr(value, '__getitem__')",
    ".xarray.core.coordinates.py@@DataArrayCoordinates.__init__": "def __init__(self, dataarray):\n    self._data = dataarray",
    ".xarray.core.coordinates.py@@AbstractCoordinates.__contains__": "def __contains__(self, key):\n    return key in self._names",
    ".xarray.core.coordinates.py@@DataArrayCoordinates._names": "def _names(self):\n    return set(self._data._coords)",
    ".xarray.core.dataset.py@@Dataset._from_vars_and_coord_names": "def _from_vars_and_coord_names(cls, variables, coord_names, attrs=None):\n    dims = calculate_dimensions(variables)\n    return cls._construct_direct(variables, coord_names, dims, attrs)",
    ".xarray.core.dataset.py@@calculate_dimensions": "def calculate_dimensions(variables: Mapping[Hashable, Variable]) -> 'Dict[Any, int]':\n    dims = {}\n    last_used = {}\n    scalar_vars = set((k for k, v in variables.items() if not v.dims))\n    for k, var in variables.items():\n        for dim, size in zip(var.dims, var.shape):\n            if dim in scalar_vars:\n                raise ValueError('dimension %r already exists as a scalar variable' % dim)\n            if dim not in dims:\n                dims[dim] = size\n                last_used[dim] = k\n            elif dims[dim] != size:\n                raise ValueError('conflicting sizes for dimension %r: length %s on %r and length %s on %r' % (dim, size, k, dims[dim], last_used[dim]))\n    return dims",
    ".xarray.core.variable.py@@Variable.dims": "def dims(self):\n    return self._dims",
    ".xarray.core.variable.py@@Variable.shape": "def shape(self):\n    return self._data.shape",
    ".xarray.core.indexing.py@@PandasIndexAdapter.shape": "def shape(self):\n    return (len(self.array),)",
    ".xarray.core.dataset.py@@Dataset._construct_direct": "def _construct_direct(cls, variables, coord_names, dims, attrs=None, indexes=None, encoding=None, file_obj=None):\n    obj = object.__new__(cls)\n    obj._variables = variables\n    obj._coord_names = coord_names\n    obj._dims = dims\n    obj._indexes = indexes\n    obj._attrs = attrs\n    obj._file_obj = file_obj\n    obj._encoding = encoding\n    obj._initialized = True\n    return obj",
    ".xarray.core.common.py@@AttrAccessMixin.__setattr__": "def __setattr__(self, name: str, value: Any) -> None:\n    if self._initialized:\n        try:\n            self.__getattribute__(name)\n        except AttributeError:\n            raise AttributeError(\"cannot set attribute %r on a %r object. Use __setitem__ style assignment (e.g., `ds['name'] = ...`) instead to assign variables.\" % (name, type(self).__name__))\n    object.__setattr__(self, name, value)",
    ".xarray.core.dataset.py@@Dataset.expand_dims": "def expand_dims(self, dim=None, axis=None, **dim_kwargs):\n    if isinstance(dim, int):\n        raise TypeError('dim should be str or sequence of strs or dict')\n    elif isinstance(dim, str):\n        dim = OrderedDict(((dim, 1),))\n    elif isinstance(dim, (list, tuple)):\n        if len(dim) != len(set(dim)):\n            raise ValueError('dims should not contain duplicate values.')\n        dim = OrderedDict(((d, 1) for d in dim))\n    python36_plus = sys.version_info[0] == 3 and sys.version_info[1] > 5\n    not_ordereddict = dim is not None and (not isinstance(dim, OrderedDict))\n    if not python36_plus and not_ordereddict:\n        raise TypeError('dim must be an OrderedDict for python <3.6')\n    elif not python36_plus and dim_kwargs:\n        raise ValueError(\"dim_kwargs isn't available for python <3.6\")\n    dim = either_dict_or_kwargs(dim, dim_kwargs, 'expand_dims')\n    if axis is not None and (not isinstance(axis, (list, tuple))):\n        axis = [axis]\n    if axis is None:\n        axis = list(range(len(dim)))\n    if len(dim) != len(axis):\n        raise ValueError('lengths of dim and axis should be identical.')\n    for d in dim:\n        if d in self.dims:\n            raise ValueError('Dimension {dim} already exists.'.format(dim=d))\n        if d in self._variables and (not utils.is_scalar(self._variables[d])):\n            raise ValueError('{dim} already exists as coordinate or variable name.'.format(dim=d))\n    variables = OrderedDict()\n    coord_names = self._coord_names.copy()\n    for k, v in dim.items():\n        if hasattr(v, '__iter__'):\n            variables[k] = xr.IndexVariable((k,), v)\n            coord_names.add(k)\n            dim[k] = variables[k].size\n        elif isinstance(v, int):\n            pass\n        else:\n            raise TypeError('The value of new dimension {k} must be an iterable or an int'.format(k=k))\n    for k, v in self._variables.items():\n        if k not in dim:\n            if k in coord_names:\n                variables[k] = v\n            else:\n                result_ndim = len(v.dims) + len(axis)\n                for a in axis:\n                    if a < -result_ndim or result_ndim - 1 < a:\n                        raise IndexError('Axis {a} is out of bounds of the expanded dimension size {dim}.'.format(a=a, v=k, dim=result_ndim))\n                axis_pos = [a if a >= 0 else result_ndim + a for a in axis]\n                if len(axis_pos) != len(set(axis_pos)):\n                    raise ValueError('axis should not contain duplicate values.')\n                zip_axis_dim = sorted(zip(axis_pos, dim.items()))\n                all_dims = list(zip(v.dims, v.shape))\n                for d, c in zip_axis_dim:\n                    all_dims.insert(d, c)\n                all_dims = OrderedDict(all_dims)\n                variables[k] = v.set_dims(all_dims)\n        else:\n            variables[k] = v.set_dims(k).to_index_variable()\n    new_dims = self._dims.copy()\n    new_dims.update(dim)\n    return self._replace_vars_and_dims(variables, dims=new_dims, coord_names=coord_names)",
    ".xarray.core.dataset.py@@Dataset.dims": "def dims(self) -> Mapping[Hashable, int]:\n    return Frozen(SortedKeysDict(self._dims))",
    ".xarray.core.utils.py@@SortedKeysDict.__init__": "def __init__(self, mapping: Optional[MutableMapping[K, V]]=None):\n    self.mapping = {} if mapping is None else mapping",
    ".xarray.core.utils.py@@Frozen.__init__": "def __init__(self, mapping: Mapping[K, V]):\n    self.mapping = mapping",
    ".xarray.core.utils.py@@Frozen.__contains__": "def __contains__(self, key: object) -> bool:\n    return key in self.mapping",
    ".xarray.core.utils.py@@SortedKeysDict.__contains__": "def __contains__(self, key: object) -> bool:\n    return key in self.mapping",
    ".xarray.core.variable.py@@Variable.set_dims": "def set_dims(self, dims, shape=None):\n    if isinstance(dims, str):\n        dims = [dims]\n    if shape is None and utils.is_dict_like(dims):\n        shape = dims.values()\n    missing_dims = set(self.dims) - set(dims)\n    if missing_dims:\n        raise ValueError('new dimensions %r must be a superset of existing dimensions %r' % (dims, self.dims))\n    self_dims = set(self.dims)\n    expanded_dims = tuple((d for d in dims if d not in self_dims)) + self.dims\n    if self.dims == expanded_dims:\n        expanded_data = self.data\n    elif shape is not None:\n        dims_map = dict(zip(dims, shape))\n        tmp_shape = tuple((dims_map[d] for d in expanded_dims))\n        expanded_data = duck_array_ops.broadcast_to(self.data, tmp_shape)\n    else:\n        expanded_data = self.data[(None,) * (len(expanded_dims) - self.ndim)]\n    expanded_var = Variable(expanded_dims, expanded_data, self._attrs, self._encoding, fastpath=True)\n    return expanded_var.transpose(*dims)",
    ".xarray.core.variable.py@@Variable.data": "def data(self):\n    if isinstance(self._data, dask_array_type):\n        return self._data\n    else:\n        return self.values",
    ".xarray.core.variable.py@@Variable.values": "def values(self):\n    return _as_array_or_item(self._data)",
    ".xarray.core.variable.py@@_as_array_or_item": "def _as_array_or_item(data):\n    data = np.asarray(data)\n    if data.ndim == 0:\n        if data.dtype.kind == 'M':\n            data = np.datetime64(data, 'ns')\n        elif data.dtype.kind == 'm':\n            data = np.timedelta64(data, 'ns')\n    return data",
    ".xarray.core.duck_array_ops.py@@f": "def f(values, axis=None, skipna=None, **kwargs):\n    if kwargs.pop('out', None) is not None:\n        raise TypeError('`out` is not valid for {}'.format(name))\n    values = asarray(values)\n    if coerce_strings and values.dtype.kind in 'SU':\n        values = values.astype(object)\n    func = None\n    if skipna or (skipna is None and values.dtype.kind in 'cfO'):\n        nanname = 'nan' + name\n        func = getattr(nanops, nanname)\n    else:\n        func = _dask_or_eager_func(name)\n    try:\n        return func(values, axis=axis, **kwargs)\n    except AttributeError:\n        if isinstance(values, dask_array_type):\n            try:\n                return func(values, axis=axis, dtype=values.dtype, **kwargs)\n            except (AttributeError, TypeError):\n                msg = '%s is not yet implemented on dask arrays' % name\n        else:\n            msg = '%s is not available with skipna=False with the installed version of numpy; upgrade to numpy 1.12 or newer to use skipna=True or skipna=None' % name\n        raise NotImplementedError(msg)",
    ".xarray.core.variable.py@@Variable.__init__": "def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):\n    self._data = as_compatible_data(data, fastpath=fastpath)\n    self._dims = self._parse_dimensions(dims)\n    self._attrs = None\n    self._encoding = None\n    if attrs is not None:\n        self.attrs = attrs\n    if encoding is not None:\n        self.encoding = encoding",
    ".xarray.core.variable.py@@as_compatible_data": "def as_compatible_data(data, fastpath=False):\n    if fastpath and getattr(data, 'ndim', 0) > 0:\n        return _maybe_wrap_data(data)\n    if isinstance(data, Variable):\n        return data.data\n    if isinstance(data, NON_NUMPY_SUPPORTED_ARRAY_TYPES):\n        return _maybe_wrap_data(data)\n    if isinstance(data, tuple):\n        data = utils.to_0d_object_array(data)\n    if isinstance(data, pd.Timestamp):\n        data = np.datetime64(data.value, 'ns')\n    if isinstance(data, timedelta):\n        data = np.timedelta64(getattr(data, 'value', data), 'ns')\n    data = getattr(data, 'values', data)\n    if isinstance(data, np.ma.MaskedArray):\n        mask = np.ma.getmaskarray(data)\n        if mask.any():\n            dtype, fill_value = dtypes.maybe_promote(data.dtype)\n            data = np.asarray(data, dtype=dtype)\n            data[mask] = fill_value\n        else:\n            data = np.asarray(data)\n    data = np.asarray(data)\n    if isinstance(data, np.ndarray):\n        if data.dtype.kind == 'O':\n            data = _possibly_convert_objects(data)\n        elif data.dtype.kind == 'M':\n            data = np.asarray(data, 'datetime64[ns]')\n        elif data.dtype.kind == 'm':\n            data = np.asarray(data, 'timedelta64[ns]')\n    return _maybe_wrap_data(data)",
    ".xarray.core.variable.py@@_maybe_wrap_data": "def _maybe_wrap_data(data):\n    if isinstance(data, pd.Index):\n        return PandasIndexAdapter(data)\n    return data",
    ".xarray.core.variable.py@@Variable._parse_dimensions": "def _parse_dimensions(self, dims):\n    if isinstance(dims, str):\n        dims = (dims,)\n    dims = tuple(dims)\n    if len(dims) != self.ndim:\n        raise ValueError('dimensions %s must have the same length as the number of data dimensions, ndim=%s' % (dims, self.ndim))\n    return dims",
    ".xarray.core.utils.py@@NdimSizeLenMixin.ndim": "def ndim(self: Any) -> int:\n    return len(self.shape)",
    ".xarray.core.variable.py@@Variable.transpose": "def transpose(self, *dims) -> 'Variable':\n    if len(dims) == 0:\n        dims = self.dims[::-1]\n    axes = self.get_axis_num(dims)\n    if len(dims) < 2:\n        return self.copy(deep=False)\n    data = as_indexable(self._data).transpose(axes)\n    return type(self)(dims, data, self._attrs, self._encoding, fastpath=True)",
    ".xarray.core.common.py@@AbstractArray.get_axis_num": "def get_axis_num(self, dim: Union[Hashable, Iterable[Hashable]]) -> Union[int, Tuple[int, ...]]:\n    if isinstance(dim, Iterable) and (not isinstance(dim, str)):\n        return tuple((self._get_axis_num(d) for d in dim))\n    else:\n        return self._get_axis_num(dim)",
    ".xarray.core.common.py@@AbstractArray._get_axis_num": "def _get_axis_num(self: Any, dim: Hashable) -> int:\n    try:\n        return self.dims.index(dim)\n    except ValueError:\n        raise ValueError('%r not found in array dimensions %r' % (dim, self.dims))",
    ".xarray.core.indexing.py@@as_indexable": "def as_indexable(array):\n    if isinstance(array, ExplicitlyIndexed):\n        return array\n    if isinstance(array, np.ndarray):\n        return NumpyIndexingAdapter(array)\n    if isinstance(array, pd.Index):\n        return PandasIndexAdapter(array)\n    if isinstance(array, dask_array_type):\n        return DaskIndexingAdapter(array)\n    raise TypeError('Invalid array type: {}'.format(type(array)))",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.__init__": "def __init__(self, array):\n    if not isinstance(array, np.ndarray):\n        raise TypeError('NumpyIndexingAdapter only wraps np.ndarray. Trying to wrap {}'.format(type(array)))\n    self.array = array",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.transpose": "def transpose(self, order):\n    return self.array.transpose(order)",
    ".xarray.core.dataset.py@@Dataset._replace_vars_and_dims": "def _replace_vars_and_dims(self, variables: 'OrderedDict[Any, Variable]', coord_names: set=None, dims: 'Optional[Dict[Any, int]]'=None, attrs: 'Optional[OrderedDict]'=__default, inplace: bool=False) -> 'Dataset':\n    if dims is None:\n        dims = calculate_dimensions(variables)\n    return self._replace(variables, coord_names, dims, attrs, indexes=None, inplace=inplace)",
    ".xarray.core.dataset.py@@Dataset._replace": "def _replace(self, variables: 'OrderedDict[Any, Variable]'=None, coord_names: Optional[Set[Hashable]]=None, dims: Dict[Any, int]=None, attrs: 'Optional[OrderedDict]'=__default, indexes: 'Optional[OrderedDict[Any, pd.Index]]'=__default, encoding: Optional[dict]=__default, inplace: bool=False) -> 'Dataset':\n    if inplace:\n        if variables is not None:\n            self._variables = variables\n        if coord_names is not None:\n            self._coord_names = coord_names\n        if dims is not None:\n            self._dims = dims\n        if attrs is not self.__default:\n            self._attrs = attrs\n        if indexes is not self.__default:\n            self._indexes = indexes\n        if encoding is not self.__default:\n            self._encoding = encoding\n        obj = self\n    else:\n        if variables is None:\n            variables = self._variables.copy()\n        if coord_names is None:\n            coord_names = self._coord_names.copy()\n        if dims is None:\n            dims = self._dims.copy()\n        if attrs is self.__default:\n            attrs = copy.copy(self._attrs)\n        if indexes is self.__default:\n            indexes = copy.copy(self._indexes)\n        if encoding is self.__default:\n            encoding = copy.copy(self._encoding)\n        obj = self._construct_direct(variables, coord_names, dims, attrs, indexes, encoding)\n    return obj"
}