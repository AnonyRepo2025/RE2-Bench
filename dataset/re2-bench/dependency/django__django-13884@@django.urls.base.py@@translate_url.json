{
    ".django.urls.base.py@@resolve": "def resolve(path, urlconf=None):\n    if urlconf is None:\n        urlconf = get_urlconf()\n    return get_resolver(urlconf).resolve(path)",
    ".django.urls.base.py@@get_urlconf": "def get_urlconf(default=None):\n    return getattr(_urlconfs, 'value', default)",
    ".django.urls.resolvers.py@@get_resolver": "def get_resolver(urlconf=None):\n    if urlconf is None:\n        urlconf = settings.ROOT_URLCONF\n    return _get_cached_resolver(urlconf)",
    ".django.urls.resolvers.py@@URLResolver.resolve": "def resolve(self, path):\n    path = str(path)\n    tried = []\n    match = self.pattern.match(path)\n    if match:\n        new_path, args, kwargs = match\n        for pattern in self.url_patterns:\n            try:\n                sub_match = pattern.resolve(new_path)\n            except Resolver404 as e:\n                self._extend_tried(tried, pattern, e.args[0].get('tried'))\n            else:\n                if sub_match:\n                    sub_match_dict = {**kwargs, **self.default_kwargs}\n                    sub_match_dict.update(sub_match.kwargs)\n                    sub_match_args = sub_match.args\n                    if not sub_match_dict:\n                        sub_match_args = args + sub_match.args\n                    current_route = '' if isinstance(pattern, URLPattern) else str(pattern.pattern)\n                    self._extend_tried(tried, pattern, sub_match.tried)\n                    return ResolverMatch(sub_match.func, sub_match_args, sub_match_dict, sub_match.url_name, [self.app_name] + sub_match.app_names, [self.namespace] + sub_match.namespaces, self._join_route(current_route, sub_match.route), tried)\n                tried.append([pattern])\n        raise Resolver404({'tried': tried, 'path': new_path})\n    raise Resolver404({'path': path})",
    ".django.urls.resolvers.py@@RegexPattern.match": "def match(self, path):\n    match = self.regex.search(path)\n    if match:\n        kwargs = match.groupdict()\n        args = () if kwargs else match.groups()\n        kwargs = {k: v for k, v in kwargs.items() if v is not None}\n        return (path[match.end():], args, kwargs)\n    return None",
    ".django.urls.resolvers.py@@URLPattern.resolve": "def resolve(self, path):\n    match = self.pattern.match(path)\n    if match:\n        new_path, args, kwargs = match\n        kwargs.update(self.default_args)\n        return ResolverMatch(self.callback, args, kwargs, self.pattern.name, route=str(self.pattern))",
    ".django.urls.resolvers.py@@RoutePattern.match": "def match(self, path):\n    match = self.regex.search(path)\n    if match:\n        kwargs = match.groupdict()\n        for key, value in kwargs.items():\n            converter = self.converters[key]\n            try:\n                kwargs[key] = converter.to_python(value)\n            except ValueError:\n                return None\n        return (path[match.end():], (), kwargs)\n    return None",
    ".django.urls.resolvers.py@@URLResolver._extend_tried": "def _extend_tried(tried, pattern, sub_tried=None):\n    if sub_tried is None:\n        tried.append([pattern])\n    else:\n        tried.extend(([pattern, *t] for t in sub_tried))",
    ".django.urls.resolvers.py@@LocaleRegexDescriptor.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    pattern = getattr(instance, self.attr)\n    if isinstance(pattern, str):\n        instance.__dict__['regex'] = instance._compile(pattern)\n        return instance.__dict__['regex']\n    language_code = get_language()\n    if language_code not in instance._regex_dict:\n        instance._regex_dict[language_code] = instance._compile(str(pattern))\n    return instance._regex_dict[language_code]",
    ".django.urls.resolvers.py@@RoutePattern._compile": "def _compile(self, route):\n    return re.compile(_route_to_regex(route, self._is_endpoint)[0])",
    ".django.urls.resolvers.py@@_route_to_regex": "def _route_to_regex(route, is_endpoint=False):\n    original_route = route\n    parts = ['^']\n    converters = {}\n    while True:\n        match = _PATH_PARAMETER_COMPONENT_RE.search(route)\n        if not match:\n            parts.append(re.escape(route))\n            break\n        elif not set(match.group()).isdisjoint(string.whitespace):\n            raise ImproperlyConfigured(\"URL route '%s' cannot contain whitespace in angle brackets <\u2026>.\" % original_route)\n        parts.append(re.escape(route[:match.start()]))\n        route = route[match.end():]\n        parameter = match['parameter']\n        if not parameter.isidentifier():\n            raise ImproperlyConfigured(\"URL route '%s' uses parameter name %r which isn't a valid Python identifier.\" % (original_route, parameter))\n        raw_converter = match['converter']\n        if raw_converter is None:\n            raw_converter = 'str'\n        try:\n            converter = get_converter(raw_converter)\n        except KeyError as e:\n            raise ImproperlyConfigured('URL route %r uses invalid converter %r.' % (original_route, raw_converter)) from e\n        converters[parameter] = converter\n        parts.append('(?P<' + parameter + '>' + converter.regex + ')')\n    if is_endpoint:\n        parts.append('$')\n    return (''.join(parts), converters)",
    ".django.utils.functional.py@@inner": "def inner(self, *args):\n    if self._wrapped is empty:\n        self._setup()\n    return func(self._wrapped, *args)",
    ".django.urls.resolvers.py@@RegexPattern._compile": "def _compile(self, regex):\n    try:\n        return re.compile(regex)\n    except re.error as e:\n        raise ImproperlyConfigured('\"%s\" is not a valid regular expression: %s' % (regex, e)) from e",
    ".django.urls.resolvers.py@@LocalePrefixPattern.match": "def match(self, path):\n    language_prefix = self.language_prefix\n    if path.startswith(language_prefix):\n        return (path[len(language_prefix):], (), {})\n    return None",
    ".django.urls.resolvers.py@@LocalePrefixPattern.language_prefix": "def language_prefix(self):\n    language_code = get_language() or settings.LANGUAGE_CODE\n    if language_code == settings.LANGUAGE_CODE and (not self.prefix_default_language):\n        return ''\n    else:\n        return '%s/' % language_code",
    ".django.utils.translation.__init__.py@@get_language": "def get_language():\n    return _trans.get_language()",
    ".django.utils.translation.trans_real.py@@get_language": "def get_language():\n    t = getattr(_active, 'value', None)\n    if t is not None:\n        try:\n            return t.to_language()\n        except AttributeError:\n            pass\n    return settings.LANGUAGE_CODE",
    ".django.utils.translation.trans_real.py@@DjangoTranslation.to_language": "def to_language(self):\n    return self.__to_language",
    ".django.utils.functional.py@@cached_property.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    res = instance.__dict__[self.name] = self.func(instance)\n    return res",
    ".django.urls.resolvers.py@@URLResolver.url_patterns": "def url_patterns(self):\n    patterns = getattr(self.urlconf_module, 'urlpatterns', self.urlconf_module)\n    try:\n        iter(patterns)\n    except TypeError as e:\n        msg = \"The included URLconf '{name}' does not appear to have any patterns in it. If you see valid patterns in the file then the issue is probably caused by a circular import.\"\n        raise ImproperlyConfigured(msg.format(name=self.urlconf_name)) from e\n    return patterns",
    ".django.urls.resolvers.py@@URLResolver.urlconf_module": "def urlconf_module(self):\n    if isinstance(self.urlconf_name, str):\n        return import_module(self.urlconf_name)\n    else:\n        return self.urlconf_name",
    ".django.utils.translation.__init__.py@@gettext": "def gettext(message):\n    return _trans.gettext(message)",
    ".django.utils.translation.trans_real.py@@gettext": "def gettext(message):\n    global _default\n    eol_message = message.replace('\\r\\n', '\\n').replace('\\r', '\\n')\n    if eol_message:\n        _default = _default or translation(settings.LANGUAGE_CODE)\n        translation_object = getattr(_active, 'value', _default)\n        result = translation_object.gettext(eol_message)\n    else:\n        result = type(message)('')\n    if isinstance(message, SafeData):\n        return mark_safe(result)\n    return result",
    ".django.utils.translation.trans_real.py@@TranslationCatalog.get": "def get(self, key, default=None):\n    missing = object()\n    for cat in self._catalogs:\n        result = cat.get(key, missing)\n        if result is not missing:\n            return result\n    return default",
    ".django.urls.resolvers.py@@RegexPattern.__str__": "def __str__(self):\n    return str(self._regex)",
    ".django.urls.resolvers.py@@ResolverMatch.__init__": "def __init__(self, func, args, kwargs, url_name=None, app_names=None, namespaces=None, route=None, tried=None):\n    self.func = func\n    self.args = args\n    self.kwargs = kwargs\n    self.url_name = url_name\n    self.route = route\n    self.tried = tried\n    self.app_names = [x for x in app_names if x] if app_names else []\n    self.app_name = ':'.join(self.app_names)\n    self.namespaces = [x for x in namespaces if x] if namespaces else []\n    self.namespace = ':'.join(self.namespaces)\n    if not hasattr(func, '__name__'):\n        self._func_path = func.__class__.__module__ + '.' + func.__class__.__name__\n    else:\n        self._func_path = func.__module__ + '.' + func.__name__\n    view_path = url_name or self._func_path\n    self.view_name = ':'.join(self.namespaces + [view_path])",
    ".django.urls.resolvers.py@@URLResolver._join_route": "def _join_route(route1, route2):\n    if not route1:\n        return route2\n    if route2.startswith('^'):\n        route2 = route2[1:]\n    return route1 + route2",
    ".django.urls.resolvers.py@@LocalePrefixPattern.__str__": "def __str__(self):\n    return self.language_prefix",
    ".django.utils.translation.__init__.py@@override.__init__": "def __init__(self, language, deactivate=False):\n    self.language = language\n    self.deactivate = deactivate",
    ".django.utils.translation.__init__.py@@override.__enter__": "def __enter__(self):\n    self.old_language = get_language()\n    if self.language is not None:\n        activate(self.language)\n    else:\n        deactivate_all()",
    ".django.utils.translation.__init__.py@@activate": "def activate(language):\n    return _trans.activate(language)",
    ".django.utils.translation.trans_real.py@@activate": "def activate(language):\n    if not language:\n        return\n    _active.value = translation(language)",
    ".django.utils.translation.trans_real.py@@translation": "def translation(language):\n    global _translations\n    if language not in _translations:\n        _translations[language] = DjangoTranslation(language)\n    return _translations[language]",
    ".django.utils.translation.trans_real.py@@DjangoTranslation.__init__": "def __init__(self, language, domain=None, localedirs=None):\n    gettext_module.GNUTranslations.__init__(self)\n    if domain is not None:\n        self.domain = domain\n    self.__language = language\n    self.__to_language = to_language(language)\n    self.__locale = to_locale(language)\n    self._catalog = None\n    self.plural = lambda n: int(n != 1)\n    if self.domain == 'django':\n        if localedirs is not None:\n            warnings.warn(\"localedirs is ignored when domain is 'django'.\", RuntimeWarning)\n            localedirs = None\n        self._init_translation_catalog()\n    if localedirs:\n        for localedir in localedirs:\n            translation = self._new_gnu_trans(localedir)\n            self.merge(translation)\n    else:\n        self._add_installed_apps_translations()\n    self._add_local_translations()\n    if self.__language == settings.LANGUAGE_CODE and self.domain == 'django' and (self._catalog is None):\n        raise OSError('No translation files found for default language %s.' % settings.LANGUAGE_CODE)\n    self._add_fallback(localedirs)\n    if self._catalog is None:\n        self._catalog = TranslationCatalog()",
    ".django.utils.translation.__init__.py@@to_language": "def to_language(locale):\n    p = locale.find('_')\n    if p >= 0:\n        return locale[:p].lower() + '-' + locale[p + 1:].lower()\n    else:\n        return locale.lower()",
    ".django.utils.translation.__init__.py@@to_locale": "def to_locale(language):\n    language, _, country = language.lower().partition('-')\n    if not country:\n        return language\n    country, _, tail = country.partition('-')\n    country = country.title() if len(country) > 2 else country.upper()\n    if tail:\n        country += '-' + tail\n    return language + '_' + country",
    ".django.utils.translation.trans_real.py@@DjangoTranslation._init_translation_catalog": "def _init_translation_catalog(self):\n    settingsfile = sys.modules[settings.__module__].__file__\n    localedir = os.path.join(os.path.dirname(settingsfile), 'locale')\n    translation = self._new_gnu_trans(localedir)\n    self.merge(translation)",
    ".django.utils.translation.trans_real.py@@DjangoTranslation._new_gnu_trans": "def _new_gnu_trans(self, localedir, use_null_fallback=True):\n    return gettext_module.translation(domain=self.domain, localedir=localedir, languages=[self.__locale], fallback=use_null_fallback)",
    ".django.utils.translation.trans_real.py@@DjangoTranslation.merge": "def merge(self, other):\n    if not getattr(other, '_catalog', None):\n        return\n    if self._catalog is None:\n        self.plural = other.plural\n        self._info = other._info.copy()\n        self._catalog = TranslationCatalog(other)\n    else:\n        self._catalog.update(other)\n    if other._fallback:\n        self.add_fallback(other._fallback)",
    ".django.utils.translation.trans_real.py@@TranslationCatalog.__init__": "def __init__(self, trans=None):\n    self._catalogs = [trans._catalog.copy()] if trans else [{}]\n    self._plurals = [trans.plural] if trans else [lambda n: int(n != 1)]",
    ".django.utils.translation.trans_real.py@@DjangoTranslation._add_installed_apps_translations": "def _add_installed_apps_translations(self):\n    try:\n        app_configs = reversed(list(apps.get_app_configs()))\n    except AppRegistryNotReady:\n        raise AppRegistryNotReady(\"The translation infrastructure cannot be initialized before the apps registry is ready. Check that you don't make non-lazy gettext calls at import time.\")\n    for app_config in app_configs:\n        localedir = os.path.join(app_config.path, 'locale')\n        if os.path.exists(localedir):\n            translation = self._new_gnu_trans(localedir)\n            self.merge(translation)",
    ".django.apps.registry.py@@Apps.get_app_configs": "def get_app_configs(self):\n    self.check_apps_ready()\n    return self.app_configs.values()",
    ".django.apps.registry.py@@Apps.check_apps_ready": "def check_apps_ready(self):\n    if not self.apps_ready:\n        from django.conf import settings\n        settings.INSTALLED_APPS\n        raise AppRegistryNotReady(\"Apps aren't loaded yet.\")",
    ".django.utils.translation.trans_real.py@@TranslationCatalog.update": "def update(self, trans):\n    for cat, plural in zip(self._catalogs, self._plurals):\n        if trans.plural.__code__ == plural.__code__:\n            cat.update(trans._catalog)\n            break\n    else:\n        self._catalogs.insert(0, trans._catalog.copy())\n        self._plurals.insert(0, trans.plural)",
    ".django.utils.translation.trans_real.py@@DjangoTranslation._add_local_translations": "def _add_local_translations(self):\n    for localedir in reversed(settings.LOCALE_PATHS):\n        translation = self._new_gnu_trans(localedir)\n        self.merge(translation)",
    ".django.utils.translation.trans_real.py@@DjangoTranslation._add_fallback": "def _add_fallback(self, localedirs=None):\n    if self.__language == settings.LANGUAGE_CODE or self.__language.startswith('en'):\n        return\n    if self.domain == 'django':\n        default_translation = translation(settings.LANGUAGE_CODE)\n    else:\n        default_translation = DjangoTranslation(settings.LANGUAGE_CODE, domain=self.domain, localedirs=localedirs)\n    self.add_fallback(default_translation)",
    ".django.urls.base.py@@reverse": "def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):\n    if urlconf is None:\n        urlconf = get_urlconf()\n    resolver = get_resolver(urlconf)\n    args = args or []\n    kwargs = kwargs or {}\n    prefix = get_script_prefix()\n    if not isinstance(viewname, str):\n        view = viewname\n    else:\n        *path, view = viewname.split(':')\n        if current_app:\n            current_path = current_app.split(':')\n            current_path.reverse()\n        else:\n            current_path = None\n        resolved_path = []\n        ns_pattern = ''\n        ns_converters = {}\n        for ns in path:\n            current_ns = current_path.pop() if current_path else None\n            try:\n                app_list = resolver.app_dict[ns]\n                if current_ns and current_ns in app_list:\n                    ns = current_ns\n                elif ns not in app_list:\n                    ns = app_list[0]\n            except KeyError:\n                pass\n            if ns != current_ns:\n                current_path = None\n            try:\n                extra, resolver = resolver.namespace_dict[ns]\n                resolved_path.append(ns)\n                ns_pattern = ns_pattern + extra\n                ns_converters.update(resolver.pattern.converters)\n            except KeyError as key:\n                if resolved_path:\n                    raise NoReverseMatch(\"%s is not a registered namespace inside '%s'\" % (key, ':'.join(resolved_path)))\n                else:\n                    raise NoReverseMatch('%s is not a registered namespace' % key)\n        if ns_pattern:\n            resolver = get_ns_resolver(ns_pattern, resolver, tuple(ns_converters.items()))\n    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)",
    ".django.urls.base.py@@get_script_prefix": "def get_script_prefix():\n    return getattr(_prefixes, 'value', '/')",
    ".django.urls.resolvers.py@@URLResolver._reverse_with_prefix": "def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):\n    if args and kwargs:\n        raise ValueError(\"Don't mix *args and **kwargs in call to reverse()!\")\n    if not self._populated:\n        self._populate()\n    possibilities = self.reverse_dict.getlist(lookup_view)\n    for possibility, pattern, defaults, converters in possibilities:\n        for result, params in possibility:\n            if args:\n                if len(args) != len(params):\n                    continue\n                candidate_subs = dict(zip(params, args))\n            else:\n                if set(kwargs).symmetric_difference(params).difference(defaults):\n                    continue\n                if any((kwargs.get(k, v) != v for k, v in defaults.items())):\n                    continue\n                candidate_subs = kwargs\n            text_candidate_subs = {}\n            match = True\n            for k, v in candidate_subs.items():\n                if k in converters:\n                    try:\n                        text_candidate_subs[k] = converters[k].to_url(v)\n                    except ValueError:\n                        match = False\n                        break\n                else:\n                    text_candidate_subs[k] = str(v)\n            if not match:\n                continue\n            candidate_pat = _prefix.replace('%', '%%') + result\n            if re.search('^%s%s' % (re.escape(_prefix), pattern), candidate_pat % text_candidate_subs):\n                url = quote(candidate_pat % text_candidate_subs, safe=RFC3986_SUBDELIMS + '/~:@')\n                return escape_leading_slashes(url)\n    m = getattr(lookup_view, '__module__', None)\n    n = getattr(lookup_view, '__name__', None)\n    if m is not None and n is not None:\n        lookup_view_s = '%s.%s' % (m, n)\n    else:\n        lookup_view_s = lookup_view\n    patterns = [pattern for _, pattern, _, _ in possibilities]\n    if patterns:\n        if args:\n            arg_msg = \"arguments '%s'\" % (args,)\n        elif kwargs:\n            arg_msg = \"keyword arguments '%s'\" % kwargs\n        else:\n            arg_msg = 'no arguments'\n        msg = \"Reverse for '%s' with %s not found. %d pattern(s) tried: %s\" % (lookup_view_s, arg_msg, len(patterns), patterns)\n    else:\n        msg = \"Reverse for '%(view)s' not found. '%(view)s' is not a valid view function or pattern name.\" % {'view': lookup_view_s}\n    raise NoReverseMatch(msg)",
    ".django.urls.resolvers.py@@URLResolver._populate": "def _populate(self):\n    if getattr(self._local, 'populating', False):\n        return\n    try:\n        self._local.populating = True\n        lookups = MultiValueDict()\n        namespaces = {}\n        apps = {}\n        language_code = get_language()\n        for url_pattern in reversed(self.url_patterns):\n            p_pattern = url_pattern.pattern.regex.pattern\n            if p_pattern.startswith('^'):\n                p_pattern = p_pattern[1:]\n            if isinstance(url_pattern, URLPattern):\n                self._callback_strs.add(url_pattern.lookup_str)\n                bits = normalize(url_pattern.pattern.regex.pattern)\n                lookups.appendlist(url_pattern.callback, (bits, p_pattern, url_pattern.default_args, url_pattern.pattern.converters))\n                if url_pattern.name is not None:\n                    lookups.appendlist(url_pattern.name, (bits, p_pattern, url_pattern.default_args, url_pattern.pattern.converters))\n            else:\n                url_pattern._populate()\n                if url_pattern.app_name:\n                    apps.setdefault(url_pattern.app_name, []).append(url_pattern.namespace)\n                    namespaces[url_pattern.namespace] = (p_pattern, url_pattern)\n                else:\n                    for name in url_pattern.reverse_dict:\n                        for matches, pat, defaults, converters in url_pattern.reverse_dict.getlist(name):\n                            new_matches = normalize(p_pattern + pat)\n                            lookups.appendlist(name, (new_matches, p_pattern + pat, {**defaults, **url_pattern.default_kwargs}, {**self.pattern.converters, **url_pattern.pattern.converters, **converters}))\n                    for namespace, (prefix, sub_pattern) in url_pattern.namespace_dict.items():\n                        current_converters = url_pattern.pattern.converters\n                        sub_pattern.pattern.converters.update(current_converters)\n                        namespaces[namespace] = (p_pattern + prefix, sub_pattern)\n                    for app_name, namespace_list in url_pattern.app_dict.items():\n                        apps.setdefault(app_name, []).extend(namespace_list)\n                self._callback_strs.update(url_pattern._callback_strs)\n        self._namespace_dict[language_code] = namespaces\n        self._app_dict[language_code] = apps\n        self._reverse_dict[language_code] = lookups\n        self._populated = True\n    finally:\n        self._local.populating = False",
    ".django.utils.datastructures.py@@MultiValueDict.__init__": "def __init__(self, key_to_list_mapping=()):\n    super().__init__(key_to_list_mapping)",
    ".django.urls.converters.py@@get_converter": "def get_converter(raw_converter):\n    return get_converters()[raw_converter]",
    ".django.urls.resolvers.py@@URLPattern.lookup_str": "def lookup_str(self):\n    callback = self.callback\n    if isinstance(callback, functools.partial):\n        callback = callback.func\n    if not hasattr(callback, '__name__'):\n        return callback.__module__ + '.' + callback.__class__.__name__\n    return callback.__module__ + '.' + callback.__qualname__",
    ".django.utils.regex_helper.py@@normalize": "def normalize(pattern):\n    result = []\n    non_capturing_groups = []\n    consume_next = True\n    pattern_iter = next_char(iter(pattern))\n    num_args = 0\n    try:\n        ch, escaped = next(pattern_iter)\n    except StopIteration:\n        return [('', [])]\n    try:\n        while True:\n            if escaped:\n                result.append(ch)\n            elif ch == '.':\n                result.append('.')\n            elif ch == '|':\n                raise NotImplementedError('Awaiting Implementation')\n            elif ch == '^':\n                pass\n            elif ch == '$':\n                break\n            elif ch == ')':\n                start = non_capturing_groups.pop()\n                inner = NonCapture(result[start:])\n                result = result[:start] + [inner]\n            elif ch == '[':\n                ch, escaped = next(pattern_iter)\n                result.append(ch)\n                ch, escaped = next(pattern_iter)\n                while escaped or ch != ']':\n                    ch, escaped = next(pattern_iter)\n            elif ch == '(':\n                ch, escaped = next(pattern_iter)\n                if ch != '?' or escaped:\n                    name = '_%d' % num_args\n                    num_args += 1\n                    result.append(Group(('%%(%s)s' % name, name)))\n                    walk_to_end(ch, pattern_iter)\n                else:\n                    ch, escaped = next(pattern_iter)\n                    if ch in '!=<':\n                        walk_to_end(ch, pattern_iter)\n                    elif ch == ':':\n                        non_capturing_groups.append(len(result))\n                    elif ch != 'P':\n                        raise ValueError(\"Non-reversible reg-exp portion: '(?%s'\" % ch)\n                    else:\n                        ch, escaped = next(pattern_iter)\n                        if ch not in ('<', '='):\n                            raise ValueError(\"Non-reversible reg-exp portion: '(?P%s'\" % ch)\n                        if ch == '<':\n                            terminal_char = '>'\n                        else:\n                            terminal_char = ')'\n                        name = []\n                        ch, escaped = next(pattern_iter)\n                        while ch != terminal_char:\n                            name.append(ch)\n                            ch, escaped = next(pattern_iter)\n                        param = ''.join(name)\n                        if terminal_char != ')':\n                            result.append(Group(('%%(%s)s' % param, param)))\n                            walk_to_end(ch, pattern_iter)\n                        else:\n                            result.append(Group(('%%(%s)s' % param, None)))\n            elif ch in '*?+{':\n                count, ch = get_quantifier(ch, pattern_iter)\n                if ch:\n                    consume_next = False\n                if count == 0:\n                    if contains(result[-1], Group):\n                        result[-1] = Choice([None, result[-1]])\n                    else:\n                        result.pop()\n                elif count > 1:\n                    result.extend([result[-1]] * (count - 1))\n            else:\n                result.append(ch)\n            if consume_next:\n                ch, escaped = next(pattern_iter)\n            consume_next = True\n    except StopIteration:\n        pass\n    except NotImplementedError:\n        return [('', [])]\n    return list(zip(*flatten_result(result)))",
    ".django.utils.regex_helper.py@@next_char": "def next_char(input_iter):\n    for ch in input_iter:\n        if ch != '\\\\':\n            yield (ch, False)\n            continue\n        ch = next(input_iter)\n        representative = ESCAPE_MAPPINGS.get(ch, ch)\n        if representative is None:\n            continue\n        yield (representative, True)",
    ".django.utils.regex_helper.py@@walk_to_end": "def walk_to_end(ch, input_iter):\n    if ch == '(':\n        nesting = 1\n    else:\n        nesting = 0\n    for ch, escaped in input_iter:\n        if escaped:\n            continue\n        elif ch == '(':\n            nesting += 1\n        elif ch == ')':\n            if not nesting:\n                return\n            nesting -= 1",
    ".django.utils.regex_helper.py@@flatten_result": "def flatten_result(source):\n    if source is None:\n        return ([''], [[]])\n    if isinstance(source, Group):\n        if source[1] is None:\n            params = []\n        else:\n            params = [source[1]]\n        return ([source[0]], [params])\n    result = ['']\n    result_args = [[]]\n    pos = last = 0\n    for pos, elt in enumerate(source):\n        if isinstance(elt, str):\n            continue\n        piece = ''.join(source[last:pos])\n        if isinstance(elt, Group):\n            piece += elt[0]\n            param = elt[1]\n        else:\n            param = None\n        last = pos + 1\n        for i in range(len(result)):\n            result[i] += piece\n            if param:\n                result_args[i].append(param)\n        if isinstance(elt, (Choice, NonCapture)):\n            if isinstance(elt, NonCapture):\n                elt = [elt]\n            inner_result, inner_args = ([], [])\n            for item in elt:\n                res, args = flatten_result(item)\n                inner_result.extend(res)\n                inner_args.extend(args)\n            new_result = []\n            new_args = []\n            for item, args in zip(result, result_args):\n                for i_item, i_args in zip(inner_result, inner_args):\n                    new_result.append(item + i_item)\n                    new_args.append(args[:] + i_args)\n            result = new_result\n            result_args = new_args\n    if pos >= last:\n        piece = ''.join(source[last:])\n        for i in range(len(result)):\n            result[i] += piece\n    return (result, result_args)",
    ".django.utils.datastructures.py@@MultiValueDict.appendlist": "def appendlist(self, key, value):\n    self.setlistdefault(key).append(value)",
    ".django.utils.datastructures.py@@MultiValueDict.setlistdefault": "def setlistdefault(self, key, default_list=None):\n    if key not in self:\n        if default_list is None:\n            default_list = []\n        self.setlist(key, default_list)\n    return self._getlist(key)",
    ".django.utils.datastructures.py@@MultiValueDict.setlist": "def setlist(self, key, list_):\n    super().__setitem__(key, list_)",
    ".django.utils.datastructures.py@@MultiValueDict._getlist": "def _getlist(self, key, default=None, force_list=False):\n    try:\n        values = super().__getitem__(key)\n    except KeyError:\n        if default is None:\n            return []\n        return default\n    else:\n        if force_list:\n            values = list(values) if values is not None else None\n        return values",
    ".django.urls.resolvers.py@@LocalePrefixPattern.regex": "def regex(self):\n    return re.compile(self.language_prefix)",
    ".django.urls.resolvers.py@@URLResolver.reverse_dict": "def reverse_dict(self):\n    language_code = get_language()\n    if language_code not in self._reverse_dict:\n        self._populate()\n    return self._reverse_dict[language_code]",
    ".django.utils.datastructures.py@@MultiValueDict.getlist": "def getlist(self, key, default=None):\n    return self._getlist(key, default, force_list=True)",
    ".django.urls.resolvers.py@@URLResolver.namespace_dict": "def namespace_dict(self):\n    language_code = get_language()\n    if language_code not in self._namespace_dict:\n        self._populate()\n    return self._namespace_dict[language_code]",
    ".django.urls.resolvers.py@@URLResolver.app_dict": "def app_dict(self):\n    language_code = get_language()\n    if language_code not in self._app_dict:\n        self._populate()\n    return self._app_dict[language_code]",
    ".django.utils.http.py@@escape_leading_slashes": "def escape_leading_slashes(url):\n    if url.startswith('//'):\n        url = '/%2F{}'.format(url[2:])\n    return url",
    ".django.utils.translation.__init__.py@@override.__exit__": "def __exit__(self, exc_type, exc_value, traceback):\n    if self.old_language is None:\n        deactivate_all()\n    elif self.deactivate:\n        deactivate()\n    else:\n        activate(self.old_language)",
    ".django.urls.resolvers.py@@RoutePattern.__str__": "def __str__(self):\n    return str(self._route)",
    ".django.conf.__init__.py@@LazySettings.__getattr__": "def __getattr__(self, name):\n    if self._wrapped is empty:\n        self._setup(name)\n    val = getattr(self._wrapped, name)\n    if name in {'MEDIA_URL', 'STATIC_URL'} and val is not None:\n        val = self._add_script_prefix(val)\n    elif name == 'SECRET_KEY' and (not val):\n        raise ImproperlyConfigured('The SECRET_KEY setting must not be empty.')\n    self.__dict__[name] = val\n    return val",
    ".django.conf.__init__.py@@UserSettingsHolder.__getattr__": "def __getattr__(self, name):\n    if not name.isupper() or name in self._deleted:\n        raise AttributeError\n    return getattr(self.default_settings, name)",
    ".django.dispatch.dispatcher.py@@Signal._remove_receiver": "def _remove_receiver(self, receiver=None):\n    self._dead_receivers = True"
}