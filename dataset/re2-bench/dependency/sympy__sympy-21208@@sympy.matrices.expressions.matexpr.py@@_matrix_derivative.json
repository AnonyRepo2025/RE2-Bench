{
    ".sympy.core.expr.py@@Expr._eval_derivative_matrix_lines": "def _eval_derivative_matrix_lines(self, x):\n    from sympy.matrices.expressions.matexpr import _LeftRightArgs\n    return [_LeftRightArgs([S.One, S.One], higher=self._eval_derivative(x))]",
    ".sympy.matrices.matrices.py@@MatrixCalculus._eval_derivative": "def _eval_derivative(self, arg):\n    return self.applyfunc(lambda x: x.diff(arg))",
    ".sympy.matrices.common.py@@MatrixOperations.applyfunc": "def applyfunc(self, f):\n    if not callable(f):\n        raise TypeError('`f` must be callable.')\n    return self._eval_applyfunc(f)",
    ".sympy.matrices.common.py@@MatrixOperations._eval_applyfunc": "def _eval_applyfunc(self, f):\n    out = self._new(self.rows, self.cols, [f(x) for x in self])\n    return out",
    ".sympy.matrices.immutable.py@@ImmutableDenseMatrix.rows": "def rows(self):\n    return self._rows",
    ".sympy.matrices.immutable.py@@ImmutableDenseMatrix.cols": "def cols(self):\n    return self._cols",
    ".sympy.matrices.dense.py@@DenseMatrix.__getitem__": "def __getitem__(self, key):\n    if isinstance(key, tuple):\n        i, j = key\n        try:\n            i, j = self.key2ij(key)\n            return self._mat[i * self.cols + j]\n        except (TypeError, IndexError):\n            if isinstance(i, Expr) and (not i.is_number) or (isinstance(j, Expr) and (not j.is_number)):\n                if (j < 0) is True or (j >= self.shape[1]) is True or (i < 0) is True or ((i >= self.shape[0]) is True):\n                    raise ValueError('index out of boundary')\n                from sympy.matrices.expressions.matexpr import MatrixElement\n                return MatrixElement(self, i, j)\n            if isinstance(i, slice):\n                i = range(self.rows)[i]\n            elif is_sequence(i):\n                pass\n            else:\n                i = [i]\n            if isinstance(j, slice):\n                j = range(self.cols)[j]\n            elif is_sequence(j):\n                pass\n            else:\n                j = [j]\n            return self.extract(i, j)\n    else:\n        if isinstance(key, slice):\n            return self._mat[key]\n        return self._mat[a2idx(key)]",
    ".sympy.matrices.common.py@@a2idx": "def a2idx(j, n=None):\n    if type(j) is not int:\n        jindex = getattr(j, '__index__', None)\n        if jindex is not None:\n            j = jindex()\n        else:\n            raise IndexError('Invalid index a[%r]' % (j,))\n    if n is not None:\n        if j < 0:\n            j += n\n        if not (j >= 0 and j < n):\n            raise IndexError('Index out of range: a[%s]' % (j,))\n    return int(j)",
    ".sympy.core.expr.py@@Expr.diff": "def diff(self, *symbols, **assumptions):\n    assumptions.setdefault('evaluate', True)\n    return _derivative_dispatch(self, *symbols, **assumptions)",
    ".sympy.core.function.py@@_derivative_dispatch": "def _derivative_dispatch(expr, *variables, **kwargs):\n    from sympy.matrices.common import MatrixCommon\n    from sympy import MatrixExpr\n    from sympy import NDimArray\n    array_types = (MatrixCommon, MatrixExpr, NDimArray, list, tuple, Tuple)\n    if isinstance(expr, array_types) or any((isinstance(i[0], array_types) if isinstance(i, (tuple, list, Tuple)) else isinstance(i, array_types) for i in variables)):\n        from sympy.tensor.array.array_derivatives import ArrayDerivative\n        return ArrayDerivative(expr, *variables, **kwargs)\n    return Derivative(expr, *variables, **kwargs)",
    ".sympy.core.function.py@@Derivative.__new__": "def __new__(cls, expr, *variables, **kwargs):\n    from sympy.matrices.common import MatrixCommon\n    from sympy import Integer, MatrixExpr\n    from sympy.tensor.array import Array, NDimArray\n    from sympy.utilities.misc import filldedent\n    expr = sympify(expr)\n    symbols_or_none = getattr(expr, 'free_symbols', None)\n    has_symbol_set = isinstance(symbols_or_none, set)\n    if not has_symbol_set:\n        raise ValueError(filldedent('\\n            Since there are no variables in the expression %s,\\n            it cannot be differentiated.' % expr))\n    if not variables:\n        variables = expr.free_symbols\n        if len(variables) != 1:\n            if expr.is_number:\n                return S.Zero\n            if len(variables) == 0:\n                raise ValueError(filldedent('\\n                    Since there are no variables in the expression,\\n                    the variable(s) of differentiation must be supplied\\n                    to differentiate %s' % expr))\n            else:\n                raise ValueError(filldedent('\\n                    Since there is more than one variable in the\\n                    expression, the variable(s) of differentiation\\n                    must be supplied to differentiate %s' % expr))\n    variables = list(sympify(variables))\n    variable_count = []\n    array_likes = (tuple, list, Tuple)\n    for i, v in enumerate(variables):\n        if isinstance(v, Integer):\n            if i == 0:\n                raise ValueError('First variable cannot be a number: %i' % v)\n            count = v\n            prev, prevcount = variable_count[-1]\n            if prevcount != 1:\n                raise TypeError('tuple {} followed by number {}'.format((prev, prevcount), v))\n            if count == 0:\n                variable_count.pop()\n            else:\n                variable_count[-1] = Tuple(prev, count)\n        else:\n            if isinstance(v, array_likes):\n                if len(v) == 0:\n                    continue\n                if isinstance(v[0], array_likes):\n                    if len(v) == 1:\n                        v = Array(v[0])\n                        count = 1\n                    else:\n                        v, count = v\n                        v = Array(v)\n                else:\n                    v, count = v\n                if count == 0:\n                    continue\n            elif isinstance(v, UndefinedFunction):\n                raise TypeError('cannot differentiate wrt UndefinedFunction: %s' % v)\n            else:\n                count = 1\n            variable_count.append(Tuple(v, count))\n    merged = []\n    for t in variable_count:\n        v, c = t\n        if c.is_negative:\n            raise ValueError('order of differentiation must be nonnegative')\n        if merged and merged[-1][0] == v:\n            c += merged[-1][1]\n            if not c:\n                merged.pop()\n            else:\n                merged[-1] = Tuple(v, c)\n        else:\n            merged.append(t)\n    variable_count = merged\n    for v, c in variable_count:\n        if not v._diff_wrt:\n            __ = ''\n            raise ValueError(filldedent(\"\\n                Can't calculate derivative wrt %s.%s\" % (v, __)))\n    if len(variable_count) == 0:\n        return expr\n    evaluate = kwargs.get('evaluate', False)\n    if evaluate:\n        if isinstance(expr, Derivative):\n            expr = expr.canonical\n        variable_count = [(v.canonical if isinstance(v, Derivative) else v, c) for v, c in variable_count]\n        zero = False\n        free = expr.free_symbols\n        for v, c in variable_count:\n            vfree = v.free_symbols\n            if c.is_positive and vfree:\n                if isinstance(v, AppliedUndef):\n                    D = Dummy()\n                    if not expr.xreplace({v: D}).has(D):\n                        zero = True\n                        break\n                elif isinstance(v, MatrixExpr):\n                    zero = False\n                    break\n                elif isinstance(v, Symbol) and v not in free:\n                    zero = True\n                    break\n                elif not free & vfree:\n                    zero = True\n                    break\n        if zero:\n            return cls._get_zero_with_shape_like(expr)\n        variable_count = cls._sort_variable_count(variable_count)\n    if isinstance(expr, Derivative):\n        variable_count = list(expr.variable_count) + variable_count\n        expr = expr.expr\n        return _derivative_dispatch(expr, *variable_count, **kwargs)\n    if not evaluate or not hasattr(expr, '_eval_derivative'):\n        if evaluate and variable_count == [(expr, 1)] and expr.is_scalar:\n            return S.One\n        return Expr.__new__(cls, expr, *variable_count)\n    nderivs = 0\n    unhandled = []\n    for i, (v, count) in enumerate(variable_count):\n        old_expr = expr\n        old_v = None\n        is_symbol = v.is_symbol or isinstance(v, (Iterable, Tuple, MatrixCommon, NDimArray))\n        if not is_symbol:\n            old_v = v\n            v = Dummy('xi')\n            expr = expr.xreplace({old_v: v})\n            clashing = not (isinstance(old_v, Derivative) or isinstance(old_v, AppliedUndef))\n            if not v in expr.free_symbols and (not clashing):\n                return expr.diff(v)\n            if not old_v.is_scalar and (not hasattr(old_v, '_eval_derivative')):\n                expr *= old_v.diff(old_v)\n        obj = cls._dispatch_eval_derivative_n_times(expr, v, count)\n        if obj is not None and obj.is_zero:\n            return obj\n        nderivs += count\n        if old_v is not None:\n            if obj is not None:\n                obj = obj.subs(v, old_v)\n            expr = old_expr\n        if obj is None:\n            unhandled = variable_count[i:]\n            break\n        expr = obj\n    expr = expr.replace(lambda x: isinstance(x, Derivative), lambda x: x.canonical)\n    if unhandled:\n        if isinstance(expr, Derivative):\n            unhandled = list(expr.variable_count) + unhandled\n            expr = expr.expr\n        expr = Expr.__new__(cls, expr, *unhandled)\n    if (nderivs > 1) == True and kwargs.get('simplify', True):\n        from sympy.core.exprtools import factor_terms\n        from sympy.simplify.simplify import signsimp\n        expr = factor_terms(signsimp(expr))\n    return expr",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    cls = getattr(a, '__class__', None)\n    if cls is None:\n        cls = type(a)\n    conv = converter.get(cls, None)\n    if conv is not None:\n        return conv(a)\n    for superclass in getmro(cls):\n        try:\n            return converter[superclass](a)\n        except KeyError:\n            continue\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from ..tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(), locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        else:\n            for coerce in (float, int):\n                try:\n                    return sympify(coerce(a))\n                except (TypeError, ValueError, AttributeError, SympifyError):\n                    continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    if not isinstance(a, str):\n        try:\n            a = str(a)\n        except Exception as exc:\n            raise SympifyError(a, exc)\n        from sympy.utilities.exceptions import SymPyDeprecationWarning\n        SymPyDeprecationWarning(feature='String fallback in sympify', useinstead='sympify(str(obj)) or ' + 'sympy.core.sympify.converter or obj._sympy_', issue=18066, deprecated_since_version='1.6').warn()\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.symbol.py@@Symbol.free_symbols": "def free_symbols(self):\n    return {self}",
    ".sympy.core.expr.py@@Expr.__hash__": "def __hash__(self) -> int:\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.containers.py@@Tuple.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.containers.py@@Tuple.__len__": "def __len__(self):\n    return len(self.args)",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, str):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Argument of Integer should be of numeric type, got %s.' % i)\n    if ival == 1:\n        return S.One\n    if ival == -1:\n        return S.NegativeOne\n    if ival == 0:\n        return S.Zero\n    obj = Expr.__new__(cls)\n    obj.p = ival\n    return obj",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.symbol.py@@Symbol._diff_wrt": "def _diff_wrt(self):\n    return True",
    ".sympy.core.function.py@@Derivative._sort_variable_count": "def _sort_variable_count(cls, vc):\n    from sympy.utilities.iterables import uniq, topological_sort\n    if not vc:\n        return []\n    vc = list(vc)\n    if len(vc) == 1:\n        return [Tuple(*vc[0])]\n    V = list(range(len(vc)))\n    E = []\n    v = lambda i: vc[i][0]\n    D = Dummy()\n\n    def _block(d, v, wrt=False):\n        if d == v:\n            return wrt\n        if d.is_Symbol:\n            return False\n        if isinstance(d, Derivative):\n            if any((_block(k, v, wrt=True) for k in d._wrt_variables)):\n                return True\n            return False\n        if not wrt and isinstance(d, AppliedUndef):\n            return False\n        if v.is_Symbol:\n            return v in d.free_symbols\n        if isinstance(v, AppliedUndef):\n            return _block(d.xreplace({v: D}), D)\n        return d.free_symbols & v.free_symbols\n    for i in range(len(vc)):\n        for j in range(i):\n            if _block(v(j), v(i)):\n                E.append((j, i))\n    O = dict(zip(ordered(uniq([i for i, c in vc])), range(len(vc))))\n    ix = topological_sort((V, E), key=lambda i: O[v(i)])\n    merged = []\n    for v, c in [vc[i] for i in ix]:\n        if merged and merged[-1][0] == v:\n            merged[-1][1] += c\n        else:\n            merged.append([v, c])\n    return [Tuple(*i) for i in merged]",
    ".sympy.core.function.py@@Derivative._dispatch_eval_derivative_n_times": "def _dispatch_eval_derivative_n_times(cls, expr, v, count):\n    return expr._eval_derivative_n_times(v, count)",
    ".sympy.core.expr.py@@AtomicExpr._eval_derivative_n_times": "def _eval_derivative_n_times(self, s, n):\n    from sympy import Piecewise, Eq\n    from sympy import Tuple, MatrixExpr\n    from sympy.matrices.common import MatrixCommon\n    if isinstance(s, (MatrixCommon, Tuple, Iterable, MatrixExpr)):\n        return super()._eval_derivative_n_times(s, n)\n    if self == s:\n        return Piecewise((self, Eq(n, 0)), (1, Eq(n, 1)), (0, True))\n    else:\n        return Piecewise((self, Eq(n, 0)), (0, True))",
    ".sympy.core.expr.py@@Expr.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n        if not isinstance(other, Expr):\n            return False\n    except (SympifyError, SyntaxError):\n        return False\n    if not (self.is_Number and other.is_Number) and type(self) != type(other):\n        return False\n    a, b = (self._hashable_content(), other._hashable_content())\n    if a != b:\n        return False\n    for a, b in zip(a, b):\n        if not isinstance(a, Expr):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return {key: value for key, value in self._assumptions.items() if value is not None}",
    ".sympy.core.relational.py@@Equality.__new__": "def __new__(cls, lhs, rhs=None, **options):\n    if rhs is None:\n        SymPyDeprecationWarning(feature='Eq(expr) with rhs default to 0', useinstead='Eq(expr, 0)', issue=16587, deprecated_since_version='1.5').warn()\n        rhs = 0\n    evaluate = options.pop('evaluate', global_parameters.evaluate)\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    if evaluate:\n        val = is_eq(lhs, rhs)\n        if val is None:\n            return cls(lhs, rhs, evaluate=False)\n        else:\n            return _sympify(val)\n    return Relational.__new__(cls, lhs, rhs)",
    ".sympy.core.relational.py@@is_eq": "def is_eq(lhs, rhs):\n    from sympy.core.add import Add\n    from sympy.functions.elementary.complexes import arg\n    from sympy.simplify.simplify import clear_coefficients\n    from sympy.utilities.iterables import sift\n    for side1, side2 in ((lhs, rhs), (rhs, lhs)):\n        eval_func = getattr(side1, '_eval_Eq', None)\n        if eval_func is not None:\n            retval = eval_func(side2)\n            if retval is not None:\n                return retval\n    retval = _eval_is_eq(lhs, rhs)\n    if retval is not None:\n        return retval\n    if dispatch(type(lhs), type(rhs)) != dispatch(type(rhs), type(lhs)):\n        retval = _eval_is_eq(rhs, lhs)\n        if retval is not None:\n            return retval\n    if lhs == rhs:\n        return True\n    elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):\n        return False\n    elif not (lhs.is_Symbol or rhs.is_Symbol) and isinstance(lhs, Boolean) != isinstance(rhs, Boolean):\n        return False\n    if lhs.is_infinite or rhs.is_infinite:\n        if fuzzy_xor([lhs.is_infinite, rhs.is_infinite]):\n            return False\n        if fuzzy_xor([lhs.is_extended_real, rhs.is_extended_real]):\n            return False\n        if fuzzy_and([lhs.is_extended_real, rhs.is_extended_real]):\n            return fuzzy_xor([lhs.is_extended_positive, fuzzy_not(rhs.is_extended_positive)])\n        I = S.ImaginaryUnit\n\n        def split_real_imag(expr):\n            real_imag = lambda t: 'real' if t.is_extended_real else 'imag' if (I * t).is_extended_real else None\n            return sift(Add.make_args(expr), real_imag)\n        lhs_ri = split_real_imag(lhs)\n        if not lhs_ri[None]:\n            rhs_ri = split_real_imag(rhs)\n            if not rhs_ri[None]:\n                eq_real = Eq(Add(*lhs_ri['real']), Add(*rhs_ri['real']))\n                eq_imag = Eq(I * Add(*lhs_ri['imag']), I * Add(*rhs_ri['imag']))\n                return fuzzy_and(map(fuzzy_bool, [eq_real, eq_imag]))\n        arglhs = arg(lhs)\n        argrhs = arg(rhs)\n        if not (arglhs == S.NaN and argrhs == S.NaN):\n            return fuzzy_bool(Eq(arglhs, argrhs))\n    if all((isinstance(i, Expr) for i in (lhs, rhs))):\n        dif = lhs - rhs\n        z = dif.is_zero\n        if z is not None:\n            if z is False and dif.is_commutative:\n                return False\n            if z:\n                return True\n        n2 = _n2(lhs, rhs)\n        if n2 is not None:\n            return _sympify(n2 == 0)\n        n, d = dif.as_numer_denom()\n        rv = None\n        if n.is_zero:\n            rv = d.is_nonzero\n        elif n.is_finite:\n            if d.is_infinite:\n                rv = True\n            elif n.is_zero is False:\n                rv = d.is_infinite\n                if rv is None:\n                    l, r = clear_coefficients(d, S.Infinity)\n                    args = [_.subs(l, r) for _ in (lhs, rhs)]\n                    if args != [lhs, rhs]:\n                        rv = fuzzy_bool(Eq(*args))\n                        if rv is True:\n                            rv = None\n        elif any((a.is_infinite for a in Add.make_args(n))):\n            rv = False\n        if rv is not None:\n            return rv",
    ".sympy.multipledispatch.dispatcher.py@@Dispatcher.__call__": "def __call__(self, *args, **kwargs):\n    types = tuple([type(arg) for arg in args])\n    try:\n        func = self._cache[types]\n    except KeyError:\n        func = self.dispatch(*types)\n        if not func:\n            raise NotImplementedError('Could not find signature for %s: <%s>' % (self.name, str_signature(types)))\n        self._cache[types] = func\n    try:\n        return func(*args, **kwargs)\n    except MDNotImplementedError:\n        funcs = self.dispatch_iter(*types)\n        next(funcs)\n        for func in funcs:\n            try:\n                return func(*args, **kwargs)\n            except MDNotImplementedError:\n                pass\n        raise NotImplementedError('Matching functions for %s: <%s> found, but none completed successfully' % (self.name, str_signature(types)))",
    ".sympy.core.relational.py@@_eval_is_eq": "def _eval_is_eq(lhs, rhs):\n    return None",
    ".sympy.multipledispatch.core.py@@dispatch": "def dispatch(*types, namespace=global_namespace, on_ambiguity=ambiguity_warn):\n    types = tuple(types)\n\n    def _(func):\n        name = func.__name__\n        if ismethod(func):\n            dispatcher = inspect.currentframe().f_back.f_locals.get(name, MethodDispatcher(name))\n        else:\n            if name not in namespace:\n                namespace[name] = Dispatcher(name)\n            dispatcher = namespace[name]\n        dispatcher.add(types, func, on_ambiguity=on_ambiguity)\n        return dispatcher\n    return _",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, int):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.numbers.py@@Integer.__sub__": "def __sub__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    ".sympy.functions.elementary.piecewise.py@@Piecewise.__new__": "def __new__(cls, *args, **options):\n    if len(args) == 0:\n        raise TypeError('At least one (expr, cond) pair expected.')\n    newargs = []\n    for ec in args:\n        pair = ExprCondPair(*getattr(ec, 'args', ec))\n        cond = pair.cond\n        if cond is false:\n            continue\n        newargs.append(pair)\n        if cond is true:\n            break\n    if options.pop('evaluate', True):\n        r = cls.eval(*newargs)\n    else:\n        r = None\n    if r is None:\n        return Basic.__new__(cls, *newargs, **options)\n    else:\n        return r",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.__new__": "def __new__(cls, expr, cond):\n    expr = as_Basic(expr)\n    if cond == True:\n        return Tuple.__new__(cls, expr, true)\n    elif cond == False:\n        return Tuple.__new__(cls, expr, false)\n    elif isinstance(cond, Basic) and cond.has(Piecewise):\n        cond = piecewise_fold(cond)\n        if isinstance(cond, Piecewise):\n            cond = cond.rewrite(ITE)\n    if not isinstance(cond, Boolean):\n        raise TypeError(filldedent('\\n            Second argument must be a Boolean,\\n            not `%s`' % func_name(cond)))\n    return Tuple.__new__(cls, expr, cond)",
    ".sympy.core.basic.py@@as_Basic": "def as_Basic(expr):\n    from sympy.utilities.misc import func_name\n    try:\n        return _sympify(expr)\n    except SympifyError:\n        raise TypeError('Argument must be a Basic object, not `%s`' % func_name(expr))",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    tself = type(self)\n    tother = type(other)\n    if tself is not tother:\n        try:\n            other = _sympify(other)\n            tother = type(other)\n        except SympifyError:\n            return NotImplemented\n        if type(tself).__ne__ is not type.__ne__:\n            if tself != tother:\n                return False\n        elif tself is not tother:\n            return False\n    return self._hashable_content() == other._hashable_content()",
    ".sympy.core.basic.py@@Basic._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.functions.elementary.piecewise.py@@ExprCondPair.cond": "def cond(self):\n    return self.args[1]",
    ".sympy.functions.elementary.piecewise.py@@Piecewise.eval": "def eval(cls, *_args):\n    from sympy.functions.elementary.complexes import im, re\n    if not _args:\n        return Undefined\n    if len(_args) == 1 and _args[0][-1] == True:\n        return _args[0][0]\n    newargs = []\n    current_cond = set()\n    args = []\n    for e, c in _args:\n        if not c.is_Atom and (not isinstance(c, Relational)) and (not c.has(im, re)):\n            free = c.free_symbols\n            if len(free) == 1:\n                funcs = [i for i in c.atoms(Function) if not isinstance(i, Boolean)]\n                if len(funcs) == 1 and len(c.xreplace({list(funcs)[0]: Dummy()}).free_symbols) == 1:\n                    free = funcs\n                _c = c\n                x = free.pop()\n                try:\n                    c = c.as_set().as_relational(x)\n                except NotImplementedError:\n                    pass\n                else:\n                    reps = {}\n                    for i in c.atoms(Relational):\n                        ic = i.canonical\n                        if ic.rhs in (S.Infinity, S.NegativeInfinity):\n                            if not _c.has(ic.rhs):\n                                reps[i] = S.true\n                            elif '=' not in ic.rel_op and c.xreplace({x: i.rhs}) != _c.xreplace({x: i.rhs}):\n                                reps[i] = Relational(i.lhs, i.rhs, i.rel_op + '=')\n                    c = c.xreplace(reps)\n        args.append((e, _canonical(c)))\n    for expr, cond in args:\n        if isinstance(expr, Piecewise):\n            unmatching = []\n            for i, (e, c) in enumerate(expr.args):\n                if c in current_cond:\n                    continue\n                if c == cond:\n                    if c != True:\n                        if unmatching:\n                            expr = Piecewise(*unmatching + [(e, c)])\n                        else:\n                            expr = e\n                    break\n                else:\n                    unmatching.append((e, c))\n        got = False\n        for i in [cond] + (list(cond.args) if isinstance(cond, And) else []):\n            if i in current_cond:\n                got = True\n                break\n        if got:\n            continue\n        if isinstance(cond, And):\n            nonredundant = []\n            for c in cond.args:\n                if isinstance(c, Relational) and c.negated.canonical in current_cond:\n                    continue\n                nonredundant.append(c)\n            cond = cond.func(*nonredundant)\n        elif isinstance(cond, Relational):\n            if cond.negated.canonical in current_cond:\n                cond = S.true\n        current_cond.add(cond)\n        if newargs:\n            if newargs[-1].expr == expr:\n                orcond = Or(cond, newargs[-1].cond)\n                if isinstance(orcond, (And, Or)):\n                    orcond = distribute_and_over_or(orcond)\n                newargs[-1] = ExprCondPair(expr, orcond)\n                continue\n            elif newargs[-1].cond == cond:\n                newargs[-1] = ExprCondPair(expr, cond)\n                continue\n        newargs.append(ExprCondPair(expr, cond))\n    missing = len(newargs) != len(_args)\n    same = all((a == b for a, b in zip(newargs, _args)))\n    if not newargs:\n        raise ValueError(filldedent('\\n            There are no conditions (or none that\\n            are not trivially false) to define an\\n            expression.'))\n    if missing or not same:\n        return cls(*newargs)",
    ".sympy.core.containers.py@@Tuple.__getitem__": "def __getitem__(self, i):\n    if isinstance(i, slice):\n        indices = i.indices(len(self))\n        return Tuple(*(self.args[j] for j in range(*indices)))\n    return self.args[i]",
    ".sympy.core.numbers.py@@Integer.__radd__": "def __radd__(self, other):\n    if global_parameters.evaluate:\n        if isinstance(other, int):\n            return Integer(other + self.p)\n        elif isinstance(other, Rational):\n            return Rational(other.p + self.p * other.q, other.q, 1)\n        return Rational.__radd__(self, other)\n    return Rational.__radd__(self, other)",
    ".sympy.core.basic.py@@Basic.replace": "def replace(self, query, value, map=False, simultaneous=True, exact=None):\n    from sympy.core.symbol import Wild\n    try:\n        query = _sympify(query)\n    except SympifyError:\n        pass\n    try:\n        value = _sympify(value)\n    except SympifyError:\n        pass\n    if isinstance(query, type):\n        _query = lambda expr: isinstance(expr, query)\n        if isinstance(value, type):\n            _value = lambda expr, result: value(*expr.args)\n        elif callable(value):\n            _value = lambda expr, result: value(*expr.args)\n        else:\n            raise TypeError('given a type, replace() expects another type or a callable')\n    elif isinstance(query, Basic):\n        _query = lambda expr: expr.match(query)\n        if exact is None:\n            exact = len(query.atoms(Wild)) > 1\n        if isinstance(value, Basic):\n            if exact:\n                _value = lambda expr, result: value.subs(result) if all(result.values()) else expr\n            else:\n                _value = lambda expr, result: value.subs(result)\n        elif callable(value):\n            if exact:\n                _value = lambda expr, result: value(**{str(k)[:-1]: v for k, v in result.items()}) if all((val for val in result.values())) else expr\n            else:\n                _value = lambda expr, result: value(**{str(k)[:-1]: v for k, v in result.items()})\n        else:\n            raise TypeError('given an expression, replace() expects another expression or a callable')\n    elif callable(query):\n        _query = query\n        if callable(value):\n            _value = lambda expr, result: value(expr)\n        else:\n            raise TypeError('given a callable, replace() expects another callable')\n    else:\n        raise TypeError('first argument to replace() must be a type, an expression or a callable')\n\n    def walk(rv, F):\n        args = getattr(rv, 'args', None)\n        if args is not None:\n            if args:\n                newargs = tuple([walk(a, F) for a in args])\n                if args != newargs:\n                    rv = rv.func(*newargs)\n                    if simultaneous:\n                        for i, e in enumerate(args):\n                            if rv == e and e != newargs[i]:\n                                return rv\n            rv = F(rv)\n        return rv\n    mapping = {}\n\n    def rec_replace(expr):\n        result = _query(expr)\n        if result or result == {}:\n            v = _value(expr, result)\n            if v is not None and v != expr:\n                if map:\n                    mapping[expr] = v\n                expr = v\n        return expr\n    rv = walk(self, rec_replace)\n    return (rv, mapping) if map else rv",
    ".sympy.core.sympify.py@@_is_numpy_instance": "def _is_numpy_instance(a):\n    return any((type_.__module__ == 'numpy' for type_ in type(a).__mro__))",
    ".sympy.core.sympify.py@@SympifyError.__init__": "def __init__(self, expr, base_exc=None):\n    self.expr = expr\n    self.base_exc = base_exc",
    ".sympy.core.basic.py@@Basic.walk": "def walk(rv, F):\n    args = getattr(rv, 'args', None)\n    if args is not None:\n        if args:\n            newargs = tuple([walk(a, F) for a in args])\n            if args != newargs:\n                rv = rv.func(*newargs)\n                if simultaneous:\n                    for i, e in enumerate(args):\n                        if rv == e and e != newargs[i]:\n                            return rv\n        rv = F(rv)\n    return rv",
    ".sympy.core.basic.py@@Basic.rec_replace": "def rec_replace(expr):\n    result = _query(expr)\n    if result or result == {}:\n        v = _value(expr, result)\n        if v is not None and v != expr:\n            if map:\n                mapping[expr] = v\n            expr = v\n    return expr",
    ".sympy.core.numbers.py@@Integer.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    if other.is_Integer:\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    ".sympy.core.function.py@@Derivative._get_zero_with_shape_like": "def _get_zero_with_shape_like(cls, expr):\n    return S.Zero",
    ".sympy.matrices.immutable.py@@ImmutableDenseMatrix._new": "def _new(cls, *args, **kwargs):\n    if len(args) == 1 and isinstance(args[0], ImmutableDenseMatrix):\n        return args[0]\n    if kwargs.get('copy', True) is False:\n        if len(args) != 3:\n            raise TypeError(\"'copy=False' requires a matrix be initialized as rows,cols,[list]\")\n        rows, cols, flat_list = args\n    else:\n        rows, cols, flat_list = cls._handle_creation_inputs(*args, **kwargs)\n        flat_list = list(flat_list)\n    obj = Basic.__new__(cls, Integer(rows), Integer(cols), Tuple(*flat_list))\n    obj._rows = rows\n    obj._cols = cols\n    obj._mat = flat_list\n    return obj",
    ".sympy.matrices.matrices.py@@MatrixBase._handle_creation_inputs": "def _handle_creation_inputs(cls, *args, **kwargs):\n    from sympy.matrices.sparse import SparseMatrix\n    from sympy.matrices.expressions.matexpr import MatrixSymbol\n    from sympy.matrices.expressions.blockmatrix import BlockMatrix\n    from sympy.utilities.iterables import reshape\n    flat_list = None\n    if len(args) == 1:\n        if isinstance(args[0], SparseMatrix):\n            return (args[0].rows, args[0].cols, flatten(args[0].tolist()))\n        elif isinstance(args[0], MatrixBase):\n            return (args[0].rows, args[0].cols, args[0]._mat)\n        elif isinstance(args[0], Basic) and args[0].is_Matrix:\n            return (args[0].rows, args[0].cols, args[0].as_explicit()._mat)\n        elif isinstance(args[0], mp.matrix):\n            M = args[0]\n            flat_list = [cls._sympify(x) for x in M]\n            return (M.rows, M.cols, flat_list)\n        elif hasattr(args[0], '__array__'):\n            return cls._handle_ndarray(args[0])\n        elif is_sequence(args[0]) and (not isinstance(args[0], DeferredVector)):\n            dat = list(args[0])\n            ismat = lambda i: isinstance(i, MatrixBase) and (evaluate or isinstance(i, BlockMatrix) or isinstance(i, MatrixSymbol))\n            raw = lambda i: is_sequence(i) and (not ismat(i))\n            evaluate = kwargs.get('evaluate', True)\n            if evaluate:\n\n                def do(x):\n                    if isinstance(x, (list, tuple)):\n                        return type(x)([do(i) for i in x])\n                    if isinstance(x, BlockMatrix) or (isinstance(x, MatrixSymbol) and all((_.is_Integer for _ in x.shape))):\n                        return x.as_explicit()\n                    return x\n                dat = do(dat)\n            if dat == [] or dat == [[]]:\n                rows = cols = 0\n                flat_list = []\n            elif not any((raw(i) or ismat(i) for i in dat)):\n                flat_list = [cls._sympify(i) for i in dat]\n                rows = len(flat_list)\n                cols = 1 if rows else 0\n            elif evaluate and all((ismat(i) for i in dat)):\n                ncol = {i.cols for i in dat if any(i.shape)}\n                if ncol:\n                    if len(ncol) != 1:\n                        raise ValueError('mismatched dimensions')\n                    flat_list = [_ for i in dat for r in i.tolist() for _ in r]\n                    cols = ncol.pop()\n                    rows = len(flat_list) // cols\n                else:\n                    rows = cols = 0\n                    flat_list = []\n            elif evaluate and any((ismat(i) for i in dat)):\n                ncol = set()\n                flat_list = []\n                for i in dat:\n                    if ismat(i):\n                        flat_list.extend([k for j in i.tolist() for k in j])\n                        if any(i.shape):\n                            ncol.add(i.cols)\n                    elif raw(i):\n                        if i:\n                            ncol.add(len(i))\n                            flat_list.extend(i)\n                    else:\n                        ncol.add(1)\n                        flat_list.append(i)\n                    if len(ncol) > 1:\n                        raise ValueError('mismatched dimensions')\n                cols = ncol.pop()\n                rows = len(flat_list) // cols\n            else:\n                flat_list = []\n                ncol = set()\n                rows = cols = 0\n                for row in dat:\n                    if not is_sequence(row) and (not getattr(row, 'is_Matrix', False)):\n                        raise ValueError('expecting list of lists')\n                    if hasattr(row, '__array__'):\n                        if 0 in row.shape:\n                            continue\n                    elif not row:\n                        continue\n                    if evaluate and all((ismat(i) for i in row)):\n                        r, c, flatT = cls._handle_creation_inputs([i.T for i in row])\n                        T = reshape(flatT, [c])\n                        flat = [T[i][j] for j in range(c) for i in range(r)]\n                        r, c = (c, r)\n                    else:\n                        r = 1\n                        if getattr(row, 'is_Matrix', False):\n                            c = 1\n                            flat = [row]\n                        else:\n                            c = len(row)\n                            flat = [cls._sympify(i) for i in row]\n                    ncol.add(c)\n                    if len(ncol) > 1:\n                        raise ValueError('mismatched dimensions')\n                    flat_list.extend(flat)\n                    rows += r\n                cols = ncol.pop() if ncol else 0\n    elif len(args) == 3:\n        rows = as_int(args[0])\n        cols = as_int(args[1])\n        if rows < 0 or cols < 0:\n            raise ValueError('Cannot create a {} x {} matrix. Both dimensions must be positive'.format(rows, cols))\n        if len(args) == 3 and isinstance(args[2], Callable):\n            op = args[2]\n            flat_list = []\n            for i in range(rows):\n                flat_list.extend([cls._sympify(op(cls._sympify(i), cls._sympify(j))) for j in range(cols)])\n        elif len(args) == 3 and is_sequence(args[2]):\n            flat_list = args[2]\n            if len(flat_list) != rows * cols:\n                raise ValueError('List length should be equal to rows*columns')\n            flat_list = [cls._sympify(i) for i in flat_list]\n    elif len(args) == 0:\n        rows = cols = 0\n        flat_list = []\n    if flat_list is None:\n        raise TypeError(filldedent('\\n            Data type not understood; expecting list of lists\\n            or lists of values.'))\n    return (rows, cols, flat_list)",
    ".sympy.core.compatibility.py@@as_int": "def as_int(n, strict=True):\n    if strict:\n        try:\n            if type(n) is bool:\n                raise TypeError\n            return operator.index(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n    else:\n        try:\n            result = int(n)\n        except TypeError:\n            raise ValueError('%s is not an integer' % (n,))\n        if n != result:\n            raise ValueError('%s is not an integer' % (n,))\n        return result",
    ".sympy.core.compatibility.py@@is_sequence": "def is_sequence(i, include=None):\n    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))",
    ".sympy.core.compatibility.py@@iterable": "def iterable(i, exclude=(str, dict, NotIterable)):\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    ".sympy.matrices.expressions.matexpr.py@@_LeftRightArgs.__init__": "def __init__(self, lines, higher=S.One):\n    self._lines = [i for i in lines]\n    self._first_pointer_parent = self._lines\n    self._first_pointer_index = 0\n    self._first_line_index = 0\n    self._second_pointer_parent = self._lines\n    self._second_pointer_index = 1\n    self._second_line_index = 1\n    self.higher = higher",
    ".sympy.matrices.expressions.matexpr.py@@_LeftRightArgs.build": "def build(self):\n    data = [self._build(i) for i in self._lines]\n    if self.higher != 1:\n        data += [self._build(self.higher)]\n    data = [i for i in data]\n    return data",
    ".sympy.matrices.expressions.matexpr.py@@_LeftRightArgs._build": "def _build(expr):\n    from sympy.core.expr import ExprBuilder\n    if isinstance(expr, ExprBuilder):\n        return expr.build()\n    if isinstance(expr, list):\n        if len(expr) == 1:\n            return expr[0]\n        else:\n            return expr[0](*[_LeftRightArgs._build(i) for i in expr[1]])\n    else:\n        return expr",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self == other",
    ".sympy.matrices.dense.py@@DenseMatrix.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return NotImplemented\n    self_shape = getattr(self, 'shape', None)\n    other_shape = getattr(other, 'shape', None)\n    if None in (self_shape, other_shape):\n        return False\n    if self_shape != other_shape:\n        return False\n    if isinstance(other, Matrix):\n        return _compare_sequence(self._mat, other._mat)\n    elif isinstance(other, MatrixBase):\n        return _compare_sequence(self._mat, Matrix(other)._mat)",
    ".sympy.matrices.immutable.py@@ImmutableDenseMatrix.shape": "def shape(self):\n    return (self._rows, self._cols)",
    ".sympy.core.assumptions.py@@ManagedProperties.__init__": "def __init__(cls, *args, **kws):\n    BasicMeta.__init__(cls, *args, **kws)\n    local_defs = {}\n    for k in _assume_defined:\n        attrname = as_property(k)\n        v = cls.__dict__.get(attrname, '')\n        if isinstance(v, (bool, int, type(None))):\n            if v is not None:\n                v = bool(v)\n            local_defs[k] = v\n    defs = {}\n    for base in reversed(cls.__bases__):\n        assumptions = getattr(base, '_explicit_class_assumptions', None)\n        if assumptions is not None:\n            defs.update(assumptions)\n    defs.update(local_defs)\n    cls._explicit_class_assumptions = defs\n    cls.default_assumptions = StdFactKB(defs)\n    cls._prop_handler = {}\n    for k in _assume_defined:\n        eval_is_meth = getattr(cls, '_eval_is_%s' % k, None)\n        if eval_is_meth is not None:\n            cls._prop_handler[k] = eval_is_meth\n    for k, v in cls.default_assumptions.items():\n        setattr(cls, as_property(k), v)\n    derived_from_bases = set()\n    for base in cls.__bases__:\n        default_assumptions = getattr(base, 'default_assumptions', None)\n        if default_assumptions is not None:\n            derived_from_bases.update(default_assumptions)\n    for fact in derived_from_bases - set(cls.default_assumptions):\n        pname = as_property(fact)\n        if pname not in cls.__dict__:\n            setattr(cls, pname, make_property(fact))\n    for fact in _assume_defined:\n        pname = as_property(fact)\n        if not hasattr(cls, pname):\n            setattr(cls, pname, make_property(fact))",
    ".sympy.core.core.py@@BasicMeta.__init__": "def __init__(cls, *args, **kws):\n    all_classes.add(cls)\n    cls.__sympy__ = property(lambda self: True)",
    ".sympy.core.assumptions.py@@as_property": "def as_property(fact):\n    return 'is_%s' % fact",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    super().__init__(_assume_rules)\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.__init__": "def __init__(self, rules):\n    self.rules = rules",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.tensor.array.expressions.conv_array_to_matrix.py@@convert_array_to_matrix": "def convert_array_to_matrix(expr):\n    rec = _array2matrix(expr)\n    rec, removed = _remove_trivial_dims(rec)\n    return rec",
    ".sympy.tensor.array.expressions.conv_array_to_matrix.py@@_array2matrix": "def _array2matrix(expr):\n    return expr",
    ".sympy.tensor.array.expressions.conv_array_to_matrix.py@@_remove_trivial_dims": "def _remove_trivial_dims(expr):\n    return (expr, [])"
}