{
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.symbol.py@@Dummy._hashable_content": "def _hashable_content(self):\n    return Symbol._hashable_content(self) + (self.dummy_index,)",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return dict(((key, value) for key, value in self._assumptions.items() if value is not None))",
    ".sympy.core.numbers.py@@NegativeInfinity.__hash__": "def __hash__(self):\n    return super(NegativeInfinity, self).__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super(Number, self).__hash__()",
    ".sympy.core.basic.py@@Basic._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.numbers.py@@Infinity.__hash__": "def __hash__(self):\n    return super(Infinity, self).__hash__()",
    ".sympy.logic.boolalg.py@@BooleanTrue.__hash__": "def __hash__(self):\n    return hash(True)",
    ".sympy.core.numbers.py@@Rational.__hash__": "def __hash__(self):\n    return super(Rational, self).__hash__()",
    ".sympy.core.numbers.py@@Rational._hashable_content": "def _hashable_content(self):\n    return (self.p, self.q)",
    ".sympy.core.numbers.py@@NaN.__hash__": "def __hash__(self):\n    return super(NaN, self).__hash__()",
    ".sympy.core.numbers.py@@Float.__hash__": "def __hash__(self):\n    return super(Float, self).__hash__()",
    ".sympy.core.numbers.py@@Float._hashable_content": "def _hashable_content(self):\n    return (self._mpf_, self._prec)",
    ".sympy.core.numbers.py@@NumberSymbol.__hash__": "def __hash__(self):\n    return super(NumberSymbol, self).__hash__()",
    ".sympy.polys.polytools.py@@Poly.__hash__": "def __hash__(self):\n    return super(Poly, self).__hash__()",
    ".sympy.polys.polytools.py@@Poly._hashable_content": "def _hashable_content(self):\n    return (self.rep, self.gens)",
    ".sympy.polys.polyclasses.py@@DMP.__hash__": "def __hash__(f):\n    return hash((f.__class__.__name__, f.to_tuple(), f.lev, f.dom, f.ring))",
    ".sympy.polys.polyclasses.py@@DMP.to_tuple": "def to_tuple(f):\n    return dmp_to_tuple(f.rep, f.lev)",
    ".sympy.polys.densebasic.py@@dmp_to_tuple": "def dmp_to_tuple(f, u):\n    if not u:\n        return tuple(f)\n    v = u - 1\n    return tuple((dmp_to_tuple(c, v) for c in f))",
    ".sympy.polys.domains.domain.py@@Domain.__hash__": "def __hash__(self):\n    return hash((self.__class__.__name__, self.dtype))",
    ".sympy.core.symbol.py@@Wild._hashable_content": "def _hashable_content(self):\n    return super(Wild, self)._hashable_content() + (self.exclude, self.properties)",
    ".sympy.geometry.point.py@@Point.__hash__": "def __hash__(self):\n    return hash(self.args)",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.logic.boolalg.py@@BooleanFalse.__hash__": "def __hash__(self):\n    return hash(False)",
    ".sympy.matrices.expressions.matexpr.py@@MatrixSymbol._hashable_content": "def _hashable_content(self):\n    return (self.name, self.shape)",
    ".sympy.matrices.expressions.matexpr.py@@MatrixSymbol.name": "def name(self):\n    return self.args[0]",
    ".sympy.matrices.expressions.matexpr.py@@MatrixSymbol.shape": "def shape(self):\n    return self.args[1:3]",
    ".sympy.core.containers.py@@Tuple.__hash__": "def __hash__(self):\n    return hash(self.args)",
    ".sympy.sets.sets.py@@FiniteSet._hashable_content": "def _hashable_content(self):\n    return (self._elements,)",
    ".sympy.matrices.immutable.py@@ImmutableSparseMatrix.__hash__": "def __hash__(self):\n    return hash((type(self).__name__,) + (self.shape, tuple(self._smat)))",
    ".sympy.matrices.matrices.py@@MatrixBase.shape": "def shape(self):\n    return (self.rows, self.cols)",
    ".sympy.physics.units.py@@Unit.__hash__": "def __hash__(self):\n    return super(Unit, self).__hash__()",
    ".sympy.physics.units.py@@Unit._hashable_content": "def _hashable_content(self):\n    return (self.name, self.abbrev)",
    ".sympy.combinatorics.permutations.py@@Permutation._hashable_content": "def _hashable_content(self):\n    return tuple(self.array_form)",
    ".sympy.combinatorics.permutations.py@@Permutation.array_form": "def array_form(self):\n    return self._array_form[:]",
    ".sympy.polys.polytools.py@@PurePoly.__hash__": "def __hash__(self):\n    return super(PurePoly, self).__hash__()",
    ".sympy.polys.rootoftools.py@@ComplexRootOf._hashable_content": "def _hashable_content(self):\n    return (self.poly, self.index)",
    ".sympy.polys.rootoftools.py@@RootSum._hashable_content": "def _hashable_content(self):\n    return (self.poly, self.fun)",
    ".sympy.polys.polytools.py@@PurePoly._hashable_content": "def _hashable_content(self):\n    return (self.rep,)",
    ".sympy.core.function.py@@Lambda.__hash__": "def __hash__(self):\n    return super(Lambda, self).__hash__()",
    ".sympy.core.function.py@@Lambda._hashable_content": "def _hashable_content(self):\n    return (self.expr.xreplace(self.canonical_variables),)",
    ".sympy.core.function.py@@Lambda.expr": "def expr(self):\n    return self._args[1]",
    ".sympy.core.basic.py@@Basic.canonical_variables": "def canonical_variables(self):\n    from sympy import Symbol\n    if not hasattr(self, 'variables'):\n        return {}\n    u = '_'\n    while any((s.name.endswith(u) for s in self.free_symbols)):\n        u += '_'\n    name = '%%i%s' % u\n    V = self.variables\n    return dict(list(zip(V, [Symbol(name % i, **v.assumptions0) for i, v in enumerate(V)])))",
    ".sympy.core.function.py@@Lambda.variables": "def variables(self):\n    return self._args[0]",
    ".sympy.core.function.py@@Lambda.free_symbols": "def free_symbols(self):\n    return self.expr.free_symbols - set(self.variables)",
    ".sympy.core.symbol.py@@Symbol.free_symbols": "def free_symbols(self):\n    return {self}",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.symbol.py@@Symbol.__new__": "def __new__(cls, name, **assumptions):\n    cls._sanitize(assumptions, cls)\n    return Symbol.__xnew_cached_(cls, name, **assumptions)",
    ".sympy.core.symbol.py@@Symbol._sanitize": "def _sanitize(assumptions, obj=None):\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    if is_commutative is None:\n        whose = '%s ' % obj.__name__ if obj else ''\n        raise ValueError('%scommutativity must be True or False.' % whose)\n    for key in list(assumptions.keys()):\n        from collections import defaultdict\n        from sympy.utilities.exceptions import SymPyDeprecationWarning\n        keymap = defaultdict(lambda: None)\n        keymap.update({'bounded': 'finite', 'unbounded': 'infinite', 'infinitesimal': 'zero'})\n        if keymap[key]:\n            SymPyDeprecationWarning(feature='%s assumption' % key, useinstead='%s' % keymap[key], issue=8071, deprecated_since_version='0.7.6').warn()\n            assumptions[keymap[key]] = assumptions[key]\n            assumptions.pop(key)\n            key = keymap[key]\n        v = assumptions[key]\n        if v is None:\n            assumptions.pop(key)\n            continue\n        assumptions[key] = bool(v)",
    ".sympy.core.logic.py@@fuzzy_bool": "def fuzzy_bool(x):\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    ".sympy.core.symbol.py@@Symbol.__new_stage2__": "def __new_stage2__(cls, name, **assumptions):\n    if not isinstance(name, string_types):\n        raise TypeError('name should be a string, not %s' % repr(type(name)))\n    obj = Expr.__new__(cls)\n    obj.name = name\n    tmp_asm_copy = assumptions.copy()\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    assumptions['commutative'] = is_commutative\n    obj._assumptions = StdFactKB(assumptions)\n    obj._assumptions._generator = tmp_asm_copy\n    return obj",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.basic.py@@Atom.xreplace": "def xreplace(self, rule, hack2=False):\n    return rule.get(self, self)",
    ".sympy.stats.rv.py@@RandomSymbol._hashable_content": "def _hashable_content(self):\n    return (self.pspace, self.symbol)"
}