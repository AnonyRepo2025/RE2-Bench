{
    ".lib.matplotlib.colors.py@@ListedColormap._init": "def _init(self):\n    self._lut = np.zeros((self.N + 3, 4), float)\n    self._lut[:-3] = to_rgba_array(self.colors)\n    self._isinit = True\n    self._set_extremes()",
    ".lib.matplotlib.colors.py@@to_rgba_array": "def to_rgba_array(c, alpha=None):\n    if isinstance(c, tuple) and len(c) == 2:\n        if alpha is None:\n            c, alpha = c\n        else:\n            c = c[0]\n    if np.iterable(alpha):\n        alpha = np.asarray(alpha).ravel()\n    if isinstance(c, np.ndarray) and c.dtype.kind in 'if' and (c.ndim == 2) and (c.shape[1] in [3, 4]):\n        mask = c.mask.any(axis=1) if np.ma.is_masked(c) else None\n        c = np.ma.getdata(c)\n        if np.iterable(alpha):\n            if c.shape[0] == 1 and alpha.shape[0] > 1:\n                c = np.tile(c, (alpha.shape[0], 1))\n            elif c.shape[0] != alpha.shape[0]:\n                raise ValueError('The number of colors must match the number of alpha values if there are more than one of each.')\n        if c.shape[1] == 3:\n            result = np.column_stack([c, np.zeros(len(c))])\n            result[:, -1] = alpha if alpha is not None else 1.0\n        elif c.shape[1] == 4:\n            result = c.copy()\n            if alpha is not None:\n                result[:, -1] = alpha\n        if mask is not None:\n            result[mask] = 0\n        if np.any((result < 0) | (result > 1)):\n            raise ValueError('RGBA values should be within 0-1 range')\n        return result\n    if cbook._str_lower_equal(c, 'none'):\n        return np.zeros((0, 4), float)\n    try:\n        if np.iterable(alpha):\n            return np.array([to_rgba(c, a) for a in alpha], float)\n        else:\n            return np.array([to_rgba(c, alpha)], float)\n    except TypeError:\n        pass\n    except ValueError as e:\n        if e.args == (\"'alpha' must be between 0 and 1, inclusive\",):\n            raise e\n    if isinstance(c, str):\n        raise ValueError(f'{c!r} is not a valid color value.')\n    if len(c) == 0:\n        return np.zeros((0, 4), float)\n    if isinstance(c, Sequence):\n        lens = {len(cc) if isinstance(cc, (list, tuple)) else -1 for cc in c}\n        if lens == {3}:\n            rgba = np.column_stack([c, np.ones(len(c))])\n        elif lens == {4}:\n            rgba = np.array(c)\n        else:\n            rgba = np.array([to_rgba(cc) for cc in c])\n    else:\n        rgba = np.array([to_rgba(cc) for cc in c])\n    if alpha is not None:\n        rgba[:, 3] = alpha\n    return rgba",
    ".lib.matplotlib.cbook.py@@_str_lower_equal": "def _str_lower_equal(obj, s):\n    return isinstance(obj, str) and obj.lower() == s",
    ".lib.matplotlib.colors.py@@to_rgba": "def to_rgba(c, alpha=None):\n    if _is_nth_color(c):\n        prop_cycler = mpl.rcParams['axes.prop_cycle']\n        colors = prop_cycler.by_key().get('color', ['k'])\n        c = colors[int(c[1:]) % len(colors)]\n    try:\n        rgba = _colors_full_map.cache[c, alpha]\n    except (KeyError, TypeError):\n        rgba = None\n    if rgba is None:\n        rgba = _to_rgba_no_colorcycle(c, alpha)\n        try:\n            _colors_full_map.cache[c, alpha] = rgba\n        except TypeError:\n            pass\n    return rgba",
    ".lib.matplotlib.colors.py@@_is_nth_color": "def _is_nth_color(c):\n    return isinstance(c, str) and re.match('\\\\AC[0-9]+\\\\Z', c)",
    ".lib.matplotlib.colors.py@@_to_rgba_no_colorcycle": "def _to_rgba_no_colorcycle(c, alpha=None):\n    if isinstance(c, tuple) and len(c) == 2:\n        if alpha is None:\n            c, alpha = c\n        else:\n            c = c[0]\n    if alpha is not None and (not 0 <= alpha <= 1):\n        raise ValueError(\"'alpha' must be between 0 and 1, inclusive\")\n    orig_c = c\n    if c is np.ma.masked:\n        return (0.0, 0.0, 0.0, 0.0)\n    if isinstance(c, str):\n        if c.lower() == 'none':\n            return (0.0, 0.0, 0.0, 0.0)\n        try:\n            c = _colors_full_map[c]\n        except KeyError:\n            if len(orig_c) != 1:\n                try:\n                    c = _colors_full_map[c.lower()]\n                except KeyError:\n                    pass\n    if isinstance(c, str):\n        match = re.match('\\\\A#[a-fA-F0-9]{6}\\\\Z', c)\n        if match:\n            return tuple((int(n, 16) / 255 for n in [c[1:3], c[3:5], c[5:7]])) + (alpha if alpha is not None else 1.0,)\n        match = re.match('\\\\A#[a-fA-F0-9]{3}\\\\Z', c)\n        if match:\n            return tuple((int(n, 16) / 255 for n in [c[1] * 2, c[2] * 2, c[3] * 2])) + (alpha if alpha is not None else 1.0,)\n        match = re.match('\\\\A#[a-fA-F0-9]{8}\\\\Z', c)\n        if match:\n            color = [int(n, 16) / 255 for n in [c[1:3], c[3:5], c[5:7], c[7:9]]]\n            if alpha is not None:\n                color[-1] = alpha\n            return tuple(color)\n        match = re.match('\\\\A#[a-fA-F0-9]{4}\\\\Z', c)\n        if match:\n            color = [int(n, 16) / 255 for n in [c[1] * 2, c[2] * 2, c[3] * 2, c[4] * 2]]\n            if alpha is not None:\n                color[-1] = alpha\n            return tuple(color)\n        try:\n            c = float(c)\n        except ValueError:\n            pass\n        else:\n            if not 0 <= c <= 1:\n                raise ValueError(f'Invalid string grayscale value {orig_c!r}. Value must be within 0-1 range')\n            return (c, c, c, alpha if alpha is not None else 1.0)\n        raise ValueError(f'Invalid RGBA argument: {orig_c!r}')\n    if isinstance(c, np.ndarray):\n        if c.ndim == 2 and c.shape[0] == 1:\n            c = c.reshape(-1)\n    if not np.iterable(c):\n        raise ValueError(f'Invalid RGBA argument: {orig_c!r}')\n    if len(c) not in [3, 4]:\n        raise ValueError('RGBA sequence should have length 3 or 4')\n    if not all((isinstance(x, Real) for x in c)):\n        raise ValueError(f'Invalid RGBA argument: {orig_c!r}')\n    c = tuple(map(float, c))\n    if len(c) == 3 and alpha is None:\n        alpha = 1\n    if alpha is not None:\n        c = c[:3] + (alpha,)\n    if any((elem < 0 or elem > 1 for elem in c)):\n        raise ValueError('RGBA values should be within 0-1 range')\n    return c",
    ".lib.matplotlib.colors.py@@LinearSegmentedColormap._init": "def _init(self):\n    self._lut = np.ones((self.N + 3, 4), float)\n    self._lut[:-3, 0] = _create_lookup_table(self.N, self._segmentdata['red'], self._gamma)\n    self._lut[:-3, 1] = _create_lookup_table(self.N, self._segmentdata['green'], self._gamma)\n    self._lut[:-3, 2] = _create_lookup_table(self.N, self._segmentdata['blue'], self._gamma)\n    if 'alpha' in self._segmentdata:\n        self._lut[:-3, 3] = _create_lookup_table(self.N, self._segmentdata['alpha'], 1)\n    self._isinit = True\n    self._set_extremes()",
    ".lib.matplotlib.colors.py@@_create_lookup_table": "def _create_lookup_table(N, data, gamma=1.0):\n    if callable(data):\n        xind = np.linspace(0, 1, N) ** gamma\n        lut = np.clip(np.array(data(xind), dtype=float), 0, 1)\n        return lut\n    try:\n        adata = np.array(data)\n    except Exception as err:\n        raise TypeError('data must be convertible to an array') from err\n    _api.check_shape((None, 3), data=adata)\n    x = adata[:, 0]\n    y0 = adata[:, 1]\n    y1 = adata[:, 2]\n    if x[0] != 0.0 or x[-1] != 1.0:\n        raise ValueError('data mapping points must start with x=0 and end with x=1')\n    if (np.diff(x) < 0).any():\n        raise ValueError('data mapping points must have x in increasing order')\n    if N == 1:\n        lut = np.array(y0[-1])\n    else:\n        x = x * (N - 1)\n        xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n        ind = np.searchsorted(x, xind)[1:-1]\n        distance = (xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])\n        lut = np.concatenate([[y1[0]], distance * (y0[ind] - y1[ind - 1]) + y1[ind - 1], [y0[-1]]])\n    return np.clip(lut, 0.0, 1.0)",
    ".lib.matplotlib._api.__init__.py@@check_shape": "def check_shape(shape, /, **kwargs):\n    for k, v in kwargs.items():\n        data_shape = v.shape\n        if len(data_shape) != len(shape) or any((s != t and t is not None for s, t in zip(data_shape, shape))):\n            dim_labels = iter(itertools.chain('MNLIJKLH', (f'D{i}' for i in itertools.count())))\n            text_shape = ', '.join((str(n) if n is not None else next(dim_labels) for n in shape))\n            if len(shape) == 1:\n                text_shape += ','\n            raise ValueError(f'{k!r} must be {len(shape)}D with shape ({text_shape}), but your input has shape {v.shape}')"
}