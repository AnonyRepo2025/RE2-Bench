{
    ".sklearn.metrics._classification.py@@_check_targets": "def _check_targets(y_true, y_pred):\n    check_consistent_length(y_true, y_pred)\n    type_true = type_of_target(y_true)\n    type_pred = type_of_target(y_pred)\n    y_type = {type_true, type_pred}\n    if y_type == {'binary', 'multiclass'}:\n        y_type = {'multiclass'}\n    if len(y_type) > 1:\n        raise ValueError(\"Classification metrics can't handle a mix of {0} and {1} targets\".format(type_true, type_pred))\n    y_type = y_type.pop()\n    if y_type not in ['binary', 'multiclass', 'multilabel-indicator']:\n        raise ValueError('{0} is not supported'.format(y_type))\n    if y_type in ['binary', 'multiclass']:\n        y_true = column_or_1d(y_true)\n        y_pred = column_or_1d(y_pred)\n        if y_type == 'binary':\n            unique_values = np.union1d(y_true, y_pred)\n            if len(unique_values) > 2:\n                y_type = 'multiclass'\n    if y_type.startswith('multilabel'):\n        y_true = csr_matrix(y_true)\n        y_pred = csr_matrix(y_pred)\n        y_type = 'multilabel-indicator'\n    return (y_type, y_true, y_pred)",
    ".sklearn.utils.validation.py@@check_consistent_length": "def check_consistent_length(*arrays):\n    lengths = [_num_samples(X) for X in arrays if X is not None]\n    uniques = np.unique(lengths)\n    if len(uniques) > 1:\n        raise ValueError('Found input variables with inconsistent numbers of samples: %r' % [int(l) for l in lengths])",
    ".sklearn.utils.validation.py@@_num_samples": "def _num_samples(x):\n    message = 'Expected sequence or array-like, got %s' % type(x)\n    if hasattr(x, 'fit') and callable(x.fit):\n        raise TypeError(message)\n    if not hasattr(x, '__len__') and (not hasattr(x, 'shape')):\n        if hasattr(x, '__array__'):\n            x = np.asarray(x)\n        else:\n            raise TypeError(message)\n    if hasattr(x, 'shape') and x.shape is not None:\n        if len(x.shape) == 0:\n            raise TypeError('Singleton array %r cannot be considered a valid collection.' % x)\n        if isinstance(x.shape[0], numbers.Integral):\n            return x.shape[0]\n    try:\n        return len(x)\n    except TypeError:\n        raise TypeError(message)",
    ".sklearn.utils.multiclass.py@@type_of_target": "def type_of_target(y):\n    valid = (isinstance(y, (Sequence, spmatrix)) or hasattr(y, '__array__')) and (not isinstance(y, str))\n    if not valid:\n        raise ValueError('Expected array-like (array or non-string sequence), got %r' % y)\n    sparse_pandas = y.__class__.__name__ in ['SparseSeries', 'SparseArray']\n    if sparse_pandas:\n        raise ValueError(\"y cannot be class 'SparseSeries' or 'SparseArray'\")\n    if is_multilabel(y):\n        return 'multilabel-indicator'\n    try:\n        y = np.asarray(y)\n    except ValueError:\n        return 'unknown'\n    try:\n        if not hasattr(y[0], '__array__') and isinstance(y[0], Sequence) and (not isinstance(y[0], str)):\n            raise ValueError('You appear to be using a legacy multi-label data representation. Sequence of sequences are no longer supported; use a binary array or sparse matrix instead - the MultiLabelBinarizer transformer can convert to this format.')\n    except IndexError:\n        pass\n    if y.ndim > 2 or (y.dtype == object and len(y) and (not isinstance(y.flat[0], str))):\n        return 'unknown'\n    if y.ndim == 2 and y.shape[1] == 0:\n        return 'unknown'\n    if y.ndim == 2 and y.shape[1] > 1:\n        suffix = '-multioutput'\n    else:\n        suffix = ''\n    if y.dtype.kind == 'f' and np.any(y != y.astype(int)):\n        _assert_all_finite(y)\n        return 'continuous' + suffix\n    if len(np.unique(y)) > 2 or (y.ndim >= 2 and len(y[0]) > 1):\n        return 'multiclass' + suffix\n    else:\n        return 'binary'",
    ".sklearn.utils.multiclass.py@@is_multilabel": "def is_multilabel(y):\n    if hasattr(y, '__array__') or isinstance(y, Sequence):\n        y = np.asarray(y)\n    if not (hasattr(y, 'shape') and y.ndim == 2 and (y.shape[1] > 1)):\n        return False\n    if issparse(y):\n        if isinstance(y, (dok_matrix, lil_matrix)):\n            y = y.tocsr()\n        return len(y.data) == 0 or (np.unique(y.data).size == 1 and (y.dtype.kind in 'biu' or _is_integral_float(np.unique(y.data))))\n    else:\n        labels = np.unique(y)\n        return len(labels) < 3 and (y.dtype.kind in 'biu' or _is_integral_float(labels))",
    ".sklearn.utils.validation.py@@column_or_1d": "def column_or_1d(y, warn=False):\n    y = np.asarray(y)\n    shape = np.shape(y)\n    if len(shape) == 1:\n        return np.ravel(y)\n    if len(shape) == 2 and shape[1] == 1:\n        if warn:\n            warnings.warn('A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel().', DataConversionWarning, stacklevel=2)\n        return np.ravel(y)\n    raise ValueError('bad input shape {0}'.format(shape))",
    ".sklearn.utils.multiclass.py@@unique_labels": "def unique_labels(*ys):\n    if not ys:\n        raise ValueError('No argument has been passed.')\n    ys_types = set((type_of_target(x) for x in ys))\n    if ys_types == {'binary', 'multiclass'}:\n        ys_types = {'multiclass'}\n    if len(ys_types) > 1:\n        raise ValueError('Mix type of y not allowed, got types %s' % ys_types)\n    label_type = ys_types.pop()\n    if label_type == 'multilabel-indicator' and len(set((check_array(y, ['csr', 'csc', 'coo']).shape[1] for y in ys))) > 1:\n        raise ValueError('Multi-label binary indicator input with different numbers of labels')\n    _unique_labels = _FN_UNIQUE_LABELS.get(label_type, None)\n    if not _unique_labels:\n        raise ValueError('Unknown label type: %s' % repr(ys))\n    ys_labels = set(chain.from_iterable((_unique_labels(y) for y in ys)))\n    if len(set((isinstance(label, str) for label in ys_labels))) > 1:\n        raise ValueError('Mix of label input types (string and number)')\n    return np.array(sorted(ys_labels))",
    ".sklearn.utils.multiclass.py@@_unique_multiclass": "def _unique_multiclass(y):\n    if hasattr(y, '__array__'):\n        return np.unique(np.asarray(y))\n    else:\n        return set(y)"
}