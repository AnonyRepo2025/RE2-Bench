{
    ".xarray.core.common.py@@AttrAccessMixin.__getattr__": "def __getattr__(self, name: str) -> Any:\n    if name not in {'__dict__', '__setstate__'}:\n        for source in self._attr_sources:\n            with suppress(KeyError):\n                return source[name]\n    raise AttributeError(f'{type(self).__name__!r} object has no attribute {name!r}')",
    ".xarray.core.dataarray.py@@DataArray._attr_sources": "def _attr_sources(self) -> Iterable[Mapping[Hashable, Any]]:\n    yield from self._item_sources\n    yield self.attrs",
    ".xarray.core.dataarray.py@@DataArray._item_sources": "def _item_sources(self) -> Iterable[Mapping[Hashable, Any]]:\n    yield HybridMappingProxy(keys=self._coords, mapping=self.coords)\n    yield HybridMappingProxy(keys=self.dims, mapping={})",
    ".xarray.core.dataarray.py@@DataArray.coords": "def coords(self) -> DataArrayCoordinates:\n    return DataArrayCoordinates(self)",
    ".xarray.core.coordinates.py@@DataArrayCoordinates.__init__": "def __init__(self, dataarray: 'DataArray'):\n    self._data = dataarray",
    ".xarray.core.utils.py@@HybridMappingProxy.__init__": "def __init__(self, keys: Collection[K], mapping: Mapping[K, V]):\n    self._keys = keys\n    self.mapping = mapping",
    ".xarray.core.utils.py@@HybridMappingProxy.__getitem__": "def __getitem__(self, key: K) -> V:\n    return self.mapping[key]",
    ".xarray.core.coordinates.py@@DataArrayCoordinates.__getitem__": "def __getitem__(self, key: Hashable) -> 'DataArray':\n    return self._data._getitem_coord(key)",
    ".xarray.core.dataarray.py@@DataArray._getitem_coord": "def _getitem_coord(self, key):\n    from .dataset import _get_virtual_variable\n    try:\n        var = self._coords[key]\n    except KeyError:\n        dim_sizes = dict(zip(self.dims, self.shape))\n        _, key, var = _get_virtual_variable(self._coords, key, dim_sizes)\n    return self._replace_maybe_drop_dims(var, name=key)",
    ".xarray.core.dataarray.py@@DataArray.dims": "def dims(self) -> tuple[Hashable, ...]:\n    return self.variable.dims",
    ".xarray.core.dataarray.py@@DataArray.variable": "def variable(self) -> Variable:\n    return self._variable",
    ".xarray.core.variable.py@@Variable.dims": "def dims(self):\n    return self._dims",
    ".xarray.core.dataarray.py@@DataArray.shape": "def shape(self) -> tuple[int, ...]:\n    return self.variable.shape",
    ".xarray.core.variable.py@@Variable.shape": "def shape(self):\n    return self._data.shape",
    ".xarray.core.dataset.py@@_get_virtual_variable": "def _get_virtual_variable(variables, key: Hashable, dim_sizes: Mapping=None) -> tuple[Hashable, Hashable, Variable]:\n    if dim_sizes is None:\n        dim_sizes = {}\n    if key in dim_sizes:\n        data = pd.Index(range(dim_sizes[key]), name=key)\n        variable = IndexVariable((key,), data)\n        return (key, key, variable)\n    if not isinstance(key, str):\n        raise KeyError(key)\n    split_key = key.split('.', 1)\n    if len(split_key) != 2:\n        raise KeyError(key)\n    ref_name, var_name = split_key\n    ref_var = variables[ref_name]\n    if _contains_datetime_like_objects(ref_var):\n        ref_var = xr.DataArray(ref_var)\n        data = getattr(ref_var.dt, var_name).data\n    else:\n        data = getattr(ref_var, var_name).data\n    virtual_var = Variable(ref_var.dims, data)\n    return (ref_name, var_name, virtual_var)",
    ".xarray.core.dataarray.py@@DataArray.attrs": "def attrs(self) -> dict[Any, Any]:\n    return self.variable.attrs",
    ".xarray.core.variable.py@@Variable.attrs": "def attrs(self) -> dict[Hashable, Any]:\n    if self._attrs is None:\n        self._attrs = {}\n    return self._attrs",
    ".xarray.core.common.py@@AbstractArray.__array__": "def __array__(self: Any, dtype: DTypeLike=None) -> np.ndarray:\n    return np.asarray(self.values, dtype=dtype)",
    ".xarray.core.dataarray.py@@DataArray.values": "def values(self) -> np.ndarray:\n    return self.variable.values",
    ".xarray.core.variable.py@@Variable.values": "def values(self):\n    return _as_array_or_item(self._data)",
    ".xarray.core.variable.py@@_as_array_or_item": "def _as_array_or_item(data):\n    data = np.asarray(data)\n    if data.ndim == 0:\n        if data.dtype.kind == 'M':\n            data = np.datetime64(data, 'ns')\n        elif data.dtype.kind == 'm':\n            data = np.timedelta64(data, 'ns')\n    return data",
    ".xarray.core.formatting.py@@set_numpy_options": "def set_numpy_options(*args, **kwargs):\n    original = np.get_printoptions()\n    np.set_printoptions(*args, **kwargs)\n    try:\n        yield\n    finally:\n        np.set_printoptions(**original)",
    ".xarray.core.utils.py@@NDArrayMixin.shape": "def shape(self: Any) -> tuple[int]:\n    return self.array.shape",
    ".xarray.core.indexing.py@@LazilyIndexedArray.shape": "def shape(self):\n    shape = []\n    for size, k in zip(self.array.shape, self.key.tuple):\n        if isinstance(k, slice):\n            shape.append(len(range(*k.indices(size))))\n        elif isinstance(k, np.ndarray):\n            shape.append(k.size)\n    return tuple(shape)",
    ".xarray.core.indexing.py@@ExplicitIndexer.tuple": "def tuple(self):\n    return self._key",
    ".xarray.core.indexing.py@@MemoryCachedArray.__array__": "def __array__(self, dtype=None):\n    self._ensure_cached()\n    return np.asarray(self.array, dtype=dtype)",
    ".xarray.core.indexing.py@@MemoryCachedArray._ensure_cached": "def _ensure_cached(self):\n    if not isinstance(self.array, NumpyIndexingAdapter):\n        self.array = NumpyIndexingAdapter(np.asarray(self.array))",
    ".xarray.core.indexing.py@@CopyOnWriteArray.__array__": "def __array__(self, dtype=None):\n    return np.asarray(self.array, dtype=dtype)",
    ".xarray.core.indexing.py@@LazilyIndexedArray.__array__": "def __array__(self, dtype=None):\n    array = as_indexable(self.array)\n    return np.asarray(array[self.key], dtype=None)",
    ".xarray.core.indexing.py@@as_indexable": "def as_indexable(array):\n    if isinstance(array, ExplicitlyIndexed):\n        return array\n    if isinstance(array, np.ndarray):\n        return NumpyIndexingAdapter(array)\n    if isinstance(array, pd.Index):\n        return PandasIndexingAdapter(array)\n    if is_duck_dask_array(array):\n        return DaskIndexingAdapter(array)\n    if hasattr(array, '__array_function__'):\n        return NdArrayLikeIndexingAdapter(array)\n    raise TypeError(f'Invalid array type: {type(array)}')",
    ".xarray.backends.netCDF4_.py@@NetCDF4ArrayWrapper.__getitem__": "def __getitem__(self, key):\n    return indexing.explicit_indexing_adapter(key, self.shape, indexing.IndexingSupport.OUTER, self._getitem)",
    ".xarray.core.indexing.py@@explicit_indexing_adapter": "def explicit_indexing_adapter(key: ExplicitIndexer, shape: Tuple[int, ...], indexing_support: IndexingSupport, raw_indexing_method: Callable) -> Any:\n    raw_key, numpy_indices = decompose_indexer(key, shape, indexing_support)\n    result = raw_indexing_method(raw_key.tuple)\n    if numpy_indices.tuple:\n        result = NumpyIndexingAdapter(np.asarray(result))[numpy_indices]\n    return result",
    ".xarray.core.indexing.py@@decompose_indexer": "def decompose_indexer(indexer: ExplicitIndexer, shape: Tuple[int, ...], indexing_support: IndexingSupport) -> Tuple[ExplicitIndexer, ExplicitIndexer]:\n    if isinstance(indexer, VectorizedIndexer):\n        return _decompose_vectorized_indexer(indexer, shape, indexing_support)\n    if isinstance(indexer, (BasicIndexer, OuterIndexer)):\n        return _decompose_outer_indexer(indexer, shape, indexing_support)\n    raise TypeError(f'unexpected key type: {indexer}')",
    ".xarray.core.indexing.py@@_decompose_outer_indexer": "def _decompose_outer_indexer(indexer: Union[BasicIndexer, OuterIndexer], shape: Tuple[int, ...], indexing_support: IndexingSupport) -> Tuple[ExplicitIndexer, ExplicitIndexer]:\n    if indexing_support == IndexingSupport.VECTORIZED:\n        return (indexer, BasicIndexer(()))\n    assert isinstance(indexer, (OuterIndexer, BasicIndexer))\n    backend_indexer: List[Any] = []\n    np_indexer = []\n    pos_indexer: list[np.ndarray | int | np.number] = []\n    for k, s in zip(indexer.tuple, shape):\n        if isinstance(k, np.ndarray):\n            pos_indexer.append(np.where(k < 0, k + s, k))\n        elif isinstance(k, integer_types) and k < 0:\n            pos_indexer.append(k + s)\n        else:\n            pos_indexer.append(k)\n    indexer_elems = pos_indexer\n    if indexing_support is IndexingSupport.OUTER_1VECTOR:\n        gains = [(np.max(k) - np.min(k) + 1.0) / len(np.unique(k)) if isinstance(k, np.ndarray) else 0 for k in indexer_elems]\n        array_index = np.argmax(np.array(gains)) if len(gains) > 0 else None\n        for i, (k, s) in enumerate(zip(indexer_elems, shape)):\n            if isinstance(k, np.ndarray) and i != array_index:\n                backend_indexer.append(slice(np.min(k), np.max(k) + 1))\n                np_indexer.append(k - np.min(k))\n            elif isinstance(k, np.ndarray):\n                pkey, ekey = np.unique(k, return_inverse=True)\n                backend_indexer.append(pkey)\n                np_indexer.append(ekey)\n            elif isinstance(k, integer_types):\n                backend_indexer.append(k)\n            else:\n                bk_slice, np_slice = _decompose_slice(k, s)\n                backend_indexer.append(bk_slice)\n                np_indexer.append(np_slice)\n        return (OuterIndexer(tuple(backend_indexer)), OuterIndexer(tuple(np_indexer)))\n    if indexing_support == IndexingSupport.OUTER:\n        for k, s in zip(indexer_elems, shape):\n            if isinstance(k, slice):\n                bk_slice, np_slice = _decompose_slice(k, s)\n                backend_indexer.append(bk_slice)\n                np_indexer.append(np_slice)\n            elif isinstance(k, integer_types):\n                backend_indexer.append(k)\n            elif isinstance(k, np.ndarray) and (np.diff(k) >= 0).all():\n                backend_indexer.append(k)\n                np_indexer.append(slice(None))\n            else:\n                oind, vind = np.unique(k, return_inverse=True)\n                backend_indexer.append(oind)\n                np_indexer.append(vind.reshape(*k.shape))\n        return (OuterIndexer(tuple(backend_indexer)), OuterIndexer(tuple(np_indexer)))\n    assert indexing_support == IndexingSupport.BASIC\n    for k, s in zip(indexer_elems, shape):\n        if isinstance(k, np.ndarray):\n            backend_indexer.append(slice(np.min(k), np.max(k) + 1))\n            np_indexer.append(k - np.min(k))\n        elif isinstance(k, integer_types):\n            backend_indexer.append(k)\n        else:\n            bk_slice, np_slice = _decompose_slice(k, s)\n            backend_indexer.append(bk_slice)\n            np_indexer.append(np_slice)\n    return (BasicIndexer(tuple(backend_indexer)), OuterIndexer(tuple(np_indexer)))",
    ".xarray.core.indexing.py@@_decompose_slice": "def _decompose_slice(key, size):\n    start, stop, step = key.indices(size)\n    if step > 0:\n        return (key, slice(None))\n    else:\n        stop = start + int((stop - start - 1) / step) * step + 1\n        start, stop = (stop + 1, start + 1)\n        return (slice(start, stop, -step), slice(None, None, -1))",
    ".xarray.core.indexing.py@@OuterIndexer.__init__": "def __init__(self, key):\n    if not isinstance(key, tuple):\n        raise TypeError(f'key must be a tuple: {key!r}')\n    new_key = []\n    for k in key:\n        if isinstance(k, integer_types):\n            k = int(k)\n        elif isinstance(k, slice):\n            k = as_integer_slice(k)\n        elif isinstance(k, np.ndarray):\n            if not np.issubdtype(k.dtype, np.integer):\n                raise TypeError(f'invalid indexer array, does not have integer dtype: {k!r}')\n            if k.ndim != 1:\n                raise TypeError(f'invalid indexer array for {type(self).__name__}; must have exactly 1 dimension: {k!r}')\n            k = np.asarray(k, dtype=np.int64)\n        else:\n            raise TypeError(f'unexpected indexer type for {type(self).__name__}: {k!r}')\n        new_key.append(k)\n    super().__init__(new_key)",
    ".xarray.core.indexing.py@@as_integer_slice": "def as_integer_slice(value):\n    start = as_integer_or_none(value.start)\n    stop = as_integer_or_none(value.stop)\n    step = as_integer_or_none(value.step)\n    return slice(start, stop, step)",
    ".xarray.core.indexing.py@@as_integer_or_none": "def as_integer_or_none(value):\n    return None if value is None else operator.index(value)",
    ".xarray.core.indexing.py@@ExplicitIndexer.__init__": "def __init__(self, key):\n    if type(self) is ExplicitIndexer:\n        raise TypeError('cannot instantiate base ExplicitIndexer objects')\n    self._key = tuple(key)",
    ".xarray.backends.netCDF4_.py@@NetCDF4ArrayWrapper._getitem": "def _getitem(self, key):\n    if self.datastore.is_remote:\n        getitem = functools.partial(robust_getitem, catch=RuntimeError)\n    else:\n        getitem = operator.getitem\n    try:\n        with self.datastore.lock:\n            original_array = self.get_array(needs_lock=False)\n            array = getitem(original_array, key)\n    except IndexError:\n        msg = 'The indexing operation you are attempting to perform is not valid on netCDF4.Variable object. Try loading your data into memory first by calling .load().'\n        raise IndexError(msg)\n    return array",
    ".xarray.backends.locks.py@@CombinedLock.__enter__": "def __enter__(self):\n    for lock in self.locks:\n        lock.__enter__()",
    ".xarray.backends.netCDF4_.py@@NetCDF4ArrayWrapper.get_array": "def get_array(self, needs_lock=True):\n    ds = self.datastore._acquire(needs_lock)\n    variable = ds.variables[self.variable_name]\n    variable.set_auto_maskandscale(False)\n    with suppress(AttributeError):\n        variable.set_auto_chartostring(False)\n    return variable",
    ".xarray.backends.netCDF4_.py@@NetCDF4DataStore._acquire": "def _acquire(self, needs_lock=True):\n    with self._manager.acquire_context(needs_lock) as root:\n        ds = _nc4_require_group(root, self._group, self._mode)\n    return ds",
    ".xarray.backends.file_manager.py@@CachingFileManager.acquire_context": "def acquire_context(self, needs_lock=True):\n    file, cached = self._acquire_with_cache_info(needs_lock)\n    try:\n        yield file\n    except Exception:\n        if not cached:\n            self.close(needs_lock)\n        raise",
    ".xarray.backends.file_manager.py@@CachingFileManager._acquire_with_cache_info": "def _acquire_with_cache_info(self, needs_lock=True):\n    with self._optional_lock(needs_lock):\n        try:\n            file = self._cache[self._key]\n        except KeyError:\n            kwargs = self._kwargs\n            if self._mode is not _DEFAULT_MODE:\n                kwargs = kwargs.copy()\n                kwargs['mode'] = self._mode\n            file = self._opener(*self._args, **kwargs)\n            if self._mode == 'w':\n                self._mode = 'a'\n            self._cache[self._key] = file\n            return (file, False)\n        else:\n            return (file, True)",
    ".xarray.backends.file_manager.py@@CachingFileManager._optional_lock": "def _optional_lock(self, needs_lock):\n    if needs_lock:\n        with self._lock:\n            yield\n    else:\n        yield",
    ".xarray.backends.lru_cache.py@@LRUCache.__getitem__": "def __getitem__(self, key: K) -> V:\n    with self._lock:\n        value = self._cache[key]\n        self._cache.move_to_end(key)\n        return value",
    ".xarray.backends.file_manager.py@@_HashedSequence.__hash__": "def __hash__(self):\n    return self.hashvalue",
    ".xarray.backends.netCDF4_.py@@_nc4_require_group": "def _nc4_require_group(ds, group, mode, create_group=_netcdf4_create_group):\n    if group in {None, '', '/'}:\n        return ds\n    else:\n        if not isinstance(group, str):\n            raise ValueError('group must be a string or None')\n        path = group.strip('/').split('/')\n        for key in path:\n            try:\n                ds = ds.groups[key]\n            except KeyError as e:\n                if mode != 'r':\n                    ds = create_group(ds, key)\n                else:\n                    raise OSError(f'group not found: {key}', e)\n        return ds",
    ".xarray.backends.locks.py@@CombinedLock.__exit__": "def __exit__(self, *args):\n    for lock in self.locks:\n        lock.__exit__(*args)",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.__init__": "def __init__(self, array):\n    if not isinstance(array, np.ndarray):\n        raise TypeError('NumpyIndexingAdapter only wraps np.ndarray. Trying to wrap {}'.format(type(array)))\n    self.array = array",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.__getitem__": "def __getitem__(self, key):\n    array, key = self._indexing_array_and_key(key)\n    return array[key]",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter._indexing_array_and_key": "def _indexing_array_and_key(self, key):\n    if isinstance(key, OuterIndexer):\n        array = self.array\n        key = _outer_to_numpy_indexer(key, self.array.shape)\n    elif isinstance(key, VectorizedIndexer):\n        array = nputils.NumpyVIndexAdapter(self.array)\n        key = key.tuple\n    elif isinstance(key, BasicIndexer):\n        array = self.array\n        key = key.tuple + (Ellipsis,)\n    else:\n        raise TypeError(f'unexpected key type: {type(key)}')\n    return (array, key)",
    ".xarray.core.indexing.py@@_outer_to_numpy_indexer": "def _outer_to_numpy_indexer(key, shape):\n    if len([k for k in key.tuple if not isinstance(k, slice)]) <= 1:\n        return key.tuple\n    else:\n        return _outer_to_vectorized_indexer(key, shape).tuple",
    ".xarray.core.indexing.py@@ExplicitlyIndexedNDArrayMixin.__array__": "def __array__(self, dtype=None):\n    key = BasicIndexer((slice(None),) * self.ndim)\n    return np.asarray(self[key], dtype=dtype)",
    ".xarray.core.utils.py@@NdimSizeLenMixin.ndim": "def ndim(self: Any) -> int:\n    return len(self.shape)",
    ".xarray.core.indexing.py@@BasicIndexer.__init__": "def __init__(self, key):\n    if not isinstance(key, tuple):\n        raise TypeError(f'key must be a tuple: {key!r}')\n    new_key = []\n    for k in key:\n        if isinstance(k, integer_types):\n            k = int(k)\n        elif isinstance(k, slice):\n            k = as_integer_slice(k)\n        else:\n            raise TypeError(f'unexpected indexer type for {type(self).__name__}: {k!r}')\n        new_key.append(k)\n    super().__init__(new_key)"
}