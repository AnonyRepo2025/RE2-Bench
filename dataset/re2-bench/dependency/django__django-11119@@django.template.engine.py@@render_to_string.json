{
    ".django.utils.functional.py@@cached_property.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    res = instance.__dict__[self.name] = self.func(instance)\n    return res",
    ".django.utils.module_loading.py@@import_string": "def import_string(dotted_path):\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n    except ValueError as err:\n        raise ImportError(\"%s doesn't look like a module path\" % dotted_path) from err\n    module = import_module(module_path)\n    try:\n        return getattr(module, class_name)\n    except AttributeError as err:\n        raise ImportError('Module \"%s\" does not define a \"%s\" attribute/class' % (module_path, class_name)) from err",
    ".django.template.loaders.cached.py@@Loader.__init__": "def __init__(self, engine, loaders):\n    self.get_template_cache = {}\n    self.loaders = engine.get_template_loaders(loaders)\n    super().__init__(engine)",
    ".django.template.loaders.filesystem.py@@Loader.__init__": "def __init__(self, engine, dirs=None):\n    super().__init__(engine)\n    self.dirs = dirs",
    ".django.template.loaders.base.py@@Loader.__init__": "def __init__(self, engine):\n    self.engine = engine",
    ".django.template.loaders.cached.py@@Loader.get_template": "def get_template(self, template_name, skip=None):\n    key = self.cache_key(template_name, skip)\n    cached = self.get_template_cache.get(key)\n    if cached:\n        if isinstance(cached, type) and issubclass(cached, TemplateDoesNotExist):\n            raise cached(template_name)\n        elif isinstance(cached, TemplateDoesNotExist):\n            raise copy_exception(cached)\n        return cached\n    try:\n        template = super().get_template(template_name, skip)\n    except TemplateDoesNotExist as e:\n        self.get_template_cache[key] = copy_exception(e) if self.engine.debug else TemplateDoesNotExist\n        raise\n    else:\n        self.get_template_cache[key] = template\n    return template",
    ".django.template.loaders.cached.py@@Loader.cache_key": "def cache_key(self, template_name, skip=None):\n    skip_prefix = ''\n    if skip:\n        matching = [origin.name for origin in skip if origin.template_name == template_name]\n        if matching:\n            skip_prefix = self.generate_hash(matching)\n    return '-'.join((s for s in (str(template_name), skip_prefix) if s))",
    ".django.template.loaders.base.py@@Loader.get_template": "def get_template(self, template_name, skip=None):\n    tried = []\n    for origin in self.get_template_sources(template_name):\n        if skip is not None and origin in skip:\n            tried.append((origin, 'Skipped'))\n            continue\n        try:\n            contents = self.get_contents(origin)\n        except TemplateDoesNotExist:\n            tried.append((origin, 'Source does not exist'))\n            continue\n        else:\n            return Template(contents, origin, origin.template_name, self.engine)\n    raise TemplateDoesNotExist(template_name, tried=tried)",
    ".django.template.loaders.cached.py@@Loader.get_template_sources": "def get_template_sources(self, template_name):\n    for loader in self.loaders:\n        yield from loader.get_template_sources(template_name)",
    ".django.template.loaders.filesystem.py@@Loader.get_template_sources": "def get_template_sources(self, template_name):\n    for template_dir in self.get_dirs():\n        try:\n            name = safe_join(template_dir, template_name)\n        except SuspiciousFileOperation:\n            continue\n        yield Origin(name=name, template_name=template_name, loader=self)",
    ".django.template.loaders.filesystem.py@@Loader.get_dirs": "def get_dirs(self):\n    return self.dirs if self.dirs is not None else self.engine.dirs",
    ".django.utils._os.py@@safe_join": "def safe_join(base, *paths):\n    final_path = abspath(join(base, *paths))\n    base_path = abspath(base)\n    if not normcase(final_path).startswith(normcase(base_path + sep)) and normcase(final_path) != normcase(base_path) and (dirname(normcase(base_path)) != normcase(base_path)):\n        raise SuspiciousFileOperation('The joined path ({}) is located outside of the base path component ({})'.format(final_path, base_path))\n    return final_path",
    ".django.template.base.py@@Origin.__init__": "def __init__(self, name, template_name=None, loader=None):\n    self.name = name\n    self.template_name = template_name\n    self.loader = loader",
    ".django.template.loaders.cached.py@@Loader.get_contents": "def get_contents(self, origin):\n    return origin.loader.get_contents(origin)",
    ".django.template.loaders.filesystem.py@@Loader.get_contents": "def get_contents(self, origin):\n    try:\n        with open(origin.name, encoding=self.engine.file_charset) as fp:\n            return fp.read()\n    except FileNotFoundError:\n        raise TemplateDoesNotExist(origin)",
    ".django.template.base.py@@Template.__init__": "def __init__(self, template_string, origin=None, name=None, engine=None):\n    if engine is None:\n        from .engine import Engine\n        engine = Engine.get_default()\n    if origin is None:\n        origin = Origin(UNKNOWN_SOURCE)\n    self.name = name\n    self.origin = origin\n    self.engine = engine\n    self.source = str(template_string)\n    self.nodelist = self.compile_nodelist()",
    ".django.template.base.py@@Template.compile_nodelist": "def compile_nodelist(self):\n    if self.engine.debug:\n        lexer = DebugLexer(self.source)\n    else:\n        lexer = Lexer(self.source)\n    tokens = lexer.tokenize()\n    parser = Parser(tokens, self.engine.template_libraries, self.engine.template_builtins, self.origin)\n    try:\n        return parser.parse()\n    except Exception as e:\n        if self.engine.debug:\n            e.template_debug = self.get_exception_info(e, e.token)\n        raise",
    ".django.template.base.py@@Lexer.__init__": "def __init__(self, template_string):\n    self.template_string = template_string\n    self.verbatim = False",
    ".django.template.base.py@@Lexer.tokenize": "def tokenize(self):\n    in_tag = False\n    lineno = 1\n    result = []\n    for bit in tag_re.split(self.template_string):\n        if bit:\n            result.append(self.create_token(bit, None, lineno, in_tag))\n        in_tag = not in_tag\n        lineno += bit.count('\\n')\n    return result",
    ".django.template.base.py@@Lexer.create_token": "def create_token(self, token_string, position, lineno, in_tag):\n    if in_tag and token_string.startswith(BLOCK_TAG_START):\n        block_content = token_string[2:-2].strip()\n        if self.verbatim and block_content == self.verbatim:\n            self.verbatim = False\n    if in_tag and (not self.verbatim):\n        if token_string.startswith(VARIABLE_TAG_START):\n            return Token(TokenType.VAR, token_string[2:-2].strip(), position, lineno)\n        elif token_string.startswith(BLOCK_TAG_START):\n            if block_content[:9] in ('verbatim', 'verbatim '):\n                self.verbatim = 'end%s' % block_content\n            return Token(TokenType.BLOCK, block_content, position, lineno)\n        elif token_string.startswith(COMMENT_TAG_START):\n            content = ''\n            if token_string.find(TRANSLATOR_COMMENT_MARK):\n                content = token_string[2:-2].strip()\n            return Token(TokenType.COMMENT, content, position, lineno)\n    else:\n        return Token(TokenType.TEXT, token_string, position, lineno)",
    ".django.template.base.py@@Token.__init__": "def __init__(self, token_type, contents, position=None, lineno=None):\n    self.token_type, self.contents = (token_type, contents)\n    self.lineno = lineno\n    self.position = position",
    ".django.template.base.py@@Parser.__init__": "def __init__(self, tokens, libraries=None, builtins=None, origin=None):\n    self.tokens = tokens\n    self.tags = {}\n    self.filters = {}\n    self.command_stack = []\n    if libraries is None:\n        libraries = {}\n    if builtins is None:\n        builtins = []\n    self.libraries = libraries\n    for builtin in builtins:\n        self.add_library(builtin)\n    self.origin = origin",
    ".django.template.base.py@@Parser.add_library": "def add_library(self, lib):\n    self.tags.update(lib.tags)\n    self.filters.update(lib.filters)",
    ".django.template.base.py@@Parser.parse": "def parse(self, parse_until=None):\n    if parse_until is None:\n        parse_until = []\n    nodelist = NodeList()\n    while self.tokens:\n        token = self.next_token()\n        if token.token_type.value == 0:\n            self.extend_nodelist(nodelist, TextNode(token.contents), token)\n        elif token.token_type.value == 1:\n            if not token.contents:\n                raise self.error(token, 'Empty variable tag on line %d' % token.lineno)\n            try:\n                filter_expression = self.compile_filter(token.contents)\n            except TemplateSyntaxError as e:\n                raise self.error(token, e)\n            var_node = VariableNode(filter_expression)\n            self.extend_nodelist(nodelist, var_node, token)\n        elif token.token_type.value == 2:\n            try:\n                command = token.contents.split()[0]\n            except IndexError:\n                raise self.error(token, 'Empty block tag on line %d' % token.lineno)\n            if command in parse_until:\n                self.prepend_token(token)\n                return nodelist\n            self.command_stack.append((command, token))\n            try:\n                compile_func = self.tags[command]\n            except KeyError:\n                self.invalid_block_tag(token, command, parse_until)\n            try:\n                compiled_result = compile_func(self, token)\n            except Exception as e:\n                raise self.error(token, e)\n            self.extend_nodelist(nodelist, compiled_result, token)\n            self.command_stack.pop()\n    if parse_until:\n        self.unclosed_block_tag(parse_until)\n    return nodelist",
    ".django.template.base.py@@Parser.next_token": "def next_token(self):\n    return self.tokens.pop(0)",
    ".django.template.base.py@@TextNode.__init__": "def __init__(self, s):\n    self.s = s",
    ".django.template.base.py@@Parser.extend_nodelist": "def extend_nodelist(self, nodelist, node, token):\n    if node.must_be_first and nodelist.contains_nontext:\n        raise self.error(token, '%r must be the first tag in the template.' % node)\n    if isinstance(nodelist, NodeList) and (not isinstance(node, TextNode)):\n        nodelist.contains_nontext = True\n    node.token = token\n    node.origin = self.origin\n    nodelist.append(node)",
    ".django.template.base.py@@Parser.compile_filter": "def compile_filter(self, token):\n    return FilterExpression(token, self)",
    ".django.template.base.py@@FilterExpression.__init__": "def __init__(self, token, parser):\n    self.token = token\n    matches = filter_re.finditer(token)\n    var_obj = None\n    filters = []\n    upto = 0\n    for match in matches:\n        start = match.start()\n        if upto != start:\n            raise TemplateSyntaxError('Could not parse some characters: %s|%s|%s' % (token[:upto], token[upto:start], token[start:]))\n        if var_obj is None:\n            var, constant = match.group('var', 'constant')\n            if constant:\n                try:\n                    var_obj = Variable(constant).resolve({})\n                except VariableDoesNotExist:\n                    var_obj = None\n            elif var is None:\n                raise TemplateSyntaxError('Could not find variable at start of %s.' % token)\n            else:\n                var_obj = Variable(var)\n        else:\n            filter_name = match.group('filter_name')\n            args = []\n            constant_arg, var_arg = match.group('constant_arg', 'var_arg')\n            if constant_arg:\n                args.append((False, Variable(constant_arg).resolve({})))\n            elif var_arg:\n                args.append((True, Variable(var_arg)))\n            filter_func = parser.find_filter(filter_name)\n            self.args_check(filter_name, filter_func, args)\n            filters.append((filter_func, args))\n        upto = match.end()\n    if upto != len(token):\n        raise TemplateSyntaxError(\"Could not parse the remainder: '%s' from '%s'\" % (token[upto:], token))\n    self.filters = filters\n    self.var = var_obj",
    ".django.template.base.py@@Variable.__init__": "def __init__(self, var):\n    self.var = var\n    self.literal = None\n    self.lookups = None\n    self.translate = False\n    self.message_context = None\n    if not isinstance(var, str):\n        raise TypeError('Variable must be a string or number, got %s' % type(var))\n    try:\n        if '.' in var or 'e' in var.lower():\n            self.literal = float(var)\n            if var.endswith('.'):\n                raise ValueError\n        else:\n            self.literal = int(var)\n    except ValueError:\n        if var.startswith('_(') and var.endswith(')'):\n            self.translate = True\n            var = var[2:-1]\n        try:\n            self.literal = mark_safe(unescape_string_literal(var))\n        except ValueError:\n            if var.find(VARIABLE_ATTRIBUTE_SEPARATOR + '_') > -1 or var[0] == '_':\n                raise TemplateSyntaxError(\"Variables and attributes may not begin with underscores: '%s'\" % var)\n            self.lookups = tuple(var.split(VARIABLE_ATTRIBUTE_SEPARATOR))",
    ".django.utils.functional.py@@wrapper": "def wrapper(*args, **kwargs):\n    if any((isinstance(arg, Promise) for arg in itertools.chain(args, kwargs.values()))):\n        return lazy_func(*args, **kwargs)\n    return func(*args, **kwargs)",
    ".django.utils.text.py@@unescape_string_literal": "def unescape_string_literal(s):\n    if s[0] not in '\"\\'' or s[-1] != s[0]:\n        raise ValueError('Not a string literal: %r' % s)\n    quote = s[0]\n    return s[1:-1].replace('\\\\%s' % quote, quote).replace('\\\\\\\\', '\\\\')",
    ".django.template.base.py@@VariableNode.__init__": "def __init__(self, filter_expression):\n    self.filter_expression = filter_expression"
}