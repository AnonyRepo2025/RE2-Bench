{
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is True:\n        return a\n    elif is_sympy is not None:\n        if not strict:\n            return a\n        else:\n            raise SympifyError(a)\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    cls = getattr(a, '__class__', None)\n    if cls is None:\n        cls = type(a)\n    conv = converter.get(cls, None)\n    if conv is not None:\n        return conv(a)\n    for superclass in getmro(cls):\n        try:\n            return converter[superclass](a)\n        except KeyError:\n            continue\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if _is_numpy_instance(a):\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from ..tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, str):\n        if _is_numpy_instance(a):\n            import numpy as np\n            assert not isinstance(a, np.number)\n            if isinstance(a, np.ndarray):\n                if a.ndim == 0:\n                    try:\n                        return sympify(a.item(), locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n                    except SympifyError:\n                        pass\n        else:\n            for coerce in (float, int):\n                try:\n                    return sympify(coerce(a))\n                except (TypeError, ValueError, AttributeError, SympifyError):\n                    continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    if not isinstance(a, str):\n        try:\n            a = str(a)\n        except Exception as exc:\n            raise SympifyError(a, exc)\n        from sympy.utilities.exceptions import SymPyDeprecationWarning\n        SymPyDeprecationWarning(feature='String fallback in sympify', useinstead='sympify(str(obj)) or ' + 'sympy.core.sympify.converter or obj._sympy_', issue=18066, deprecated_since_version='1.6').warn()\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.sympify.py@@SympifyError.__init__": "def __init__(self, expr, base_exc=None):\n    self.expr = expr\n    self.base_exc = base_exc"
}