{
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.tensor.tensor.py@@TensMul._tensMul_contract_indices": "def _tensMul_contract_indices(args, replace_indices=True):\n    replacements = [{} for _ in args]\n    args_indices = [get_indices(arg) for arg in args]\n    indices, free, free_names, dummy_data = TensMul._indices_to_free_dum(args_indices)\n    cdt = defaultdict(int)\n\n    def dummy_name_gen(tensor_index_type):\n        nd = str(cdt[tensor_index_type])\n        cdt[tensor_index_type] += 1\n        return tensor_index_type.dummy_name + '_' + nd\n    if replace_indices:\n        for old_index, pos1cov, pos1contra, pos2cov, pos2contra in dummy_data:\n            index_type = old_index.tensor_index_type\n            while True:\n                dummy_name = dummy_name_gen(index_type)\n                if dummy_name not in free_names:\n                    break\n            dummy = TensorIndex(dummy_name, index_type, True)\n            replacements[pos1cov][old_index] = dummy\n            replacements[pos1contra][-old_index] = -dummy\n            indices[pos2cov] = dummy\n            indices[pos2contra] = -dummy\n        args = [arg._replace_indices(repl) if isinstance(arg, TensExpr) else arg for arg, repl in zip(args, replacements)]\n    dum = TensMul._dummy_data_to_dum(dummy_data)\n    return (args, indices, free, dum)",
    ".sympy.tensor.tensor.py@@get_indices": "def get_indices(t):\n    if not isinstance(t, TensExpr):\n        return ()\n    return t.get_indices()",
    ".sympy.tensor.tensor.py@@Tensor.get_indices": "def get_indices(self):\n    return list(self.args[1])",
    ".sympy.core.containers.py@@Tuple.__len__": "def __len__(self):\n    return len(self.args)",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.tensor.tensor.py@@TensMul._indices_to_free_dum": "def _indices_to_free_dum(args_indices):\n    free2pos1 = {}\n    free2pos2 = {}\n    dummy_data = []\n    indices = []\n    pos2 = 0\n    for pos1, arg_indices in enumerate(args_indices):\n        for index_pos, index in enumerate(arg_indices):\n            if not isinstance(index, TensorIndex):\n                raise TypeError('expected TensorIndex')\n            if -index in free2pos1:\n                other_pos1 = free2pos1.pop(-index)\n                other_pos2 = free2pos2.pop(-index)\n                if index.is_up:\n                    dummy_data.append((index, pos1, other_pos1, pos2, other_pos2))\n                else:\n                    dummy_data.append((-index, other_pos1, pos1, other_pos2, pos2))\n                indices.append(index)\n            elif index in free2pos1:\n                raise ValueError('Repeated index: %s' % index)\n            else:\n                free2pos1[index] = pos1\n                free2pos2[index] = pos2\n                indices.append(index)\n            pos2 += 1\n    free = [(i, p) for i, p in free2pos2.items()]\n    free_names = [i.name for i in free2pos2.keys()]\n    dummy_data.sort(key=lambda x: x[3])\n    return (indices, free, free_names, dummy_data)",
    ".sympy.tensor.tensor.py@@TensorIndex.__neg__": "def __neg__(self):\n    t1 = TensorIndex(self.name, self.tensor_index_type, not self.is_up)\n    return t1",
    ".sympy.tensor.tensor.py@@TensorIndex.name": "def name(self):\n    return self.args[0].name",
    ".sympy.tensor.tensor.py@@TensorIndex.tensor_index_type": "def tensor_index_type(self):\n    return self.args[1]",
    ".sympy.tensor.tensor.py@@TensorIndex.is_up": "def is_up(self):\n    return self.args[2]",
    ".sympy.logic.boolalg.py@@BooleanTrue.__nonzero__": "def __nonzero__(self):\n    return True",
    ".sympy.tensor.tensor.py@@TensorIndex.__new__": "def __new__(cls, name, tensor_index_type, is_up=True):\n    if isinstance(name, str):\n        name_symbol = Symbol(name)\n    elif isinstance(name, Symbol):\n        name_symbol = name\n    elif name is True:\n        name = '_i{0}'.format(len(tensor_index_type._autogenerated))\n        name_symbol = Symbol(name)\n        tensor_index_type._autogenerated.append(name_symbol)\n    else:\n        raise ValueError('invalid name')\n    is_up = sympify(is_up)\n    return Basic.__new__(cls, name_symbol, tensor_index_type, is_up)",
    ".sympy.core.symbol.py@@Symbol.__new__": "def __new__(cls, name, **assumptions):\n    cls._sanitize(assumptions, cls)\n    return Symbol.__xnew_cached_(cls, name, **assumptions)",
    ".sympy.core.symbol.py@@Symbol._sanitize": "def _sanitize(assumptions, obj=None):\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    if is_commutative is None:\n        whose = '%s ' % obj.__name__ if obj else ''\n        raise ValueError('%scommutativity must be True or False.' % whose)\n    for key in list(assumptions.keys()):\n        v = assumptions[key]\n        if v is None:\n            assumptions.pop(key)\n            continue\n        assumptions[key] = bool(v)",
    ".sympy.core.logic.py@@fuzzy_bool": "def fuzzy_bool(x):\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    ".sympy.core.symbol.py@@Symbol.__new_stage2__": "def __new_stage2__(cls, name, **assumptions):\n    if not isinstance(name, str):\n        raise TypeError('name should be a string, not %s' % repr(type(name)))\n    obj = Expr.__new__(cls)\n    obj.name = name\n    tmp_asm_copy = assumptions.copy()\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    assumptions['commutative'] = is_commutative\n    obj._assumptions = StdFactKB(assumptions)\n    obj._assumptions._generator = tmp_asm_copy\n    return obj",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    super(StdFactKB, self).__init__(_assume_rules)\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.__init__": "def __init__(self, rules):\n    self.rules = rules",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    is_sympy = getattr(a, '__sympy__', None)\n    if is_sympy is not None:\n        return a\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    cls = getattr(a, '__class__', None)\n    if cls is None:\n        cls = type(a)\n    conv = converter.get(cls, None)\n    if conv is not None:\n        return conv(a)\n    for superclass in getmro(cls):\n        try:\n            return converter[superclass](a)\n        except KeyError:\n            continue\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    if evaluate is None:\n        evaluate = global_parameters.evaluate\n    if type(a).__module__ == 'numpy':\n        import numpy as np\n        if np.isscalar(a):\n            return _convert_numpy_types(a, locals=locals, convert_xor=convert_xor, strict=strict, rational=rational, evaluate=evaluate)\n    _sympy_ = getattr(a, '_sympy_', None)\n    if _sympy_ is not None:\n        try:\n            return a._sympy_()\n        except AttributeError:\n            pass\n    if not strict:\n        flat = getattr(a, 'flat', None)\n        if flat is not None:\n            shape = getattr(a, 'shape', None)\n            if shape is not None:\n                from ..tensor.array import Array\n                return Array(a.flat, a.shape)\n    if not isinstance(a, str):\n        for coerce in (float, int):\n            try:\n                coerced = coerce(a)\n            except (TypeError, ValueError):\n                continue\n            try:\n                return sympify(coerced)\n            except SympifyError:\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.basic.py@@Basic._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.expr.py@@Expr.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return dict(((key, value) for key, value in self._assumptions.items() if value is not None))",
    ".sympy.logic.boolalg.py@@BooleanFalse.__hash__": "def __hash__(self):\n    return hash(False)",
    ".sympy.tensor.tensor.py@@Tensor._replace_indices": "def _replace_indices(self, repl):\n    return self.xreplace(repl)",
    ".sympy.core.basic.py@@Basic.xreplace": "def xreplace(self, rule):\n    value, _ = self._xreplace(rule)\n    return value",
    ".sympy.core.basic.py@@Basic._xreplace": "def _xreplace(self, rule):\n    if self in rule:\n        return (rule[self], True)\n    elif rule:\n        args = []\n        changed = False\n        for a in self.args:\n            _xreplace = getattr(a, '_xreplace', None)\n            if _xreplace is not None:\n                a_xr = _xreplace(rule)\n                args.append(a_xr[0])\n                changed |= a_xr[1]\n            else:\n                args.append(a)\n        args = tuple(args)\n        if changed:\n            return (self.func(*args), True)\n    return (self, False)",
    ".sympy.tensor.tensor.py@@TensMul._dummy_data_to_dum": "def _dummy_data_to_dum(dummy_data):\n    return [(p2a, p2b) for i, p1a, p1b, p2a, p2b in dummy_data]",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.core.basic.py@@Basic.free_symbols": "def free_symbols(self):\n    return set().union(*[a.free_symbols for a in self.args])",
    ".sympy.core.symbol.py@@Symbol.free_symbols": "def free_symbols(self):\n    return {self}",
    ".sympy.core.expr.py@@Expr.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n        if not isinstance(other, Expr):\n            return False\n    except (SympifyError, SyntaxError):\n        return False\n    if not (self.is_Number and other.is_Number) and type(self) != type(other):\n        return False\n    a, b = (self._hashable_content(), other._hashable_content())\n    if a != b:\n        return False\n    for a, b in zip(a, b):\n        if not isinstance(a, Expr):\n            continue\n        if a.is_Number and type(a) != type(b):\n            return False\n    return True",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.tensor.tensor.py@@Tensor.get_free_indices": "def get_free_indices(self):\n    return self._index_structure.get_free_indices()",
    ".sympy.tensor.tensor.py@@_IndexStructure.get_free_indices": "def get_free_indices(self):\n    free = sorted(self.free, key=lambda x: x[1])\n    return [i[0] for i in free]",
    ".sympy.core.expr.py@@Expr._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.containers.py@@Tuple.__hash__": "def __hash__(self):\n    return hash(self.args)",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.containers.py@@Tuple.__new__": "def __new__(cls, *args, **kwargs):\n    if kwargs.get('sympify', True):\n        args = (sympify(arg) for arg in args)\n    obj = Basic.__new__(cls, *args)\n    return obj",
    ".sympy.tensor.tensor.py@@Tensor.__new__": "def __new__(cls, tensor_head, indices, **kw_args):\n    is_canon_bp = kw_args.pop('is_canon_bp', False)\n    indices = cls._parse_indices(tensor_head, indices)\n    obj = Basic.__new__(cls, tensor_head, Tuple(*indices), **kw_args)\n    obj._index_structure = _IndexStructure.from_indices(*indices)\n    obj._free = obj._index_structure.free[:]\n    obj._dum = obj._index_structure.dum[:]\n    obj._ext_rank = obj._index_structure._ext_rank\n    obj._coeff = S.One\n    obj._nocoeff = obj\n    obj._component = tensor_head\n    obj._components = [tensor_head]\n    if tensor_head.rank != len(indices):\n        raise ValueError('wrong number of indices')\n    obj.is_canon_bp = is_canon_bp\n    obj._index_map = Tensor._build_index_map(indices, obj._index_structure)\n    return obj",
    ".sympy.tensor.tensor.py@@Tensor._parse_indices": "def _parse_indices(tensor_head, indices):\n    if not isinstance(indices, (tuple, list, Tuple)):\n        raise TypeError('indices should be an array, got %s' % type(indices))\n    indices = list(indices)\n    for i, index in enumerate(indices):\n        if isinstance(index, Symbol):\n            indices[i] = TensorIndex(index, tensor_head.index_types[i], True)\n        elif isinstance(index, Mul):\n            c, e = index.as_coeff_Mul()\n            if c == -1 and isinstance(e, Symbol):\n                indices[i] = TensorIndex(e, tensor_head.index_types[i], False)\n            else:\n                raise ValueError('index not understood: %s' % index)\n        elif not isinstance(index, TensorIndex):\n            raise TypeError('wrong type for index: %s is %s' % (index, type(index)))\n    return indices",
    ".sympy.tensor.tensor.py@@_IndexStructure.from_indices": "def from_indices(*indices):\n    free, dum = _IndexStructure._free_dum_from_indices(*indices)\n    index_types = [i.tensor_index_type for i in indices]\n    indices = _IndexStructure._replace_dummy_names(indices, free, dum)\n    return _IndexStructure(free, dum, index_types, indices)",
    ".sympy.tensor.tensor.py@@_IndexStructure._free_dum_from_indices": "def _free_dum_from_indices(*indices):\n    n = len(indices)\n    if n == 1:\n        return ([(indices[0], 0)], [])\n    free = [True] * len(indices)\n    index_dict = {}\n    dum = []\n    for i, index in enumerate(indices):\n        name = index.name\n        typ = index.tensor_index_type\n        contr = index.is_up\n        if (name, typ) in index_dict:\n            is_contr, pos = index_dict[name, typ]\n            if is_contr:\n                if contr:\n                    raise ValueError('two equal contravariant indices in slots %d and %d' % (pos, i))\n                else:\n                    free[pos] = False\n                    free[i] = False\n            elif contr:\n                free[pos] = False\n                free[i] = False\n            else:\n                raise ValueError('two equal covariant indices in slots %d and %d' % (pos, i))\n            if contr:\n                dum.append((i, pos))\n            else:\n                dum.append((pos, i))\n        else:\n            index_dict[name, typ] = (index.is_up, i)\n    free = [(index, i) for i, index in enumerate(indices) if free[i]]\n    free.sort()\n    return (free, dum)",
    ".sympy.tensor.tensor.py@@_IndexStructure._replace_dummy_names": "def _replace_dummy_names(indices, free, dum):\n    dum.sort(key=lambda x: x[0])\n    new_indices = [ind for ind in indices]\n    assert len(indices) == len(free) + 2 * len(dum)\n    generate_dummy_name = _IndexStructure._get_generator_for_dummy_indices(free)\n    for ipos1, ipos2 in dum:\n        typ1 = new_indices[ipos1].tensor_index_type\n        indname = generate_dummy_name(typ1)\n        new_indices[ipos1] = TensorIndex(indname, typ1, True)\n        new_indices[ipos2] = TensorIndex(indname, typ1, False)\n    return new_indices",
    ".sympy.tensor.tensor.py@@_IndexStructure._get_generator_for_dummy_indices": "def _get_generator_for_dummy_indices(free):\n    cdt = defaultdict(int)\n    for indx, ipos in free:\n        if indx.name.split('_')[0] == indx.tensor_index_type.dummy_name:\n            cdt[indx.tensor_index_type] = max(cdt[indx.tensor_index_type], int(indx.name.split('_')[1]) + 1)\n\n    def dummy_name_gen(tensor_index_type):\n        nd = str(cdt[tensor_index_type])\n        cdt[tensor_index_type] += 1\n        return tensor_index_type.dummy_name + '_' + nd\n    return dummy_name_gen",
    ".sympy.tensor.tensor.py@@TensorIndexType.dummy_name": "def dummy_name(self):\n    return self.args[1].name",
    ".sympy.tensor.tensor.py@@_IndexStructure.__init__": "def __init__(self, free, dum, index_types, indices, canon_bp=False):\n    self.free = free\n    self.dum = dum\n    self.index_types = index_types\n    self.indices = indices\n    self._ext_rank = len(self.free) + 2 * len(self.dum)\n    self.dum.sort(key=lambda x: x[0])",
    ".sympy.tensor.tensor.py@@TensorHead.rank": "def rank(self):\n    return len(self.index_types)",
    ".sympy.tensor.tensor.py@@TensorHead.index_types": "def index_types(self):\n    return list(self.args[1])",
    ".sympy.tensor.tensor.py@@Tensor._build_index_map": "def _build_index_map(indices, index_structure):\n    index_map = {}\n    for idx in indices:\n        index_map[idx] = (indices.index(idx),)\n    return index_map",
    ".sympy.logic.boolalg.py@@BooleanFalse.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.logic.boolalg.py@@BooleanTrue.__hash__": "def __hash__(self):\n    return hash(True)",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    if self is other:\n        return True\n    tself = type(self)\n    tother = type(other)\n    if tself is not tother:\n        try:\n            other = _sympify(other)\n            tother = type(other)\n        except SympifyError:\n            return NotImplemented\n        if type(tself).__ne__ is not type.__ne__:\n            if tself != tother:\n                return False\n        elif tself is not tother:\n            return False\n    return self._hashable_content() == other._hashable_content()",
    ".sympy.tensor.tensor.py@@TensorIndex.__lt__": "def __lt__(self, other):\n    return (self.tensor_index_type, self.name) < (other.tensor_index_type, other.name)"
}