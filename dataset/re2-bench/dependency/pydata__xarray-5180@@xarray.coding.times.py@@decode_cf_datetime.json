{
    ".xarray.coding.times.py@@_decode_datetime_with_pandas": "def _decode_datetime_with_pandas(flat_num_dates, units, calendar):\n    if not _is_standard_calendar(calendar):\n        raise OutOfBoundsDatetime('Cannot decode times from a non-standard calendar, {!r}, using pandas.'.format(calendar))\n    delta, ref_date = _unpack_netcdf_time_units(units)\n    delta = _netcdf_to_numpy_timeunit(delta)\n    try:\n        ref_date = pd.Timestamp(ref_date)\n    except ValueError:\n        raise OutOfBoundsDatetime\n    with warnings.catch_warnings():\n        warnings.filterwarnings('ignore', 'invalid value encountered', RuntimeWarning)\n        pd.to_timedelta(flat_num_dates.min(), delta) + ref_date\n        pd.to_timedelta(flat_num_dates.max(), delta) + ref_date\n    if flat_num_dates.dtype.kind == 'i':\n        flat_num_dates = flat_num_dates.astype(np.int64)\n    flat_num_dates_ns_int = (flat_num_dates * _NS_PER_TIME_DELTA[delta]).astype(np.int64)\n    return (pd.to_timedelta(flat_num_dates_ns_int, 'ns') + ref_date).values",
    ".xarray.coding.times.py@@_is_standard_calendar": "def _is_standard_calendar(calendar):\n    return calendar.lower() in _STANDARD_CALENDARS",
    ".xarray.coding.times.py@@_unpack_netcdf_time_units": "def _unpack_netcdf_time_units(units):\n    matches = re.match('(.+) since (.+)', units)\n    if not matches:\n        raise ValueError(f'invalid time units: {units}')\n    delta_units, ref_date = [s.strip() for s in matches.groups()]\n    ref_date = _ensure_padded_year(ref_date)\n    return (delta_units, ref_date)",
    ".xarray.coding.times.py@@_ensure_padded_year": "def _ensure_padded_year(ref_date):\n    matches_year = re.match('.*\\\\d{4}.*', ref_date)\n    if matches_year:\n        return ref_date\n    matches_start_digits = re.match('(\\\\d+)(.*)', ref_date)\n    ref_year, everything_else = [s for s in matches_start_digits.groups()]\n    ref_date_padded = '{:04d}{}'.format(int(ref_year), everything_else)\n    warning_msg = f'Ambiguous reference date string: {ref_date}. The first value is assumed to be the year hence will be padded with zeros to remove the ambiguity (the padded reference date string is: {ref_date_padded}). To remove this message, remove the ambiguity by padding your reference date strings with zeros.'\n    warnings.warn(warning_msg, SerializationWarning)\n    return ref_date_padded",
    ".xarray.coding.times.py@@_netcdf_to_numpy_timeunit": "def _netcdf_to_numpy_timeunit(units):\n    units = units.lower()\n    if not units.endswith('s'):\n        units = '%ss' % units\n    return {'nanoseconds': 'ns', 'microseconds': 'us', 'milliseconds': 'ms', 'seconds': 's', 'minutes': 'm', 'hours': 'h', 'days': 'D'}[units]",
    ".xarray.coding.times.py@@_decode_datetime_with_cftime": "def _decode_datetime_with_cftime(num_dates, units, calendar):\n    import cftime\n    return np.asarray(cftime.num2date(num_dates, units, calendar, only_use_cftime_datetimes=True))",
    ".xarray.coding.times.py@@cftime_to_nptime": "def cftime_to_nptime(times):\n    times = np.asarray(times)\n    new = np.empty(times.shape, dtype='M8[ns]')\n    for i, t in np.ndenumerate(times):\n        try:\n            dt = pd.Timestamp(t.year, t.month, t.day, t.hour, t.minute, t.second, t.microsecond)\n        except ValueError as e:\n            raise ValueError('Cannot convert date {} to a date in the standard calendar.  Reason: {}.'.format(t, e))\n        new[i] = np.datetime64(dt)\n    return new",
    ".xarray.core.indexing.py@@ExplicitlyIndexedNDArrayMixin.__array__": "def __array__(self, dtype=None):\n    key = BasicIndexer((slice(None),) * self.ndim)\n    return np.asarray(self[key], dtype=dtype)",
    ".xarray.core.utils.py@@NdimSizeLenMixin.ndim": "def ndim(self: Any) -> int:\n    return len(self.shape)",
    ".xarray.core.utils.py@@NDArrayMixin.shape": "def shape(self: Any) -> Tuple[int]:\n    return self.array.shape",
    ".xarray.core.indexing.py@@BasicIndexer.__init__": "def __init__(self, key):\n    if not isinstance(key, tuple):\n        raise TypeError(f'key must be a tuple: {key!r}')\n    new_key = []\n    for k in key:\n        if isinstance(k, integer_types):\n            k = int(k)\n        elif isinstance(k, slice):\n            k = as_integer_slice(k)\n        else:\n            raise TypeError(f'unexpected indexer type for {type(self).__name__}: {k!r}')\n        new_key.append(k)\n    super().__init__(new_key)",
    ".xarray.core.indexing.py@@as_integer_slice": "def as_integer_slice(value):\n    start = as_integer_or_none(value.start)\n    stop = as_integer_or_none(value.stop)\n    step = as_integer_or_none(value.step)\n    return slice(start, stop, step)",
    ".xarray.core.indexing.py@@as_integer_or_none": "def as_integer_or_none(value):\n    return None if value is None else operator.index(value)",
    ".xarray.core.indexing.py@@ExplicitIndexer.__init__": "def __init__(self, key):\n    if type(self) is ExplicitIndexer:\n        raise TypeError('cannot instantiate base ExplicitIndexer objects')\n    self._key = tuple(key)",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.__getitem__": "def __getitem__(self, key):\n    array, key = self._indexing_array_and_key(key)\n    return array[key]",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter._indexing_array_and_key": "def _indexing_array_and_key(self, key):\n    if isinstance(key, OuterIndexer):\n        array = self.array\n        key = _outer_to_numpy_indexer(key, self.array.shape)\n    elif isinstance(key, VectorizedIndexer):\n        array = nputils.NumpyVIndexAdapter(self.array)\n        key = key.tuple\n    elif isinstance(key, BasicIndexer):\n        array = self.array\n        key = key.tuple + (Ellipsis,)\n    else:\n        raise TypeError('unexpected key type: {}'.format(type(key)))\n    return (array, key)",
    ".xarray.core.indexing.py@@ExplicitIndexer.tuple": "def tuple(self):\n    return self._key",
    ".xarray.core.indexing.py@@PandasIndexAdapter.__array__": "def __array__(self, dtype: DTypeLike=None) -> np.ndarray:\n    if dtype is None:\n        dtype = self.dtype\n    array = self.array\n    if isinstance(array, pd.PeriodIndex):\n        with suppress(AttributeError):\n            array = array.astype('object')\n    return np.asarray(array.values, dtype=dtype)",
    ".xarray.core.indexing.py@@PandasIndexAdapter.dtype": "def dtype(self) -> np.dtype:\n    return self._dtype"
}