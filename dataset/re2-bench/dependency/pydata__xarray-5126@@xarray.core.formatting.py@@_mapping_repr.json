{
    ".xarray.core.formatting.py@@_calculate_col_width": "def _calculate_col_width(col_items):\n    max_name_length = max((len(str(s)) for s in col_items)) if col_items else 0\n    col_width = max(max_name_length, 7) + 6\n    return col_width",
    ".xarray.core.dataset.py@@DataVariables.__len__": "def __len__(self) -> int:\n    return len(self._dataset._variables) - len(self._dataset._coord_names)",
    ".xarray.core.dataset.py@@DataVariables.__iter__": "def __iter__(self) -> Iterator[Hashable]:\n    return (key for key in self._dataset._variables if key not in self._dataset._coord_names)",
    ".xarray.core.options.py@@_get_boolean_with_default": "def _get_boolean_with_default(option, default):\n    global_choice = OPTIONS[option]\n    if global_choice == 'default':\n        return default\n    elif global_choice in [True, False]:\n        return global_choice\n    else:\n        raise ValueError(f\"The global option {option} must be one of True, False or 'default'.\")",
    ".xarray.core.dataset.py@@DataVariables.__getitem__": "def __getitem__(self, key: Hashable) -> 'DataArray':\n    if key not in self._dataset._coord_names:\n        return cast('DataArray', self._dataset[key])\n    raise KeyError(key)",
    ".xarray.core.dataset.py@@Dataset.__getitem__": "def __getitem__(self, key: Mapping) -> 'Dataset':\n    ...",
    ".xarray.core.utils.py@@is_dict_like": "def is_dict_like(value: Any) -> bool:\n    return hasattr(value, 'keys') and hasattr(value, '__getitem__')",
    ".xarray.core.utils.py@@hashable": "def hashable(v: Any) -> bool:\n    try:\n        hash(v)\n    except TypeError:\n        return False\n    return True",
    ".xarray.core.dataset.py@@Dataset._construct_dataarray": "def _construct_dataarray(self, name: Hashable) -> 'DataArray':\n    from .dataarray import DataArray\n    try:\n        variable = self._variables[name]\n    except KeyError:\n        _, name, variable = _get_virtual_variable(self._variables, name, self._level_coords, self.dims)\n    needed_dims = set(variable.dims)\n    coords: Dict[Hashable, Variable] = {}\n    for k in self._variables:\n        if k in self._coord_names and set(self.variables[k].dims) <= needed_dims:\n            coords[k] = self.variables[k]\n    if self._indexes is None:\n        indexes = None\n    else:\n        indexes = {k: v for k, v in self._indexes.items() if k in coords}\n    return DataArray(variable, coords, name=name, indexes=indexes, fastpath=True)",
    ".xarray.core.variable.py@@Variable.dims": "def dims(self):\n    return self._dims",
    ".xarray.core.dataset.py@@Dataset.variables": "def variables(self) -> Mapping[Hashable, Variable]:\n    return Frozen(self._variables)",
    ".xarray.core.utils.py@@Frozen.__init__": "def __init__(self, mapping: Mapping[K, V]):\n    self.mapping = mapping",
    ".xarray.core.utils.py@@Frozen.__getitem__": "def __getitem__(self, key: K) -> V:\n    return self.mapping[key]",
    ".xarray.core.dataarray.py@@DataArray.__init__": "def __init__(self, data: Any=dtypes.NA, coords: Union[Sequence[Tuple], Mapping[Hashable, Any], None]=None, dims: Union[Hashable, Sequence[Hashable], None]=None, name: Hashable=None, attrs: Mapping=None, indexes: Dict[Hashable, pd.Index]=None, fastpath: bool=False):\n    if fastpath:\n        variable = data\n        assert dims is None\n        assert attrs is None\n    else:\n        if coords is None:\n            if isinstance(data, DataArray):\n                coords = data.coords\n            elif isinstance(data, pd.Series):\n                coords = [data.index]\n            elif isinstance(data, pd.DataFrame):\n                coords = [data.index, data.columns]\n            elif isinstance(data, (pd.Index, IndexVariable)):\n                coords = [data]\n            elif isinstance(data, pdcompat.Panel):\n                coords = [data.items, data.major_axis, data.minor_axis]\n        if dims is None:\n            dims = getattr(data, 'dims', getattr(coords, 'dims', None))\n        if name is None:\n            name = getattr(data, 'name', None)\n        if attrs is None and (not isinstance(data, PANDAS_TYPES)):\n            attrs = getattr(data, 'attrs', None)\n        data = _check_data_shape(data, coords, dims)\n        data = as_compatible_data(data)\n        coords, dims = _infer_coords_and_dims(data.shape, coords, dims)\n        variable = Variable(dims, data, attrs, fastpath=True)\n        indexes = dict(_extract_indexes_from_coords(coords))\n    self._variable = variable\n    assert isinstance(coords, dict)\n    self._coords = coords\n    self._name = name\n    self._indexes = indexes\n    self._close = None",
    ".xarray.core.common.py@@AttrAccessMixin.__setattr__": "def __setattr__(self, name: str, value: Any) -> None:\n    try:\n        object.__setattr__(self, name, value)\n    except AttributeError as e:\n        if str(e) != '{!r} object has no attribute {!r}'.format(type(self).__name__, name):\n            raise\n        raise AttributeError(\"cannot set attribute %r on a %r object. Use __setitem__ styleassignment (e.g., `ds['name'] = ...`) instead of assigning variables.\" % (name, type(self).__name__)) from e",
    ".xarray.core.formatting.py@@summarize_datavar": "def summarize_datavar(name, var, col_width):\n    return summarize_variable(name, var.variable, col_width)",
    ".xarray.core.dataarray.py@@DataArray.variable": "def variable(self) -> Variable:\n    return self._variable",
    ".xarray.core.formatting.py@@summarize_variable": "def summarize_variable(name: Hashable, var, col_width: int, marker: str=' ', max_width: int=None):\n    if max_width is None:\n        max_width_options = OPTIONS['display_width']\n        if not isinstance(max_width_options, int):\n            raise TypeError(f'`max_width` value of `{max_width}` is not a valid int')\n        else:\n            max_width = max_width_options\n    first_col = pretty_print(f'  {marker} {name} ', col_width)\n    if var.dims:\n        dims_str = '({}) '.format(', '.join(map(str, var.dims)))\n    else:\n        dims_str = ''\n    front_str = f'{first_col}{dims_str}{var.dtype} '\n    values_width = max_width - len(front_str)\n    values_str = inline_variable_array_repr(var, values_width)\n    return front_str + values_str",
    ".xarray.core.formatting.py@@pretty_print": "def pretty_print(x, numchars: int):\n    s = maybe_truncate(x, numchars)\n    return s + ' ' * max(numchars - len(s), 0)",
    ".xarray.core.formatting.py@@maybe_truncate": "def maybe_truncate(obj, maxlen=500):\n    s = str(obj)\n    if len(s) > maxlen:\n        s = s[:maxlen - 3] + '...'\n    return s",
    ".xarray.core.variable.py@@Variable.dtype": "def dtype(self):\n    return self._data.dtype",
    ".xarray.core.formatting.py@@inline_variable_array_repr": "def inline_variable_array_repr(var, max_width):\n    if var._in_memory:\n        return format_array_flat(var, max_width)\n    elif isinstance(var._data, dask_array_type):\n        return inline_dask_repr(var.data)\n    elif isinstance(var._data, sparse_array_type):\n        return inline_sparse_repr(var.data)\n    elif hasattr(var._data, '_repr_inline_'):\n        return var._data._repr_inline_(max_width)\n    elif hasattr(var._data, '__array_function__'):\n        return maybe_truncate(repr(var._data).replace('\\n', ' '), max_width)\n    else:\n        return '...'",
    ".xarray.core.variable.py@@Variable._in_memory": "def _in_memory(self):\n    return isinstance(self._data, (np.ndarray, np.number, PandasIndexAdapter)) or (isinstance(self._data, indexing.MemoryCachedArray) and isinstance(self._data.array, indexing.NumpyIndexingAdapter))",
    ".xarray.core.formatting.py@@format_array_flat": "def format_array_flat(array, max_width: int):\n    max_possibly_relevant = min(max(array.size, 1), max(int(np.ceil(max_width / 2.0)), 2))\n    relevant_front_items = format_items(first_n_items(array, (max_possibly_relevant + 1) // 2))\n    relevant_back_items = format_items(last_n_items(array, max_possibly_relevant // 2))\n    relevant_items = sum(zip_longest(relevant_front_items, reversed(relevant_back_items)), ())[:max_possibly_relevant]\n    cum_len = np.cumsum([len(s) + 1 for s in relevant_items]) - 1\n    if array.size > 2 and (max_possibly_relevant < array.size or (cum_len > max_width).any()):\n        padding = ' ... '\n        max_len = max(np.argmax(cum_len + len(padding) - 1 > max_width), 2)\n        count = min(array.size, max_len)\n    else:\n        count = array.size\n        padding = '' if count <= 1 else ' '\n    num_front = (count + 1) // 2\n    num_back = count - num_front\n    pprint_str = ''.join([' '.join(relevant_front_items[:num_front]), padding, ' '.join(relevant_back_items[-num_back:])])\n    if len(pprint_str) > max_width:\n        pprint_str = pprint_str[:max(max_width - 3, 0)] + '...'\n    return pprint_str",
    ".xarray.core.utils.py@@NdimSizeLenMixin.size": "def size(self: Any) -> int:\n    return int(np.prod(self.shape))",
    ".xarray.core.variable.py@@Variable.shape": "def shape(self):\n    return self._data.shape",
    ".xarray.core.formatting.py@@first_n_items": "def first_n_items(array, n_desired):\n    if n_desired < 1:\n        raise ValueError('must request at least one item')\n    if array.size == 0:\n        return []\n    if n_desired < array.size:\n        indexer = _get_indexer_at_least_n_items(array.shape, n_desired, from_end=False)\n        array = array[indexer]\n    return np.asarray(array).flat[:n_desired]",
    ".xarray.core.formatting.py@@_get_indexer_at_least_n_items": "def _get_indexer_at_least_n_items(shape, n_desired, from_end):\n    assert 0 < n_desired <= np.prod(shape)\n    cum_items = np.cumprod(shape[::-1])\n    n_steps = np.argmax(cum_items >= n_desired)\n    stop = int(np.ceil(float(n_desired) / np.r_[1, cum_items][n_steps]))\n    indexer = (-1 if from_end else 0,) * (len(shape) - 1 - n_steps) + (slice(-stop, None) if from_end else slice(stop),) + (slice(None),) * n_steps\n    return indexer",
    ".xarray.core.variable.py@@Variable.__getitem__": "def __getitem__(self: VariableType, key) -> VariableType:\n    dims, indexer, new_order = self._broadcast_indexes(key)\n    data = as_indexable(self._data)[indexer]\n    if new_order:\n        data = duck_array_ops.moveaxis(data, range(len(new_order)), new_order)\n    return self._finalize_indexing_result(dims, data)",
    ".xarray.core.variable.py@@Variable._broadcast_indexes": "def _broadcast_indexes(self, key):\n    key = self._item_key_to_tuple(key)\n    key = indexing.expanded_indexer(key, self.ndim)\n    key = tuple((k.data.item() if isinstance(k, Variable) and k.ndim == 0 else k for k in key))\n    key = tuple((k.item() if isinstance(k, np.ndarray) and k.ndim == 0 else k for k in key))\n    if all((isinstance(k, BASIC_INDEXING_TYPES) for k in key)):\n        return self._broadcast_indexes_basic(key)\n    self._validate_indexers(key)\n    if all((not isinstance(k, Variable) for k in key)):\n        return self._broadcast_indexes_outer(key)\n    dims = []\n    for k, d in zip(key, self.dims):\n        if isinstance(k, Variable):\n            if len(k.dims) > 1:\n                return self._broadcast_indexes_vectorized(key)\n            dims.append(k.dims[0])\n        elif not isinstance(k, integer_types):\n            dims.append(d)\n    if len(set(dims)) == len(dims):\n        return self._broadcast_indexes_outer(key)\n    return self._broadcast_indexes_vectorized(key)",
    ".xarray.core.variable.py@@Variable._item_key_to_tuple": "def _item_key_to_tuple(self, key):\n    if utils.is_dict_like(key):\n        return tuple((key.get(dim, slice(None)) for dim in self.dims))\n    else:\n        return key",
    ".xarray.core.utils.py@@NdimSizeLenMixin.ndim": "def ndim(self: Any) -> int:\n    return len(self.shape)",
    ".xarray.core.indexing.py@@expanded_indexer": "def expanded_indexer(key, ndim):\n    if not isinstance(key, tuple):\n        key = (key,)\n    new_key = []\n    found_ellipsis = False\n    for k in key:\n        if k is Ellipsis:\n            if not found_ellipsis:\n                new_key.extend((ndim + 1 - len(key)) * [slice(None)])\n                found_ellipsis = True\n            else:\n                new_key.append(slice(None))\n        else:\n            new_key.append(k)\n    if len(new_key) > ndim:\n        raise IndexError('too many indices')\n    new_key.extend((ndim - len(new_key)) * [slice(None)])\n    return tuple(new_key)",
    ".xarray.core.variable.py@@Variable._broadcast_indexes_basic": "def _broadcast_indexes_basic(self, key):\n    dims = tuple((dim for k, dim in zip(key, self.dims) if not isinstance(k, integer_types)))\n    return (dims, BasicIndexer(key), None)",
    ".xarray.core.indexing.py@@BasicIndexer.__init__": "def __init__(self, key):\n    if not isinstance(key, tuple):\n        raise TypeError(f'key must be a tuple: {key!r}')\n    new_key = []\n    for k in key:\n        if isinstance(k, integer_types):\n            k = int(k)\n        elif isinstance(k, slice):\n            k = as_integer_slice(k)\n        else:\n            raise TypeError(f'unexpected indexer type for {type(self).__name__}: {k!r}')\n        new_key.append(k)\n    super().__init__(new_key)",
    ".xarray.core.indexing.py@@as_integer_slice": "def as_integer_slice(value):\n    start = as_integer_or_none(value.start)\n    stop = as_integer_or_none(value.stop)\n    step = as_integer_or_none(value.step)\n    return slice(start, stop, step)",
    ".xarray.core.indexing.py@@as_integer_or_none": "def as_integer_or_none(value):\n    return None if value is None else operator.index(value)",
    ".xarray.core.indexing.py@@ExplicitIndexer.__init__": "def __init__(self, key):\n    if type(self) is ExplicitIndexer:\n        raise TypeError('cannot instantiate base ExplicitIndexer objects')\n    self._key = tuple(key)",
    ".xarray.core.indexing.py@@as_indexable": "def as_indexable(array):\n    if isinstance(array, ExplicitlyIndexed):\n        return array\n    if isinstance(array, np.ndarray):\n        return NumpyIndexingAdapter(array)\n    if isinstance(array, pd.Index):\n        return PandasIndexAdapter(array)\n    if isinstance(array, dask_array_type):\n        return DaskIndexingAdapter(array)\n    if hasattr(array, '__array_function__'):\n        return NdArrayLikeIndexingAdapter(array)\n    raise TypeError('Invalid array type: {}'.format(type(array)))",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.__init__": "def __init__(self, array):\n    if not isinstance(array, np.ndarray):\n        raise TypeError('NumpyIndexingAdapter only wraps np.ndarray. Trying to wrap {}'.format(type(array)))\n    self.array = array",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter.__getitem__": "def __getitem__(self, key):\n    array, key = self._indexing_array_and_key(key)\n    return array[key]",
    ".xarray.core.indexing.py@@NumpyIndexingAdapter._indexing_array_and_key": "def _indexing_array_and_key(self, key):\n    if isinstance(key, OuterIndexer):\n        array = self.array\n        key = _outer_to_numpy_indexer(key, self.array.shape)\n    elif isinstance(key, VectorizedIndexer):\n        array = nputils.NumpyVIndexAdapter(self.array)\n        key = key.tuple\n    elif isinstance(key, BasicIndexer):\n        array = self.array\n        key = key.tuple + (Ellipsis,)\n    else:\n        raise TypeError('unexpected key type: {}'.format(type(key)))\n    return (array, key)",
    ".xarray.core.indexing.py@@ExplicitIndexer.tuple": "def tuple(self):\n    return self._key",
    ".xarray.core.variable.py@@Variable._finalize_indexing_result": "def _finalize_indexing_result(self: VariableType, dims, data) -> VariableType:\n    return self._replace(dims=dims, data=data)",
    ".xarray.core.variable.py@@Variable._replace": "def _replace(self: VariableType, dims=_default, data=_default, attrs=_default, encoding=_default) -> VariableType:\n    if dims is _default:\n        dims = copy.copy(self._dims)\n    if data is _default:\n        data = copy.copy(self.data)\n    if attrs is _default:\n        attrs = copy.copy(self._attrs)\n    if encoding is _default:\n        encoding = copy.copy(self._encoding)\n    return type(self)(dims, data, attrs, encoding, fastpath=True)",
    ".xarray.core.variable.py@@Variable.__init__": "def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):\n    self._data = as_compatible_data(data, fastpath=fastpath)\n    self._dims = self._parse_dimensions(dims)\n    self._attrs = None\n    self._encoding = None\n    if attrs is not None:\n        self.attrs = attrs\n    if encoding is not None:\n        self.encoding = encoding",
    ".xarray.core.variable.py@@as_compatible_data": "def as_compatible_data(data, fastpath=False):\n    if fastpath and getattr(data, 'ndim', 0) > 0:\n        return _maybe_wrap_data(data)\n    if isinstance(data, Variable):\n        return data.data\n    if isinstance(data, NON_NUMPY_SUPPORTED_ARRAY_TYPES):\n        return _maybe_wrap_data(data)\n    if isinstance(data, tuple):\n        data = utils.to_0d_object_array(data)\n    if isinstance(data, pd.Timestamp):\n        data = np.datetime64(data.value, 'ns')\n    if isinstance(data, timedelta):\n        data = np.timedelta64(getattr(data, 'value', data), 'ns')\n    if isinstance(data, (pd.Series, pd.Index, pd.DataFrame)):\n        data = data.values\n    if isinstance(data, np.ma.MaskedArray):\n        mask = np.ma.getmaskarray(data)\n        if mask.any():\n            dtype, fill_value = dtypes.maybe_promote(data.dtype)\n            data = np.asarray(data, dtype=dtype)\n            data[mask] = fill_value\n        else:\n            data = np.asarray(data)\n    if not isinstance(data, np.ndarray):\n        if hasattr(data, '__array_function__'):\n            return data\n    data = np.asarray(data)\n    if isinstance(data, np.ndarray):\n        if data.dtype.kind == 'O':\n            data = _possibly_convert_objects(data)\n        elif data.dtype.kind == 'M':\n            data = _possibly_convert_objects(data)\n        elif data.dtype.kind == 'm':\n            data = _possibly_convert_objects(data)\n    return _maybe_wrap_data(data)",
    ".xarray.core.variable.py@@_maybe_wrap_data": "def _maybe_wrap_data(data):\n    if isinstance(data, pd.Index):\n        return PandasIndexAdapter(data)\n    return data",
    ".xarray.core.variable.py@@Variable._parse_dimensions": "def _parse_dimensions(self, dims):\n    if isinstance(dims, str):\n        dims = (dims,)\n    dims = tuple(dims)\n    if len(dims) != self.ndim:\n        raise ValueError('dimensions %s must have the same length as the number of data dimensions, ndim=%s' % (dims, self.ndim))\n    return dims",
    ".xarray.core.variable.py@@Variable.encoding": "def encoding(self):\n    if self._encoding is None:\n        self._encoding = {}\n    return self._encoding",
    ".xarray.core.common.py@@AbstractArray.__array__": "def __array__(self: Any, dtype: DTypeLike=None) -> np.ndarray:\n    return np.asarray(self.values, dtype=dtype)",
    ".xarray.core.variable.py@@Variable.values": "def values(self):\n    return _as_array_or_item(self._data)",
    ".xarray.core.variable.py@@_as_array_or_item": "def _as_array_or_item(data):\n    if isinstance(data, cupy_array_type):\n        data = data.get()\n    else:\n        data = np.asarray(data)\n    if data.ndim == 0:\n        if data.dtype.kind == 'M':\n            data = np.datetime64(data, 'ns')\n        elif data.dtype.kind == 'm':\n            data = np.timedelta64(data, 'ns')\n    return data",
    ".xarray.core.formatting.py@@format_items": "def format_items(x):\n    x = np.asarray(x)\n    timedelta_format = 'datetime'\n    if np.issubdtype(x.dtype, np.timedelta64):\n        x = np.asarray(x, dtype='timedelta64[ns]')\n        day_part = x[~pd.isnull(x)].astype('timedelta64[D]').astype('timedelta64[ns]')\n        time_needed = x[~pd.isnull(x)] != day_part\n        day_needed = day_part != np.timedelta64(0, 'ns')\n        if np.logical_not(day_needed).all():\n            timedelta_format = 'time'\n        elif np.logical_not(time_needed).all():\n            timedelta_format = 'date'\n    formatted = [format_item(xi, timedelta_format) for xi in x]\n    return formatted",
    ".xarray.core.formatting.py@@format_item": "def format_item(x, timedelta_format=None, quote_strings=True):\n    if isinstance(x, (np.datetime64, datetime)):\n        return format_timestamp(x)\n    if isinstance(x, (np.timedelta64, timedelta)):\n        return format_timedelta(x, timedelta_format=timedelta_format)\n    elif isinstance(x, (str, bytes)):\n        return repr(x) if quote_strings else x\n    elif np.issubdtype(type(x), np.floating):\n        return f'{x:.4}'\n    else:\n        return str(x)",
    ".xarray.core.formatting.py@@last_n_items": "def last_n_items(array, n_desired):\n    if n_desired == 0 or array.size == 0:\n        return []\n    if n_desired < array.size:\n        indexer = _get_indexer_at_least_n_items(array.shape, n_desired, from_end=True)\n        array = array[indexer]\n    return np.asarray(array).flat[-n_desired:]",
    ".xarray.core.coordinates.py@@Coordinates.__len__": "def __len__(self) -> int:\n    return len(self._names)",
    ".xarray.core.coordinates.py@@DatasetCoordinates._names": "def _names(self) -> Set[Hashable]:\n    return self._data._coord_names",
    ".xarray.core.coordinates.py@@Coordinates.__iter__": "def __iter__(self) -> Iterator['Hashable']:\n    for k in self.variables:\n        if k in self._names:\n            yield k",
    ".xarray.core.coordinates.py@@DatasetCoordinates.variables": "def variables(self) -> Mapping[Hashable, Variable]:\n    return Frozen({k: v for k, v in self._data.variables.items() if k in self._names})",
    ".xarray.core.utils.py@@Frozen.__iter__": "def __iter__(self) -> Iterator[K]:\n    return iter(self.mapping)",
    ".xarray.core.coordinates.py@@DatasetCoordinates.__getitem__": "def __getitem__(self, key: Hashable) -> 'DataArray':\n    if key in self._data.data_vars:\n        raise KeyError(key)\n    return cast('DataArray', self._data[key])",
    ".xarray.core.dataset.py@@Dataset.data_vars": "def data_vars(self) -> DataVariables:\n    return DataVariables(self)",
    ".xarray.core.dataset.py@@DataVariables.__init__": "def __init__(self, dataset: 'Dataset'):\n    self._dataset = dataset",
    ".xarray.core.dataset.py@@DataVariables.__contains__": "def __contains__(self, key: Hashable) -> bool:\n    return key in self._dataset._variables and key not in self._dataset._coord_names",
    ".xarray.core.formatting.py@@summarize_coord": "def summarize_coord(name: Hashable, var, col_width: int):\n    is_index = name in var.dims\n    marker = '*' if is_index else ' '\n    if is_index:\n        coord = var.variable.to_index_variable()\n        if coord.level_names is not None:\n            return '\\n'.join([_summarize_coord_multiindex(coord, col_width, marker), _summarize_coord_levels(coord, col_width)])\n    return summarize_variable(name, var.variable, col_width, marker)",
    ".xarray.core.dataarray.py@@DataArray.dims": "def dims(self) -> Tuple[Hashable, ...]:\n    return self.variable.dims",
    ".xarray.core.variable.py@@IndexVariable.to_index_variable": "def to_index_variable(self):\n    return self",
    ".xarray.core.variable.py@@IndexVariable.level_names": "def level_names(self):\n    index = self.to_index()\n    if isinstance(index, pd.MultiIndex):\n        return index.names\n    else:\n        return None",
    ".xarray.core.variable.py@@IndexVariable.to_index": "def to_index(self):\n    assert self.ndim == 1\n    index = self._data.array\n    if isinstance(index, pd.MultiIndex):\n        valid_level_names = [name or '{}_level_{}'.format(self.dims[0], i) for i, name in enumerate(index.names)]\n        index = index.set_names(valid_level_names)\n    else:\n        index = index.set_names(self.name)\n    return index",
    ".xarray.core.indexing.py@@PandasIndexAdapter.shape": "def shape(self) -> Tuple[int]:\n    return (len(self.array),)",
    ".xarray.core.variable.py@@IndexVariable.name": "def name(self):\n    return self.dims[0]",
    ".xarray.core.indexing.py@@PandasIndexAdapter.dtype": "def dtype(self) -> np.dtype:\n    return self._dtype",
    ".xarray.core.indexing.py@@PandasIndexAdapter.__getitem__": "def __getitem__(self, indexer) -> Union[NumpyIndexingAdapter, np.ndarray, np.datetime64, np.timedelta64]:\n    key = indexer.tuple\n    if isinstance(key, tuple) and len(key) == 1:\n        key, = key\n    if getattr(key, 'ndim', 0) > 1:\n        return NumpyIndexingAdapter(self.array.values)[indexer]\n    result = self.array[key]\n    if isinstance(result, pd.Index):\n        result = PandasIndexAdapter(result, dtype=self.dtype)\n    else:\n        if result is pd.NaT:\n            result = np.datetime64('NaT', 'ns')\n        elif isinstance(result, timedelta):\n            result = np.timedelta64(getattr(result, 'value', result), 'ns')\n        elif isinstance(result, pd.Timestamp):\n            result = np.asarray(result.to_datetime64())\n        elif self.dtype != object:\n            result = np.asarray(result, dtype=self.dtype)\n        result = utils.to_0d_array(result)\n    return result",
    ".xarray.core.indexing.py@@PandasIndexAdapter.__init__": "def __init__(self, array: Any, dtype: DTypeLike=None):\n    self.array = utils.safe_cast_to_index(array)\n    if dtype is None:\n        if isinstance(array, pd.PeriodIndex):\n            dtype_ = np.dtype('O')\n        elif hasattr(array, 'categories'):\n            dtype_ = array.categories.dtype\n        elif not utils.is_valid_numpy_dtype(array.dtype):\n            dtype_ = np.dtype('O')\n        else:\n            dtype_ = array.dtype\n    else:\n        dtype_ = np.dtype(dtype)\n    self._dtype = dtype_",
    ".xarray.core.utils.py@@safe_cast_to_index": "def safe_cast_to_index(array: Any) -> pd.Index:\n    if isinstance(array, pd.Index):\n        index = array\n    elif hasattr(array, 'to_index'):\n        index = array.to_index()\n    else:\n        kwargs = {}\n        if hasattr(array, 'dtype') and array.dtype.kind == 'O':\n            kwargs['dtype'] = object\n        index = pd.Index(np.asarray(array), **kwargs)\n    return _maybe_cast_to_cftimeindex(index)",
    ".xarray.core.utils.py@@_maybe_cast_to_cftimeindex": "def _maybe_cast_to_cftimeindex(index: pd.Index) -> pd.Index:\n    from ..coding.cftimeindex import CFTimeIndex\n    if len(index) > 0 and index.dtype == 'O':\n        try:\n            return CFTimeIndex(index)\n        except (ImportError, TypeError):\n            return index\n    else:\n        return index",
    ".xarray.core.variable.py@@IndexVariable._finalize_indexing_result": "def _finalize_indexing_result(self, dims, data):\n    if getattr(data, 'ndim', 0) != 1:\n        return Variable(dims, data, self._attrs, self._encoding)\n    else:\n        return self._replace(dims=dims, data=data)",
    ".xarray.core.variable.py@@IndexVariable.__init__": "def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):\n    super().__init__(dims, data, attrs, encoding, fastpath)\n    if self.ndim != 1:\n        raise ValueError('%s objects must be 1-dimensional' % type(self).__name__)\n    if not isinstance(self._data, PandasIndexAdapter):\n        self._data = PandasIndexAdapter(self._data)",
    ".xarray.core.variable.py@@Variable.attrs": "def attrs(self) -> Dict[Hashable, Any]:\n    if self._attrs is None:\n        self._attrs = {}\n    return self._attrs",
    ".xarray.core.indexing.py@@PandasIndexAdapter.__array__": "def __array__(self, dtype: DTypeLike=None) -> np.ndarray:\n    if dtype is None:\n        dtype = self.dtype\n    array = self.array\n    if isinstance(array, pd.PeriodIndex):\n        with suppress(AttributeError):\n            array = array.astype('object')\n    return np.asarray(array.values, dtype=dtype)",
    ".xarray.core.formatting.py@@format_timestamp": "def format_timestamp(t):\n    try:\n        datetime_str = str(pd.Timestamp(t))\n    except OutOfBoundsDatetime:\n        datetime_str = str(t)\n    try:\n        date_str, time_str = datetime_str.split()\n    except ValueError:\n        return datetime_str\n    else:\n        if time_str == '00:00:00':\n            return date_str\n        else:\n            return f'{date_str}T{time_str}'",
    ".xarray.coding.cftimeindex.py@@CFTimeIndex.__new__": "def __new__(cls, data, name=None):\n    assert_all_valid_date_type(data)\n    if name is None and hasattr(data, 'name'):\n        name = data.name\n    result = object.__new__(cls)\n    result._data = np.array(data, dtype='O')\n    result.name = name\n    result._cache = {}\n    return result",
    ".xarray.coding.cftimeindex.py@@assert_all_valid_date_type": "def assert_all_valid_date_type(data):\n    import cftime\n    if len(data) > 0:\n        sample = data[0]\n        date_type = type(sample)\n        if not isinstance(sample, cftime.datetime):\n            raise TypeError('CFTimeIndex requires cftime.datetime objects. Got object of {}.'.format(date_type))\n        if not all((isinstance(value, date_type) for value in data)):\n            raise TypeError('CFTimeIndex requires using datetime objects of all the same type.  Got\\n{}.'.format(data))",
    ".xarray.core.formatting.py@@summarize_attr": "def summarize_attr(key, value, col_width=None):\n    k_str = f'    {key}:'\n    if col_width is not None:\n        k_str = pretty_print(k_str, col_width)\n    v_str = str(value).replace('\\t', '\\\\t').replace('\\n', '\\\\n')\n    return maybe_truncate(f'{k_str} {v_str}', OPTIONS['display_width'])",
    ".xarray.core.formatting.py@@_summarize_coord_multiindex": "def _summarize_coord_multiindex(coord, col_width, marker):\n    first_col = pretty_print(f'  {marker} {coord.name} ', col_width)\n    return '{}({}) MultiIndex'.format(first_col, str(coord.dims[0]))",
    ".xarray.core.formatting.py@@_summarize_coord_levels": "def _summarize_coord_levels(coord, col_width, marker='-'):\n    if len(coord) > 100 and col_width < len(coord):\n        n_values = col_width\n        indices = list(range(0, n_values)) + list(range(-n_values, 0))\n        subset = coord[indices]\n    else:\n        subset = coord\n    return '\\n'.join((summarize_variable(lname, subset.get_level_variable(lname), col_width, marker=marker) for lname in subset.level_names))",
    ".xarray.core.utils.py@@NdimSizeLenMixin.__len__": "def __len__(self: Any) -> int:\n    try:\n        return self.shape[0]\n    except IndexError:\n        raise TypeError('len() of unsized object')",
    ".xarray.core.variable.py@@IndexVariable.get_level_variable": "def get_level_variable(self, level):\n    if self.level_names is None:\n        raise ValueError('IndexVariable %r has no MultiIndex' % self.name)\n    index = self.to_index()\n    return type(self)(self.dims, index.get_level_values(level))",
    ".xarray.core.utils.py@@is_valid_numpy_dtype": "def is_valid_numpy_dtype(dtype: Any) -> bool:\n    try:\n        np.dtype(dtype)\n    except (TypeError, ValueError):\n        return False\n    else:\n        return True"
}