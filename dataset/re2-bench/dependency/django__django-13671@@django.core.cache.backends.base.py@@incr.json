{
    ".django.core.cache.backends.filebased.py@@FileBasedCache.get": "def get(self, key, default=None, version=None):\n    fname = self._key_to_file(key, version)\n    try:\n        with open(fname, 'rb') as f:\n            if not self._is_expired(f):\n                return pickle.loads(zlib.decompress(f.read()))\n    except FileNotFoundError:\n        pass\n    return default",
    ".django.core.cache.backends.filebased.py@@FileBasedCache._key_to_file": "def _key_to_file(self, key, version=None):\n    key = self.make_key(key, version=version)\n    self.validate_key(key)\n    return os.path.join(self._dir, ''.join([hashlib.md5(key.encode()).hexdigest(), self.cache_suffix]))",
    ".django.core.cache.backends.base.py@@default_key_func": "def default_key_func(key, key_prefix, version):\n    return '%s:%s:%s' % (key_prefix, version, key)",
    ".django.core.cache.backends.base.py@@memcache_key_warnings": "def memcache_key_warnings(key):\n    if len(key) > MEMCACHE_MAX_KEY_LENGTH:\n        yield ('Cache key will cause errors if used with memcached: %r (longer than %s)' % (key, MEMCACHE_MAX_KEY_LENGTH))\n    for char in key:\n        if ord(char) < 33 or ord(char) == 127:\n            yield ('Cache key contains characters that will cause errors if used with memcached: %r' % key)\n            break",
    ".django.core.cache.backends.filebased.py@@FileBasedCache._is_expired": "def _is_expired(self, f):\n    try:\n        exp = pickle.load(f)\n    except EOFError:\n        exp = 0\n    if exp is not None and exp < time.time():\n        f.close()\n        self._delete(f.name)\n        return True\n    return False",
    ".django.core.cache.backends.filebased.py@@FileBasedCache.set": "def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n    self._createdir()\n    fname = self._key_to_file(key, version)\n    self._cull()\n    fd, tmp_path = tempfile.mkstemp(dir=self._dir)\n    renamed = False\n    try:\n        with open(fd, 'wb') as f:\n            self._write_content(f, timeout, value)\n        file_move_safe(tmp_path, fname, allow_overwrite=True)\n        renamed = True\n    finally:\n        if not renamed:\n            os.remove(tmp_path)",
    ".django.core.cache.backends.filebased.py@@FileBasedCache._createdir": "def _createdir(self):\n    old_umask = os.umask(63)\n    try:\n        os.makedirs(self._dir, 448, exist_ok=True)\n    finally:\n        os.umask(old_umask)",
    ".django.core.cache.backends.filebased.py@@FileBasedCache._cull": "def _cull(self):\n    filelist = self._list_cache_files()\n    num_entries = len(filelist)\n    if num_entries < self._max_entries:\n        return\n    if self._cull_frequency == 0:\n        return self.clear()\n    filelist = random.sample(filelist, int(num_entries / self._cull_frequency))\n    for fname in filelist:\n        self._delete(fname)",
    ".django.core.cache.backends.filebased.py@@FileBasedCache._list_cache_files": "def _list_cache_files(self):\n    return [os.path.join(self._dir, fname) for fname in glob.glob1(self._dir, '*%s' % self.cache_suffix)]",
    ".django.core.cache.backends.filebased.py@@FileBasedCache._write_content": "def _write_content(self, file, timeout, value):\n    expiry = self.get_backend_timeout(timeout)\n    file.write(pickle.dumps(expiry, self.pickle_protocol))\n    file.write(zlib.compress(pickle.dumps(value, self.pickle_protocol)))",
    ".django.core.files.move.py@@file_move_safe": "def file_move_safe(old_file_name, new_file_name, chunk_size=1024 * 64, allow_overwrite=False):\n    if _samefile(old_file_name, new_file_name):\n        return\n    try:\n        if not allow_overwrite and os.access(new_file_name, os.F_OK):\n            raise FileExistsError('Destination file %s exists and allow_overwrite is False.' % new_file_name)\n        os.rename(old_file_name, new_file_name)\n        return\n    except OSError:\n        pass\n    with open(old_file_name, 'rb') as old_file:\n        fd = os.open(new_file_name, os.O_WRONLY | os.O_CREAT | getattr(os, 'O_BINARY', 0) | (os.O_EXCL if not allow_overwrite else 0))\n        try:\n            locks.lock(fd, locks.LOCK_EX)\n            current_chunk = None\n            while current_chunk != b'':\n                current_chunk = old_file.read(chunk_size)\n                os.write(fd, current_chunk)\n        finally:\n            locks.unlock(fd)\n            os.close(fd)\n    try:\n        copystat(old_file_name, new_file_name)\n    except PermissionError as e:\n        if e.errno != errno.EPERM:\n            raise\n    try:\n        os.remove(old_file_name)\n    except PermissionError as e:\n        if getattr(e, 'winerror', 0) != 32:\n            raise",
    ".django.core.files.move.py@@_samefile": "def _samefile(src, dst):\n    if hasattr(os.path, 'samefile'):\n        try:\n            return os.path.samefile(src, dst)\n        except OSError:\n            return False\n    return os.path.normcase(os.path.abspath(src)) == os.path.normcase(os.path.abspath(dst))",
    ".django.core.cache.backends.db.py@@DatabaseCache.get": "def get(self, key, default=None, version=None):\n    return self.get_many([key], version).get(key, default)",
    ".django.core.cache.backends.db.py@@DatabaseCache.get_many": "def get_many(self, keys, version=None):\n    if not keys:\n        return {}\n    key_map = {}\n    for key in keys:\n        self.validate_key(key)\n        key_map[self.make_key(key, version)] = key\n    db = router.db_for_read(self.cache_model_class)\n    connection = connections[db]\n    quote_name = connection.ops.quote_name\n    table = quote_name(self._table)\n    with connection.cursor() as cursor:\n        cursor.execute('SELECT %s, %s, %s FROM %s WHERE %s IN (%s)' % (quote_name('cache_key'), quote_name('value'), quote_name('expires'), table, quote_name('cache_key'), ', '.join(['%s'] * len(key_map))), list(key_map))\n        rows = cursor.fetchall()\n    result = {}\n    expired_keys = []\n    expression = models.Expression(output_field=models.DateTimeField())\n    converters = connection.ops.get_db_converters(expression) + expression.get_db_converters(connection)\n    for key, value, expires in rows:\n        for converter in converters:\n            expires = converter(expires, expression, connection)\n        if expires < timezone.now():\n            expired_keys.append(key)\n        else:\n            value = connection.ops.process_clob(value)\n            value = pickle.loads(base64.b64decode(value.encode()))\n            result[key_map.get(key)] = value\n    self._base_delete_many(expired_keys)\n    return result",
    ".django.db.utils.py@@ConnectionRouter._route_db": "def _route_db(self, model, **hints):\n    chosen_db = None\n    for router in self.routers:\n        try:\n            method = getattr(router, action)\n        except AttributeError:\n            pass\n        else:\n            chosen_db = method(model, **hints)\n            if chosen_db:\n                return chosen_db\n    instance = hints.get('instance')\n    if instance is not None and instance._state.db:\n        return instance._state.db\n    return DEFAULT_DB_ALIAS",
    ".django.utils.connection.py@@BaseConnectionHandler.__getitem__": "def __getitem__(self, alias):\n    try:\n        return getattr(self._connections, alias)\n    except AttributeError:\n        if alias not in self.settings:\n            raise self.exception_class(f\"The connection '{alias}' doesn't exist.\")\n    conn = self.create_connection(alias)\n    setattr(self._connections, alias, conn)\n    return conn",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.quote_name": "def quote_name(self, name):\n    if name.startswith('\"') and name.endswith('\"'):\n        return name\n    return '\"%s\"' % name",
    ".django.utils.asyncio.py@@inner": "def inner(*args, **kwargs):\n    if not os.environ.get('DJANGO_ALLOW_ASYNC_UNSAFE'):\n        try:\n            event_loop = asyncio.get_event_loop()\n        except RuntimeError:\n            pass\n        else:\n            if event_loop.is_running():\n                raise SynchronousOnlyOperation(message)\n    return func(*args, **kwargs)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.cursor": "def cursor(self):\n    return self._cursor()",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper._cursor": "def _cursor(self, name=None):\n    self.ensure_connection()\n    with self.wrap_database_errors:\n        return self._prepare_cursor(self.create_cursor(name))",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.ensure_connection": "def ensure_connection(self):\n    if self.connection is None:\n        with self.wrap_database_errors:\n            self.connect()",
    ".django.db.utils.py@@DatabaseErrorWrapper.__enter__": "def __enter__(self):\n    pass",
    ".django.db.backends.sqlite3.base.py@@DatabaseWrapper.create_cursor": "def create_cursor(self, name=None):\n    return self.connection.cursor(factory=SQLiteCursorWrapper)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper._prepare_cursor": "def _prepare_cursor(self, cursor):\n    self.validate_thread_sharing()\n    if self.queries_logged:\n        wrapped_cursor = self.make_debug_cursor(cursor)\n    else:\n        wrapped_cursor = self.make_cursor(cursor)\n    return wrapped_cursor",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.validate_thread_sharing": "def validate_thread_sharing(self):\n    if not (self.allow_thread_sharing or self._thread_ident == _thread.get_ident()):\n        raise DatabaseError(\"DatabaseWrapper objects created in a thread can only be used in that same thread. The object with alias '%s' was created in thread id %s and this is thread id %s.\" % (self.alias, self._thread_ident, _thread.get_ident()))",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.allow_thread_sharing": "def allow_thread_sharing(self):\n    with self._thread_sharing_lock:\n        return self._thread_sharing_count > 0",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.queries_logged": "def queries_logged(self):\n    return self.force_debug_cursor or settings.DEBUG",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.make_cursor": "def make_cursor(self, cursor):\n    return utils.CursorWrapper(cursor, self)",
    ".django.db.backends.utils.py@@CursorWrapper.__init__": "def __init__(self, cursor, db):\n    self.cursor = cursor\n    self.db = db",
    ".django.db.utils.py@@DatabaseErrorWrapper.__exit__": "def __exit__(self, exc_type, exc_value, traceback):\n    if exc_type is None:\n        return\n    for dj_exc_type in (DataError, OperationalError, IntegrityError, InternalError, ProgrammingError, NotSupportedError, DatabaseError, InterfaceError, Error):\n        db_exc_type = getattr(self.wrapper.Database, dj_exc_type.__name__)\n        if issubclass(exc_type, db_exc_type):\n            dj_exc_value = dj_exc_type(*exc_value.args)\n            if dj_exc_type not in (DataError, IntegrityError):\n                self.wrapper.errors_occurred = True\n            raise dj_exc_value.with_traceback(traceback) from exc_value",
    ".django.db.backends.utils.py@@CursorWrapper.__enter__": "def __enter__(self):\n    return self",
    ".django.db.backends.utils.py@@CursorWrapper.execute": "def execute(self, sql, params=None):\n    return self._execute_with_wrappers(sql, params, many=False, executor=self._execute)",
    ".django.db.backends.utils.py@@CursorWrapper._execute_with_wrappers": "def _execute_with_wrappers(self, sql, params, many, executor):\n    context = {'connection': self.db, 'cursor': self}\n    for wrapper in reversed(self.db.execute_wrappers):\n        executor = functools.partial(wrapper, executor)\n    return executor(sql, params, many, context)",
    ".django.db.backends.utils.py@@CursorWrapper._execute": "def _execute(self, sql, params, *ignored_wrapper_args):\n    self.db.validate_no_broken_transaction()\n    with self.db.wrap_database_errors:\n        if params is None:\n            return self.cursor.execute(sql)\n        else:\n            return self.cursor.execute(sql, params)",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.validate_no_broken_transaction": "def validate_no_broken_transaction(self):\n    if self.needs_rollback:\n        raise TransactionManagementError(\"An error occurred in the current transaction. You can't execute queries until the end of the 'atomic' block.\")",
    ".django.db.backends.sqlite3.base.py@@SQLiteCursorWrapper.execute": "def execute(self, query, params=None):\n    if params is None:\n        return Database.Cursor.execute(self, query)\n    query = self.convert_query(query)\n    return Database.Cursor.execute(self, query, params)",
    ".django.db.backends.sqlite3.base.py@@SQLiteCursorWrapper.convert_query": "def convert_query(self, query):\n    return FORMAT_QMARK_REGEX.sub('?', query).replace('%%', '%')",
    ".django.utils.functional.py@@inner": "def inner(self, *args):\n    if self._wrapped is empty:\n        self._setup()\n    return func(self._wrapped, *args)",
    ".django.utils.dateparse.py@@parse_datetime": "def parse_datetime(value):\n    match = datetime_re.match(value)\n    if match:\n        kw = match.groupdict()\n        kw['microsecond'] = kw['microsecond'] and kw['microsecond'].ljust(6, '0')\n        tzinfo = kw.pop('tzinfo')\n        if tzinfo == 'Z':\n            tzinfo = utc\n        elif tzinfo is not None:\n            offset_mins = int(tzinfo[-2:]) if len(tzinfo) > 3 else 0\n            offset = 60 * int(tzinfo[1:3]) + offset_mins\n            if tzinfo[0] == '-':\n                offset = -offset\n            tzinfo = get_fixed_timezone(offset)\n        kw = {k: int(v) for k, v in kw.items() if v is not None}\n        kw['tzinfo'] = tzinfo\n        return datetime.datetime(**kw)",
    ".django.db.backends.utils.py@@CursorWrapper.__getattr__": "def __getattr__(self, attr):\n    cursor_attr = getattr(self.cursor, attr)\n    if attr in CursorWrapper.WRAP_ERROR_ATTRS:\n        return self.db.wrap_database_errors(cursor_attr)\n    else:\n        return cursor_attr",
    ".django.db.utils.py@@DatabaseErrorWrapper.__call__": "def __call__(self, func):\n\n    def inner(*args, **kwargs):\n        with self:\n            return func(*args, **kwargs)\n    return inner",
    ".django.db.utils.py@@DatabaseErrorWrapper.inner": "def inner(*args, **kwargs):\n    with self:\n        return func(*args, **kwargs)",
    ".django.db.backends.utils.py@@CursorWrapper.__exit__": "def __exit__(self, type, value, traceback):\n    try:\n        self.close()\n    except self.db.Database.Error:\n        pass",
    ".django.db.models.fields.__init__.py@@DateField.__init__": "def __init__(self, verbose_name=None, name=None, auto_now=False, auto_now_add=False, **kwargs):\n    self.auto_now, self.auto_now_add = (auto_now, auto_now_add)\n    if auto_now or auto_now_add:\n        kwargs['editable'] = False\n        kwargs['blank'] = True\n    super().__init__(verbose_name, name, **kwargs)",
    ".django.db.models.fields.__init__.py@@Field.__init__": "def __init__(self, verbose_name=None, name=None, primary_key=False, max_length=None, unique=False, blank=False, null=False, db_index=False, rel=None, default=NOT_PROVIDED, editable=True, serialize=True, unique_for_date=None, unique_for_month=None, unique_for_year=None, choices=None, help_text='', db_column=None, db_tablespace=None, auto_created=False, validators=(), error_messages=None):\n    self.name = name\n    self.verbose_name = verbose_name\n    self._verbose_name = verbose_name\n    self.primary_key = primary_key\n    self.max_length, self._unique = (max_length, unique)\n    self.blank, self.null = (blank, null)\n    self.remote_field = rel\n    self.is_relation = self.remote_field is not None\n    self.default = default\n    self.editable = editable\n    self.serialize = serialize\n    self.unique_for_date = unique_for_date\n    self.unique_for_month = unique_for_month\n    self.unique_for_year = unique_for_year\n    if isinstance(choices, collections.abc.Iterator):\n        choices = list(choices)\n    self.choices = choices\n    self.help_text = help_text\n    self.db_index = db_index\n    self.db_column = db_column\n    self._db_tablespace = db_tablespace\n    self.auto_created = auto_created\n    if auto_created:\n        self.creation_counter = Field.auto_creation_counter\n        Field.auto_creation_counter -= 1\n    else:\n        self.creation_counter = Field.creation_counter\n        Field.creation_counter += 1\n    self._validators = list(validators)\n    messages = {}\n    for c in reversed(self.__class__.__mro__):\n        messages.update(getattr(c, 'default_error_messages', {}))\n    messages.update(error_messages or {})\n    self._error_messages = error_messages\n    self.error_messages = messages",
    ".django.utils.deconstruct.py@@__new__": "def __new__(cls, *args, **kwargs):\n    obj = super(klass, cls).__new__(cls)\n    obj._constructor_args = (args, kwargs)\n    return obj",
    ".django.db.models.expressions.py@@BaseExpression.__init__": "def __init__(self, output_field=None):\n    if output_field is not None:\n        self.output_field = output_field",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.get_db_converters": "def get_db_converters(self, expression):\n    converters = super().get_db_converters(expression)\n    internal_type = expression.output_field.get_internal_type()\n    if internal_type == 'DateTimeField':\n        converters.append(self.convert_datetimefield_value)\n    elif internal_type == 'DateField':\n        converters.append(self.convert_datefield_value)\n    elif internal_type == 'TimeField':\n        converters.append(self.convert_timefield_value)\n    elif internal_type == 'DecimalField':\n        converters.append(self.get_decimalfield_converter(expression))\n    elif internal_type == 'UUIDField':\n        converters.append(self.convert_uuidfield_value)\n    elif internal_type in ('NullBooleanField', 'BooleanField'):\n        converters.append(self.convert_booleanfield_value)\n    return converters",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.get_db_converters": "def get_db_converters(self, expression):\n    return []",
    ".django.db.models.fields.__init__.py@@DateTimeField.get_internal_type": "def get_internal_type(self):\n    return 'DateTimeField'",
    ".django.db.models.expressions.py@@BaseExpression.get_db_converters": "def get_db_converters(self, connection):\n    return ([] if self.convert_value is self._convert_value_noop else [self.convert_value]) + self.output_field.get_db_converters(connection)",
    ".django.utils.functional.py@@cached_property.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    res = instance.__dict__[self.name] = self.func(instance)\n    return res",
    ".django.db.models.expressions.py@@BaseExpression.convert_value": "def convert_value(self):\n    field = self.output_field\n    internal_type = field.get_internal_type()\n    if internal_type == 'FloatField':\n        return lambda value, expression, connection: None if value is None else float(value)\n    elif internal_type.endswith('IntegerField'):\n        return lambda value, expression, connection: None if value is None else int(value)\n    elif internal_type == 'DecimalField':\n        return lambda value, expression, connection: None if value is None else Decimal(value)\n    return self._convert_value_noop",
    ".django.db.models.fields.__init__.py@@Field.get_db_converters": "def get_db_converters(self, connection):\n    if hasattr(self, 'from_db_value'):\n        return [self.from_db_value]\n    return []",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.convert_datetimefield_value": "def convert_datetimefield_value(self, value, expression, connection):\n    if value is not None:\n        if not isinstance(value, datetime.datetime):\n            value = parse_datetime(value)\n        if settings.USE_TZ and (not timezone.is_aware(value)):\n            value = timezone.make_aware(value, self.connection.timezone)\n    return value",
    ".django.utils.timezone.py@@now": "def now():\n    if settings.USE_TZ:\n        return datetime.utcnow().replace(tzinfo=utc)\n    else:\n        return datetime.now()",
    ".django.db.backends.base.operations.py@@BaseDatabaseOperations.process_clob": "def process_clob(self, value):\n    return value",
    ".django.core.cache.backends.db.py@@DatabaseCache._base_delete_many": "def _base_delete_many(self, keys):\n    if not keys:\n        return False\n    db = router.db_for_write(self.cache_model_class)\n    connection = connections[db]\n    quote_name = connection.ops.quote_name\n    table = quote_name(self._table)\n    with connection.cursor() as cursor:\n        cursor.execute('DELETE FROM %s WHERE %s IN (%s)' % (table, quote_name('cache_key'), ', '.join(['%s'] * len(keys))), keys)\n    return bool(cursor.rowcount)",
    ".django.core.cache.backends.db.py@@DatabaseCache.set": "def set(self, key, value, timeout=DEFAULT_TIMEOUT, version=None):\n    key = self.make_key(key, version=version)\n    self.validate_key(key)\n    self._base_set('set', key, value, timeout)",
    ".django.core.cache.backends.db.py@@DatabaseCache._base_set": "def _base_set(self, mode, key, value, timeout=DEFAULT_TIMEOUT):\n    timeout = self.get_backend_timeout(timeout)\n    db = router.db_for_write(self.cache_model_class)\n    connection = connections[db]\n    quote_name = connection.ops.quote_name\n    table = quote_name(self._table)\n    with connection.cursor() as cursor:\n        cursor.execute('SELECT COUNT(*) FROM %s' % table)\n        num = cursor.fetchone()[0]\n        now = timezone.now()\n        now = now.replace(microsecond=0)\n        if timeout is None:\n            exp = datetime.max\n        elif settings.USE_TZ:\n            exp = datetime.utcfromtimestamp(timeout)\n        else:\n            exp = datetime.fromtimestamp(timeout)\n        exp = exp.replace(microsecond=0)\n        if num > self._max_entries:\n            self._cull(db, cursor, now)\n        pickled = pickle.dumps(value, self.pickle_protocol)\n        b64encoded = base64.b64encode(pickled).decode('latin1')\n        try:\n            with transaction.atomic(using=db):\n                cursor.execute('SELECT %s, %s FROM %s WHERE %s = %%s' % (quote_name('cache_key'), quote_name('expires'), table, quote_name('cache_key')), [key])\n                result = cursor.fetchone()\n                if result:\n                    current_expires = result[1]\n                    expression = models.Expression(output_field=models.DateTimeField())\n                    for converter in connection.ops.get_db_converters(expression) + expression.get_db_converters(connection):\n                        current_expires = converter(current_expires, expression, connection)\n                exp = connection.ops.adapt_datetimefield_value(exp)\n                if result and mode == 'touch':\n                    cursor.execute('UPDATE %s SET %s = %%s WHERE %s = %%s' % (table, quote_name('expires'), quote_name('cache_key')), [exp, key])\n                elif result and (mode == 'set' or (mode == 'add' and current_expires < now)):\n                    cursor.execute('UPDATE %s SET %s = %%s, %s = %%s WHERE %s = %%s' % (table, quote_name('value'), quote_name('expires'), quote_name('cache_key')), [b64encoded, exp, key])\n                elif mode != 'touch':\n                    cursor.execute('INSERT INTO %s (%s, %s, %s) VALUES (%%s, %%s, %%s)' % (table, quote_name('cache_key'), quote_name('value'), quote_name('expires')), [key, b64encoded, exp])\n                else:\n                    return False\n        except DatabaseError:\n            return False\n        else:\n            return True",
    ".django.db.transaction.py@@atomic": "def atomic(using=None, savepoint=True, durable=False):\n    if callable(using):\n        return Atomic(DEFAULT_DB_ALIAS, savepoint, durable)(using)\n    else:\n        return Atomic(using, savepoint, durable)",
    ".django.db.transaction.py@@Atomic.__init__": "def __init__(self, using, savepoint, durable):\n    self.using = using\n    self.savepoint = savepoint\n    self.durable = durable",
    ".django.db.transaction.py@@Atomic.__enter__": "def __enter__(self):\n    connection = get_connection(self.using)\n    if self.durable and self._ensure_durability and connection.in_atomic_block:\n        raise RuntimeError('A durable atomic block cannot be nested within another atomic block.')\n    if not connection.in_atomic_block:\n        connection.commit_on_exit = True\n        connection.needs_rollback = False\n        if not connection.get_autocommit():\n            connection.in_atomic_block = True\n            connection.commit_on_exit = False\n    if connection.in_atomic_block:\n        if self.savepoint and (not connection.needs_rollback):\n            sid = connection.savepoint()\n            connection.savepoint_ids.append(sid)\n        else:\n            connection.savepoint_ids.append(None)\n    else:\n        connection.set_autocommit(False, force_begin_transaction_with_broken_autocommit=True)\n        connection.in_atomic_block = True",
    ".django.db.transaction.py@@get_connection": "def get_connection(using=None):\n    if using is None:\n        using = DEFAULT_DB_ALIAS\n    return connections[using]",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.get_autocommit": "def get_autocommit(self):\n    self.ensure_connection()\n    return self.autocommit",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.set_autocommit": "def set_autocommit(self, autocommit, force_begin_transaction_with_broken_autocommit=False):\n    self.validate_no_atomic_block()\n    self.ensure_connection()\n    start_transaction_under_autocommit = force_begin_transaction_with_broken_autocommit and (not autocommit) and hasattr(self, '_start_transaction_under_autocommit')\n    if start_transaction_under_autocommit:\n        self._start_transaction_under_autocommit()\n    else:\n        self._set_autocommit(autocommit)\n    self.autocommit = autocommit\n    if autocommit and self.run_commit_hooks_on_set_autocommit_on:\n        self.run_and_clear_commit_hooks()\n        self.run_commit_hooks_on_set_autocommit_on = False",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.validate_no_atomic_block": "def validate_no_atomic_block(self):\n    if self.in_atomic_block:\n        raise TransactionManagementError(\"This is forbidden when an 'atomic' block is active.\")",
    ".django.db.backends.sqlite3.base.py@@DatabaseWrapper._start_transaction_under_autocommit": "def _start_transaction_under_autocommit(self):\n    self.cursor().execute('BEGIN')",
    ".django.db.backends.sqlite3.operations.py@@DatabaseOperations.adapt_datetimefield_value": "def adapt_datetimefield_value(self, value):\n    if value is None:\n        return None\n    if hasattr(value, 'resolve_expression'):\n        return value\n    if timezone.is_aware(value):\n        if settings.USE_TZ:\n            value = timezone.make_naive(value, self.connection.timezone)\n        else:\n            raise ValueError('SQLite backend does not support timezone-aware datetimes when USE_TZ is False.')\n    return str(value)",
    ".django.utils.timezone.py@@is_aware": "def is_aware(value):\n    return value.utcoffset() is not None",
    ".django.db.transaction.py@@Atomic.__exit__": "def __exit__(self, exc_type, exc_value, traceback):\n    connection = get_connection(self.using)\n    if connection.savepoint_ids:\n        sid = connection.savepoint_ids.pop()\n    else:\n        connection.in_atomic_block = False\n    try:\n        if connection.closed_in_transaction:\n            pass\n        elif exc_type is None and (not connection.needs_rollback):\n            if connection.in_atomic_block:\n                if sid is not None:\n                    try:\n                        connection.savepoint_commit(sid)\n                    except DatabaseError:\n                        try:\n                            connection.savepoint_rollback(sid)\n                            connection.savepoint_commit(sid)\n                        except Error:\n                            connection.needs_rollback = True\n                        raise\n            else:\n                try:\n                    connection.commit()\n                except DatabaseError:\n                    try:\n                        connection.rollback()\n                    except Error:\n                        connection.close()\n                    raise\n        else:\n            connection.needs_rollback = False\n            if connection.in_atomic_block:\n                if sid is None:\n                    connection.needs_rollback = True\n                else:\n                    try:\n                        connection.savepoint_rollback(sid)\n                        connection.savepoint_commit(sid)\n                    except Error:\n                        connection.needs_rollback = True\n            else:\n                try:\n                    connection.rollback()\n                except Error:\n                    connection.close()\n    finally:\n        if not connection.in_atomic_block:\n            if connection.closed_in_transaction:\n                connection.connection = None\n            else:\n                connection.set_autocommit(True)\n        elif not connection.savepoint_ids and (not connection.commit_on_exit):\n            if connection.closed_in_transaction:\n                connection.connection = None\n            else:\n                connection.in_atomic_block = False",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.commit": "def commit(self):\n    self.validate_thread_sharing()\n    self.validate_no_atomic_block()\n    self._commit()\n    self.errors_occurred = False\n    self.run_commit_hooks_on_set_autocommit_on = True",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper._commit": "def _commit(self):\n    if self.connection is not None:\n        with self.wrap_database_errors:\n            return self.connection.commit()",
    ".django.db.backends.sqlite3.base.py@@DatabaseWrapper._set_autocommit": "def _set_autocommit(self, autocommit):\n    if autocommit:\n        level = None\n    else:\n        level = ''\n    with self.wrap_database_errors:\n        self.connection.isolation_level = level",
    ".django.db.backends.base.base.py@@BaseDatabaseWrapper.run_and_clear_commit_hooks": "def run_and_clear_commit_hooks(self):\n    self.validate_no_atomic_block()\n    current_run_on_commit = self.run_on_commit\n    self.run_on_commit = []\n    while current_run_on_commit:\n        sids, func = current_run_on_commit.pop(0)\n        func()",
    ".django.utils.timezone.py@@make_aware": "def make_aware(value, timezone=None, is_dst=None):\n    if timezone is None:\n        timezone = get_current_timezone()\n    if hasattr(timezone, 'localize'):\n        return timezone.localize(value, is_dst=is_dst)\n    else:\n        if is_aware(value):\n            raise ValueError('make_aware expects a naive datetime, got %s' % value)\n        return value.replace(tzinfo=timezone)"
}