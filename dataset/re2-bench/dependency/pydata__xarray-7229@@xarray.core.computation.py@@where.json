{
    ".xarray.core.options.py@@_get_keep_attrs": "def _get_keep_attrs(default: bool) -> bool:\n    return _get_boolean_with_default('keep_attrs', default)",
    ".xarray.core.options.py@@_get_boolean_with_default": "def _get_boolean_with_default(option: Options, default: bool) -> bool:\n    global_choice = OPTIONS[option]\n    if global_choice == 'default':\n        return default\n    elif isinstance(global_choice, bool):\n        return global_choice\n    else:\n        raise ValueError(f\"The global option {option} must be one of True, False or 'default'.\")",
    ".xarray.core.computation.py@@apply_ufunc": "def apply_ufunc(func: Callable, *args: Any, input_core_dims: Sequence[Sequence] | None=None, output_core_dims: Sequence[Sequence] | None=((),), exclude_dims: AbstractSet=frozenset(), vectorize: bool=False, join: JoinOptions='exact', dataset_join: str='exact', dataset_fill_value: object=_NO_FILL_VALUE, keep_attrs: bool | str | None=None, kwargs: Mapping | None=None, dask: str='forbidden', output_dtypes: Sequence | None=None, output_sizes: Mapping[Any, int] | None=None, meta: Any=None, dask_gufunc_kwargs: dict[str, Any] | None=None) -> Any:\n    from .dataarray import DataArray\n    from .groupby import GroupBy\n    from .variable import Variable\n    if input_core_dims is None:\n        input_core_dims = ((),) * len(args)\n    elif len(input_core_dims) != len(args):\n        raise ValueError(f'input_core_dims must be None or a tuple with the length same to the number of arguments. Given {len(input_core_dims)} input_core_dims: {input_core_dims},  but number of args is {len(args)}.')\n    if kwargs is None:\n        kwargs = {}\n    signature = _UFuncSignature(input_core_dims, output_core_dims)\n    if exclude_dims:\n        if not isinstance(exclude_dims, set):\n            raise TypeError(f\"Expected exclude_dims to be a 'set'. Received '{type(exclude_dims).__name__}' instead.\")\n        if not exclude_dims <= signature.all_core_dims:\n            raise ValueError(f'each dimension in `exclude_dims` must also be a core dimension in the function signature. Please make {exclude_dims - signature.all_core_dims} a core dimension')\n    if dask == 'parallelized':\n        if dask_gufunc_kwargs is None:\n            dask_gufunc_kwargs = {}\n        else:\n            dask_gufunc_kwargs = dask_gufunc_kwargs.copy()\n        if meta is not None:\n            warnings.warn('``meta`` should be given in the ``dask_gufunc_kwargs`` parameter. It will be removed as direct parameter in a future version.', FutureWarning, stacklevel=2)\n            dask_gufunc_kwargs.setdefault('meta', meta)\n        if output_sizes is not None:\n            warnings.warn('``output_sizes`` should be given in the ``dask_gufunc_kwargs`` parameter. It will be removed as direct parameter in a future version.', FutureWarning, stacklevel=2)\n            dask_gufunc_kwargs.setdefault('output_sizes', output_sizes)\n    if kwargs:\n        func = functools.partial(func, **kwargs)\n    if keep_attrs is None:\n        keep_attrs = _get_keep_attrs(default=False)\n    if isinstance(keep_attrs, bool):\n        keep_attrs = 'override' if keep_attrs else 'drop'\n    variables_vfunc = functools.partial(apply_variable_ufunc, func, signature=signature, exclude_dims=exclude_dims, keep_attrs=keep_attrs, dask=dask, vectorize=vectorize, output_dtypes=output_dtypes, dask_gufunc_kwargs=dask_gufunc_kwargs)\n    if any((isinstance(a, GroupBy) for a in args)):\n        this_apply = functools.partial(apply_ufunc, func, input_core_dims=input_core_dims, output_core_dims=output_core_dims, exclude_dims=exclude_dims, join=join, dataset_join=dataset_join, dataset_fill_value=dataset_fill_value, keep_attrs=keep_attrs, dask=dask, vectorize=vectorize, output_dtypes=output_dtypes, dask_gufunc_kwargs=dask_gufunc_kwargs)\n        return apply_groupby_func(this_apply, *args)\n    elif any((is_dict_like(a) for a in args)):\n        return apply_dataset_vfunc(variables_vfunc, *args, signature=signature, join=join, exclude_dims=exclude_dims, dataset_join=dataset_join, fill_value=dataset_fill_value, keep_attrs=keep_attrs)\n    elif any((isinstance(a, DataArray) for a in args)):\n        return apply_dataarray_vfunc(variables_vfunc, *args, signature=signature, join=join, exclude_dims=exclude_dims, keep_attrs=keep_attrs)\n    elif any((isinstance(a, Variable) for a in args)):\n        return variables_vfunc(*args)\n    else:\n        return apply_array_ufunc(func, *args, dask=dask)",
    ".xarray.core.computation.py@@_UFuncSignature.__init__": "def __init__(self, input_core_dims, output_core_dims=((),)):\n    self.input_core_dims = tuple((tuple(a) for a in input_core_dims))\n    self.output_core_dims = tuple((tuple(a) for a in output_core_dims))\n    self._all_input_core_dims = None\n    self._all_output_core_dims = None\n    self._all_core_dims = None",
    ".xarray.core.utils.py@@is_dict_like": "def is_dict_like(value: Any) -> TypeGuard[Mapping]:\n    return hasattr(value, 'keys') and hasattr(value, '__getitem__')",
    ".xarray.core.common.py@@AttrAccessMixin.__getattr__": "def __getattr__(self, name: str) -> Any:\n    if name not in {'__dict__', '__setstate__'}:\n        for source in self._attr_sources:\n            with suppress(KeyError):\n                return source[name]\n    raise AttributeError(f'{type(self).__name__!r} object has no attribute {name!r}')",
    ".xarray.core.dataarray.py@@DataArray._attr_sources": "def _attr_sources(self) -> Iterable[Mapping[Hashable, Any]]:\n    yield from self._item_sources\n    yield self.attrs",
    ".xarray.core.dataarray.py@@DataArray._item_sources": "def _item_sources(self) -> Iterable[Mapping[Hashable, Any]]:\n    yield HybridMappingProxy(keys=self._coords, mapping=self.coords)\n    yield HybridMappingProxy(keys=self.dims, mapping={})",
    ".xarray.core.dataarray.py@@DataArray.coords": "def coords(self) -> DataArrayCoordinates:\n    return DataArrayCoordinates(self)",
    ".xarray.core.coordinates.py@@DataArrayCoordinates.__init__": "def __init__(self, dataarray: T_DataArray) -> None:\n    self._data = dataarray",
    ".xarray.core.utils.py@@HybridMappingProxy.__init__": "def __init__(self, keys: Collection[K], mapping: Mapping[K, V]):\n    self._keys = keys\n    self.mapping = mapping",
    ".xarray.core.utils.py@@HybridMappingProxy.__getitem__": "def __getitem__(self, key: K) -> V:\n    return self.mapping[key]",
    ".xarray.core.coordinates.py@@DataArrayCoordinates.__getitem__": "def __getitem__(self, key: Hashable) -> T_DataArray:\n    return self._data._getitem_coord(key)",
    ".xarray.core.dataarray.py@@DataArray._getitem_coord": "def _getitem_coord(self: T_DataArray, key: Any) -> T_DataArray:\n    from .dataset import _get_virtual_variable\n    try:\n        var = self._coords[key]\n    except KeyError:\n        dim_sizes = dict(zip(self.dims, self.shape))\n        _, key, var = _get_virtual_variable(self._coords, key, dim_sizes)\n    return self._replace_maybe_drop_dims(var, name=key)",
    ".xarray.core.dataarray.py@@DataArray.dims": "def dims(self) -> tuple[Hashable, ...]:\n    return self.variable.dims",
    ".xarray.core.dataarray.py@@DataArray.variable": "def variable(self) -> Variable:\n    return self._variable",
    ".xarray.core.variable.py@@Variable.dims": "def dims(self) -> tuple[Hashable, ...]:\n    return self._dims",
    ".xarray.core.dataarray.py@@DataArray.shape": "def shape(self) -> tuple[int, ...]:\n    return self.variable.shape",
    ".xarray.core.variable.py@@Variable.shape": "def shape(self):\n    return self._data.shape",
    ".xarray.core.dataset.py@@_get_virtual_variable": "def _get_virtual_variable(variables, key: Hashable, dim_sizes: Mapping | None=None) -> tuple[Hashable, Hashable, Variable]:\n    from .dataarray import DataArray\n    if dim_sizes is None:\n        dim_sizes = {}\n    if key in dim_sizes:\n        data = pd.Index(range(dim_sizes[key]), name=key)\n        variable = IndexVariable((key,), data)\n        return (key, key, variable)\n    if not isinstance(key, str):\n        raise KeyError(key)\n    split_key = key.split('.', 1)\n    if len(split_key) != 2:\n        raise KeyError(key)\n    ref_name, var_name = split_key\n    ref_var = variables[ref_name]\n    if _contains_datetime_like_objects(ref_var):\n        ref_var = DataArray(ref_var)\n        data = getattr(ref_var.dt, var_name).data\n    else:\n        data = getattr(ref_var, var_name).data\n    virtual_var = Variable(ref_var.dims, data)\n    return (ref_name, var_name, virtual_var)",
    ".xarray.core.dataarray.py@@DataArray.attrs": "def attrs(self) -> dict[Any, Any]:\n    return self.variable.attrs",
    ".xarray.core.variable.py@@Variable.attrs": "def attrs(self) -> dict[Any, Any]:\n    if self._attrs is None:\n        self._attrs = {}\n    return self._attrs",
    ".xarray.core.computation.py@@apply_dataarray_vfunc": "def apply_dataarray_vfunc(func, *args, signature: _UFuncSignature, join: JoinOptions='inner', exclude_dims=frozenset(), keep_attrs='override') -> tuple[DataArray, ...] | DataArray:\n    from .dataarray import DataArray\n    if len(args) > 1:\n        args = deep_align(args, join=join, copy=False, exclude=exclude_dims, raise_on_invalid=False)\n    objs = _all_of_type(args, DataArray)\n    if keep_attrs == 'drop':\n        name = result_name(args)\n    else:\n        first_obj = _first_of_type(args, DataArray)\n        name = first_obj.name\n    result_coords, result_indexes = build_output_coords_and_indexes(args, signature, exclude_dims, combine_attrs=keep_attrs)\n    data_vars = [getattr(a, 'variable', a) for a in args]\n    result_var = func(*data_vars)\n    out: tuple[DataArray, ...] | DataArray\n    if signature.num_outputs > 1:\n        out = tuple((DataArray(variable, coords=coords, indexes=indexes, name=name, fastpath=True) for variable, coords, indexes in zip(result_var, result_coords, result_indexes)))\n    else:\n        coords, = result_coords\n        indexes, = result_indexes\n        out = DataArray(result_var, coords=coords, indexes=indexes, name=name, fastpath=True)\n    attrs = merge_attrs([x.attrs for x in objs], combine_attrs=keep_attrs)\n    if isinstance(out, tuple):\n        for da in out:\n            da.attrs = attrs\n    else:\n        out.attrs = attrs\n    return out",
    ".xarray.core.alignment.py@@deep_align": "def deep_align(objects: Iterable[Any], join: JoinOptions='inner', copy=True, indexes=None, exclude=frozenset(), raise_on_invalid=True, fill_value=dtypes.NA):\n    from .dataarray import DataArray\n    from .dataset import Dataset\n    if indexes is None:\n        indexes = {}\n\n    def is_alignable(obj):\n        return isinstance(obj, (DataArray, Dataset))\n    positions = []\n    keys = []\n    out = []\n    targets = []\n    no_key = object()\n    not_replaced = object()\n    for position, variables in enumerate(objects):\n        if is_alignable(variables):\n            positions.append(position)\n            keys.append(no_key)\n            targets.append(variables)\n            out.append(not_replaced)\n        elif is_dict_like(variables):\n            current_out = {}\n            for k, v in variables.items():\n                if is_alignable(v) and k not in indexes:\n                    positions.append(position)\n                    keys.append(k)\n                    targets.append(v)\n                    current_out[k] = not_replaced\n                else:\n                    current_out[k] = v\n            out.append(current_out)\n        elif raise_on_invalid:\n            raise ValueError('object to align is neither an xarray.Dataset, an xarray.DataArray nor a dictionary: {!r}'.format(variables))\n        else:\n            out.append(variables)\n    aligned = align(*targets, join=join, copy=copy, indexes=indexes, exclude=exclude, fill_value=fill_value)\n    for position, key, aligned_obj in zip(positions, keys, aligned):\n        if key is no_key:\n            out[position] = aligned_obj\n        else:\n            out[position][key] = aligned_obj\n    return out",
    ".xarray.core.alignment.py@@is_alignable": "def is_alignable(obj):\n    return isinstance(obj, (DataArray, Dataset))",
    ".xarray.core.alignment.py@@align": "def align(*objects: DataAlignable, join: JoinOptions='inner', copy: bool=True, indexes=None, exclude=frozenset(), fill_value=dtypes.NA) -> tuple[DataAlignable, ...]:\n    aligner = Aligner(objects, join=join, copy=copy, indexes=indexes, exclude_dims=exclude, fill_value=fill_value)\n    aligner.align()\n    return aligner.results",
    ".xarray.core.alignment.py@@Aligner.__init__": "def __init__(self, objects: Iterable[DataAlignable], join: str='inner', indexes: Mapping[Any, Any] | None=None, exclude_dims: Iterable=frozenset(), exclude_vars: Iterable[Hashable]=frozenset(), method: str | None=None, tolerance: int | float | Iterable[int | float] | None=None, copy: bool=True, fill_value: Any=dtypes.NA, sparse: bool=False):\n    self.objects = tuple(objects)\n    self.objects_matching_indexes = ()\n    if join not in ['inner', 'outer', 'override', 'exact', 'left', 'right']:\n        raise ValueError(f'invalid value for join: {join}')\n    self.join = join\n    self.copy = copy\n    self.fill_value = fill_value\n    self.sparse = sparse\n    if method is None and tolerance is None:\n        self.reindex_kwargs = {}\n    else:\n        self.reindex_kwargs = {'method': method, 'tolerance': tolerance}\n    if isinstance(exclude_dims, str):\n        exclude_dims = [exclude_dims]\n    self.exclude_dims = frozenset(exclude_dims)\n    self.exclude_vars = frozenset(exclude_vars)\n    if indexes is None:\n        indexes = {}\n    self.indexes, self.index_vars = self._normalize_indexes(indexes)\n    self.all_indexes = {}\n    self.all_index_vars = {}\n    self.unindexed_dim_sizes = {}\n    self.aligned_indexes = {}\n    self.aligned_index_vars = {}\n    self.reindex = {}\n    self.results = tuple()",
    ".xarray.core.alignment.py@@Aligner._normalize_indexes": "def _normalize_indexes(self, indexes: Mapping[Any, Any]) -> tuple[NormalizedIndexes, NormalizedIndexVars]:\n    if isinstance(indexes, Indexes):\n        xr_variables = dict(indexes.variables)\n    else:\n        xr_variables = {}\n    xr_indexes: dict[Hashable, Index] = {}\n    for k, idx in indexes.items():\n        if not isinstance(idx, Index):\n            if getattr(idx, 'dims', (k,)) != (k,):\n                raise ValueError(f\"Indexer has dimensions {idx.dims} that are different from that to be indexed along '{k}'\")\n            data = as_compatible_data(idx)\n            pd_idx = safe_cast_to_index(data)\n            pd_idx.name = k\n            if isinstance(pd_idx, pd.MultiIndex):\n                idx = PandasMultiIndex(pd_idx, k)\n            else:\n                idx = PandasIndex(pd_idx, k, coord_dtype=data.dtype)\n            xr_variables.update(idx.create_variables())\n        xr_indexes[k] = idx\n    normalized_indexes = {}\n    normalized_index_vars = {}\n    for idx, index_vars in Indexes(xr_indexes, xr_variables).group_by_index():\n        coord_names_and_dims = []\n        all_dims: set[Hashable] = set()\n        for name, var in index_vars.items():\n            dims = var.dims\n            coord_names_and_dims.append((name, dims))\n            all_dims.update(dims)\n        exclude_dims = all_dims & self.exclude_dims\n        if exclude_dims == all_dims:\n            continue\n        elif exclude_dims:\n            excl_dims_str = ', '.join((str(d) for d in exclude_dims))\n            incl_dims_str = ', '.join((str(d) for d in all_dims - exclude_dims))\n            raise ValueError(f'cannot exclude dimension(s) {excl_dims_str} from alignment because these are used by an index together with non-excluded dimensions {incl_dims_str}')\n        key = (tuple(coord_names_and_dims), type(idx))\n        normalized_indexes[key] = idx\n        normalized_index_vars[key] = index_vars\n    return (normalized_indexes, normalized_index_vars)",
    ".xarray.core.indexes.py@@Indexes.__init__": "def __init__(self, indexes: dict[Any, T_PandasOrXarrayIndex], variables: dict[Any, Variable]):\n    self._indexes = indexes\n    self._variables = variables\n    self._dims: Mapping[Hashable, int] | None = None\n    self.__coord_name_id: dict[Any, int] | None = None\n    self.__id_index: dict[int, T_PandasOrXarrayIndex] | None = None\n    self.__id_coord_names: dict[int, tuple[Hashable, ...]] | None = None",
    ".xarray.core.indexes.py@@Indexes.group_by_index": "def group_by_index(self) -> list[tuple[T_PandasOrXarrayIndex, dict[Hashable, Variable]]]:\n    index_coords = []\n    for i in self._id_index:\n        index = self._id_index[i]\n        coords = {k: self._variables[k] for k in self._id_coord_names[i]}\n        index_coords.append((index, coords))\n    return index_coords",
    ".xarray.core.indexes.py@@Indexes._id_index": "def _id_index(self) -> dict[int, T_PandasOrXarrayIndex]:\n    if self.__id_index is None:\n        self.__id_index = {id(idx): idx for idx in self.get_unique()}\n    return self.__id_index",
    ".xarray.core.indexes.py@@Indexes.get_unique": "def get_unique(self) -> list[T_PandasOrXarrayIndex]:\n    unique_indexes: list[T_PandasOrXarrayIndex] = []\n    seen: set[int] = set()\n    for index in self._indexes.values():\n        index_id = id(index)\n        if index_id not in seen:\n            unique_indexes.append(index)\n            seen.add(index_id)\n    return unique_indexes",
    ".xarray.core.alignment.py@@Aligner.align": "def align(self) -> None:\n    if not self.indexes and len(self.objects) == 1:\n        obj, = self.objects\n        self.results = (obj.copy(deep=self.copy),)\n        return\n    self.find_matching_indexes()\n    self.find_matching_unindexed_dims()\n    self.assert_no_index_conflict()\n    self.align_indexes()\n    self.assert_unindexed_dim_sizes_equal()\n    if self.join == 'override':\n        self.override_indexes()\n    else:\n        self.reindex_all()",
    ".xarray.core.dataarray.py@@DataArray.copy": "def copy(self: T_DataArray, deep: bool=True, data: Any=None) -> T_DataArray:\n    return self._copy(deep=deep, data=data)",
    ".xarray.core.dataarray.py@@DataArray._copy": "def _copy(self: T_DataArray, deep: bool=True, data: Any=None, memo: dict[int, Any] | None=None) -> T_DataArray:\n    variable = self.variable._copy(deep=deep, data=data, memo=memo)\n    indexes, index_vars = self.xindexes.copy_indexes(deep=deep)\n    coords = {}\n    for k, v in self._coords.items():\n        if k in index_vars:\n            coords[k] = index_vars[k]\n        else:\n            coords[k] = v._copy(deep=deep, memo=memo)\n    return self._replace(variable, coords, indexes=indexes)",
    ".xarray.core.variable.py@@Variable._copy": "def _copy(self: T_Variable, deep: bool=True, data: ArrayLike | None=None, memo: dict[int, Any] | None=None) -> T_Variable:\n    if data is None:\n        ndata = self._data\n        if isinstance(ndata, indexing.MemoryCachedArray):\n            ndata = indexing.MemoryCachedArray(ndata.array)\n        if deep:\n            ndata = copy.deepcopy(ndata, memo)\n    else:\n        ndata = as_compatible_data(data)\n        if self.shape != ndata.shape:\n            raise ValueError('Data shape {} must match shape of object {}'.format(ndata.shape, self.shape))\n    attrs = copy.deepcopy(self._attrs, memo) if deep else copy.copy(self._attrs)\n    encoding = copy.deepcopy(self._encoding, memo) if deep else copy.copy(self._encoding)\n    return self._replace(data=ndata, attrs=attrs, encoding=encoding)",
    ".xarray.core.variable.py@@Variable._replace": "def _replace(self: T_Variable, dims=_default, data=_default, attrs=_default, encoding=_default) -> T_Variable:\n    if dims is _default:\n        dims = copy.copy(self._dims)\n    if data is _default:\n        data = copy.copy(self.data)\n    if attrs is _default:\n        attrs = copy.copy(self._attrs)\n    if encoding is _default:\n        encoding = copy.copy(self._encoding)\n    return type(self)(dims, data, attrs, encoding, fastpath=True)",
    ".xarray.core.variable.py@@Variable.__init__": "def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):\n    self._data = as_compatible_data(data, fastpath=fastpath)\n    self._dims = self._parse_dimensions(dims)\n    self._attrs = None\n    self._encoding = None\n    if attrs is not None:\n        self.attrs = attrs\n    if encoding is not None:\n        self.encoding = encoding",
    ".xarray.core.variable.py@@as_compatible_data": "def as_compatible_data(data, fastpath=False):\n    from .dataarray import DataArray\n    if fastpath and getattr(data, 'ndim', 0) > 0:\n        return _maybe_wrap_data(data)\n    if isinstance(data, (Variable, DataArray)):\n        return data.data\n    if isinstance(data, NON_NUMPY_SUPPORTED_ARRAY_TYPES):\n        data = _possibly_convert_datetime_or_timedelta_index(data)\n        return _maybe_wrap_data(data)\n    if isinstance(data, tuple):\n        data = utils.to_0d_object_array(data)\n    if isinstance(data, pd.Timestamp):\n        data = np.datetime64(data.value, 'ns')\n    if isinstance(data, timedelta):\n        data = np.timedelta64(getattr(data, 'value', data), 'ns')\n    if isinstance(data, (pd.Series, pd.Index, pd.DataFrame)):\n        data = data.values\n    if isinstance(data, np.ma.MaskedArray):\n        mask = np.ma.getmaskarray(data)\n        if mask.any():\n            dtype, fill_value = dtypes.maybe_promote(data.dtype)\n            data = np.asarray(data, dtype=dtype)\n            data[mask] = fill_value\n        else:\n            data = np.asarray(data)\n    if not isinstance(data, np.ndarray) and (hasattr(data, '__array_function__') or hasattr(data, '__array_namespace__')):\n        return data\n    data = np.asarray(data)\n    if isinstance(data, np.ndarray) and data.dtype.kind in 'OMm':\n        data = _possibly_convert_objects(data)\n    return _maybe_wrap_data(data)",
    ".xarray.core.variable.py@@_maybe_wrap_data": "def _maybe_wrap_data(data):\n    if isinstance(data, pd.Index):\n        return PandasIndexingAdapter(data)\n    return data",
    ".xarray.core.variable.py@@Variable._parse_dimensions": "def _parse_dimensions(self, dims: str | Iterable[Hashable]) -> tuple[Hashable, ...]:\n    if isinstance(dims, str):\n        dims = (dims,)\n    dims = tuple(dims)\n    if len(dims) != self.ndim:\n        raise ValueError(f'dimensions {dims} must have the same length as the number of data dimensions, ndim={self.ndim}')\n    return dims",
    ".xarray.core.utils.py@@NdimSizeLenMixin.ndim": "def ndim(self: Any) -> int:\n    return len(self.shape)",
    ".xarray.core.dataarray.py@@DataArray.xindexes": "def xindexes(self) -> Indexes:\n    return Indexes(self._indexes, {k: self._coords[k] for k in self._indexes})",
    ".xarray.core.indexes.py@@Indexes.copy_indexes": "def copy_indexes(self, deep: bool=True) -> tuple[dict[Hashable, T_PandasOrXarrayIndex], dict[Hashable, Variable]]:\n    new_indexes = {}\n    new_index_vars = {}\n    for idx, coords in self.group_by_index():\n        if isinstance(idx, pd.Index):\n            convert_new_idx = True\n            dim = next(iter(coords.values())).dims[0]\n            if isinstance(idx, pd.MultiIndex):\n                idx = PandasMultiIndex(idx, dim)\n            else:\n                idx = PandasIndex(idx, dim)\n        else:\n            convert_new_idx = False\n        new_idx = idx.copy(deep=deep)\n        idx_vars = idx.create_variables(coords)\n        if convert_new_idx:\n            new_idx = cast(PandasIndex, new_idx).index\n        new_indexes.update({k: new_idx for k in coords})\n        new_index_vars.update(idx_vars)\n    return (new_indexes, new_index_vars)",
    ".xarray.core.dataarray.py@@DataArray._replace": "def _replace(self: T_DataArray, variable: Variable | None=None, coords=None, name: Hashable | None | Default=_default, indexes=None) -> T_DataArray:\n    if variable is None:\n        variable = self.variable\n    if coords is None:\n        coords = self._coords\n    if indexes is None:\n        indexes = self._indexes\n    if name is _default:\n        name = self.name\n    return type(self)(variable, coords, name=name, indexes=indexes, fastpath=True)",
    ".xarray.core.dataarray.py@@DataArray.name": "def name(self) -> Hashable | None:\n    return self._name",
    ".xarray.core.dataarray.py@@DataArray.__init__": "def __init__(self, data: Any=dtypes.NA, coords: Sequence[Sequence[Any] | pd.Index | DataArray] | Mapping[Any, Any] | None=None, dims: Hashable | Sequence[Hashable] | None=None, name: Hashable | None=None, attrs: Mapping | None=None, indexes: dict[Hashable, Index] | None=None, fastpath: bool=False) -> None:\n    if fastpath:\n        variable = data\n        assert dims is None\n        assert attrs is None\n        assert indexes is not None\n    else:\n        if indexes is not None:\n            raise ValueError('Providing explicit indexes is not supported yet')\n        if coords is None:\n            if isinstance(data, DataArray):\n                coords = data.coords\n            elif isinstance(data, pd.Series):\n                coords = [data.index]\n            elif isinstance(data, pd.DataFrame):\n                coords = [data.index, data.columns]\n            elif isinstance(data, (pd.Index, IndexVariable)):\n                coords = [data]\n        if dims is None:\n            dims = getattr(data, 'dims', getattr(coords, 'dims', None))\n        if name is None:\n            name = getattr(data, 'name', None)\n        if attrs is None and (not isinstance(data, PANDAS_TYPES)):\n            attrs = getattr(data, 'attrs', None)\n        data = _check_data_shape(data, coords, dims)\n        data = as_compatible_data(data)\n        coords, dims = _infer_coords_and_dims(data.shape, coords, dims)\n        variable = Variable(dims, data, attrs, fastpath=True)\n        indexes, coords = _create_indexes_from_coords(coords)\n    self._variable = variable\n    assert isinstance(coords, dict)\n    self._coords = coords\n    self._name = name\n    self._indexes = indexes\n    self._close = None",
    ".xarray.core.common.py@@AttrAccessMixin.__setattr__": "def __setattr__(self, name: str, value: Any) -> None:\n    try:\n        object.__setattr__(self, name, value)\n    except AttributeError as e:\n        if str(e) != '{!r} object has no attribute {!r}'.format(type(self).__name__, name):\n            raise\n        raise AttributeError(f\"cannot set attribute {name!r} on a {type(self).__name__!r} object. Use __setitem__ styleassignment (e.g., `ds['name'] = ...`) instead of assigning variables.\") from e",
    ".xarray.core.computation.py@@_all_of_type": "def _all_of_type(args, kind):\n    return [arg for arg in args if isinstance(arg, kind)]",
    ".xarray.core.computation.py@@result_name": "def result_name(objects: Iterable[Any]) -> Any:\n    names = {getattr(obj, 'name', _DEFAULT_NAME) for obj in objects}\n    names.discard(_DEFAULT_NAME)\n    if len(names) == 1:\n        name, = names\n    else:\n        name = None\n    return name",
    ".xarray.core.utils.py@@ReprObject.__hash__": "def __hash__(self) -> int:\n    return hash((type(self), self._value))",
    ".xarray.core.computation.py@@build_output_coords_and_indexes": "def build_output_coords_and_indexes(args: Iterable[Any], signature: _UFuncSignature, exclude_dims: AbstractSet=frozenset(), combine_attrs: CombineAttrsOptions='override') -> tuple[list[dict[Any, Variable]], list[dict[Any, Index]]]:\n    coords_list = _get_coords_list(args)\n    if len(coords_list) == 1 and (not exclude_dims):\n        unpacked_coords, = coords_list\n        merged_vars = dict(unpacked_coords.variables)\n        merged_indexes = dict(unpacked_coords.xindexes)\n    else:\n        merged_vars, merged_indexes = merge_coordinates_without_align(coords_list, exclude_dims=exclude_dims, combine_attrs=combine_attrs)\n    output_coords = []\n    output_indexes = []\n    for output_dims in signature.output_core_dims:\n        dropped_dims = signature.all_input_core_dims - set(output_dims)\n        if dropped_dims:\n            filtered_coords = {k: v for k, v in merged_vars.items() if dropped_dims.isdisjoint(v.dims)}\n            filtered_indexes = filter_indexes_from_coords(merged_indexes, set(filtered_coords))\n        else:\n            filtered_coords = merged_vars\n            filtered_indexes = merged_indexes\n        output_coords.append(filtered_coords)\n        output_indexes.append(filtered_indexes)\n    return (output_coords, output_indexes)",
    ".xarray.core.computation.py@@_get_coords_list": "def _get_coords_list(args: Iterable[Any]) -> list[Coordinates]:\n    coords_list = []\n    for arg in args:\n        try:\n            coords = arg.coords\n        except AttributeError:\n            pass\n        else:\n            coords_list.append(coords)\n    return coords_list",
    ".xarray.core.coordinates.py@@DataArrayCoordinates.variables": "def variables(self):\n    return Frozen(self._data._coords)",
    ".xarray.core.utils.py@@Frozen.__init__": "def __init__(self, mapping: Mapping[K, V]):\n    self.mapping = mapping",
    ".xarray.core.utils.py@@Frozen.__iter__": "def __iter__(self) -> Iterator[K]:\n    return iter(self.mapping)",
    ".xarray.core.coordinates.py@@Coordinates.xindexes": "def xindexes(self) -> Indexes[Index]:\n    return self._data.xindexes",
    ".xarray.core.indexes.py@@Indexes.__iter__": "def __iter__(self) -> Iterator[T_PandasOrXarrayIndex]:\n    return iter(self._indexes)",
    ".xarray.core.computation.py@@_UFuncSignature.all_input_core_dims": "def all_input_core_dims(self):\n    if self._all_input_core_dims is None:\n        self._all_input_core_dims = frozenset((dim for dims in self.input_core_dims for dim in dims))\n    return self._all_input_core_dims",
    ".xarray.core.computation.py@@apply_variable_ufunc": "def apply_variable_ufunc(func, *args, signature: _UFuncSignature, exclude_dims=frozenset(), dask='forbidden', output_dtypes=None, vectorize=False, keep_attrs='override', dask_gufunc_kwargs=None) -> Variable | tuple[Variable, ...]:\n    from .variable import Variable, as_compatible_data\n    dim_sizes = unified_dim_sizes((a for a in args if hasattr(a, 'dims')), exclude_dims=exclude_dims)\n    broadcast_dims = tuple((dim for dim in dim_sizes if dim not in signature.all_core_dims))\n    output_dims = [broadcast_dims + out for out in signature.output_core_dims]\n    input_data = [broadcast_compat_data(arg, broadcast_dims, core_dims) if isinstance(arg, Variable) else arg for arg, core_dims in zip(args, signature.input_core_dims)]\n    if any((is_duck_dask_array(array) for array in input_data)):\n        if dask == 'forbidden':\n            raise ValueError('apply_ufunc encountered a dask array on an argument, but handling for dask arrays has not been enabled. Either set the ``dask`` argument or load your data into memory first with ``.load()`` or ``.compute()``')\n        elif dask == 'parallelized':\n            numpy_func = func\n            if dask_gufunc_kwargs is None:\n                dask_gufunc_kwargs = {}\n            else:\n                dask_gufunc_kwargs = dask_gufunc_kwargs.copy()\n            allow_rechunk = dask_gufunc_kwargs.get('allow_rechunk', None)\n            if allow_rechunk is None:\n                for n, (data, core_dims) in enumerate(zip(input_data, signature.input_core_dims)):\n                    if is_duck_dask_array(data):\n                        for axis, dim in enumerate(core_dims, start=-len(core_dims)):\n                            if len(data.chunks[axis]) != 1:\n                                raise ValueError(f\"dimension {dim} on {n}th function argument to apply_ufunc with dask='parallelized' consists of multiple chunks, but is also a core dimension. To fix, either rechunk into a single dask array chunk along this dimension, i.e., ``.chunk(dict({dim}=-1))``, or pass ``allow_rechunk=True`` in ``dask_gufunc_kwargs`` but beware that this may significantly increase memory usage.\")\n                dask_gufunc_kwargs['allow_rechunk'] = True\n            output_sizes = dask_gufunc_kwargs.pop('output_sizes', {})\n            if output_sizes:\n                output_sizes_renamed = {}\n                for key, value in output_sizes.items():\n                    if key not in signature.all_output_core_dims:\n                        raise ValueError(f\"dimension '{key}' in 'output_sizes' must correspond to output_core_dims\")\n                    output_sizes_renamed[signature.dims_map[key]] = value\n                dask_gufunc_kwargs['output_sizes'] = output_sizes_renamed\n            for key in signature.all_output_core_dims:\n                if key not in signature.all_input_core_dims and key not in output_sizes:\n                    raise ValueError(f\"dimension '{key}' in 'output_core_dims' needs corresponding (dim, size) in 'output_sizes'\")\n\n            def func(*arrays):\n                import dask.array as da\n                res = da.apply_gufunc(numpy_func, signature.to_gufunc_string(exclude_dims), *arrays, vectorize=vectorize, output_dtypes=output_dtypes, **dask_gufunc_kwargs)\n                return res\n        elif dask == 'allowed':\n            pass\n        else:\n            raise ValueError('unknown setting for dask array handling in apply_ufunc: {}'.format(dask))\n    elif vectorize:\n        func = _vectorize(func, signature, output_dtypes=output_dtypes, exclude_dims=exclude_dims)\n    result_data = func(*input_data)\n    if signature.num_outputs == 1:\n        result_data = (result_data,)\n    elif not isinstance(result_data, tuple) or len(result_data) != signature.num_outputs:\n        raise ValueError('applied function does not have the number of outputs specified in the ufunc signature. Result is not a tuple of {} elements: {!r}'.format(signature.num_outputs, result_data))\n    objs = _all_of_type(args, Variable)\n    attrs = merge_attrs([obj.attrs for obj in objs], combine_attrs=keep_attrs)\n    output: list[Variable] = []\n    for dims, data in zip(output_dims, result_data):\n        data = as_compatible_data(data)\n        if data.ndim != len(dims):\n            raise ValueError(f'applied function returned data with unexpected number of dimensions. Received {data.ndim} dimension(s) but expected {len(dims)} dimensions with names: {dims!r}')\n        var = Variable(dims, data, fastpath=True)\n        for dim, new_size in var.sizes.items():\n            if dim in dim_sizes and new_size != dim_sizes[dim]:\n                raise ValueError('size of dimension {!r} on inputs was unexpectedly changed by applied function from {} to {}. Only dimensions specified in ``exclude_dims`` with xarray.apply_ufunc are allowed to change size.'.format(dim, dim_sizes[dim], new_size))\n        var.attrs = attrs\n        output.append(var)\n    if signature.num_outputs == 1:\n        return output[0]\n    else:\n        return tuple(output)",
    ".xarray.core.computation.py@@unified_dim_sizes": "def unified_dim_sizes(variables: Iterable[Variable], exclude_dims: AbstractSet=frozenset()) -> dict[Hashable, int]:\n    dim_sizes: dict[Hashable, int] = {}\n    for var in variables:\n        if len(set(var.dims)) < len(var.dims):\n            raise ValueError(f'broadcasting cannot handle duplicate dimensions on a variable: {list(var.dims)}')\n        for dim, size in zip(var.dims, var.shape):\n            if dim not in exclude_dims:\n                if dim not in dim_sizes:\n                    dim_sizes[dim] = size\n                elif dim_sizes[dim] != size:\n                    raise ValueError(f'operands cannot be broadcast together with mismatched lengths for dimension {dim}: {dim_sizes[dim]} vs {size}')\n    return dim_sizes",
    ".xarray.core.computation.py@@_UFuncSignature.all_core_dims": "def all_core_dims(self):\n    if self._all_core_dims is None:\n        self._all_core_dims = self.all_input_core_dims | self.all_output_core_dims\n    return self._all_core_dims",
    ".xarray.core.computation.py@@_UFuncSignature.all_output_core_dims": "def all_output_core_dims(self):\n    if self._all_output_core_dims is None:\n        self._all_output_core_dims = frozenset((dim for dims in self.output_core_dims for dim in dims))\n    return self._all_output_core_dims",
    ".xarray.core.computation.py@@broadcast_compat_data": "def broadcast_compat_data(variable: Variable, broadcast_dims: tuple[Hashable, ...], core_dims: tuple[Hashable, ...]) -> Any:\n    data = variable.data\n    old_dims = variable.dims\n    new_dims = broadcast_dims + core_dims\n    if new_dims == old_dims:\n        return data\n    set_old_dims = set(old_dims)\n    missing_core_dims = [d for d in core_dims if d not in set_old_dims]\n    if missing_core_dims:\n        raise ValueError('operand to apply_ufunc has required core dimensions {}, but some of these dimensions are absent on an input variable: {}'.format(list(core_dims), missing_core_dims))\n    set_new_dims = set(new_dims)\n    unexpected_dims = [d for d in old_dims if d not in set_new_dims]\n    if unexpected_dims:\n        raise ValueError(f'operand to apply_ufunc encountered unexpected dimensions {unexpected_dims!r} on an input variable: these are core dimensions on other input or output variables')\n    old_broadcast_dims = tuple((d for d in broadcast_dims if d in set_old_dims))\n    reordered_dims = old_broadcast_dims + core_dims\n    if reordered_dims != old_dims:\n        order = tuple((old_dims.index(d) for d in reordered_dims))\n        data = duck_array_ops.transpose(data, order)\n    if new_dims != reordered_dims:\n        key_parts: list[slice | None] = []\n        for dim in new_dims:\n            if dim in set_old_dims:\n                key_parts.append(SLICE_NONE)\n            elif key_parts:\n                key_parts.append(np.newaxis)\n        data = data[tuple(key_parts)]\n    return data",
    ".xarray.core.variable.py@@Variable.data": "def data(self) -> Any:\n    if is_duck_array(self._data):\n        return self._data\n    else:\n        return self.values",
    ".xarray.core.utils.py@@is_duck_array": "def is_duck_array(value: Any) -> bool:\n    if isinstance(value, np.ndarray):\n        return True\n    return hasattr(value, 'ndim') and hasattr(value, 'shape') and hasattr(value, 'dtype') and (hasattr(value, '__array_function__') and hasattr(value, '__array_ufunc__') or hasattr(value, '__array_namespace__'))",
    ".xarray.core.pycompat.py@@is_duck_dask_array": "def is_duck_dask_array(x):\n    return is_duck_array(x) and is_dask_collection(x)",
    ".xarray.core.pycompat.py@@is_dask_collection": "def is_dask_collection(x):\n    if module_available('dask'):\n        from dask.base import is_dask_collection\n        return is_dask_collection(x)\n    return False",
    ".xarray.core.utils.py@@module_available": "def module_available(module: str) -> bool:\n    return importlib.util.find_spec(module) is not None",
    ".xarray.core.duck_array_ops.py@@where": "def where(condition, x, y):\n    xp = get_array_namespace(condition)\n    return xp.where(condition, *as_shared_dtype([x, y], xp=xp))",
    ".xarray.core.duck_array_ops.py@@get_array_namespace": "def get_array_namespace(x):\n    if hasattr(x, '__array_namespace__'):\n        return x.__array_namespace__()\n    else:\n        return np",
    ".xarray.core.duck_array_ops.py@@as_shared_dtype": "def as_shared_dtype(scalars_or_arrays, xp=np):\n    if any((isinstance(x, array_type('cupy')) for x in scalars_or_arrays)):\n        import cupy as cp\n        arrays = [asarray(x, xp=cp) for x in scalars_or_arrays]\n    else:\n        arrays = [asarray(x, xp=xp) for x in scalars_or_arrays]\n    out_type = dtypes.result_type(*arrays)\n    return [astype(x, out_type, copy=False) for x in arrays]",
    ".xarray.core.pycompat.py@@array_type": "def array_type(mod: ModType) -> DuckArrayTypes:\n    return DuckArrayModule(mod).type",
    ".xarray.core.pycompat.py@@DuckArrayModule.__init__": "def __init__(self, mod: ModType) -> None:\n    duck_array_module: ModuleType | None = None\n    duck_array_version: Version\n    duck_array_type: DuckArrayTypes\n    try:\n        duck_array_module = import_module(mod)\n        duck_array_version = Version(duck_array_module.__version__)\n        if mod == 'dask':\n            duck_array_type = (import_module('dask.array').Array,)\n        elif mod == 'pint':\n            duck_array_type = (duck_array_module.Quantity,)\n        elif mod == 'cupy':\n            duck_array_type = (duck_array_module.ndarray,)\n        elif mod == 'sparse':\n            duck_array_type = (duck_array_module.SparseArray,)\n        else:\n            raise NotImplementedError\n    except ImportError:\n        duck_array_module = None\n        duck_array_version = Version('0.0.0')\n        duck_array_type = ()\n    self.module = duck_array_module\n    self.version = duck_array_version\n    self.type = duck_array_type\n    self.available = duck_array_module is not None",
    ".xarray.core.duck_array_ops.py@@asarray": "def asarray(data, xp=np):\n    return data if is_duck_array(data) else xp.asarray(data)",
    ".xarray.core.dtypes.py@@result_type": "def result_type(*arrays_and_dtypes):\n    types = {np.result_type(t).type for t in arrays_and_dtypes}\n    for left, right in PROMOTE_TO_OBJECT:\n        if any((issubclass(t, left) for t in types)) and any((issubclass(t, right) for t in types)):\n            return np.dtype(object)\n    return np.result_type(*arrays_and_dtypes)",
    ".xarray.core.duck_array_ops.py@@astype": "def astype(data, dtype, **kwargs):\n    if hasattr(data, '__array_namespace__'):\n        xp = get_array_namespace(data)\n        return xp.astype(data, dtype, **kwargs)\n    return data.astype(dtype, **kwargs)",
    ".xarray.core.computation.py@@_UFuncSignature.num_outputs": "def num_outputs(self):\n    return len(self.output_core_dims)",
    ".xarray.core.merge.py@@merge_attrs": "def merge_attrs(variable_attrs, combine_attrs, context=None):\n    if not variable_attrs:\n        return None\n    if callable(combine_attrs):\n        return combine_attrs(variable_attrs, context=context)\n    elif combine_attrs == 'drop':\n        return {}\n    elif combine_attrs == 'override':\n        return dict(variable_attrs[0])\n    elif combine_attrs == 'no_conflicts':\n        result = dict(variable_attrs[0])\n        for attrs in variable_attrs[1:]:\n            try:\n                result = compat_dict_union(result, attrs)\n            except ValueError as e:\n                raise MergeError(f\"combine_attrs='no_conflicts', but some values are not the same. Merging {str(result)} with {str(attrs)}\") from e\n        return result\n    elif combine_attrs == 'drop_conflicts':\n        result = {}\n        dropped_keys = set()\n        for attrs in variable_attrs:\n            result.update({key: value for key, value in attrs.items() if key not in result and key not in dropped_keys})\n            result = {key: value for key, value in result.items() if key not in attrs or equivalent(attrs[key], value)}\n            dropped_keys |= {key for key in attrs if key not in result}\n        return result\n    elif combine_attrs == 'identical':\n        result = dict(variable_attrs[0])\n        for attrs in variable_attrs[1:]:\n            if not dict_equiv(result, attrs):\n                raise MergeError(f\"combine_attrs='identical', but attrs differ. First is {str(result)} , other is {str(attrs)}.\")\n        return result\n    else:\n        raise ValueError(f'Unrecognised value for combine_attrs={combine_attrs}')",
    ".xarray.core.common.py@@AbstractArray.sizes": "def sizes(self: Any) -> Frozen[Hashable, int]:\n    return Frozen(dict(zip(self.dims, self.shape)))",
    ".xarray.core.utils.py@@Frozen.__getitem__": "def __getitem__(self, key: K) -> V:\n    return self.mapping[key]",
    ".xarray.core.alignment.py@@Aligner.find_matching_indexes": "def find_matching_indexes(self) -> None:\n    all_indexes: dict[MatchingIndexKey, list[Index]]\n    all_index_vars: dict[MatchingIndexKey, list[dict[Hashable, Variable]]]\n    all_indexes_dim_sizes: dict[MatchingIndexKey, dict[Hashable, set]]\n    objects_matching_indexes: list[dict[MatchingIndexKey, Index]]\n    all_indexes = defaultdict(list)\n    all_index_vars = defaultdict(list)\n    all_indexes_dim_sizes = defaultdict(lambda: defaultdict(set))\n    objects_matching_indexes = []\n    for obj in self.objects:\n        obj_indexes, obj_index_vars = self._normalize_indexes(obj.xindexes)\n        objects_matching_indexes.append(obj_indexes)\n        for key, idx in obj_indexes.items():\n            all_indexes[key].append(idx)\n        for key, index_vars in obj_index_vars.items():\n            all_index_vars[key].append(index_vars)\n            for dim, size in calculate_dimensions(index_vars).items():\n                all_indexes_dim_sizes[key][dim].add(size)\n    self.objects_matching_indexes = tuple(objects_matching_indexes)\n    self.all_indexes = all_indexes\n    self.all_index_vars = all_index_vars\n    if self.join == 'override':\n        for dim_sizes in all_indexes_dim_sizes.values():\n            for dim, sizes in dim_sizes.items():\n                if len(sizes) > 1:\n                    raise ValueError(f\"cannot align objects with join='override' with matching indexes along dimension {dim!r} that don't have the same size\")",
    ".xarray.core.indexes.py@@Indexes.variables": "def variables(self) -> Mapping[Hashable, Variable]:\n    return Frozen(self._variables)",
    ".xarray.core.indexes.py@@Indexes.__getitem__": "def __getitem__(self, key) -> T_PandasOrXarrayIndex:\n    return self._indexes[key]",
    ".xarray.core.indexes.py@@Indexes._id_coord_names": "def _id_coord_names(self) -> dict[int, tuple[Hashable, ...]]:\n    if self.__id_coord_names is None:\n        id_coord_names: Mapping[int, list[Hashable]] = defaultdict(list)\n        for k, v in self._coord_name_id.items():\n            id_coord_names[v].append(k)\n        self.__id_coord_names = {k: tuple(v) for k, v in id_coord_names.items()}\n    return self.__id_coord_names",
    ".xarray.core.indexes.py@@Indexes._coord_name_id": "def _coord_name_id(self) -> dict[Any, int]:\n    if self.__coord_name_id is None:\n        self.__coord_name_id = {k: id(idx) for k, idx in self._indexes.items()}\n    return self.__coord_name_id",
    ".xarray.core.variable.py@@calculate_dimensions": "def calculate_dimensions(variables: Mapping[Any, Variable]) -> dict[Hashable, int]:\n    dims: dict[Hashable, int] = {}\n    last_used = {}\n    scalar_vars = {k for k, v in variables.items() if not v.dims}\n    for k, var in variables.items():\n        for dim, size in zip(var.dims, var.shape):\n            if dim in scalar_vars:\n                raise ValueError(f'dimension {dim!r} already exists as a scalar variable')\n            if dim not in dims:\n                dims[dim] = size\n                last_used[dim] = k\n            elif dims[dim] != size:\n                raise ValueError(f'conflicting sizes for dimension {dim!r}: length {size} on {k!r} and length {dims[dim]} on {last_used!r}')\n    return dims",
    ".xarray.core.indexing.py@@PandasIndexingAdapter.shape": "def shape(self) -> tuple[int, ...]:\n    return (len(self.array),)",
    ".xarray.core.alignment.py@@Aligner.find_matching_unindexed_dims": "def find_matching_unindexed_dims(self) -> None:\n    unindexed_dim_sizes = defaultdict(set)\n    for obj in self.objects:\n        for dim in obj.dims:\n            if dim not in self.exclude_dims and dim not in obj.xindexes.dims:\n                unindexed_dim_sizes[dim].add(obj.sizes[dim])\n    self.unindexed_dim_sizes = unindexed_dim_sizes",
    ".xarray.core.indexes.py@@Indexes.dims": "def dims(self) -> Mapping[Hashable, int]:\n    from .variable import calculate_dimensions\n    if self._dims is None:\n        self._dims = calculate_dimensions(self._variables)\n    return Frozen(self._dims)",
    ".xarray.core.utils.py@@Frozen.__contains__": "def __contains__(self, key: object) -> bool:\n    return key in self.mapping",
    ".xarray.core.alignment.py@@Aligner.assert_no_index_conflict": "def assert_no_index_conflict(self) -> None:\n    matching_keys = set(self.all_indexes) | set(self.indexes)\n    coord_count: dict[Hashable, int] = defaultdict(int)\n    dim_count: dict[Hashable, int] = defaultdict(int)\n    for coord_names_dims, _ in matching_keys:\n        dims_set: set[Hashable] = set()\n        for name, dims in coord_names_dims:\n            coord_count[name] += 1\n            dims_set.update(dims)\n        for dim in dims_set:\n            dim_count[dim] += 1\n    for count, msg in [(coord_count, 'coordinates'), (dim_count, 'dimensions')]:\n        dup = {k: v for k, v in count.items() if v > 1}\n        if dup:\n            items_msg = ', '.join((f'{k!r} ({v} conflicting indexes)' for k, v in dup.items()))\n            raise ValueError(f\"cannot re-index or align objects with conflicting indexes found for the following {msg}: {items_msg}\\nConflicting indexes may occur when\\n- they relate to different sets of coordinate and/or dimension names\\n- they don't have the same type\\n- they may be used to reindex data along common dimensions\")",
    ".xarray.core.alignment.py@@Aligner.align_indexes": "def align_indexes(self) -> None:\n    aligned_indexes = {}\n    aligned_index_vars = {}\n    reindex = {}\n    new_indexes = {}\n    new_index_vars = {}\n    for key, matching_indexes in self.all_indexes.items():\n        matching_index_vars = self.all_index_vars[key]\n        dims = {d for coord in matching_index_vars[0].values() for d in coord.dims}\n        index_cls = key[1]\n        if self.join == 'override':\n            joined_index = matching_indexes[0]\n            joined_index_vars = matching_index_vars[0]\n            need_reindex = False\n        elif key in self.indexes:\n            joined_index = self.indexes[key]\n            joined_index_vars = self.index_vars[key]\n            cmp_indexes = list(zip([joined_index] + matching_indexes, [joined_index_vars] + matching_index_vars))\n            need_reindex = self._need_reindex(dims, cmp_indexes)\n        else:\n            if len(matching_indexes) > 1:\n                need_reindex = self._need_reindex(dims, list(zip(matching_indexes, matching_index_vars)))\n            else:\n                need_reindex = False\n            if need_reindex:\n                if self.join == 'exact':\n                    raise ValueError(\"cannot align objects with join='exact' where index/labels/sizes are not equal along these coordinates (dimensions): \" + ', '.join((f'{name!r} {dims!r}' for name, dims in key[0])))\n                joiner = self._get_index_joiner(index_cls)\n                joined_index = joiner(matching_indexes)\n                if self.join == 'left':\n                    joined_index_vars = matching_index_vars[0]\n                elif self.join == 'right':\n                    joined_index_vars = matching_index_vars[-1]\n                else:\n                    joined_index_vars = joined_index.create_variables()\n            else:\n                joined_index = matching_indexes[0]\n                joined_index_vars = matching_index_vars[0]\n        reindex[key] = need_reindex\n        aligned_indexes[key] = joined_index\n        aligned_index_vars[key] = joined_index_vars\n        for name, var in joined_index_vars.items():\n            new_indexes[name] = joined_index\n            new_index_vars[name] = var\n    for key, idx in self.indexes.items():\n        if key not in aligned_indexes:\n            index_vars = self.index_vars[key]\n            reindex[key] = False\n            aligned_indexes[key] = idx\n            aligned_index_vars[key] = index_vars\n            for name, var in index_vars.items():\n                new_indexes[name] = idx\n                new_index_vars[name] = var\n    self.aligned_indexes = aligned_indexes\n    self.aligned_index_vars = aligned_index_vars\n    self.reindex = reindex\n    self.new_indexes = Indexes(new_indexes, new_index_vars)",
    ".xarray.core.alignment.py@@Aligner._need_reindex": "def _need_reindex(self, dims, cmp_indexes) -> bool:\n    has_unindexed_dims = any((dim in self.unindexed_dim_sizes for dim in dims))\n    return not indexes_all_equal(cmp_indexes) or has_unindexed_dims",
    ".xarray.core.indexes.py@@indexes_all_equal": "def indexes_all_equal(elements: Sequence[tuple[Index, dict[Hashable, Variable]]]) -> bool:\n\n    def check_variables():\n        variables = [e[1] for e in elements]\n        return any((not variables[0][k].equals(other_vars[k]) for other_vars in variables[1:] for k in variables[0]))\n    indexes = [e[0] for e in elements]\n    same_type = all((type(indexes[0]) is type(other_idx) for other_idx in indexes[1:]))\n    if same_type:\n        try:\n            not_equal = any((not indexes[0].equals(other_idx) for other_idx in indexes[1:]))\n        except NotImplementedError:\n            not_equal = check_variables()\n    else:\n        not_equal = check_variables()\n    return not not_equal",
    ".xarray.core.indexes.py@@PandasIndex.equals": "def equals(self, other: Index):\n    if not isinstance(other, PandasIndex):\n        return False\n    return self.index.equals(other.index) and self.dim == other.dim",
    ".xarray.core.alignment.py@@Aligner.assert_unindexed_dim_sizes_equal": "def assert_unindexed_dim_sizes_equal(self) -> None:\n    for dim, sizes in self.unindexed_dim_sizes.items():\n        index_size = self.new_indexes.dims.get(dim)\n        if index_size is not None:\n            sizes.add(index_size)\n            add_err_msg = f' (note: an index is found along that dimension with size={index_size!r})'\n        else:\n            add_err_msg = ''\n        if len(sizes) > 1:\n            raise ValueError(f'cannot reindex or align along dimension {dim!r} because of conflicting dimension sizes: {sizes!r}' + add_err_msg)",
    ".xarray.core.alignment.py@@Aligner.reindex_all": "def reindex_all(self) -> None:\n    self.results = tuple((self._reindex_one(obj, matching_indexes) for obj, matching_indexes in zip(self.objects, self.objects_matching_indexes)))",
    ".xarray.core.alignment.py@@Aligner._reindex_one": "def _reindex_one(self, obj: DataAlignable, matching_indexes: dict[MatchingIndexKey, Index]) -> DataAlignable:\n    new_indexes, new_variables = self._get_indexes_and_vars(obj, matching_indexes)\n    dim_pos_indexers = self._get_dim_pos_indexers(matching_indexes)\n    new_obj = obj._reindex_callback(self, dim_pos_indexers, new_variables, new_indexes, self.fill_value, self.exclude_dims, self.exclude_vars)\n    new_obj.encoding = obj.encoding\n    return new_obj",
    ".xarray.core.alignment.py@@Aligner._get_indexes_and_vars": "def _get_indexes_and_vars(self, obj: DataAlignable, matching_indexes: dict[MatchingIndexKey, Index]) -> tuple[dict[Hashable, Index], dict[Hashable, Variable]]:\n    new_indexes = {}\n    new_variables = {}\n    for key, aligned_idx in self.aligned_indexes.items():\n        index_vars = self.aligned_index_vars[key]\n        obj_idx = matching_indexes.get(key)\n        if obj_idx is None:\n            index_vars_dims = {d for var in index_vars.values() for d in var.dims}\n            if index_vars_dims <= set(obj.dims):\n                obj_idx = aligned_idx\n        if obj_idx is not None:\n            for name, var in index_vars.items():\n                new_indexes[name] = aligned_idx\n                new_variables[name] = var.copy()\n    return (new_indexes, new_variables)",
    ".xarray.core.variable.py@@IndexVariable.copy": "def copy(self, deep: bool=True, data: ArrayLike | None=None):\n    if data is None:\n        ndata = self._data.copy(deep=deep)\n    else:\n        ndata = as_compatible_data(data)\n        if self.shape != ndata.shape:\n            raise ValueError('Data shape {} must match shape of object {}'.format(ndata.shape, self.shape))\n    attrs = copy.deepcopy(self._attrs) if deep else copy.copy(self._attrs)\n    encoding = copy.deepcopy(self._encoding) if deep else copy.copy(self._encoding)\n    return self._replace(data=ndata, attrs=attrs, encoding=encoding)",
    ".xarray.core.indexing.py@@PandasIndexingAdapter.copy": "def copy(self, deep: bool=True) -> PandasIndexingAdapter:\n    array = self.array.copy(deep=True) if deep else self.array\n    return type(self)(array, self._dtype)",
    ".xarray.core.indexing.py@@PandasIndexingAdapter.__init__": "def __init__(self, array: pd.Index, dtype: DTypeLike=None):\n    from .indexes import safe_cast_to_index\n    self.array = safe_cast_to_index(array)\n    if dtype is None:\n        self._dtype = get_valid_numpy_dtype(array)\n    else:\n        self._dtype = np.dtype(dtype)",
    ".xarray.core.indexes.py@@safe_cast_to_index": "def safe_cast_to_index(array: Any) -> pd.Index:\n    from .dataarray import DataArray\n    from .variable import Variable\n    if isinstance(array, pd.Index):\n        index = array\n    elif isinstance(array, (DataArray, Variable)):\n        index = array._to_index()\n    elif isinstance(array, Index):\n        index = array.to_pandas_index()\n    elif isinstance(array, PandasIndexingAdapter):\n        index = array.array\n    else:\n        kwargs = {}\n        if hasattr(array, 'dtype') and array.dtype.kind == 'O':\n            kwargs['dtype'] = object\n        index = pd.Index(np.asarray(array), **kwargs)\n    return _maybe_cast_to_cftimeindex(index)",
    ".xarray.core.indexes.py@@_maybe_cast_to_cftimeindex": "def _maybe_cast_to_cftimeindex(index: pd.Index) -> pd.Index:\n    from ..coding.cftimeindex import CFTimeIndex\n    if len(index) > 0 and index.dtype == 'O':\n        try:\n            return CFTimeIndex(index)\n        except (ImportError, TypeError):\n            return index\n    else:\n        return index",
    ".xarray.core.variable.py@@IndexVariable.__init__": "def __init__(self, dims, data, attrs=None, encoding=None, fastpath=False):\n    super().__init__(dims, data, attrs, encoding, fastpath)\n    if self.ndim != 1:\n        raise ValueError(f'{type(self).__name__} objects must be 1-dimensional')\n    if not isinstance(self._data, PandasIndexingAdapter):\n        self._data = PandasIndexingAdapter(self._data)",
    ".xarray.core.variable.py@@Variable.encoding": "def encoding(self) -> dict[Any, Any]:\n    if self._encoding is None:\n        self._encoding = {}\n    return self._encoding",
    ".xarray.core.alignment.py@@Aligner._get_dim_pos_indexers": "def _get_dim_pos_indexers(self, matching_indexes: dict[MatchingIndexKey, Index]) -> dict[Hashable, Any]:\n    dim_pos_indexers = {}\n    for key, aligned_idx in self.aligned_indexes.items():\n        obj_idx = matching_indexes.get(key)\n        if obj_idx is not None:\n            if self.reindex[key]:\n                indexers = obj_idx.reindex_like(aligned_idx, **self.reindex_kwargs)\n                dim_pos_indexers.update(indexers)\n    return dim_pos_indexers",
    ".xarray.core.dataarray.py@@DataArray._reindex_callback": "def _reindex_callback(self: T_DataArray, aligner: alignment.Aligner, dim_pos_indexers: dict[Hashable, Any], variables: dict[Hashable, Variable], indexes: dict[Hashable, Index], fill_value: Any, exclude_dims: frozenset[Hashable], exclude_vars: frozenset[Hashable]) -> T_DataArray:\n    if isinstance(fill_value, dict):\n        fill_value = fill_value.copy()\n        sentinel = object()\n        value = fill_value.pop(self.name, sentinel)\n        if value is not sentinel:\n            fill_value[_THIS_ARRAY] = value\n    ds = self._to_temp_dataset()\n    reindexed = ds._reindex_callback(aligner, dim_pos_indexers, variables, indexes, fill_value, exclude_dims, exclude_vars)\n    return self._from_temp_dataset(reindexed)",
    ".xarray.core.dataarray.py@@DataArray._to_temp_dataset": "def _to_temp_dataset(self) -> Dataset:\n    return self._to_dataset_whole(name=_THIS_ARRAY, shallow_copy=False)",
    ".xarray.core.dataarray.py@@DataArray._to_dataset_whole": "def _to_dataset_whole(self, name: Hashable=None, shallow_copy: bool=True) -> Dataset:\n    if name is None:\n        name = self.name\n    if name is None:\n        raise ValueError('unable to convert unnamed DataArray to a Dataset without providing an explicit name')\n    if name in self.coords:\n        raise ValueError('cannot create a Dataset from a DataArray with the same name as one of its coordinates')\n    variables = self._coords.copy()\n    variables[name] = self.variable\n    if shallow_copy:\n        for k in variables:\n            variables[k] = variables[k].copy(deep=False)\n    indexes = self._indexes\n    coord_names = set(self._coords)\n    return Dataset._construct_direct(variables, coord_names, indexes=indexes)",
    ".xarray.core.coordinates.py@@Coordinates.__contains__": "def __contains__(self, key: Hashable) -> bool:\n    return key in self._names",
    ".xarray.core.coordinates.py@@DataArrayCoordinates._names": "def _names(self) -> set[Hashable]:\n    return set(self._data._coords)",
    ".xarray.core.dataset.py@@Dataset._construct_direct": "def _construct_direct(cls: type[T_Dataset], variables: dict[Any, Variable], coord_names: set[Hashable], dims: dict[Any, int] | None=None, attrs: dict | None=None, indexes: dict[Any, Index] | None=None, encoding: dict | None=None, close: Callable[[], None] | None=None) -> T_Dataset:\n    if dims is None:\n        dims = calculate_dimensions(variables)\n    if indexes is None:\n        indexes = {}\n    obj = object.__new__(cls)\n    obj._variables = variables\n    obj._coord_names = coord_names\n    obj._dims = dims\n    obj._indexes = indexes\n    obj._attrs = attrs\n    obj._close = close\n    obj._encoding = encoding\n    return obj",
    ".xarray.core.dataset.py@@Dataset._reindex_callback": "def _reindex_callback(self, aligner: alignment.Aligner, dim_pos_indexers: dict[Hashable, Any], variables: dict[Hashable, Variable], indexes: dict[Hashable, Index], fill_value: Any, exclude_dims: frozenset[Hashable], exclude_vars: frozenset[Hashable]) -> Dataset:\n    new_variables = variables.copy()\n    new_indexes = indexes.copy()\n    for name, new_var in new_variables.items():\n        var = self._variables.get(name)\n        if var is not None:\n            new_var.attrs = var.attrs\n            new_var.encoding = var.encoding\n    for name, idx in self._indexes.items():\n        var = self._variables[name]\n        if set(var.dims) <= exclude_dims:\n            new_indexes[name] = idx\n            new_variables[name] = var\n    if not dim_pos_indexers:\n        if set(new_indexes) - set(self._indexes):\n            reindexed = self._overwrite_indexes(new_indexes, new_variables)\n        else:\n            reindexed = self.copy(deep=aligner.copy)\n    else:\n        to_reindex = {k: v for k, v in self.variables.items() if k not in variables and k not in exclude_vars}\n        reindexed_vars = alignment.reindex_variables(to_reindex, dim_pos_indexers, copy=aligner.copy, fill_value=fill_value, sparse=aligner.sparse)\n        new_variables.update(reindexed_vars)\n        new_coord_names = self._coord_names | set(new_indexes)\n        reindexed = self._replace_with_new_dims(new_variables, new_coord_names, indexes=new_indexes)\n    return reindexed",
    ".xarray.core.dataset.py@@Dataset.copy": "def copy(self: T_Dataset, deep: bool=False, data: Mapping[Any, ArrayLike] | None=None) -> T_Dataset:\n    return self._copy(deep=deep, data=data)",
    ".xarray.core.dataset.py@@Dataset._copy": "def _copy(self: T_Dataset, deep: bool=False, data: Mapping[Any, ArrayLike] | None=None, memo: dict[int, Any] | None=None) -> T_Dataset:\n    if data is None:\n        data = {}\n    elif not utils.is_dict_like(data):\n        raise ValueError('Data must be dict-like')\n    if data:\n        var_keys = set(self.data_vars.keys())\n        data_keys = set(data.keys())\n        keys_not_in_vars = data_keys - var_keys\n        if keys_not_in_vars:\n            raise ValueError('Data must only contain variables in original dataset. Extra variables: {}'.format(keys_not_in_vars))\n        keys_missing_from_data = var_keys - data_keys\n        if keys_missing_from_data:\n            raise ValueError('Data must contain all variables in original dataset. Data is missing {}'.format(keys_missing_from_data))\n    indexes, index_vars = self.xindexes.copy_indexes(deep=deep)\n    variables = {}\n    for k, v in self._variables.items():\n        if k in index_vars:\n            variables[k] = index_vars[k]\n        else:\n            variables[k] = v._copy(deep=deep, data=data.get(k), memo=memo)\n    attrs = copy.deepcopy(self._attrs, memo) if deep else copy.copy(self._attrs)\n    encoding = copy.deepcopy(self._encoding, memo) if deep else copy.copy(self._encoding)\n    return self._replace(variables, indexes=indexes, attrs=attrs, encoding=encoding)",
    ".xarray.core.dataset.py@@Dataset.xindexes": "def xindexes(self) -> Indexes[Index]:\n    return Indexes(self._indexes, {k: self._variables[k] for k in self._indexes})",
    ".xarray.core.indexes.py@@PandasIndex.copy": "def copy(self, deep=True):\n    if deep:\n        index = self.index.copy(deep=True)\n    else:\n        index = self.index\n    return self._replace(index)",
    ".xarray.core.indexes.py@@PandasIndex._replace": "def _replace(self, index, dim=None, coord_dtype=None):\n    if dim is None:\n        dim = self.dim\n    if coord_dtype is None:\n        coord_dtype = self.coord_dtype\n    return type(self)(index, dim, coord_dtype)",
    ".xarray.core.indexes.py@@PandasIndex.__init__": "def __init__(self, array: Any, dim: Hashable, coord_dtype: Any=None):\n    index = safe_cast_to_index(array).copy()\n    if index.name is None:\n        index.name = dim\n    self.index = index\n    self.dim = dim\n    if coord_dtype is None:\n        coord_dtype = get_valid_numpy_dtype(index)\n    self.coord_dtype = coord_dtype",
    ".xarray.core.indexes.py@@PandasIndex.create_variables": "def create_variables(self, variables: Mapping[Any, Variable] | None=None) -> IndexVars:\n    from .variable import IndexVariable\n    name = self.index.name\n    attrs: Mapping[Hashable, Any] | None\n    encoding: Mapping[Hashable, Any] | None\n    if variables is not None and name in variables:\n        var = variables[name]\n        attrs = var.attrs\n        encoding = var.encoding\n    else:\n        attrs = None\n        encoding = None\n    data = PandasIndexingAdapter(self.index, dtype=self.coord_dtype)\n    var = IndexVariable(self.dim, data, attrs=attrs, encoding=encoding)\n    return {name: var}",
    ".xarray.core.variable.py@@_possibly_convert_datetime_or_timedelta_index": "def _possibly_convert_datetime_or_timedelta_index(data):\n    if isinstance(data, (pd.DatetimeIndex, pd.TimedeltaIndex)):\n        return _as_nanosecond_precision(data)\n    else:\n        return data",
    ".xarray.core.dataset.py@@Dataset._replace": "def _replace(self: T_Dataset, variables: dict[Hashable, Variable] | None=None, coord_names: set[Hashable] | None=None, dims: dict[Any, int] | None=None, attrs: dict[Hashable, Any] | None | Default=_default, indexes: dict[Hashable, Index] | None=None, encoding: dict | None | Default=_default, inplace: bool=False) -> T_Dataset:\n    if inplace:\n        if variables is not None:\n            self._variables = variables\n        if coord_names is not None:\n            self._coord_names = coord_names\n        if dims is not None:\n            self._dims = dims\n        if attrs is not _default:\n            self._attrs = attrs\n        if indexes is not None:\n            self._indexes = indexes\n        if encoding is not _default:\n            self._encoding = encoding\n        obj = self\n    else:\n        if variables is None:\n            variables = self._variables.copy()\n        if coord_names is None:\n            coord_names = self._coord_names.copy()\n        if dims is None:\n            dims = self._dims.copy()\n        if attrs is _default:\n            attrs = copy.copy(self._attrs)\n        if indexes is None:\n            indexes = self._indexes.copy()\n        if encoding is _default:\n            encoding = copy.copy(self._encoding)\n        obj = self._construct_direct(variables, coord_names, dims, attrs, indexes, encoding)\n    return obj",
    ".xarray.core.dataarray.py@@DataArray._from_temp_dataset": "def _from_temp_dataset(self: T_DataArray, dataset: Dataset, name: Hashable | None | Default=_default) -> T_DataArray:\n    variable = dataset._variables.pop(_THIS_ARRAY)\n    coords = dataset._variables\n    indexes = dataset._indexes\n    return self._replace(variable, coords, name, indexes=indexes)",
    ".xarray.core.dataarray.py@@DataArray.encoding": "def encoding(self) -> dict[Any, Any]:\n    return self.variable.encoding",
    ".xarray.core.computation.py@@_first_of_type": "def _first_of_type(args, kind):\n    for arg in args:\n        if isinstance(arg, kind):\n            return arg\n    raise ValueError('This should be unreachable.')",
    ".xarray.core.merge.py@@merge_coordinates_without_align": "def merge_coordinates_without_align(objects: list[Coordinates], prioritized: Mapping[Any, MergeElement] | None=None, exclude_dims: AbstractSet=frozenset(), combine_attrs: CombineAttrsOptions='override') -> tuple[dict[Hashable, Variable], dict[Hashable, Index]]:\n    collected = collect_from_coordinates(objects)\n    if exclude_dims:\n        filtered: dict[Hashable, list[MergeElement]] = {}\n        for name, elements in collected.items():\n            new_elements = [(variable, index) for variable, index in elements if exclude_dims.isdisjoint(variable.dims)]\n            if new_elements:\n                filtered[name] = new_elements\n    else:\n        filtered = collected\n    merged_coords, merged_indexes = merge_collected(filtered, prioritized, combine_attrs=combine_attrs)\n    merged_indexes = filter_indexes_from_coords(merged_indexes, set(merged_coords))\n    return (merged_coords, merged_indexes)",
    ".xarray.core.merge.py@@collect_from_coordinates": "def collect_from_coordinates(list_of_coords: list[Coordinates]) -> dict[Hashable, list[MergeElement]]:\n    grouped: dict[Hashable, list[MergeElement]] = defaultdict(list)\n    for coords in list_of_coords:\n        variables = coords.variables\n        indexes = coords.xindexes\n        for name, variable in variables.items():\n            grouped[name].append((variable, indexes.get(name)))\n    return grouped",
    ".xarray.core.merge.py@@merge_collected": "def merge_collected(grouped: dict[Hashable, list[MergeElement]], prioritized: Mapping[Any, MergeElement] | None=None, compat: CompatOptions='minimal', combine_attrs: CombineAttrsOptions='override', equals: dict[Hashable, bool] | None=None) -> tuple[dict[Hashable, Variable], dict[Hashable, Index]]:\n    if prioritized is None:\n        prioritized = {}\n    if equals is None:\n        equals = {}\n    _assert_compat_valid(compat)\n    _assert_prioritized_valid(grouped, prioritized)\n    merged_vars: dict[Hashable, Variable] = {}\n    merged_indexes: dict[Hashable, Index] = {}\n    index_cmp_cache: dict[tuple[int, int], bool | None] = {}\n    for name, elements_list in grouped.items():\n        if name in prioritized:\n            variable, index = prioritized[name]\n            merged_vars[name] = variable\n            if index is not None:\n                merged_indexes[name] = index\n        else:\n            indexed_elements = [(variable, index) for variable, index in elements_list if index is not None]\n            if indexed_elements:\n                variable, index = indexed_elements[0]\n                for other_var, other_index in indexed_elements[1:]:\n                    if not indexes_equal(index, other_index, variable, other_var, index_cmp_cache):\n                        raise MergeError(f'conflicting values/indexes on objects to be combined fo coordinate {name!r}\\nfirst index: {index!r}\\nsecond index: {other_index!r}\\nfirst variable: {variable!r}\\nsecond variable: {other_var!r}\\n')\n                if compat == 'identical':\n                    for other_variable, _ in indexed_elements[1:]:\n                        if not dict_equiv(variable.attrs, other_variable.attrs):\n                            raise MergeError(f'conflicting attribute values on combined variable {name!r}:\\nfirst value: {variable.attrs!r}\\nsecond value: {other_variable.attrs!r}')\n                merged_vars[name] = variable\n                merged_vars[name].attrs = merge_attrs([var.attrs for var, _ in indexed_elements], combine_attrs=combine_attrs)\n                merged_indexes[name] = index\n            else:\n                variables = [variable for variable, _ in elements_list]\n                try:\n                    merged_vars[name] = unique_variable(name, variables, compat, equals.get(name, None))\n                except MergeError:\n                    if compat != 'minimal':\n                        raise\n                if name in merged_vars:\n                    merged_vars[name].attrs = merge_attrs([var.attrs for var in variables], combine_attrs=combine_attrs)\n    return (merged_vars, merged_indexes)",
    ".xarray.core.merge.py@@_assert_compat_valid": "def _assert_compat_valid(compat):\n    if compat not in _VALID_COMPAT:\n        raise ValueError(f'compat={compat!r} invalid: must be {set(_VALID_COMPAT)}')",
    ".xarray.core.merge.py@@_assert_prioritized_valid": "def _assert_prioritized_valid(grouped: dict[Hashable, list[MergeElement]], prioritized: Mapping[Any, MergeElement]) -> None:\n    prioritized_names = set(prioritized)\n    grouped_by_index: dict[int, list[Hashable]] = defaultdict(list)\n    indexes: dict[int, Index] = {}\n    for name, elements_list in grouped.items():\n        for _, index in elements_list:\n            if index is not None:\n                grouped_by_index[id(index)].append(name)\n                indexes[id(index)] = index\n    for index_id, index_coord_names in grouped_by_index.items():\n        index_names = set(index_coord_names)\n        common_names = index_names & prioritized_names\n        if common_names and len(common_names) != len(index_names):\n            common_names_str = ', '.join((f'{k!r}' for k in common_names))\n            index_names_str = ', '.join((f'{k!r}' for k in index_coord_names))\n            raise ValueError(f'cannot set or update variable(s) {common_names_str}, which would corrupt the following index built from coordinates {index_names_str}:\\n{indexes[index_id]!r}')",
    ".xarray.core.indexes.py@@indexes_equal": "def indexes_equal(index: Index, other_index: Index, variable: Variable, other_variable: Variable, cache: dict[tuple[int, int], bool | None] | None=None) -> bool:\n    if cache is None:\n        cache = {}\n    key = (id(index), id(other_index))\n    equal: bool | None = None\n    if key not in cache:\n        if type(index) is type(other_index):\n            try:\n                equal = index.equals(other_index)\n            except NotImplementedError:\n                equal = None\n            else:\n                cache[key] = equal\n        else:\n            equal = None\n    else:\n        equal = cache[key]\n    if equal is None:\n        equal = variable.equals(other_variable)\n    return cast(bool, equal)",
    ".xarray.core.indexes.py@@filter_indexes_from_coords": "def filter_indexes_from_coords(indexes: Mapping[Any, Index], filtered_coord_names: set) -> dict[Hashable, Index]:\n    filtered_indexes: dict[Any, Index] = dict(**indexes)\n    index_coord_names: dict[Hashable, set[Hashable]] = defaultdict(set)\n    for name, idx in indexes.items():\n        index_coord_names[id(idx)].add(name)\n    for idx_coord_names in index_coord_names.values():\n        if not idx_coord_names <= filtered_coord_names:\n            for k in idx_coord_names:\n                del filtered_indexes[k]\n    return filtered_indexes",
    ".xarray.core.coordinates.py@@Coordinates.__iter__": "def __iter__(self) -> Iterator[Hashable]:\n    for k in self.variables:\n        if k in self._names:\n            yield k",
    ".xarray.core.dataarray.py@@DataArray._replace_maybe_drop_dims": "def _replace_maybe_drop_dims(self: T_DataArray, variable: Variable, name: Hashable | None | Default=_default) -> T_DataArray:\n    if variable.dims == self.dims and variable.shape == self.shape:\n        coords = self._coords.copy()\n        indexes = self._indexes\n    elif variable.dims == self.dims:\n        new_sizes = dict(zip(self.dims, variable.shape))\n        coords = {k: v for k, v in self._coords.items() if v.shape == tuple((new_sizes[d] for d in v.dims))}\n        indexes = filter_indexes_from_coords(self._indexes, set(coords))\n    else:\n        allowed_dims = set(variable.dims)\n        coords = {k: v for k, v in self._coords.items() if set(v.dims) <= allowed_dims}\n        indexes = filter_indexes_from_coords(self._indexes, set(coords))\n    return self._replace(variable, coords, name, indexes=indexes)",
    ".xarray.core.dataarray.py@@DataArray.__getitem__": "def __getitem__(self: T_DataArray, key: Any) -> T_DataArray:\n    if isinstance(key, str):\n        return self._getitem_coord(key)\n    else:\n        return self.isel(indexers=self._item_key_to_dict(key))",
    ".xarray.core.computation.py@@apply_dataset_vfunc": "def apply_dataset_vfunc(func, *args, signature: _UFuncSignature, join='inner', dataset_join='exact', fill_value=_NO_FILL_VALUE, exclude_dims=frozenset(), keep_attrs='override') -> Dataset | tuple[Dataset, ...]:\n    from .dataset import Dataset\n    if dataset_join not in _JOINS_WITHOUT_FILL_VALUES and fill_value is _NO_FILL_VALUE:\n        raise TypeError('to apply an operation to datasets with different data variables with apply_ufunc, you must supply the dataset_fill_value argument.')\n    objs = _all_of_type(args, Dataset)\n    if len(args) > 1:\n        args = deep_align(args, join=join, copy=False, exclude=exclude_dims, raise_on_invalid=False)\n    list_of_coords, list_of_indexes = build_output_coords_and_indexes(args, signature, exclude_dims, combine_attrs=keep_attrs)\n    args = tuple((getattr(arg, 'data_vars', arg) for arg in args))\n    result_vars = apply_dict_of_variables_vfunc(func, *args, signature=signature, join=dataset_join, fill_value=fill_value)\n    out: Dataset | tuple[Dataset, ...]\n    if signature.num_outputs > 1:\n        out = tuple((_fast_dataset(*args) for args in zip(result_vars, list_of_coords, list_of_indexes)))\n    else:\n        coord_vars, = list_of_coords\n        indexes, = list_of_indexes\n        out = _fast_dataset(result_vars, coord_vars, indexes=indexes)\n    attrs = merge_attrs([x.attrs for x in objs], combine_attrs=keep_attrs)\n    if isinstance(out, tuple):\n        for ds in out:\n            ds.attrs = attrs\n    else:\n        out.attrs = attrs\n    return out",
    ".xarray.core.dataset.py@@Dataset.dims": "def dims(self) -> Frozen[Hashable, int]:\n    return Frozen(self._dims)",
    ".xarray.core.dataset.py@@Dataset.encoding": "def encoding(self) -> dict[Any, Any]:\n    if self._encoding is None:\n        self._encoding = {}\n    return self._encoding",
    ".xarray.core.dataset.py@@Dataset.coords": "def coords(self) -> DatasetCoordinates:\n    return DatasetCoordinates(self)",
    ".xarray.core.coordinates.py@@DatasetCoordinates.__init__": "def __init__(self, dataset: Dataset):\n    self._data = dataset",
    ".xarray.core.coordinates.py@@DatasetCoordinates.variables": "def variables(self) -> Mapping[Hashable, Variable]:\n    return Frozen({k: v for k, v in self._data.variables.items() if k in self._names})",
    ".xarray.core.dataset.py@@Dataset.variables": "def variables(self) -> Frozen[Hashable, Variable]:\n    return Frozen(self._variables)",
    ".xarray.core.coordinates.py@@DatasetCoordinates._names": "def _names(self) -> set[Hashable]:\n    return self._data._coord_names",
    ".xarray.core.dataset.py@@Dataset.data_vars": "def data_vars(self) -> DataVariables:\n    return DataVariables(self)",
    ".xarray.core.dataset.py@@DataVariables.__init__": "def __init__(self, dataset: Dataset):\n    self._dataset = dataset",
    ".xarray.core.computation.py@@apply_dict_of_variables_vfunc": "def apply_dict_of_variables_vfunc(func, *args, signature: _UFuncSignature, join='inner', fill_value=None):\n    args = tuple((_as_variables_or_variable(arg) for arg in args))\n    names = join_dict_keys(args, how=join)\n    grouped_by_name = collect_dict_values(args, names, fill_value)\n    result_vars = {}\n    for name, variable_args in zip(names, grouped_by_name):\n        result_vars[name] = func(*variable_args)\n    if signature.num_outputs > 1:\n        return _unpack_dict_tuples(result_vars, signature.num_outputs)\n    else:\n        return result_vars",
    ".xarray.core.computation.py@@_as_variables_or_variable": "def _as_variables_or_variable(arg):\n    try:\n        return arg.variables\n    except AttributeError:\n        try:\n            return arg.variable\n        except AttributeError:\n            return arg",
    ".xarray.core.dataset.py@@DataVariables.variables": "def variables(self) -> Mapping[Hashable, Variable]:\n    all_variables = self._dataset.variables\n    return Frozen({k: all_variables[k] for k in self})",
    ".xarray.core.dataset.py@@DataVariables.__iter__": "def __iter__(self) -> Iterator[Hashable]:\n    return (key for key in self._dataset._variables if key not in self._dataset._coord_names)",
    ".xarray.core.computation.py@@join_dict_keys": "def join_dict_keys(objects: Iterable[Mapping | Any], how: str='inner') -> Iterable:\n    joiner = _JOINERS[how]\n    all_keys = [obj.keys() for obj in objects if hasattr(obj, 'keys')]\n    return joiner(all_keys)",
    ".xarray.core.computation.py@@assert_and_return_exact_match": "def assert_and_return_exact_match(all_keys):\n    first_keys = all_keys[0]\n    for keys in all_keys[1:]:\n        if keys != first_keys:\n            raise ValueError(f'exact match required for all data variable names, but {keys!r} != {first_keys!r}')\n    return first_keys",
    ".xarray.core.utils.py@@Frozen.__len__": "def __len__(self) -> int:\n    return len(self.mapping)",
    ".xarray.core.computation.py@@collect_dict_values": "def collect_dict_values(objects: Iterable[Mapping | Any], keys: Iterable, fill_value: object=None) -> list[list]:\n    return [[obj.get(key, fill_value) if is_dict_like(obj) else obj for obj in objects] for key in keys]",
    ".xarray.core.computation.py@@_fast_dataset": "def _fast_dataset(variables: dict[Hashable, Variable], coord_variables: Mapping[Hashable, Variable], indexes: dict[Hashable, Index]) -> Dataset:\n    from .dataset import Dataset\n    variables.update(coord_variables)\n    coord_names = set(coord_variables)\n    return Dataset._construct_direct(variables, coord_names, indexes=indexes)",
    ".xarray.core.dataset.py@@Dataset.attrs": "def attrs(self) -> dict[Any, Any]:\n    if self._attrs is None:\n        self._attrs = {}\n    return self._attrs",
    ".xarray.core.dataset.py@@Dataset._attr_sources": "def _attr_sources(self) -> Iterable[Mapping[Hashable, Any]]:\n    yield from self._item_sources\n    yield self.attrs",
    ".xarray.core.dataset.py@@Dataset._item_sources": "def _item_sources(self) -> Iterable[Mapping[Hashable, Any]]:\n    yield self.data_vars\n    yield HybridMappingProxy(keys=self._coord_names, mapping=self.coords)\n    yield HybridMappingProxy(keys=self.dims, mapping=self)",
    ".xarray.core.dataset.py@@DataVariables.__getitem__": "def __getitem__(self, key: Hashable) -> DataArray:\n    if key not in self._dataset._coord_names:\n        return cast('DataArray', self._dataset[key])\n    raise KeyError(key)",
    ".xarray.core.dataset.py@@Dataset.__getitem__": "def __getitem__(self, key: Hashable) -> DataArray:\n    ...",
    ".xarray.core.utils.py@@hashable": "def hashable(v: Any) -> TypeGuard[Hashable]:\n    try:\n        hash(v)\n    except TypeError:\n        return False\n    return True",
    ".xarray.core.dataset.py@@Dataset._construct_dataarray": "def _construct_dataarray(self, name: Hashable) -> DataArray:\n    from .dataarray import DataArray\n    try:\n        variable = self._variables[name]\n    except KeyError:\n        _, name, variable = _get_virtual_variable(self._variables, name, self.dims)\n    needed_dims = set(variable.dims)\n    coords: dict[Hashable, Variable] = {}\n    for k in self._variables:\n        if k in self._coord_names and set(self.variables[k].dims) <= needed_dims:\n            coords[k] = self.variables[k]\n    indexes = filter_indexes_from_coords(self._indexes, set(coords))\n    return DataArray(variable, coords, name=name, indexes=indexes, fastpath=True)",
    ".xarray.core.coordinates.py@@DatasetCoordinates.__getitem__": "def __getitem__(self, key: Hashable) -> DataArray:\n    if key in self._data.data_vars:\n        raise KeyError(key)\n    return self._data[key]",
    ".xarray.core.dataset.py@@DataVariables.__contains__": "def __contains__(self, key: Hashable) -> bool:\n    return key in self._dataset._variables and key not in self._dataset._coord_names"
}