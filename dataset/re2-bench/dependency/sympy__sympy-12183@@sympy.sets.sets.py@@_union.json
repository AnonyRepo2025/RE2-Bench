{
    ".sympy.sets.sets.py@@FiniteSet.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.basic.py@@Basic.args": "def args(self):\n    return self._args",
    ".sympy.sets.sets.py@@Set.contains": "def contains(self, other):\n    other = sympify(other, strict=True)\n    ret = sympify(self._contains(other))\n    if ret is None:\n        ret = Contains(other, self, evaluate=False)\n    return ret",
    ".sympy.core.sympify.py@@sympify": "def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):\n    if evaluate is None:\n        if global_evaluate[0] is False:\n            evaluate = global_evaluate[0]\n        else:\n            evaluate = True\n    try:\n        if a in sympy_classes:\n            return a\n    except TypeError:\n        pass\n    try:\n        cls = a.__class__\n    except AttributeError:\n        cls = type(a)\n    if cls in sympy_classes:\n        return a\n    if cls is type(None):\n        if strict:\n            raise SympifyError(a)\n        else:\n            return a\n    try:\n        return converter[cls](a)\n    except KeyError:\n        for superclass in getmro(cls):\n            try:\n                return converter[superclass](a)\n            except KeyError:\n                continue\n    if isinstance(a, CantSympify):\n        raise SympifyError(a)\n    try:\n        return a._sympy_()\n    except AttributeError:\n        pass\n    if not isinstance(a, string_types):\n        for coerce in (float, int):\n            try:\n                return sympify(coerce(a))\n            except (TypeError, ValueError, AttributeError, SympifyError):\n                continue\n    if strict:\n        raise SympifyError(a)\n    if iterable(a):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])\n        except TypeError:\n            pass\n    if isinstance(a, dict):\n        try:\n            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])\n        except TypeError:\n            pass\n    try:\n        from .compatibility import unicode\n        a = unicode(a)\n    except Exception as exc:\n        raise SympifyError(a, exc)\n    from sympy.parsing.sympy_parser import parse_expr, TokenError, standard_transformations\n    from sympy.parsing.sympy_parser import convert_xor as t_convert_xor\n    from sympy.parsing.sympy_parser import rationalize as t_rationalize\n    transformations = standard_transformations\n    if rational:\n        transformations += (t_rationalize,)\n    if convert_xor:\n        transformations += (t_convert_xor,)\n    try:\n        a = a.replace('\\n', '')\n        expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n    except (TokenError, SyntaxError) as exc:\n        raise SympifyError('could not parse %r' % a, exc)\n    return expr",
    ".sympy.core.numbers.py@@Float.__hash__": "def __hash__(self):\n    return super(Float, self).__hash__()",
    ".sympy.core.numbers.py@@Number.__hash__": "def __hash__(self):\n    return super(Number, self).__hash__()",
    ".sympy.core.basic.py@@Basic.__hash__": "def __hash__(self):\n    h = self._mhash\n    if h is None:\n        h = hash((type(self).__name__,) + self._hashable_content())\n        self._mhash = h\n    return h",
    ".sympy.logic.boolalg.py@@BooleanFalse.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.core.numbers.py@@Float.__ge__": "def __ge__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s >= %s' % (self, other))\n    if isinstance(other, NumberSymbol):\n        return other.__lt__(self)\n    if other.is_comparable:\n        other = other.evalf()\n    if isinstance(other, Number) and other is not S.NaN:\n        return _sympify(bool(mlib.mpf_ge(self._mpf_, other._as_mpf_val(self._prec))))\n    return Expr.__ge__(self, other)",
    ".sympy.core.sympify.py@@_sympify": "def _sympify(a):\n    return sympify(a, strict=True)",
    ".sympy.core.numbers.py@@Integer.__hash__": "def __hash__(self):\n    return hash(self.p)",
    ".sympy.core.basic.py@@Basic.is_comparable": "def is_comparable(self):\n    is_real = self.is_real\n    if is_real is False:\n        return False\n    is_number = self.is_number\n    if is_number is False:\n        return False\n    n, i = [p.evalf(2) if not p.is_Number else p for p in self.as_real_imag()]\n    if not i.is_Number or not n.is_Number:\n        return False\n    if i:\n        return False\n    else:\n        return n._prec != 1",
    ".sympy.core.expr.py@@Expr.as_real_imag": "def as_real_imag(self, deep=True, **hints):\n    from sympy import im, re\n    if hints.get('ignore') == self:\n        return None\n    else:\n        return (re(self), im(self))",
    ".sympy.core.numbers.py@@Integer.__eq__": "def __eq__(self, other):\n    if isinstance(other, integer_types):\n        return self.p == other\n    elif isinstance(other, Integer):\n        return self.p == other.p\n    return Rational.__eq__(self, other)",
    ".sympy.core.numbers.py@@Rational.__eq__": "def __eq__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return False\n    if isinstance(other, NumberSymbol):\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if isinstance(other, Number):\n        if isinstance(other, Rational):\n            return self.p == other.p and self.q == other.q\n        if isinstance(other, Float):\n            return mlib.mpf_eq(self._as_mpf_val(other._prec), other._mpf_)\n    return False",
    ".sympy.core.sympify.py@@SympifyError.__init__": "def __init__(self, expr, base_exc=None):\n    self.expr = expr\n    self.base_exc = base_exc",
    ".sympy.core.function.py@@Function.__new__": "def __new__(cls, *args, **options):\n    if cls is Function:\n        return UndefinedFunction(*args, **options)\n    n = len(args)\n    if n not in cls.nargs:\n        temp = '%(name)s takes %(qual)s %(args)s argument%(plural)s (%(given)s given)'\n        raise TypeError(temp % {'name': cls, 'qual': 'exactly' if len(cls.nargs) == 1 else 'at least', 'args': min(cls.nargs), 'plural': 's' * (min(cls.nargs) != 1), 'given': n})\n    evaluate = options.get('evaluate', global_evaluate[0])\n    result = super(Function, cls).__new__(cls, *args, **options)\n    if not evaluate or not isinstance(result, cls):\n        return result\n    pr = max((cls._should_evalf(a) for a in result.args))\n    pr2 = min((cls._should_evalf(a) for a in result.args))\n    if pr2 > 0:\n        return result.evalf(mlib.libmpf.prec_to_dps(pr))\n    return result",
    ".sympy.core.function.py@@FunctionClass.nargs": "def nargs(self):\n    from sympy.sets.sets import FiniteSet\n    return FiniteSet(*self._nargs) if self._nargs else S.Naturals0",
    ".sympy.sets.sets.py@@FiniteSet.__new__": "def __new__(cls, *args, **kwargs):\n    evaluate = kwargs.get('evaluate', global_evaluate[0])\n    if evaluate:\n        args = list(map(sympify, args))\n        if len(args) == 0:\n            return EmptySet()\n    else:\n        args = list(map(sympify, args))\n    args = list(ordered(frozenset(tuple(args)), Set._infimum_key))\n    obj = Basic.__new__(cls, *args)\n    obj._elements = frozenset(args)\n    return obj",
    ".sympy.core.numbers.py@@Integer.__new__": "def __new__(cls, i):\n    if isinstance(i, string_types):\n        i = i.replace(' ', '')\n    try:\n        ival = int(i)\n    except TypeError:\n        raise TypeError('Integer can only work with integer expressions.')\n    try:\n        return _intcache[ival]\n    except KeyError:\n        obj = Expr.__new__(cls)\n        obj.p = ival\n        _intcache[ival] = obj\n        return obj",
    ".sympy.core.compatibility.py@@ordered": "def ordered(seq, keys=None, default=True, warn=False):\n    d = defaultdict(list)\n    if keys:\n        if not isinstance(keys, (list, tuple)):\n            keys = [keys]\n        keys = list(keys)\n        f = keys.pop(0)\n        for a in seq:\n            d[f(a)].append(a)\n    else:\n        if not default:\n            raise ValueError('if default=False then keys must be provided')\n        d[None].extend(seq)\n    for k in sorted(d.keys()):\n        if len(d[k]) > 1:\n            if keys:\n                d[k] = ordered(d[k], keys, default, warn)\n            elif default:\n                d[k] = ordered(d[k], (_nodes, default_sort_key), default=False, warn=warn)\n            elif warn:\n                from sympy.utilities.iterables import uniq\n                u = list(uniq(d[k]))\n                if len(u) > 1:\n                    raise ValueError('not enough keys to break ties: %s' % u)\n        for v in d[k]:\n            yield v\n        d.pop(k)",
    ".sympy.sets.sets.py@@Set._infimum_key": "def _infimum_key(expr):\n    try:\n        infimum = expr.inf\n        assert infimum.is_comparable\n    except (NotImplementedError, AttributeError, AssertionError, ValueError):\n        infimum = S.Infinity\n    return infimum",
    ".sympy.core.numbers.py@@Infinity.__hash__": "def __hash__(self):\n    return super(Infinity, self).__hash__()",
    ".sympy.core.basic.py@@Basic.__new__": "def __new__(cls, *args):\n    obj = object.__new__(cls)\n    obj._assumptions = cls.default_assumptions\n    obj._mhash = None\n    obj._args = args\n    return obj",
    ".sympy.sets.sets.py@@Set.__contains__": "def __contains__(self, other):\n    symb = sympify(self.contains(other))\n    if not (symb is S.true or symb is S.false):\n        raise TypeError('contains did not evaluate to a bool: %r' % symb)\n    return bool(symb)",
    ".sympy.sets.sets.py@@FiniteSet._contains": "def _contains(self, other):\n    r = false\n    for e in self._elements:\n        t = Eq(e, other, evaluate=True)\n        if isinstance(t, Eq):\n            t = t.simplify()\n        if t == true:\n            return t\n        elif t != false:\n            r = None\n    return r",
    ".sympy.core.relational.py@@Equality.__new__": "def __new__(cls, lhs, rhs=0, **options):\n    from sympy.core.add import Add\n    from sympy.core.logic import fuzzy_bool\n    from sympy.simplify.simplify import clear_coefficients\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    evaluate = options.pop('evaluate', global_evaluate[0])\n    if evaluate:\n        if hasattr(lhs, '_eval_Eq'):\n            r = lhs._eval_Eq(rhs)\n            if r is not None:\n                return r\n        if hasattr(rhs, '_eval_Eq'):\n            r = rhs._eval_Eq(lhs)\n            if r is not None:\n                return r\n        if lhs == rhs:\n            return S.true\n        elif all((isinstance(i, BooleanAtom) for i in (rhs, lhs))):\n            return S.false\n        fin = L, R = [i.is_finite for i in (lhs, rhs)]\n        if None not in fin:\n            if L != R:\n                return S.false\n            if L is False:\n                return S.true\n        if all((isinstance(i, Expr) for i in (lhs, rhs))):\n            dif = lhs - rhs\n            z = dif.is_zero\n            if z is not None:\n                if z is False and dif.is_commutative:\n                    return S.false\n                if z:\n                    return S.true\n            n, d = dif.as_numer_denom()\n            rv = None\n            if n.is_zero:\n                rv = d.is_nonzero\n            elif n.is_finite:\n                if d.is_infinite:\n                    rv = S.true\n                elif n.is_zero is False:\n                    rv = d.is_infinite\n                    if rv is None:\n                        l, r = clear_coefficients(d, S.Infinity)\n                        args = [_.subs(l, r) for _ in (lhs, rhs)]\n                        if args != [lhs, rhs]:\n                            rv = fuzzy_bool(Eq(*args))\n                            if rv is True:\n                                rv = None\n            elif any((a.is_infinite for a in Add.make_args(n))):\n                rv = S.false\n            if rv is not None:\n                return _sympify(rv)\n    return Relational.__new__(cls, lhs, rhs, **options)",
    ".sympy.core.basic.py@@Basic.__eq__": "def __eq__(self, other):\n    from sympy import Pow\n    if self is other:\n        return True\n    from .function import AppliedUndef, UndefinedFunction as UndefFunc\n    if isinstance(self, UndefFunc) and isinstance(other, UndefFunc):\n        if self.class_key() == other.class_key():\n            return True\n        else:\n            return False\n    if type(self) is not type(other):\n        if isinstance(self, Pow) and self.exp == 1:\n            return self.base == other\n        if isinstance(other, Pow) and other.exp == 1:\n            return self == other.base\n        try:\n            other = _sympify(other)\n        except SympifyError:\n            return False\n        if isinstance(self, AppliedUndef) and isinstance(other, AppliedUndef):\n            if self.class_key() != other.class_key():\n                return False\n        elif type(self) is not type(other):\n            return False\n    return self._hashable_content() == other._hashable_content()",
    ".sympy.logic.boolalg.py@@BooleanTrue.__hash__": "def __hash__(self):\n    return hash(True)",
    ".sympy.logic.boolalg.py@@BooleanTrue.__nonzero__": "def __nonzero__(self):\n    return True",
    ".sympy.core.function.py@@Application.__new__": "def __new__(cls, *args, **options):\n    from sympy.sets.fancysets import Naturals0\n    from sympy.sets.sets import FiniteSet\n    args = list(map(sympify, args))\n    evaluate = options.pop('evaluate', global_evaluate[0])\n    options.pop('nargs', None)\n    if options:\n        raise ValueError('Unknown options: %s' % options)\n    if evaluate:\n        evaluated = cls.eval(*args)\n        if evaluated is not None:\n            return evaluated\n    obj = super(Application, cls).__new__(cls, *args, **options)\n    try:\n        if is_sequence(obj.nargs):\n            nargs = tuple(ordered(set(obj.nargs)))\n        elif obj.nargs is not None:\n            nargs = (as_int(obj.nargs),)\n        else:\n            nargs = None\n    except AttributeError:\n        nargs = obj._nargs\n    obj.nargs = FiniteSet(*nargs) if nargs else Naturals0()\n    return obj",
    ".sympy.functions.elementary.complexes.py@@re.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_real:\n        return arg\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        return S.Zero\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[0]\n    elif arg.is_Function and arg.func is conjugate:\n        return re(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_real:\n                    reverted.append(coeff)\n            elif not term.has(S.ImaginaryUnit) and term.is_real:\n                excluded.append(term)\n            else:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[0])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) - im(b) + c",
    ".sympy.functions.elementary.complexes.py@@im.eval": "def eval(cls, arg):\n    if arg is S.NaN:\n        return S.NaN\n    elif arg is S.ComplexInfinity:\n        return S.NaN\n    elif arg.is_real:\n        return S.Zero\n    elif arg.is_imaginary or (S.ImaginaryUnit * arg).is_real:\n        return -S.ImaginaryUnit * arg\n    elif arg.is_Matrix:\n        return arg.as_real_imag()[1]\n    elif arg.is_Function and arg.func is conjugate:\n        return -im(arg.args[0])\n    else:\n        included, reverted, excluded = ([], [], [])\n        args = Add.make_args(arg)\n        for term in args:\n            coeff = term.as_coefficient(S.ImaginaryUnit)\n            if coeff is not None:\n                if not coeff.is_real:\n                    reverted.append(coeff)\n                else:\n                    excluded.append(coeff)\n            elif term.has(S.ImaginaryUnit) or not term.is_real:\n                real_imag = term.as_real_imag(ignore=arg)\n                if real_imag:\n                    excluded.append(real_imag[1])\n                else:\n                    included.append(term)\n        if len(args) != len(included):\n            a, b, c = (Add(*xs) for xs in [included, reverted, excluded])\n            return cls(a) + re(b) + c",
    ".sympy.core.numbers.py@@Zero.__nonzero__": "def __nonzero__(self):\n    return False",
    ".sympy.core.evalf.py@@EvalfMixin.evalf": "def evalf(self, n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False):\n    from sympy import Float, Number\n    n = n if n is not None else 15\n    if subs and is_sequence(subs):\n        raise TypeError('subs must be given as a dictionary')\n    if n == 1 and isinstance(self, Number):\n        from sympy.core.expr import _mag\n        rv = self.evalf(2, subs, maxn, chop, strict, quad, verbose)\n        m = _mag(rv)\n        rv = rv.round(1 - m)\n        return rv\n    if not evalf_table:\n        _create_evalf_table()\n    prec = dps_to_prec(n)\n    options = {'maxprec': max(prec, int(maxn * LG10)), 'chop': chop, 'strict': strict, 'verbose': verbose}\n    if subs is not None:\n        options['subs'] = subs\n    if quad is not None:\n        options['quad'] = quad\n    try:\n        result = evalf(self, prec + 4, options)\n    except NotImplementedError:\n        v = self._eval_evalf(prec)\n        if v is None:\n            return self\n        try:\n            result = evalf(v, prec, options)\n        except NotImplementedError:\n            return v\n    re, im, re_acc, im_acc = result\n    if re:\n        p = max(min(prec, re_acc), 1)\n        re = Float._new(re, p)\n    else:\n        re = S.Zero\n    if im:\n        p = max(min(prec, im_acc), 1)\n        im = Float._new(im, p)\n        return re + im * S.ImaginaryUnit\n    else:\n        return re",
    ".sympy.core.evalf.py@@evalf": "def evalf(x, prec, options):\n    from sympy import re as re_, im as im_\n    try:\n        rf = evalf_table[x.func]\n        r = rf(x, prec, options)\n    except KeyError:\n        try:\n            if 'subs' in options:\n                x = x.subs(evalf_subs(prec, options['subs']))\n            xe = x._eval_evalf(prec)\n            re, im = xe.as_real_imag()\n            if re.has(re_) or im.has(im_):\n                raise NotImplementedError\n            if re == 0:\n                re = None\n                reprec = None\n            elif re.is_number:\n                re = re._to_mpmath(prec, allow_ints=False)._mpf_\n                reprec = prec\n            if im == 0:\n                im = None\n                imprec = None\n            elif im.is_number:\n                im = im._to_mpmath(prec, allow_ints=False)._mpf_\n                imprec = prec\n            r = (re, im, reprec, imprec)\n        except AttributeError:\n            raise NotImplementedError\n    if options.get('verbose'):\n        print('### input', x)\n        print('### output', to_str(r[0] or fzero, 50))\n        print('### raw', r)\n        print()\n    chop = options.get('chop', False)\n    if chop:\n        if chop is True:\n            chop_prec = prec\n        else:\n            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))\n            if chop_prec == 3:\n                chop_prec -= 1\n        r = chop_parts(r, chop_prec)\n    if options.get('strict'):\n        check_target(x, r, prec)\n    return r",
    ".sympy.core.basic.py@@Basic.func": "def func(self):\n    return self.__class__",
    ".sympy.core.numbers.py@@Integer._as_mpf_val": "def _as_mpf_val(self, prec):\n    return mlib.from_int(self.p, prec)",
    ".sympy.core.numbers.py@@Float.__le__": "def __le__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s <= %s' % (self, other))\n    if isinstance(other, NumberSymbol):\n        return other.__gt__(self)\n    if other.is_real and other.is_number:\n        other = other.evalf()\n    if isinstance(other, Number) and other is not S.NaN:\n        return _sympify(bool(mlib.mpf_le(self._mpf_, other._as_mpf_val(self._prec))))\n    return Expr.__le__(self, other)",
    ".sympy.core.numbers.py@@Float._new": "def _new(cls, _mpf_, _prec):\n    if _mpf_ == _mpf_zero:\n        return S.Zero\n    elif _mpf_ == _mpf_nan:\n        return S.NaN\n    obj = Expr.__new__(cls)\n    obj._mpf_ = mpf_norm(_mpf_, _prec)\n    obj._prec = _prec\n    return obj",
    ".sympy.core.numbers.py@@mpf_norm": "def mpf_norm(mpf, prec):\n    sign, man, expt, bc = mpf\n    if not man:\n        if not bc:\n            return _mpf_zero\n        else:\n            return mpf\n    from mpmath.libmp.backend import MPZ\n    rv = mpf_normalize(sign, MPZ(man), expt, bc, prec, rnd)\n    return rv",
    ".sympy.core.numbers.py@@Float._as_mpf_val": "def _as_mpf_val(self, prec):\n    rv = mpf_norm(self._mpf_, prec)\n    if rv != self._mpf_ and self._prec == prec:\n        debug(self._mpf_, rv)\n    return rv",
    ".sympy.core.operations.py@@LatticeOp.__new__": "def __new__(cls, *args, **options):\n    args = (_sympify(arg) for arg in args)\n    try:\n        _args = frozenset(cls._new_args_filter(args))\n    except ShortCircuit:\n        return sympify(cls.zero)\n    if not _args:\n        return sympify(cls.identity)\n    elif len(_args) == 1:\n        return set(_args).pop()\n    else:\n        obj = super(AssocOp, cls).__new__(cls, _args)\n        obj._argset = _args\n        return obj",
    ".sympy.logic.boolalg.py@@And._new_args_filter": "def _new_args_filter(cls, args):\n    newargs = []\n    rel = []\n    for x in reversed(list(args)):\n        if isinstance(x, Number) or x in (0, 1):\n            newargs.append(True if x else False)\n            continue\n        if x.is_Relational:\n            c = x.canonical\n            if c in rel:\n                continue\n            nc = (~c).canonical\n            if any((r == nc for r in rel)):\n                return [S.false]\n            rel.append(c)\n        newargs.append(x)\n    return LatticeOp._new_args_filter(newargs, And)",
    ".sympy.core.operations.py@@LatticeOp._new_args_filter": "def _new_args_filter(cls, arg_sequence, call_cls=None):\n    ncls = call_cls or cls\n    for arg in arg_sequence:\n        if arg == ncls.zero:\n            raise ShortCircuit(arg)\n        elif arg == ncls.identity:\n            continue\n        elif arg.func == ncls:\n            for x in arg.args:\n                yield x\n        else:\n            yield arg",
    ".sympy.logic.boolalg.py@@BooleanFalse.__hash__": "def __hash__(self):\n    return hash(False)",
    ".sympy.core.numbers.py@@Integer.__le__": "def __le__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s <= %s' % (self, other))\n    if isinstance(other, Integer):\n        return _sympify(self.p <= other.p)\n    return Rational.__le__(self, other)",
    ".sympy.core.numbers.py@@Integer.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    if isinstance(other, Integer):\n        return _sympify(self.p < other.p)\n    return Rational.__lt__(self, other)",
    ".sympy.core.numbers.py@@Integer.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s > %s' % (self, other))\n    if isinstance(other, Integer):\n        return _sympify(self.p > other.p)\n    return Rational.__gt__(self, other)",
    ".sympy.core.numbers.py@@NumberSymbol.__hash__": "def __hash__(self):\n    return super(NumberSymbol, self).__hash__()",
    ".sympy.sets.fancysets.py@@Naturals._contains": "def _contains(self, other):\n    if not isinstance(other, Expr):\n        return S.false\n    elif other.is_positive and other.is_integer:\n        return S.true\n    elif other.is_integer is False or other.is_positive is False:\n        return S.false",
    ".sympy.core.numbers.py@@NegativeInfinity.__hash__": "def __hash__(self):\n    return super(NegativeInfinity, self).__hash__()",
    ".sympy.core.numbers.py@@Rational.__gt__": "def __gt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s > %s' % (self, other))\n    if isinstance(other, NumberSymbol):\n        return other.__le__(self)\n    expr = self\n    if isinstance(other, Number):\n        if isinstance(other, Rational):\n            return _sympify(bool(self.p * other.q > self.q * other.p))\n        if isinstance(other, Float):\n            return _sympify(bool(mlib.mpf_gt(self._as_mpf_val(other._prec), other._mpf_)))\n    elif other.is_number and other.is_real:\n        expr, other = (Integer(self.p), self.q * other)\n    return Expr.__gt__(expr, other)",
    ".sympy.core.expr.py@@Expr.__gt__": "def __gt__(self, other):\n    from sympy import StrictGreaterThan\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s > %s' % (self, other))\n    for me in (self, other):\n        if me.is_complex and me.is_real is False or me.has(S.ComplexInfinity):\n            raise TypeError('Invalid comparison of complex %s' % me)\n        if me is S.NaN:\n            raise TypeError('Invalid NaN comparison')\n    if self.is_real or other.is_real:\n        dif = self - other\n        if dif.is_positive is not None and dif.is_positive is not dif.is_nonpositive:\n            return sympify(dif.is_positive)\n    return StrictGreaterThan(self, other, evaluate=False)",
    ".sympy.core.basic.py@@Basic.has": "def has(self, *patterns):\n    return any((self._has(pattern) for pattern in patterns))",
    ".sympy.core.basic.py@@Basic._has": "def _has(self, pattern):\n    from sympy.core.function import UndefinedFunction, Function\n    if isinstance(pattern, UndefinedFunction):\n        return any((f.func == pattern or f == pattern for f in self.atoms(Function, UndefinedFunction)))\n    pattern = sympify(pattern)\n    if isinstance(pattern, BasicMeta):\n        return any((isinstance(arg, pattern) for arg in preorder_traversal(self)))\n    try:\n        match = pattern._has_matcher()\n        return any((match(arg) for arg in preorder_traversal(self)))\n    except AttributeError:\n        return any((arg == pattern for arg in preorder_traversal(self)))",
    ".sympy.core.basic.py@@Basic._has_matcher": "def _has_matcher(self):\n    return self.__eq__",
    ".sympy.core.basic.py@@preorder_traversal.__init__": "def __init__(self, node, keys=None):\n    self._skip_flag = False\n    self._pt = self._preorder_traversal(node, keys)",
    ".sympy.core.basic.py@@preorder_traversal.__iter__": "def __iter__(self):\n    return self",
    ".sympy.core.basic.py@@preorder_traversal.__next__": "def __next__(self):\n    return next(self._pt)",
    ".sympy.core.basic.py@@preorder_traversal._preorder_traversal": "def _preorder_traversal(self, node, keys):\n    yield node\n    if self._skip_flag:\n        self._skip_flag = False\n        return\n    if isinstance(node, Basic):\n        if not keys and hasattr(node, '_argset'):\n            args = node._argset\n        else:\n            args = node.args\n        if keys:\n            if keys != True:\n                args = ordered(args, keys, default=False)\n            else:\n                args = ordered(args)\n        for arg in args:\n            for subtree in self._preorder_traversal(arg, keys):\n                yield subtree\n    elif iterable(node):\n        for item in node:\n            for subtree in self._preorder_traversal(item, keys):\n                yield subtree",
    ".sympy.core.numbers.py@@Integer.__sub__": "def __sub__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p - other)\n        elif isinstance(other, Integer):\n            return Integer(self.p - other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - other.p, other.q, 1)\n        return Rational.__sub__(self, other)\n    return Rational.__sub__(self, other)",
    ".sympy.core.decorators.py@@__sympifyit_wrapper": "def __sympifyit_wrapper(a, b):\n    try:\n        if not hasattr(b, '_op_priority'):\n            b = sympify(b, strict=True)\n        return func(a, b)\n    except SympifyError:\n        return retval",
    ".sympy.core.numbers.py@@Rational.__sub__": "def __sub__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, Integer):\n            return Rational(self.p - self.q * other.p, self.q, 1)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q - self.q * other.p, self.q * other.q)\n        elif isinstance(other, Float):\n            return -other + self\n        else:\n            return Number.__sub__(self, other)\n    return Number.__sub__(self, other)",
    ".sympy.core.numbers.py@@Number.__sub__": "def __sub__(self, other):\n    if isinstance(other, Number) and global_evaluate[0]:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            return S.NegativeInfinity\n        elif other is S.NegativeInfinity:\n            return S.Infinity\n    return AtomicExpr.__sub__(self, other)",
    ".sympy.core.numbers.py@@Integer.__ge__": "def __ge__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s >= %s' % (self, other))\n    if isinstance(other, Integer):\n        return _sympify(self.p >= other.p)\n    return Rational.__ge__(self, other)",
    ".sympy.sets.sets.py@@Intersection._contains": "def _contains(self, other):\n    return And(*[set.contains(other) for set in self.args])",
    ".sympy.core.assumptions.py@@getit": "def getit(self):\n    try:\n        return self._assumptions[fact]\n    except KeyError:\n        if self._assumptions is self.default_assumptions:\n            self._assumptions = self.default_assumptions.copy()\n        return _ask(fact, self)",
    ".sympy.core.decorators.py@@binary_op_wrapper": "def binary_op_wrapper(self, other):\n    if hasattr(other, '_op_priority'):\n        if other._op_priority > self._op_priority:\n            try:\n                f = getattr(other, method_name)\n            except AttributeError:\n                pass\n            else:\n                return f(self)\n    return func(self, other)",
    ".sympy.core.expr.py@@Expr.__sub__": "def __sub__(self, other):\n    return Add(self, -other)",
    ".sympy.core.numbers.py@@Zero.__neg__": "def __neg__():\n    return S.Zero",
    ".sympy.core.operations.py@@AssocOp.__new__": "def __new__(cls, *args, **options):\n    from sympy import Order\n    args = list(map(_sympify, args))\n    args = [a for a in args if a is not cls.identity]\n    if not options.pop('evaluate', global_evaluate[0]):\n        return cls._from_args(args)\n    if len(args) == 0:\n        return cls.identity\n    if len(args) == 1:\n        return args[0]\n    c_part, nc_part, order_symbols = cls.flatten(args)\n    is_commutative = not nc_part\n    obj = cls._from_args(c_part + nc_part, is_commutative)\n    if order_symbols is not None:\n        return Order(obj, *order_symbols)\n    return obj",
    ".sympy.core.expr.py@@Expr.as_numer_denom": "def as_numer_denom(self):\n    return (self, S.One)",
    ".sympy.core.operations.py@@AssocOp.make_args": "def make_args(cls, expr):\n    if isinstance(expr, cls):\n        return expr.args\n    else:\n        return (sympify(expr),)",
    ".sympy.core.relational.py@@Relational.__new__": "def __new__(cls, lhs, rhs, rop=None, **assumptions):\n    if cls is not Relational:\n        return Expr.__new__(cls, lhs, rhs, **assumptions)\n    try:\n        cls = cls.ValidRelationOperator[rop]\n        return cls(lhs, rhs, **assumptions)\n    except KeyError:\n        raise ValueError('Invalid relational operator symbol: %r' % rop)",
    ".sympy.core.expr.py@@Expr.simplify": "def simplify(self, ratio=1.7, measure=None):\n    from sympy.simplify import simplify\n    from sympy.core.function import count_ops\n    measure = measure or count_ops\n    return simplify(self, ratio, measure)",
    ".sympy.simplify.simplify.py@@simplify": "def simplify(expr, ratio=1.7, measure=count_ops, fu=False):\n    expr = sympify(expr)\n    try:\n        return expr._eval_simplify(ratio=ratio, measure=measure)\n    except AttributeError:\n        pass\n    original_expr = expr = signsimp(expr)\n    from sympy.simplify.hyperexpand import hyperexpand\n    from sympy.functions.special.bessel import BesselBase\n    from sympy import Sum, Product\n    if not isinstance(expr, Basic) or not expr.args:\n        return expr\n    if not isinstance(expr, (Add, Mul, Pow, ExpBase)):\n        if isinstance(expr, Function) and hasattr(expr, 'inverse'):\n            if len(expr.args) == 1 and len(expr.args[0].args) == 1 and isinstance(expr.args[0], expr.inverse(argindex=1)):\n                return simplify(expr.args[0].args[0], ratio=ratio, measure=measure, fu=fu)\n        return expr.func(*[simplify(x, ratio=ratio, measure=measure, fu=fu) for x in expr.args])\n\n    def shorter(*choices):\n        if not has_variety(choices):\n            return choices[0]\n        return min(choices, key=measure)\n    expr = bottom_up(expr, lambda w: w.normal())\n    expr = Mul(*powsimp(expr).as_content_primitive())\n    _e = cancel(expr)\n    expr1 = shorter(_e, _mexpand(_e).cancel())\n    expr2 = shorter(together(expr, deep=True), together(expr1, deep=True))\n    if ratio is S.Infinity:\n        expr = expr2\n    else:\n        expr = shorter(expr2, expr1, expr)\n    if not isinstance(expr, Basic):\n        return expr\n    expr = factor_terms(expr, sign=False)\n    expr = hyperexpand(expr)\n    expr = piecewise_fold(expr)\n    if expr.has(BesselBase):\n        expr = besselsimp(expr)\n    if expr.has(TrigonometricFunction) and (not fu) or expr.has(HyperbolicFunction):\n        expr = trigsimp(expr, deep=True)\n    if expr.has(log):\n        expr = shorter(expand_log(expr, deep=True), logcombine(expr))\n    if expr.has(CombinatorialFunction, gamma):\n        expr = combsimp(expr)\n    if expr.has(Sum):\n        expr = sum_simplify(expr)\n    if expr.has(Product):\n        expr = product_simplify(expr)\n    short = shorter(powsimp(expr, combine='exp', deep=True), powsimp(expr), expr)\n    short = shorter(short, factor_terms(short), expand_power_exp(expand_mul(short)))\n    if short.has(TrigonometricFunction, HyperbolicFunction, ExpBase):\n        short = exptrigsimp(short, simplify=False)\n    hollow_mul = Transform(lambda x: Mul(*x.args), lambda x: x.is_Mul and len(x.args) == 2 and x.args[0].is_Number and x.args[1].is_Add and x.is_commutative)\n    expr = short.xreplace(hollow_mul)\n    numer, denom = expr.as_numer_denom()\n    if denom.is_Add:\n        n, d = fraction(radsimp(1 / denom, symbolic=False, max_terms=1))\n        if n is not S.One:\n            expr = (numer * n).expand() / d\n    if expr.could_extract_minus_sign():\n        n, d = fraction(expr)\n        if d != 0:\n            expr = signsimp(-n / -d)\n    if measure(expr) > ratio * measure(original_expr):\n        expr = original_expr\n    return expr",
    ".sympy.core.basic.py@@Basic._hashable_content": "def _hashable_content(self):\n    return self._args",
    ".sympy.core.relational.py@@Relational._eval_simplify": "def _eval_simplify(self, ratio, measure):\n    r = self\n    r = r.func(*[i.simplify(ratio=ratio, measure=measure) for i in r.args])\n    if r.is_Relational:\n        dif = r.lhs - r.rhs\n        v = None\n        if dif.is_comparable:\n            v = dif.n(2)\n        elif dif.equals(0):\n            v = S.Zero\n        if v is not None:\n            r = r.func._eval_relation(v, S.Zero)\n    r = r.canonical\n    if measure(r) < ratio * measure(self):\n        return r\n    else:\n        return self",
    ".sympy.core.basic.py@@Atom._eval_simplify": "def _eval_simplify(self, ratio, measure):\n    return self",
    ".sympy.core.relational.py@@Relational.lhs": "def lhs(self):\n    return self._args[0]",
    ".sympy.core.relational.py@@Relational.rhs": "def rhs(self):\n    return self._args[1]",
    ".sympy.core.expr.py@@Expr.equals": "def equals(self, other, failing_expression=False):\n    from sympy.simplify.simplify import nsimplify, simplify\n    from sympy.solvers.solveset import solveset\n    from sympy.polys.polyerrors import NotAlgebraic\n    from sympy.polys.numberfields import minimal_polynomial\n    other = sympify(other)\n    if self == other:\n        return True\n    diff = factor_terms(simplify(self - other), radical=True)\n    if not diff:\n        return True\n    if not diff.has(Add, Mod):\n        return False\n    constant = diff.is_constant(simplify=False, failing_number=True)\n    if constant is False:\n        return False\n    if constant is None and (diff.free_symbols or not diff.is_number):\n        return\n    if constant is True:\n        ndiff = diff._random()\n        if ndiff:\n            return False\n    if diff.is_number:\n        approx = diff.nsimplify()\n        if not approx:\n            surds = [s for s in diff.atoms(Pow) if s.args[0].is_Integer]\n            surds.sort(key=lambda x: -x.args[0])\n            for s in surds:\n                try:\n                    if s.is_Symbol:\n                        sol = list(solveset(diff, s))\n                    else:\n                        sol = [s]\n                    if sol:\n                        if s in sol:\n                            return True\n                        if s.is_real:\n                            if any((nsimplify(si, [s]) == s and simplify(si) == s for si in sol)):\n                                return True\n                except NotImplementedError:\n                    pass\n            if True:\n                try:\n                    mp = minimal_polynomial(diff)\n                    if mp.is_Symbol:\n                        return True\n                    return False\n                except (NotAlgebraic, NotImplementedError):\n                    pass\n    if constant not in (True, None) and constant != 0:\n        return False\n    if failing_expression:\n        return diff\n    return None",
    ".sympy.core.exprtools.py@@factor_terms": "def factor_terms(expr, radical=False, clear=False, fraction=False, sign=True):\n\n    def do(expr):\n        from sympy.concrete.summations import Sum\n        from sympy.simplify.simplify import factor_sum\n        is_iterable = iterable(expr)\n        if not isinstance(expr, Basic) or expr.is_Atom:\n            if is_iterable:\n                return type(expr)([do(i) for i in expr])\n            return expr\n        if expr.is_Pow or expr.is_Function or is_iterable or (not hasattr(expr, 'args_cnc')):\n            args = expr.args\n            newargs = tuple([do(i) for i in args])\n            if newargs == args:\n                return expr\n            return expr.func(*newargs)\n        if isinstance(expr, Sum):\n            return factor_sum(expr, radical=radical, clear=clear, fraction=fraction, sign=sign)\n        cont, p = expr.as_content_primitive(radical=radical, clear=clear)\n        if p.is_Add:\n            list_args = [do(a) for a in Add.make_args(p)]\n            if all((a.as_coeff_Mul()[0] < 0 for a in list_args)):\n                cont = -cont\n                list_args = [-a for a in list_args]\n            special = {}\n            for i, a in enumerate(list_args):\n                b, e = a.as_base_exp()\n                if e.is_Mul and e != Mul(*e.args):\n                    list_args[i] = Dummy()\n                    special[list_args[i]] = a\n            p = Add._from_args(list_args)\n            p = gcd_terms(p, isprimitive=True, clear=clear, fraction=fraction).xreplace(special)\n        elif p.args:\n            p = p.func(*[do(a) for a in p.args])\n        rv = _keep_coeff(cont, p, clear=clear, sign=sign)\n        return rv\n    expr = sympify(expr)\n    return do(expr)",
    ".sympy.core.exprtools.py@@do": "def do(expr):\n    from sympy.concrete.summations import Sum\n    from sympy.simplify.simplify import factor_sum\n    is_iterable = iterable(expr)\n    if not isinstance(expr, Basic) or expr.is_Atom:\n        if is_iterable:\n            return type(expr)([do(i) for i in expr])\n        return expr\n    if expr.is_Pow or expr.is_Function or is_iterable or (not hasattr(expr, 'args_cnc')):\n        args = expr.args\n        newargs = tuple([do(i) for i in args])\n        if newargs == args:\n            return expr\n        return expr.func(*newargs)\n    if isinstance(expr, Sum):\n        return factor_sum(expr, radical=radical, clear=clear, fraction=fraction, sign=sign)\n    cont, p = expr.as_content_primitive(radical=radical, clear=clear)\n    if p.is_Add:\n        list_args = [do(a) for a in Add.make_args(p)]\n        if all((a.as_coeff_Mul()[0] < 0 for a in list_args)):\n            cont = -cont\n            list_args = [-a for a in list_args]\n        special = {}\n        for i, a in enumerate(list_args):\n            b, e = a.as_base_exp()\n            if e.is_Mul and e != Mul(*e.args):\n                list_args[i] = Dummy()\n                special[list_args[i]] = a\n        p = Add._from_args(list_args)\n        p = gcd_terms(p, isprimitive=True, clear=clear, fraction=fraction).xreplace(special)\n    elif p.args:\n        p = p.func(*[do(a) for a in p.args])\n    rv = _keep_coeff(cont, p, clear=clear, sign=sign)\n    return rv",
    ".sympy.core.compatibility.py@@iterable": "def iterable(i, exclude=(string_types, dict, NotIterable)):\n    if hasattr(i, '_iterable'):\n        return i._iterable\n    try:\n        iter(i)\n    except TypeError:\n        return False\n    if exclude:\n        return not isinstance(i, exclude)\n    return True",
    ".sympy.core.relational.py@@Relational.canonical": "def canonical(self):\n    r = self\n    if r.func in (Ge, Gt):\n        r = r.reversed\n    elif r.func in (Lt, Le):\n        pass\n    elif r.func in (Eq, Ne):\n        r = r.func(*ordered(r.args), evaluate=False)\n    else:\n        raise NotImplemented\n    if r.lhs.is_Number and (not r.rhs.is_Number):\n        r = r.reversed\n    elif r.rhs.is_Symbol and (not r.lhs.is_Symbol):\n        r = r.reversed\n    if _coeff_isneg(r.lhs):\n        r = r.reversed.func(-r.lhs, -r.rhs, evaluate=False)\n    return r",
    ".sympy.core.compatibility.py@@_nodes": "def _nodes(e):\n    from .basic import Basic\n    if isinstance(e, Basic):\n        return e.count(Basic)\n    elif iterable(e):\n        return 1 + sum((_nodes(ei) for ei in e))\n    elif isinstance(e, dict):\n        return 1 + sum((_nodes(k) + _nodes(v) for k, v in e.items()))\n    else:\n        return 1",
    ".sympy.core.basic.py@@Basic.count": "def count(self, query):\n    query = _make_find_query(query)\n    return sum((bool(query(sub)) for sub in preorder_traversal(self)))",
    ".sympy.core.basic.py@@_make_find_query": "def _make_find_query(query):\n    try:\n        query = sympify(query)\n    except SympifyError:\n        pass\n    if isinstance(query, type):\n        return lambda expr: isinstance(expr, query)\n    elif isinstance(query, Basic):\n        return lambda expr: expr.match(query) is not None\n    return query",
    ".sympy.core.compatibility.py@@default_sort_key": "def default_sort_key(item, order=None):\n    from .singleton import S\n    from .basic import Basic\n    from .sympify import sympify, SympifyError\n    from .compatibility import iterable\n    if isinstance(item, Basic):\n        return item.sort_key(order=order)\n    if iterable(item, exclude=string_types):\n        if isinstance(item, dict):\n            args = item.items()\n            unordered = True\n        elif isinstance(item, set):\n            args = item\n            unordered = True\n        else:\n            args = list(item)\n            unordered = False\n        args = [default_sort_key(arg, order=order) for arg in args]\n        if unordered:\n            args = sorted(args)\n        cls_index, args = (10, (len(args), tuple(args)))\n    else:\n        if not isinstance(item, string_types):\n            try:\n                item = sympify(item)\n            except SympifyError:\n                pass\n            else:\n                if isinstance(item, Basic):\n                    return default_sort_key(item)\n        cls_index, args = (0, (1, (str(item),)))\n    return ((cls_index, 0, item.__class__.__name__), args, S.One.sort_key(), S.One)",
    ".sympy.core.symbol.py@@Symbol.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One)",
    ".sympy.core.basic.py@@Atom.class_key": "def class_key(cls):\n    return (2, 0, cls.__name__)",
    ".sympy.core.basic.py@@Basic.__str__": "def __str__(self):\n    from sympy.printing import sstr\n    return sstr(self, order=None)",
    ".sympy.printing.str.py@@sstr": "def sstr(expr, **settings):\n    p = StrPrinter(settings)\n    s = p.doprint(expr)\n    return s",
    ".sympy.printing.printer.py@@Printer.__init__": "def __init__(self, settings=None):\n    self._str = str\n    self._settings = self._default_settings.copy()\n    for key, val in self._global_settings.items():\n        if key in self._default_settings:\n            self._settings[key] = val\n    if settings is not None:\n        self._settings.update(settings)\n        if len(self._settings) > len(self._default_settings):\n            for key in self._settings:\n                if key not in self._default_settings:\n                    raise TypeError(\"Unknown setting '%s'.\" % key)\n    self._print_level = 0",
    ".sympy.printing.printer.py@@Printer.doprint": "def doprint(self, expr):\n    return self._str(self._print(expr))",
    ".sympy.printing.printer.py@@Printer._print": "def _print(self, expr, *args, **kwargs):\n    self._print_level += 1\n    try:\n        if self.printmethod and hasattr(expr, self.printmethod) and (not isinstance(expr, BasicMeta)):\n            return getattr(expr, self.printmethod)(self, *args, **kwargs)\n        for cls in type(expr).__mro__:\n            printmethod = '_print_' + cls.__name__\n            if hasattr(self, printmethod):\n                return getattr(self, printmethod)(expr, *args, **kwargs)\n        return self.emptyPrinter(expr)\n    finally:\n        self._print_level -= 1",
    ".sympy.printing.str.py@@StrPrinter._print_Symbol": "def _print_Symbol(self, expr):\n    return expr.name",
    ".sympy.core.numbers.py@@Number.sort_key": "def sort_key(self, order=None):\n    return (self.class_key(), (0, ()), (), self)",
    ".sympy.core.numbers.py@@Number.class_key": "def class_key(cls):\n    return (1, 0, 'Number')",
    ".sympy.core.relational.py@@Relational.reversed": "def reversed(self):\n    ops = {Gt: Lt, Ge: Le, Lt: Gt, Le: Ge}\n    a, b = self.args\n    return ops.get(self.func, self.func)(b, a, evaluate=False)",
    ".sympy.core.function.py@@_coeff_isneg": "def _coeff_isneg(a):\n    if a.is_Mul:\n        a = a.args[0]\n    return a.is_Number and a.is_negative",
    ".sympy.core.function.py@@count_ops": "def count_ops(expr, visual=False):\n    from sympy import Integral, Symbol\n    from sympy.simplify.radsimp import fraction\n    from sympy.logic.boolalg import BooleanFunction\n    expr = sympify(expr)\n    if isinstance(expr, Expr):\n        ops = []\n        args = [expr]\n        NEG = Symbol('NEG')\n        DIV = Symbol('DIV')\n        SUB = Symbol('SUB')\n        ADD = Symbol('ADD')\n        while args:\n            a = args.pop()\n            if isinstance(a, string_types):\n                continue\n            if a.is_Rational:\n                if a is not S.One:\n                    if a.p < 0:\n                        ops.append(NEG)\n                    if a.q != 1:\n                        ops.append(DIV)\n                    continue\n            elif a.is_Mul:\n                if _coeff_isneg(a):\n                    ops.append(NEG)\n                    if a.args[0] is S.NegativeOne:\n                        a = a.as_two_terms()[1]\n                    else:\n                        a = -a\n                n, d = fraction(a)\n                if n.is_Integer:\n                    ops.append(DIV)\n                    if n < 0:\n                        ops.append(NEG)\n                    args.append(d)\n                    continue\n                elif d is not S.One:\n                    if not d.is_Integer:\n                        args.append(d)\n                    ops.append(DIV)\n                    args.append(n)\n                    continue\n            elif a.is_Add:\n                aargs = list(a.args)\n                negs = 0\n                for i, ai in enumerate(aargs):\n                    if _coeff_isneg(ai):\n                        negs += 1\n                        args.append(-ai)\n                        if i > 0:\n                            ops.append(SUB)\n                    else:\n                        args.append(ai)\n                        if i > 0:\n                            ops.append(ADD)\n                if negs == len(aargs):\n                    ops.append(NEG)\n                elif _coeff_isneg(aargs[0]):\n                    ops.append(SUB - ADD)\n                continue\n            if a.is_Pow and a.exp is S.NegativeOne:\n                ops.append(DIV)\n                args.append(a.base)\n                continue\n            if a.is_Mul or a.is_Pow or a.is_Function or isinstance(a, Derivative) or isinstance(a, Integral):\n                o = Symbol(a.func.__name__.upper())\n                if a.is_Mul or isinstance(a, LatticeOp):\n                    ops.append(o * (len(a.args) - 1))\n                else:\n                    ops.append(o)\n            if not a.is_Symbol:\n                args.extend(a.args)\n    elif type(expr) is dict:\n        ops = [count_ops(k, visual=visual) + count_ops(v, visual=visual) for k, v in expr.items()]\n    elif iterable(expr):\n        ops = [count_ops(i, visual=visual) for i in expr]\n    elif isinstance(expr, BooleanFunction):\n        ops = []\n        for arg in expr.args:\n            ops.append(count_ops(arg, visual=True))\n        o = Symbol(expr.func.__name__.upper())\n        ops.append(o)\n    elif not isinstance(expr, Basic):\n        ops = []\n    elif not isinstance(expr, Basic):\n        raise TypeError('Invalid type of expr')\n    else:\n        ops = []\n        args = [expr]\n        while args:\n            a = args.pop()\n            if isinstance(a, string_types):\n                continue\n            if a.args:\n                o = Symbol(a.func.__name__.upper())\n                if a.is_Boolean:\n                    ops.append(o * (len(a.args) - 1))\n                else:\n                    ops.append(o)\n                args.extend(a.args)\n    if not ops:\n        if visual:\n            return S.Zero\n        return 0\n    ops = Add(*ops)\n    if visual:\n        return ops\n    if ops.is_Number:\n        return int(ops)\n    return sum((int((a.args or [1])[0]) for a in Add.make_args(ops)))",
    ".sympy.core.symbol.py@@Symbol.__new__": "def __new__(cls, name, **assumptions):\n    cls._sanitize(assumptions, cls)\n    return Symbol.__xnew_cached_(cls, name, **assumptions)",
    ".sympy.core.symbol.py@@Symbol._sanitize": "def _sanitize(assumptions, obj=None):\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    if is_commutative is None:\n        whose = '%s ' % obj.__name__ if obj else ''\n        raise ValueError('%scommutativity must be True or False.' % whose)\n    for key in list(assumptions.keys()):\n        from collections import defaultdict\n        from sympy.utilities.exceptions import SymPyDeprecationWarning\n        keymap = defaultdict(lambda: None)\n        keymap.update({'bounded': 'finite', 'unbounded': 'infinite', 'infinitesimal': 'zero'})\n        if keymap[key]:\n            SymPyDeprecationWarning(feature='%s assumption' % key, useinstead='%s' % keymap[key], issue=8071, deprecated_since_version='0.7.6').warn()\n            assumptions[keymap[key]] = assumptions[key]\n            assumptions.pop(key)\n            key = keymap[key]\n        v = assumptions[key]\n        if v is None:\n            assumptions.pop(key)\n            continue\n        assumptions[key] = bool(v)",
    ".sympy.core.logic.py@@fuzzy_bool": "def fuzzy_bool(x):\n    if x is None:\n        return None\n    if x in (True, False):\n        return bool(x)",
    ".sympy.core.symbol.py@@Symbol.__new_stage2__": "def __new_stage2__(cls, name, **assumptions):\n    if not isinstance(name, string_types):\n        raise TypeError('name should be a string, not %s' % repr(type(name)))\n    obj = Expr.__new__(cls)\n    obj.name = name\n    tmp_asm_copy = assumptions.copy()\n    is_commutative = fuzzy_bool(assumptions.get('commutative', True))\n    assumptions['commutative'] = is_commutative\n    obj._assumptions = StdFactKB(assumptions)\n    obj._assumptions._generator = tmp_asm_copy\n    return obj",
    ".sympy.core.assumptions.py@@StdFactKB.__init__": "def __init__(self, facts=None):\n    if not facts:\n        self._generator = {}\n    elif not isinstance(facts, FactKB):\n        self._generator = facts.copy()\n    else:\n        self._generator = facts.generator\n    if facts:\n        self.deduce_all_facts(facts)",
    ".sympy.core.facts.py@@FactKB.deduce_all_facts": "def deduce_all_facts(self, facts):\n    full_implications = self.rules.full_implications\n    beta_triggers = self.rules.beta_triggers\n    beta_rules = self.rules.beta_rules\n    if isinstance(facts, dict):\n        facts = facts.items()\n    while facts:\n        beta_maytrigger = set()\n        for k, v in facts:\n            if not self._tell(k, v) or v is None:\n                continue\n            for key, value in full_implications[k, v]:\n                self._tell(key, value)\n            beta_maytrigger.update(beta_triggers[k, v])\n        facts = []\n        for bidx in beta_maytrigger:\n            bcond, bimpl = beta_rules[bidx]\n            if all((self.get(k) is v for k, v in bcond)):\n                facts.append(bimpl)",
    ".sympy.core.facts.py@@FactKB._tell": "def _tell(self, k, v):\n    if k in self and self[k] is not None:\n        if self[k] == v:\n            return False\n        else:\n            raise InconsistentAssumptions(self, k, v)\n    else:\n        self[k] = v\n        return True",
    ".sympy.core.basic.py@@Basic.__ne__": "def __ne__(self, other):\n    return not self.__eq__(other)",
    ".sympy.core.function.py@@Application.func": "def func(self):\n    return self.__class__",
    ".sympy.core.assumptions.py@@_ask": "def _ask(fact, obj):\n    assumptions = obj._assumptions\n    handler_map = obj._prop_handler\n    assumptions._tell(fact, None)\n    try:\n        evaluate = handler_map[fact]\n    except KeyError:\n        pass\n    else:\n        a = evaluate(obj)\n        if a is not None:\n            assumptions.deduce_all_facts(((fact, a),))\n            return a\n    prereq = list(_assume_rules.prereq[fact])\n    shuffle(prereq)\n    for pk in prereq:\n        if pk in assumptions:\n            continue\n        if pk in handler_map:\n            _ask(pk, obj)\n            ret_val = assumptions.get(fact)\n            if ret_val is not None:\n                return ret_val\n    return None",
    ".sympy.core.expr.py@@Expr._eval_is_negative": "def _eval_is_negative(self):\n    from sympy.polys.numberfields import minimal_polynomial\n    from sympy.polys.polyerrors import NotAlgebraic\n    if self.is_number:\n        if self.is_real is False:\n            return False\n        try:\n            n2 = self._eval_evalf(2)\n            if n2 is None:\n                raise AttributeError\n            if n2._prec == 1:\n                raise AttributeError\n            if n2 == S.NaN:\n                raise AttributeError\n        except (AttributeError, ValueError):\n            return None\n        n, i = self.evalf(2).as_real_imag()\n        if not i.is_Number or not n.is_Number:\n            return False\n        if n._prec != 1 and i._prec != 1:\n            return bool(not i and n < 0)\n        elif n._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):\n            try:\n                if minimal_polynomial(self).is_Symbol:\n                    return False\n            except (NotAlgebraic, NotImplementedError):\n                pass",
    ".sympy.core.expr.py@@Expr._eval_is_positive": "def _eval_is_positive(self):\n    from sympy.polys.numberfields import minimal_polynomial\n    from sympy.polys.polyerrors import NotAlgebraic\n    if self.is_number:\n        if self.is_real is False:\n            return False\n        try:\n            n2 = self._eval_evalf(2)\n            if n2 is None:\n                raise AttributeError\n            if n2._prec == 1:\n                raise AttributeError\n            if n2 == S.NaN:\n                raise AttributeError\n        except (AttributeError, ValueError):\n            return None\n        n, i = self.evalf(2).as_real_imag()\n        if not i.is_Number or not n.is_Number:\n            return False\n        if n._prec != 1 and i._prec != 1:\n            return bool(not i and n > 0)\n        elif n._prec == 1 and (not i or i._prec == 1) and self.is_algebraic and (not self.has(Function)):\n            try:\n                if minimal_polynomial(self).is_Symbol:\n                    return False\n            except (NotAlgebraic, NotImplementedError):\n                pass",
    ".sympy.core.expr.py@@Expr.__ge__": "def __ge__(self, other):\n    from sympy import GreaterThan\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s >= %s' % (self, other))\n    for me in (self, other):\n        if me.is_complex and me.is_real is False or me.has(S.ComplexInfinity):\n            raise TypeError('Invalid comparison of complex %s' % me)\n        if me is S.NaN:\n            raise TypeError('Invalid NaN comparison')\n    if self.is_real or other.is_real:\n        dif = self - other\n        if dif.is_nonnegative is not None and dif.is_nonnegative is not dif.is_negative:\n            return sympify(dif.is_nonnegative)\n    return GreaterThan(self, other, evaluate=False)",
    ".sympy.core.relational.py@@_Inequality.__new__": "def __new__(cls, lhs, rhs, **options):\n    lhs = _sympify(lhs)\n    rhs = _sympify(rhs)\n    evaluate = options.pop('evaluate', global_evaluate[0])\n    if evaluate:\n        r = cls._eval_relation(lhs, rhs)\n        if r is not None:\n            return r\n    return Relational.__new__(cls, lhs, rhs, **options)",
    ".sympy.core.expr.py@@Expr.__le__": "def __le__(self, other):\n    from sympy import LessThan\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s <= %s' % (self, other))\n    for me in (self, other):\n        if me.is_complex and me.is_real is False or me.has(S.ComplexInfinity):\n            raise TypeError('Invalid comparison of complex %s' % me)\n        if me is S.NaN:\n            raise TypeError('Invalid NaN comparison')\n    if self.is_real or other.is_real:\n        dif = self - other\n        if dif.is_nonpositive is not None and dif.is_nonpositive is not dif.is_positive:\n            return sympify(dif.is_nonpositive)\n    return LessThan(self, other, evaluate=False)",
    ".sympy.core.numbers.py@@Integer.__neg__": "def __neg__(self):\n    return Integer(-self.p)",
    ".sympy.core.add.py@@Add.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        if a.is_Rational:\n            if b.is_Mul:\n                rv = ([a, b], [], None)\n        if rv:\n            if all((s.is_commutative for s in rv[0])):\n                return rv\n            return ([], rv[0], None)\n    terms = {}\n    coeff = S.Zero\n    order_factors = []\n    for o in seq:\n        if o.is_Order:\n            for o1 in order_factors:\n                if o1.contains(o):\n                    o = None\n                    break\n            if o is None:\n                continue\n            order_factors = [o] + [o1 for o1 in order_factors if not o.contains(o1)]\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o.is_finite is False):\n                return ([S.NaN], [], None)\n            if coeff.is_Number:\n                coeff += o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__add__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if coeff.is_finite is False:\n                return ([S.NaN], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o.is_Add:\n            seq.extend(o.args)\n            continue\n        elif o.is_Mul:\n            c, s = o.as_coeff_Mul()\n        elif o.is_Pow:\n            b, e = o.as_base_exp()\n            if b.is_Number and (e.is_Integer or (e.is_Rational and e.is_negative)):\n                seq.append(b ** e)\n                continue\n            c, s = (S.One, o)\n        else:\n            c = S.One\n            s = o\n        if s in terms:\n            terms[s] += c\n            if terms[s] is S.NaN:\n                return ([S.NaN], [], None)\n        else:\n            terms[s] = c\n    newseq = []\n    noncommutative = False\n    for s, c in terms.items():\n        if c is S.Zero:\n            continue\n        elif c is S.One:\n            newseq.append(s)\n        elif s.is_Mul:\n            cs = s._new_rawargs(*(c,) + s.args)\n            newseq.append(cs)\n        elif s.is_Add:\n            newseq.append(Mul(c, s, evaluate=False))\n        else:\n            newseq.append(Mul(c, s))\n        noncommutative = noncommutative or not s.is_commutative\n    if coeff is S.Infinity:\n        newseq = [f for f in newseq if not (f.is_nonnegative or (f.is_real and f.is_finite))]\n    elif coeff is S.NegativeInfinity:\n        newseq = [f for f in newseq if not (f.is_nonpositive or (f.is_real and f.is_finite))]\n    if coeff is S.ComplexInfinity:\n        newseq = [c for c in newseq if not (c.is_finite and c.is_real is not None)]\n    if order_factors:\n        newseq2 = []\n        for t in newseq:\n            for o in order_factors:\n                if o.contains(t):\n                    t = None\n                    break\n            if t is not None:\n                newseq2.append(t)\n        newseq = newseq2 + order_factors\n        for o in order_factors:\n            if o.contains(coeff):\n                coeff = S.Zero\n                break\n    _addsort(newseq)\n    if coeff is not S.Zero:\n        newseq.insert(0, coeff)\n    if noncommutative:\n        return ([], newseq, None)\n    else:\n        return (newseq, [], None)",
    ".sympy.core.numbers.py@@Integer.__add__": "def __add__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p + other)\n        elif isinstance(other, Integer):\n            return Integer(self.p + other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q + other.p, other.q, 1)\n        return Rational.__add__(self, other)\n    else:\n        return Add(self, other)",
    ".sympy.core.add.py@@_addsort": "def _addsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.operations.py@@AssocOp._from_args": "def _from_args(cls, args, is_commutative=None):\n    if len(args) == 0:\n        return cls.identity\n    elif len(args) == 1:\n        return args[0]\n    obj = super(AssocOp, cls).__new__(cls, *args)\n    if is_commutative is None:\n        is_commutative = fuzzy_and((a.is_commutative for a in args))\n    obj.is_commutative = is_commutative\n    return obj",
    ".sympy.core.assumptions.py@@StdFactKB.copy": "def copy(self):\n    return self.__class__(self)",
    ".sympy.core.add.py@@Add._eval_is_nonpositive": "def _eval_is_nonpositive(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_nonpositive:\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s.is_nonpositive:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v.is_nonpositive:\n                        return True",
    ".sympy.core.expr.py@@Expr.is_number": "def is_number(self):\n    return all((obj.is_number for obj in self.args))",
    ".sympy.core.add.py@@Add.as_coeff_Add": "def as_coeff_Add(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number and (not rational) or coeff.is_Rational:\n        return (coeff, self._new_rawargs(*args))\n    return (S.Zero, self)",
    ".sympy.core.operations.py@@AssocOp._new_rawargs": "def _new_rawargs(self, *args, **kwargs):\n    if kwargs.pop('reeval', True) and self.is_commutative is False:\n        is_commutative = None\n    else:\n        is_commutative = self.is_commutative\n    return self._from_args(args, is_commutative)",
    ".sympy.core.assumptions.py@@StdFactKB.generator": "def generator(self):\n    return self._generator.copy()",
    ".sympy.core.numbers.py@@Rational._eval_is_zero": "def _eval_is_zero(self):\n    return self.p == 0",
    ".sympy.core.add.py@@Add._eval_is_negative": "def _eval_is_negative(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if self.is_number:\n        return super(Add, self)._eval_is_negative()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s.is_negative and a.is_nonpositive:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v.is_negative:\n                    return True\n    neg = nonpos = nonneg = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        isneg = a.is_negative\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((isneg, a.is_nonpositive)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if isneg:\n            neg = True\n            continue\n        elif a.is_nonpositive:\n            nonpos = True\n            continue\n        elif a.is_nonnegative:\n            nonneg = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonneg and (not nonpos) and neg:\n        return True\n    elif not nonneg and neg:\n        return True\n    elif not neg and (not nonpos):\n        return False",
    ".sympy.core.exprtools.py@@_monotonic_sign": "def _monotonic_sign(self):\n    if not self.is_real:\n        return\n    if (-self).is_Symbol:\n        rv = _monotonic_sign(-self)\n        return rv if rv is None else -rv\n    if not self.is_Add and self.as_numer_denom()[1].is_number:\n        s = self\n        if s.is_prime:\n            if s.is_odd:\n                return S(3)\n            else:\n                return S(2)\n        elif s.is_positive:\n            if s.is_even:\n                return S(2)\n            elif s.is_integer:\n                return S.One\n            else:\n                return _eps\n        elif s.is_negative:\n            if s.is_even:\n                return S(-2)\n            elif s.is_integer:\n                return S.NegativeOne\n            else:\n                return -_eps\n        if s.is_zero or s.is_nonpositive or s.is_nonnegative:\n            return S.Zero\n        return None\n    free = self.free_symbols\n    if len(free) == 1:\n        if self.is_polynomial():\n            from sympy.polys.polytools import real_roots\n            from sympy.polys.polyroots import roots\n            from sympy.polys.polyerrors import PolynomialError\n            x = free.pop()\n            x0 = _monotonic_sign(x)\n            if x0 == _eps or x0 == -_eps:\n                x0 = S.Zero\n            if x0 is not None:\n                d = self.diff(x)\n                if d.is_number:\n                    roots = []\n                else:\n                    try:\n                        roots = real_roots(d)\n                    except (PolynomialError, NotImplementedError):\n                        roots = [r for r in roots(d, x) if r.is_real]\n                y = self.subs(x, x0)\n                if x.is_nonnegative and all((r <= x0 for r in roots)):\n                    if y.is_nonnegative and d.is_positive:\n                        if y:\n                            return y if y.is_positive else Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_negative:\n                        if y:\n                            return y if y.is_negative else Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n                elif x.is_nonpositive and all((r >= x0 for r in roots)):\n                    if y.is_nonnegative and d.is_negative:\n                        if y:\n                            return Dummy('pos', positive=True)\n                        else:\n                            return Dummy('nneg', nonnegative=True)\n                    if y.is_nonpositive and d.is_positive:\n                        if y:\n                            return Dummy('neg', negative=True)\n                        else:\n                            return Dummy('npos', nonpositive=True)\n        else:\n            n, d = self.as_numer_denom()\n            den = None\n            if n.is_number:\n                den = _monotonic_sign(d)\n            elif not d.is_number:\n                if _monotonic_sign(n) is not None:\n                    den = _monotonic_sign(d)\n            if den is not None and (den.is_positive or den.is_negative):\n                v = n * den\n                if v.is_positive:\n                    return Dummy('pos', positive=True)\n                elif v.is_nonnegative:\n                    return Dummy('nneg', nonnegative=True)\n                elif v.is_negative:\n                    return Dummy('neg', negative=True)\n                elif v.is_nonpositive:\n                    return Dummy('npos', nonpositive=True)\n        return None\n    c, a = self.as_coeff_Add()\n    v = None\n    if not a.is_polynomial():\n        n, d = a.as_numer_denom()\n        if not (n.is_number or d.is_number):\n            return\n        if (a.is_Mul or a.is_Pow) and a.is_rational and all((p.exp.is_Integer for p in a.atoms(Pow) if p.is_Pow)) and (a.is_positive or a.is_negative):\n            v = S(1)\n            for ai in Mul.make_args(a):\n                if ai.is_number:\n                    v *= ai\n                    continue\n                reps = {}\n                for x in ai.free_symbols:\n                    reps[x] = _monotonic_sign(x)\n                    if reps[x] is None:\n                        return\n                v *= ai.subs(reps)\n    elif c:\n        if not any((p for p in a.atoms(Pow) if not p.is_number)) and (a.is_nonpositive or a.is_nonnegative):\n            free = list(a.free_symbols)\n            p = {}\n            for i in free:\n                v = _monotonic_sign(i)\n                if v is None:\n                    return\n                p[i] = v or (_eps if i.is_nonnegative else -_eps)\n            v = a.xreplace(p)\n    if v is not None:\n        rv = v + c\n        if v.is_nonnegative and rv.is_positive:\n            return rv.subs(_eps, 0)\n        if v.is_nonpositive and rv.is_negative:\n            return rv.subs(_eps, 0)",
    ".sympy.core.numbers.py@@Number._eval_evalf": "def _eval_evalf(self, prec):\n    return Float._new(self._as_mpf_val(prec), prec)",
    ".sympy.core.numbers.py@@Float.__eq__": "def __eq__(self, other):\n    if isinstance(other, float):\n        o = Float(other)\n        try:\n            ompf = o._as_mpf_val(self._prec)\n        except ValueError:\n            return False\n        return bool(mlib.mpf_eq(self._mpf_, ompf))\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        return False\n    if isinstance(other, NumberSymbol):\n        if other.is_irrational:\n            return False\n        return other.__eq__(self)\n    if isinstance(other, Float):\n        return bool(mlib.mpf_eq(self._mpf_, other._mpf_))\n    if isinstance(other, Number):\n        ompf = other._as_mpf_val(self._prec)\n        return bool(mlib.mpf_eq(self._mpf_, ompf))\n    return False",
    ".sympy.core.numbers.py@@NaN.__hash__": "def __hash__(self):\n    return super(NaN, self).__hash__()",
    ".sympy.core.numbers.py@@NaN._as_mpf_val": "def _as_mpf_val(self, prec):\n    return _mpf_nan",
    ".sympy.core.numbers.py@@Float._hashable_content": "def _hashable_content(self):\n    return (self._mpf_, self._prec)",
    ".sympy.core.numbers.py@@Float.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    if isinstance(other, NumberSymbol):\n        return other.__ge__(self)\n    if other.is_real and other.is_number:\n        other = other.evalf()\n    if isinstance(other, Number) and other is not S.NaN:\n        return _sympify(bool(mlib.mpf_lt(self._mpf_, other._as_mpf_val(self._prec))))\n    return Expr.__lt__(self, other)",
    ".sympy.core.numbers.py@@Number._eval_is_finite": "def _eval_is_finite(self):\n    return True",
    ".sympy.core.add.py@@Add._eval_is_imaginary": "def _eval_is_imaginary(self):\n    nz = []\n    im_I = []\n    for a in self.args:\n        if a.is_real:\n            if a.is_zero:\n                pass\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im_I.append(a * S.ImaginaryUnit)\n        elif (S.ImaginaryUnit * a).is_real:\n            im_I.append(a * S.ImaginaryUnit)\n        else:\n            return\n    if self.func(*nz).is_zero:\n        return fuzzy_not(self.func(*im_I).is_zero)\n    elif self.func(*nz).is_zero is False:\n        return False",
    ".sympy.core.expr.py@@Expr.__mul__": "def __mul__(self, other):\n    return Mul(self, other)",
    ".sympy.core.mul.py@@Mul.flatten": "def flatten(cls, seq):\n    from sympy.calculus.util import AccumBounds\n    rv = None\n    if len(seq) == 2:\n        a, b = seq\n        if b.is_Rational:\n            a, b = (b, a)\n        assert not a is S.One\n        if not a.is_zero and a.is_Rational:\n            r, b = b.as_coeff_Mul()\n            if b.is_Add:\n                if r is not S.One:\n                    rv = ([cls(a * r, b, evaluate=False)], [], None)\n                elif b.is_commutative:\n                    if a is S.One:\n                        rv = ([b], [], None)\n                    else:\n                        r, b = b.as_coeff_Add()\n                        bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n                        _addsort(bargs)\n                        ar = a * r\n                        if ar:\n                            bargs.insert(0, ar)\n                        bargs = [Add._from_args(bargs)]\n                        rv = (bargs, [], None)\n        if rv:\n            return rv\n    c_part = []\n    nc_part = []\n    nc_seq = []\n    coeff = S.One\n    c_powers = []\n    num_exp = []\n    neg1e = S.Zero\n    pnum_rat = {}\n    order_symbols = None\n    for o in seq:\n        if o.is_Order:\n            o, order_symbols = o.as_expr_variables(order_symbols)\n        if o.is_Mul:\n            if o.is_commutative:\n                seq.extend(o.args)\n            else:\n                for q in o.args:\n                    if q.is_commutative:\n                        seq.append(q)\n                    else:\n                        nc_seq.append(q)\n                seq.append(NC_Marker)\n            continue\n        elif o.is_Number:\n            if o is S.NaN or (coeff is S.ComplexInfinity and o is S.Zero):\n                return ([S.NaN], [], None)\n            elif coeff.is_Number:\n                coeff *= o\n                if coeff is S.NaN:\n                    return ([S.NaN], [], None)\n            continue\n        elif isinstance(o, AccumBounds):\n            coeff = o.__mul__(coeff)\n            continue\n        elif o is S.ComplexInfinity:\n            if not coeff:\n                return ([S.NaN], [], None)\n            if coeff is S.ComplexInfinity:\n                return ([S.ComplexInfinity], [], None)\n            coeff = S.ComplexInfinity\n            continue\n        elif o is S.ImaginaryUnit:\n            neg1e += S.Half\n            continue\n        elif o.is_commutative:\n            b, e = o.as_base_exp()\n            if o.is_Pow:\n                if b.is_Number:\n                    if e.is_Rational:\n                        if e.is_Integer:\n                            coeff *= Pow(b, e)\n                            continue\n                        elif e.is_negative:\n                            seq.append(Pow(b, e))\n                            continue\n                        elif b.is_negative:\n                            neg1e += e\n                            b = -b\n                        if b is not S.One:\n                            pnum_rat.setdefault(b, []).append(e)\n                        continue\n                    elif b.is_positive or e.is_integer:\n                        num_exp.append((b, e))\n                        continue\n                elif b is S.ImaginaryUnit and e.is_Rational:\n                    neg1e += e / 2\n                    continue\n            c_powers.append((b, e))\n        else:\n            if o is not NC_Marker:\n                nc_seq.append(o)\n            while nc_seq:\n                o = nc_seq.pop(0)\n                if not nc_part:\n                    nc_part.append(o)\n                    continue\n                o1 = nc_part.pop()\n                b1, e1 = o1.as_base_exp()\n                b2, e2 = o.as_base_exp()\n                new_exp = e1 + e2\n                if b1 == b2 and (not new_exp.is_Add):\n                    o12 = b1 ** new_exp\n                    if o12.is_commutative:\n                        seq.append(o12)\n                        continue\n                    else:\n                        nc_seq.insert(0, o12)\n                else:\n                    nc_part.append(o1)\n                    nc_part.append(o)\n\n    def _gather(c_powers):\n        common_b = {}\n        for b, e in c_powers:\n            co = e.as_coeff_Mul()\n            common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n        for b, d in common_b.items():\n            for di, li in d.items():\n                d[di] = Add(*li)\n        new_c_powers = []\n        for b, e in common_b.items():\n            new_c_powers.extend([(b, c * t) for t, c in e.items()])\n        return new_c_powers\n    c_powers = _gather(c_powers)\n    num_exp = _gather(num_exp)\n    for i in range(2):\n        new_c_powers = []\n        changed = False\n        for b, e in c_powers:\n            if e.is_zero:\n                continue\n            if e is S.One:\n                if b.is_Number:\n                    coeff *= b\n                    continue\n                p = b\n            if e is not S.One:\n                p = Pow(b, e)\n                if p.is_Pow and (not b.is_Pow):\n                    bi = b\n                    b, e = p.as_base_exp()\n                    if b != bi:\n                        changed = True\n            c_part.append(p)\n            new_c_powers.append((b, e))\n        if changed and len(set((b for b, e in new_c_powers))) != len(new_c_powers):\n            c_part = []\n            c_powers = _gather(new_c_powers)\n        else:\n            break\n    inv_exp_dict = {}\n    for b, e in num_exp:\n        inv_exp_dict.setdefault(e, []).append(b)\n    for e, b in inv_exp_dict.items():\n        inv_exp_dict[e] = cls(*b)\n    c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n    comb_e = {}\n    for b, e in pnum_rat.items():\n        comb_e.setdefault(Add(*e), []).append(b)\n    del pnum_rat\n    num_rat = []\n    for e, b in comb_e.items():\n        b = cls(*b)\n        if e.q == 1:\n            coeff *= Pow(b, e)\n            continue\n        if e.p > e.q:\n            e_i, ep = divmod(e.p, e.q)\n            coeff *= Pow(b, e_i)\n            e = Rational(ep, e.q)\n        num_rat.append((b, e))\n    del comb_e\n    pnew = defaultdict(list)\n    i = 0\n    while i < len(num_rat):\n        bi, ei = num_rat[i]\n        grow = []\n        for j in range(i + 1, len(num_rat)):\n            bj, ej = num_rat[j]\n            g = bi.gcd(bj)\n            if g is not S.One:\n                e = ei + ej\n                if e.q == 1:\n                    coeff *= Pow(g, e)\n                else:\n                    if e.p > e.q:\n                        e_i, ep = divmod(e.p, e.q)\n                        coeff *= Pow(g, e_i)\n                        e = Rational(ep, e.q)\n                    grow.append((g, e))\n                num_rat[j] = (bj / g, ej)\n                bi = bi / g\n                if bi is S.One:\n                    break\n        if bi is not S.One:\n            obj = Pow(bi, ei)\n            if obj.is_Number:\n                coeff *= obj\n            else:\n                for obj in Mul.make_args(obj):\n                    if obj.is_Number:\n                        coeff *= obj\n                    else:\n                        assert obj.is_Pow\n                        bi, ei = obj.args\n                        pnew[ei].append(bi)\n        num_rat.extend(grow)\n        i += 1\n    for e, b in pnew.items():\n        pnew[e] = cls(*b)\n    if neg1e:\n        p, q = neg1e.as_numer_denom()\n        n, p = divmod(p, q)\n        if n % 2:\n            coeff = -coeff\n        if q == 2:\n            c_part.append(S.ImaginaryUnit)\n        elif p:\n            neg1e = Rational(p, q)\n            for e, b in pnew.items():\n                if e == neg1e and b.is_positive:\n                    pnew[e] = -b\n                    break\n            else:\n                c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n    c_part.extend([Pow(b, e) for e, b in pnew.items()])\n    if coeff is S.Infinity or coeff is S.NegativeInfinity:\n\n        def _handle_for_oo(c_part, coeff_sign):\n            new_c_part = []\n            for t in c_part:\n                if t.is_positive:\n                    continue\n                if t.is_negative:\n                    coeff_sign *= -1\n                    continue\n                new_c_part.append(t)\n            return (new_c_part, coeff_sign)\n        c_part, coeff_sign = _handle_for_oo(c_part, 1)\n        nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n        coeff *= coeff_sign\n    if coeff is S.ComplexInfinity:\n        c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n        nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and c.is_real is not None)]\n    elif coeff is S.Zero:\n        if any((c.is_finite == False for c in c_part)):\n            return ([S.NaN], [], order_symbols)\n        return ([coeff], [], order_symbols)\n    _new = []\n    for i in c_part:\n        if i.is_Number:\n            coeff *= i\n        else:\n            _new.append(i)\n    c_part = _new\n    _mulsort(c_part)\n    if coeff is not S.One:\n        c_part.insert(0, coeff)\n    if not nc_part and len(c_part) == 2 and c_part[0].is_Number and c_part[1].is_Add:\n        coeff = c_part[0]\n        c_part = [Add(*[coeff * f for f in c_part[1].args])]\n    return (c_part, nc_part, order_symbols)",
    ".sympy.core.numbers.py@@Rational.__new__": "def __new__(cls, p, q=None, gcd=None):\n    if q is None:\n        if isinstance(p, Rational):\n            return p\n        if isinstance(p, string_types):\n            if p.count('/') > 1:\n                raise TypeError('invalid input: %s' % p)\n            pq = p.rsplit('/', 1)\n            if len(pq) == 2:\n                p, q = pq\n                fp = fractions.Fraction(p)\n                fq = fractions.Fraction(q)\n                f = fp / fq\n                return Rational(f.numerator, f.denominator, 1)\n            p = p.replace(' ', '')\n            try:\n                p = fractions.Fraction(p)\n            except ValueError:\n                pass\n        if not isinstance(p, string_types):\n            try:\n                if isinstance(p, fractions.Fraction):\n                    return Rational(p.numerator, p.denominator, 1)\n            except NameError:\n                pass\n            if isinstance(p, (float, Float)):\n                return Rational(*_as_integer_ratio(p))\n        if not isinstance(p, SYMPY_INTS + (Rational,)):\n            raise TypeError('invalid input: %s' % p)\n        q = q or S.One\n        gcd = 1\n    else:\n        p = Rational(p)\n        q = Rational(q)\n    if isinstance(q, Rational):\n        p *= q.q\n        q = q.p\n    if isinstance(p, Rational):\n        q *= p.q\n        p = p.p\n    if q == 0:\n        if p == 0:\n            if _errdict['divide']:\n                raise ValueError('Indeterminate 0/0')\n            else:\n                return S.NaN\n        return S.ComplexInfinity\n    if q < 0:\n        q = -q\n        p = -p\n    if not gcd:\n        gcd = igcd(abs(p), q)\n    if gcd > 1:\n        p //= gcd\n        q //= gcd\n    if q == 1:\n        return Integer(p)\n    if p == 1 and q == 2:\n        return S.Half\n    obj = Expr.__new__(cls)\n    obj.p = p\n    obj.q = q\n    return obj",
    ".sympy.core.numbers.py@@Integer.__mul__": "def __mul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p * other)\n        elif isinstance(other, Integer):\n            return Integer(self.p * other.p)\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, other.q, igcd(self.p, other.q))\n        return Rational.__mul__(self, other)\n    return Rational.__mul__(self, other)",
    ".sympy.core.expr.py@@Expr.as_base_exp": "def as_base_exp(self):\n    return (self, S.One)",
    ".sympy.core.mul.py@@Mul._gather": "def _gather(c_powers):\n    common_b = {}\n    for b, e in c_powers:\n        co = e.as_coeff_Mul()\n        common_b.setdefault(b, {}).setdefault(co[1], []).append(co[0])\n    for b, d in common_b.items():\n        for di, li in d.items():\n            d[di] = Add(*li)\n    new_c_powers = []\n    for b, e in common_b.items():\n        new_c_powers.extend([(b, c * t) for t, c in e.items()])\n    return new_c_powers",
    ".sympy.core.numbers.py@@Rational.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (self, S.One)",
    ".sympy.core.numbers.py@@Rational.as_numer_denom": "def as_numer_denom(self):\n    return (Integer(self.p), Integer(self.q))",
    ".sympy.core.numbers.py@@Integer.__divmod__": "def __divmod__(self, other):\n    from .containers import Tuple\n    if isinstance(other, Integer) and global_evaluate[0]:\n        return Tuple(*divmod(self.p, other.p))\n    else:\n        return Number.__divmod__(self, other)",
    ".sympy.core.containers.py@@Tuple.__new__": "def __new__(cls, *args):\n    args = [sympify(arg) for arg in args]\n    obj = Basic.__new__(cls, *args)\n    return obj",
    ".sympy.core.containers.py@@Tuple.__iter__": "def __iter__(self):\n    return iter(self.args)",
    ".sympy.core.numbers.py@@Integer.__mod__": "def __mod__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, integer_types):\n            return Integer(self.p % other)\n        elif isinstance(other, Integer):\n            return Integer(self.p % other.p)\n        return Rational.__mod__(self, other)\n    return Rational.__mod__(self, other)",
    ".sympy.core.mul.py@@_mulsort": "def _mulsort(args):\n    args.sort(key=_args_sortkey)",
    ".sympy.core.basic.py@@Basic.compare": "def compare(self, other):\n    if self is other:\n        return 0\n    n1 = self.__class__\n    n2 = other.__class__\n    c = (n1 > n2) - (n1 < n2)\n    if c:\n        return c\n    st = self._hashable_content()\n    ot = other._hashable_content()\n    c = (len(st) > len(ot)) - (len(st) < len(ot))\n    if c:\n        return c\n    for l, r in zip(st, ot):\n        l = Basic(*l) if isinstance(l, frozenset) else l\n        r = Basic(*r) if isinstance(r, frozenset) else r\n        if isinstance(l, Basic):\n            c = l.compare(r)\n        else:\n            c = (l > r) - (l < r)\n        if c:\n            return c\n    return 0",
    ".sympy.core.core.py@@BasicMeta.__gt__": "def __gt__(cls, other):\n    if cls.__cmp__(other) == 1:\n        return True\n    return False",
    ".sympy.core.core.py@@BasicMeta.__cmp__": "def __cmp__(cls, other):\n    if not isinstance(other, BasicMeta):\n        return -1\n    n1 = cls.__name__\n    n2 = other.__name__\n    if n1 == n2:\n        return 0\n    UNKNOWN = len(ordering_of_classes) + 1\n    try:\n        i1 = ordering_of_classes.index(n1)\n    except ValueError:\n        i1 = UNKNOWN\n    try:\n        i2 = ordering_of_classes.index(n2)\n    except ValueError:\n        i2 = UNKNOWN\n    if i1 == UNKNOWN and i2 == UNKNOWN:\n        return (n1 > n2) - (n1 < n2)\n    return (i1 > i2) - (i1 < i2)",
    ".sympy.core.core.py@@BasicMeta.__lt__": "def __lt__(cls, other):\n    if cls.__cmp__(other) == -1:\n        return True\n    return False",
    ".sympy.core.mul.py@@Mul._eval_is_real": "def _eval_is_real(self):\n    return self._eval_real_imag(True)",
    ".sympy.core.mul.py@@Mul._eval_real_imag": "def _eval_real_imag(self, real):\n    zero = one_neither = False\n    for t in self.args:\n        if not t.is_complex:\n            return t.is_complex\n        elif t.is_imaginary:\n            real = not real\n        elif t.is_real:\n            if not zero:\n                z = t.is_zero\n                if not z and zero is False:\n                    zero = z\n                elif z:\n                    if all((a.is_finite for a in self.args)):\n                        return True\n                    return\n        elif t.is_real is False:\n            if one_neither:\n                return\n            one_neither = True\n        else:\n            return\n    if one_neither:\n        if real:\n            return zero\n    elif zero is False:\n        return real\n    elif real:\n        return real",
    ".sympy.core.logic.py@@_fuzzy_group": "def _fuzzy_group(args, quick_exit=False):\n    saw_other = False\n    for a in args:\n        if a is True:\n            continue\n        if a is None:\n            return\n        if quick_exit and saw_other:\n            return\n        saw_other = True\n    return not saw_other",
    ".sympy.core.mul.py@@Mul._eval_is_odd": "def _eval_is_odd(self):\n    is_integer = self.is_integer\n    if is_integer:\n        r, acc = (True, 1)\n        for t in self.args:\n            if not t.is_integer:\n                return None\n            elif t.is_even:\n                r = False\n            elif t.is_integer:\n                if r is False:\n                    pass\n                elif acc != 1 and (acc + t).is_odd:\n                    r = False\n                elif t.is_odd is None:\n                    r = None\n            acc = t\n        return r\n    elif is_integer is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_integer": "def _eval_is_integer(self):\n    is_rational = self.is_rational\n    if is_rational:\n        n, d = self.as_numer_denom()\n        if d is S.One:\n            return True\n        elif d is S(2):\n            return n.is_even\n    elif is_rational is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_rational": "def _eval_is_rational(self):\n    r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        return self.is_zero",
    ".sympy.core.mul.py@@Mul._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all(((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others)):\n                return True\n            return\n        if a is None:\n            return\n    return False",
    ".sympy.core.mul.py@@Mul._eval_is_hermitian": "def _eval_is_hermitian(self):\n    return self._eval_herm_antiherm(True)",
    ".sympy.core.mul.py@@Mul._eval_herm_antiherm": "def _eval_herm_antiherm(self, real):\n    one_nc = zero = one_neither = False\n    for t in self.args:\n        if not t.is_commutative:\n            if one_nc:\n                return\n            one_nc = True\n        if t.is_antihermitian:\n            real = not real\n        elif t.is_hermitian:\n            if not zero:\n                z = t.is_zero\n                if not z and zero is False:\n                    zero = z\n                elif z:\n                    if all((a.is_finite for a in self.args)):\n                        return True\n                    return\n        elif t.is_hermitian is False:\n            if one_neither:\n                return\n            one_neither = True\n        else:\n            return\n    if one_neither:\n        if real:\n            return zero\n    elif zero is False or real:\n        return real",
    ".sympy.core.mul.py@@Mul._eval_is_even": "def _eval_is_even(self):\n    is_integer = self.is_integer\n    if is_integer:\n        return fuzzy_not(self.is_odd)\n    elif is_integer is False:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_zero": "def _eval_is_zero(self):\n    zero = infinite = False\n    for a in self.args:\n        z = a.is_zero\n        if z:\n            if infinite:\n                return\n            zero = True\n        else:\n            if not a.is_finite:\n                if zero:\n                    return\n                infinite = True\n            if zero is False and z is None:\n                zero = None\n    return zero",
    ".sympy.core.mul.py@@Mul._eval_is_prime": "def _eval_is_prime(self):\n    if self.is_number:\n        '\\n        If input is a number that is not completely simplified.\\n        e.g. Mul(sqrt(3), sqrt(3), evaluate=False)\\n        So we manually evaluate it and return whether that is prime or not.\\n        '\n        r = S.One\n        for arg in self.args:\n            r *= arg\n        return r.is_prime\n    if self.is_integer and self.is_positive:\n        '\\n        Here we count the number of arguments that have a minimum value\\n        greater than two.\\n        If there are more than one of such a symbol then the result is not prime.\\n        Else, the result cannot be determined.\\n        '\n        number_of_args = 0\n        for arg in self.args:\n            if (arg - 1).is_positive:\n                number_of_args += 1\n        if number_of_args > 1:\n            return False",
    ".sympy.core.mul.py@@Mul._eval_is_positive": "def _eval_is_positive(self):\n    return self._eval_pos_neg(1)",
    ".sympy.core.mul.py@@Mul._eval_pos_neg": "def _eval_pos_neg(self, sign):\n    saw_NON = saw_NOT = False\n    for t in self.args:\n        if t.is_positive:\n            continue\n        elif t.is_negative:\n            sign = -sign\n        elif t.is_zero:\n            if all((a.is_finite for a in self.args)):\n                return False\n            return\n        elif t.is_nonpositive:\n            sign = -sign\n            saw_NON = True\n        elif t.is_nonnegative:\n            saw_NON = True\n        elif t.is_positive is False:\n            sign = -sign\n            if saw_NOT:\n                return\n            saw_NOT = True\n        elif t.is_negative is False:\n            if saw_NOT:\n                return\n            saw_NOT = True\n        else:\n            return\n    if sign == 1 and saw_NON is False and (saw_NOT is False):\n        return True\n    if sign < 0:\n        return False",
    ".sympy.core.mul.py@@Mul._eval_is_imaginary": "def _eval_is_imaginary(self):\n    z = self.is_zero\n    if z:\n        return False\n    elif z is False:\n        return self._eval_real_imag(False)",
    ".sympy.core.mul.py@@Mul._eval_is_antihermitian": "def _eval_is_antihermitian(self):\n    z = self.is_zero\n    if z:\n        return False\n    elif z is False:\n        return self._eval_herm_antiherm(False)",
    ".sympy.core.mul.py@@Mul._eval_is_negative": "def _eval_is_negative(self):\n    if self.args[0] == -1:\n        return (-self).is_positive\n    return self._eval_pos_neg(-1)",
    ".sympy.core.mul.py@@Mul._eval_is_algebraic": "def _eval_is_algebraic(self):\n    r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)\n    if r:\n        return r\n    elif r is False:\n        return self.is_zero",
    ".sympy.core.mul.py@@Mul._eval_is_infinite": "def _eval_is_infinite(self):\n    if any((a.is_infinite for a in self.args)):\n        if any((a.is_zero for a in self.args)):\n            return S.NaN.is_infinite\n        if any((a.is_zero is None for a in self.args)):\n            return None\n        return True",
    ".sympy.core.add.py@@Add._eval_is_irrational": "def _eval_is_irrational(self):\n    for t in self.args:\n        a = t.is_irrational\n        if a:\n            others = list(self.args)\n            others.remove(t)\n            if all((x.is_rational is True for x in others)):\n                return True\n            return None\n        if a is None:\n            return\n    return False",
    ".sympy.core.add.py@@Add._eval_is_zero": "def _eval_is_zero(self):\n    if self.is_commutative is False:\n        return\n    nz = []\n    z = 0\n    im_or_z = False\n    im = False\n    for a in self.args:\n        if a.is_real:\n            if a.is_zero:\n                z += 1\n            elif a.is_zero is False:\n                nz.append(a)\n            else:\n                return\n        elif a.is_imaginary:\n            im = True\n        elif (S.ImaginaryUnit * a).is_real:\n            im_or_z = True\n        else:\n            return\n    if z == len(self.args):\n        return True\n    if self.func(*nz).is_zero:\n        if not im_or_z and (not im):\n            return True\n        if im and (not im_or_z):\n            return False\n    if self.func(*nz).is_zero is False:\n        return False",
    ".sympy.core.add.py@@Add._eval_is_positive": "def _eval_is_positive(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if self.is_number:\n        return super(Add, self)._eval_is_positive()\n    c, a = self.as_coeff_Add()\n    if not c.is_zero:\n        v = _monotonic_sign(a)\n        if v is not None:\n            s = v + c\n            if s.is_positive and a.is_nonnegative:\n                return True\n            if len(self.free_symbols) == 1:\n                v = _monotonic_sign(self)\n                if v is not None and v.is_positive:\n                    return True\n    pos = nonneg = nonpos = unknown_sign = False\n    saw_INF = set()\n    args = [a for a in self.args if not a.is_zero]\n    if not args:\n        return False\n    for a in args:\n        ispos = a.is_positive\n        infinite = a.is_infinite\n        if infinite:\n            saw_INF.add(fuzzy_or((ispos, a.is_nonnegative)))\n            if True in saw_INF and False in saw_INF:\n                return\n        if ispos:\n            pos = True\n            continue\n        elif a.is_nonnegative:\n            nonneg = True\n            continue\n        elif a.is_nonpositive:\n            nonpos = True\n            continue\n        if infinite is None:\n            return\n        unknown_sign = True\n    if saw_INF:\n        if len(saw_INF) > 1:\n            return\n        return saw_INF.pop()\n    elif unknown_sign:\n        return\n    elif not nonpos and (not nonneg) and pos:\n        return True\n    elif not nonpos and pos:\n        return True\n    elif not pos and (not nonneg):\n        return False",
    ".sympy.core.add.py@@Add._eval_is_nonnegative": "def _eval_is_nonnegative(self):\n    from sympy.core.exprtools import _monotonic_sign\n    if not self.is_number:\n        c, a = self.as_coeff_Add()\n        if not c.is_zero and a.is_nonnegative:\n            v = _monotonic_sign(a)\n            if v is not None:\n                s = v + c\n                if s.is_nonnegative:\n                    return True\n                if len(self.free_symbols) == 1:\n                    v = _monotonic_sign(self)\n                    if v is not None and v.is_nonnegative:\n                        return True",
    ".sympy.core.add.py@@Add._eval_is_odd": "def _eval_is_odd(self):\n    l = [f for f in self.args if not f.is_even is True]\n    if not l:\n        return False\n    if l[0].is_odd:\n        return self._new_rawargs(*l[1:]).is_even",
    ".sympy.core.numbers.py@@Integer._eval_is_odd": "def _eval_is_odd(self):\n    return bool(self.p % 2)",
    ".sympy.logic.boolalg.py@@Boolean.__invert__": "def __invert__(self):\n    return Not(self)",
    ".sympy.logic.boolalg.py@@Not.eval": "def eval(cls, arg):\n    from sympy import Equality, GreaterThan, LessThan, StrictGreaterThan, StrictLessThan, Unequality\n    if isinstance(arg, Number) or arg in (True, False):\n        return false if arg else true\n    if arg.is_Not:\n        return arg.args[0]\n    if isinstance(arg, Equality):\n        return Unequality(*arg.args)\n    if isinstance(arg, Unequality):\n        return Equality(*arg.args)\n    if isinstance(arg, StrictLessThan):\n        return GreaterThan(*arg.args)\n    if isinstance(arg, StrictGreaterThan):\n        return LessThan(*arg.args)\n    if isinstance(arg, LessThan):\n        return StrictGreaterThan(*arg.args)\n    if isinstance(arg, GreaterThan):\n        return StrictLessThan(*arg.args)",
    ".sympy.core.relational.py@@StrictGreaterThan._eval_relation": "def _eval_relation(cls, lhs, rhs):\n    return _sympify(lhs.__gt__(rhs))",
    ".sympy.core.relational.py@@StrictLessThan._eval_relation": "def _eval_relation(cls, lhs, rhs):\n    return _sympify(lhs.__lt__(rhs))",
    ".sympy.core.expr.py@@Expr.__lt__": "def __lt__(self, other):\n    from sympy import StrictLessThan\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    for me in (self, other):\n        if me.is_complex and me.is_real is False or me.has(S.ComplexInfinity):\n            raise TypeError('Invalid comparison of complex %s' % me)\n        if me is S.NaN:\n            raise TypeError('Invalid NaN comparison')\n    if self.is_real or other.is_real:\n        dif = self - other\n        if dif.is_negative is not None and dif.is_negative is not dif.is_nonnegative:\n            return sympify(dif.is_negative)\n    return StrictLessThan(self, other, evaluate=False)",
    ".sympy.core.expr.py@@Expr.sort_key": "def sort_key(self, order=None):\n    coeff, expr = self.as_coeff_Mul()\n    if expr.is_Pow:\n        expr, exp = expr.args\n    else:\n        expr, exp = (expr, S.One)\n    if expr.is_Dummy:\n        args = (expr.sort_key(),)\n    elif expr.is_Atom:\n        args = (str(expr),)\n    else:\n        if expr.is_Add:\n            args = expr.as_ordered_terms(order=order)\n        elif expr.is_Mul:\n            args = expr.as_ordered_factors(order=order)\n        else:\n            args = expr.args\n        args = tuple([default_sort_key(arg, order=order) for arg in args])\n    args = (len(args), tuple(args))\n    exp = exp.sort_key(order=order)\n    return (expr.class_key(), args, exp, coeff)",
    ".sympy.core.expr.py@@Expr.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    return (S.One, self)",
    ".sympy.core.basic.py@@Basic.class_key": "def class_key(cls):\n    return (5, 0, cls.__name__)",
    ".sympy.core.function.py@@Application.eval": "def eval(cls, *args):\n    return",
    ".sympy.core.compatibility.py@@is_sequence": "def is_sequence(i, include=None):\n    return hasattr(i, '__getitem__') and iterable(i) or (bool(include) and isinstance(i, include))",
    ".sympy.core.singleton.py@@Singleton.__call__": "def __call__(self, *args, **kwargs):\n    if self not in Singleton._instances:\n        Singleton._instances[self] = super(Singleton, self).__call__(*args, **kwargs)\n    return Singleton._instances[self]\n\n    def __getnewargs__(self):\n        return ()\n    self.__getnewargs__ = __getnewargs__",
    ".sympy.sets.sets.py@@FiniteSet._hashable_content": "def _hashable_content(self):\n    return (self._elements,)",
    ".sympy.sets.sets.py@@Union._contains": "def _contains(self, other):\n    return Or(*[set.contains(other) for set in self.args])",
    ".sympy.core.add.py@@Add.as_numer_denom": "def as_numer_denom(self):\n    content, expr = self.primitive()\n    ncon, dcon = content.as_numer_denom()\n    nd = defaultdict(list)\n    for f in expr.args:\n        ni, di = f.as_numer_denom()\n        nd[di].append(ni)\n    if S.Zero in nd:\n        n = nd.pop(S.Zero)\n        assert len(n) == 1\n        n = n[0]\n        nd[S.One].append(n / S.Zero)\n    if len(nd) == 1:\n        d, n = nd.popitem()\n        return (self.func(*[_keep_coeff(ncon, ni) for ni in n]), _keep_coeff(dcon, d))\n    for d, n in nd.items():\n        if len(n) == 1:\n            nd[d] = n[0]\n        else:\n            nd[d] = self.func(*n)\n    denoms, numers = [list(i) for i in zip(*iter(nd.items()))]\n    n, d = (self.func(*[Mul(*denoms[:i] + [numers[i]] + denoms[i + 1:]) for i in range(len(numers))]), Mul(*denoms))\n    return (_keep_coeff(ncon, n), _keep_coeff(dcon, d))",
    ".sympy.core.add.py@@Add.primitive": "def primitive(self):\n    terms = []\n    inf = False\n    for a in self.args:\n        c, m = a.as_coeff_Mul()\n        if not c.is_Rational:\n            c = S.One\n            m = a\n        inf = inf or m is S.ComplexInfinity\n        terms.append((c.p, c.q, m))\n    if not inf:\n        ngcd = reduce(igcd, [t[0] for t in terms], 0)\n        dlcm = reduce(ilcm, [t[1] for t in terms], 1)\n    else:\n        ngcd = reduce(igcd, [t[0] for t in terms if t[1]], 0)\n        dlcm = reduce(ilcm, [t[1] for t in terms if t[1]], 1)\n    if ngcd == dlcm == 1:\n        return (S.One, self)\n    if not inf:\n        for i, (p, q, term) in enumerate(terms):\n            terms[i] = _keep_coeff(Rational(p // ngcd * (dlcm // q)), term)\n    else:\n        for i, (p, q, term) in enumerate(terms):\n            if q:\n                terms[i] = _keep_coeff(Rational(p // ngcd * (dlcm // q)), term)\n            else:\n                terms[i] = _keep_coeff(Rational(p, q), term)\n    if terms[0].is_Number or terms[0] is S.ComplexInfinity:\n        c = terms.pop(0)\n    else:\n        c = None\n    _addsort(terms)\n    if c:\n        terms.insert(0, c)\n    return (Rational(ngcd, dlcm), self._new_rawargs(*terms))",
    ".sympy.core.numbers.py@@igcd": "def igcd(*args):\n    if len(args) < 2:\n        raise TypeError('igcd() takes at least 2 arguments (%s given)' % len(args))\n    if 1 in args:\n        a = 1\n        k = 0\n    else:\n        a = abs(as_int(args[0]))\n        k = 1\n    if a != 1:\n        while k < len(args):\n            b = args[k]\n            k += 1\n            try:\n                a = _gcdcache[a, b]\n            except KeyError:\n                b = as_int(b)\n                if not b:\n                    continue\n                if b == 1:\n                    a = 1\n                    break\n                if b < 0:\n                    b = -b\n                t = (a, b)\n                while b:\n                    a, b = (b, a % b)\n                _gcdcache[t] = _gcdcache[t[1], t[0]] = a\n    while k < len(args):\n        ok = as_int(args[k])\n        k += 1\n    return a",
    ".sympy.core.compatibility.py@@as_int": "def as_int(n):\n    try:\n        result = int(n)\n        if result != n:\n            raise TypeError\n    except TypeError:\n        raise ValueError('%s is not an integer' % (n,))\n    return result",
    ".sympy.core.numbers.py@@ilcm": "def ilcm(*args):\n    if len(args) < 2:\n        raise TypeError('ilcm() takes at least 2 arguments (%s given)' % len(args))\n    if 0 in args:\n        return 0\n    a = args[0]\n    for b in args[1:]:\n        a = a * b // igcd(a, b)\n    return a",
    ".sympy.core.numbers.py@@Integer.as_numer_denom": "def as_numer_denom(self):\n    return (self, S.One)",
    ".sympy.core.mul.py@@_keep_coeff": "def _keep_coeff(coeff, factors, clear=True, sign=False):\n    if not coeff.is_Number:\n        if factors.is_Number:\n            factors, coeff = (coeff, factors)\n        else:\n            return coeff * factors\n    if coeff is S.One:\n        return factors\n    elif coeff is S.NegativeOne and (not sign):\n        return -factors\n    elif factors.is_Add:\n        if not clear and coeff.is_Rational and (coeff.q != 1):\n            q = S(coeff.q)\n            for i in factors.args:\n                c, t = i.as_coeff_Mul()\n                r = c / q\n                if r == int(r):\n                    return coeff * factors\n        return Mul._from_args((coeff, factors))\n    elif factors.is_Mul:\n        margs = list(factors.args)\n        if margs[0].is_Number:\n            margs[0] *= coeff\n            if margs[0] == 1:\n                margs.pop(0)\n        else:\n            margs.insert(0, coeff)\n        return Mul._from_args(margs)\n    else:\n        return coeff * factors",
    ".sympy.simplify.simplify.py@@signsimp": "def signsimp(expr, evaluate=None):\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    expr = sympify(expr)\n    if not isinstance(expr, Expr) or expr.is_Atom:\n        return expr\n    e = sub_post(sub_pre(expr))\n    if not isinstance(e, Expr) or e.is_Atom:\n        return e\n    if e.is_Add:\n        return e.func(*[signsimp(a) for a in e.args])\n    if evaluate:\n        e = e.xreplace({m: --m for m in e.atoms(Mul) if --m != m})\n    return e",
    ".sympy.simplify.cse_opts.py@@sub_pre": "def sub_pre(e):\n    reps = [a for a in e.atoms(Add) if a.could_extract_minus_sign()]\n    reps.sort(key=default_sort_key)\n    e = e.xreplace(dict(((a, Mul._from_args([S.NegativeOne, -a])) for a in reps)))\n    if isinstance(e, Basic):\n        negs = {}\n        for a in sorted(e.atoms(Add), key=default_sort_key):\n            if a in reps or a.could_extract_minus_sign():\n                negs[a] = Mul._from_args([S.One, S.NegativeOne, -a])\n        e = e.xreplace(negs)\n    return e",
    ".sympy.core.basic.py@@Basic.atoms": "def atoms(self, *types):\n    if types:\n        types = tuple([t if isinstance(t, type) else type(t) for t in types])\n    else:\n        types = (Atom,)\n    result = set()\n    for expr in preorder_traversal(self):\n        if isinstance(expr, types):\n            result.add(expr)\n    return result",
    ".sympy.core.expr.py@@Expr.could_extract_minus_sign": "def could_extract_minus_sign(self):\n    negative_self = -self\n    self_has_minus = self.extract_multiplicatively(-1) is not None\n    negative_self_has_minus = negative_self.extract_multiplicatively(-1) is not None\n    if self_has_minus != negative_self_has_minus:\n        return self_has_minus\n    else:\n        if self.is_Add:\n            all_args = len(self.args)\n            negative_args = len([False for arg in self.args if arg.could_extract_minus_sign()])\n            positive_args = all_args - negative_args\n            if positive_args > negative_args:\n                return False\n            elif positive_args < negative_args:\n                return True\n        elif self.is_Mul:\n            num, den = self.as_numer_denom()\n            args = Mul.make_args(num) + Mul.make_args(den)\n            arg_signs = [arg.could_extract_minus_sign() for arg in args]\n            negative_args = list(filter(None, arg_signs))\n            return len(negative_args) % 2 == 1\n        return bool(self.sort_key() < negative_self.sort_key())",
    ".sympy.core.add.py@@Add.__neg__": "def __neg__(self):\n    return self.func(*[-t for t in self.args])",
    ".sympy.core.expr.py@@Expr.__neg__": "def __neg__(self):\n    return Mul(S.NegativeOne, self)",
    ".sympy.core.expr.py@@Expr.extract_multiplicatively": "def extract_multiplicatively(self, c):\n    c = sympify(c)\n    if self is S.NaN:\n        return None\n    if c is S.One:\n        return self\n    elif c == self:\n        return S.One\n    if c.is_Add:\n        cc, pc = c.primitive()\n        if cc is not S.One:\n            c = Mul(cc, pc, evaluate=False)\n    if c.is_Mul:\n        a, b = c.as_two_terms()\n        x = self.extract_multiplicatively(a)\n        if x is not None:\n            return x.extract_multiplicatively(b)\n    quotient = self / c\n    if self.is_Number:\n        if self is S.Infinity:\n            if c.is_positive:\n                return S.Infinity\n        elif self is S.NegativeInfinity:\n            if c.is_negative:\n                return S.Infinity\n            elif c.is_positive:\n                return S.NegativeInfinity\n        elif self is S.ComplexInfinity:\n            if not c.is_zero:\n                return S.ComplexInfinity\n        elif self.is_Integer:\n            if not quotient.is_Integer:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n        elif self.is_Rational:\n            if not quotient.is_Rational:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n        elif self.is_Float:\n            if not quotient.is_Float:\n                return None\n            elif self.is_positive and quotient.is_negative:\n                return None\n            else:\n                return quotient\n    elif self.is_NumberSymbol or self.is_Symbol or self is S.ImaginaryUnit:\n        if quotient.is_Mul and len(quotient.args) == 2:\n            if quotient.args[0].is_Integer and quotient.args[0].is_positive and (quotient.args[1] == self):\n                return quotient\n        elif quotient.is_Integer and c.is_Number:\n            return quotient\n    elif self.is_Add:\n        cs, ps = self.primitive()\n        if cs is not S.One:\n            return Mul(cs, ps, evaluate=False).extract_multiplicatively(c)\n        newargs = []\n        for arg in self.args:\n            newarg = arg.extract_multiplicatively(c)\n            if newarg is not None:\n                newargs.append(newarg)\n            else:\n                return None\n        return Add(*newargs)\n    elif self.is_Mul:\n        args = list(self.args)\n        for i, arg in enumerate(args):\n            newarg = arg.extract_multiplicatively(c)\n            if newarg is not None:\n                args[i] = newarg\n                return Mul(*args)\n    elif self.is_Pow:\n        if c.is_Pow and c.base == self.base:\n            new_exp = self.exp.extract_additively(c.exp)\n            if new_exp is not None:\n                return self.base ** new_exp\n        elif c == self.base:\n            new_exp = self.exp.extract_additively(1)\n            if new_exp is not None:\n                return self.base ** new_exp",
    ".sympy.core.expr.py@@Expr.__div__": "def __div__(self, other):\n    return Mul(self, Pow(other, S.NegativeOne))",
    ".sympy.core.power.py@@Pow.__new__": "def __new__(cls, b, e, evaluate=None):\n    if evaluate is None:\n        evaluate = global_evaluate[0]\n    from sympy.functions.elementary.exponential import exp_polar\n    b = _sympify(b)\n    e = _sympify(e)\n    if evaluate:\n        if e is S.Zero:\n            return S.One\n        elif e is S.One:\n            return b\n        elif (b.is_Symbol or b.is_number) and (e.is_Symbol or e.is_number) and e.is_integer and _coeff_isneg(b):\n            if e.is_even:\n                b = -b\n            elif e.is_odd:\n                return -Pow(-b, e)\n        if S.NaN in (b, e):\n            return S.NaN\n        elif b is S.One:\n            if abs(e).is_infinite:\n                return S.NaN\n            return S.One\n        else:\n            if not e.is_Atom and b is not S.Exp1 and (b.func is not exp_polar):\n                from sympy import numer, denom, log, sign, im, factor_terms\n                c, ex = factor_terms(e, sign=False).as_coeff_Mul()\n                den = denom(ex)\n                if den.func is log and den.args[0] == b:\n                    return S.Exp1 ** (c * numer(ex))\n                elif den.is_Add:\n                    s = sign(im(b))\n                    if s.is_Number and s and (den == log(-factor_terms(b, sign=False)) + s * S.ImaginaryUnit * S.Pi):\n                        return S.Exp1 ** (c * numer(ex))\n            obj = b._eval_power(e)\n            if obj is not None:\n                return obj\n    obj = Expr.__new__(cls, b, e)\n    obj.is_commutative = b.is_commutative and e.is_commutative\n    return obj",
    ".sympy.core.numbers.py@@NegativeOne.__neg__": "def __neg__():\n    return S.One",
    ".sympy.core.numbers.py@@NegativeOne.__abs__": "def __abs__():\n    return S.One",
    ".sympy.core.numbers.py@@One.__neg__": "def __neg__():\n    return S.NegativeOne",
    ".sympy.core.logic.py@@fuzzy_and": "def fuzzy_and(args):\n    rv = True\n    for ai in args:\n        ai = fuzzy_bool(ai)\n        if ai is False:\n            return False\n        if rv:\n            rv = ai\n    return rv",
    ".sympy.core.numbers.py@@Rational.__div__": "def __div__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, Integer):\n            if self.p and other.p == S.Zero:\n                return S.ComplexInfinity\n            else:\n                return Rational(self.p, self.q * other.p, igcd(self.p, other.p))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.q, self.q * other.p, igcd(self.p, other.p) * igcd(self.q, other.q))\n        elif isinstance(other, Float):\n            return self * (1 / other)\n        else:\n            return Number.__div__(self, other)\n    return Number.__div__(self, other)",
    ".sympy.core.mul.py@@Mul.as_coeff_Mul": "def as_coeff_Mul(self, rational=False):\n    coeff, args = (self.args[0], self.args[1:])\n    if coeff.is_Number:\n        if not rational or coeff.is_Rational:\n            if len(args) == 1:\n                return (coeff, args[0])\n            else:\n                return (coeff, self._new_rawargs(*args))\n        elif coeff.is_negative:\n            return (S.NegativeOne, self._new_rawargs(*(-coeff,) + args))\n    return (S.One, self)",
    ".sympy.core.expr.py@@Expr.as_ordered_terms": "def as_ordered_terms(self, order=None, data=False):\n    key, reverse = self._parse_order(order)\n    terms, gens = self.as_terms()\n    if not any((term.is_Order for term, _ in terms)):\n        ordered = sorted(terms, key=key, reverse=reverse)\n    else:\n        _terms, _order = ([], [])\n        for term, repr in terms:\n            if not term.is_Order:\n                _terms.append((term, repr))\n            else:\n                _order.append((term, repr))\n        ordered = sorted(_terms, key=key, reverse=True) + sorted(_order, key=key, reverse=True)\n    if data:\n        return (ordered, gens)\n    else:\n        return [term for term, _ in ordered]",
    ".sympy.core.expr.py@@Expr._parse_order": "def _parse_order(cls, order):\n    from sympy.polys.orderings import monomial_key\n    try:\n        reverse = order.startswith('rev-')\n    except AttributeError:\n        reverse = False\n    else:\n        if reverse:\n            order = order[4:]\n    monom_key = monomial_key(order)\n\n    def neg(monom):\n        result = []\n        for m in monom:\n            if isinstance(m, tuple):\n                result.append(neg(m))\n            else:\n                result.append(-m)\n        return tuple(result)\n\n    def key(term):\n        _, ((re, im), monom, ncpart) = term\n        monom = neg(monom_key(monom))\n        ncpart = tuple([e.sort_key(order=order) for e in ncpart])\n        coeff = ((bool(im), im), (re, im))\n        return (monom, ncpart, coeff)\n    return (key, reverse)",
    ".sympy.polys.orderings.py@@monomial_key": "def monomial_key(order=None, gens=None):\n    if order is None:\n        order = lex\n    if isinstance(order, Symbol):\n        order = str(order)\n    if isinstance(order, str):\n        try:\n            order = _monomial_key[order]\n        except KeyError:\n            raise ValueError(\"supported monomial orderings are 'lex', 'grlex' and 'grevlex', got %r\" % order)\n    if hasattr(order, '__call__'):\n        if gens is not None:\n\n            def _order(expr):\n                return order(expr.as_poly(*gens).degree_list())\n            return _order\n        return order\n    else:\n        raise ValueError('monomial ordering specification must be a string or a callable, got %s' % order)",
    ".sympy.core.expr.py@@Expr.as_terms": "def as_terms(self):\n    from .add import Add\n    from .mul import Mul\n    from .exprtools import decompose_power\n    gens, terms = (set([]), [])\n    for term in Add.make_args(self):\n        coeff, _term = term.as_coeff_Mul()\n        coeff = complex(coeff)\n        cpart, ncpart = ({}, [])\n        if _term is not S.One:\n            for factor in Mul.make_args(_term):\n                if factor.is_number:\n                    try:\n                        coeff *= complex(factor)\n                    except TypeError:\n                        pass\n                    else:\n                        continue\n                if factor.is_commutative:\n                    base, exp = decompose_power(factor)\n                    cpart[base] = exp\n                    gens.add(base)\n                else:\n                    ncpart.append(factor)\n        coeff = (coeff.real, coeff.imag)\n        ncpart = tuple(ncpart)\n        terms.append((term, (coeff, cpart, ncpart)))\n    gens = sorted(gens, key=default_sort_key)\n    k, indices = (len(gens), {})\n    for i, g in enumerate(gens):\n        indices[g] = i\n    result = []\n    for term, (coeff, cpart, ncpart) in terms:\n        monom = [0] * k\n        for base, exp in cpart.items():\n            monom[indices[base]] = exp\n        result.append((term, (coeff, tuple(monom), ncpart)))\n    return (result, gens)",
    ".sympy.core.expr.py@@Expr.__complex__": "def __complex__(self):\n    result = self.evalf()\n    re, im = result.as_real_imag()\n    return complex(float(re), float(im))",
    ".sympy.core.numbers.py@@Number.__float__": "def __float__(self):\n    return mlib.to_float(self._as_mpf_val(53))",
    ".sympy.core.exprtools.py@@decompose_power": "def decompose_power(expr):\n    base, exp = expr.as_base_exp()\n    if exp.is_Number:\n        if exp.is_Rational:\n            if not exp.is_Integer:\n                base = Pow(base, Rational(1, exp.q))\n            exp = exp.p\n        else:\n            base, exp = (expr, 1)\n    else:\n        exp, tail = exp.as_coeff_Mul(rational=True)\n        if exp is S.NegativeOne:\n            base, exp = (Pow(base, tail), -1)\n        elif exp is not S.One:\n            tail = _keep_coeff(Rational(1, exp.q), tail)\n            base, exp = (Pow(base, tail), exp.p)\n        else:\n            base, exp = (expr, 1)\n    return (base, exp)",
    ".sympy.core.expr.py@@Expr.key": "def key(term):\n    _, ((re, im), monom, ncpart) = term\n    monom = neg(monom_key(monom))\n    ncpart = tuple([e.sort_key(order=order) for e in ncpart])\n    coeff = ((bool(im), im), (re, im))\n    return (monom, ncpart, coeff)",
    ".sympy.polys.orderings.py@@LexOrder.__call__": "def __call__(self, monomial):\n    return monomial",
    ".sympy.core.expr.py@@Expr.neg": "def neg(monom):\n    result = []\n    for m in monom:\n        if isinstance(m, tuple):\n            result.append(neg(m))\n        else:\n            result.append(-m)\n    return tuple(result)",
    ".sympy.core.add.py@@Add.class_key": "def class_key(cls):\n    return (3, 1, cls.__name__)",
    ".sympy.core.basic.py@@Basic.xreplace": "def xreplace(self, rule):\n    value, _ = self._xreplace(rule)\n    return value",
    ".sympy.core.basic.py@@Basic._xreplace": "def _xreplace(self, rule):\n    if self in rule:\n        return (rule[self], True)\n    elif rule:\n        args = []\n        changed = False\n        for a in self.args:\n            try:\n                a_xr = a._xreplace(rule)\n                args.append(a_xr[0])\n                changed |= a_xr[1]\n            except AttributeError:\n                args.append(a)\n        args = tuple(args)\n        if changed:\n            return (self.func(*args), True)\n    return (self, False)",
    ".sympy.simplify.cse_opts.py@@sub_post": "def sub_post(e):\n    replacements = []\n    for node in preorder_traversal(e):\n        if isinstance(node, Mul) and node.args[0] is S.One and (node.args[1] is S.NegativeOne):\n            replacements.append((node, -Mul._from_args(node.args[2:])))\n    for node, replacement in replacements:\n        e = e.xreplace({node: replacement})\n    return e",
    ".sympy.simplify.simplify.py@@bottom_up": "def bottom_up(rv, F, atoms=False, nonbasic=False):\n    try:\n        if rv.args:\n            args = tuple([bottom_up(a, F, atoms, nonbasic) for a in rv.args])\n            if args != rv.args:\n                rv = rv.func(*args)\n            rv = F(rv)\n        elif atoms:\n            rv = F(rv)\n    except AttributeError:\n        if nonbasic:\n            try:\n                rv = F(rv)\n            except TypeError:\n                pass\n    return rv",
    ".sympy.core.expr.py@@Expr.normal": "def normal(self):\n    n, d = self.as_numer_denom()\n    if d is S.One:\n        return n\n    return n / d",
    ".sympy.simplify.powsimp.py@@powsimp": "def powsimp(expr, deep=False, combine='all', force=False, measure=count_ops):\n    from sympy.matrices.expressions.matexpr import MatrixSymbol\n\n    def recurse(arg, **kwargs):\n        _deep = kwargs.get('deep', deep)\n        _combine = kwargs.get('combine', combine)\n        _force = kwargs.get('force', force)\n        _measure = kwargs.get('measure', measure)\n        return powsimp(arg, _deep, _combine, _force, _measure)\n    expr = sympify(expr)\n    if not isinstance(expr, Basic) or isinstance(expr, MatrixSymbol) or (expr.is_Atom or expr in (exp_polar(0), exp_polar(1))):\n        return expr\n    if deep or expr.is_Add or (expr.is_Mul and _y not in expr.args):\n        expr = expr.func(*[recurse(w) for w in expr.args])\n    if expr.is_Pow:\n        return recurse(expr * _y, deep=False) / _y\n    if not expr.is_Mul:\n        return expr\n    if combine in ('exp', 'all'):\n        c_powers = defaultdict(list)\n        nc_part = []\n        newexpr = []\n        coeff = S.One\n        for term in expr.args:\n            if term.is_Rational:\n                coeff *= term\n                continue\n            if term.is_Pow:\n                term = _denest_pow(term)\n            if term.is_commutative:\n                b, e = term.as_base_exp()\n                if deep:\n                    b, e = [recurse(i) for i in [b, e]]\n                if b.is_Pow or b.func is exp:\n                    b, e = (b ** e, S.One)\n                c_powers[b].append(e)\n            else:\n                if nc_part:\n                    b1, e1 = nc_part[-1].as_base_exp()\n                    b2, e2 = term.as_base_exp()\n                    if b1 == b2 and e1.is_commutative and e2.is_commutative:\n                        nc_part[-1] = Pow(b1, Add(e1, e2))\n                        continue\n                nc_part.append(term)\n        for b, e in ordered(iter(c_powers.items())):\n            if b and b.is_Number and (not all((ei.is_Number for ei in e))) and (coeff is not S.One) and (b not in (S.One, S.NegativeOne)):\n                m = multiplicity(abs(b), abs(coeff))\n                if m:\n                    e.append(m)\n                    coeff /= b ** m\n            c_powers[b] = Add(*e)\n        if coeff is not S.One:\n            if coeff in c_powers:\n                c_powers[coeff] += S.One\n            else:\n                c_powers[coeff] = S.One\n        c_powers = dict(c_powers)\n        be = list(c_powers.items())\n        skip = set()\n        for b, e in be:\n            if b in skip:\n                continue\n            bpos = b.is_positive or b.is_polar\n            if bpos:\n                binv = 1 / b\n                if b != binv and binv in c_powers:\n                    if b.as_numer_denom()[0] is S.One:\n                        c_powers.pop(b)\n                        c_powers[binv] -= e\n                    else:\n                        skip.add(binv)\n                        e = c_powers.pop(binv)\n                        c_powers[b] -= e\n        be = list(c_powers.items())\n        _n = S.NegativeOne\n        for i, (b, e) in enumerate(be):\n            if ((-b).is_Symbol or b.is_Add) and -b in c_powers:\n                if b.is_positive in (0, 1) or e.is_integer:\n                    c_powers[-b] += c_powers.pop(b)\n                    if _n in c_powers:\n                        c_powers[_n] += e\n                    else:\n                        c_powers[_n] = e\n        c_powers = [(b, e) for b, e in c_powers.items() if e]\n\n        def ratq(x):\n            return bkey(x)[0][1]\n\n        def bkey(b, e=None):\n            if e is not None:\n                if e.is_Integer:\n                    return ((b, S.One), e)\n                elif e.is_Rational:\n                    return ((b, Integer(e.q)), Integer(e.p))\n                else:\n                    c, m = e.as_coeff_Mul(rational=True)\n                    if c is not S.One:\n                        if m.is_integer:\n                            return ((b, Integer(c.q)), m * Integer(c.p))\n                        return ((b ** m, Integer(c.q)), Integer(c.p))\n                    else:\n                        return ((b ** e, S.One), S.One)\n            else:\n                return bkey(*b.as_base_exp())\n\n        def update(b):\n            newe, r = divmod(common_b[b], b[1])\n            if not r:\n                common_b.pop(b)\n                if newe:\n                    for m in Mul.make_args(b[0] ** newe):\n                        b, e = bkey(m)\n                        if b not in common_b:\n                            common_b[b] = 0\n                        common_b[b] += e\n                        if b[1] != 1:\n                            bases.append(b)\n        common_b = {}\n        done = []\n        bases = []\n        for b, e in c_powers:\n            b, e = bkey(b, e)\n            if b in common_b.keys():\n                common_b[b] = common_b[b] + e\n            else:\n                common_b[b] = e\n            if b[1] != 1 and b[0].is_Mul:\n                bases.append(b)\n        c_powers = [(b, e) for b, e in common_b.items() if e]\n        bases.sort(key=default_sort_key)\n        bases.sort(key=measure, reverse=True)\n        for base in bases:\n            if base not in common_b:\n                continue\n            b, exponent = base\n            last = False\n            qlcm = 1\n            while True:\n                bstart = b\n                qstart = qlcm\n                bb = []\n                ee = []\n                for bi in Mul.make_args(b):\n                    bib, bie = bkey(bi)\n                    if bib not in common_b or common_b[bib] < bie:\n                        ee = bb = []\n                        break\n                    ee.append([bie, common_b[bib]])\n                    bb.append(bib)\n                if ee:\n                    min1 = ee[0][1] / ee[0][0]\n                    for i in range(len(ee)):\n                        rat = ee[i][1] / ee[i][0]\n                        if rat < 1:\n                            break\n                        min1 = min(min1, rat)\n                    else:\n                        for i in range(len(bb)):\n                            common_b[bb[i]] -= min1 * ee[i][0]\n                            update(bb[i])\n                        common_b[base] += min1 * qstart * exponent\n                if last or len(common_b) == 1 or all((k[1] == 1 for k in common_b)):\n                    break\n                qlcm = lcm([ratq(bi) for bi in Mul.make_args(bstart)])\n                if qlcm == 1:\n                    break\n                b = bstart ** qlcm\n                qlcm *= qstart\n                if all((ratq(bi) == 1 for bi in Mul.make_args(b))):\n                    last = True\n            b, q = base\n            done.append((b, common_b.pop(base) * Rational(1, q)))\n        c_powers = done\n        for (b, q), e in common_b.items():\n            if (b.is_Pow or b.func is exp) and q is not S.One and (not b.exp.is_Rational):\n                b, be = b.as_base_exp()\n                b = b ** (be / q)\n            else:\n                b = root(b, q)\n            c_powers.append((b, e))\n        check = len(c_powers)\n        c_powers = dict(c_powers)\n        assert len(c_powers) == check\n        newexpr = expr.func(*newexpr + [Pow(b, e) for b, e in c_powers.items()])\n        if combine == 'exp':\n            return expr.func(newexpr, expr.func(*nc_part))\n        else:\n            return recurse(expr.func(*nc_part), combine='base') * recurse(newexpr, combine='base')\n    elif combine == 'base':\n        c_powers = []\n        nc_part = []\n        for term in expr.args:\n            if term.is_commutative:\n                c_powers.append(list(term.as_base_exp()))\n            else:\n                nc_part.append(term)\n        for i in range(len(c_powers)):\n            b, e = c_powers[i]\n            if not (all((x.is_nonnegative for x in b.as_numer_denom())) or e.is_integer or force or b.is_polar):\n                continue\n            exp_c, exp_t = e.as_coeff_Mul(rational=True)\n            if exp_c is not S.One and exp_t is not S.One:\n                c_powers[i] = [Pow(b, exp_c), exp_t]\n        c_exp = defaultdict(list)\n        for b, e in c_powers:\n            if deep:\n                e = recurse(e)\n            c_exp[e].append(b)\n        del c_powers\n        c_powers = defaultdict(list)\n        for e in c_exp:\n            bases = c_exp[e]\n            if len(bases) == 1:\n                new_base = bases[0]\n            elif e.is_integer or force:\n                new_base = expr.func(*bases)\n            else:\n                unk = []\n                nonneg = []\n                neg = []\n                for bi in bases:\n                    if bi.is_negative:\n                        neg.append(bi)\n                    elif bi.is_nonnegative:\n                        nonneg.append(bi)\n                    elif bi.is_polar:\n                        nonneg.append(bi)\n                    else:\n                        unk.append(bi)\n                if len(unk) == 1 and (not neg) or (len(neg) == 1 and (not unk)):\n                    nonneg.extend(unk + neg)\n                    unk = neg = []\n                elif neg:\n                    israt = False\n                    if e.is_Rational:\n                        israt = True\n                    else:\n                        p, d = e.as_numer_denom()\n                        if p.is_integer and d.is_integer:\n                            israt = True\n                    if israt:\n                        neg = [-w for w in neg]\n                        unk.extend([S.NegativeOne] * len(neg))\n                    else:\n                        unk.extend(neg)\n                        neg = []\n                    del israt\n                for b in unk:\n                    c_powers[b].append(e)\n                new_base = expr.func(*nonneg + neg)\n\n                def _terms(e):\n                    if e.is_Add:\n                        return sum([_terms(ai) for ai in e.args])\n                    if e.is_Mul:\n                        return prod([_terms(mi) for mi in e.args])\n                    return 1\n                xnew_base = expand_mul(new_base, deep=False)\n                if len(Add.make_args(xnew_base)) < _terms(new_base):\n                    new_base = factor_terms(xnew_base)\n            c_powers[new_base].append(e)\n        c_part = [Pow(b, ei) for b, e in c_powers.items() for ei in e]\n        return expr.func(*c_part + nc_part)\n    else:\n        raise ValueError(\"combine must be one of ('all', 'exp', 'base').\")",
    ".sympy.sets.fancysets.py@@Naturals0._contains": "def _contains(self, other):\n    if not isinstance(other, Expr):\n        return S.false\n    elif other.is_integer and other.is_nonnegative:\n        return S.true\n    elif other.is_integer is False or other.is_nonnegative is False:\n        return S.false",
    ".sympy.core.function.py@@Function._should_evalf": "def _should_evalf(cls, arg):\n    from sympy.core.symbol import Wild\n    if arg.is_Float:\n        return arg._prec\n    if not arg.is_Add:\n        return -1\n    a, b = (Wild('a'), Wild('b'))\n    m = arg.match(a + b * S.ImaginaryUnit)\n    if not m or not (m[a].is_Float or m[b].is_Float):\n        return -1\n    l = [m[i]._prec for i in m if m[i].is_Float]\n    l.append(-1)\n    return max(l)",
    ".sympy.simplify.powsimp.py@@recurse": "def recurse(arg, **kwargs):\n    _deep = kwargs.get('deep', deep)\n    _combine = kwargs.get('combine', combine)\n    _force = kwargs.get('force', force)\n    _measure = kwargs.get('measure', measure)\n    return powsimp(arg, _deep, _combine, _force, _measure)",
    ".sympy.core.add.py@@Add.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    con, prim = self.func(*[_keep_coeff(*a.as_content_primitive(radical=radical, clear=clear)) for a in self.args]).primitive()\n    if not clear and (not con.is_Integer) and prim.is_Add:\n        con, d = con.as_numer_denom()\n        _p = prim / d\n        if any((a.as_coeff_Mul()[0].is_Integer for a in _p.args)):\n            prim = _p\n        else:\n            con /= d\n    if radical and prim.is_Add:\n        args = prim.args\n        rads = []\n        common_q = None\n        for m in args:\n            term_rads = defaultdict(list)\n            for ai in Mul.make_args(m):\n                if ai.is_Pow:\n                    b, e = ai.as_base_exp()\n                    if e.is_Rational and b.is_Integer:\n                        term_rads[e.q].append(abs(int(b)) ** e.p)\n            if not term_rads:\n                break\n            if common_q is None:\n                common_q = set(term_rads.keys())\n            else:\n                common_q = common_q & set(term_rads.keys())\n                if not common_q:\n                    break\n            rads.append(term_rads)\n        else:\n            for r in rads:\n                for q in list(r.keys()):\n                    if q not in common_q:\n                        r.pop(q)\n                for q in r:\n                    r[q] = prod(r[q])\n            G = []\n            for q in common_q:\n                g = reduce(igcd, [r[q] for r in rads], 0)\n                if g != 1:\n                    G.append(g ** Rational(1, q))\n            if G:\n                G = Mul(*G)\n                args = [ai / G for ai in args]\n                prim = G * prim.func(*args)\n    return (con, prim)",
    ".sympy.core.numbers.py@@Rational.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    if self:\n        if self.is_positive:\n            return (self, S.One)\n        return (-self, S.NegativeOne)\n    return (S.One, self)",
    ".sympy.core.expr.py@@Expr.as_content_primitive": "def as_content_primitive(self, radical=False, clear=True):\n    return (S.One, self)",
    ".sympy.polys.polytools.py@@cancel": "def cancel(f, *gens, **args):\n    from sympy.core.exprtools import factor_terms\n    from sympy.functions.elementary.piecewise import Piecewise\n    options.allowed_flags(args, ['polys'])\n    f = sympify(f)\n    if not isinstance(f, (tuple, Tuple)):\n        if f.is_Number or isinstance(f, Relational) or (not isinstance(f, Expr)):\n            return f\n        f = factor_terms(f, radical=True)\n        p, q = f.as_numer_denom()\n    elif len(f) == 2:\n        p, q = f\n    elif isinstance(f, Tuple):\n        return factor_terms(f)\n    else:\n        raise ValueError('unexpected argument: %s' % f)\n    try:\n        (F, G), opt = parallel_poly_from_expr((p, q), *gens, **args)\n    except PolificationFailed:\n        if not isinstance(f, (tuple, Tuple)):\n            return f\n        else:\n            return (S.One, p, q)\n    except PolynomialError as msg:\n        if f.is_commutative and (not f.has(Piecewise)):\n            raise PolynomialError(msg)\n        if f.is_Add or f.is_Mul:\n            sifted = sift(f.args, lambda x: x.is_commutative is True and (not x.has(Piecewise)))\n            c, nc = (sifted[True], sifted[False])\n            nc = [cancel(i) for i in nc]\n            return f.func(cancel(f.func._from_args(c)), *nc)\n        else:\n            reps = []\n            pot = preorder_traversal(f)\n            next(pot)\n            for e in pot:\n                if isinstance(e, (tuple, Tuple, BooleanAtom)):\n                    continue\n                try:\n                    reps.append((e, cancel(e)))\n                    pot.skip()\n                except NotImplementedError:\n                    pass\n            return f.xreplace(dict(reps))\n    c, P, Q = F.cancel(G)\n    if not isinstance(f, (tuple, Tuple)):\n        return c * (P.as_expr() / Q.as_expr())\n    elif not opt.polys:\n        return (c, P.as_expr(), Q.as_expr())\n    else:\n        return (c, P, Q)",
    ".sympy.polys.polyoptions.py@@allowed_flags": "def allowed_flags(args, flags):\n    flags = set(flags)\n    for arg in args.keys():\n        try:\n            if Options.__options__[arg].is_Flag and (not arg in flags):\n                raise FlagError(\"'%s' flag is not allowed in this context\" % arg)\n        except KeyError:\n            raise OptionError(\"'%s' is not a valid option\" % arg)",
    ".sympy.core.exprtools.py@@gcd_terms": "def gcd_terms(terms, isprimitive=False, clear=True, fraction=True):\n\n    def mask(terms):\n        args = [(a, []) if a.is_commutative else a.args_cnc() for a in terms]\n        reps = []\n        for i, (c, nc) in enumerate(args):\n            if nc:\n                nc = Mul._from_args(nc)\n                d = Dummy()\n                reps.append((d, nc))\n                c.append(d)\n                args[i] = Mul._from_args(c)\n            else:\n                args[i] = c\n        return (args, dict(reps))\n    isadd = isinstance(terms, Add)\n    addlike = isadd or (not isinstance(terms, Basic) and is_sequence(terms, include=set) and (not isinstance(terms, Dict)))\n    if addlike:\n        if isadd:\n            terms = list(terms.args)\n        else:\n            terms = sympify(terms)\n        terms, reps = mask(terms)\n        cont, numer, denom = _gcd_terms(terms, isprimitive, fraction)\n        numer = numer.xreplace(reps)\n        coeff, factors = cont.as_coeff_Mul()\n        if not clear:\n            c, _coeff = coeff.as_coeff_Mul()\n            if not c.is_Integer and (not clear) and numer.is_Add:\n                n, d = c.as_numer_denom()\n                _numer = numer / d\n                if any((a.as_coeff_Mul()[0].is_Integer for a in _numer.args)):\n                    numer = _numer\n                    coeff = n * _coeff\n        return _keep_coeff(coeff, factors * numer / denom, clear=clear)\n    if not isinstance(terms, Basic):\n        return terms\n    if terms.is_Atom:\n        return terms\n    if terms.is_Mul:\n        c, args = terms.as_coeff_mul()\n        return _keep_coeff(c, Mul(*[gcd_terms(i, isprimitive, clear, fraction) for i in args]), clear=clear)\n\n    def handle(a):\n        if not isinstance(a, Expr):\n            if isinstance(a, Basic):\n                return a.func(*[handle(i) for i in a.args])\n            return type(a)([handle(i) for i in a])\n        return gcd_terms(a, isprimitive, clear, fraction)\n    if isinstance(terms, Dict):\n        return Dict(*[(k, handle(v)) for k, v in terms.args])\n    return terms.func(*[handle(i) for i in terms.args])",
    ".sympy.core.exprtools.py@@mask": "def mask(terms):\n    args = [(a, []) if a.is_commutative else a.args_cnc() for a in terms]\n    reps = []\n    for i, (c, nc) in enumerate(args):\n        if nc:\n            nc = Mul._from_args(nc)\n            d = Dummy()\n            reps.append((d, nc))\n            c.append(d)\n            args[i] = Mul._from_args(c)\n        else:\n            args[i] = c\n    return (args, dict(reps))",
    ".sympy.core.exprtools.py@@_gcd_terms": "def _gcd_terms(terms, isprimitive=False, fraction=True):\n    if isinstance(terms, Basic) and (not isinstance(terms, Tuple)):\n        terms = Add.make_args(terms)\n    terms = list(map(Term, [t for t in terms if t]))\n    if len(terms) == 0:\n        return (S.Zero, S.Zero, S.One)\n    if len(terms) == 1:\n        cont = terms[0].coeff\n        numer = terms[0].numer.as_expr()\n        denom = terms[0].denom.as_expr()\n    else:\n        cont = terms[0]\n        for term in terms[1:]:\n            cont = cont.gcd(term)\n        for i, term in enumerate(terms):\n            terms[i] = term.quo(cont)\n        if fraction:\n            denom = terms[0].denom\n            for term in terms[1:]:\n                denom = denom.lcm(term.denom)\n            numers = []\n            for term in terms:\n                numer = term.numer.mul(denom.quo(term.denom))\n                numers.append(term.coeff * numer.as_expr())\n        else:\n            numers = [t.as_expr() for t in terms]\n            denom = Term(S(1)).numer\n        cont = cont.as_expr()\n        numer = Add(*numers)\n        denom = denom.as_expr()\n    if not isprimitive and numer.is_Add:\n        _cont, numer = numer.primitive()\n        cont *= _cont\n    return (cont, numer, denom)",
    ".sympy.core.exprtools.py@@Term.__init__": "def __init__(self, term, numer=None, denom=None):\n    if numer is None and denom is None:\n        if not term.is_commutative:\n            raise NonCommutativeExpression('commutative expression expected')\n        coeff, factors = term.as_coeff_mul()\n        numer, denom = (defaultdict(int), defaultdict(int))\n        for factor in factors:\n            base, exp = decompose_power(factor)\n            if base.is_Add:\n                cont, base = base.primitive()\n                coeff *= cont ** exp\n            if exp > 0:\n                numer[base] += exp\n            else:\n                denom[base] += -exp\n        numer = Factors(numer)\n        denom = Factors(denom)\n    else:\n        coeff = term\n        if numer is None:\n            numer = Factors()\n        if denom is None:\n            denom = Factors()\n    self.coeff = coeff\n    self.numer = numer\n    self.denom = denom",
    ".sympy.core.numbers.py@@Number.as_coeff_mul": "def as_coeff_mul(self, *deps, **kwargs):\n    if self.is_Rational or not kwargs.pop('rational', True):\n        return (self, tuple())\n    elif self.is_negative:\n        return (S.NegativeOne, (-self,))\n    return (S.One, (self,))",
    ".sympy.core.exprtools.py@@Factors.__init__": "def __init__(self, factors=None):\n    if isinstance(factors, (SYMPY_INTS, float)):\n        factors = S(factors)\n    if isinstance(factors, Factors):\n        factors = factors.factors.copy()\n    elif factors is None or factors is S.One:\n        factors = {}\n    elif factors is S.Zero or factors == 0:\n        factors = {S.Zero: S.One}\n    elif isinstance(factors, Number):\n        n = factors\n        factors = {}\n        if n < 0:\n            factors[S.NegativeOne] = S.One\n            n = -n\n        if n is not S.One:\n            if n.is_Float or n.is_Integer or n is S.Infinity:\n                factors[n] = S.One\n            elif n.is_Rational:\n                if n.p != 1:\n                    factors[Integer(n.p)] = S.One\n                factors[Integer(n.q)] = S.NegativeOne\n            else:\n                raise ValueError('Expected Float|Rational|Integer, not %s' % n)\n    elif isinstance(factors, Basic) and (not factors.args):\n        factors = {factors: S.One}\n    elif isinstance(factors, Expr):\n        c, nc = factors.args_cnc()\n        i = c.count(I)\n        for _ in range(i):\n            c.remove(I)\n        factors = dict(Mul._from_args(c).as_powers_dict())\n        if i:\n            factors[I] = S.One * i\n        if nc:\n            factors[Mul(*nc, evaluate=False)] = S.One\n    else:\n        factors = factors.copy()\n        handle = []\n        for k in factors:\n            if k is I or k in (-1, 1):\n                handle.append(k)\n        if handle:\n            i1 = S.One\n            for k in handle:\n                if not _isnumber(factors[k]):\n                    continue\n                i1 *= k ** factors.pop(k)\n            if i1 is not S.One:\n                for a in i1.args if i1.is_Mul else [i1]:\n                    if a is S.NegativeOne:\n                        factors[a] = S.One\n                    elif a is I:\n                        factors[I] = S.One\n                    elif a.is_Pow:\n                        if S.NegativeOne not in factors:\n                            factors[S.NegativeOne] = S.Zero\n                        factors[S.NegativeOne] += a.exp\n                    elif a == 1:\n                        factors[a] = S.One\n                    elif a == -1:\n                        factors[-a] = S.One\n                        factors[S.NegativeOne] = S.One\n                    else:\n                        raise ValueError('unexpected factor in i1: %s' % a)\n    self.factors = factors\n    try:\n        self.gens = frozenset(factors.keys())\n    except AttributeError:\n        raise TypeError('expecting Expr or dictionary')",
    ".sympy.core.expr.py@@Expr.as_coeff_mul": "def as_coeff_mul(self, *deps, **kwargs):\n    if deps:\n        if not self.has(*deps):\n            return (self, tuple())\n    return (S.One, (self,))",
    ".sympy.core.exprtools.py@@Term.gcd": "def gcd(self, other):\n    return Term(self.coeff.gcd(other.coeff), self.numer.gcd(other.numer), self.denom.gcd(other.denom))",
    ".sympy.core.numbers.py@@Rational.gcd": "def gcd(self, other):\n    if isinstance(other, Rational):\n        if other is S.Zero:\n            return other\n        return Rational(Integer(igcd(self.p, other.p)), Integer(ilcm(self.q, other.q)))\n    return Number.gcd(self, other)",
    ".sympy.core.exprtools.py@@Factors.gcd": "def gcd(self, other):\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if other.is_zero:\n            return Factors(self.factors)\n    factors = {}\n    for factor, exp in self.factors.items():\n        factor, exp = (sympify(factor), sympify(exp))\n        if factor in other.factors:\n            lt = (exp - other.factors[factor]).is_negative\n            if lt == True:\n                factors[factor] = exp\n            elif lt == False:\n                factors[factor] = other.factors[factor]\n    return Factors(factors)",
    ".sympy.core.exprtools.py@@Term.quo": "def quo(self, other):\n    return self.mul(other.inv())",
    ".sympy.core.exprtools.py@@Term.inv": "def inv(self):\n    return Term(1 / self.coeff, self.denom, self.numer)",
    ".sympy.core.expr.py@@Expr.__rdiv__": "def __rdiv__(self, other):\n    return Mul(other, Pow(self, S.NegativeOne))",
    ".sympy.core.exprtools.py@@Term.mul": "def mul(self, other):\n    coeff = self.coeff * other.coeff\n    numer = self.numer.mul(other.numer)\n    denom = self.denom.mul(other.denom)\n    numer, denom = numer.normal(denom)\n    return Term(coeff, numer, denom)",
    ".sympy.core.exprtools.py@@Factors.mul": "def mul(self, other):\n    if not isinstance(other, Factors):\n        other = Factors(other)\n    if any((f.is_zero for f in (self, other))):\n        return Factors(S.Zero)\n    factors = dict(self.factors)\n    for factor, exp in other.factors.items():\n        if factor in factors:\n            exp = factors[factor] + exp\n            if not exp:\n                del factors[factor]\n                continue\n        factors[factor] = exp\n    return Factors(factors)",
    ".sympy.core.exprtools.py@@Factors.is_zero": "def is_zero(self):\n    f = self.factors\n    return len(f) == 1 and S.Zero in f",
    ".sympy.core.exprtools.py@@Factors.normal": "def normal(self, other):\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if other.is_zero:\n            return (Factors(), Factors(S.Zero))\n        if self.is_zero:\n            return (Factors(S.Zero), Factors())\n    self_factors = dict(self.factors)\n    other_factors = dict(other.factors)\n    for factor, self_exp in self.factors.items():\n        try:\n            other_exp = other.factors[factor]\n        except KeyError:\n            continue\n        exp = self_exp - other_exp\n        if not exp:\n            del self_factors[factor]\n            del other_factors[factor]\n        elif _isnumber(exp):\n            if exp > 0:\n                self_factors[factor] = exp\n                del other_factors[factor]\n            else:\n                del self_factors[factor]\n                other_factors[factor] = -exp\n        else:\n            r = self_exp.extract_additively(other_exp)\n            if r is not None:\n                if r:\n                    self_factors[factor] = r\n                    del other_factors[factor]\n                else:\n                    del self_factors[factor]\n                    del other_factors[factor]\n            else:\n                sc, sa = self_exp.as_coeff_Add()\n                if sc:\n                    oc, oa = other_exp.as_coeff_Add()\n                    diff = sc - oc\n                    if diff > 0:\n                        self_factors[factor] -= oc\n                        other_exp = oa\n                    elif diff < 0:\n                        self_factors[factor] -= sc\n                        other_factors[factor] -= sc\n                        other_exp = oa - diff\n                    else:\n                        self_factors[factor] = sa\n                        other_exp = oa\n                if other_exp:\n                    other_factors[factor] = other_exp\n                else:\n                    del other_factors[factor]\n    return (Factors(self_factors), Factors(other_factors))",
    ".sympy.core.exprtools.py@@Term.as_expr": "def as_expr(self):\n    return self.coeff * (self.numer.as_expr() / self.denom.as_expr())",
    ".sympy.core.exprtools.py@@Factors.as_expr": "def as_expr(self):\n    args = []\n    for factor, exp in self.factors.items():\n        if exp != 1:\n            b, e = factor.as_base_exp()\n            if isinstance(exp, int):\n                e = _keep_coeff(Integer(exp), e)\n            elif isinstance(exp, Rational):\n                e = _keep_coeff(exp, e)\n            else:\n                e *= exp\n            args.append(b ** e)\n        else:\n            args.append(factor)\n    return Mul(*args)",
    ".sympy.core.numbers.py@@Rational.__mul__": "def __mul__(self, other):\n    if global_evaluate[0]:\n        if isinstance(other, Integer):\n            return Rational(self.p * other.p, self.q, igcd(other.p, self.q))\n        elif isinstance(other, Rational):\n            return Rational(self.p * other.p, self.q * other.q, igcd(self.p, other.q) * igcd(self.q, other.p))\n        elif isinstance(other, Float):\n            return other * self\n        else:\n            return Number.__mul__(self, other)\n    return Number.__mul__(self, other)",
    ".sympy.core.numbers.py@@Number.__mul__": "def __mul__(self, other):\n    if isinstance(other, Number) and global_evaluate[0]:\n        if other is S.NaN:\n            return S.NaN\n        elif other is S.Infinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.Infinity\n            else:\n                return S.NegativeInfinity\n        elif other is S.NegativeInfinity:\n            if self.is_zero:\n                return S.NaN\n            elif self.is_positive:\n                return S.NegativeInfinity\n            else:\n                return S.Infinity\n    elif isinstance(other, Tuple):\n        return NotImplemented\n    return AtomicExpr.__mul__(self, other)",
    ".sympy.polys.polytools.py@@parallel_poly_from_expr": "def parallel_poly_from_expr(exprs, *gens, **args):\n    opt = options.build_options(gens, args)\n    return _parallel_poly_from_expr(exprs, opt)",
    ".sympy.polys.polyoptions.py@@build_options": "def build_options(gens, args=None):\n    if args is None:\n        gens, args = ((), gens)\n    if len(args) != 1 or 'opt' not in args or gens:\n        return Options(gens, args)\n    else:\n        return args['opt']",
    ".sympy.polys.polyoptions.py@@Options.__init__": "def __init__(self, gens, args, flags=None, strict=False):\n    dict.__init__(self)\n    if gens and args.get('gens', ()):\n        raise OptionError(\"both '*gens' and keyword argument 'gens' supplied\")\n    elif gens:\n        args = dict(args)\n        args['gens'] = gens\n    defaults = args.pop('defaults', {})\n\n    def preprocess_options(args):\n        for option, value in args.items():\n            try:\n                cls = self.__options__[option]\n            except KeyError:\n                raise OptionError(\"'%s' is not a valid option\" % option)\n            if issubclass(cls, Flag):\n                if flags is None or option not in flags:\n                    if strict:\n                        raise OptionError(\"'%s' flag is not allowed in this context\" % option)\n            if value is not None:\n                self[option] = cls.preprocess(value)\n    preprocess_options(args)\n    for key, value in dict(defaults).items():\n        if key in self:\n            del defaults[key]\n        else:\n            for option in self.keys():\n                cls = self.__options__[option]\n                if key in cls.excludes:\n                    del defaults[key]\n                    break\n    preprocess_options(defaults)\n    for option in self.keys():\n        cls = self.__options__[option]\n        for require_option in cls.requires:\n            if self.get(require_option) is None:\n                raise OptionError(\"'%s' option is only allowed together with '%s'\" % (option, require_option))\n        for exclude_option in cls.excludes:\n            if self.get(exclude_option) is not None:\n                raise OptionError(\"'%s' option is not allowed together with '%s'\" % (option, exclude_option))\n    for option in self.__order__:\n        self.__options__[option].postprocess(self)",
    ".sympy.polys.polyoptions.py@@Options.preprocess_options": "def preprocess_options(args):\n    for option, value in args.items():\n        try:\n            cls = self.__options__[option]\n        except KeyError:\n            raise OptionError(\"'%s' is not a valid option\" % option)\n        if issubclass(cls, Flag):\n            if flags is None or option not in flags:\n                if strict:\n                    raise OptionError(\"'%s' flag is not allowed in this context\" % option)\n        if value is not None:\n            self[option] = cls.preprocess(value)",
    ".sympy.polys.polyoptions.py@@Option.postprocess": "def postprocess(cls, options):\n    pass",
    ".sympy.polys.polyoptions.py@@Extension.postprocess": "def postprocess(cls, options):\n    if 'extension' in options and options['extension'] is not True:\n        options['domain'] = sympy.polys.domains.QQ.algebraic_field(*options['extension'])",
    ".sympy.polys.polyoptions.py@@Gaussian.postprocess": "def postprocess(cls, options):\n    if 'gaussian' in options and options['gaussian'] is True:\n        options['extension'] = set([S.ImaginaryUnit])\n        Extension.postprocess(options)",
    ".sympy.polys.polyoptions.py@@Domain.postprocess": "def postprocess(cls, options):\n    if 'gens' in options and 'domain' in options and options['domain'].is_Composite and set(options['domain'].symbols) & set(options['gens']):\n        raise GeneratorsError('ground domain and generators interfere together')\n    elif ('gens' not in options or not options['gens']) and 'domain' in options and (options['domain'] == sympy.polys.domains.EX):\n        raise GeneratorsError('you have to provide generators because EX domain was requested')",
    ".sympy.polys.polyoptions.py@@Auto.postprocess": "def postprocess(cls, options):\n    if ('domain' in options or 'field' in options) and 'auto' not in options:\n        options['auto'] = False",
    ".sympy.polys.polyoptions.py@@Modulus.postprocess": "def postprocess(cls, options):\n    if 'modulus' in options:\n        modulus = options['modulus']\n        symmetric = options.get('symmetric', True)\n        options['domain'] = sympy.polys.domains.FF(modulus, symmetric)",
    ".sympy.polys.polyoptions.py@@Split.postprocess": "def postprocess(cls, options):\n    if 'split' in options:\n        raise NotImplementedError(\"'split' option is not implemented yet\")",
    ".sympy.polys.polytools.py@@_parallel_poly_from_expr": "def _parallel_poly_from_expr(exprs, opt):\n    from sympy.functions.elementary.piecewise import Piecewise\n    if len(exprs) == 2:\n        f, g = exprs\n        if isinstance(f, Poly) and isinstance(g, Poly):\n            f = f.__class__._from_poly(f, opt)\n            g = g.__class__._from_poly(g, opt)\n            f, g = f.unify(g)\n            opt.gens = f.gens\n            opt.domain = f.domain\n            if opt.polys is None:\n                opt.polys = True\n            return ([f, g], opt)\n    origs, exprs = (list(exprs), [])\n    _exprs, _polys = ([], [])\n    failed = False\n    for i, expr in enumerate(origs):\n        expr = sympify(expr)\n        if isinstance(expr, Basic):\n            if expr.is_Poly:\n                _polys.append(i)\n            else:\n                _exprs.append(i)\n                if opt.expand:\n                    expr = expr.expand()\n        else:\n            failed = True\n        exprs.append(expr)\n    if failed:\n        raise PolificationFailed(opt, origs, exprs, True)\n    if _polys:\n        for i in _polys:\n            exprs[i] = exprs[i].as_expr()\n    reps, opt = _parallel_dict_from_expr(exprs, opt)\n    if not opt.gens:\n        raise PolificationFailed(opt, origs, exprs, True)\n    for k in opt.gens:\n        if isinstance(k, Piecewise):\n            raise PolynomialError('Piecewise generators do not make sense')\n    coeffs_list, lengths = ([], [])\n    all_monoms = []\n    all_coeffs = []\n    for rep in reps:\n        monoms, coeffs = list(zip(*list(rep.items())))\n        coeffs_list.extend(coeffs)\n        all_monoms.append(monoms)\n        lengths.append(len(coeffs))\n    domain = opt.domain\n    if domain is None:\n        opt.domain, coeffs_list = construct_domain(coeffs_list, opt=opt)\n    else:\n        coeffs_list = list(map(domain.from_sympy, coeffs_list))\n    for k in lengths:\n        all_coeffs.append(coeffs_list[:k])\n        coeffs_list = coeffs_list[k:]\n    polys = []\n    for monoms, coeffs in zip(all_monoms, all_coeffs):\n        rep = dict(list(zip(monoms, coeffs)))\n        poly = Poly._from_dict(rep, opt)\n        polys.append(poly)\n    if opt.polys is None:\n        opt.polys = bool(_polys)\n    return (polys, opt)",
    ".sympy.polys.polyoptions.py@@OptionType.getter": "def getter(self):\n    try:\n        return self[cls.option]\n    except KeyError:\n        return cls.default()",
    ".sympy.polys.polyoptions.py@@Expand.default": "def default(cls):\n    return True",
    ".sympy.core.expr.py@@Expr.expand": "def expand(self, deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints):\n    from sympy.simplify.radsimp import fraction\n    hints.update(power_base=power_base, power_exp=power_exp, mul=mul, log=log, multinomial=multinomial, basic=basic)\n    expr = self\n    if hints.pop('frac', False):\n        n, d = [a.expand(deep=deep, modulus=modulus, **hints) for a in fraction(self)]\n        return n / d\n    elif hints.pop('denom', False):\n        n, d = fraction(self)\n        return n / d.expand(deep=deep, modulus=modulus, **hints)\n    elif hints.pop('numer', False):\n        n, d = fraction(self)\n        return n.expand(deep=deep, modulus=modulus, **hints) / d\n\n    def _expand_hint_key(hint):\n        if hint == 'mul':\n            return 'mulz'\n        return hint\n    for hint in sorted(hints.keys(), key=_expand_hint_key):\n        use_hint = hints[hint]\n        if use_hint:\n            hint = '_eval_expand_' + hint\n            expr, hit = Expr._expand_hint(expr, hint, deep=deep, **hints)\n    while True:\n        was = expr\n        if hints.get('multinomial', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_multinomial', deep=deep, **hints)\n        if hints.get('mul', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_mul', deep=deep, **hints)\n        if hints.get('log', False):\n            expr, _ = Expr._expand_hint(expr, '_eval_expand_log', deep=deep, **hints)\n        if expr == was:\n            break\n    if modulus is not None:\n        modulus = sympify(modulus)\n        if not modulus.is_Integer or modulus <= 0:\n            raise ValueError('modulus must be a positive integer, got %s' % modulus)\n        terms = []\n        for term in Add.make_args(expr):\n            coeff, tail = term.as_coeff_Mul(rational=True)\n            coeff %= modulus\n            if coeff:\n                terms.append(coeff * tail)\n        expr = Add(*terms)\n    return expr",
    ".sympy.core.expr.py@@Expr._expand_hint_key": "def _expand_hint_key(hint):\n    if hint == 'mul':\n        return 'mulz'\n    return hint",
    ".sympy.core.expr.py@@Expr._expand_hint": "def _expand_hint(expr, hint, deep=True, **hints):\n    hit = False\n    if deep and getattr(expr, 'args', ()) and (not expr.is_Atom):\n        sargs = []\n        for arg in expr.args:\n            arg, arghit = Expr._expand_hint(arg, hint, **hints)\n            hit |= arghit\n            sargs.append(arg)\n        if hit:\n            expr = expr.func(*sargs)\n    if hasattr(expr, hint):\n        newexpr = getattr(expr, hint)(**hints)\n        if newexpr != expr:\n            return (newexpr, True)\n    return (expr, hit)",
    ".sympy.polys.polyutils.py@@_parallel_dict_from_expr": "def _parallel_dict_from_expr(exprs, opt):\n    if opt.expand is not False:\n        exprs = [expr.expand() for expr in exprs]\n    if any((expr.is_commutative is False for expr in exprs)):\n        raise PolynomialError('non-commutative expressions are not supported')\n    if opt.gens:\n        reps, gens = _parallel_dict_from_expr_if_gens(exprs, opt)\n    else:\n        reps, gens = _parallel_dict_from_expr_no_gens(exprs, opt)\n    return (reps, opt.clone({'gens': gens}))",
    ".sympy.polys.polyoptions.py@@Gens.default": "def default(cls):\n    return ()",
    ".sympy.polys.polyutils.py@@_parallel_dict_from_expr_no_gens": "def _parallel_dict_from_expr_no_gens(exprs, opt):\n    if opt.domain is not None:\n\n        def _is_coeff(factor):\n            return factor in opt.domain\n    elif opt.extension is True:\n\n        def _is_coeff(factor):\n            return factor.is_algebraic\n    elif opt.greedy is not False:\n\n        def _is_coeff(factor):\n            return False\n    else:\n\n        def _is_coeff(factor):\n            return factor.is_number\n    gens, reprs = (set([]), [])\n    for expr in exprs:\n        terms = []\n        if expr.is_Equality:\n            expr = expr.lhs - expr.rhs\n        for term in Add.make_args(expr):\n            coeff, elements = ([], {})\n            for factor in Mul.make_args(term):\n                if not _not_a_coeff(factor) and (factor.is_Number or _is_coeff(factor)):\n                    coeff.append(factor)\n                else:\n                    if opt.series is False:\n                        base, exp = decompose_power(factor)\n                        if exp < 0:\n                            exp, base = (-exp, Pow(base, -S.One))\n                    else:\n                        base, exp = decompose_power_rat(factor)\n                    elements[base] = elements.setdefault(base, 0) + exp\n                    gens.add(base)\n            terms.append((coeff, elements))\n        reprs.append(terms)\n    gens = _sort_gens(gens, opt=opt)\n    k, indices = (len(gens), {})\n    for i, g in enumerate(gens):\n        indices[g] = i\n    polys = []\n    for terms in reprs:\n        poly = {}\n        for coeff, term in terms:\n            monom = [0] * k\n            for base, exp in term.items():\n                monom[indices[base]] = exp\n            monom = tuple(monom)\n            if monom in poly:\n                poly[monom] += Mul(*coeff)\n            else:\n                poly[monom] = Mul(*coeff)\n        polys.append(poly)\n    return (polys, tuple(gens))",
    ".sympy.polys.polyoptions.py@@Option.default": "def default(cls):\n    return None",
    ".sympy.polys.polyutils.py@@_not_a_coeff": "def _not_a_coeff(expr):\n    return expr in [S.NaN, S.Infinity, S.NegativeInfinity, S.ComplexInfinity]",
    ".sympy.core.numbers.py@@NaN.__eq__": "def __eq__(self, other):\n    return other is S.NaN",
    ".sympy.core.numbers.py@@Infinity.__eq__": "def __eq__(self, other):\n    return other is S.Infinity",
    ".sympy.core.numbers.py@@NegativeInfinity.__eq__": "def __eq__(self, other):\n    return other is S.NegativeInfinity",
    ".sympy.polys.polyutils.py@@_is_coeff": "def _is_coeff(factor):\n    return factor.is_number",
    ".sympy.polys.polyoptions.py@@Series.default": "def default(cls):\n    return False",
    ".sympy.polys.polyutils.py@@_sort_gens": "def _sort_gens(gens, **args):\n    opt = build_options(args)\n    gens_order, wrt = ({}, None)\n    if opt is not None:\n        gens_order, wrt = ({}, opt.wrt)\n        for i, gen in enumerate(opt.sort):\n            gens_order[gen] = i + 1\n\n    def order_key(gen):\n        gen = str(gen)\n        if wrt is not None:\n            try:\n                return (-len(wrt) + wrt.index(gen), gen, 0)\n            except ValueError:\n                pass\n        name, index = _re_gen.match(gen).groups()\n        if index:\n            index = int(index)\n        else:\n            index = 0\n        try:\n            return (gens_order[name], name, index)\n        except KeyError:\n            pass\n        try:\n            return (_gens_order[name], name, index)\n        except KeyError:\n            pass\n        return (_max_order, name, index)\n    try:\n        gens = sorted(gens, key=order_key)\n    except TypeError:\n        pass\n    return tuple(gens)",
    ".sympy.polys.polyoptions.py@@Sort.default": "def default(cls):\n    return []",
    ".sympy.polys.polyutils.py@@order_key": "def order_key(gen):\n    gen = str(gen)\n    if wrt is not None:\n        try:\n            return (-len(wrt) + wrt.index(gen), gen, 0)\n        except ValueError:\n            pass\n    name, index = _re_gen.match(gen).groups()\n    if index:\n        index = int(index)\n    else:\n        index = 0\n    try:\n        return (gens_order[name], name, index)\n    except KeyError:\n        pass\n    try:\n        return (_gens_order[name], name, index)\n    except KeyError:\n        pass\n    return (_max_order, name, index)",
    ".sympy.polys.polyoptions.py@@Options.clone": "def clone(self, updates={}):\n    obj = dict.__new__(self.__class__)\n    for option, value in self.items():\n        obj[option] = value\n    for option, value in updates.items():\n        obj[option] = value\n    return obj",
    ".sympy.polys.constructor.py@@construct_domain": "def construct_domain(obj, **args):\n    opt = build_options(args)\n    if hasattr(obj, '__iter__'):\n        if isinstance(obj, dict):\n            if not obj:\n                monoms, coeffs = ([], [])\n            else:\n                monoms, coeffs = list(zip(*list(obj.items())))\n        else:\n            coeffs = obj\n    else:\n        coeffs = [obj]\n    coeffs = list(map(sympify, coeffs))\n    result = _construct_simple(coeffs, opt)\n    if result is not None:\n        if result is not False:\n            domain, coeffs = result\n        else:\n            domain, coeffs = _construct_expression(coeffs, opt)\n    else:\n        if opt.composite is False:\n            result = None\n        else:\n            result = _construct_composite(coeffs, opt)\n        if result is not None:\n            domain, coeffs = result\n        else:\n            domain, coeffs = _construct_expression(coeffs, opt)\n    if hasattr(obj, '__iter__'):\n        if isinstance(obj, dict):\n            return (domain, dict(list(zip(monoms, coeffs))))\n        else:\n            return (domain, coeffs)\n    else:\n        return (domain, coeffs[0])",
    ".sympy.polys.constructor.py@@_construct_simple": "def _construct_simple(coeffs, opt):\n    result, rationals, reals, algebraics = ({}, False, False, False)\n    if opt.extension is True:\n        is_algebraic = lambda coeff: coeff.is_number and coeff.is_algebraic\n    else:\n        is_algebraic = lambda coeff: False\n    for coeff in coeffs:\n        if coeff.is_Rational:\n            if not coeff.is_Integer:\n                rationals = True\n        elif coeff.is_Float:\n            if not algebraics:\n                reals = True\n            else:\n                return False\n        elif is_algebraic(coeff):\n            if not reals:\n                algebraics = True\n            else:\n                return False\n        else:\n            return None\n    if algebraics:\n        domain, result = _construct_algebraic(coeffs, opt)\n    else:\n        if reals:\n            max_prec = max([c._prec for c in coeffs])\n            domain = RealField(prec=max_prec)\n        elif opt.field or rationals:\n            domain = QQ\n        else:\n            domain = ZZ\n        result = []\n        for coeff in coeffs:\n            result.append(domain.from_sympy(coeff))\n    return (domain, result)",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.from_sympy": "def from_sympy(self, a):\n    if a.is_Integer:\n        return PythonInteger(a.p)\n    elif a.is_Float and int(a) == a:\n        return PythonInteger(int(a))\n    else:\n        raise CoercionFailed('expected an integer, got %s' % a)",
    ".sympy.polys.polyoptions.py@@Options.__setattr__": "def __setattr__(self, attr, value):\n    if attr in self.__options__:\n        self[attr] = value\n    else:\n        super(Options, self).__setattr__(attr, value)",
    ".sympy.polys.polytools.py@@Poly._from_dict": "def _from_dict(cls, rep, opt):\n    gens = opt.gens\n    if not gens:\n        raise GeneratorsNeeded(\"can't initialize from 'dict' without generators\")\n    level = len(gens) - 1\n    domain = opt.domain\n    if domain is None:\n        domain, rep = construct_domain(rep, opt=opt)\n    else:\n        for monom, coeff in rep.items():\n            rep[monom] = domain.convert(coeff)\n    return cls.new(DMP.from_dict(rep, level, domain), *gens)",
    ".sympy.polys.domains.domain.py@@Domain.convert": "def convert(self, element, base=None):\n    if base is not None:\n        return self.convert_from(element, base)\n    if self.of_type(element):\n        return element\n    from sympy.polys.domains import PythonIntegerRing, GMPYIntegerRing, GMPYRationalField, RealField, ComplexField\n    if isinstance(element, integer_types):\n        return self.convert_from(element, PythonIntegerRing())\n    if HAS_GMPY:\n        integers = GMPYIntegerRing()\n        if isinstance(element, integers.tp):\n            return self.convert_from(element, integers)\n        rationals = GMPYRationalField()\n        if isinstance(element, rationals.tp):\n            return self.convert_from(element, rationals)\n    if isinstance(element, float):\n        parent = RealField(tol=False)\n        return self.convert_from(parent(element), parent)\n    if isinstance(element, complex):\n        parent = ComplexField(tol=False)\n        return self.convert_from(parent(element), parent)\n    if isinstance(element, DomainElement):\n        return self.convert_from(element, element.parent())\n    if self.is_Numerical and getattr(element, 'is_ground', False):\n        return self.convert(element.LC())\n    if isinstance(element, Basic):\n        try:\n            return self.from_sympy(element)\n        except (TypeError, ValueError):\n            pass\n    elif not is_sequence(element):\n        try:\n            element = sympify(element)\n            if isinstance(element, Basic):\n                return self.from_sympy(element)\n        except (TypeError, ValueError):\n            pass\n    raise CoercionFailed(\"can't convert %s of type %s to %s\" % (element, type(element), self))",
    ".sympy.polys.domains.domain.py@@Domain.of_type": "def of_type(self, element):\n    return isinstance(element, self.tp)",
    ".sympy.polys.domains.domain.py@@Domain.tp": "def tp(self):\n    return self.dtype",
    ".sympy.polys.polyclasses.py@@DMP.from_dict": "def from_dict(cls, rep, lev, dom):\n    return cls(dmp_from_dict(rep, lev, dom), dom, lev)",
    ".sympy.polys.densebasic.py@@dmp_from_dict": "def dmp_from_dict(f, u, K):\n    if not u:\n        return dup_from_dict(f, K)\n    if not f:\n        return dmp_zero(u)\n    coeffs = {}\n    for monom, coeff in f.items():\n        head, tail = (monom[0], monom[1:])\n        if head in coeffs:\n            coeffs[head][tail] = coeff\n        else:\n            coeffs[head] = {tail: coeff}\n    n, v, h = (max(coeffs.keys()), u - 1, [])\n    for k in range(n, -1, -1):\n        coeff = coeffs.get(k)\n        if coeff is not None:\n            h.append(dmp_from_dict(coeff, v, K))\n        else:\n            h.append(dmp_zero(v))\n    return dmp_strip(h, u)",
    ".sympy.polys.densebasic.py@@dup_from_dict": "def dup_from_dict(f, K):\n    if not f:\n        return []\n    n, h = (max(f.keys()), [])\n    if type(n) is int:\n        for k in range(n, -1, -1):\n            h.append(f.get(k, K.zero))\n    else:\n        n, = n\n        for k in range(n, -1, -1):\n            h.append(f.get((k,), K.zero))\n    return dup_strip(h)",
    ".sympy.polys.densebasic.py@@dup_strip": "def dup_strip(f):\n    if not f or f[0]:\n        return f\n    i = 0\n    for cf in f:\n        if cf:\n            break\n        else:\n            i += 1\n    return f[i:]",
    ".sympy.polys.polyclasses.py@@DMP.__init__": "def __init__(self, rep, dom, lev=None, ring=None):\n    if lev is not None:\n        if type(rep) is dict:\n            rep = dmp_from_dict(rep, lev, dom)\n        elif type(rep) is not list:\n            rep = dmp_ground(dom.convert(rep), lev)\n    else:\n        rep, lev = dmp_validate(rep)\n    self.rep = rep\n    self.lev = lev\n    self.dom = dom\n    self.ring = ring",
    ".sympy.polys.polytools.py@@Poly.new": "def new(cls, rep, *gens):\n    if not isinstance(rep, DMP):\n        raise PolynomialError('invalid polynomial representation: %s' % rep)\n    elif rep.lev != len(gens) - 1:\n        raise PolynomialError('invalid arguments: %s, %s' % (rep, gens))\n    obj = Basic.__new__(cls)\n    obj.rep = rep\n    obj.gens = gens\n    return obj",
    ".sympy.polys.polytools.py@@Poly.cancel": "def cancel(f, g, include=False):\n    dom, per, F, G = f._unify(g)\n    if hasattr(F, 'cancel'):\n        result = F.cancel(G, include=include)\n    else:\n        raise OperationNotSupported(f, 'cancel')\n    if not include:\n        if dom.has_assoc_Ring:\n            dom = dom.get_ring()\n        cp, cq, p, q = result\n        cp = dom.to_sympy(cp)\n        cq = dom.to_sympy(cq)\n        return (cp / cq, per(p), per(q))\n    else:\n        return tuple(map(per, result))",
    ".sympy.polys.polytools.py@@Poly._unify": "def _unify(f, g):\n    g = sympify(g)\n    if not g.is_Poly:\n        try:\n            return (f.rep.dom, f.per, f.rep, f.rep.per(f.rep.dom.from_sympy(g)))\n        except CoercionFailed:\n            raise UnificationFailed(\"can't unify %s with %s\" % (f, g))\n    if isinstance(f.rep, DMP) and isinstance(g.rep, DMP):\n        gens = _unify_gens(f.gens, g.gens)\n        dom, lev = (f.rep.dom.unify(g.rep.dom, gens), len(gens) - 1)\n        if f.gens != gens:\n            f_monoms, f_coeffs = _dict_reorder(f.rep.to_dict(), f.gens, gens)\n            if f.rep.dom != dom:\n                f_coeffs = [dom.convert(c, f.rep.dom) for c in f_coeffs]\n            F = DMP(dict(list(zip(f_monoms, f_coeffs))), dom, lev)\n        else:\n            F = f.rep.convert(dom)\n        if g.gens != gens:\n            g_monoms, g_coeffs = _dict_reorder(g.rep.to_dict(), g.gens, gens)\n            if g.rep.dom != dom:\n                g_coeffs = [dom.convert(c, g.rep.dom) for c in g_coeffs]\n            G = DMP(dict(list(zip(g_monoms, g_coeffs))), dom, lev)\n        else:\n            G = g.rep.convert(dom)\n    else:\n        raise UnificationFailed(\"can't unify %s with %s\" % (f, g))\n    cls = f.__class__\n\n    def per(rep, dom=dom, gens=gens, remove=None):\n        if remove is not None:\n            gens = gens[:remove] + gens[remove + 1:]\n            if not gens:\n                return dom.to_sympy(rep)\n        return cls.new(rep, *gens)\n    return (dom, per, F, G)",
    ".sympy.polys.polytools.py@@Poly.__hash__": "def __hash__(self):\n    return super(Poly, self).__hash__()",
    ".sympy.polys.polytools.py@@Poly._hashable_content": "def _hashable_content(self):\n    return (self.rep, self.gens)",
    ".sympy.polys.polyclasses.py@@DMP.__hash__": "def __hash__(f):\n    return hash((f.__class__.__name__, f.to_tuple(), f.lev, f.dom, f.ring))",
    ".sympy.polys.polyclasses.py@@DMP.to_tuple": "def to_tuple(f):\n    return dmp_to_tuple(f.rep, f.lev)",
    ".sympy.polys.densebasic.py@@dmp_to_tuple": "def dmp_to_tuple(f, u):\n    if not u:\n        return tuple(f)\n    v = u - 1\n    return tuple((dmp_to_tuple(c, v) for c in f))",
    ".sympy.polys.domains.domain.py@@Domain.__hash__": "def __hash__(self):\n    return hash((self.__class__.__name__, self.dtype))",
    ".sympy.polys.polyutils.py@@_unify_gens": "def _unify_gens(f_gens, g_gens):\n    f_gens = list(f_gens)\n    g_gens = list(g_gens)\n    if f_gens == g_gens:\n        return tuple(f_gens)\n    gens, common, k = ([], [], 0)\n    for gen in f_gens:\n        if gen in g_gens:\n            common.append(gen)\n    for i, gen in enumerate(g_gens):\n        if gen in common:\n            g_gens[i], k = (common[k], k + 1)\n    for gen in common:\n        i = f_gens.index(gen)\n        gens.extend(f_gens[:i])\n        f_gens = f_gens[i + 1:]\n        i = g_gens.index(gen)\n        gens.extend(g_gens[:i])\n        g_gens = g_gens[i + 1:]\n        gens.append(gen)\n    gens.extend(f_gens)\n    gens.extend(g_gens)\n    return tuple(gens)",
    ".sympy.polys.domains.domain.py@@Domain.unify": "def unify(K0, K1, symbols=None):\n    if symbols is not None:\n        return K0.unify_with_symbols(K1, symbols)\n    if K0 == K1:\n        return K0\n    if K0.is_EX:\n        return K0\n    if K1.is_EX:\n        return K1\n    if K0.is_Composite or K1.is_Composite:\n        K0_ground = K0.dom if K0.is_Composite else K0\n        K1_ground = K1.dom if K1.is_Composite else K1\n        K0_symbols = K0.symbols if K0.is_Composite else ()\n        K1_symbols = K1.symbols if K1.is_Composite else ()\n        domain = K0_ground.unify(K1_ground)\n        symbols = _unify_gens(K0_symbols, K1_symbols)\n        order = K0.order if K0.is_Composite else K1.order\n        if (K0.is_FractionField and K1.is_PolynomialRing or (K1.is_FractionField and K0.is_PolynomialRing)) and (not K0_ground.has_Field or not K1_ground.has_Field) and domain.has_Field:\n            domain = domain.get_ring()\n        if K0.is_Composite and (not K1.is_Composite or K0.is_FractionField or K1.is_PolynomialRing):\n            cls = K0.__class__\n        else:\n            cls = K1.__class__\n        from sympy.polys.domains.old_polynomialring import GlobalPolynomialRing\n        if cls == GlobalPolynomialRing:\n            return cls(domain, symbols)\n        return cls(domain, symbols, order)\n\n    def mkinexact(cls, K0, K1):\n        prec = max(K0.precision, K1.precision)\n        tol = max(K0.tolerance, K1.tolerance)\n        return cls(prec=prec, tol=tol)\n    if K0.is_ComplexField and K1.is_ComplexField:\n        return mkinexact(K0.__class__, K0, K1)\n    if K0.is_ComplexField and K1.is_RealField:\n        return mkinexact(K0.__class__, K0, K1)\n    if K0.is_RealField and K1.is_ComplexField:\n        return mkinexact(K1.__class__, K1, K0)\n    if K0.is_RealField and K1.is_RealField:\n        return mkinexact(K0.__class__, K0, K1)\n    if K0.is_ComplexField or K0.is_RealField:\n        return K0\n    if K1.is_ComplexField or K1.is_RealField:\n        return K1\n    if K0.is_AlgebraicField and K1.is_AlgebraicField:\n        return K0.__class__(K0.dom.unify(K1.dom), *_unify_gens(K0.orig_ext, K1.orig_ext))\n    elif K0.is_AlgebraicField:\n        return K0\n    elif K1.is_AlgebraicField:\n        return K1\n    if K0.is_RationalField:\n        return K0\n    if K1.is_RationalField:\n        return K1\n    if K0.is_IntegerRing:\n        return K0\n    if K1.is_IntegerRing:\n        return K1\n    if K0.is_FiniteField and K1.is_FiniteField:\n        return K0.__class__(max(K0.mod, K1.mod, key=default_sort_key))\n    from sympy.polys.domains import EX\n    return EX",
    ".sympy.polys.domains.domain.py@@Domain.unify_with_symbols": "def unify_with_symbols(K0, K1, symbols):\n    if K0.is_Composite and set(K0.symbols) & set(symbols) or (K1.is_Composite and set(K1.symbols) & set(symbols)):\n        raise UnificationFailed(\"can't unify %s with %s, given %s generators\" % (K0, K1, tuple(symbols)))\n    return K0.unify(K1)",
    ".sympy.polys.domains.domain.py@@Domain.__eq__": "def __eq__(self, other):\n    return isinstance(other, Domain) and self.dtype == other.dtype",
    ".sympy.polys.polyclasses.py@@DMP.convert": "def convert(f, dom):\n    if f.dom == dom:\n        return f\n    else:\n        return DMP(dmp_convert(f.rep, f.lev, f.dom, dom), dom, f.lev)",
    ".sympy.polys.polyclasses.py@@DMP.cancel": "def cancel(f, g, include=True):\n    lev, dom, per, F, G = f.unify(g)\n    if include:\n        F, G = dmp_cancel(F, G, lev, dom, include=True)\n    else:\n        cF, cG, F, G = dmp_cancel(F, G, lev, dom, include=False)\n    F, G = (per(F), per(G))\n    if include:\n        return (F, G)\n    else:\n        return (cF, cG, F, G)",
    ".sympy.polys.polyclasses.py@@DMP.unify": "def unify(f, g):\n    if not isinstance(g, DMP) or f.lev != g.lev:\n        raise UnificationFailed(\"can't unify %s with %s\" % (f, g))\n    if f.dom == g.dom and f.ring == g.ring:\n        return (f.lev, f.dom, f.per, f.rep, g.rep)\n    else:\n        lev, dom = (f.lev, f.dom.unify(g.dom))\n        ring = f.ring\n        if g.ring is not None:\n            if ring is not None:\n                ring = ring.unify(g.ring)\n            else:\n                ring = g.ring\n        F = dmp_convert(f.rep, lev, f.dom, dom)\n        G = dmp_convert(g.rep, lev, g.dom, dom)\n\n        def per(rep, dom=dom, lev=lev, kill=False):\n            if kill:\n                if not lev:\n                    return rep\n                else:\n                    lev -= 1\n            return DMP(rep, dom, lev, ring)\n        return (lev, dom, per, F, G)",
    ".sympy.polys.euclidtools.py@@dmp_cancel": "def dmp_cancel(f, g, u, K, include=True):\n    K0 = None\n    if K.has_Field and K.has_assoc_Ring:\n        K0, K = (K, K.get_ring())\n        cq, f = dmp_clear_denoms(f, u, K0, K, convert=True)\n        cp, g = dmp_clear_denoms(g, u, K0, K, convert=True)\n    else:\n        cp, cq = (K.one, K.one)\n    _, p, q = dmp_inner_gcd(f, g, u, K)\n    if K0 is not None:\n        _, cp, cq = K.cofactors(cp, cq)\n        p = dmp_convert(p, u, K, K0)\n        q = dmp_convert(q, u, K, K0)\n        K = K0\n    p_neg = K.is_negative(dmp_ground_LC(p, u, K))\n    q_neg = K.is_negative(dmp_ground_LC(q, u, K))\n    if p_neg and q_neg:\n        p, q = (dmp_neg(p, u, K), dmp_neg(q, u, K))\n    elif p_neg:\n        cp, p = (-cp, dmp_neg(p, u, K))\n    elif q_neg:\n        cp, q = (-cp, dmp_neg(q, u, K))\n    if not include:\n        return (cp, cq, p, q)\n    p = dmp_mul_ground(p, cp, u, K)\n    q = dmp_mul_ground(q, cq, u, K)\n    return (p, q)",
    ".sympy.polys.euclidtools.py@@dmp_inner_gcd": "def dmp_inner_gcd(f, g, u, K):\n    if not u:\n        return dup_inner_gcd(f, g, K)\n    J, (f, g) = dmp_multi_deflate((f, g), u, K)\n    h, cff, cfg = _dmp_inner_gcd(f, g, u, K)\n    return (dmp_inflate(h, J, u, K), dmp_inflate(cff, J, u, K), dmp_inflate(cfg, J, u, K))",
    ".sympy.polys.euclidtools.py@@dup_inner_gcd": "def dup_inner_gcd(f, g, K):\n    if not K.is_Exact:\n        try:\n            exact = K.get_exact()\n        except DomainError:\n            return ([K.one], f, g)\n        f = dup_convert(f, K, exact)\n        g = dup_convert(g, K, exact)\n        h, cff, cfg = dup_inner_gcd(f, g, exact)\n        h = dup_convert(h, exact, K)\n        cff = dup_convert(cff, exact, K)\n        cfg = dup_convert(cfg, exact, K)\n        return (h, cff, cfg)\n    elif K.has_Field:\n        if K.is_QQ and query('USE_HEU_GCD'):\n            try:\n                return dup_qq_heu_gcd(f, g, K)\n            except HeuristicGCDFailed:\n                pass\n        return dup_ff_prs_gcd(f, g, K)\n    else:\n        if K.is_ZZ and query('USE_HEU_GCD'):\n            try:\n                return dup_zz_heu_gcd(f, g, K)\n            except HeuristicGCDFailed:\n                pass\n        return dup_rr_prs_gcd(f, g, K)",
    ".sympy.polys.polyconfig.py@@query": "def query(key):\n    return _current_config.get(key.upper(), None)",
    ".sympy.polys.euclidtools.py@@dup_zz_heu_gcd": "def dup_zz_heu_gcd(f, g, K):\n    result = _dup_rr_trivial_gcd(f, g, K)\n    if result is not None:\n        return result\n    df = dup_degree(f)\n    dg = dup_degree(g)\n    gcd, f, g = dup_extract(f, g, K)\n    if df == 0 or dg == 0:\n        return ([gcd], f, g)\n    f_norm = dup_max_norm(f, K)\n    g_norm = dup_max_norm(g, K)\n    B = K(2 * min(f_norm, g_norm) + 29)\n    x = max(min(B, 99 * K.sqrt(B)), 2 * min(f_norm // abs(dup_LC(f, K)), g_norm // abs(dup_LC(g, K))) + 2)\n    for i in range(0, HEU_GCD_MAX):\n        ff = dup_eval(f, x, K)\n        gg = dup_eval(g, x, K)\n        if ff and gg:\n            h = K.gcd(ff, gg)\n            cff = ff // h\n            cfg = gg // h\n            h = _dup_zz_gcd_interpolate(h, x, K)\n            h = dup_primitive(h, K)[1]\n            cff_, r = dup_div(f, h, K)\n            if not r:\n                cfg_, r = dup_div(g, h, K)\n                if not r:\n                    h = dup_mul_ground(h, gcd, K)\n                    return (h, cff_, cfg_)\n            cff = _dup_zz_gcd_interpolate(cff, x, K)\n            h, r = dup_div(f, cff, K)\n            if not r:\n                cfg_, r = dup_div(g, h, K)\n                if not r:\n                    h = dup_mul_ground(h, gcd, K)\n                    return (h, cff, cfg_)\n            cfg = _dup_zz_gcd_interpolate(cfg, x, K)\n            h, r = dup_div(g, cfg, K)\n            if not r:\n                cff_, r = dup_div(f, h, K)\n                if not r:\n                    h = dup_mul_ground(h, gcd, K)\n                    return (h, cff_, cfg)\n        x = 73794 * x * K.sqrt(K.sqrt(x)) // 27011\n    raise HeuristicGCDFailed('no luck')",
    ".sympy.polys.euclidtools.py@@_dup_rr_trivial_gcd": "def _dup_rr_trivial_gcd(f, g, K):\n    if not (f or g):\n        return ([], [], [])\n    elif not f:\n        if K.is_nonnegative(dup_LC(g, K)):\n            return (g, [], [K.one])\n        else:\n            return (dup_neg(g, K), [], [-K.one])\n    elif not g:\n        if K.is_nonnegative(dup_LC(f, K)):\n            return (f, [K.one], [])\n        else:\n            return (dup_neg(f, K), [-K.one], [])\n    return None",
    ".sympy.polys.densebasic.py@@dup_degree": "def dup_degree(f):\n    if not f:\n        return -oo\n    return len(f) - 1",
    ".sympy.polys.densetools.py@@dup_extract": "def dup_extract(f, g, K):\n    fc = dup_content(f, K)\n    gc = dup_content(g, K)\n    gcd = K.gcd(fc, gc)\n    if not K.is_one(gcd):\n        f = dup_quo_ground(f, gcd, K)\n        g = dup_quo_ground(g, gcd, K)\n    return (gcd, f, g)",
    ".sympy.polys.densetools.py@@dup_content": "def dup_content(f, K):\n    from sympy.polys.domains import QQ\n    if not f:\n        return K.zero\n    cont = K.zero\n    if K == QQ:\n        for c in f:\n            cont = K.gcd(cont, c)\n    else:\n        for c in f:\n            cont = K.gcd(cont, c)\n            if K.is_one(cont):\n                break\n    return cont",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.gcd": "def gcd(self, a, b):\n    return python_gcd(a, b)",
    ".sympy.polys.domains.domain.py@@Domain.is_one": "def is_one(self, a):\n    return a == self.one",
    ".sympy.polys.densebasic.py@@dmp_ground_LC": "def dmp_ground_LC(f, u, K):\n    while u:\n        f = dmp_LC(f, K)\n        u -= 1\n    return dup_LC(f, K)",
    ".sympy.polys.densebasic.py@@poly_LC": "def poly_LC(f, K):\n    if not f:\n        return K.zero\n    else:\n        return f[0]",
    ".sympy.polys.domains.domain.py@@Domain.is_negative": "def is_negative(self, a):\n    return a < 0",
    ".sympy.polys.polyclasses.py@@DMP.per": "def per(f, rep, dom=None, kill=False, ring=None):\n    lev = f.lev\n    if kill:\n        if not lev:\n            return rep\n        else:\n            lev -= 1\n    if dom is None:\n        dom = f.dom\n    if ring is None:\n        ring = f.ring\n    return DMP(rep, dom, lev, ring)",
    ".sympy.polys.domains.ring.py@@Ring.get_ring": "def get_ring(self):\n    return self",
    ".sympy.polys.domains.pythonintegerring.py@@PythonIntegerRing.to_sympy": "def to_sympy(self, a):\n    return SymPyInteger(a)",
    ".sympy.polys.polytools.py@@Poly.per": "def per(f, rep, gens=None, remove=None):\n    if gens is None:\n        gens = f.gens\n    if remove is not None:\n        gens = gens[:remove] + gens[remove + 1:]\n        if not gens:\n            return f.rep.dom.to_sympy(rep)\n    return f.__class__.new(rep, *gens)",
    ".sympy.polys.polytools.py@@Poly.as_expr": "def as_expr(f, *gens):\n    if not gens:\n        gens = f.gens\n    elif len(gens) == 1 and isinstance(gens[0], dict):\n        mapping = gens[0]\n        gens = list(f.gens)\n        for gen, value in mapping.items():\n            try:\n                index = gens.index(gen)\n            except ValueError:\n                raise GeneratorsError(\"%s doesn't have %s as generator\" % (f, gen))\n            else:\n                gens[index] = value\n    return basic_from_dict(f.rep.to_sympy_dict(), *gens)",
    ".sympy.polys.polyclasses.py@@DMP.to_sympy_dict": "def to_sympy_dict(f, zero=False):\n    rep = dmp_to_dict(f.rep, f.lev, f.dom, zero=zero)\n    for k, v in rep.items():\n        rep[k] = f.dom.to_sympy(v)\n    return rep",
    ".sympy.polys.densebasic.py@@dmp_to_dict": "def dmp_to_dict(f, u, K=None, zero=False):\n    if not u:\n        return dup_to_dict(f, K, zero=zero)\n    if dmp_zero_p(f, u) and zero:\n        return {(0,) * (u + 1): K.zero}\n    n, v, result = (dmp_degree(f, u), u - 1, {})\n    if n == -oo:\n        n = -1\n    for k in range(0, n + 1):\n        h = dmp_to_dict(f[n - k], v)\n        for exp, coeff in h.items():\n            result[(k,) + exp] = coeff\n    return result",
    ".sympy.polys.densebasic.py@@dup_to_dict": "def dup_to_dict(f, K=None, zero=False):\n    if not f and zero:\n        return {(0,): K.zero}\n    n, result = (len(f) - 1, {})\n    for k in range(0, n + 1):\n        if f[n - k]:\n            result[k,] = f[n - k]\n    return result",
    ".sympy.polys.polyutils.py@@expr_from_dict": "def expr_from_dict(rep, *gens):\n    result = []\n    for monom, coeff in rep.items():\n        term = [coeff]\n        for g, m in zip(gens, monom):\n            if m:\n                term.append(Pow(g, m))\n        result.append(Mul(*term))\n    return Add(*result)",
    ".sympy.core.function.py@@_mexpand": "def _mexpand(expr, recursive=False):\n    if expr is None:\n        return\n    was = None\n    while was != expr:\n        was, expr = (expr, expand_mul(expand_multinomial(expr)))\n        if not recursive:\n            break\n    return expr",
    ".sympy.core.function.py@@expand_multinomial": "def expand_multinomial(expr, deep=True):\n    return sympify(expr).expand(deep=deep, mul=False, power_exp=False, power_base=False, basic=False, multinomial=True, log=False)",
    ".sympy.core.function.py@@expand_mul": "def expand_mul(expr, deep=True):\n    return sympify(expr).expand(deep=deep, mul=True, power_exp=False, power_base=False, basic=False, multinomial=False, log=False)",
    ".sympy.core.expr.py@@Expr.cancel": "def cancel(self, *gens, **args):\n    from sympy.polys import cancel\n    return cancel(self, *gens, **args)",
    ".sympy.simplify.simplify.py@@shorter": "def shorter(*choices):\n    if not has_variety(choices):\n        return choices[0]\n    return min(choices, key=measure)",
    ".sympy.utilities.iterables.py@@has_variety": "def has_variety(seq):\n    for i, s in enumerate(seq):\n        if i == 0:\n            sentinel = s\n        elif s != sentinel:\n            return True\n    return False",
    ".sympy.polys.rationaltools.py@@together": "def together(expr, deep=False):\n\n    def _together(expr):\n        if isinstance(expr, Basic):\n            if expr.is_Atom or (expr.is_Function and (not deep)):\n                return expr\n            elif expr.is_Add:\n                return gcd_terms(list(map(_together, Add.make_args(expr))))\n            elif expr.is_Pow:\n                base = _together(expr.base)\n                if deep:\n                    exp = _together(expr.exp)\n                else:\n                    exp = expr.exp\n                return expr.__class__(base, exp)\n            else:\n                return expr.__class__(*[_together(arg) for arg in expr.args])\n        elif iterable(expr):\n            return expr.__class__([_together(ex) for ex in expr])\n        return expr\n    return _together(sympify(expr))",
    ".sympy.polys.rationaltools.py@@_together": "def _together(expr):\n    if isinstance(expr, Basic):\n        if expr.is_Atom or (expr.is_Function and (not deep)):\n            return expr\n        elif expr.is_Add:\n            return gcd_terms(list(map(_together, Add.make_args(expr))))\n        elif expr.is_Pow:\n            base = _together(expr.base)\n            if deep:\n                exp = _together(expr.exp)\n            else:\n                exp = expr.exp\n            return expr.__class__(base, exp)\n        else:\n            return expr.__class__(*[_together(arg) for arg in expr.args])\n    elif iterable(expr):\n        return expr.__class__([_together(ex) for ex in expr])\n    return expr",
    ".sympy.core.exprtools.py@@Factors.lcm": "def lcm(self, other):\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if any((f.is_zero for f in (self, other))):\n            return Factors(S.Zero)\n    factors = dict(self.factors)\n    for factor, exp in other.factors.items():\n        if factor in factors:\n            exp = max(exp, factors[factor])\n        factors[factor] = exp\n    return Factors(factors)",
    ".sympy.core.exprtools.py@@Factors.quo": "def quo(self, other):\n    return self.div(other)[0]",
    ".sympy.core.exprtools.py@@Factors.div": "def div(self, other):\n    quo, rem = (dict(self.factors), {})\n    if not isinstance(other, Factors):\n        other = Factors(other)\n        if other.is_zero:\n            raise ZeroDivisionError\n        if self.is_zero:\n            return (Factors(S.Zero), Factors())\n    for factor, exp in other.factors.items():\n        if factor in quo:\n            d = quo[factor] - exp\n            if _isnumber(d):\n                if d <= 0:\n                    del quo[factor]\n                if d >= 0:\n                    if d:\n                        quo[factor] = d\n                    continue\n                exp = -d\n            else:\n                r = quo[factor].extract_additively(exp)\n                if r is not None:\n                    if r:\n                        quo[factor] = r\n                    else:\n                        del quo[factor]\n                else:\n                    other_exp = exp\n                    sc, sa = quo[factor].as_coeff_Add()\n                    if sc:\n                        oc, oa = other_exp.as_coeff_Add()\n                        diff = sc - oc\n                        if diff > 0:\n                            quo[factor] -= oc\n                            other_exp = oa\n                        elif diff < 0:\n                            quo[factor] -= sc\n                            other_exp = oa - diff\n                        else:\n                            quo[factor] = sa\n                            other_exp = oa\n                    if other_exp:\n                        rem[factor] = other_exp\n                    else:\n                        assert factor not in rem\n                continue\n        rem[factor] = exp\n    return (Factors(quo), Factors(rem))",
    ".sympy.simplify.hyperexpand.py@@hyperexpand": "def hyperexpand(f, allow_hyper=False, rewrite='default', place=None):\n    f = sympify(f)\n\n    def do_replace(ap, bq, z):\n        r = _hyperexpand(Hyper_Function(ap, bq), z, rewrite=rewrite)\n        if r is None:\n            return hyper(ap, bq, z)\n        else:\n            return r\n\n    def do_meijer(ap, bq, z):\n        r = _meijergexpand(G_Function(ap[0], ap[1], bq[0], bq[1]), z, allow_hyper, rewrite=rewrite, place=place)\n        if not r.has(nan, zoo, oo, -oo):\n            return r\n    return f.replace(hyper, do_replace).replace(meijerg, do_meijer)",
    ".sympy.core.basic.py@@Basic.replace": "def replace(self, query, value, map=False, simultaneous=True, exact=False):\n    from sympy.core.symbol import Dummy\n    from sympy.simplify.simplify import bottom_up\n    try:\n        query = sympify(query)\n    except SympifyError:\n        pass\n    try:\n        value = sympify(value)\n    except SympifyError:\n        pass\n    if isinstance(query, type):\n        _query = lambda expr: isinstance(expr, query)\n        if isinstance(value, type):\n            _value = lambda expr, result: value(*expr.args)\n        elif callable(value):\n            _value = lambda expr, result: value(*expr.args)\n        else:\n            raise TypeError('given a type, replace() expects another type or a callable')\n    elif isinstance(query, Basic):\n        _query = lambda expr: expr.match(query)\n        if isinstance(value, Basic):\n            if exact:\n                _value = lambda expr, result: value.subs(result) if all((val for val in result.values())) else expr\n            else:\n                _value = lambda expr, result: value.subs(result)\n        elif callable(value):\n            if exact:\n                _value = lambda expr, result: value(**dict([(str(key)[:-1], val) for key, val in result.items()])) if all((val for val in result.values())) else expr\n            else:\n                _value = lambda expr, result: value(**dict([(str(key)[:-1], val) for key, val in result.items()]))\n        else:\n            raise TypeError('given an expression, replace() expects another expression or a callable')\n    elif callable(query):\n        _query = query\n        if callable(value):\n            _value = lambda expr, result: value(expr)\n        else:\n            raise TypeError('given a callable, replace() expects another callable')\n    else:\n        raise TypeError('first argument to replace() must be a type, an expression or a callable')\n    mapping = {}\n    mask = []\n\n    def rec_replace(expr):\n        result = _query(expr)\n        if result or result == {}:\n            new = _value(expr, result)\n            if new is not None and new != expr:\n                mapping[expr] = new\n                if simultaneous:\n                    com = getattr(new, 'is_commutative', True)\n                    if com is None:\n                        com = True\n                    d = Dummy(commutative=com)\n                    mask.append((d, new))\n                    expr = d\n                else:\n                    expr = new\n        return expr\n    rv = bottom_up(self, rec_replace, atoms=True)\n    if simultaneous:\n        mask = list(reversed(mask))\n        for o, n in mask:\n            r = {o: n}\n            rv = rv.xreplace(r)\n    if not map:\n        return rv\n    else:\n        if simultaneous:\n            for o, n in mask:\n                r = {o: n}\n                mapping = {k.xreplace(r): v.xreplace(r) for k, v in mapping.items()}\n        return (rv, mapping)",
    ".sympy.parsing.sympy_parser.py@@parse_expr": "def parse_expr(s, local_dict=None, transformations=standard_transformations, global_dict=None, evaluate=True):\n    if local_dict is None:\n        local_dict = {}\n    if global_dict is None:\n        global_dict = {}\n        exec_('from sympy import *', global_dict)\n    code = stringify_expr(s, local_dict, global_dict, transformations)\n    if not evaluate:\n        code = compile(evaluateFalse(code), '<string>', 'eval')\n    return eval_expr(code, local_dict, global_dict)",
    ".sympy.parsing.sympy_parser.py@@stringify_expr": "def stringify_expr(s, local_dict, global_dict, transformations):\n    tokens = []\n    input_code = StringIO(s.strip())\n    for toknum, tokval, _, _, _ in generate_tokens(input_code.readline):\n        tokens.append((toknum, tokval))\n    for transform in transformations:\n        tokens = transform(tokens, local_dict, global_dict)\n    return untokenize(tokens)",
    ".sympy.parsing.sympy_tokenize.py@@generate_tokens": "def generate_tokens(readline):\n    lnum = parenlev = continued = 0\n    namechars, numchars = (string.ascii_letters + '_', '0123456789')\n    contstr, needcont = ('', 0)\n    contline = None\n    indents = [0]\n    while 1:\n        try:\n            line = readline()\n        except StopIteration:\n            line = ''\n        lnum = lnum + 1\n        pos, max = (0, len(line))\n        if contstr:\n            if not line:\n                raise TokenError('EOF in multi-line string', strstart)\n            endmatch = endprog.match(line)\n            if endmatch:\n                pos = end = endmatch.end(0)\n                yield (STRING, contstr + line[:end], strstart, (lnum, end), contline + line)\n                contstr, needcont = ('', 0)\n                contline = None\n            elif needcont and line[-2:] != '\\\\\\n' and (line[-3:] != '\\\\\\r\\n'):\n                yield (ERRORTOKEN, contstr + line, strstart, (lnum, len(line)), contline)\n                contstr = ''\n                contline = None\n                continue\n            else:\n                contstr = contstr + line\n                contline = contline + line\n                continue\n        elif parenlev == 0 and (not continued):\n            if not line:\n                break\n            column = 0\n            while pos < max:\n                if line[pos] == ' ':\n                    column = column + 1\n                elif line[pos] == '\\t':\n                    column = (column / tabsize + 1) * tabsize\n                elif line[pos] == '\\x0c':\n                    column = 0\n                else:\n                    break\n                pos = pos + 1\n            if pos == max:\n                break\n            if line[pos] in '#\\r\\n':\n                if line[pos] == '#':\n                    comment_token = line[pos:].rstrip('\\r\\n')\n                    nl_pos = pos + len(comment_token)\n                    yield (COMMENT, comment_token, (lnum, pos), (lnum, pos + len(comment_token)), line)\n                    yield (NL, line[nl_pos:], (lnum, nl_pos), (lnum, len(line)), line)\n                else:\n                    yield ((NL, COMMENT)[line[pos] == '#'], line[pos:], (lnum, pos), (lnum, len(line)), line)\n                continue\n            if column > indents[-1]:\n                indents.append(column)\n                yield (INDENT, line[:pos], (lnum, 0), (lnum, pos), line)\n            while column < indents[-1]:\n                if column not in indents:\n                    raise IndentationError('unindent does not match any outer indentation level', ('<tokenize>', lnum, pos, line))\n                indents = indents[:-1]\n                yield (DEDENT, '', (lnum, pos), (lnum, pos), line)\n        else:\n            if not line:\n                raise TokenError('EOF in multi-line statement', (lnum, 0))\n            continued = 0\n        while pos < max:\n            pseudomatch = pseudoprog.match(line, pos)\n            if pseudomatch:\n                start, end = pseudomatch.span(1)\n                spos, epos, pos = ((lnum, start), (lnum, end), end)\n                token, initial = (line[start:end], line[start])\n                if initial in numchars or (initial == '.' and token != '.'):\n                    yield (NUMBER, token, spos, epos, line)\n                elif initial in '\\r\\n':\n                    yield (NL if parenlev > 0 else NEWLINE, token, spos, epos, line)\n                elif initial == '#':\n                    if token.endswith('\\n'):\n                        raise ValueError('Token should not end with \\n')\n                    yield (COMMENT, token, spos, epos, line)\n                elif token in triple_quoted:\n                    endprog = endprogs[token]\n                    endmatch = endprog.match(line, pos)\n                    if endmatch:\n                        pos = endmatch.end(0)\n                        token = line[start:pos]\n                        yield (STRING, token, spos, (lnum, pos), line)\n                    else:\n                        strstart = (lnum, start)\n                        contstr = line[start:]\n                        contline = line\n                        break\n                elif initial in single_quoted or token[:2] in single_quoted or token[:3] in single_quoted:\n                    if token[-1] == '\\n':\n                        strstart = (lnum, start)\n                        endprog = endprogs[initial] or endprogs[token[1]] or endprogs[token[2]]\n                        contstr, needcont = (line[start:], 1)\n                        contline = line\n                        break\n                    else:\n                        yield (STRING, token, spos, epos, line)\n                elif initial in namechars:\n                    yield (NAME, token, spos, epos, line)\n                elif initial == '\\\\':\n                    continued = 1\n                else:\n                    if initial in '([{':\n                        parenlev = parenlev + 1\n                    elif initial in ')]}':\n                        parenlev = parenlev - 1\n                    yield (OP, token, spos, epos, line)\n            else:\n                yield (ERRORTOKEN, line[pos], (lnum, pos), (lnum, pos + 1), line)\n                pos = pos + 1\n    for indent in indents[1:]:\n        yield (DEDENT, '', (lnum, 0), (lnum, 0), '')\n    yield (ENDMARKER, '', (lnum, 0), (lnum, 0), '')",
    ".sympy.parsing.sympy_parser.py@@lambda_notation": "def lambda_notation(tokens, local_dict, global_dict):\n    result = []\n    flag = False\n    toknum, tokval = tokens[0]\n    tokLen = len(tokens)\n    if toknum == NAME and tokval == 'lambda':\n        if tokLen == 2:\n            result.extend(tokens)\n        elif tokLen > 2:\n            result.extend([(NAME, 'Lambda'), (OP, '('), (OP, '('), (OP, ')'), (OP, ')')])\n            for tokNum, tokVal in tokens[1:]:\n                if tokNum == OP and tokVal == ':':\n                    tokVal = ','\n                    flag = True\n                if not flag and tokNum == OP and (tokVal in ['*', '**']):\n                    raise TokenError('Starred arguments in lambda not supported')\n                if flag:\n                    result.insert(-1, (tokNum, tokVal))\n                else:\n                    result.insert(-2, (tokNum, tokVal))\n    else:\n        result.extend(tokens)\n    return result",
    ".sympy.parsing.sympy_parser.py@@auto_symbol": "def auto_symbol(tokens, local_dict, global_dict):\n    result = []\n    prevTok = (None, None)\n    tokens.append((None, None))\n    for tok, nextTok in zip(tokens, tokens[1:]):\n        tokNum, tokVal = tok\n        nextTokNum, nextTokVal = nextTok\n        if tokNum == NAME:\n            name = tokVal\n            if name in ['True', 'False', 'None'] or iskeyword(name) or name in local_dict or (prevTok[0] == OP and prevTok[1] == '.') or (prevTok[0] == OP and prevTok[1] in ('(', ',') and (nextTokNum == OP) and (nextTokVal == '=')):\n                result.append((NAME, name))\n                continue\n            elif name in global_dict:\n                obj = global_dict[name]\n                if isinstance(obj, (Basic, type)) or callable(obj):\n                    result.append((NAME, name))\n                    continue\n            result.extend([(NAME, 'Symbol'), (OP, '('), (NAME, repr(str(name))), (OP, ')')])\n        else:\n            result.append((tokNum, tokVal))\n        prevTok = (tokNum, tokVal)\n    return result",
    ".sympy.parsing.sympy_parser.py@@auto_number": "def auto_number(tokens, local_dict, global_dict):\n    result = []\n    prevtoken = ''\n    for toknum, tokval in tokens:\n        if toknum == NUMBER:\n            number = tokval\n            postfix = []\n            if number.endswith('j') or number.endswith('J'):\n                number = number[:-1]\n                postfix = [(OP, '*'), (NAME, 'I')]\n            if '.' in number or (('e' in number or 'E' in number) and (not (number.startswith('0x') or number.startswith('0X')))):\n                match = _re_repeated.match(number)\n                if match is not None:\n                    pre, post, repetend = match.groups()\n                    zeros = '0' * len(post)\n                    post, repetends = [w.lstrip('0') for w in [post, repetend]]\n                    a = pre or '0'\n                    b, c = (post or '0', '1' + zeros)\n                    d, e = (repetends, '9' * len(repetend) + zeros)\n                    seq = [(OP, '('), (NAME, 'Integer'), (OP, '('), (NUMBER, a), (OP, ')'), (OP, '+'), (NAME, 'Rational'), (OP, '('), (NUMBER, b), (OP, ','), (NUMBER, c), (OP, ')'), (OP, '+'), (NAME, 'Rational'), (OP, '('), (NUMBER, d), (OP, ','), (NUMBER, e), (OP, ')'), (OP, ')')]\n                else:\n                    seq = [(NAME, 'Float'), (OP, '('), (NUMBER, repr(str(number))), (OP, ')')]\n            else:\n                seq = [(NAME, 'Integer'), (OP, '('), (NUMBER, number), (OP, ')')]\n            result.extend(seq + postfix)\n        else:\n            result.append((toknum, tokval))\n    return result",
    ".sympy.parsing.sympy_parser.py@@factorial_notation": "def factorial_notation(tokens, local_dict, global_dict):\n    result = []\n    prevtoken = ''\n    for toknum, tokval in tokens:\n        if toknum == OP:\n            op = tokval\n            if op == '!!':\n                if prevtoken == '!' or prevtoken == '!!':\n                    raise TokenError\n                result = _add_factorial_tokens('factorial2', result)\n            elif op == '!':\n                if prevtoken == '!' or prevtoken == '!!':\n                    raise TokenError\n                result = _add_factorial_tokens('factorial', result)\n            else:\n                result.append((OP, op))\n        else:\n            result.append((toknum, tokval))\n        prevtoken = tokval\n    return result",
    ".sympy.parsing.sympy_parser.py@@convert_xor": "def convert_xor(tokens, local_dict, global_dict):\n    result = []\n    for toknum, tokval in tokens:\n        if toknum == OP:\n            if tokval == '^':\n                result.append((OP, '**'))\n            else:\n                result.append((toknum, tokval))\n        else:\n            result.append((toknum, tokval))\n    return result",
    ".sympy.parsing.sympy_tokenize.py@@untokenize": "def untokenize(iterable):\n    ut = Untokenizer()\n    return ut.untokenize(iterable)",
    ".sympy.parsing.sympy_tokenize.py@@Untokenizer.__init__": "def __init__(self):\n    self.tokens = []\n    self.prev_row = 1\n    self.prev_col = 0",
    ".sympy.parsing.sympy_tokenize.py@@Untokenizer.untokenize": "def untokenize(self, iterable):\n    for t in iterable:\n        if len(t) == 2:\n            self.compat(t, iterable)\n            break\n        tok_type, token, start, end, line = t\n        self.add_whitespace(start)\n        self.tokens.append(token)\n        self.prev_row, self.prev_col = end\n        if tok_type in (NEWLINE, NL):\n            self.prev_row += 1\n            self.prev_col = 0\n    return ''.join(self.tokens)",
    ".sympy.parsing.sympy_tokenize.py@@Untokenizer.compat": "def compat(self, token, iterable):\n    startline = False\n    indents = []\n    toks_append = self.tokens.append\n    toknum, tokval = token\n    if toknum in (NAME, NUMBER):\n        tokval += ' '\n    if toknum in (NEWLINE, NL):\n        startline = True\n    prevstring = False\n    for tok in iterable:\n        toknum, tokval = tok[:2]\n        if toknum in (NAME, NUMBER):\n            tokval += ' '\n        if toknum == STRING:\n            if prevstring:\n                tokval = ' ' + tokval\n            prevstring = True\n        else:\n            prevstring = False\n        if toknum == INDENT:\n            indents.append(tokval)\n            continue\n        elif toknum == DEDENT:\n            indents.pop()\n            continue\n        elif toknum in (NEWLINE, NL):\n            startline = True\n        elif startline and indents:\n            toks_append(indents[-1])\n            startline = False\n        toks_append(tokval)",
    ".sympy.parsing.sympy_parser.py@@eval_expr": "def eval_expr(code, local_dict, global_dict):\n    expr = eval(code, global_dict, local_dict)\n    return expr",
    ".sympy.core.basic.py@@Basic.rec_replace": "def rec_replace(expr):\n    result = _query(expr)\n    if result or result == {}:\n        new = _value(expr, result)\n        if new is not None and new != expr:\n            mapping[expr] = new\n            if simultaneous:\n                com = getattr(new, 'is_commutative', True)\n                if com is None:\n                    com = True\n                d = Dummy(commutative=com)\n                mask.append((d, new))\n                expr = d\n            else:\n                expr = new\n    return expr",
    ".sympy.functions.elementary.piecewise.py@@piecewise_fold": "def piecewise_fold(expr):\n    if not isinstance(expr, Basic) or not expr.has(Piecewise):\n        return expr\n    new_args = list(map(piecewise_fold, expr.args))\n    if expr.func is ExprCondPair:\n        return ExprCondPair(*new_args)\n    piecewise_args = []\n    for n, arg in enumerate(new_args):\n        if isinstance(arg, Piecewise):\n            piecewise_args.append(n)\n    if len(piecewise_args) > 0:\n        n = piecewise_args[0]\n        new_args = [(expr.func(*new_args[:n] + [e] + new_args[n + 1:]), c) for e, c in new_args[n].args]\n        if isinstance(expr, Boolean):\n            other = True\n            rtn = False\n            for e, c in new_args:\n                rtn = Or(rtn, And(other, c, e))\n                other = And(other, Not(c))\n            if len(piecewise_args) > 1:\n                return piecewise_fold(rtn)\n            return rtn\n        if len(piecewise_args) > 1:\n            return piecewise_fold(Piecewise(*new_args))\n        return Piecewise(*new_args)\n    else:\n        return expr.func(*new_args)",
    ".sympy.core.function.py@@expand_power_exp": "def expand_power_exp(expr, deep=True):\n    return sympify(expr).expand(deep=deep, complex=False, basic=False, log=False, mul=False, power_exp=True, power_base=False, multinomial=False)",
    ".sympy.core.rules.py@@Transform.__init__": "def __init__(self, transform, filter=lambda x: True):\n    self._transform = transform\n    self._filter = filter",
    ".sympy.core.rules.py@@Transform.__contains__": "def __contains__(self, item):\n    return self._filter(item)",
    ".sympy.core.symbol.py@@Symbol._hashable_content": "def _hashable_content(self):\n    return (self.name,) + tuple(sorted(self.assumptions0.items()))",
    ".sympy.core.symbol.py@@Symbol.assumptions0": "def assumptions0(self):\n    return dict(((key, value) for key, value in self._assumptions.items() if value is not None))",
    ".sympy.core.expr.py@@Expr.is_constant": "def is_constant(self, *wrt, **flags):\n    simplify = flags.get('simplify', True)\n    free = self.free_symbols\n    if self.is_number or not free:\n        assert not free\n        return True\n    wrt = set(wrt)\n    if wrt and (not wrt & free):\n        return True\n    wrt = wrt or free\n    expr = self\n    if simplify:\n        expr = expr.simplify()\n    if expr.is_zero:\n        return True\n    failing_number = None\n    if wrt == free:\n        try:\n            a = expr.subs(list(zip(free, [0] * len(free))), simultaneous=True)\n            if a is S.NaN:\n                a = expr._random(None, 0, 0, 0, 0)\n        except ZeroDivisionError:\n            a = None\n        if a is not None and a is not S.NaN:\n            try:\n                b = expr.subs(list(zip(free, [1] * len(free))), simultaneous=True)\n                if b is S.NaN:\n                    b = expr._random(None, 1, 0, 1, 0)\n            except ZeroDivisionError:\n                b = None\n            if b is not None and b is not S.NaN and (b.equals(a) is False):\n                return False\n            b = expr._random(None, -1, 0, 1, 0)\n            if b is not None and b is not S.NaN and (b.equals(a) is False):\n                return False\n            b = expr._random()\n            if b is not None and b is not S.NaN:\n                if b.equals(a) is False:\n                    return False\n                failing_number = a if a.is_number else b\n    for w in wrt:\n        deriv = expr.diff(w)\n        if simplify:\n            deriv = deriv.simplify()\n        if deriv != 0:\n            if not pure_complex(deriv, or_real=True):\n                if flags.get('failing_number', False):\n                    return failing_number\n                elif deriv.free_symbols:\n                    return None\n            return False\n    return True",
    ".sympy.core.basic.py@@Basic.free_symbols": "def free_symbols(self):\n    return set().union(*[a.free_symbols for a in self.args])",
    ".sympy.core.symbol.py@@Symbol.free_symbols": "def free_symbols(self):\n    return {self}",
    ".sympy.core.basic.py@@Basic.subs": "def subs(self, *args, **kwargs):\n    from sympy.core.containers import Dict\n    from sympy.utilities import default_sort_key\n    from sympy import Dummy, Symbol\n    unordered = False\n    if len(args) == 1:\n        sequence = args[0]\n        if isinstance(sequence, set):\n            unordered = True\n        elif isinstance(sequence, (Dict, Mapping)):\n            unordered = True\n            sequence = sequence.items()\n        elif not iterable(sequence):\n            from sympy.utilities.misc import filldedent\n            raise ValueError(filldedent('\\n               When a single argument is passed to subs\\n               it should be a dictionary of old: new pairs or an iterable\\n               of (old, new) tuples.'))\n    elif len(args) == 2:\n        sequence = [args]\n    else:\n        raise ValueError('subs accepts either 1 or 2 arguments')\n    sequence = list(sequence)\n    for i in range(len(sequence)):\n        s = list(sequence[i])\n        for j, si in enumerate(s):\n            try:\n                si = sympify(si, strict=True)\n            except SympifyError:\n                if type(si) is str:\n                    si = Symbol(si)\n                else:\n                    sequence[i] = None\n                    break\n            s[j] = si\n        else:\n            sequence[i] = None if _aresame(*s) else tuple(s)\n    sequence = list(filter(None, sequence))\n    if unordered:\n        sequence = dict(sequence)\n        if not all((k.is_Atom for k in sequence)):\n            d = {}\n            for o, n in sequence.items():\n                try:\n                    ops = (o.count_ops(), len(o.args))\n                except TypeError:\n                    ops = (0, 0)\n                d.setdefault(ops, []).append((o, n))\n            newseq = []\n            for k in sorted(d.keys(), reverse=True):\n                newseq.extend(sorted([v[0] for v in d[k]], key=default_sort_key))\n            sequence = [(k, sequence[k]) for k in newseq]\n            del newseq, d\n        else:\n            sequence = sorted([(k, v) for k, v in sequence.items()], key=default_sort_key)\n    if kwargs.pop('simultaneous', False):\n        reps = {}\n        rv = self\n        kwargs['hack2'] = True\n        m = Dummy()\n        for old, new in sequence:\n            d = Dummy(commutative=new.is_commutative)\n            rv = rv._subs(old, d * m, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n            reps[d] = new\n        reps[m] = S.One\n        return rv.xreplace(reps)\n    else:\n        rv = self\n        for old, new in sequence:\n            rv = rv._subs(old, new, **kwargs)\n            if not isinstance(rv, Basic):\n                break\n        return rv",
    ".sympy.core.basic.py@@_aresame": "def _aresame(a, b):\n    from .function import AppliedUndef, UndefinedFunction as UndefFunc\n    for i, j in zip_longest(preorder_traversal(a), preorder_traversal(b)):\n        if i != j or type(i) != type(j):\n            if isinstance(i, UndefFunc) and isinstance(j, UndefFunc) or (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef)):\n                if i.class_key() != j.class_key():\n                    return False\n            else:\n                return False\n    else:\n        return True",
    ".sympy.core.symbol.py@@Dummy.__new__": "def __new__(cls, name=None, **assumptions):\n    if name is None:\n        name = 'Dummy_' + str(Dummy._count)\n    cls._sanitize(assumptions, cls)\n    obj = Symbol.__xnew__(cls, name, **assumptions)\n    Dummy._count += 1\n    obj.dummy_index = Dummy._count\n    return obj",
    ".sympy.core.symbol.py@@Dummy._hashable_content": "def _hashable_content(self):\n    return Symbol._hashable_content(self) + (self.dummy_index,)",
    ".sympy.core.basic.py@@Basic._subs": "def _subs(self, old, new, **hints):\n\n    def fallback(self, old, new):\n        hit = False\n        args = list(self.args)\n        for i, arg in enumerate(args):\n            if not hasattr(arg, '_eval_subs'):\n                continue\n            arg = arg._subs(old, new, **hints)\n            if not _aresame(arg, args[i]):\n                hit = True\n                args[i] = arg\n        if hit:\n            rv = self.func(*args)\n            hack2 = hints.get('hack2', False)\n            if hack2 and self.is_Mul and (not rv.is_Mul):\n                coeff = S.One\n                nonnumber = []\n                for i in args:\n                    if i.is_Number:\n                        coeff *= i\n                    else:\n                        nonnumber.append(i)\n                nonnumber = self.func(*nonnumber)\n                if coeff is S.One:\n                    return nonnumber\n                else:\n                    return self.func(coeff, nonnumber, evaluate=False)\n            return rv\n        return self\n    if _aresame(self, old):\n        return new\n    rv = self._eval_subs(old, new)\n    if rv is None:\n        rv = fallback(self, old, new)\n    return rv",
    ".sympy.core.add.py@@Add._eval_subs": "def _eval_subs(self, old, new):\n    if not old.is_Add:\n        return None\n    coeff_self, terms_self = self.as_coeff_Add()\n    coeff_old, terms_old = old.as_coeff_Add()\n    if coeff_self.is_Rational and coeff_old.is_Rational:\n        if terms_self == terms_old:\n            return self.func(new, coeff_self, -coeff_old)\n        if terms_self == -terms_old:\n            return self.func(-new, coeff_self, coeff_old)\n    if coeff_self.is_Rational and coeff_old.is_Rational or coeff_self == coeff_old:\n        args_old, args_self = (self.func.make_args(terms_old), self.func.make_args(terms_self))\n        if len(args_old) < len(args_self):\n            self_set = set(args_self)\n            old_set = set(args_old)\n            if old_set < self_set:\n                ret_set = self_set - old_set\n                return self.func(new, coeff_self, -coeff_old, *[s._subs(old, new) for s in ret_set])\n            args_old = self.func.make_args(-terms_old)\n            old_set = set(args_old)\n            if old_set < self_set:\n                ret_set = self_set - old_set\n                return self.func(-new, coeff_self, coeff_old, *[s._subs(old, new) for s in ret_set])",
    ".sympy.core.basic.py@@Basic.fallback": "def fallback(self, old, new):\n    hit = False\n    args = list(self.args)\n    for i, arg in enumerate(args):\n        if not hasattr(arg, '_eval_subs'):\n            continue\n        arg = arg._subs(old, new, **hints)\n        if not _aresame(arg, args[i]):\n            hit = True\n            args[i] = arg\n    if hit:\n        rv = self.func(*args)\n        hack2 = hints.get('hack2', False)\n        if hack2 and self.is_Mul and (not rv.is_Mul):\n            coeff = S.One\n            nonnumber = []\n            for i in args:\n                if i.is_Number:\n                    coeff *= i\n                else:\n                    nonnumber.append(i)\n            nonnumber = self.func(*nonnumber)\n            if coeff is S.One:\n                return nonnumber\n            else:\n                return self.func(coeff, nonnumber, evaluate=False)\n        return rv\n    return self",
    ".sympy.core.numbers.py@@Integer.__ne__": "def __ne__(self, other):\n    return not self.__eq__(other)",
    ".sympy.core.numbers.py@@Number._eval_subs": "def _eval_subs(self, old, new):\n    if old == -self:\n        return -new\n    return self",
    ".sympy.logic.boolalg.py@@Or._new_args_filter": "def _new_args_filter(cls, args):\n    newargs = []\n    rel = []\n    for x in args:\n        if isinstance(x, Number) or x in (0, 1):\n            newargs.append(True if x else False)\n            continue\n        if x.is_Relational:\n            c = x.canonical\n            if c in rel:\n                continue\n            nc = (~c).canonical\n            if any((r == nc for r in rel)):\n                return [S.true]\n            rel.append(c)\n        newargs.append(x)\n    return LatticeOp._new_args_filter(newargs, Or)",
    ".sympy.core.numbers.py@@Rational.__lt__": "def __lt__(self, other):\n    try:\n        other = _sympify(other)\n    except SympifyError:\n        raise TypeError('Invalid comparison %s < %s' % (self, other))\n    if isinstance(other, NumberSymbol):\n        return other.__ge__(self)\n    expr = self\n    if isinstance(other, Number):\n        if isinstance(other, Rational):\n            return _sympify(bool(self.p * other.q < self.q * other.p))\n        if isinstance(other, Float):\n            return _sympify(bool(mlib.mpf_lt(self._as_mpf_val(other._prec), other._mpf_)))\n    elif other.is_number and other.is_real:\n        expr, other = (Integer(self.p), self.q * other)\n    return Expr.__lt__(expr, other)"
}