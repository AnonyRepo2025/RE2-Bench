{
    ".django.middleware.csrf.py@@_sanitize_token": "def _sanitize_token(token):\n    if len(token) not in (CSRF_TOKEN_LENGTH, CSRF_SECRET_LENGTH):\n        raise InvalidTokenFormat(REASON_INCORRECT_LENGTH)\n    if invalid_token_chars_re.search(token):\n        raise InvalidTokenFormat(REASON_INVALID_CHARACTERS)\n    if len(token) == CSRF_SECRET_LENGTH:\n        return _mask_cipher_secret(token)\n    return token",
    ".django.utils.functional.py@@inner": "def inner(self, *args):\n    if self._wrapped is empty:\n        self._setup()\n    return func(self._wrapped, *args)",
    ".django.middleware.csrf.py@@InvalidTokenFormat.__init__": "def __init__(self, reason):\n    self.reason = reason",
    ".django.http.request.py@@HttpRequest.get_host": "def get_host(self):\n    host = self._get_raw_host()\n    allowed_hosts = settings.ALLOWED_HOSTS\n    if settings.DEBUG and (not allowed_hosts):\n        allowed_hosts = ['.localhost', '127.0.0.1', '[::1]']\n    domain, port = split_domain_port(host)\n    if domain and validate_host(domain, allowed_hosts):\n        return host\n    else:\n        msg = 'Invalid HTTP_HOST header: %r.' % host\n        if domain:\n            msg += ' You may need to add %r to ALLOWED_HOSTS.' % domain\n        else:\n            msg += ' The domain name provided is not valid according to RFC 1034/1035.'\n        raise DisallowedHost(msg)",
    ".django.http.request.py@@HttpRequest._get_raw_host": "def _get_raw_host(self):\n    if settings.USE_X_FORWARDED_HOST and 'HTTP_X_FORWARDED_HOST' in self.META:\n        host = self.META['HTTP_X_FORWARDED_HOST']\n    elif 'HTTP_HOST' in self.META:\n        host = self.META['HTTP_HOST']\n    else:\n        host = self.META['SERVER_NAME']\n        server_port = self.get_port()\n        if server_port != ('443' if self.is_secure() else '80'):\n            host = '%s:%s' % (host, server_port)\n    return host",
    ".django.http.request.py@@split_domain_port": "def split_domain_port(host):\n    host = host.lower()\n    if not host_validation_re.match(host):\n        return ('', '')\n    if host[-1] == ']':\n        return (host, '')\n    bits = host.rsplit(':', 1)\n    domain, port = bits if len(bits) == 2 else (bits[0], '')\n    domain = domain[:-1] if domain.endswith('.') else domain\n    return (domain, port)",
    ".django.http.request.py@@validate_host": "def validate_host(host, allowed_hosts):\n    return any((pattern == '*' or is_same_domain(host, pattern) for pattern in allowed_hosts))",
    ".django.utils.http.py@@is_same_domain": "def is_same_domain(host, pattern):\n    if not pattern:\n        return False\n    pattern = pattern.lower()\n    return pattern[0] == '.' and (host.endswith(pattern) or host == pattern[1:]) or pattern == host",
    ".django.middleware.csrf.py@@_mask_cipher_secret": "def _mask_cipher_secret(secret):\n    mask = _get_new_csrf_string()\n    chars = CSRF_ALLOWED_CHARS\n    pairs = zip((chars.index(x) for x in secret), (chars.index(x) for x in mask))\n    cipher = ''.join((chars[(x + y) % len(chars)] for x, y in pairs))\n    return mask + cipher",
    ".django.middleware.csrf.py@@_get_new_csrf_string": "def _get_new_csrf_string():\n    return get_random_string(CSRF_SECRET_LENGTH, allowed_chars=CSRF_ALLOWED_CHARS)",
    ".django.utils.crypto.py@@get_random_string": "def get_random_string(length, allowed_chars=RANDOM_STRING_CHARS):\n    return ''.join((secrets.choice(allowed_chars) for i in range(length)))",
    ".django.utils.datastructures.py@@MultiValueDict.get": "def get(self, key, default=None):\n    try:\n        val = self[key]\n    except KeyError:\n        return default\n    if val == []:\n        return default\n    return val",
    ".django.utils.datastructures.py@@MultiValueDict.__getitem__": "def __getitem__(self, key):\n    try:\n        list_ = super().__getitem__(key)\n    except KeyError:\n        raise MultiValueDictKeyError(key)\n    try:\n        return list_[-1]\n    except IndexError:\n        return []",
    ".django.middleware.csrf.py@@_compare_masked_tokens": "def _compare_masked_tokens(request_csrf_token, csrf_token):\n    return constant_time_compare(_unmask_cipher_token(request_csrf_token), _unmask_cipher_token(csrf_token))",
    ".django.middleware.csrf.py@@_unmask_cipher_token": "def _unmask_cipher_token(token):\n    mask = token[:CSRF_SECRET_LENGTH]\n    token = token[CSRF_SECRET_LENGTH:]\n    chars = CSRF_ALLOWED_CHARS\n    pairs = zip((chars.index(x) for x in token), (chars.index(x) for x in mask))\n    return ''.join((chars[x - y] for x, y in pairs))",
    ".django.utils.crypto.py@@constant_time_compare": "def constant_time_compare(val1, val2):\n    return secrets.compare_digest(force_bytes(val1), force_bytes(val2))",
    ".django.utils.encoding.py@@force_bytes": "def force_bytes(s, encoding='utf-8', strings_only=False, errors='strict'):\n    if isinstance(s, bytes):\n        if encoding == 'utf-8':\n            return s\n        else:\n            return s.decode('utf-8', errors).encode(encoding, errors)\n    if strings_only and is_protected_type(s):\n        return s\n    if isinstance(s, memoryview):\n        return bytes(s)\n    return str(s).encode(encoding, errors)",
    ".django.conf.__init__.py@@LazySettings.__getattr__": "def __getattr__(self, name):\n    if self._wrapped is empty:\n        self._setup(name)\n    val = getattr(self._wrapped, name)\n    if name in {'MEDIA_URL', 'STATIC_URL'} and val is not None:\n        val = self._add_script_prefix(val)\n    elif name == 'SECRET_KEY' and (not val):\n        raise ImproperlyConfigured('The SECRET_KEY setting must not be empty.')\n    self.__dict__[name] = val\n    return val",
    ".django.conf.__init__.py@@UserSettingsHolder.__getattr__": "def __getattr__(self, name):\n    if not name.isupper() or name in self._deleted:\n        raise AttributeError\n    return getattr(self.default_settings, name)",
    ".django.utils.functional.py@@cached_property.__get__": "def __get__(self, instance, cls=None):\n    if instance is None:\n        return self\n    res = instance.__dict__[self.name] = self.func(instance)\n    return res",
    ".django.middleware.csrf.py@@RejectRequest.__init__": "def __init__(self, reason):\n    self.reason = reason",
    ".django.http.request.py@@HttpRequest.get_port": "def get_port(self):\n    if settings.USE_X_FORWARDED_PORT and 'HTTP_X_FORWARDED_PORT' in self.META:\n        port = self.META['HTTP_X_FORWARDED_PORT']\n    else:\n        port = self.META['SERVER_PORT']\n    return str(port)",
    ".django.http.request.py@@HttpRequest.is_secure": "def is_secure(self):\n    return self.scheme == 'https'",
    ".django.http.request.py@@HttpRequest.scheme": "def scheme(self):\n    if settings.SECURE_PROXY_SSL_HEADER:\n        try:\n            header, secure_value = settings.SECURE_PROXY_SSL_HEADER\n        except ValueError:\n            raise ImproperlyConfigured('The SECURE_PROXY_SSL_HEADER setting must be a tuple containing two values.')\n        header_value = self.META.get(header)\n        if header_value is not None:\n            return 'https' if header_value == secure_value else 'http'\n    return self._get_scheme()",
    ".django.http.request.py@@HttpRequest._get_scheme": "def _get_scheme(self):\n    return 'http'",
    ".django.contrib.sessions.backends.base.py@@SessionBase.get": "def get(self, key, default=None):\n    return self._session.get(key, default)",
    ".django.contrib.sessions.backends.base.py@@SessionBase._get_session": "def _get_session(self, no_load=False):\n    self.accessed = True\n    try:\n        return self._session_cache\n    except AttributeError:\n        if self.session_key is None or no_load:\n            self._session_cache = {}\n        else:\n            self._session_cache = self.load()\n    return self._session_cache",
    ".django.contrib.sessions.backends.base.py@@SessionBase._get_session_key": "def _get_session_key(self):\n    return self.__session_key"
}