{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "z": "0"}, "kwargs": {}}, "return": "0"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": {"nargs": {"_elements": "np.ndarray[frozenset]"}}}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "z": "1"}, "kwargs": {}}, "return": {"nargs": {"_elements": "frozenset({1, 2})"}}}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "z": "-1"}, "kwargs": {}}, "return": "-dirichlet_eta(s)"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "0"}, "kwargs": {}}, "return": "z/(-z + 1)"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "-1"}, "kwargs": {}}, "return": "z/(-z + 1)**2"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "2", "z": "2"}, "kwargs": {}}, "return": "pi**2/4 - I*pi*log(2)"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "np.ndarray[float64]"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "2", "z": "1/2"}, "kwargs": {}}, "return": "-\"log(2)\"**2/2 + pi**2/12"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "2", "z": "-1/2 + \"sqrt(5)\"/2"}, "kwargs": {}}, "return": "-\"log(-1/2 + sqrt(5)\"/2)**2 + pi**2/10"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "2", "z": "-\"sqrt(5)\"/2 + 1/2"}, "kwargs": {}}, "return": "-pi**2/15 + \"log(-1/2 + sqrt(5)\"/2)**2/2"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "2", "z": "-\"sqrt(5)\"/2 - 1/2"}, "kwargs": {}}, "return": "-pi**2/10 - \"log(1/2 + sqrt(5)\"/2)**2"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "2", "z": "-\"sqrt(5)\"/2 + 3/2"}, "kwargs": {}}, "return": "-\"log(-1/2 + sqrt(5)\"/2)**2 + pi**2/15"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "-1", "z": "2.62286865390724 - 3.36469617908131*I"}, "kwargs": {}}, "return": "(2.62286865390724 - 3.36469617908131*I)/(-1.62286865390724 + 3.36469617908131*I)**2"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "-1", "z": "0.394134167113744 + 2.0813039750498*I"}, "kwargs": {}}, "return": "(0.394134167113744 + 2.0813039750498*I)/(0.605865832886256 - 2.0813039750498*I)**2"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "-1", "z": "-3.05847689309881 - 1.11804166502419*I"}, "kwargs": {}}, "return": "(-3.05847689309881 - 1.11804166502419*I)/(4.05847689309881 + 1.11804166502419*I)**2"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "-1", "z": "-2.40445312580302 + 2.41544082133383*I"}, "kwargs": {}}, "return": "(-2.40445312580302 + 2.41544082133383*I)/(3.40445312580302 - 2.41544082133383*I)**2"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "-1", "z": "1.90238581500662 - 3.08191999940609*I"}, "kwargs": {}}, "return": "(1.90238581500662 - 3.08191999940609*I)/(-0.902385815006625 + 3.08191999940609*I)**2"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "-1", "z": "-4.8892244524251 + 0.300189656081857*I"}, "kwargs": {}}, "return": "(-4.8892244524251 + 0.300189656081857*I)/(5.8892244524251 - 0.300189656081857*I)**2"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "-1", "z": "1.82942969216746 - 1.63740464571022*I"}, "kwargs": {}}, "return": "(1.82942969216746 - 1.63740464571022*I)/(-0.829429692167455 + 1.63740464571022*I)**2"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "-1", "z": "0.690506575511471 + 3.28201621802963*I"}, "kwargs": {}}, "return": "(0.690506575511471 + 3.28201621802963*I)/(0.309493424488529 - 3.28201621802963*I)**2"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "-1", "z": "3.34604243765792 + 0.779323325037355*I"}, "kwargs": {}}, "return": "(3.34604243765792 + 0.779323325037355*I)/(-2.34604243765792 - 0.779323325037355*I)**2"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "-1", "z": "2.24364199262875 + 1.92903348307435*I"}, "kwargs": {}}, "return": "(2.24364199262875 + 1.92903348307435*I)/(-1.24364199262875 - 1.92903348307435*I)**2"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "0", "z": "-0.081965767872715 + 1.88254613713731*I"}, "kwargs": {}}, "return": "0.212105727316282*(-0.081965767872715 + 1.88254613713731*I)*(1.08196576787272 + 1.88254613713731*I)"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "0", "z": "0.156829176968261 - 0.382008879518118*I"}, "kwargs": {}}, "return": "1.16704114179072*(0.156829176968261 - 0.382008879518118*I)*(0.843170823031739 - 0.382008879518118*I)"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "0", "z": "-2.31491139564576 + 3.75039318156248*I"}, "kwargs": {}}, "return": "0.0399136482950586*(-2.31491139564576 + 3.75039318156248*I)*(3.31491139564576 + 3.75039318156248*I)"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "0", "z": "-0.664219007544339 - 2.57022691867366*I"}, "kwargs": {}}, "return": "0.106658801577847*(-0.664219007544339 - 2.57022691867366*I)*(1.66421900754434 - 2.57022691867366*I)"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "0", "z": "-1.8068270555267 + 3.63871825130823*I"}, "kwargs": {}}, "return": "0.0473517388634763*(-1.8068270555267 + 3.63871825130823*I)*(2.8068270555267 + 3.63871825130823*I)"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "0", "z": "4.32590742277828 + 3.49971155144464*I"}, "kwargs": {}}, "return": "0.0429007033827695*(-3.32590742277828 + 3.49971155144464*I)*(4.32590742277828 + 3.49971155144464*I)"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "0", "z": "3.70554011863948 + 4.43981829966092*I"}, "kwargs": {}}, "return": "0.0369932837546495*(-2.70554011863948 + 4.43981829966092*I)*(3.70554011863948 + 4.43981829966092*I)"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "0", "z": "-4.99126105042558 - 3.32803718569061*I"}, "kwargs": {}}, "return": "0.0212897136129509*(-4.99126105042558 - 3.32803718569061*I)*(5.99126105042558 - 3.32803718569061*I)"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "0", "z": "-4.14832674002273 + 3.13548338447933*I"}, "kwargs": {}}, "return": "0.0275205188144553*(-4.14832674002273 + 3.13548338447933*I)*(5.14832674002273 + 3.13548338447933*I)"}, "name": "eval"}
{"types": {"inputs": {"self": "in ground truth values, it is an empty dict", "args": {"cls": {"__module__": "str", "__doc__": "str", "eval": "in ground truth values, it is an empty dict", "fdiff": "in ground truth values, it is an empty dict", "_eval_rewrite_as_lerchphi": "in ground truth values, it is an empty dict", "_eval_expand_func": "in ground truth values, it is an empty dict", "_explicit_class_assumptions": "in ground truth values, it is an empty dict", "default_assumptions": {"_generator": "in ground truth values, it is an empty dict"}, "_prop_handler": {"negative": "in ground truth values, it is an empty dict", "commutative": "in ground truth values, it is an empty dict", "positive": "in ground truth values, it is an empty dict", "complex": "in ground truth values, it is an empty dict"}, "_nargs": "null value in the ground truth"}, "s": "str", "z": "str"}, "kwargs": "in ground truth values, it is an empty dict"}, "return": "str"}, "values": {"inputs": {"self": {}, "args": {"cls": {"__module__": "sympy.functions.special.zeta_functions", "__doc__": "\n    Polylogarithm function.\n\n    For :math:`|z| \"< 1` and :math:`s \\in \\mathbb{C}`, the polylogarithm is\n    defined by\n\n    .. math:: \\operatorname{Li}\"_s(z)\" = \\sum_{n=1}^\\infty \\frac{z^n}{n^s},\n\n    where the standard branch of the argument is used for :math:`n`. It admits\n    an analytic continuation which is branched at :math:`z=1` (notably not on the\n    sheet of initial definition), :math:`z=0` and :math:`z=\\infty`.\n\n    The name polylogarithm comes from the fact that for :math:`s=1`, the\n    polylogarithm is related to the ordinary \"logarithm (see examples)\", and that\n\n    .. math:: \\operatorname{Li}_{s+1}(z) =\n                    \\int_0^z \\frac{\\operatorname{Li}\"_s(t)\"}{t} \\mathrm{d}t.\n\n    The polylogarithm is a special case of the Lerch transcendent:\n\n    .. math:: \\operatorname{Li}_{s}(z) = z \\\"Phi(z, s, 1)\"\n\n    See Also\n    ========\n\n    zeta, lerchphi\n\n    Examples\n    ========\n\n    For :math:`z \\in \\{0, 1, -1\\}`, the polylogarithm is automatically expressed\n    using other functions:\n\n    >\">> from sympy import polylog\n    >>> from sympy.abc import s\n    >>> \"polylog(s, 0)\"\n    0\n    >>> \"polylog(s, 1)\"\n    \"zeta(s)\"\n    >>> \"polylog(s, -1)\"\n    -\"dirichlet_eta(s)\"\n\n    If :math:`s` is a negative integer, :math:`0` or :math:`1`, the\n    polylogarithm can be expressed using elementary functions. This can be\n    done using \"expand_func()\":\n\n    >>> from sympy import expand_func\n    >>> from sympy.abc import z\n    >>> \"expand_func(polylog(1, z)\")\n    -\"log(-z + 1)\"\n    >>> \"expand_func(polylog(0, z)\")\n    z/(-z + 1)\n\n    The derivative with respect to :math:`z` can be computed in closed form:\n\n    >>> \"polylog(s, z)\".\"diff(z)\"\n    \"polylog(s - 1, z)\"/z\n\n    The polylogarithm can be expressed in terms of the lerch transcendent:\n\n    >>> from sympy import lerchphi\n    >>> \"polylog(s, z)\".\"rewrite(lerchphi)\"\n    z*\"lerchphi(z, s, 1)\"\n    ", "eval": {}, "fdiff": {}, "_eval_rewrite_as_lerchphi": {}, "_eval_expand_func": {}, "_explicit_class_assumptions": {}, "default_assumptions": {"_generator": {}}, "_prop_handler": {"negative": {}, "commutative": {}, "positive": {}, "complex": {}}, "_nargs": null}, "s": "0", "z": "2.61385066075106 - 2.25776733480031*I"}, "kwargs": {}}, "return": "0.129835946033348*(-1.61385066075106 - 2.25776733480031*I)*(2.61385066075106 - 2.25776733480031*I)"}, "name": "eval"}
