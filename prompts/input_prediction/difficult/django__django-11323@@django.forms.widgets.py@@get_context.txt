You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided output (between [OUTPUT] and [\OUTPUT]) and predict the input of the function. Both input and output are presented in a JSON format. The input structure is defined between [STRUCTURE] and [\STRUCTURE]. You only need to predict input variable values to fill out placeholders XXX in the structure, and print input between [INPUT] and [\INPUT]. You should maintain the structure when printing inputs. Do not change anything else. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT].
[EXAMPLE]
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )
[/PYTHON]
What will be the input of `mktemp`, given the following output:
[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": XXX,
            "_trace": XXX,
            "_basetemp": XXX
        }
    },
    "args": {
        "basename": XXX
    },
    "kwargs": XXX
}
```
[/STRUCTURE]

[THOUGHT]
1. To get ".../world0", we need:
basename == "world", and self.getbasetemp() to be exactly "/tmp/pytest-of-root/pytest-0/test_mktemp0".
2. Make `getbasetemp()` return that exact base directory.`getbasetemp()` returns `_given_basetemp` if it is not None. So I set `_given_basetemp` to "/tmp/pytest-of-root/pytest-0/test_mktemp0" and _basetemp to None.
3. Ensure the numbered suffix is 0.
`make_numbered_dir` scans existing children with the given prefix and picks max_existing + 1. If none exist, it creates <prefix>0. To align with world0, we assume thereâ€™s no existing world* folder under the base; thus the first created is world0.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
import copy
import datetime
import re
import warnings
from collections import defaultdict
from itertools import chain
from django.conf import settings
from django.forms.utils import to_current_timezone
from django.templatetags.static import static
from django.utils import datetime_safe, formats
from django.utils.datastructures import OrderedSet
from django.utils.dates import MONTHS
from django.utils.formats import get_format
from django.utils.html import format_html, html_safe
from django.utils.safestring import mark_safe
from django.utils.topological_sort import CyclicDependencyError, stable_topological_sort
from django.utils.translation import gettext_lazy as _
from .renderers import get_default_renderer
__all__ = ('Media', 'MediaDefiningClass', 'Widget', 'TextInput', 'NumberInput', 'EmailInput', 'URLInput', 'PasswordInput', 'HiddenInput', 'MultipleHiddenInput', 'FileInput', 'ClearableFileInput', 'Textarea', 'DateInput', 'DateTimeInput', 'TimeInput', 'CheckboxInput', 'Select', 'NullBooleanSelect', 'SelectMultiple', 'RadioSelect', 'CheckboxSelectMultiple', 'MultiWidget', 'SplitDateTimeWidget', 'SplitHiddenDateTimeWidget', 'SelectDateWidget')
MEDIA_TYPES = ('css', 'js')
FILE_INPUT_CONTRADICTION = object()

class SelectDateWidget(Widget):
    none_value = ('', '---')
    month_field = '%s_month'
    day_field = '%s_day'
    year_field = '%s_year'
    template_name = 'django/forms/widgets/select_date.html'
    input_type = 'select'
    select_widget = Select
    date_re = re.compile('(\\d{4}|0)-(\\d\\d?)-(\\d\\d?)$')

    def get_context(self, name, value, attrs):
        context = super().get_context(name, value, attrs)
        date_context = {}
        year_choices = [(i, str(i)) for i in self.years]
        if not self.is_required:
            year_choices.insert(0, self.year_none_value)
        year_name = self.year_field % name
        date_context['year'] = self.select_widget(attrs, choices=year_choices).get_context(name=year_name, value=context['widget']['value']['year'], attrs={**context['widget']['attrs'], 'id': 'id_%s' % year_name, 'placeholder': _('Year') if self.is_required else False})
        month_choices = list(self.months.items())
        if not self.is_required:
            month_choices.insert(0, self.month_none_value)
        month_name = self.month_field % name
        date_context['month'] = self.select_widget(attrs, choices=month_choices).get_context(name=month_name, value=context['widget']['value']['month'], attrs={**context['widget']['attrs'], 'id': 'id_%s' % month_name, 'placeholder': _('Month') if self.is_required else False})
        day_choices = [(i, i) for i in range(1, 32)]
        if not self.is_required:
            day_choices.insert(0, self.day_none_value)
        day_name = self.day_field % name
        date_context['day'] = self.select_widget(attrs, choices=day_choices).get_context(name=day_name, value=context['widget']['value']['day'], attrs={**context['widget']['attrs'], 'id': 'id_%s' % day_name, 'placeholder': _('Day') if self.is_required else False})
        subwidgets = []
        for field in self._parse_date_fmt():
            subwidgets.append(date_context[field]['widget'])
        context['widget']['subwidgets'] = subwidgets
        return context

    def format_value(self, value):
        year, month, day = (None, None, None)
        if isinstance(value, (datetime.date, datetime.datetime)):
            year, month, day = (value.year, value.month, value.day)
        elif isinstance(value, str):
            match = self.date_re.match(value)
            if match:
                year, month, day = [int(val) or '' for val in match.groups()]
            elif settings.USE_L10N:
                input_format = get_format('DATE_INPUT_FORMATS')[0]
                try:
                    d = datetime.datetime.strptime(value, input_format)
                except ValueError:
                    pass
                else:
                    year, month, day = (d.year, d.month, d.day)
        return {'year': year, 'month': month, 'day': day}
[/PYTHON]

Functions called during the execution:
[PYTHON]
.django.forms.widgets.Widget.get_context

def get_context(self, name, value, attrs):
    context = {}
    context['widget'] = {'name': name, 'is_hidden': self.is_hidden, 'required': self.is_required, 'value': self.format_value(value), 'attrs': self.build_attrs(self.attrs, attrs), 'template_name': self.template_name}
    return context

.django.forms.widgets.Widget.is_hidden

def is_hidden(self):
    return self.input_type == 'hidden' if hasattr(self, 'input_type') else False

.django.conf.__init__.LazySettings.__getattr__

def __getattr__(self, name):
    if self._wrapped is empty:
        self._setup(name)
    val = getattr(self._wrapped, name)
    self.__dict__[name] = val
    return val

.django.forms.widgets.Widget.build_attrs

def build_attrs(self, base_attrs, extra_attrs=None):
    return {**base_attrs, **(extra_attrs or {})}

.django.utils.formats.get_format

def get_format(format_type, lang=None, use_l10n=None):
    use_l10n = use_l10n or (use_l10n is None and settings.USE_L10N)
    if use_l10n and lang is None:
        lang = get_language()
    cache_key = (format_type, lang)
    try:
        return _format_cache[cache_key]
    except KeyError:
        pass
    val = None
    if use_l10n:
        for module in get_format_modules(lang):
            val = getattr(module, format_type, None)
            if val is not None:
                break
    if val is None:
        if format_type not in FORMAT_SETTINGS:
            return format_type
        val = getattr(settings, format_type)
    elif format_type in ISO_INPUT_FORMATS:
        val = list(val)
        for iso_input in ISO_INPUT_FORMATS.get(format_type, ()):
            if iso_input not in val:
                val.append(iso_input)
    _format_cache[cache_key] = val
    return val

.django.utils.translation.__init__.get_language

def get_language():
    return _trans.get_language()

.django.utils.translation.trans_real.get_language

def get_language():
    t = getattr(_active, 'value', None)
    if t is not None:
        try:
            return t.to_language()
        except AttributeError:
            pass
    return settings.LANGUAGE_CODE

.django.utils.translation.trans_real.DjangoTranslation.to_language

def to_language(self):
    return self.__to_language

.django.utils.formats.get_format_modules

def get_format_modules(lang=None, reverse=False):
    if lang is None:
        lang = get_language()
    if lang not in _format_modules_cache:
        _format_modules_cache[lang] = list(iter_format_modules(lang, settings.FORMAT_MODULE_PATH))
    modules = _format_modules_cache[lang]
    if reverse:
        return list(reversed(modules))
    return modules

.django.conf.__init__.UserSettingsHolder.__getattr__

def __getattr__(self, name):
    if not name.isupper() or name in self._deleted:
        raise AttributeError
    return getattr(self.default_settings, name)

.django.utils.formats.iter_format_modules

def iter_format_modules(lang, format_module_path=None):
    if not check_for_language(lang):
        return
    if format_module_path is None:
        format_module_path = settings.FORMAT_MODULE_PATH
    format_locations = []
    if format_module_path:
        if isinstance(format_module_path, str):
            format_module_path = [format_module_path]
        for path in format_module_path:
            format_locations.append(path + '.%s')
    format_locations.append('django.conf.locale.%s')
    locale = to_locale(lang)
    locales = [locale]
    if '_' in locale:
        locales.append(locale.split('_')[0])
    for location in format_locations:
        for loc in locales:
            try:
                yield import_module('%s.formats' % (location % loc))
            except ImportError:
                pass

.django.utils.translation.__init__.check_for_language

def check_for_language(lang_code):
    return _trans.check_for_language(lang_code)

.django.utils.translation.trans_real.check_for_language

def check_for_language(lang_code):
    if lang_code is None or not language_code_re.search(lang_code):
        return False
    return any((gettext_module.find('django', path, [to_locale(lang_code)]) is not None for path in all_locale_paths()))

.django.utils.translation.trans_real.all_locale_paths

def all_locale_paths():
    globalpath = os.path.join(os.path.dirname(sys.modules[settings.__module__].__file__), 'locale')
    app_paths = []
    for app_config in apps.get_app_configs():
        locale_path = os.path.join(app_config.path, 'locale')
        if os.path.exists(locale_path):
            app_paths.append(locale_path)
    return [globalpath, *settings.LOCALE_PATHS, *app_paths]

.django.apps.registry.Apps.get_app_configs

def get_app_configs(self):
    self.check_apps_ready()
    return self.app_configs.values()


[/PYTHON]
What will be the input of `get_context`, given the following output:
[OUTPUT]
```
{
    "widget": {
        "name": "mydate",
        "is_hidden": false,
        "required": false,
        "value": {
            "year": null,
            "month": null,
            "day": null
        },
        "attrs": {},
        "template_name": "django/forms/widgets/select_date.html",
        "subwidgets": null
    }
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "attrs": {},
        "years": XXX,
        "months": {
            "1": {
                "_proxy____args": XXX,
                "_proxy____kw": {},
                "_proxy____prepared": XXX
            },
            "2": {
                "_proxy____args": XXX,
                "_proxy____kw": {},
                "_proxy____prepared": XXX
            },
            "3": {
                "_proxy____args": XXX,
                "_proxy____kw": {},
                "_proxy____prepared": XXX
            },
            "4": {
                "_proxy____args": XXX,
                "_proxy____kw": {},
                "_proxy____prepared": XXX
            },
            "5": {
                "_proxy____args": XXX,
                "_proxy____kw": {},
                "_proxy____prepared": XXX
            },
            "6": {
                "_proxy____args": XXX,
                "_proxy____kw": {},
                "_proxy____prepared": XXX
            },
            "7": {
                "_proxy____args": XXX,
                "_proxy____kw": {},
                "_proxy____prepared": XXX
            },
            "8": {
                "_proxy____args": XXX,
                "_proxy____kw": {},
                "_proxy____prepared": XXX
            },
            "9": {
                "_proxy____args": XXX,
                "_proxy____kw": {},
                "_proxy____prepared": XXX
            },
            "10": {
                "_proxy____args": XXX,
                "_proxy____kw": {},
                "_proxy____prepared": XXX
            },
            "11": {
                "_proxy____args": XXX,
                "_proxy____kw": {},
                "_proxy____prepared": XXX
            },
            "12": {
                "_proxy____args": XXX,
                "_proxy____kw": {},
                "_proxy____prepared": XXX
            }
        },
        "year_none_value": XXX,
        "month_none_value": XXX,
        "day_none_value": XXX
    },
    "args": {
        "name": XXX,
        "value": XXX,
        "attrs": XXX
    },
    "kwargs": {}
}
```
[/STRUCTURE]

[THOUGHT]
