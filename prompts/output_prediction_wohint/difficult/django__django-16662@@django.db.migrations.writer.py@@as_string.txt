You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided inputs (between [INPUT] and [\INPUT]) and predict the output of the function. Both input and output are presented in a JSON format. You need to predict output variable values, and print output between [OUTPUT] and [\OUTPUT]. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT].
[PYTHON]
class TempPathFactory(object):
    _given_basetemp = attr.ib(
        converter=attr.converters.optional(
            lambda p: Path(os.path.abspath(six.text_type(p)))
        )
    )
    _trace = attr.ib()
    _basetemp = attr.ib(default=None)

    def mktemp(self, basename, numbered=True):
        if not numbered:
            p = self.getbasetemp().joinpath(basename)
            p.mkdir()
        else:
            p = make_numbered_dir(root=self.getbasetemp(), prefix=basename)
            self._trace("mktemp", p)
        return p

    def getbasetemp(self):
        if self._basetemp is not None:
            return self._basetemp

        if self._given_basetemp is not None:
            basetemp = self._given_basetemp
            ensure_reset_dir(basetemp)
            basetemp = basetemp.resolve()
        else:
            from_env = os.environ.get("PYTEST_DEBUG_TEMPROOT")
            temproot = Path(from_env or tempfile.gettempdir()).resolve()
            user = get_user() or "unknown"
            rootdir = temproot.joinpath("pytest-of-{}".format(user))
            rootdir.mkdir(exist_ok=True)
            basetemp = make_numbered_dir_with_cleanup(
                prefix="pytest-", root=rootdir, keep=3, lock_timeout=LOCK_TIMEOUT
            )
        assert basetemp is not None, basetemp
        self._basetemp = t = basetemp
        self._trace("new basetemp", t)
        return t
[/PYTHON]

Functions called during the execution:
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1

def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]


def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)

def make_numbered_dir(root, prefix):
    for i in range(10):
        # try up to 10 times to create the folder
        max_existing = _max(map(parse_num, find_suffixes(root, prefix)), default=-1)
        new_number = max_existing + 1
        new_path = root.joinpath("{}{}".format(prefix, new_number))
        try:
            new_path.mkdir()
        except Exception:
            pass
        else:
            _force_symlink(root, prefix + "current", new_path)
            return new_path
    else:
        raise EnvironmentError(
            "could not create numbered dir with prefix "
            "{prefix} in {root} after 10 tries".format(prefix=prefix, root=root)
        )

[/PYTHON]

What will be the output of `mktemp`, given the following input:
[INPUT]
```
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "basename": "world"
    },
    "kwargs": {}
}
```
[/INPUT]

[THOUGHT]
1. Inside `mktemp`, since `numbered`=True (default), it calls: p = make_numbered_dir(root=self.getbasetemp(), prefix="world")
2. Inside `getbasetemp`, since `_basetemp` is None, so basetemp = Path("/tmp/pytest-of-root/pytest-0/test_mktemp0"). Therefore, getbasetemp() returns "/tmp/pytest-of-root/pytest-0/test_mktemp0".
3. Inside `make_numbered_dir`:
    root = /tmp/pytest-of-root/pytest-0/test_mktemp0
    prefix = "world"
    Since max_existing = -1, new_number = 0, so `new_path` = "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
[/THOUGHT]

[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]

[PYTHON]
import os
import re
from importlib import import_module
from django import get_version
from django.apps import apps
from django.conf import SettingsReference
from django.db import migrations
from django.db.migrations.loader import MigrationLoader
from django.db.migrations.serializer import Serializer, serializer_factory
from django.utils.inspect import get_func_args
from django.utils.module_loading import module_dir
from django.utils.timezone import now
MIGRATION_HEADER_TEMPLATE = '# Generated by Django %(version)s on %(timestamp)s\n\n'
MIGRATION_TEMPLATE = '%(migration_header)s%(imports)s\n\nclass Migration(migrations.Migration):\n%(replaces_str)s%(initial_str)s\n    dependencies = [\n%(dependencies)s    ]\n\n    operations = [\n%(operations)s    ]\n'

class MigrationWriter:

    def as_string(self):
        items = {'replaces_str': '', 'initial_str': ''}
        imports = set()
        operations = []
        for operation in self.migration.operations:
            operation_string, operation_imports = OperationWriter(operation).serialize()
            imports.update(operation_imports)
            operations.append(operation_string)
        items['operations'] = '\n'.join(operations) + '\n' if operations else ''
        dependencies = []
        for dependency in self.migration.dependencies:
            if dependency[0] == '__setting__':
                dependencies.append('        migrations.swappable_dependency(settings.%s),' % dependency[1])
                imports.add('from django.conf import settings')
            else:
                dependencies.append('        %s,' % self.serialize(dependency)[0])
        items['dependencies'] = '\n'.join(dependencies) + '\n' if dependencies else ''
        migration_imports = set()
        for line in list(imports):
            if re.match('^import (.*)\\.\\d+[^\\s]*$', line):
                migration_imports.add(line.split('import')[1].strip())
                imports.remove(line)
                self.needs_manual_porting = True
        if 'from django.db import models' in imports:
            imports.discard('from django.db import models')
            imports.add('from django.db import migrations, models')
        else:
            imports.add('from django.db import migrations')
        sorted_imports = sorted(imports, key=lambda i: (i.split()[0] == 'from', i.split()[1]))
        items['imports'] = '\n'.join(sorted_imports) + '\n' if imports else ''
        if migration_imports:
            items['imports'] += '\n\n# Functions from the following migrations need manual copying.\n# Move them and any dependencies into this file, then update the\n# RunPython operations to refer to the local versions:\n# %s' % '\n# '.join(sorted(migration_imports))
        if self.migration.replaces:
            items['replaces_str'] = '\n    replaces = %s\n' % self.serialize(self.migration.replaces)[0]
        if self.include_header:
            items['migration_header'] = MIGRATION_HEADER_TEMPLATE % {'version': get_version(), 'timestamp': now().strftime('%Y-%m-%d %H:%M')}
        else:
            items['migration_header'] = ''
        if self.migration.initial:
            items['initial_str'] = '\n    initial = True\n'
        return MIGRATION_TEMPLATE % items

    @classmethod
    def serialize(cls, value):
        return serializer_factory(value).serialize()
[/PYTHON]

Functions called during the execution:
[PYTHON]
.django.db.migrations.writer.OperationWriter.__init__

def __init__(self, operation, indentation=2):
    self.operation = operation
    self.buff = []
    self.indentation = indentation

.django.db.migrations.writer.OperationWriter.serialize

def serialize(self):

    def _write(_arg_name, _arg_value):
        if _arg_name in self.operation.serialization_expand_args and isinstance(_arg_value, (list, tuple, dict)):
            if isinstance(_arg_value, dict):
                self.feed('%s={' % _arg_name)
                self.indent()
                for key, value in _arg_value.items():
                    key_string, key_imports = MigrationWriter.serialize(key)
                    arg_string, arg_imports = MigrationWriter.serialize(value)
                    args = arg_string.splitlines()
                    if len(args) > 1:
                        self.feed('%s: %s' % (key_string, args[0]))
                        for arg in args[1:-1]:
                            self.feed(arg)
                        self.feed('%s,' % args[-1])
                    else:
                        self.feed('%s: %s,' % (key_string, arg_string))
                    imports.update(key_imports)
                    imports.update(arg_imports)
                self.unindent()
                self.feed('},')
            else:
                self.feed('%s=[' % _arg_name)
                self.indent()
                for item in _arg_value:
                    arg_string, arg_imports = MigrationWriter.serialize(item)
                    args = arg_string.splitlines()
                    if len(args) > 1:
                        for arg in args[:-1]:
                            self.feed(arg)
                        self.feed('%s,' % args[-1])
                    else:
                        self.feed('%s,' % arg_string)
                    imports.update(arg_imports)
                self.unindent()
                self.feed('],')
        else:
            arg_string, arg_imports = MigrationWriter.serialize(_arg_value)
            args = arg_string.splitlines()
            if len(args) > 1:
                self.feed('%s=%s' % (_arg_name, args[0]))
                for arg in args[1:-1]:
                    self.feed(arg)
                self.feed('%s,' % args[-1])
            else:
                self.feed('%s=%s,' % (_arg_name, arg_string))
            imports.update(arg_imports)
    imports = set()
    name, args, kwargs = self.operation.deconstruct()
    operation_args = get_func_args(self.operation.__init__)
    if getattr(migrations, name, None) == self.operation.__class__:
        self.feed('migrations.%s(' % name)
    else:
        imports.add('import %s' % self.operation.__class__.__module__)
        self.feed('%s.%s(' % (self.operation.__class__.__module__, name))
    self.indent()
    for i, arg in enumerate(args):
        arg_value = arg
        arg_name = operation_args[i]
        _write(arg_name, arg_value)
    i = len(args)
    for arg_name in operation_args[i:]:
        if arg_name in kwargs:
            arg_value = kwargs[arg_name]
            _write(arg_name, arg_value)
    self.unindent()
    self.feed('),')
    return (self.render(), imports)

.django.utils.inspect.get_func_args

def get_func_args(func):
    params = _get_callable_parameters(func)
    return [param.name for param in params if param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD]

.django.utils.inspect._get_callable_parameters

def _get_callable_parameters(meth_or_func):
    is_method = inspect.ismethod(meth_or_func)
    func = meth_or_func.__func__ if is_method else meth_or_func
    return _get_func_parameters(func, remove_first=is_method)

.django.db.migrations.writer.OperationWriter.feed

def feed(self, line):
    self.buff.append(' ' * (self.indentation * 4) + line)

.django.db.migrations.writer.OperationWriter.indent

def indent(self):
    self.indentation += 1

.django.db.migrations.writer.OperationWriter.unindent

def unindent(self):
    self.indentation -= 1

.django.db.migrations.writer.OperationWriter.render

def render(self):
    return '\n'.join(self.buff)

.django.db.migrations.operations.models.CreateModel.deconstruct

def deconstruct(self):
    kwargs = {'name': self.name, 'fields': self.fields}
    if self.options:
        kwargs['options'] = self.options
    if self.bases and self.bases != (models.Model,):
        kwargs['bases'] = self.bases
    if self.managers and self.managers != [('objects', models.Manager())]:
        kwargs['managers'] = self.managers
    return (self.__class__.__qualname__, [], kwargs)

.django.utils.inspect._get_func_parameters

def _get_func_parameters(func, remove_first):
    parameters = tuple(inspect.signature(func).parameters.values())
    if remove_first:
        parameters = parameters[1:]
    return parameters

.django.db.migrations.writer.OperationWriter._write

def _write(_arg_name, _arg_value):
    if _arg_name in self.operation.serialization_expand_args and isinstance(_arg_value, (list, tuple, dict)):
        if isinstance(_arg_value, dict):
            self.feed('%s={' % _arg_name)
            self.indent()
            for key, value in _arg_value.items():
                key_string, key_imports = MigrationWriter.serialize(key)
                arg_string, arg_imports = MigrationWriter.serialize(value)
                args = arg_string.splitlines()
                if len(args) > 1:
                    self.feed('%s: %s' % (key_string, args[0]))
                    for arg in args[1:-1]:
                        self.feed(arg)
                    self.feed('%s,' % args[-1])
                else:
                    self.feed('%s: %s,' % (key_string, arg_string))
                imports.update(key_imports)
                imports.update(arg_imports)
            self.unindent()
            self.feed('},')
        else:
            self.feed('%s=[' % _arg_name)
            self.indent()
            for item in _arg_value:
                arg_string, arg_imports = MigrationWriter.serialize(item)
                args = arg_string.splitlines()
                if len(args) > 1:
                    for arg in args[:-1]:
                        self.feed(arg)
                    self.feed('%s,' % args[-1])
                else:
                    self.feed('%s,' % arg_string)
                imports.update(arg_imports)
            self.unindent()
            self.feed('],')
    else:
        arg_string, arg_imports = MigrationWriter.serialize(_arg_value)
        args = arg_string.splitlines()
        if len(args) > 1:
            self.feed('%s=%s' % (_arg_name, args[0]))
            for arg in args[1:-1]:
                self.feed(arg)
            self.feed('%s,' % args[-1])
        else:
            self.feed('%s=%s,' % (_arg_name, arg_string))
        imports.update(arg_imports)

.django.db.migrations.serializer.serializer_factory

def serializer_factory(value):
    if isinstance(value, Promise):
        value = str(value)
    elif isinstance(value, LazyObject):
        value = value.__reduce__()[1][0]
    if isinstance(value, models.Field):
        return ModelFieldSerializer(value)
    if isinstance(value, models.manager.BaseManager):
        return ModelManagerSerializer(value)
    if isinstance(value, Operation):
        return OperationSerializer(value)
    if isinstance(value, type):
        return TypeSerializer(value)
    if hasattr(value, 'deconstruct'):
        return DeconstructableSerializer(value)
    for type_, serializer_cls in Serializer._registry.items():
        if isinstance(value, type_):
            return serializer_cls(value)
    raise ValueError('Cannot serialize: %r\nThere are some values Django cannot serialize into migration files.\nFor more, see https://docs.djangoproject.com/en/%s/topics/migrations/#migration-serializing' % (value, get_docs_version()))

.django.db.migrations.serializer.BaseSerializer.__init__

def __init__(self, value):
    self.value = value

.django.db.migrations.serializer.BaseSimpleSerializer.serialize

def serialize(self):
    return (repr(self.value), set())

.django.utils.version.get_version

def get_version(version=None):
    version = get_complete_version(version)
    main = get_main_version(version)
    sub = ''
    if version[3] == 'alpha' and version[4] == 0:
        git_changeset = get_git_changeset()
        if git_changeset:
            sub = '.dev%s' % git_changeset
    elif version[3] != 'final':
        mapping = {'alpha': 'a', 'beta': 'b', 'rc': 'rc'}
        sub = mapping[version[3]] + str(version[4])
    return main + sub


[/PYTHON]
What will be the output of `as_string`, given the following input:
[INPUT]
```
{
    "self": {
        "migration": {
            "operations": null,
            "__module__": "migrations.test_writer",
            "__doc__": null
        },
        "include_header": false,
        "needs_manual_porting": false
    },
    "args": {},
    "kwargs": {}
}
```
[/INPUT]

[THOUGHT]
