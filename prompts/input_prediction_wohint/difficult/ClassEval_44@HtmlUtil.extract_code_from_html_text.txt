You are given a Python function (between [PYTHON] and [/PYTHON]). For this function, I want you to take the provided output (between [OUTPUT] and [\OUTPUT]) and predict the input of the function. Both input and output are presented in a JSON format. You only need to predict input variable values, and print input between [INPUT] and [\INPUT]. For prediction, simulate the execution of the program step by step and print your reasoning process before arriving at an answer between [THOUGHT] and [/THOUGHT]. 
[/EXAMPLE]
[PYTHON]
from typing import Iterable

class CaesarCipher:

    def __init__(self, shift: int = 3):
        self.shift = shift
    @classmethod
    def normalize(cls, text: str) -> str:
        return str(text).replace("\r\n", "\n").replace("\r", "\n")

    @classmethod
    def _alpha_index(cls, ch: str) -> int:
        if "A" <= ch <= "Z":
            return ord(ch) - ord("A")
        if "a" <= ch <= "z":
            return ord(ch) - ord("a")
        return -1

    @classmethod
    def _shift_char(cls, ch: str, k: int) -> str:
        idx = cls._alpha_index(ch)
        if idx == -1:
            return ch  # non-letter unchanged
        base = ord("A") if ch.isupper() else ord("a")
        return chr(base + (idx + k) % 26)

    @classmethod
    def _transform(cls, text: str, k: int) -> str:
        text = cls.normalize(text)
        return "".join(cls._shift_char(c, k) for c in text)


    def encode(self, plaintext: str) -> str:
        return self._transform(plaintext, self.shift)

    def decode(self, ciphertext: str) -> str:
        return self._transform(ciphertext, -self.shift)
[/PYTHON]


What will be the input of `encode`, given the following output:

[OUTPUT]
```
{
    "output": "Mjqqt, Btwqi!"
}
```
[/OUTPUT]

[THOUGHT]
Caesar cipher with shift = 5: move each letter 5 positions forward (wrapping A↔Z), keep punctuation/spaces unchanged.
Apply to "Hello, World!":
    H→M, e→j, l→q, l→q, o→t → “Mjqqt”
    comma/space stay the same → “Mjqqt, ”
    W→B (wrap), o→t, r→w, l→q, d→i → “Btwqi”
    “!” stays “!”
Combined: "Mjqqt, Btwqi!"
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "shift": 5
    },
    "args": {
        "plaintext": "Hello, World!"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
import re
import string
import gensim
from bs4 import BeautifulSoup

class HtmlUtil:

    def __init__(self):
        self.SPACE_MARK = '-SPACE-'
        self.JSON_MARK = '-JSON-'
        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'
        self.URL_MARK = '-URL-'
        self.NUMBER_MARK = '-NUMBER-'
        self.TRACE_MARK = '-TRACE-'
        self.COMMAND_MARK = '-COMMAND-'
        self.COMMENT_MARK = '-COMMENT-'
        self.CODE_MARK = '-CODE-'

    def format_line_html_text(self, html_text):
        if html_text is None or len(html_text) == 0:
            return ''
        soup = BeautifulSoup(html_text, 'lxml')
        code_tag = soup.find_all(name=['pre', 'blockquote'])
        for tag in code_tag:
            tag.string = self.CODE_MARK
        ul_ol_group = soup.find_all(name=['ul', 'ol'])
        for ul_ol_item in ul_ol_group:
            li_group = ul_ol_item.find_all('li')
            for li_item in li_group:
                li_item_text = li_item.get_text().strip()
                if len(li_item_text) == 0:
                    continue
                if li_item_text[-1] in string.punctuation:
                    li_item.string = '[{0}]{1}'.format('-', li_item_text)
                    continue
                li_item.string = '[{0}]{1}.'.format('-', li_item_text)
        p_group = soup.find_all(name=['p'])
        for p_item in p_group:
            p_item_text = p_item.get_text().strip()
            if p_item_text:
                if p_item_text[-1] in string.punctuation:
                    p_item.string = p_item_text
                    continue
                next_sibling = p_item.find_next_sibling()
                if next_sibling and self.CODE_MARK in next_sibling.get_text():
                    p_item.string = p_item_text + ':'
                    continue
                p_item.string = p_item_text + '.'
        clean_text = gensim.utils.decode_htmlentities(soup.get_text())
        return self.__format_line_feed(clean_text)

    def extract_code_from_html_text(self, html_text):
        text_with_code_tag = self.format_line_html_text(html_text)
        if self.CODE_MARK not in text_with_code_tag:
            return []
        code_index_start = 0
        soup = BeautifulSoup(html_text, 'lxml')
        code_tag = soup.find_all(name=['pre', 'blockquote'])
        code_count = text_with_code_tag.count(self.CODE_MARK)
        code_list = []
        for code_index in range(code_index_start, code_index_start + code_count):
            code = code_tag[code_index].get_text()
            if code:
                code_list.append(code)
        return code_list
[/PYTHON]

What will be the input of `extract_code_from_html_text`, given the following output:
[OUTPUT]
```
{
    "output": [
        "print('Hello, world!')",
        "for i in range(4):\n                print(i)"
    ]
}
```
[/OUTPUT]

[THOUGHT]
        