1. The output is a product of terms. Each term is a product of factors.
2. The factors are either symbols or functions of symbols.
3. The symbols are of the form `conjugate(A)` or `conjugate(B)`.
4. The functions are of the form `\"conjugate(A)\"` or `\"conjugate(B)\"`.
5. The functions are raised to a power.
6. The power is a product of terms.
7. The terms are either symbols or functions of symbols.
8. The symbols are of the form `conjugate(A)` or `conjugate(B)`.
9. The functions are of the form `\"conjugate(A)\"` or `\"conjugate(B)\"`.
10. The functions are raised to a power.
11. The power is a product of terms.
12. The terms are either symbols or functions of symbols.
13. The symbols are of the form `conjugate(A)` or `conjugate(B)`.
14. The functions are of the form `\"conjugate(A)\"` or `\"conjugate(B)\"`.
15. The functions are raised to a power.
16. The power is a product of terms.
17. The terms are either symbols or functions of symbols.
18. The symbols are of the form `conjugate(A)` or `conjugate(B)`.
19. The functions are of the form `\"conjugate(A)\"` or `\"conjugate(B)\"`.
20. The functions are raised to a power.
21. The power is a product of terms.
22. The terms are either symbols or functions of symbols.
23. The symbols are of the form `conjugate(A)` or `conjugate(B)`.
24. The functions are of the form `\"conjugate(A)\"` or `\"conjugate(B)\"`.
25. The functions are raised to a power.
26. The power is a product of terms.
27. The terms are either symbols or functions of symbols.
28. The symbols are of the form `conjugate(A)` or `conjugate(B)`.
29. The functions are of the form `\"conjugate(A)\"` or `\"conjugate(B)\"`.
30. The functions are raised to a power.
31. The power is a product of terms.
32. The terms are either symbols or functions of symbols.
33. The symbols are of the form `conjugate(A)` or `conjugate(B)`.
34. The functions are of the form `\"conjugate(A)\"` or `\"conjugate(B)\"`.
35. The functions are raised to a power.
36. The power is a product of terms.
37. The terms are either symbols or functions of symbols.
38. The symbols are of the form `conjugate(A)` or `conjugate(B)`.
39. The functions are of the form `\"conjugate(A)\"` or `\"conjugate(B)\"`.
40. The functions are raised to a power.
41. The power is a product of terms.
42. The terms are either symbols or functions of symbols.
43. The symbols are of the form `conjugate(A)` or `conjugate(B)`.
44. The functions are of the form `\"conjugate(A)\"` or `\"conjugate(B)\"`.
45. The functions are raised to a power.
46. The power is a product of terms.
47. The terms are either symbols or functions of symbols.
48. The symbols are of the form `conjugate(A)` or `conjugate(B)`.
49. The functions are of the form `\"conjugate(A)\"` or `\"conjugate(B)\"`.
50. The functions are raised to a power.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "term": "conjugate(A)*\"conjugate(B)\"*\"conjugate(A)\"*\"conjugate(B)\"**2*\"conjugate(A)\"*\"conjugate(B)\"**3",
        "limits": {
            "k": "conjugate(A)",
            "a": "conjugate(B)",
            "n": "conjugate(A)*\"conjugate(B)\"*\"conjugate(A)\"*\"conjugate(B)\"**2*\"conjugate(A)\"*\"conjugate(B)\"**3"
        }
    }
}
```
[/INPUT]
[/PYTHON]
[PYTHON]
from __future__ import print_function, division
from sympy.tensor.indexed import Idx
from sympy.core.mul import Mul
from sympy.core.singleton import S
from sympy.core.symbol import symbols
from sympy.concrete.expr_with_intlimits import ExprWithIntLimits
from sympy.functions.elementary.exponential import exp, log
from sympy.polys import quo, roots
from sympy.simplify import powsimp
from sympy.core.compatibility import range
from sympy.concrete.summations import Sum
from sympy.concrete.delta import deltaproduct, _has_simple_delta
from sympy.concrete.summations import summation
from sympy.functions import KroneckerDelta, RisingFactorial
from sympy.simplify.simplify import product_simplify
from sympy.concrete.summations import Sum
from sympy.concrete.summations import Sum

class Product(ExprWithIntLimits):
    __slots__ = ['is_commutative']
    function = term

    def _eval_product(self, term, limits):
        from sympy.concrete.delta import deltaproduct, _has_simple_delta
        from sympy.concrete.summations import summation
        from sympy.functions import KroneckerDelta, RisingFactorial
        k, a, n = limits
        if k not in term.free_symbols:
            if (term - 1).is_zero:
                return S.One
            return term ** (n - a + 1)
        if a == n:
            return term.subs(k, a)
        if term.has(KroneckerDelta) and _has_simple_delta(term, limits[0]):
            return deltaproduct(term, limits)
        dif = n - a
        if dif.is_Integer:
            return Mul(*[term.subs(k, a + i) for i in range(dif + 1)])
        elif term.is_polynomial(k):
            poly = term.as_poly(k)
            A = B = Q = S.One
            all_roots = roots(poly)
            M = 0
            for r, m in all_roots.items():
                M += m
                A *= RisingFactorial(a - r, n - a + 1) ** m
                Q *= (n - r) ** m
            if M < poly.degree():
                arg = quo(poly, Q.as_poly(k))
                B = self.func(arg, (k, a, n)).doit()
            return poly.LC() ** (n - a + 1) * A * B
        elif term.is_Add:
            p, q = term.as_numer_denom()
            q = self._eval_product(q, (k, a, n))
            if q.is_Number:
                from sympy.concrete.summations import Sum
                p = exp(Sum(log(p), (k, a, n)))
            else:
                p = self._eval_product(p, (k, a, n))
            return p / q
        elif term.is_Mul:
            exclude, include = ([], [])
            for t in term.args:
                p = self._eval_product(t, (k, a, n))
                if p is not None:
                    exclude.append(p)
                else:
                    include.append(t)
            if not exclude:
                return None
            else:
               