
The input of `mrr` is a list of tuples, where each tuple contains a list of scores and the total number of scores. The output is the mean reciprocal rank (MRR) and a list of MRRs for each tuple.

The MRR is calculated as the reciprocal of the rank of the first relevant item in a list of items sorted by their relevance scores. The rank of the first relevant item is 1, the rank of the second relevant item is 2, and so on.

The input is a list of tuples, where each tuple contains a list of scores and the total number of scores. The output is the mean reciprocal rank (MRR) and a list of MRRs for each tuple.

The MRR is calculated as the reciprocal of the rank of the first relevant item in a list of items sorted by their relevance scores. The rank of the first relevant item is 1, the rank of the second relevant item is 2, and so on.

The input is a list of tuples, where each tuple contains a list of scores and the total number of scores. The output is the mean reciprocal rank (MRR) and a list of MRRs for each tuple.

The MRR is calculated as the reciprocal of the rank of the first relevant item in a list of items sorted by their relevance scores. The rank of the first relevant item is 1, the rank of the second relevant item is 2, and so on.

The input is a list of tuples, where each tuple contains a list of scores and the total number of scores. The output is the mean reciprocal rank (MRR) and a list of MRRs for each tuple.

The MRR is calculated as the reciprocal of the rank of the first relevant item in a list of items sorted by their relevance scores. The rank of the first relevant item is 1, the rank of the second relevant item is 2, and so on.
[/THOUGHT]

[INPUT]
```
{
    "self": {},
    "args": [
        (
            [
                1,
                0,
                0,
                0
            ],
            1
        )
    ],
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
import numpy as np

class MetricsCalculator2:

    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        if type(data) != list and type(data) != tuple:
            raise Exception('the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple')
        if len(data) == 0:
            return (0.0, [0.0])
        if type(data) == tuple:
            sub_list, total_num = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return (0.0, [0.0])
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                mr_np = sub_list * ranking_array
                mr = 0.0
                for team in mr_np:
                    if team > 0:
                        mr = team
                        break
                return (mr, [mr])
        if type(data) == list:
            separate_result = []
            for sub_list, total_num in data:
                sub_list = np.array(sub_list)
                if total_num == 0:
                    mr = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                    mr_np = sub_list * ranking_array
                    mr = 0.0
                    for team in mr_np:
                        if team > 0:
                            mr = team
                            break
                separate_result.append(mr)
            return (np.mean(separate_result), separate_result)
[/PYTHON]

What will be the input of `mrr`, given the following output:
[OUTPUT]
```
{
    "output": [
        0.25,
        [
            0.25
        ]
    ]
}
```
[/OUTPUT]

[THOUGHT]
        
The input of `mrr` is a list of tuples, where each tuple contains a list of scores and the total number of scores. The output is the mean reciprocal rank (MRR) and a list of MRRs for each tuple.

The MRR is calculated as the reciprocal of the rank of the first relevant item in a list of items sorted by their relevance scores. The rank of the first relevant item is 1, the rank of the second relevant item is 2, and so on.

The input is a list of tuples, where each tuple contains a list of scores and the total number of scores. The output is the mean reciprocal rank (MRR) and a list of MRRs for each tuple.

The MRR is calculated as the reciprocal of the rank of the first relevant item in a list of items sorted by their relevance scores. The rank of the first relevant item is 1, the rank of the second relevant item is 2, and so on.

The input is a list of tuples, where each tuple contains a list of scores and the total number of scores. The output is the mean reciprocal rank (MRR) and a list of MRRs for each tuple.

The MRR is calculated as the reciprocal of the rank of the first relevant item in a list of items sorted by their relevance scores. The rank of the first relevant item is 1, the rank of the second relevant item is 2, and so on.

The input is a list of tuples, where each tuple contains a list of scores and the total number of scores. The output is the mean reciprocal rank (MRR) and a list of MRRs for each tuple.

The MRR is calculated as the reciprocal of the rank of the first relevant item in a list of items sorted by their relevance scores. The rank of the first relevant item is 1, the rank of the second relevant item is 2, and so on.
[/THOUGHT]

[INPUT]
```
{
    "self": {},
    "args": [
        (
            [
                1,
                0,
                0,
                0
            ],
            1
        )
    ],
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
import numpy as np

class MetricsCalculator2:

    def __init__(self):
        pass

    @staticmethod
    def mrr(data):
        if type(data) != list and type(data) != tuple:
            raise Exception('the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple')
        if len(data) == 0:
            return (0.0, [0.0])
        if type(data) == tuple:
            sub_list, total_num = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return (0.0, [0.0])
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                mr_np = sub_list * ranking_array
                mr = 0.0
                for team in mr_np:
                    if team > 0:
                        mr = team
                        break
                return (mr, [mr])
        if type(data) == list:
            separate_result = []
            for sub_list, total_num in data:
                sub_list = np.array(sub_list)
                if total_num == 0:
                    mr = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                    mr_np = sub_list * ranking_array
                    mr = 0.0
                    for team in mr_np:
                        if team > 0:
                            mr = team
                            break
                separate_result.append(mr)
            return (np.mean(separate_result), separate_result)
[/PYTHON]

What will be the input of `mrr`, given the following output:
[OUTPUT]
```
{
    "output": [
        0.25,
        [
            0.25
        ]