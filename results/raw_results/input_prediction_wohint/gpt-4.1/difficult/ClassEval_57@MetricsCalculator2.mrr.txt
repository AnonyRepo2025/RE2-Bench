[THOUGHT]
The function mrr can take either a tuple (sub_list, total_num) or a list of such tuples. The output is a tuple: (mean_mrr, [list of mrrs]).

Given the output is [0.25, [0.25]], this means only one value was processed (since the list of mrrs has one element), and the mean is the same as the only value.

So, the input must be a tuple (sub_list, total_num) or a list with one such tuple.

Let's look at the calculation for a tuple input:
- sub_list is a list/array of 0s and 1s.
- total_num is not used except to check if it's 0 (in which case output is 0.0).
- ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
- mr_np = sub_list * ranking_array
- For each team in mr_np, if team > 0, mr = team, break.

So, the first 1 in sub_list determines the reciprocal rank.

For example, if sub_list = [0, 0, 1, 0], then ranking_array = [1, 0.5, 0.333..., 0.25], so mr_np = [0, 0, 0.333..., 0], so mr = 0.333...

If sub_list = [0, 0, 0, 1], ranking_array = [1, 0.5, 0.333..., 0.25], mr_np = [0, 0, 0, 0.25], so mr = 0.25.

So, to get 0.25, the first 1 must be at index 3 (0-based), i.e., sub_list = [0, 0, 0, 1].

total_num can be any nonzero value (say 1).

So, input could be ([0, 0, 0, 1], 1) or as a list: [([0, 0, 0, 1], 1)].

Either is valid, but the function will return a list of mrrs only if input is a list.

Given the output is a list of mrrs, the input must be a list: [([0, 0, 0, 1], 1)].

[/THOUGHT]

[INPUT]
```
{
    "data": [
        [
            [0, 0, 0, 1],
            1
        ]
    ]
}
```
[/INPUT]