[THOUGHT]
Let's analyze the code and the output step by step.

1. The function in question is `FunctionUnitBase.to(self, other, value=1.0, equivalencies=[])`.
2. The output is `100.0`.

Let's see how this function can return a float (100.0).

- The function first checks if `other is self.physical_unit`. If so, it returns `self.to_physical(value)`.
- Otherwise, it gets `other_function_unit = getattr(other, 'function_unit', other)`.
- If `self.function_unit.is_equivalent(other_function_unit)`:
    - It gets `other_physical_unit = getattr(other, 'physical_unit', dimensionless_unscaled)`.
    - If `self.physical_unit != other_physical_unit`:
        - It computes `value_other_physical = self.physical_unit.to(other_physical_unit, self.to_physical(value), equivalencies)`
        - Then `value = self.from_physical(value_other_physical)`
    - Returns `self.function_unit.to(other_function_unit, value)`
- Otherwise, it tries:
    - `self.physical_unit.to(other, self.to_physical(value), equivalencies)`
    - If that fails and `self.function_unit == Unit('mag')`, raises with a message.

We want the output to be 100.0.

The simplest way for this to happen is for the first branch to be taken: `if other is self.physical_unit: return self.to_physical(value)`. So, if `self.to_physical(value)` returns 100.0, then the output is 100.0.

Alternatively, if the function proceeds to the other branches, the output would be whatever is returned by the various `.to()` methods.

But the most direct way is the first branch.

So, let's assume:
- `other is self.physical_unit`
- `self.to_physical(value)` returns 100.0

Therefore, the input should be:
- `self` is an instance of `FunctionUnitBase` (or subclass) with a `physical_unit` attribute (could be any object, but let's say a string or a Unit object for clarity).
- `other` is exactly the same object as `self.physical_unit`.
- `value` is any value such that `self.to_physical(value)` returns 100.0. The default is 1.0, but maybe `to_physical` is overridden to return 100.0 for any input, or we can set value=100.0 and have `to_physical` be the identity.

Since we don't have the implementation of `to_physical`, let's assume it's the identity function (i.e., returns its input). Then, if we pass `value=100.0`, the output will be 100.0.

Alternatively, if `to_physical` multiplies by 100, then `value=1.0` would work.

But since we don't know, let's use the most general case: set `value=100.0` and assume `to_physical` is the identity.

So, the input is:
- `self`: an instance with a `physical_unit` attribute (let's say "m" for meters)
- `other`: the same as `self.physical_unit` ("m")
- `value`: 100.0

[/THOUGHT]

[INPUT]
```
{
    "self": {
        "physical_unit": "m"
    },
    "other": "m",
    "value": 100.0,
    "equivalencies": []
}
```
[/INPUT]