1. Inside `__hash__`, it returns hash(self.name).
2. self.name = "example", so hash(self.name) = hash("example")
[/THOUGHT]

[OUTPUT]
```
{
    "hash": 1003869050371119314
}
```
[/OUTPUT]

[PYTHON]
class _Base:
    def __init__(self, name: str, bases: Tuple[Type[Any], ...], attrs: Dict[str, Any]):
        self.name = name
        self.bases = bases
        self.attrs = attrs

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} {self.name}>"

    def __eq__(self, other: Any) -> bool:
        return (
            isinstance(other, self.__class__)
            and self.name == other.name
            and self.bases == other.bases
            and self.attrs == other.attrs
        )

    def __hash__(self) -> int:
        return hash((self.name, self.bases, frozenset(self.attrs.items())))

    def __call__(self, *args: Any, **kwargs: Any) -> Any:
        raise NotImplementedError

    def __getattr__(self, name: str) -> Any:
        try:
            return self.attrs[name]
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name: str, value: Any) -> None:
        if name in ("name", "bases", "attrs"):
            super().__setattr__(name, value)
        else:
            self.attrs[name] = value

    def __delattr__(self, name: str) -> None:
        try:
            del self.attrs[name]
        except KeyError:
            raise AttributeError(name)

    def __dir__(self) -> List[str]:
        return list(self.attrs.keys())

    def __reduce__(self) -> Tuple[Callable[..., Any], Tuple[Any, ...]]:
        return self.__class__, (self.name, self.bases, self.attrs)

    def __prepare__(self, name: str, bases: Tuple[Type[Any], ...]) -> Dict[str, Any]:
        return {}

    def __instancecheck__(self, instance: Any) -> bool:
        return instance.__class__ is self

    def __subclasscheck__(self, subclass: Type[Any]) -> bool:
        return issubclass(subclass, self)

    def __getitem__(self, item: Any) -> Any:
        return self.attrs[item]

    def __setitem__(self, key: Any, value: Any) -> None:
        self.attrs[key] = value

    def __delitem__(self, key: Any) -> None:
        del self.attrs[key]

    def __contains__(self, item: Any) -> bool:
        return item in self.attrs

    def __iter__(self) -> Iterator[Any]:
        return iter(self.attrs)

    def __len__(self) -> int:
        return len(self.attrs)

    def __format__(self, format_spec: str) -> str:
        return self.name.__format__(format_spec)

    def __reduce_ex__(self, protocol: int) -> Tuple[Callable[..., Any], Tuple[Any, ...]]:
        return self.__class__, (self.name, self.bases, self.attrs)

    def __sizeof__(self) -> int:
        return object.__sizeof__(self) + sum(sys.getsizeof(v) for v in self.attrs.values())

    def __str__(self) -> str:
        return self.name
[/PYTHON]

What will be the output of `__str__`, given the following input:
[INPUT]
```
{
    "self": {
        "name": "example"
    },
    "args": {},
    "kwargs": {}
}
```
[/INPUT]

[THOUGHT]
1. Inside `__str__`, it returns self.name.
2. self.name = "example", so self.name.__str__() = "example"
[/THOUGHT]

[OUTPUT]
```
{
    "str": "example"
}
```
[/OUTPUT]

[PYTHON]
class _Base:
    def __init__(self, name: str, bases: Tuple[Type[Any], ...], attrs: Dict[str, Any]):
        self.name = name
        self.bases = bases
        self.attrs = attrs

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__} {self.name}>"

    def __eq__(self, other: Any) -> bool:
        return (
            isinstance(other, self.__class__)
            and self.name == other.name
            and self.bases == other.bases
            and self.attrs == other.attrs
        )

    def __hash__(self) -> int:
        return hash((self.name, self.bases, frozenset(self.attrs.items())))

    def __call__(self, *args: Any, **kwargs: Any) -> Any:
        raise NotImplementedError

    def __getattr__(self, name: str) -> Any:
        try:
            return self.attrs[name]
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name: str, value: Any) -> None:
        if name in ("name", "bases", "attrs"):
            super().__setattr__(name, value)
        else:
            self.attrs[name] = value

    def __delattr__(self, name: str) -> None:
        try:
            del self.attrs[name]
        except KeyError:
            raise AttributeError(name)

    def __dir__(self) -> List[str]:
        return list(self.attrs.keys())

    def __reduce__(self) -> Tuple[Callable[..., Any], Tuple[Any, ...]]:
        return self.__class__, (self.name, self.bases, self.attrs)

    def __prepare__(self, name: str, bases: Tuple[Type[Any], ...]) -> Dict[str, Any]:
        return {}

    def __instancecheck__(self, instance: Any) -> bool:
        return instance.__class__ is self

    def __subclasscheck__(self, subclass: Type[Any]) -> bool:
        return issubclass(subclass, self)

    def __getitem__(self, item: Any) -> Any:
        return self.attrs[item]

    def __setitem__(self, key: Any, value: Any) -> None:
        self.attrs[key] = value

    def __delitem__(self, key: Any) -> None:
        del self.attrs[key]

    def __contains__(self, item: Any) -> bool:
        return item in self.attrs

    def __iter__(self) -> Iterator[Any]:
        return iter(self.attrs)

    def __len__(self) -> int:
        return len(self.attrs)

    def __format__(self, format_spec: str) -> str:
        return self.name.__format__(format_spec)

    def __reduce_ex__(self, protocol: int) -> Tuple[Callable[..., Any], Tuple[Any, ...]]:
        return self.__class__, (self.name, self.bases, self.attrs)

    def __sizeof__(self) -> int:
        return object.__sizeof__(self) + sum(sys.getsizeof(v) for v in self.attrs.values())

    def __str__(self) -> str:
        return self.name
[/