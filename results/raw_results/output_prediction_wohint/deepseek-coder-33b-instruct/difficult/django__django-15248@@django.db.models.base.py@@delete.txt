1. Inside `delete`, it calls: collector = Collector(using=using, origin=self)
2. Inside `Collector.__init__`:
    self.using = using = "default"
    self.origin = origin = self
    self.data = defaultdict(set)
    self.field_updates = defaultdict(partial(defaultdict, set))
    self.restricted_objects = defaultdict(partial(defaultdict, set))
    self.fast_deletes = []
    self.dependencies = defaultdict(set)
3. Then it calls: new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
4. Inside `Collector.add`:
    model = new_objs[0].__class__ = self.__class__
    instances = self.data[model] = defaultdict(set)
    for obj in objs:
        if obj not in instances:
            new_objs.append(obj)
    instances.update(new_objs)
    return new_objs
5. So, new_objs = [self]
6. Then it calls: self.collect(new_objs, source=model, source_attr=ptr.remote_field.related_name, collect_related=False, reverse_dependency=True, fail_on_restricted=False)
7. Inside `Collector.collect`:
    if self.can_fast_delete(objs):
        self.fast_deletes.append(objs)
        return
    new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
    if not new_objs:
        return
    model = new_objs[0].__class__
    if not keep_parents:
        concrete_model = model._meta.concrete_model
        for ptr in concrete_model._meta.parents.values():
            if ptr:
                parent_objs = [getattr(obj, ptr.name) for obj in new_objs]
                self.collect(parent_objs, source=model, source_attr=ptr.remote_field.related_name, collect_related=False, reverse_dependency=True, fail_on_restricted=False)
    if not collect_related:
        return
    if keep_parents:
        parents = set(model._meta.get_parent_list())
    model_fast_deletes = defaultdict(list)
    protected_objects = defaultdict(list)
    for related in get_candidate_relations_to_delete(model._meta):
        if keep_parents and related.model in parents:
            continue
        field = related.field
        if field.remote_field.on_delete == DO_NOTHING:
            continue
        related_model = related.related_model
        if self.can_fast_delete(related_model, from_field=field):
            model_fast_deletes[related_model].append(field)
            continue
        batches = self.get_del_batches(new_objs, [field])
        for batch in batches:
            sub_objs = self.related_objects(related_model, [field], batch)
            if not (sub_objs.query.select_related or self._has_signal_listeners(related_model)):
                referenced_fields = set(chain.from_iterable(((rf.attname for rf in rel.field.foreign_related_fields) for rel in get_candidate_relations_to_delete(related_model._meta))))
                sub_objs = sub_objs.only(*tuple(referenced_fields))
            if sub_objs:
                try:
                    field.remote_field.on_delete(self, field, sub_objs, self.using)
                except ProtectedError as error:
                    key = "'%s.%s'" % (field.model.__name__, field.name)
                    protected_objects[key] += error.protected_objects
    if protected_objects:
        raise ProtectedError('Cannot delete some instances of model %r because they are referenced through protected foreign keys: %s.' % (model.__name__, ', '.join(protected_objects)), set(chain.from_iterable(protected_objects.values())))
    for related_model, related_fields in model_fast_deletes.items():
        batches = self.get_del_batches(new_objs, related_fields)
        for batch in batches:
            sub_objs = self.related_objects(related_model, related_fields, batch)
            self.fast_deletes.append(sub_objs)
    for field in model._meta.private_fields:
        if hasattr(field, 'bulk_related_objects'):
            sub_objs = field.bulk_related_objects(new_objs, self.using)
            self.collect(sub_objs, source=model, nullable=True, fail_on_restricted=False)
    if fail_on_restricted:
        for related_model, instances in self.data.items():
            self.clear_restricted_objects_from_set(related_model, instances)
        for qs in self.fast_deletes:
            self.clear_restricted_objects_from_queryset(qs.model, qs)
        if self.restricted_objects.values():
            restricted_objects = defaultdict(list)
            for related_model, fields in self.restricted_objects.items():
                for field, objs in fields.items():
                    if objs:
                        key = "'%s.%s'" % (related_model.__name__, field.name)
                        restricted_objects[key] += objs
            if restricted_objects:
                raise RestrictedError('Cannot delete some instances of model %r because they are referenced through restricted foreign keys: %s.' % (model.__name__, ', '.join(restricted_objects)), set(chain.from_iterable(restricted_objects.values())))
8. Inside `Collector.can_fast_delete`:
    if from_field and from_field.remote_field.on_delete is not CASCADE:
        return False
    if hasattr(objs, '_meta'):
        model = objs._meta.model
    elif hasattr(objs, 'model') and hasattr(objs, '_raw_delete'):
        model = objs.model
    else:
        return False
    if self._has_signal_listeners(model):
        return False
    opts = model._meta
    return all((link == from_field for link in opts.concrete_model._meta.parents.values())) and all((related.field.remote_field.on_delete is DO_NOTHING for related in get_candidate_relations_to_delete(opts))) and (not any((hasattr(field, 'bulk_related_objects') for field in opts.private_fields)))
9. Inside `get_candidate_relations_to_delete`:
    return (f for f in opts.get_fields(include_hidden=True) if f.auto_created and (not f.concrete) and (f.one_to_one or f.one_to_many))
10. Inside `Options.get_fields`:
    if include_parents is False:
        include_parents = PROXY_PARENTS
    return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
11. Inside `Options._get_fields`:
    if include_parents not in (True, False, PROXY_PARENTS):
        raise TypeError('Invalid argument for include_parents: %s' % (include_parents,))
    topmost_call = seen_models is None
    if topmost_call:
        seen_models = set()
    seen_models.add(self.model)
    cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
    try:
        return self._get_fields_cache[cache_key]
    except KeyError:
        pass
    fields = []
    if include_parents is not False:
        for parent in self.parents:
            if parent in seen_models:
                continue
            if parent._meta.concrete_model != self.concrete_model and include_parents == PROXY_PARENTS:
                continue
            for obj in parent._meta._get_fields(forward=forward, reverse=reverse, include_parents=include_parents, include_hidden=include_hidden, seen_models=seen_models):
               