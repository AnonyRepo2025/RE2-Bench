1. The `fit` method is called with `X` and `y` as arguments.
2. `X` is a 2D array of shape (100, 1) and `y` is a 1D array of shape (100,).
3. The `fit` method first checks if `X` and `y` are valid.
4. Then, it checks if `self.transformer` is None. If it is, it creates a `FunctionTransformer` object with `self.func` and `self.inverse_func` as the `func` and `inverse_func` parameters respectively.
5. If `self.transformer` is not None, it checks if `self.func` and `self.inverse_func` are None. If they are not, it raises a ValueError.
6. If `self.check_inverse` is True, it checks if the inverse transform of `X` is equal to `X`.
7. If `self.regressor` is None, it creates a `LinearRegression` object.
8. Finally, it fits the `regressor_` with `X` and the transformed `y`.
[/THOUGHT]

[OUTPUT]
```
{
    "self": {
        "regressor_": {
            "coef_": "[-0.00000000e+00]",
            "intercept_": "17.2134918",
            "n_features_in_": "1",
            "n_jobs": null,
            "rank_": "1",
            "singular_": "[17.2134918]",
            "_residues": "1.7213491841385757e-30",
            "_sklearn_version": "0.24.2",
            "feature_names_in_": "[0]"
        },
        "transformer_": {
            "func": "\"<function sqrt>\"",
            "inverse_func": "\"<function log>\"",
            "validate": false,
            "accept_sparse": false,
            "check_inverse": true,
            "kw_args": null,
            "inv_kw_args": null
        },
        "func": "\"<function sqrt>\"",
        "inverse_func": "\"<function log>\"",
        "check_inverse": true
    }
}
```
[/OUTPUT]

[PYTHON]
.sklearn.linear_model.LinearRegression.__init__

def __init__(self, fit_intercept=True, normalize='deprecated', copy_X=True, n_jobs=None, positive=False):
    self.fit_intercept = fit_intercept
    self.normalize = normalize
    self.copy_X = copy_X
    self.n_jobs = n_jobs
    self.positive = positive

.sklearn.linear_model.LinearRegression.fit

def fit(self, X, y, sample_weight=None):
    X, y = check_X_y(X, y, ['csr', 'csc', 'coo'], dtype=FLOAT_DTYPES, y_numeric=True, multi_output=True)
    if sample_weight is not None:
        sample_weight = _check_sample_weight(sample_weight, X)
    return self._fit(X, y, sample_weight)

.sklearn.linear_model.LinearRegression._fit

def _fit(self, X, y, sample_weight=None):
    n_samples, n_features = X.shape
    X, y, X_offset, y_offset, X_scale = self._preprocess_data(X, y, fit_intercept=self.fit_intercept, normalize=self.normalize, copy=self.copy_X, sample_weight=sample_weight)
    self._set_intercept(X_offset, y_offset, X_scale)
    self._residues = _residuals(self, X, y, sample_weight=sample_weight)
    return self

.sklearn.linear_model.LinearRegression._set_intercept

def _set_intercept(self, X_offset, y_offset, X_scale):
    if self.fit_intercept:
        self.coef_ = self._residues[:n_features] / X_scale
        self.intercept_ = y_offset - np.dot(X_offset, self.coef_.T)
    else:
        self.coef_ = self._residues[:n_features]
        self.intercept