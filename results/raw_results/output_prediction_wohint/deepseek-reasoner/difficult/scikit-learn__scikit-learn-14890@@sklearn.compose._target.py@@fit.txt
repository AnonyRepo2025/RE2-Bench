The `fit` method modifies the `TransformedTargetRegressor` instance in-place and returns it. The key steps are:

1. **Input validation**:  
   - `y` is validated using `check_array` to ensure it's a numeric 1D array (shape `(100,)`).

2. **Set training dimension**:  
   - `self._training_dim = 1` since `y` is 1D.

3. **Reshape `y`**:  
   - `y` is reshaped to `(100, 1)` for transformer compatibility.

4. **Fit transformer**:  
   - Since `transformer=None` and both `func`/`inverse_func` are provided, a `FunctionTransformer` is initialized with `func=sqrt` and `inverse_func=log`.
   - The transformer checks if `sqrt` and `log` are inverses (they are not, so a `UserWarning` is issued).
   - The transformer is fitted to `y_2d`.

5. **Transform target**:  
   - `y_trans = transformer.transform(y_2d)` applies `sqrt` to `y`.
   - The result is squeezed back to 1D (`(100,)`).

6. **Fit regressor**:  
   - The `regressor` is cloned (as `LinearRegression` with given parameters).
   - `regressor.fit(X, y_trans)` is called to train on the transformed target.

**Output state**:  
- `_training_dim=1`  
- `transformer_`: Configured `FunctionTransformer`  
- `regressor_`: Fitted `LinearRegression` instance  

[OUTPUT]
{
    "regressor": {
        "fit_intercept": true,
        "normalize": false,
        "copy_X": true,
        "n_jobs": null
    },
    "transformer": null,
    "func": "\"<function sqrt>\"",
    "inverse_func": "\"<function log>\"",
    "check_inverse": true,
    "_training_dim": 1,
    "transformer_": {
        "func": "\"<function sqrt>\"",
        "inverse_func": "\"<function log>\"",
        "validate": true,
        "accept_sparse": false,
        "check_inverse": true,
        "kw_args": null,
        "inv_kw_args": null
    },
    "regressor_": {
        "fit_intercept": true,
        "normalize": false,
        "copy_X": true,
        "n_jobs": null,
        "coef_": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
        "intercept_": 0.0
    }
}
[/OUTPUT]