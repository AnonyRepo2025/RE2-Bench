[THOUGHT]
1. The `delete` method is called on a model instance with `id=99998`.
2. Since `self.pk` (which is `self.id`) is not `None`, it proceeds.
3. The `using` database is determined by `router.db_for_write`. Since no database is specified and `self._state.db` is "default", it uses "default".
4. A `Collector` is initialized with `using="default"` and `origin=self`.
5. `collector.collect([self], keep_parents=False)` is called:
   - `objs` is a list containing the single model instance.
   - `can_fast_delete(objs)` returns `False` because:
     - `objs` is a list, not a queryset with `_raw_delete`.
     - The model may have relations or signals preventing fast deletion.
   - `new_objs = self.add(objs, ...)` adds the instance to `collector.data`.
   - Since `keep_parents=False`, parent objects are collected if any exist (none here).
   - Related objects are collected via `get_candidate_relations_to_delete` (auto-created 1:1 or 1:many relations). No relations are provided in the input, so no additional objects are collected.
6. `collector.delete()` is called:
   - Since only one object exists in `collector.data`, it is deleted.
   - The return value is a tuple `(deleted_count, deleted_by_model)`, where `deleted_count` is the total number of objects deleted (1), and `deleted_by_model` is a dictionary mapping model classes to counts (`{ModelClass: 1}`).
7. The model class is unknown from the input, so it's represented as `"<class 'app_label.ModelName'>"` in the output.

Thus, the output is `(1, {"<class 'app_label.ModelName'>": 1})`.
[/THOUGHT]

[OUTPUT]
[
  1,
  {
    "<class 'app_label.ModelName'>": 1
  }
]
[/OUTPUT]