1. **`check_pairwise_arrays(X, Y)`:**
   - `_return_float_dtype(X, Y)` converts X and Y to numpy arrays with `dtype=np.float64`.
   - `check_array` further validates and potentially copies the arrays. Since `Y` is not `None` and `Y is not X`, both X and Y are checked individually.
   - The shapes of X and Y are compatible because `X.shape[1] == Y.shape[1] == 4`.
   - The function returns the validated numpy arrays X and Y.

2. **`X_norm_squared` and `Y_norm_squared` Calculation:**
   - Since `X_norm_squared` is not provided and `X.dtype` is not `np.float32`, `XX = row_norms(X, squared=True)[:, np.newaxis]` is computed.
   - `row_norms` calculates the squared Euclidean norm of each row of X.
   - `XX` will be a column vector of shape (1, 1) containing the squared norm of the single row in X.
   - Similarly, `YY = row_norms(Y, squared=True)[np.newaxis, :]` is computed, resulting in a row vector of shape (1, 1) containing the squared norm of the single row in Y.

3. **`distances` Calculation:**
   - `distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)` is computed.
   - `safe_sparse_dot` computes the dot product of X and Y.T. Since neither X nor Y are sparse, it's equivalent to `np.dot(X, Y.T)`.
   - The result is multiplied by -2.
   - `distances += XX` adds the squared norms of X to each column of `distances`.
   - `distances += YY` adds the squared norms of Y to each row of `distances`.

4. **`np.maximum(distances, 0, out=distances)`:**
   - This ensures that all elements in `distances` are non-negative. In this case, it's unlikely to change anything since Euclidean distances squared are always non-negative.

5. **Return `distances`:**
   - Since `squared=True`, the function returns the `distances` array without taking the square root.

Let's calculate the values:

```python
import numpy as np

X = np.array([[0.56804456, 0.92559664, 0.07103606, 0.0871293]])
Y = np.array([[0.96366276, 0.38344152, 0.79172504, 0.52889492]])

XX = np.sum(X * X, axis=1)[:, np.newaxis]
YY = np.sum(Y * Y, axis=1)[np.newaxis, :]

distances = -2 * np.dot(X, Y.T)
distances += XX
distances += YY

print(distances)
```

This will output: `[[1.02667916]]`

[OUTPUT]
```json
{
  "distances": [[1.02667916]]
}
```
[/OUTPUT]