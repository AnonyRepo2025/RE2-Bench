[THOUGHT]
Let's step through the function with the given input.

First, the function is `FitnessFunc.fit(self, t, x=None, sigma=None)`. The input is:
- self: has p0=0.05, gamma=None, ncp_prior=None
- t: a numpy array of 20 floats (times)
- x: a numpy array of 20 floats (values)
- sigma: 0.1

Assume that `self._fitness_args` and `self.fitness` are defined elsewhere, but since the code is incomplete, let's reason about the output structure.

### Step 1: Input validation
`t, x, sigma = self.validate_input(t, x, sigma)`
- This likely just ensures t, x, sigma are numpy arrays of the right shape. Let's assume t and x are already numpy arrays, sigma is a scalar.

### Step 2: Compute ak_raw, bk_raw, ck_raw
If 'a_k', 'b_k', 'c_k' in self._fitness_args, then:
- ak_raw = np.ones_like(x) / sigma**2 = np.ones(20) / 0.01 = np.ones(20) * 100 = array of 100s
- bk_raw = x / sigma**2 = x / 0.01 = x * 100
- ck_raw = x * x / sigma**2 = (x**2) / 0.01 = (x**2) * 100

### Step 3: Compute edges
edges = np.concatenate([t[:1], 0.5 * (t[1:] + t[:-1]), t[-1:]])
- t[:1] is the first element
- 0.5 * (t[1:] + t[:-1]) is the average of each pair of consecutive t's
- t[-1:] is the last element

So edges will be length 21 (for t of length 20).

### Step 4: block_length = t[-1] - edges
- t[-1] is the last value of t (let's call it t20)
- block_length is t20 - edges (so array of 21 values)

### Step 5: N = len(t) = 20

### Step 6: best = np.zeros(N), last = np.zeros(N, dtype=int)

### Step 7: ncp_prior
If self.ncp_prior is None, ncp_prior = self.compute_ncp_prior(N)
- Let's assume ncp_prior is a scalar (say, 4.5 for example, but the actual value depends on the implementation).

### Step 8: Main loop over R in range(N)
For R in 0..19:
- kwds is built up depending on self._fitness_args
- fit_vec = self.fitness(**kwds)  # returns a vector of length R+1
- A_R = fit_vec - ncp_prior
- A_R[1:] += best[:R]
- i_max = np.argmax(A_R)
- last[R] = i_max
- best[R] = A_R[i_max]

### Step 9: Backtrack to find change points
change_points = np.zeros(N, dtype=int)
i_cp = N
ind = N
while True:
    i_cp -= 1
    change_points[i_cp] = ind
    if ind == 0: break
    ind = last[ind - 1]
change_points = change_points[i_cp:]

### Step 10: Return edges[change_points]

### Output
The output is edges[change_points], which is a numpy array of the edges at the change points.

#### Since the actual fitness function and _fitness_args are not given, we cannot compute the exact output values. However, the output will be a numpy array of floats, a subset of the edges array, corresponding to the detected change points.

#### The output format should be a list of floats (the change point edges).

[/THOUGHT]
[OUTPUT]
```
{
    "result": "array of floats (change point edges), length <= 21"
}
```
[/OUTPUT]