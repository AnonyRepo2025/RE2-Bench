[THOUGHT]
We call get_integer_part(expr=1/2, no=-1, options={}, return_ints=True).

1. assumed_size=30  
2. evalf(1/2, 30, {}) will compute the real part of 1/2 to mpf ≈ 0.5, so we get  
   ire = (mpf-tuple for 0.5), iim = None, ire_acc ≈ 30, iim_acc = None  

3. Since ire is present, we compute calc_part on the real part:
   - nexpr = the mpf‐tuple for 0.5, so unpacking gives exponent p = –1 ≠ 0 → not an exact integer.
   - We form expr – nint with nint = int(to_int(nexpr)) = int(to_int(0.5)) = 0.
   - evalf(expr – 0, 10, {}) again yields x = mpf‐tuple for 0.5.
   - mpf_cmp(x, fzero) = +1, which is ≠ no (–1), so we do not adjust nint (remains 0).
   - calc_part returns (from_int(0), INF).

4. There is no imaginary part, so the imaginary integer part is 0.

5. return_ints=True → return (int(to_int(real_part)), int(to_int(imag_part))) = (0, 0).
[/THOUGHT]

[OUTPUT]
[0, 0]
[/OUTPUT]