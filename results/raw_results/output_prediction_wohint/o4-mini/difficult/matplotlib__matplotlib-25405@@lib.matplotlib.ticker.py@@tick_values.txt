[THOUGHT]
We have a LogLocator with:
- base b = 10.0
- subs = the string "[1.]" (not special-cased to 'auto')
- numticks = 3
- no axis

Call tick_values(vmin=6, vmax=150):

1. numticks is not 'auto', so numticks = 3.
2. vmin>0 and vmax>vmin, so proceed.
3. Compute
   log_vmin = log10(6) ≈ 0.77815
   log_vmax = log10(150) ≈ 2.17609
4. numdec = floor(log_vmax) – ceil(log_vmin)
         = 2 – 1 = 1
5. subs is a string ≠ 'auto', and numdec=1≤10 and b=10≥3, so
   _first = 1.0
   subs = np.arange(1.0, 10.0) → [1,2,3,4,5,6,7,8,9]
6. stride (modern mode) = numdec // numticks + 1 = 1 // 3 + 1 = 1
   since stride ≥ numdec (1 ≥ 1), we reset stride = max(1, numdec–1) = 1
7. have_subs = True (len(subs)>1)
8. decades = np.arange(floor(log_vmin)−stride,
                       ceil(log_vmax)+2·stride,
                       stride)
          = np.arange(0–1, 3+2, 1) = np.arange(-1, 5) = [-1,0,1,2,3,4]
9. No transform, but have_subs and stride==1 → use
     ticklocs = concatenate over each decade d of subs * b**d
   For d in [-1,0,1,2,3,4], b**d = [0.1,1,10,100,1000,10000].
   Multiplying subs [1..9] by each gives:
     [0.1–0.9],
     [1–9],
     [10–90],
     [100–900],
     [1000–9000],
     [10000–90000]
   Flattened → 54 values in ascending grouped order.
10. We check how many of these lie in [6,150]: there are more than one (in fact 14),
    so we do not fall back to AutoLocator and simply return this array.

Thus the result is the 54-element numpy array:

[0.1,0.2,...,0.9,
 1.0,2.0,...,9.0,
 10.0,20.0,...,90.0,
 100.0,200.0,...,900.0,
 1000.0,2000.0,...,9000.0,
 10000.0,20000.0,...,90000.0]
[/THOUGHT]

[OUTPUT]
[
 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9,
 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0,
 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0,
 100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0, 800.0, 900.0,
 1000.0, 2000.0, 3000.0, 4000.0, 5000.0, 6000.0, 7000.0, 8000.0, 9000.0,
 10000.0, 20000.0, 30000.0, 40000.0, 50000.0, 60000.0, 70000.0, 80000.0, 90000.0
]
[/OUTPUT]