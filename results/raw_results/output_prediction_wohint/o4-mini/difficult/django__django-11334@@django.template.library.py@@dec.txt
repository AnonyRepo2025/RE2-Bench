[THOUGHT]
1. We call Library.simple_tag(self, func=<function>, takes_context=None, name=None).
2. In `simple_tag`, `func` is not None and is callable, so we go to the `elif callable(func):` branch and return `dec(func)`.
3. Inside `dec(func)`:
   a. We compute `getfullargspec(unwrap(func))` but ignore its values for the return.
   b. We set `function_name = name or getattr(func, '_decorated_function', func).__name__`. Here `name` is None and `func` has no `_decorated_function`, so `function_name = func.__name__` which is "func".
   c. We define `compile_func` and register it via `self.tag("func", compile_func)`, but this side‚Äêeffect does not change `func`.
   d. Finally, `dec` returns the original `func` object unchanged.
4. Therefore, the output of `dec` is exactly the same function object we passed in, with the same metadata.

[/THOUGHT]

[OUTPUT]
```
{
  "return": {
    "__module__": "template_tests.test_library",
    "__name__": "func",
    "__qualname__": "SimpleTagRegistrationTests.test_simple_tag_wrapped.\"<locals>\".func",
    "__doc__": null,
    "__annotations__": {},
    "__wrapped__": {}
  }
}
```
[/OUTPUT]