[THOUGHT]
We call extract_code_from_html_text(html_text).

1. format_line_html_text(html_text):
   - Parse with BeautifulSoup.
   - Find all <pre> and <blockquote> tags (there are two <pre> tags).
     For each, set tag.string = self.CODE_MARK (i.e. "-CODE-").
   - No <ul> or <ol>, skip.
   - Process <p> tags: both paragraphs end with ".", so they remain unchanged.
   - Get text via soup.get_text(), which now contains two occurrences of "-CODE-".
   - __format_line_feed likely normalizes line breaks but does not remove "-CODE-".
   => text_with_code_tag contains "-CODE-" twice.

2. Back in extract_code_from_html_text:
   - CODE_MARK is present, so proceed.
   - Re-parse original html_text with BeautifulSoup into `soup`.
   - code_tag = soup.find_all(['pre','blockquote']) gives two elements:
     a) <pre>print('Hello, world!')</pre>
     b) <pre><code>for i in range(4):
                print(i)</code></pre>
   - code_count = count of CODE_MARK in formatted text = 2.
   - Loop over code_index = 0,1:
     - code_tag[0].get_text() → "print('Hello, world!')"
     - code_tag[1].get_text() → the code block text, including the line break and indentation:
         "for i in range(4):\n                print(i)"
   - Collect these into a list and return it.

Thus the output list is:
[
  "print('Hello, world!')",
  "for i in range(4):\n                print(i)"
]
[/THOUGHT]

[OUTPUT]
```
{
    "output": [
        "print('Hello, world!')",
        "for i in range(4):\n                print(i)"
    ]
}
```
[/OUTPUT]