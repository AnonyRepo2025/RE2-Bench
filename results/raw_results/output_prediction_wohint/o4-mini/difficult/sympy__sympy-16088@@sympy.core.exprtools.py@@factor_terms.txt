[THOUGHT]
1. The input expression is the string "R3 + R4 + 4050".  
2. sympify parses this into the SymPy expression Add(R3, R4, 4050).  
3. factor_terms calls do(expr) on this Add.  
4. In do:
   - expr.is_Add is True, so it does the content‐primitive split: `cont, p = expr.as_content_primitive(...)`.  
     For an Add, this yields cont=1, p=R3+R4+4050.  
   - It then recursively calls do on each summand:
     • do(R3) returns R3 (it's an atom).  
     • do(R4) returns R4.  
     • do(4050) returns 4050.  
   - Collecting back gives list_args = [R3, R4, 4050].  
   - It checks whether all summands carry a factor of –1 that could be pulled out; 4050 fails this check, so no sign is factored.  
   - It rebuilds the Add from [R3, R4, 4050], then calls gcd_terms but with no common polynomial factor among symbol terms and the integer.  
   - Finally _keep_coeff(1, p) just returns p unchanged.  
5. The result is the same sum, possibly with the terms ordered as SymPy would print them: 4050 + R3 + R4 (SymPy orders numbers before symbols).  
6. Therefore factor_terms returns the SymPy expression 4050 + R3 + R4.  
[/THOUGHT]

[OUTPUT]
{
  "return": "4050 + R3 + R4"
}
[/OUTPUT]