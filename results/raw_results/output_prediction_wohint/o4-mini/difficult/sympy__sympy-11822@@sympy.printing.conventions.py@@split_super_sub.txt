[THOUGHT]
We call split_super_sub("alpha^+_1").

Initialize pos=0, name=None, supers=[], subs=[].

Iteration 1:
- pos=0, start=1, text[0:2]="al"≠'__'
- find '^' from 1 → at index 5; find '_' from 1 → at index 7
- pos_next = min(5,7) = 5
- part = text[0:5] = "alpha"
- name was None, so name = "alpha"
- pos = 5

Iteration 2:
- pos=5, start=6, text[5:7]="^+"≠'__'
- find '^' from 6 → none → pos_hat=9; find '_' from 6 → at 7
- pos_next = min(9,7) = 7
- part = text[5:7] = "^+"
- name set, part.startswith('^') → supers.append(part[1:]) = supers.append("+")
- supers = ["+"]
- pos = 7

Iteration 3:
- pos=7, start=8, text[7:9]="_1"≠'__'
- find '^' from 8 → none → pos_hat=9; find '_' from 8 → none → pos_usc=9
- pos_next = 9
- part = text[7:9] = "_1"
- part.startswith('_') → subs.append(part[1:]) = subs.append("1")
- subs = ["1"]
- pos = 9

Loop ends (pos == len(text) == 9).

Now name = "alpha". Regex `^([A-Za-z]+)([0-9]+)$` does not match "alpha" (no trailing digits), so we leave subs as is.

Return (name, supers, subs) = ("alpha", ["+"], ["1"]).
[/THOUGHT]

[OUTPUT]
{
  "name": "alpha",
  "supers": ["+"],
  "subs": ["1"]
}
[/OUTPUT]