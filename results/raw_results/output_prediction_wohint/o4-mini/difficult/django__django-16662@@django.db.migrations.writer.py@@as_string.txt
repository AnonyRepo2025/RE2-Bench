[THOUGHT]
We call MigrationWriter.as_string with:
- self.include_header = False
- self.migration.operations is empty (or None treated as empty)
- self.migration.dependencies is empty
- self.migration.replaces is falsey
- self.migration.initial is false

Steps:
1. Collect operations: none → items['operations'] = ''.
2. Collect dependencies: none → items['dependencies'] = ''.
3. imports starts empty; since none added, we fall into the else and add 'from django.db import migrations'.
4. No migration_imports, no 'from django.db import models' to adjust.
5. items['imports'] = 'from django.db import migrations\n'
6. items['migration_header'] = '' (include_header False).
7. items['replaces_str'] = ''.
8. items['initial_str'] = ''.
9. Plug into MIGRATION_TEMPLATE:

"%(migration_header)s%(imports)s\n\nclass Migration(migrations.Migration):\n%(replaces_str)s%(initial_str)s    dependencies = [\n%(dependencies)s    ]\n\n    operations = [\n%(operations)s    ]\n"

Becomes:

from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
    ]

    operations = [
    ]

(with a trailing newline)

That's the returned string.
[/THOUGHT]
[OUTPUT]
from django.db import migrations

class Migration(migrations.Migration):
    dependencies = [
    ]

    operations = [
    ]

[/OUTPUT]