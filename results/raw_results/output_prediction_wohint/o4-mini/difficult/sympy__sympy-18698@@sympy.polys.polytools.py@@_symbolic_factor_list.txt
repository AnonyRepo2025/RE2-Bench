[THOUGHT]
We call `_symbolic_factor_list(expr, opt, method)` with
  expr = x + 4  (a SymPy Add)
  opt = {}      (we assume a default‐constructed poly options object, so that `_poly_from_expr` works)
  method = "factor"

1. Initialize `coeff = S.One` and `factors = []`.
2. Build `args` via `Mul.make_args(expr)`. Since `expr` is not a Mul, `Mul.make_args` returns `(sympify(expr),)` i.e. `(x+4,)`. None of these have an `_eval_factor` method, so `args = [x+4]`.
3. Loop over `arg = x+4`:
   - `arg.is_Number` is False.
   - `arg.is_Pow` is False.
   - So we set `base = arg = x+4` and `exp = S.One`.
4. Attempt `_poly_from_expr(base, opt)`. This succeeds, yielding `poly = Poly(x+4, x)` (over QQ by default).
5. We look up `func = getattr(poly, "factor_list")`, then call it:
     `_coeff, _factors = poly.factor_list()`
   For `x+4`, `poly.factor_list()` returns `(1, [(x+4, 1)])`.
6. Since `_coeff` is `1` (i.e. `S.One`), we don’t multiply it into `coeff`.
7. Because `exp is S.One`, we extend `factors` by `_factors`, giving `factors = [(x+4, 1)]`.
8. No special `"sqf"` handling is needed.
9. We return `(coeff, factors)`, i.e. `(S.One, [(x+4,1)])`, which prints as `(1, [(x + 4, 1)])`.

[/THOUGHT]
[OUTPUT]
(1, [(x + 4, 1)])
[/OUTPUT]