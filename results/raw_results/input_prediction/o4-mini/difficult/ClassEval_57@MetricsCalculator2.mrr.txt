[THOUGHT]
The `mrr` function sees `data` as a list, so it goes into the `type(data) == list` branch. It will loop over each `(sub_list, total_num)` pair, compute

  ranking_array = [1/1, 1/2, 1/3, …]  
  mr_np = sub_list * ranking_array  
  mr = first positive entry of mr_np

and then return `(mean of all mr’s, [mr’s])`.

To get an MRR of 0.25:

– We need `mr_np` to have its first positive at 0.25.  
– That happens if `sub_list = [0, 0, 1, 1]`, since ranking_array = [1, 1/2, 1/3, 1/4], so mr_np = [0, 0, 1/3, 1/4] ⇒ first positive = 0.25.  
  **Iteration 1: team=0, team > 0 is false.
  **Iteration 2: team=0, team > 0 is false.
  **Iteration 3: team=0.33333333, team > 0 is true,
  mr=0.33333333
  **Iteration 4: team=0.25, team > 0 is true, mr = 0.25.
With a single query,  
  separate_result = [0.25],  
  mean = 0.25,  

so the function returns `(0.25, [0.25])`, matching the observed output.

Thus the input should be:

{
  "data": [
    ([0, 0, 1, 1], 1)
  ]
}

In JSON (tuples as arrays), that is `[[[0, 0, 1, 1], 1]]`.  
[/THOUGHT]

[INPUT]
```
{
    "self": {},
    "args": {
        "data": [
            [
                [0, 0, 1, 1],
                1
            ]
        ]
    },
    "kwargs": {}
}
```
[/INPUT]