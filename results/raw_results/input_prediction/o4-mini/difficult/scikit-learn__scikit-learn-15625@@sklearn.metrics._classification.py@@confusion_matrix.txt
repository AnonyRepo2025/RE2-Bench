[THOUGHT]
The confusion matrix returned is  
```
[[20 20]
 [10 50]]
```  
where entry (i,j) is the sum of sample_weights for all instances with true label i and predicted label j.

By default, `labels=None`, so `labels = unique_labels(y_true, y_pred)` picks the sorted unique labels present.

Also, if `sample_weight=None`, each sample is weighted 1, so the counts would have to be 20,20,10,50 occurrencesâ€”i.e. 100 samples total, which is unwieldy to list.

A more concise construction is to supply a `sample_weight` array. For example, with only four sample entries:

 y_true = [0, 0, 1, 1]  
 y_pred = [0, 1, 0, 1]  
 sample_weight = [20, 20, 10, 50]  

This yields exactly:  
- weight 20 at (true=0, pred=0)  
- weight 20 at (0,1)  
- weight 10 at (1,0)  
- weight 50 at (1,1)  

and so produces the desired matrix. In this case, `labels=None` can be represented as `null` in JSON.

Therefore the input is:
[INPUT]
```
{
    "self": {},
    "args": {
        "y_true": [0, 0, 1, 1],
        "y_pred": [0, 1, 0, 1]
    },
    "kwargs": {
        "labels": null,
        "sample_weight": [20, 20, 10, 50]
    }
}
```
[/INPUT]