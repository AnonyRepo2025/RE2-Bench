[THOUGHT]
We know from the output that after calling partial_fit we have

- n_components was left as None (so n_components_ was set internally to min(n_samples, n_features) = 3),
- whiten=False, copy=True, batch_size="18" all unchanged from __init__,
- batch_size_ was already set to "18" (so this must have been done in a prior call to fit),
- components_ was initially None,
- n_samples_seen_, mean_, var_ were initialized to 0 or 0.0 by the first partial_fit entry guard,
- singular_values_, explained_variance_, explained_variance_ratio_, noise_variance_ were initially None,
- n_components_ did not yet exist before the call.

The call to partial_fit must therefore have had

  args:
    X = a dense numpy array of shape (100, 3) (dtype float64 or float32)
  kwargs:
    check_input left at its default value True

Putting this together, the `self` state just before the call (after __init__ and a prior fit that set batch_size_) must have been:

  n_components: None
  whiten: False
  copy: True
  batch_size: "18"
  components_: None
  n_samples_seen_: 0
  mean_: 0.0
  var_: 0.0
  singular_values_: None
  explained_variance_: None
  explained_variance_ratio_: None
  noise_variance_: None
  batch_size_: "18"
  n_components_: None

And the partial_fit call was

  partial_fit(X, check_input=True)

where X is the original 100Ã—3 data array.

[/THOUGHT]

[INPUT]
{
  "self": {
    "n_components": null,
    "whiten": false,
    "copy": true,
    "batch_size": "18",
    "components_": null,
    "n_samples_seen_": 0,
    "mean_": 0.0,
    "var_": 0.0,
    "singular_values_": null,
    "explained_variance_": null,
    "explained_variance_ratio_": null,
    "noise_variance_": null,
    "batch_size_": "18",
    "n_components_": null
  },
  "args": {
    "X": "numpy.ndarray of shape (100, 3)"
  },
  "kwargs": {
    "check_input": true
  }
}
[/INPUT]