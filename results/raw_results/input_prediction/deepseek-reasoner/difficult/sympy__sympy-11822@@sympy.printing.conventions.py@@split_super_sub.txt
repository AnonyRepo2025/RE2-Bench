[THOUGHT]
To achieve the output `["alpha", ["+"], ["1"]`, the input string `text` must be processed as follows by `split_super_sub`:

1. The base name should be "alpha", which implies the first token in the string must either be "alpha" (no trailing digits) or include digits that are split later.
2. A superscript "+" is present, indicated by a `^+` segment or a `__+` segment.
3. A subscript "1" is present, which can come from an explicit `_1` segment or from trailing digits in the base name (like "alpha1" splitting into "alpha" and "1").

Possible valid inputs include:
- `"alpha1^+"`: Base name "alpha1" splits into "alpha" and subscript "1", then a superscript "+".
- `"alpha_1^+"`: Base name "alpha", explicit subscript "_1", then superscript "^+".
- `"alpha^+_1"`: Base name "alpha", superscript "^+", then subscript "_1".

The output does not distinguish the input order of superscript and subscript tokens, but the lists contain single elements. The most natural LaTeX-style representation (`alpha_1^+`) is chosen here for clarity and familiarity in mathematical notation, where subscripts often precede superscripts. This input results in:
- First token: "alpha" (base name).
- Second token: "_1" → subscript "1".
- Third token: "^+" → superscript "+".
- The base name "alpha" has no trailing digits, so no additional digit splitting occurs.
Thus, the function will return `("alpha", ["+"], ["1"])`.
[/THOUGHT]

[INPUT]
{
    "self": {},
    "args": {
        "text": "alpha_1^+"
    },
    "kwargs": {}
}
[/INPUT]