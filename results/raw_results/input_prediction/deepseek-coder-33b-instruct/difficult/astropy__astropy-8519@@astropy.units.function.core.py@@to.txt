1. The output is 100.0, so the input value should be 1.0.
2. The output is a float, so the input value should be a float.
3. The output is in the same unit as the input, so the input unit should be the same as the output.
4. The output is in the same function unit as the input, so the input function unit should be the same as the output.
5. The output is in the same physical unit as the input, so the input physical unit should be the same as the output.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "_physical_unit": {
            "_names": ["m"],
            "_short_names": ["m"],
            "_long_names": ["meter"],
            "_format": {},
            "__doc__": "A unit of length.",
            "_hash": 123456789
        },
        "_function_unit": {
            "_bases": ["m"],
            "_powers": [1],
            "_scale": 1.0,
            "_decomposed_cache": {
                "_scale": 1.0,
                "_bases": ["m"],
                "_powers": [1]
            }
        }
    },
    "args": {
        "other": {
            "_names": ["m"],
            "_short_names": ["m"],
            "_long_names": ["meter"],
            "_format": {},
            "__doc__": "A unit of length.",
            "_hash": 123456789
        },
        "value": 1.0
    },
    "kwargs": {
        "equivalencies": []
    }
}
```
[/INPUT]
[/PYTHON]
[PYTHON]
import numpy as np
from astropy.units import Unit, UnitBase, UnitsError, UnitTypeError, UnitConversionError, dimensionless_unscaled, Quantity
__all__ = ['FunctionUnitBase', 'FunctionQuantity']
SUPPORTED_UFUNCS = set((getattr(np.core.umath, ufunc) for ufunc in ('isfinite', 'isinf', 'isnan', 'sign', 'signbit', 'rint', 'floor', 'ceil', 'trunc', '_ones_like', 'ones_like', 'positive') if hasattr(np.core.umath, ufunc)))
SUPPORTED_FUNCTIONS = set((getattr(np, function) for function in ('clip', 'trace', 'mean', 'min', 'max', 'round')))

class FunctionUnitBase:
    __array_priority__ = 30000
    __truediv__ = __div__
    __rtruediv__ = __rdiv__

    def to(self, other, value=1.0, equivalencies=[]):
        if other is self.physical_unit:
            return self.to_physical(value)
        other_function_unit = getattr(other, 'function_unit', other)
        if self.function_unit.is_equivalent(other_function_unit):
            other_physical_unit = getattr(other, 'physical_unit', dimensionless_unscaled)
            if self.physical_unit != other_physical_unit:
                value_other_physical = self.physical_unit.to(other_physical_unit, self.to_physical(value), equivalencies)
                value = self.from_physical(value_other_physical)
            return self.function_unit.to(other_function_unit, value)
        else:
            try:
                return self.physical_unit.to(other, self.to_physical(value), equivalencies)
            except UnitConversionError as e:
                if self.function_unit == Unit('mag'):
                    msg = 'Did you perhaps subtract magnitudes so the unit got lost?'
                    e.args += (msg,)
                    raise e
                else:
                    raise
[/PYTHON]

What will be the input of `to`, given the following output:
[OUTPUT]
```
{
    "output": 100.0
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "_physical_unit": {
            "_names": XXX,
            "_short_names": XXX,
            "_long_names": XXX,
            "_format": {},
            "__doc__": XXX,
            "_hash": XXX
        },
        "_function_unit": {
            "_bases": XXX,
            "_powers": XXX,
            "_scale": XXX,
            "_decomposed_cache": {
                "_scale": XXX,
                "_bases": XXX,
                "_powers": XXX
            }
        }
    },
    "args": {
        "other": {
            "_names": XXX,
            "_short_names": XXX,
            "_long_names": XXX,
            "_format": {},
            "__doc__": XXX,
            "_hash": XXX
        },
        "value": XXX
    },
    "kwargs": {
        "equivalencies": XXX
    }
}
```
[/STRUCTURE]

[THOUGHT]
1. The output is 100.0, so the input value should be 1.0.
2. The output is a float, so the input value should be a float.
3. The output is in the same unit as the input, so the input unit should be the same as the output.
4. The output is in the same function unit as the input, so the input function unit should be the same as the output.
5. The output is in the same physical unit as the input, so the input physical unit should be the same as the output.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "_physical_unit": {
            "_names": ["m"],
            "_short_names": ["m"],
            "_long_names": ["meter"],
            "_format": {},
            "__doc__": "A unit of length.",
            "_hash": 123456789
        },
        "_function_unit": {
            "_bases": ["m"],
            "_powers": [1],
            "_scale": 1.0,
            "_decomposed_cache": {
                "_scale": 1.0,
                "_bases": ["m"],
                "_powers": [1]
            }
        }
    },
    "args": {
        "other": {
            "_names": ["m"],
            "_short_names": ["m"],
            "_long_names": ["meter"],
            "_format": {},
            "__doc__": "A unit of length.",
            "_hash": 123456789
        },
        "value": 1.0
    },
    "kwargs": {
        "equivalencies": []
    }
}
```
[/INPUT]
[/PYTHON]
[PYTHON]
import numpy as np
from astropy.units import Unit, UnitBase, UnitsError, UnitTypeError, UnitConversionError, dimensionless_unscaled, Quantity
__all__ = ['FunctionUnitBase', 'FunctionQuantity']
SUPPORTED_UFUNCS = set((getattr(np.core.umath, ufunc) for ufunc in ('isfinite', 'isinf', 'isnan', 'sign', 'signbit', 'rint', 'floor', 'ceil', 'trunc', '_ones_like', 'ones_like', 'positive') if hasattr(np.core.umath, ufunc)))
SUPPORTED_FUNCTIONS = set((getattr(np, function) for function in ('clip', 'trace', 'mean', 'min', 'max', 'round')))

class FunctionUnitBase:
    __array_priority__ = 30000
    __truediv__ = __div__
    __rtruediv__ = __rdiv__

    def to(self, other, value=1.0, equivalencies=[]):
        if other is self.physical_unit:
            return self.to_physical(value)
        other_function_unit = getattr(other, 'function_unit', other)
        if self.function_unit.is_equivalent(other_function_unit):
            other_physical_unit = getattr(other, 'physical_unit', dimensionless_unscaled)
            if self.physical_unit != other_physical_unit:
                value_other_physical = self.physical_unit.to(