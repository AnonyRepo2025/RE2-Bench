
The Chandrasekhar Sieve is a method of finding all primes up to a given limit n. It works by iteratively marking the multiples of each prime number starting from 2.

The output is a list of prime numbers up to 13. So, the input n should be 13.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "n": 13,
        "primes": [
            2,
            3,
            5,
            7,
            11,
            13
        ]
    },
    "args": {},
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
class CaesarCipher:

    def __init__(self, shift: int = 3):
        self.shift = shift

    @classmethod
    def normalize(cls, text: str) -> str:
        return str(text).replace("\r\n", "\n").replace("\r", "\n")

    @classmethod
    def _alpha_index(cls, ch: str) -> int:
        if "A" <= ch <= "Z":
            return ord(ch) - ord("A")
        if "a" <= ch <= "z":
            return ord(ch) - ord("a")
        return -1

    @classmethod
    def _shift_char(cls, ch: str, k: int) -> str:
        idx = cls._alpha_index(ch)
        if idx == -1:
            return ch  # non-letter unchanged
        base = ord("A") if ch.isupper() else ord("a")
        return chr(base + (idx + k) % 26)

    @classmethod
    def _transform(cls, text: str, k: int) -> str:
        text = cls.normalize(text)
        return "".join(cls._shift_char(c, k) for c in text)


    def encode(self, plaintext: str) -> str:
        return self._transform(plaintext, self.shift)

    def decode(self, ciphertext: str) -> str:
        return self._transform(ciphertext, -self.shift)
[/PYTHON]

What will be the input of `decode`, given the following output:

[OUTPUT]
```
{
    "output": "Hello, World!"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "shift": XXX
    },
    "args": {
        "ciphertext": XXX
    },
    "kwargs": XXX
}
```
[/STRUCTURE]

[THOUGHT]
The Caesar cipher is a type of substitution cipher in which each letter in the plaintext is 'shifted' a certain number of places down the alphabet. In this case, the shift is 3.

The output is "Hello, World!". So, the input ciphertext should be "Khoor, Zruog!".
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "shift": 3
    },
    "args": {
        "ciphertext": "Khoor, Zruog!"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
class ChandrasekharSieve:

    def __init__(self, n):
        self.n = n
        self.primes = self.generate_primes()

    def generate_primes(self):
        if self.n < 2:
            return []
        sieve = [True] * (self.n + 1)
        sieve[0] = sieve[1] = False
        p = 2
        while p * p <= self.n:
            if sieve[p]:
                for i in range(p * p, self.n + 1, p):
                    sieve[i] = False
            p += 1
        primes = []
        for i in range(2, self.n + 1):
            if sieve[i]:
                primes.append(i)
        return primes
[/PYTHON]

What will be the input of `generate_primes`, given the following output:
[OUTPUT]
```
{
    "output": [
        2,
        3,
        5,
        7,
        11,
        13,
        17,
        19,
        23,
        29,
        31,
        37,
        41,
        43,
        47,
        53,
        59,
        61,
        67,
        71,
        73,
        79,
        83,
        89,
        97
    ]
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "n": XXX,
        "primes": XXX
    },
    "args": {},
    "kwargs": {}
}
```
[/STRUCTURE]

[THOUGHT]
The Chandrasekhar Sieve is a method of finding all primes up to a given limit n. It works by iteratively marking the multiples of each prime number starting from 2.

The output is a list of prime numbers up to 97. So, the input n should be 97.
[/THOUGHT]

[INPUT]
```
{
    "self": {
        "n": 97,
        "primes": [
            2,
            3,
            5,
            7,
            11,
            13,
            17,
            19,
            23,
            29,
            31,
            37,
            41,
            43,
            47,
            53,
            59,
            61,
            67,
            71,
            73,
            79,
            83,
            89,
            97
        ]
    },
    "args": {},
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
class CaesarCipher:

    def __init__(self, shift: int = 3):
        self.shift = shift

    @classmethod
    def normalize(cls, text: str) -> str:
        return str(text).replace("\r\n", "\n").replace("\r", "\n")

    @classmethod
    def _alpha_index(cls, ch: str) -> int:
        if "A" <= ch <= "Z":
            return ord(ch) - ord("A")
        if "a" <= ch <= "z":
            return ord(ch) - ord("a")
        return -1

    @classmethod
    def _shift_char(cls, ch: str, k: int) -> str:
        idx = cls._alpha_index(ch)
        if idx == -1:
            return ch  # non-letter unchanged
        base = ord("A") if ch.isupper() else ord("a")
        return chr(base + (idx + k) % 26)

    @classmethod
    def _transform(cls, text: str, k: int) -> str:
        text = cls.normalize(text)
        return "".join(cls._shift_char(c, k) for c in text)


    def encode(self, plaintext: str) -> str:
        return self._transform(plaintext, self.shift)

    def decode(self, ciphertext: str) -> str:
        return self._transform(ciphertext, -self.shift)
[/PYTHON]

What will be the input of `decode`, given the following output:

[OUTPUT]
```
{
    "output": "Hello, World!"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "shift": XXX
    },
    "args": {
        "ciphertext": XXX
    },
    "kwargs": XXX
}
```
[/STRUCTURE]

[THOUGHT]
The Caesar cipher is a type of substitution cipher in which each letter in the plaintext is