Let's trace the execution of the `prepare` method with a few simple examples to understand how it transforms an infix expression to postfix notation.

**Example 1:  "2+3"**

1. **Initialization:**
   - `postfix_stack`: []
   - `op_stack`: [',']

2. **Processing '2':**
   - `count`: 1
   - `current_index`: 0

3. **Processing '+':**
   - `count`: 1 > 0, so `postfix_stack.append('2')`: ['2']
   - `peek_op`: ','
   - '+' is an operator. Since ',' has lower precedence, '+' is pushed onto `op_stack`: [',', '+']
   - `count`: 0
   - `current_index`: 2

4. **Processing '3':**
   - `count`: 1
   - `current_index`: 2

5. **Loop ends:**
   - `count`: 1 > 0, so `postfix_stack.append('3')`: ['2', '3']
   - While loop pops '+' from `op_stack` and appends to `postfix_stack`: ['2', '3', '+']

**Example 2: "2+3*4"**

Following a similar process, the `postfix_stack` becomes ['2', '3', '4', '*', '+'].

**Example 3: "(2+3)*4"**

The parentheses change the order of operations. The `postfix_stack` becomes ['2', '3', '+', '4', '*'].

**Example 4: "100*(2+12)/14"**
The postfix_stack becomes ['100', '2', '12', '+', '*', '14', '/']

**Given Output:**

The output is `null`, which means the `postfix_stack` is modified but not returned.  We can choose any valid expression as input. Let's use a simple one: "2+3".


[INPUT]
```
{
    "self": {
        "postfix_stack": [],
        "operat_priority": [0, 3, 2, 1, -1, 1, 0, 2]
    },
    "args": {
        "expression": "2+3"
    },
    "kwargs": {}
}
```
[/INPUT]
