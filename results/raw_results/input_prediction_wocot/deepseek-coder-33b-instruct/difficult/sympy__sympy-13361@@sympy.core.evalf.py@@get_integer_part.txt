
[INPUT]
```
{
    "self": {},
    "args": {
        "expr": "0",
        "no": 0,
        "options": {}
    },
    "kwargs": {
        "return_ints": False
    }
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from __future__ import print_function, division
import math
import mpmath.libmp as libmp
from mpmath import make_mpc, make_mpf, mp, mpc, mpf, nsum, quadts, quadosc, workprec
from mpmath import inf as mpmath_inf
from mpmath.libmp import from_int, from_man_exp, from_rational, fhalf, fnan, fnone, fone, fzero, mpf_abs, mpf_add, mpf_atan, mpf_atan2, mpf_cmp, mpf_cos, mpf_e, mpf_exp, mpf_log, mpf_lt, mpf_mul, mpf_neg, mpf_pi, mpf_pow, mpf_pow_int, mpf_shift, mpf_sin, mpf_sqrt, normalize, round_nearest, to_int, to_str
from mpmath.libmp import bitcount as mpmath_bitcount
from mpmath.libmp.backend import MPZ
from mpmath.libmp.libmpc import _infs_nan
from mpmath.libmp.libmpf import dps_to_prec, prec_to_dps
from mpmath.libmp.gammazeta import mpf_bernoulli
from .compatibility import SYMPY_INTS, range
from .sympify import sympify
from .singleton import S
from sympy.utilities.iterables import is_sequence
from sympy.functions.elementary.complexes import re, im
from sympy.core.numbers import Float
from sympy.core.numbers import Float
from sympy import cos, sin
from sympy import Abs, Add, log
from sympy import Float, Integer
from sympy.core.numbers import Infinity, NegativeInfinity, Zero
from sympy import Poly
from sympy import Float, hypersimp, lambdify
from sympy import Sum
from sympy import Float
from sympy.functions.combinatorial.numbers import bernoulli
from sympy.concrete.products import Product
from sympy.concrete.summations import Sum
from sympy.core.add import Add
from sympy.core.mul import Mul
from sympy import cos, sin, Wild
from sympy import Float, Number
from sympy.core.expr import _mag
from sympy.core.compatibility import as_int
LG10 = math.log(10, 2)
rnd = round_nearest
INF = float(mpmath_inf)
MINUS_INF = float(-mpmath_inf)
DEFAULT_MAXPREC = 333
evalf_table = None

def get_integer_part(expr, no, options, return_ints=False):
    from sympy.functions.elementary.complexes import re, im
    assumed_size = 30
    ire, iim, ire_acc, iim_acc = evalf(expr, assumed_size, options)
    if ire and iim:
        gap = max(fastlog(ire) - ire_acc, fastlog(iim) - iim_acc)
    elif ire:
        gap = fastlog(ire) - ire_acc
    elif iim:
        gap = fastlog(iim) - iim_acc
    else:
        return (None, None, None, None)
    margin = 10
    if gap >= -margin:
        ire, iim, ire_acc, iim_acc = evalf(expr, margin + assumed_size + gap, options)

    def calc_part(expr, nexpr):
        from sympy.core.add import Add
        nint = int(to_int(nexpr, rnd))
        n, c, p, b = nexpr
        is_int = p == 0
        if not is_int:
            s = options.get('subs', False)
            if s:
                doit = True
                from sympy.core.compatibility import as_int
                for v in s.values():
                    try:
                        as_int(v)
                    except ValueError:
                        try:
                            [as_int(i) for i in v.as_real_imag()]
                            continue
                        except (ValueError, AttributeError):
                            doit = False
                            break
                if doit:
                    expr = expr.subs(s)
            expr = Add(expr, -nint, evaluate=False)
            x, _, x_acc, _ = evalf(expr, 10, options)
            try:
                check_target(expr, (x, None, x_acc, None), 3)
            except PrecisionExhausted:
                if not expr.equals(0):
                    raise PrecisionExhausted
                x = fzero
            nint += int(no * (mpf_cmp(x or fzero, fzero) == no))
        nint = from_int(nint)
        return (nint, INF)
    re_, im_, re_acc, im_acc = (None, None, None, None)
    if ire:
        re_, re_acc = calc_part(re(expr, evaluate=False), ire)
    if iim:
        im_, im_acc = calc_part(im(expr, evaluate=False), iim)
    if return_ints:
        return (int(to_int(re_ or fzero)), int(to_int(im_ or fzero)))
    return (re_, im_, re_acc, im_acc)
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.core.evalf.evalf

def evalf(x, prec, options):
    from sympy import re as re_, im as im_
    try:
        rf = evalf_table[x.func]
        r = rf(x, prec, options)
    except KeyError:
        try:
            if 'subs' in options:
                x = x.subs(evalf_subs(prec, options['subs']))
            xe = x._eval_evalf(prec)
            re, im = xe.as_real_imag()
            if re.has(re_) or im.has(im_):
                raise NotImplementedError
            if re == 0:
                re = None
                reprec = None
            elif re.is_number:
                re = re._to_mpmath(prec, allow_ints=False)._mpf_
                reprec = prec
            if im == 0:
                im = None
                imprec = None
            elif im.is_number:
                im = im._to_mpmath(prec, allow_ints=False)._mpf_
                imprec = prec
            r = (re, im, reprec, imprec)
        except AttributeError:
            raise NotImplementedError
    if options.get('verbose'):
        print('### input', x)
        print('### output', to_str(r[0] or fzero, 50))
        print('### raw', r)
        print()
    chop = options.get('chop', False)
    if chop:
        if chop is True:
            chop_prec = prec
        else:
            chop_prec = int(round(-3.321 * math.log10(chop) + 2.5))
            if chop_prec == 3:
                chop_prec -= 1
        r = chop_parts(r, chop_prec)
    if options.get('strict'):
        check_target(x, r, prec)
    return r

.sympy.core.basic.Basic.func

def func(self):
    return self.__class__

.sympy.core.evalf.evalf_add

def evalf_add(v, prec, options):
    res = pure_complex(v)
    if res:
        h, c = res
        re, _, re_acc, _ = evalf(h, prec, options)
        im, _, im_acc