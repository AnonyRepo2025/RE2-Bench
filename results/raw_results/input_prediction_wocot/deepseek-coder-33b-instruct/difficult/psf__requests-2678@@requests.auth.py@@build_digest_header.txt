
[INPUT]
```
{
    "self": {
        "username": "user",
        "password": "pass",
        "_thread_local": {
            "init": true,
            "last_nonce": "54c8df80c7443b10ad9890ddfce551f9",
            "nonce_count": 1,
            "chal": {
                "realm": "me@kennethreitz.com",
                "nonce": "54c8df80c7443b10ad9890ddfce551f9",
                "qop": "auth",
                "opaque": "cbe3b2ba4f82f0040cf76baec4025b43",
                "algorithm": "MD5",
                "stale": false
            },
            "pos": 0,
            "num_401_calls": 1
        }
    },
    "args": {
        "method": "GET",
        "url": "http://httpbin.org/digest-auth/auth/user/pass"
    },
    kwargs: {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
import os
import re
import time
import hashlib
import threading
from base64 import b64encode
from .compat import urlparse, str
from .cookies import extract_cookies_to_jar
from .utils import parse_dict_header, to_native_string
from .status_codes import codes
CONTENT_TYPE_FORM_URLENCODED = 'application/x-www-form-urlencoded'
CONTENT_TYPE_MULTI_PART = 'multipart/form-data'

class HTTPDigestAuth(AuthBase):

    def build_digest_header(self, method, url):
        realm = self._thread_local.chal['realm']
        nonce = self._thread_local.chal['nonce']
        qop = self._thread_local.chal.get('qop')
        algorithm = self._thread_local.chal.get('algorithm')
        opaque = self._thread_local.chal.get('opaque')
        if algorithm is None:
            _algorithm = 'MD5'
        else:
            _algorithm = algorithm.upper()
        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':

            def md5_utf8(x):
                if isinstance(x, str):
                    x = x.encode('utf-8')
                return hashlib.md5(x).hexdigest()
            hash_utf8 = md5_utf8
        elif _algorithm == 'SHA':

            def sha_utf8(x):
                if isinstance(x, str):
                    x = x.encode('utf-8')
                return hashlib.sha1(x).hexdigest()
            hash_utf8 = sha_utf8
        KD = lambda s, d: hash_utf8('%s:%s' % (s, d))
        if hash_utf8 is None:
            return None
        entdig = None
        p_parsed = urlparse(url)
        path = p_parsed.path or '/'
        if p_parsed.query:
            path += '?' + p_parsed.query
        A1 = '%s:%s:%s' % (self.username, realm, self.password)
        A2 = '%s:%s' % (method, path)
        HA1 = hash_utf8(A1)
        HA2 = hash_utf8(A2)
        if nonce == self._thread_local.last_nonce:
            self._thread_local.nonce_count += 1
        else:
            self._thread_local.nonce_count = 1
        ncvalue = '%08x' % self._thread_local.nonce_count
        s = str(self._thread_local.nonce_count).encode('utf-8')
        s += nonce.encode('utf-8')
        s += time.ctime().encode('utf-8')
        s += os.urandom(8)
        cnonce = hashlib.sha1(s).hexdigest()[:16]
        if _algorithm == 'MD5-SESS':
            HA1 = hash_utf8('%s:%s:%s' % (HA1, nonce, cnonce))
        if qop is None:
            respdig = KD(HA1, '%s:%s' % (nonce, HA2))
        elif qop == 'auth' or 'auth' in qop.split(','):
            noncebit = '%s:%s:%s:%s:%s' % (nonce, ncvalue, cnonce, 'auth', HA2)
            respdig = KD(HA1, noncebit)
        else:
            return None
        self._thread_local.last_nonce = nonce
        base = 'username="%s", realm="%s", nonce="%s", uri="%s", response="%s"' % (self.username, realm, nonce, path, respdig)
        if opaque:
            base += ', opaque="%s"' % opaque
        if algorithm:
            base += ', algorithm="%s"' % algorithm
        if entdig:
            base += ', digest="%s"' % entdig
        if qop:
            base += ', qop="auth", nc=%s, cnonce="%s"' % (ncvalue, cnonce)
        return 'Digest %s' % base

    def handle_redirect(self, r, **kwargs):
        if r.is_redirect:
            self._thread_local.num_401_calls = 1
[/PYTHON]

Functions called during the execution:
[PYTHON]
.requests.cookies.MockRequest.get_origin_req_host

def get_origin_req_host(self):
    return self.get_host()

.requests.cookies.MockRequest.get_host

def get_host(self):
    return urlparse(self._r.url).netloc

.requests.cookies.MockRequest.get_full_url

def get_full_url(self):
    if not self._r.headers.get('Host'):
        return self._r.url
    host = self._r.headers['Host']
    parsed = urlparse(self._r.url)
    return urlunparse([parsed.scheme, host, parsed.path, parsed.params, parsed.query, parsed.fragment])

.requests.structures.CaseInsensitiveDict.__getitem__

def __getitem__(self, key):
    return self._store[key.lower()][1]

.requests.cookies.MockResponse.__init__

def __init__(self, headers):
    self._headers = headers

.requests.cookies.MockResponse.info

def info(self):
    return self._headers

.requests.cookies.RequestsCookieJar.set_cookie

def set_cookie(self, cookie, *args, **kwargs):
    if hasattr(cookie.value, 'startswith') and cookie.value.startswith('"') and cookie.value.endswith('"'):
        cookie.value = cookie.value.replace('\\"', '')
    return super(RequestsCookieJar, self).set_cookie(cookie, *args, **kwargs)

.requests.cookies.MockRequest.origin_req_host

def origin_req_host(self):
    return self.get_origin_req_host()

.requests.structures.CaseInsensitiveDict.__setitem__

def __setitem__(self, key, value):
    self._store[key.lower()] = (key, value)

.requests.packages.urllib3._collections.HTTPHeaderDict.__getitem__

def __getitem__(self, key):
    val = _dict_getitem(self, key.lower())
    return ', '.join(val[1:])

.requests.models.PreparedRequest.copy

def copy(self):
    p = Prep