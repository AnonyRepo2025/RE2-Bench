
[INPUT]
```
{
    "self": {
        "n_components": null,
        "whiten": false,
        "copy": true,
        "batch_size": "18",
        "components_": "[[ 0.67880581, -0.1558399, 0.71759083], [-0.15555747, 0.92452514, 0.34792979], [ 0.71765211, 0.34780338, -0.60333098]]",
        "n_samples_seen_": "100",
        "mean_": "[ 0.090962, -0.12025564, -0.02202145]",
        "var_": "[0.98004322, 0.87276777, 1.009518]",
        "singular_values_": "[10.92506979, 9.35311337, 8.91038833]",
        "explained_variance_": "[1.20562778, 0.88364374, 0.8019699]",
        "explained_variance_ratio_": "[0.41699312, 0.30562779, 0.27737909]",
        "noise_variance_": 0.0,
        "batch_size_": "18",
        "n_components_": 3
    },
    "args": {
        "X": "[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]]"
    },
    "kwargs": {
        "check_input": true
    }
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
import numpy as np
from scipy import linalg, sparse
from .base import _BasePCA
from ..utils import check_array, gen_batches
from ..utils.extmath import svd_flip, _incremental_mean_and_var

class IncrementalPCA(_BasePCA):

    def __init__(self, n_components=None, whiten=False, copy=True, batch_size=None):
        self.n_components = n_components
        self.whiten = whiten
        self.copy = copy
        self.batch_size = batch_size

    def fit(self, X, y=None):
        self.components_ = None
        self.n_samples_seen_ = 0
        self.mean_ = 0.0
        self.var_ = 0.0
        self.singular_values_ = None
        self.explained_variance_ = None
        self.explained_variance_ratio_ = None
        self.singular_values_ = None
        self.noise_variance_ = None
        X = check_array(X, accept_sparse=['csr', 'csc', 'lil'], copy=self.copy, dtype=[np.float64, np.float32])
        n_samples, n_features = X.shape
        if self.batch_size is None:
            self.batch_size_ = 5 * n_features
        else:
            self.batch_size_ = self.batch_size
        for batch in gen_batches(n_samples, self.batch_size_, min_batch_size=self.n_components or 0):
            X_batch = X[batch]
            if sparse.issparse(X_batch):
                X_batch = X_batch.toarray()
            self.partial_fit(X_batch, check_input=False)
        return self

    def partial_fit(self, X, y=None, check_input=True):
        if check_input:
            if sparse.issparse(X):
                raise TypeError('IncrementalPCA.partial_fit does not support sparse input. Either convert data to dense or use IncrementalPCA.fit to do so in batches.')
            X = check_array(X, copy=self.copy, dtype=[np.float64, np.float32])
        n_samples, n_features = X.shape
        if not hasattr(self, 'components_'):
            self.components_ = None
        if self.n_components is None:
            if self.components_ is None:
                self.n_components_ = min(n_samples, n_features)
            else:
                self.n_components_ = self.components_.shape[0]
        elif not 1 <= self.n_components <= n_features:
            raise ValueError('n_components=%r invalid for n_features=%d, need more rows than columns for IncrementalPCA processing' % (self.n_components, n_features))
        elif not self.n_components <= n_samples:
            raise ValueError('n_components=%r must be less or equal to the batch number of samples %d.' % (self.n_components, n_samples))
        else:
            self.n_components_ = self.n_components
        if self.components_ is not None and self.components_.shape[0] != self.n_components_:
            raise ValueError('Number of input features has changed from %i to %i between calls to partial_fit!' % (self.components_.shape[0], self.n_components_))
        if not hasattr(self, 'n_samples_seen_'):
            self.n_samples_seen_ = 0
            self.mean_ = 0.0
            self.var_ = 0.0
        col_mean, col_var, n_total_samples = _incremental_mean_and_var(X, last_mean=self.mean_, last_variance=self.var_, last_sample_count=np.repeat(self.n_samples_seen_, X.shape[1]))
        n_total_samples = n_total_samples[0]
        if self.n_samples_seen_ == 0:
            X -= col_mean
        else:
            col_batch_mean = np.mean(X, axis=0)
            X -= col_batch_mean
            mean_correction = np.sqrt(self.n_samples_seen_ * n_samples / n_total_samples) * (self.mean_ - col_batch_mean)
            X = np.vstack((self.singular_values_.reshape((-1, 1)) * self.components_, X, mean_correction))
        U, S, V = linalg.svd(X, full_matrices=False)
        U, V = svd_flip(U, V, u_based_decision=False)
        explained_variance = S ** 2 / (n_total_samples - 1)
        explained_variance_ratio = S ** 2 / np.sum(col_var * n_total_samples)
        self.n_samples_seen_ = n_total_samples
        self.components_ = V[:self.n_components_]
        self.singular_values_ = S[:self.n_components_]
        self.mean_ = col_mean
        self.var_ = col_var
        self.explained_variance_ = explained_variance[:self.n_components_]
        self.explained_variance_ratio_ = explained_variance_ratio[:self.n_components_]
        if self.n_components_ < n_features:
            self.noise_variance_ = explained_variance[self.n_components_:].mean()
        else:
            self.noise_variance_ = 0.0
        return self

    def transform(self, X):
        if sparse.issparse(X):
            n_samples = X.shape[0]
            output = []
            for batch in gen_batches(n_samples, self.batch_size_, min