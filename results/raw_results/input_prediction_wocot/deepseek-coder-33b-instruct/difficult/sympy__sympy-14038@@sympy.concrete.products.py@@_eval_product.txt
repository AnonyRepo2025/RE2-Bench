
[INPUT]
```
{
    "self": {},
    "args": {
        "term": "2**Sum(2*f(k), (k, 1, n))",
        "limits": "(k, 1, n)"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from __future__ import print_function, division
from sympy.core.sympify import _sympify
from sympy.core.singleton import S
from sympy.core.symbol import symbols
from sympy.core.exprtools import factor_terms
from sympy.functions.elementary.exponential import exp, log
from sympy.polys import quo, roots
from sympy.simplify import powsimp
from sympy.core.compatibility import range
from sympy.concrete.summations import Sum
from sympy.concrete.delta import deltaproduct, _has_simple_delta
from sympy.concrete.summations import summation
from sympy.functions import KroneckerDelta, RisingFactorial
from sympy.simplify.simplify import product_simplify
from sympy.concrete.summations import Sum

class Product(ExprWithIntLimits):
    __slots__ = ['is_commutative']
    function = term

    def _eval_product(self, term, limits):
        from sympy.concrete.delta import deltaproduct, _has_simple_delta
        from sympy.concrete.summations import summation
        from sympy.functions import KroneckerDelta, RisingFactorial
        k, a, n = limits
        if k not in term.free_symbols:
            if (term - 1).is_zero:
                return S.One
            return term ** (n - a + 1)
        if a == n:
            return term.subs(k, a)
        if term.has(KroneckerDelta) and _has_simple_delta(term, limits[0]):
            return deltaproduct(term, limits)
        dif = n - a
        if dif.is_Integer:
            return Mul(*[term.subs(k, a + i) for i in range(dif + 1)])
        elif term.is_polynomial(k):
            poly = term.as_poly(k)
            A = B = Q = S.One
            all_roots = roots(poly)
            M = 0
            for r, m in all_roots.items():
                M += m
                A *= RisingFactorial(a - r, n - a + 1) ** m
                Q *= (n - r) ** m
            if M < poly.degree():
                arg = quo(poly, Q.as_poly(k))
                B = self.func(arg, (k, a, n)).doit()
            return poly.LC() ** (n - a + 1) * A * B
        elif term.is_Add:
            factored = factor_terms(term, fraction=True)
            if factored.is_Mul:
                return self._eval_product(factored, (k, a, n))
        elif term.is_Mul:
            exclude, include = ([], [])
            for t in term.args:
                p = self._eval_product(t, (k, a, n))
                if p is not None:
                    exclude.append(p)
                else:
                    include.append(t)
            if not exclude:
                return None
            else:
                arg = term._new_rawargs(*include)
                A = Mul(*exclude)
                B = self.func(arg, (k, a, n)).doit()
                return A * B
        elif term.is_Pow:
            if not term.base.has(k):
                s = summation(term.exp, (k, a, n))
                return term.base ** s
            elif not term.exp.has(k):
                p = self._eval_product(term.base, (k, a, n))
                if p is not None:
                    return p ** term.exp
        elif isinstance(term, Product):
            evaluated = term.doit()
            f = self._eval_product(evaluated, limits)
            if f is None:
                return self.func(evaluated, limits)
            else:
                return f
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.core.cache.__cacheit_nocache

def __cacheit_nocache(func):
    return func

.sympy.core.basic.Basic.free_symbols

def free_symbols(self):
    return set().union(*[a.free_symbols for a in self.args])

.sympy.core.basic.Basic.args

def args(self):
    return self._args

.sympy.core.symbol.Symbol.free_symbols

def free_symbols(self):
    return {self}

.sympy.core.basic.Basic.__hash__

def __hash__(self):
    h = self._mhash
    if h is None:
        h = hash((type(self).__name__,) + self._hashable_content())
        self._mhash = h
    return h

.sympy.core.basic.Basic.__eq__

def __eq__(self, other):
    from sympy import Pow
    if self is other:
        return True
    if type(self) is not type(other):
        try:
            other = _sympify(other)
        except SympifyError:
            return NotImplemented
        if type(self) != type(other):
            return False
    return self._hashable_content() == other._hashable_content()

.sympy.core.sympify._sympify

def _sympify(a):
    return sympify(a, strict=True)

.sympy.core.sympify.sympify

def sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None):
    if evaluate is None:
        if global_evaluate[0] is False:
            evaluate = global_evaluate[0]
        else:
            evaluate = True
    try:
        if a in sympy_classes:
            return a
    except TypeError:
        pass
    try:
        cls = a.__class__
    except AttributeError:
        cls = type(a)
    if cls in sympy_classes:
        return a
    if cls is type(None):
        if strict:
            raise SympifyError(a)
        else:
            return a
    if type(a).__module__ == 'numpy':
        import numpy as np
        if np.isscalar(a):
            return _convert_numpy_types(a)
    try:
        return converter[cls](a)
    except KeyError:
        for superclass in getmro(cls):
            try:
                return converter[superclass](a)
            except KeyError:
                continue
    if isinstance(a, CantSympify):
        raise SympifyError(a)
    try:
        return a._sympy_()
    except AttributeError:
        pass
    if not strict:
        try:
            from ..tensor.array import Array
            return Array(a.flat, a.shape)
        except AttributeError:
            pass
    if not isinstance(a, string_types):
        for coerce in (float, int):
            try:
                return sympify(coerce(a))
            except (TypeError, ValueError, AttributeError, SympifyError):
                continue
    if strict:
        raise SympifyError(a)
    if iterable(a):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a])
        except TypeError:
            pass
    if isinstance(a, dict):
        try:
            return type(a)([sympify(x, locals=locals, convert_xor=convert_xor, rational=rational) for x in a.items()])
        except TypeError:
            pass
    try:
