
[INPUT]
```
{
    "self": {
        "n_iter": 300,
        "tol": 0.001,
        "alpha_1": 1e-06,
        "alpha_2": 1e-06,
        "lambda_1": 1e-06,
        "lambda_2": 1e-06,
        "alpha_init": null,
        "lambda_init": null,
        "compute_score": false,
        "fit_intercept": true,
        "normalize": false,
        "copy_X": true,
        "verbose": false
    },
    "args": {
        "X": [[0.57255817, 0.45644296, 0.53982188, 0.44155843, 0.50433734],
              [0.57255817, 0.45644296, 0.53982188, 0.44155843, 0.50433734],
              [0.57255817, 0.45644296, 0.53982188, 0.44155843, 0.50433734],
              [0.57255817, 0.45644296, 0.53982188, 0.44155843, 0.50433734],
              [0.57255817, 0.45644296, 0.53982188, 0.44155843, 0.50433734]],
        "y": [1.00242412e+00, -4.91430923e-03, 1.01726381e+00, -9.99932334e-01, 7.92438961e-04]
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from sklearn.linear_model import LinearRegression
import numpy as np

class MyLinearRegression(LinearRegression):
    def __init__(self, fit_intercept=True, normalize=False, copy_X=True, n_jobs=None):
        self.fit_intercept = fit_intercept
        self.normalize = normalize
        self.copy_X = copy_X
        self.n_jobs = n_jobs

    def fit(self, X, y, sample_weight=None):
        X, y = self._validate_data(X, y, accept_sparse=['csr', 'csc', 'coo'], y_numeric=True, multi_output=True)
        if sample_weight is not None:
            sample_weight = np.asarray(sample_weight)
        X, y, X_offset, y_offset, X_scale = self._preprocess_data(X, y, fit_intercept=self.fit_intercept, normalize=self.normalize, copy=self.copy_X, sample_weight=sample_weight)
        self.coef_ = np.linalg.lstsq(X, y, rcond=None)[0]
        self._set_intercept(X_offset, y_offset, X_scale)
        return self

    def predict(self, X):
        return self._decision_function(X)

    def _set_intercept(self, X_offset, y_offset, X_scale):
        if self.fit_intercept:
            self.coef_ = self.coef_ / X_scale
            self.intercept_ = y_offset - np.dot(X_offset, self.coef_.T)
        else:
            self.intercept_ = 0.

    def _decision_function(self, X):
        return np.dot(X, self.coef_.T) + self.intercept_
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sklearn.linear_model.base._validate_data

def _validate_data(self, X, y=None, reset=True, validate_separately=False, **check_params):
    if validate_separately:
        X = check_array(X, **check_params)
        if y is not None:
            y = check_array(y, ensure_2d=False)
    else:
        X, y = check_X_y(X, y, **check_params)
    return (X, y)

.sklearn.utils.validation.check_X_y

def check_X_y(X, y, accept_sparse=False, accept_large_sparse=True, dtype='numeric', order=None, copy=False, force_all_finite=True, ensure_2d=True, allow_nd=False, multi_output=False, ensure_min_samples=1, ensure_min_features=1, y_numeric=False, warn_on_dtype=None, estimator=None):
    if y is None:
        raise ValueError('y cannot be None')
    X = check_array(X, accept_sparse=accept_sparse, accept_large_sparse=accept_large_sparse, dtype=dtype, order=order, copy=copy, force_all_finite=force_all_finite, ensure_2d=ensure_2d, allow_nd=allow_nd, ensure_min_samples=ensure_min_samples, ensure_min_features=ensure_min_features, warn_on_dtype=warn_on_dtype, estimator=estimator)
    if multi_output:
        y = check_array(y, 'csr', force_all_finite=True, ensure_2d=False, dtype=None)
    else:
        y = column_or_1d(y, warn=True)
        _assert_all_finite(y)
    if y_numeric and y.dtype.kind == 'O':
        y = y.astype(np.float64)
    check_consistent_length(X, y)
    return (X, y)

.sklearn.utils.validation.check_array

def check_array(array, accept_sparse=False, accept_large_sparse=True, dtype='numeric', order=None, copy=False, force_all_finite=True, ensure_2d=True, allow_nd=False, ensure_min_samples=1, ensure_min_features=1, warn_on_dtype=None, estimator=None):
    if warn_on_dtype is not None:
        warnings.warn("'warn_on_dtype' is deprecated in version 0.21 and will be removed in 0.23. Don't set `warn_on_dtype` to remove this warning.", DeprecationWarning)
    array_orig = array
    dtype_numeric = isinstance(dtype, str) and dtype == 'numeric'
    dtype_orig = getattr(array, 'dtype', None)
    if not hasattr(dtype_orig, 'kind'):
        dtype_orig = None
    dtypes_orig = None
    if hasattr(array, 'dtypes') and hasattr(array.dtypes, '__array__'):
        dtypes_orig = np.array(array.dtypes)
    if dtype_numeric:
        if dtype_orig is not None and dtype_orig.kind == 'O':
            dtype = np.float64
        else:
            dtype = None
    if isinstance(dtype, (list, tuple)):
        if dtype_orig is not None and dtype_orig in dtype:
            dtype = None
        else:
            dtype = dtype[0]
    if force_all_finite not in (True, False, 'allow-nan'):
        raise ValueError('force_all_finite should be a bool or "allow-nan". Got {force