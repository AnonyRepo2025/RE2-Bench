
[INPUT]
```
{
    "self": {
        "default_timeout": 300,
        "_max_entries": 300,
        "_cull_frequency": 3,
        "key_prefix": "",
        "version": 1,
        "key_func": {},
        "_dir": "/tmp/django_cache"
    },
    "args": {
        "key": ["key1", "key2", "key3"]
    },
    "kwargs": {
        "version": 1
    }
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
import os
import re
import json
import attr
from pathlib import Path
from typing import Optional, List, Dict, Any

@attr.s(auto_attribs=True)
class Config:
    name: str
    path: Path
    options: Optional[Dict[str, Any]] = None

@attr.s(auto_attribs=True)
class Configs:
    configs: List[Config]

    def to_json(self):
        return json.dumps(self, default=lambda o: o.__dict__, indent=4)

def load_configs(path: Path) -> Configs:
    configs = []
    for file in path.iterdir():
        if file.is_file() and file.suffix == ".json":
            with file.open() as f:
                data = json.load(f)
                configs.append(Config(name=file.stem, path=file, options=data))
    return Configs(configs=configs)

def save_configs(configs: Configs, path: Path):
    for config in configs.configs:
        with config.path.open("w") as f:
            json.dump(config.options, f, indent=4)

def find_config(configs: Configs, name: str) -> Optional[Config]:
    for config in configs.configs:
        if config.name == name:
            return config
    return None

def update_config(configs: Configs, name: str, options: Dict[str, Any]):
    config = find_config(configs, name)
    if config is not None:
        config.options.update(options)

def delete_config(configs: Configs, name: str):
    config = find_config(configs, name)
    if config is not None:
        configs.configs.remove(config)
        config.path.unlink()
[/PYTHON]
What will be the input of `update_config`, given the following output:
[OUTPUT]
```
None
```
[/OUTPUT]

[STRUCTURE]
```
{
    "configs": {
        "configs": [
            {
                "name": XXX,
                "path": XXX,
                "options": XXX
            },
            ...
        ]
    },
    "args": {
        "name": XXX,
        "options": XXX
    },
    "kwargs": {}
}
```
[/STRUCTURE]

[INPUT]
```
{
    "configs": {
        "configs": [
            {
                "name": "config1",
                "path": "/path/to/config1.json",
                "options": {
                    "option1": "value1",
                    "option2": "value2"
                }
            },
            {
                "name": "config2",
                "path": "/path/to/config2.json",
                "options": {
                    "option1": "value1",
                    "option2": "value2"
                }
            }
        ]
    },
    "args": {
        "name": "config1",
        "options": {
            "option1": "new_value1",
            "option3": "new_value3"
        }
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
import os
import re
import json
import attr
from pathlib import Path
from typing import Optional, List, Dict, Any

@attr.s(auto_attribs=True)
class Config:
    name: str
    path: Path
    options: Optional[Dict[str, Any]] = None

@attr.s(auto_attribs=True)
class Configs:
    configs: List[Config]

    def to_json(self):
        return json.dumps(self, default=lambda o: o.__dict__, indent=4)

def load_configs(path: Path) -> Configs:
    configs = []
    for file in path.iterdir():
        if file.is_file() and file.suffix == ".json":
            with file.open() as f:
                data = json.load(f)
                configs.append(Config(name=file.stem, path=file, options=data))
    return Configs(configs=configs)

def save_configs(configs: Configs, path: Path):
    for config in configs.configs:
        with config.path.open("w") as f:
            json.dump(config.options, f, indent=4)

def find_config(configs: Configs, name: str) -> Optional[Config]:
    for config in configs.configs:
        if config.name == name:
            return config
    return None

def update_config(configs: Configs, name: str, options: Dict[str, Any]):
    config = find_config(configs, name)
    if config is not None:
        config.options.update(options)

def delete_config(configs: Configs, name: str):
    config = find_config(configs, name)
    if config is not None:
        configs.configs.remove(config)
        config.path.unlink()
[/PYTHON]
What will be the input of `delete_config`, given the following output:
[OUTPUT]
```
None
```
[/OUTPUT]

[STRUCTURE]
```
{
    "configs": {
        "configs": [
            {
                "name": XXX,
                "path": XXX,
                "options": XXX
            },
            ...
        ]
    },
    "args": {
        "name": XXX
    },
    "kwargs": {}
}
```
[/STRUCTURE]

[INPUT]
```
{
    "configs": {
        "configs": [
            {
                "name": "config1",
                "path": "/path/to/config1.json",
                "options": {
                    "option1": "value1",
                    "option2": "value2"
                }
            },
            {
                "name": "config2",
                "path": "/path/to/config2.json",
                "options": {
                    "option1": "value1",
                    "option2": "value2"
                }
            }
        ]
    },
    "args": {
        "name": "config1"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
import os
import re
import json
import attr
from pathlib import Path
from typing import Optional, List, Dict, Any

@attr.s(auto_attribs=True)
class Config:
    name: str
    path: Path
    options: Optional[Dict[str, Any]] = None

@attr.s(auto_attribs=True)
class Configs:
    configs: List[Config]

    def to_json(self):
        return json.dumps(self, default=lambda o: o.__dict__, indent=4)

def load_configs(path: Path) -> Configs:
    configs = []
    for file in path.iterdir():
        if file.is_file() and file.suffix == ".json":
            with file.open() as f:
                data = json.load(f)
                configs.append(Config(name=file.stem, path=file, options=data))
    return Configs(configs=configs)

def save_configs(configs: Config