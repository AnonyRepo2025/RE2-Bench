
[INPUT]
```
{
    "self": {
        "secret": "django-insecure-$%^&*()_+",
        "algorithm": "sha1"
    },
    "args": {
        "user": {
            "_state": {
                "db": "default",
                "adding": false
            },
            "id": 1,
            "password": "pbkdf2_sha256$260000$...$...=",
            "last_login": "2022-01-01T00:00:00Z",
            "is_superuser": false,
            "username": "user1",
            "first_name": "",
            "last_name": "",
            "email": "user1@example.com",
            "is_staff": false,
            "is_active": true,
            "date_joined": "2022-01-01T00:00:00Z"
        },
        "token": "1234567890-abcdefghijklmnopqrstuvwxyz"
    },
    kwargs: {}
}
```
[/INPUT]
[/EXAMPLE]
[EXAMPLE]
[PYTHON]
import os
import sys
import json
import time
import random
import string
import hashlib
import binascii
import argparse
import requests
from urllib.parse import urlparse, urlencode
from base64 import b64encode, b64decode
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

class AESCipher:
    def __init__(self, key):
        self.key = hashlib.sha256(key.encode()).digest()

    def encrypt(self, data):
        iv = get_random_bytes(AES.block_size)
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return b64encode(iv + cipher.encrypt(pad(data.encode(), AES.block_size)))

    def decrypt(self, data):
        raw = b64decode(data)
        iv = raw[:AES.block_size]
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return unpad(cipher.decrypt(raw[AES.block_size:]), AES.block_size)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-k', '--key', required=True, help='Encryption key')
    parser.add_argument('-d', '--data', required=True, help='Data to encrypt or decrypt')
    parser.add_argument('-e', '--encrypt', action='store_true', help='Encrypt data')
    parser.add_argument('-D', '--decrypt', action='store_true', help='Decrypt data')
    args = parser.parse_args()

    cipher = AESCipher(args.key)

    if args.encrypt:
        print(cipher.encrypt(args.data).decode())
    elif args.decrypt:
        print(cipher.decrypt(args.data).decode())

if __name__ == '__main__':
    main()
[/PYTHON]
What will be the input of `encrypt`, given the following output:
[OUTPUT]
```
{
    "output": "gAAAAABj1...=="
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "key": XXX
    },
    "args": {
        "data": XXX
    },
    "kwargs": {}
}
```
[/STRUCTURE]

[INPUT]
```
{
    "self": {
        "key": "my_secret_key"
    },
    "args": {
        "data": "hello world"
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[EXAMPLE]
[PYTHON]
import os
import sys
import json
import time
import random
import string
import hashlib
import binascii
import argparse
import requests
from urllib.parse import urlparse, urlencode
from base64 import b64encode, b64decode
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

class AESCipher:
    def __init__(self, key):
        self.key = hashlib.sha256(key.encode()).digest()

    def encrypt(self, data):
        iv = get_random_bytes(AES.block_size)
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return b64encode(iv + cipher.encrypt(pad(data.encode(), AES.block_size)))

    def decrypt(self, data):
        raw = b64decode(data)
        iv = raw[:AES.block_size]
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return unpad(cipher.decrypt(raw[AES.block_size:]), AES.block_size)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-k', '--key', required=True, help='Encryption key')
    parser.add_argument('-d', '--data', required=True, help='Data to encrypt or decrypt')
    parser.add_argument('-e', '--encrypt', action='store_true', help='Encrypt data')
    parser.add_argument('-D', '--decrypt', action='store_true', help='Decrypt data')
    args = parser.parse_args()

    cipher = AESCipher(args.key)

    if args.encrypt:
        print(cipher.encrypt(args.data).decode())
    elif args.decrypt:
        print(cipher.decrypt(args.data).decode())

if __name__ == '__main__':
    main()
[/PYTHON]
What will be the input of `decrypt`, given the following output:
[OUTPUT]
```
{
    "output": "hello world"
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "self": {
        "key": XXX
    },
    "args": {
        "data": XXX
    },
    "kwargs": {}
}
```
[/STRUCTURE]

[INPUT]
```
{
    "self": {
        "key": "my_secret_key"
    },
    "args": {
        "data": "gAAAAABj1...=="
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[EXAMPLE]
[PYTHON]
import os
import sys
import json
import time
import random
import string
import hashlib
import binascii
import argparse
import requests
from urllib.parse import urlparse, urlencode
from base64 import b64encode, b64decode
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

class AESCipher:
    def __init__(self, key):
        self.key = hashlib.sha256(key.encode()).digest()

    def encrypt(self, data):
        iv = get_random_bytes(AES.block_size)
        cipher = AES.new(self.key, AES.MODE_CBC, iv)
        return b64encode(iv + cipher.encrypt(pad(data.encode(), AES.block_size)))

    def decrypt(self, data):
        raw = b64decode(data)
        iv = raw[:AES.block_size]
        cipher = AES.new(self.key, AES.MODE_CBC,