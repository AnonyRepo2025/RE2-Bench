
[INPUT]
```
{
    "self": {
        "step": 2,
        "n_features_in_": 5
    },
    "args": {
        "X": {
            "_shape": [2, 9],
            "maxprint": 50,
            "data": "[ 2  4  6  8 10 12 14 16 18]",
            "indices": "[1 2 3 4 0 1 2 3 4]",
            "indptr": "[0 4 9]"
        }
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
import numpy as np
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.utils import check_array
from sklearn.utils.validation import check_is_fitted

class CustomTransformer(BaseEstimator, TransformerMixin):

    def __init__(self, n_components=2):
        self.n_components = n_components

    def fit(self, X, y=None):
        X = check_array(X)
        self.n_features_in_ = X.shape[1]
        return self

    def transform(self, X):
        check_is_fitted(self)
        X = check_array(X)
        if self.n_features_in_ != X.shape[1]:
            raise ValueError('X has a different shape than during fitting.')
        return X[:, ::self.n_components]
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sklearn.base.BaseEstimator.fit

def fit(self, X, y=None):
    if y is None or isinstance(y, str):
        raise ValueError('y should be defined.')
    if not hasattr(self, 'fit_transform'):
        X, y = self._validate_data(X, y, accept_sparse=['csr', 'csc', 'coo'], reset=True, y_numeric=True, multi_output=True)
        return self._fit(X, y, **(self.fit_params if hasattr(self, 'fit_params') else {}))
    else:
        X, y = self._validate_data(X, y, reset=True, y_numeric=True, multi_output=True)
        return self.fit_transform(X, y)

.sklearn.base.BaseEstimator._validate_data

def _validate_data(self, X='no_validation', y='no_validation', reset=True, validate_separately=False, **check_params):
    self._check_feature_names(X, reset=reset)
    if y is None and self._get_tags()['requires_y']:
        raise ValueError(f'This {self.__class__.__name__} estimator requires y to be passed, but the target y is None.')
    no_val_X = isinstance(X, str) and X == 'no_validation'
    no_val_y = y is None or (isinstance(y, str) and y == 'no_validation')
    default_check_params = {'estimator': self}
    check_params = {**default_check_params, **check_params}
    if no_val_X and no_val_y:
        raise ValueError('Validation should be done on X, y or both.')
    elif not no_val_X and no_val_y:
        X = check_array(X, input_name='X', **check_params)
        out = X
    elif no_val_X and (not no_val_y):
        y = _check_y(y, **check_params)
        out = y
    else:
        if validate_separately:
            check_X_params, check_y_params = validate_separately
            if 'estimator' not in check_X_params:
                check_X_params = {**default_check_params, **check_X_params}
            X = check_array(X, input_name='X', **check_X_params)
            if 'estimator' not in check_y_params:
                check_y_params = {**default_check_params, **check_y_params}
            y = check_array(y, input_name='y', **check_y_params)
        else:
            X, y = check_X_y(X, y, **check_params)
        out = (X, y)
    if not no_val_X and check_params.get('ensure_2d', True):
        self._check_n_features(X, reset=reset)
    return out

.sklearn.base.BaseEstimator._check_feature_names

def _check_feature_names(self, X, *, reset):
    if reset:
        feature_names_in = _get_feature_names(X)
        if feature_names_in is not None:
            self.feature_names_in_ = feature_names_in
        elif hasattr(self, 'feature_names_in_'):
            delattr(self, 'feature_names_in_')
        return
    fitted_feature_names = getattr(self, 'feature_names_in_', None)
    X_feature_names = _get_feature_names(X)
    if fitted_feature_names is None and X_feature_names is None:
        return
    if X_feature_names is not None and fitted_feature_names is None:
        warnings.warn(f'X has feature names, but {self.__class__.__name__} was fitted without feature names')
        return
    if X_feature_names is None and fitted_feature_names is not None:
        warnings.warn(f'X does not have valid feature names, but {self.__class__.__name__} was fitted with feature names')
        return
    if len(fitted_feature_names) != len(X_feature_names) or np.any(fitted_feature_names != X_feature_names):
        message = 'The feature names should match those that were passed during fit.\n'
        fitted_feature_names_set = set(fitted_feature_names)
        X_feature_names_set = set(X_feature_names)
        unexpected_names = sorted(X_feature_names_set - fitted_feature_names_set)
        missing_names = sorted(fitted_feature_names_set - X_feature_names_set)

        def add_names(names):
            output = ''
            max_n_names = 5
            for i, name in enumerate(names):
                if i >= max_n_names:
                    output += '- ...\n'
                    break
                output += f'- {name}\n'
            return output
        if unexpected_names:
            message += 'Feature names unseen at fit time:\n'
            message += add_names(unexpected_names)
        if missing_names:
            message += 'Feature names seen at fit time, yet now missing:\n'
            message += add_names(missing_names)
        if not missing_names and (not unexpected_names):
            message += 'Feature names must be in the same order as they were in fit.\n'
        raise ValueError(message)

.sklearn.base.BaseEstimator._get_tags

def _get_tags(self):
    collected_tags = {}
    for base_class in reversed(inspect.getmro(self.__class__)):
        if hasattr(base_class, '_more_tags'):
            more_tags = base_class._more_tags(self)
            collected_tags.update(more_tags)
    return collected_tags

.sklearn.base.BaseEstimator._more_tags

def _more_tags(self):
    return _DEFAULT_TAGS

.sklearn.base.BaseEstimator.transform

def transform(self, X):
    check_is_fitted(self)
    X = self._validate_data(X, reset=False)
    return self._transform(X)

.sklearn.base.BaseEstimator._transform

def _transform(self, X):
    return X

.sklearn.utils.validation.check_array

def check_array(array, accept_sparse=False, *, accept_