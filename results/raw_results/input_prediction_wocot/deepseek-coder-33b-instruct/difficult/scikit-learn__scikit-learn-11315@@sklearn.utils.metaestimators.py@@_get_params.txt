
[INPUT]
```
{
    "self": {
        "transformers": null,
        "remainder": {
            "with_mean": true,
            "with_std": false,
            "copy": true
        },
        "n_jobs": 1,
        "transformer_weights": null
    },
    "args": {
        "attr": "remainder"
    },
    "kwargs": {
        "deep": true
    }
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from typing import List, Tuple

def get_max_profit(stock_prices: List[int]) -> int:
    if len(stock_prices) < 2:
        raise ValueError('Getting a profit requires at least 2 prices')

    min_price  = stock_prices[0]
    max_profit = stock_prices[1] - stock_prices[0]

    for price in stock_prices[1:]:
        profit = price - min_price
        max_profit = max(max_profit, profit)
        min_price  = min(min_price, price)

    return max_profit

def get_max_profit_with_indexes(stock_prices: List[int]) -> Tuple[int, int, int]:
    if len(stock_prices) < 2:
        raise ValueError('Getting a profit requires at least 2 prices')

    min_price  = stock_prices[0]
    max_profit = stock_prices[1] - stock_prices[0]
    buy_index = 0
    sell_index = 1

    for index, price in enumerate(stock_prices):
        if index == 0:
            continue

        profit = price - min_price

        if profit > max_profit:
            max_profit = profit
            sell_index = index

        min_price = min(min_price, price)

        if price == min_price:
            buy_index = index

    return max_profit, buy_index, sell_index
[/PYTHON]

Functions called during the execution:
[PYTHON]
.builtins.enumerate

def enumerate(sequence, start=0):
    n = start
    for elem in sequence:
        yield n, elem
        n += 1

.builtins.max

def max(iterable, *[, key, default]):
    if iterable:
        max_value = next(iter(iterable))
        for x in iterable:
            if max_value < x:
                max_value = x
        return max_value
    else:
        return default

.builtins.min

def min(iterable, *[, key, default]):
    if iterable:
        min_value = next(iter(iterable))
        for x in iterable:
            if min_value > x:
                min_value = x
        return min_value
    else:
        return default
[/PYTHON]
What will be the input of `get_max_profit`, given the following output:
[OUTPUT]
```
{
    "max_profit": 6
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "stock_prices": XXX
}
```
[/STRUCTURE]

[INPUT]
```
{
    "stock_prices": [10, 7, 5, 8, 11, 9]
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from typing import List

def get_products_of_all_ints_except_at_index(int_list: List[int]) -> List[int]:
    if len(int_list) < 2:
        raise IndexError('Getting the product of numbers at other indices requires at least 2 numbers')

    products_of_all_ints_except_at_index = [None] * len(int_list)

    product_so_far = 1
    for i in range(len(int_list)):
        products_of_all_ints_except_at_index[i] = product_so_far
        product_so_far *= int_list[i]

    product_so_far = 1
    for i in range(len(int_list) - 1, -1, -1):
        products_of_all_ints_except_at_index[i] *= product_so_far
        product_so_far *= int_list[i]

    return products_of_all_ints_except_at_index
[/PYTHON]

Functions called during the execution:
[PYTHON]
.builtins.len

def len(obj, /):
    return obj.__len__()

.builtins.range

def range(start, stop=None, step=None):
    if stop is None:
        stop = start
        start = 0
    if step is None:
        step = 1
    return _range(start, stop, step)

.builtins._range

def _range(*args):
    return _range_with_step(args[0], args[1], args[2])

.builtins._range_with_step

def _range_with_step(start, stop, step):
    if step == 0:
        raise ValueError("range() arg 3 must not be zero")
    if stop == start:
        return []
    if stop > start and step < 0:
        return []
    if stop < start and step > 0:
        return []
    result = []
    i = start
    while i < stop:
        result.append(i)
        i += step
    return result
[/PYTHON]
What will be the input of `get_products_of_all_ints_except_at_index`, given the following output:
[OUTPUT]
```
{
    "products": [840, 1260, 960, 672, 480, 720]
}
```
[/OUTPUT]

[STRUCTURE]
```
{
    "int_list": XXX
}
```
[/STRUCTURE]

[INPUT]
```
{
    "int_list": [2, 3, 4, 5, 6, 7]
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from typing import List

def highest_product_of_3(list_of_ints: List[int]) -> int:
    if len(list_of_ints) < 3:
        raise Exception('Less than 3 items')

    highest = max(list_of_ints[0], list_of_ints[1])
    lowest  = min(list_of_ints[0], list_of_ints[1])
    highest_product_of_2 = list_of_ints[0] * list_of_ints[1]
    lowest_product_of_2  = list_of_ints[0] * list_of_ints[1]
    highest_product_of_3 = list_of_ints[0] * list_of_ints[1] * list_of_ints[2]

    for current in list_of_ints[2:]:
        highest_product_of_3 = max(highest_product_of_3,
                                    current * highest_product_of_2,
                                    current * lowest_product_of_2)

        highest_product_of_2 = max(highest_product_of_2,
                                    current * highest,
                                    current * lowest)

        lowest_product_of_2 = min(lowest_product_of_2,
                                   current * highest,
                                   current * lowest)

        highest = max(highest, current)
        lowest = min(lowest, current)

    return highest_product_of_3
[/PYTHON]

Functions called during the execution:
[PYTHON]
.builtins.max

def max(iterable, *[, key, default]):
    if iterable:
        max_value = next(iter(iterable))
        for x in iterable:
            if max_value < x:
                max_value = x
        return max_value
    else:
        return default

.builtins.min

def min(iterable, *[, key, default