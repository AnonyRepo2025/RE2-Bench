
[INPUT]
```
{
    "self": {
        "nargs": {}
    },
    "args": {
        "old": {
            "_extra_kwargs": {},
            "__module__": "sympy.core.function",
            "__doc__": "Subs(x, y, z)",
            "_nargs": 3,
            "_explicit_class_assumptions": {},
            "default_assumptions": {
                "_generator": {}
            },
            "_prop_handler": {
                "positive": {},
                "commutative": {},
                "complex": {},
                "negative": {}
            }
        },
        "new": {
            "nargs": {
                "_elements": 2
            }
        }
    },
    "kwargs": {}
}
```
[/INPUT]
[/EXAMPLE]
[PYTHON]
from sympy import symbols, sin, cos, exp, log, sqrt, I, E, pi, oo
from sympy.abc import x, y, z
from sympy.calculus.util import continuous_domain
from sympy.core.decorators import wraps
from sympy.core.function import Function
from sympy.core.singleton import S
from sympy.core.sympify import _sympify
from sympy.functions.elementary.exponential import LambertW
from sympy.functions.elementary.miscellaneous import sqrt
from sympy.functions.elementary.trigonometric import cos, sin
from sympy.sets import Interval, FiniteSet
from sympy.utilities.decorator import threaded
from sympy.utilities.iterables import iterable
from sympy.utilities.misc import as_int
from sympy.utilities.pytest import raises

class LambertW(Function):
    """
    The Lambert W function, defined as the inverse of w * exp(w).

    This is a multivalued function.

    Examples
    ========

    >>> from sympy import *
    >>> x = symbols('x')
    >>> lambertw(x)
    lambertw(x)

    We can evaluate lambertw(x) for x > 0:

    >>> lambertw(1).evalf()
    0.5671432904097834

    We can also evaluate lambertw(x) for x < 0:

    >>> lambertw(-1).evalf()
    0.5671432904097834 - 2*I*pi

    """

    nargs = 1

    @classmethod
    def eval(cls, x):
        if x.is_Number:
            if x is S.NaN:
                return S.NaN
            elif x is S.Infinity:
                return S.Infinity
            elif x is S.NegativeInfinity:
                return S.NaN
            elif x is S.Zero:
                return S.Zero
            elif x is S.One:
                return S.One
            elif x.is_negative:
                return cls(x).rewrite(sqrt)
        elif x.is_Mul:
            coeff, term = x.as_coeff_Mul()
            if coeff.is_negative:
                return Mul(coeff, cls(term), evaluate=False)

    @staticmethod
    def _eval_apply_evalf(x):
        try:
            return continuous_domain(x, S.Reals, S.Reals)
        except NotImplementedError:
            pass

    def _eval_is_real(self):
        if self.args[0].is_real:
            if self.args[0] < 0:
                return False
            elif self.args[0] == 0:
                return True
            else:
                return None  # We don't know
        else:
            return False

    def _eval_as_leading_term(self, x):
        arg = self.args[0].as_leading_term(x)
        if arg != self.args[0]:
            return self.func(arg)
        else:
            return self

    def _eval_rewrite_as_sqrt(self, x):
        return sqrt(x)

    def _eval_rewrite_as_exp(self, x):
        return exp(x)

    def _eval_rewrite_as_sin(self, x):
        return sin(x)

    def _eval_rewrite_as_cos(self, x):
        return cos(x)

    def _eval_rewrite_as_log(self, x):
        return log(x)

    def _eval_rewrite_as_exp(self, x):
        return exp(x)

    def _eval_rewrite_as_sin(self, x):
        return sin(x)

    def _eval_rewrite_as_cos(self, x):
        return cos(x)

    def _eval_rewrite_as_log(self, x):
        return log(x)

    def _eval_rewrite_as_exp(self, x):
        return exp(x)

    def _eval_rewrite_as_sin(self, x):
        return sin(x)

    def _eval_rewrite_as_cos(self, x):
        return cos(x)

    def _eval_rewrite_as_log(self, x):
        return log(x)

    def _eval_rewrite_as_exp(self, x):
        return exp(x)

    def _eval_rewrite_as_sin(self, x):
        return sin(x)

    def _eval_rewrite_as_cos(self, x):
        return cos(x)

    def _eval_rewrite_as_log(self, x):
        return log(x)
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.core.function.Function.__init__

def __init__(self, *args, **kwargs):
    self._args = tuple(args)
    self._hash = None
    self._kwargs = kwargs

.sympy.core.function.Function.__hash__

def __hash__(self):
    if self._hash is None:
        self._hash = hash((self.func, self.args, frozenset(self._kwargs.items())))
    return self._hash

.sympy.core.function.Function.__eq__

def __eq__(self, other):
    """Returns true iff 'other' is the same class and has the same args."""
    if not isinstance(other, self.__class__):
        return False
    if self.args != other.args:
        return False
    if self._kwargs != other._kwargs:
        return False
    return True

.sympy.core.function.Function.__ne__

def __ne__(self, other):
    return not self.__eq__(other)

.sympy.core.function.Function.__str__

def __str__(self):
    return self._sympystr()

.sympy.core.function.Function._sympystr

def _sympystr(self, printer=None, *args):
    if printer is None:
        from sympy.printing.str import StrPrinter
        printer = StrPrinter()
    return printer.doprint(self, *args)

.sympy.core.function.Function.__repr__

def __repr__(self):
    return self._sympyrepr()

.sympy.core.function.Function._sympyrepr

def _sympyrepr(self, printer=None, *args):
    if printer is None:
        from sympy.printing.repr import ReprPrinter
        printer = ReprPrinter()
    return printer.doprint(self, *args)

.sympy.core.function.Function.subs

def subs(self, x, *args, **kwargs):
    return self._subs(x, *args, **kwargs)

.sympy.core.function.Function._subs

def _subs(self, x, *args, **kwargs):
    if len(args) == 1 and not kwargs:
        y = args[0]
        if