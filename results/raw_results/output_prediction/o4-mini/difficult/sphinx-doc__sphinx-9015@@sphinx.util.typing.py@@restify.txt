[THOUGHT]
1. The JSON `"cls": { "__module__": "tests.test_util_typing" }` will be deserialized into a plain Python dict:
     cls = {"__module__": "tests.test_util_typing"}
2. Call restify(cls):
   - `cls` is not None or NoneType.
   - `cls` is not Ellipsis.
   - `cls not in INVALID_BUILTIN_CLASSES`.
   - `inspect.isNewType(cls)` → safe_getattr(cls,'__module__',None) returns the dict’s class‐attribute `"builtins"` (not the key), so not a NewType.
   - `isinstance(cls, types_Union)` → False.
   - Next: `cls.__module__ in ('__builtin__','builtins')`?  
     getattr on a dict instance for `__module__` finds the class attribute on dict, which is `"builtins"`.  
     So this branch is taken.
3. In that branch we do `return ':class:`%s`' % cls.__name__`.
   - But `cls` is a dict instance, and it has no `__name__` attribute, so `cls.__name__` raises AttributeError.
4. Therefore the call to restify raises:
     AttributeError: 'dict' object has no attribute '__name__'
[/THOUGHT]
[OUTPUT]
{
    "output": {
        "exception": "AttributeError",
        "message": "'dict' object has no attribute '__name__'"
    }
}
[/OUTPUT]