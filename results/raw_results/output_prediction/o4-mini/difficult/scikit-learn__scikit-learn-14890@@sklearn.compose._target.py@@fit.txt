[THOUGHT]
1. We call TransformedTargetRegressor.fit(self, X, y).
2. In fit, first `y = check_array(y, ..., ensure_2d=False)`. Our `y` is a 1-D numeric array, so this succeeds and yields a 1-D array of shape (150,).
3. We set `self._training_dim = y.ndim`, so `_training_dim = 1`.
4. Since `y.ndim == 1`, we reshape to 2-D: `y_2d = y.reshape(-1,1)`, shape (150,1).
5. We enter `_fit_transformer(y_2d)`. Because `self.transformer is None` and both `func` and `inverse_func` are provided, we create
     `self.transformer_ = FunctionTransformer(func=self.func, inverse_func=self.inverse_func, validate=True, check_inverse=True)`.
6. We call `self.transformer_.fit(y_2d)`. Inside that:
   - `_check_input(y_2d)` is called with `validate=True`, so it calls `check_array(y_2d, ensure_2d=True)`, which succeeds.
   - Because `check_inverse=True` and both `func` and `inverse_func` are set, `_check_inverse_transform` is invoked. 
   - `_check_inverse_transform` does roughly:
       y_sel = a slice of `y_2d`
       y_sel_t = `self.transformer_.transform(y_sel)`  
                 → this calls `_transform(y_sel, func=self.func)`  
                 → since `self.func` is the string `"<function sqrt>"`, Python attempts `"<function sqrt>"(y_sel)`  
                 → TypeError: string object is not callable.
7. Therefore, the fit process raises a TypeError and does not complete.

No instance is returned; instead an exception is raised.

[OUTPUT]
{}
[/OUTPUT]
