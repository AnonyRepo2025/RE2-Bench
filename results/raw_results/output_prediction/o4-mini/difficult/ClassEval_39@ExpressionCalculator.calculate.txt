[THOUGHT]
1. Call calculate("2 + 4 / 4"):
   - transform:
     • Remove whitespace: "2+4/4"
     • No trailing '='.
     • No unary minus to replace.
     → transformed expression: "2+4/4"
2. prepare("2+4/4"):
   - Initialize op_stack = [','], postfix_stack = [].
   - Read characters:
     i=0, '2': not operator → count=1
     i=1, '+': operator
       • count>0 → append "2" to postfix → ['2']
       • peek_op = ','
       • '+' ≠ ')', peek_op==',' → stop popping
       • push '+' onto op_stack → [',','+']
       → reset count=0, current_index=2
     i=2, '4': not operator → count=1
     i=3, '/': operator
       • count>0 → append "4" → postfix ['2','4']
       • peek_op = '+'
       • compare '/' vs '+': priority('/')=1 ≤ priority('+')=3 → pop '+' → postfix ['2','4','+']
       • now peek_op = ','
       • push '/' → op_stack [',','/']
       → reset count=0, current_index=4
     i=4, '4': not operator → count=1
   - End of loop:
     • count==1 and arr[4] not operator → append "4" → postfix ['2','4','+','4']
     • pop remaining operators until ',':
       – pop '/' → postfix ['2','4','+','4','/']
   → final postfix_stack = ['2','4','+','4','/']
3. Evaluate postfix:
   - Reverse postfix_stack → ['/','4','+','4','2']
   - Pop and process:
     1) '2' → push → [ '2' ]
     2) '4' → push → [ '2', '4' ]
     3) '+' → pop 4, pop 2 → compute 2+4 = 6 → push '6' → [ '6' ]
     4) '4' → push → [ '6', '4' ]
     5) '/' → pop 4, pop 6 → compute 6/4 = 1.5 → push '1.5' → [ '1.5' ]
   - result_stack = ['1.5']
   - Return float(eval('*'.join(['1.5']))) = float(eval("1.5")) = 1.5
[/THOUGHT]

[OUTPUT]
```
{
    "output": 1.5        
}
```
[/OUTPUT]