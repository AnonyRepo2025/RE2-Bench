1. **`check_pairwise_arrays(X, Y)`:**
   - `_return_float_dtype(X, Y)` converts X and Y to numpy arrays with `dtype=np.float64`.
   - `check_array` further validates and potentially copies the arrays. Since `X` and `Y` are different, they are checked separately.
   - The function returns the validated `X` and `Y` arrays.

2. **`euclidean_distances(X, Y, squared=True)`:**
   - `X_norm_squared` and `Y_norm_squared` are not provided.
   - `XX = row_norms(X, squared=True)[:, np.newaxis]` calculates the squared row norms of X and adds a new axis.
   - `YY = row_norms(Y, squared=True)[np.newaxis, :]` calculates the squared row norms of Y and adds a new axis.
   - `distances = -2 * safe_sparse_dot(X, Y.T, dense_output=True)` calculates the dot product of X and Y transpose, multiplies by -2.
   - `distances += XX` adds the squared row norms of X to `distances`.
   - `distances += YY` adds the squared row norms of Y to `distances`.
   - `np.maximum(distances, 0, out=distances)` clips negative values to 0.
   - Since X is not Y, the diagonal is not filled with 0.
   - Since `squared=True`, the square root is not taken.

Let's calculate the values:

```python
import numpy as np
from sklearn.metrics.pairwise import euclidean_distances

X = np.array([[0.56804456, 0.92559664, 0.07103606, 0.0871293]])
Y = np.array([[0.96366276, 0.38344152, 0.79172504, 0.52889492]])

distances = euclidean_distances(X, Y, squared=True)
print(distances)
```

This will output:

```
[[1.07774291]]
```

[OUTPUT]
```
{
    "output": [[1.07774291]]
}
```
[/OUTPUT]