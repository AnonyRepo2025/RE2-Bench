1. The input `y` is 1D array. `check_array` converts it to a 2D numpy array with shape (100, 1).
2. `_training_dim` is set to 1.
3. `_fit_transformer` is called with `y` being a 2D array.
4. Since `transformer` is None, a `FunctionTransformer` is created with `func=sqrt` and `inverse_func=log`.
5. `FunctionTransformer.fit` is called. It calls `_check_inverse_transform` which checks if the provided functions are inverse. It will issue a warning because `sqrt` and `log` are not strictly inverse for negative numbers.
6. `y_trans` becomes `np.sqrt(y)`.
7. `y_trans` is squeezed to a 1D array.
8. Since `regressor` is not None, a `LinearRegression` object is cloned and fitted to `X` and `y_trans`.

[OUTPUT]
```
{
    "regressor": {
        "fit_intercept": true,
        "normalize": false,
        "copy_X": true,
        "n_jobs": null
    },
    "transformer": null,
    "func": "<function sqrt>",
    "inverse_func": "<function log>",
    "check_inverse": true,
    "_training_dim": 1,
    "transformer_": {
        "func": "<function sqrt>",
        "inverse_func": "<function log>",
        "validate": true,
        "accept_sparse": false,
        "check_inverse": true,
        "kw_args": null,
        "inv_kw_args": null
    },
    "regressor_": {
        "fit_intercept": true,
        "normalize": false,
        "copy_X": true,
        "n_jobs": null,
        "coef_": [[-0.01278763,  0.00301599, -0.00140384,  0.00618015,  0.0079084 ,
   0.00149448,  0.00521037,  0.00398221,  0.00628982,  0.01046279,
   0.00240829,  0.0029302 ,  0.00906555,  0.00270328,  0.00370853,
   0.00187131,  0.00857723,  0.0040126 ,  0.00015606,  0.00241419,
   0.00296556,  0.00272437,  0.00708698,  0.00310381,  0.00270322,
   0.00899867,  0.0090315 ,  0.00217663,  0.00734814,  0.00012171]],
        "_residues": 17.29997244566653,
        "rank_": 1,
        "singular_": [3.50713377],
        "intercept_": 2.994163779941638
    }
}
```
[/OUTPUT]