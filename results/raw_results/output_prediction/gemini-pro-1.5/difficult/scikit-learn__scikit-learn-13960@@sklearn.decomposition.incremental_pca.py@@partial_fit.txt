Here's how `partial_fit` will execute with the given input:

1. **Input Processing:**
   - `check_input` is `False`, so input `X` is not checked.
   - `X` has 10 samples and 3 features.

2. **Component Initialization:**
   - `n_components` is `None`, and `components_` exists, so `n_components_` becomes 3 (from `components_.shape[0]`).

3. **Incremental Mean and Variance:**
   - `_incremental_mean_and_var` updates the mean, variance, and total sample count.
   - The new mean, variance, and `n_total_samples` are calculated based on the existing values (`self.mean_`, `self.var_`, `self.n_samples_seen_`) and the new batch (`X`).

4. **Centering the Data:**
   - Since `n_samples_seen_` was 90, the data `X` is centered using the batch mean and a correction based on the previous mean.

5. **SVD:**
   - SVD is performed on the combined data (previous components scaled by singular values, centered new batch, and mean correction).

6. **Updating Attributes:**
   - `n_samples_seen_` becomes 100 (90 + 10).
   - `components_`, `singular_values_`, `mean_`, `var_`, `explained_variance_`, and `explained_variance_ratio_` are updated based on the SVD results.
   - `noise_variance_` remains 0.0 because `n_components_` (3) is equal to `n_features` (3).

[OUTPUT]
```
{
    "n_components": null,
    "whiten": false,
    "copy": true,
    "batch_size": "18",
    "components_": "[[-0.65077723 -0.22229198  0.72346412]\n [-0.10577198  0.97269098  0.20539372]\n [-0.75109998  0.06952797 -0.65623999]]",
    "n_samples_seen_": 100,
    "mean_": "[0.09199176 -0.15175088 -0.01230249]",
    "var_": "[0.99600015 0.92000001 1.104     ]",
    "singular_values_": "[10.62983922  9.15870072  8.51538355]",
    "explained_variance_": "[1.26056878 0.93750001 0.81125002]",
    "explained_variance_ratio_": "[0.41599999 0.30933334 0.26766667]",
    "noise_variance_": 0.0,
    "batch_size_": "18",
    "n_components_": 3
}
```
[/OUTPUT]