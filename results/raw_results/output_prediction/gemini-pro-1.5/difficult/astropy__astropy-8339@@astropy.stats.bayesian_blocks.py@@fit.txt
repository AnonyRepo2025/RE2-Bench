```python
import warnings
import numpy as np
from inspect import signature
from astropy.utils.exceptions import AstropyUserWarning
__all__ = ['FitnessFunc', 'Events', 'RegularEvents', 'PointMeasures', 'bayesian_blocks']

class FitnessFunc:

    def __init__(self, p0=0.05, gamma=None, ncp_prior=None):
        self.p0 = p0
        self.gamma = gamma
        self.ncp_prior = ncp_prior

    def validate_input(self, t, x, sigma):
        if x is None:
            if sigma is not None:
                raise ValueError("If sigma is specified, x must be specified")
            else:
                sigma = 1
            x = np.ones_like(t)

        # validate array input
        t = np.asarray(t, dtype=float)
        x = np.asarray(x)
        if sigma is not None:
            sigma = np.asarray(sigma)

        # find unique values of t
        t = np.array(t)
        if t.ndim != 1:
            raise ValueError("t must be a 1-D array")
        unq_t, unq_ind, unq_inv = np.unique(t, return_indices=True,
                                            return_inverse=True)

        # if x is not None, average values with the same t
        if x is not None:
            if x.shape not in [(), (1,), t.shape]:
                raise ValueError("x does not match shape of t")
            x = np.asarray(x)
            if x.ndim == 0:
                x = np.full(t.shape, x)
            elif x.ndim == 1:
                x = np.bincount(unq_inv, weights=x) / np.bincount(unq_inv)
                t = unq_t
            else:
                raise ValueError("Invalid dimensions for x")

        # if sigma is not None, average values with the same t
        if sigma is not None:
            if sigma.shape not in [(), (1,), t.shape]:
                raise ValueError("sigma does not match shape of t")
            sigma = np.asarray(sigma)
            if sigma.ndim == 0:
                sigma = np.full(t.shape, sigma)
            elif sigma.ndim == 1:
                sigma = (np.sqrt(np.bincount(unq_inv,
                                             weights=(sigma ** -2)))
                         / np.bincount(unq_inv)) ** -1
                t = unq_t
            else:
                raise ValueError("Invalid dimensions for sigma")

        return t, x, sigma

    def fitness(self, **kwargs):
        return -0.5 * (kwargs['N_k'] * np.log(2 * np.pi * kwargs['sigma'] ** 2)
                       + kwargs['a_k'])

    def compute_ncp_prior(self, N):
        return 4 - np.log(73.53 * self.p0 * (N ** -0.478))

    def fit(self, t, x=None, sigma=None):
        t, x, sigma = self.validate_input(t, x, sigma)
        self._fitness_args = signature(self.fitness).parameters.keys()
        if 'a_k' in self._fitness_args:
            ak_raw = np.ones_like(x) / sigma ** 2
        if 'b_k' in self._fitness_args:
            bk_raw = x / sigma ** 2
        if 'c_k' in self._fitness_args:
            ck_raw = x * x / sigma ** 2
        edges = np.concatenate([t[:1], 0.5 * (t[1:] + t[:-1]), t[-1:]])
        block_length = t[-1] - edges
        N = len(t)
        best = np.zeros(N, dtype=float)
        last = np.zeros(N, dtype=int)
        if self.ncp_prior is None:
            ncp_prior = self.compute_ncp_prior(N)
        else:
            ncp_prior = self.ncp_prior
        for R in range(N):
            kwds = {}
            if 'T_k' in self._fitness_args:
                kwds['T_k'] = block_length[:R + 1] - block_length[R + 1]
            if 'N_k' in self._fitness_args:
                kwds['N_k'] = np.cumsum(x[:R + 1][::-1])[::-1]
            if 'a_k' in self._fitness_args:
                kwds['a_k'] = 0.5 * np.cumsum(ak_raw[:R + 1][::-1])[::-1]
            if 'b_k' in self._fitness_args:
                kwds['b_k'] = -np.cumsum(bk_raw[:R + 1][::-1])[::-1]
            if 'c_k' in self._fitness_args:
                kwds['c_k'] = 0.5 * np.cumsum(ck_raw[:R + 1][::-1])[::-1]
            kwds['sigma'] = sigma
            fit_vec = self.fitness(**kwds)
            A_R = fit_vec - ncp_prior
            A_R[1:] += best[:R]
            i_max = np.argmax(A_R)
            last[R] = i_max
            best[R] = A_R[i_max]
        change_points = np.zeros(N, dtype=int)
        i_cp = N
        ind = N
        while True:
            i_cp -= 1
            change_points[i_cp] = ind
            if ind == 0:
                break
            ind = last[ind - 1]
        change_points = change_points[i_cp:]
        return edges[change_points]

```

The `fit` function calculates the optimal change points in a time series using the Bayesian Blocks algorithm.  Given the input, the function will first validate the input data and then proceed with the core Bayesian Blocks logic. The output will be an array of change points.

```
{
    "output": [4.36037718, 99.45505108]
}
```
