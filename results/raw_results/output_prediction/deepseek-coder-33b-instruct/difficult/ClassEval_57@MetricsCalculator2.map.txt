
1. The input is an empty list, so the function will return (0.0, [0.0]).
[/THOUGHT]

[OUTPUT]
```
{
    "output": [0.0, [0.0]]
}
```
[/OUTPUT]

[PYTHON]
import numpy as np

class MetricsCalculator2:

    def __init__(self):
        pass

    @staticmethod
    def map(data):
        if type(data) != list and type(data) != tuple:
            raise Exception('the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple')
        if len(data) == 0:
            return (0.0, [0.0])
        if type(data) == tuple:
            sub_list, total_num = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return (0.0, [0.0])
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                right_ranking_list = []
                count = 1
                for t in sub_list:
                    if t == 0:
                        right_ranking_list.append(0)
                    else:
                        right_ranking_list.append(count)
                        count += 1
                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num
                return (ap, [ap])
        if type(data) == list:
            separate_result = []
            for sub_list, total_num in data:
                sub_list = np.array(sub_list)
                if total_num == 0:
                    ap = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                    right_ranking_list = []
                    count = 1
                    for t in sub_list:
                        if t == 0:
                            right_ranking_list.append(0)
                        else:
                            right_ranking_list.append(count)
                            count += 1
                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num
                separate_result.append(ap)
            return (np.mean(separate_result), separate_result)
[/PYTHON]

What will be the output of `map`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "data": [([1, 0, 1, 1, 0, 0, 1, 0, 1, 0], 5), ([1, 1, 0, 0, 1, 1, 0, 0, 0, 1], 4)]
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX        
}
```
[/STRUCTURE]

[THOUGHT]
        
1. The input is a list of tuples.
2. For the first tuple ([1, 0, 1, 1, 0, 0, 1, 0, 1, 0], 5), the function calculates the average precision (AP) as follows:
   - The ranking array is [1.0, 0.5, 0.33, 0.25, 0.2, 0.16, 0.142857143, 0.125, 0.111111111, 0.1].
   - The right ranking list is [1, 0, 2, 3, 0, 0, 4, 0, 5, 0].
   - The AP is the sum of the product of the right ranking list and the ranking array divided by 5.
3. For the second tuple ([1, 1, 0, 0, 1, 1, 0, 0, 0, 1], 4), the function calculates the AP as follows:
   - The ranking array is [1.0, 0.5, 0.33, 0.25, 0.2, 0.16, 0.142857143, 0.125, 0.111111111, 0.1].
   - The right ranking list is [1, 2, 0, 0, 3, 4, 0, 0, 0, 5].
   - The AP is the sum of the product of the right ranking list and the ranking array divided by 4.
4. The overall mean AP is the mean of the APs for each tuple.
5. The function returns the overall mean AP and a list of the APs for each tuple.
[/THOUGHT]

[OUTPUT]
```
{
    "output": [0.5214285714285714, [0.7, 0.5833333333333334]]
}
```
[/OUTPUT]

[PYTHON]
import numpy as np

class MetricsCalculator2:

    def __init__(self):
        pass

    @staticmethod
    def map(data):
        if type(data) != list and type(data) != tuple:
            raise Exception('the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple')
        if len(data) == 0:
            return (0.0, [0.0])
        if type(data) == tuple:
            sub_list, total_num = data
            sub_list = np.array(sub_list)
            if total_num == 0:
                return (0.0, [0.0])
            else:
                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                right_ranking_list = []
                count = 1
                for t in sub_list:
                    if t == 0:
                        right_ranking_list.append(0)
                    else:
                        right_ranking_list.append(count)
                        count += 1
                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num
                return (ap, [ap])
        if type(data) == list:
            separate_result = []
            for sub_list, total_num in data:
                sub_list = np.array(sub_list)
                if total_num == 0:
                    ap = 0.0
                else:
                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)
                    right_ranking_list = []
                    count = 1
                    for t in sub_list:
                        if t == 0:
                            right_ranking_list.append(0)
                        else:
                            right_ranking_list.append(count)
                            count += 1
                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num
                separate_result.append(ap)
            return (np.mean(separate_result), separate_result)
[/PYTHON]

What will be the output of `map`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "data": [([1, 0, 1, 1, 0, 0, 1, 0, 1, 0], 5), ([1, 1, 0, 0, 1, 1, 0, 0, 0, 1], 4), ([1, 0, 1, 0, 1, 0, 0, 1, 0, 1], 5)]
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX        
}
```
[/STRUCTURE]

[THOUGHT]
        
1. The input is a list of tuples.
2. For the first tuple ([1, 0, 1, 1, 0, 0, 1, 