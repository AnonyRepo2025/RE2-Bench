1. Inside `_setup`, `new = copy(self)` creates a copy of the current object.
2. Since `_tick_params` is None, it calls `new = new.tick()`.
3. Since `_label_params` is None, it calls `new = new.label()`.
4. `forward, inverse = new._get_transform()` calls `new._get_transform()`.
5. `mpl_scale = new._get_scale(str(data.name), forward, inverse)` calls `new._get_scale(str(data.name), forward, inverse)`.
6. Since `axis` is None, it creates a new `PseudoAxis` object and updates its units.
7. `mpl_scale.set_default_locators_and_formatters(axis)` sets the default locators and formatters for the scale.
8. If `prop.normed` is False, `normalize` is set to None.
9. `new._pipeline = [axis.convert_units, forward, normalize, prop.get_mapping(new, data)]` creates a pipeline of transformations.
10. If `prop.legend` is True, it sets up the legend.
11. Finally, it returns the new object.
[/THOUGHT]

[OUTPUT]
```
{
    "values": null,
    "norm": null,
    "trans": "log",
    "_tick_params": {
        "locator": null,
        "at": null,
        "upto": null,
        "count": null,
        "every": null,
        "between": null,
        "minor": null
    },
    "_label_params": {
        "formatter": null,
        "like": null,
        "base": {},
        "unit": null
    },
    "_legend": null,
    "_priority": 0,
    "_matplotlib_scale": {
        "_transform": {
            "_parents": {},
            "_invalid": null,
            "_shorthand_name": null,
            "_forward": {},
            "_inverse": {}
        }
    },
    "_pipeline": null,
    "_spacer": null
}
```
[/OUTPUT]
