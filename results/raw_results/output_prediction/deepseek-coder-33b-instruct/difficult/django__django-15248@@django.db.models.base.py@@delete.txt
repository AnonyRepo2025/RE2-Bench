1. Inside `delete`, it calls: collector = Collector(using=using, origin=self)
2. Inside `Collector.__init__`:
    self.using = using = "default"
    self.origin = origin = self
    self.data = defaultdict(set)
    self.field_updates = defaultdict(partial(defaultdict, set))
    self.restricted_objects = defaultdict(partial(defaultdict, set))
    self.fast_deletes = []
    self.dependencies = defaultdict(set)
3. Then it calls: new_objs = self.add(objs, source, nullable, reverse_dependency=reverse_dependency)
4. Inside `Collector.add`:
    model = objs[0].__class__ = self.__class__ = User
    instances = self.data[model] = self.data[User] = set()
    for obj in objs:
        if obj not in instances:
            new_objs.append(obj)
    instances.update(new_objs)
5. Then it calls: self.collect(new_objs, source=model, nullable=True, fail_on_restricted=False)
6. Inside `Collector.collect`:
    if not collect_related:
        return
    if keep_parents:
        parents = set(model._meta.get_parent_list())
    model_fast_deletes = defaultdict(list)
    protected_objects = defaultdict(list)
    for related in get_candidate_relations_to_delete(model._meta):
        if keep_parents and related.model in parents:
            continue
        field = related.field
        if field.remote_field.on_delete == DO_NOTHING:
            continue
        related_model = related.related_model
        if self.can_fast_delete(related_model, from_field=field):
            model_fast_deletes[related_model].append(field)
            continue
        batches = self.get_del_batches(new_objs, [field])
        for batch in batches:
            sub_objs = self.related_objects(related_model, [field], batch)
            if not (sub_objs.query.select_related or self._has_signal_listeners(related_model)):
                referenced_fields = set(chain.from_iterable(((rf.attname for rf in rel.field.foreign_related_fields) for rel in get_candidate_relations_to_delete(related_model._meta))))
                sub_objs = sub_objs.only(*tuple(referenced_fields))
            if sub_objs:
                try:
                    field.remote_field.on_delete(self, field, sub_objs, self.using)
                except ProtectedError as error:
                    key = "'%s.%s'" % (field.model.__name__, field.name)
                    protected_objects[key] += error.protected_objects
7. Then it calls: self.clear_restricted_objects_from_set(related_model, objs)
8. Inside `Collector.clear_restricted_objects_from_set`:
    if model in self.restricted_objects:
        self.restricted_objects[model] = {field: items - objs for field, items in self.restricted_objects[model].items()}
9. Then it calls: self.clear_restricted_objects_from_queryset(qs.model, qs)
10. Finally, it calls: return collector.delete()
11. Inside `Collector.delete`:
    for qs in self.fast_deletes:
        qs.delete()
    return len(self.fast_deletes), dict(self.data)
[/THOUGHT]

[OUTPUT]
```
{
    "output": {
        "deleted_count": 1,
        "deleted_objects": {
            "User": [
                {
                    "id": 99998,
                    "first_name": "James",
                    "last_name": "Jones"
                }
            ]
        }
    }
}
```
[/OUTPUT]
