
[OUTPUT]
```
{
    "output": -1
}
```
[/OUTPUT]
[/PYTHON]

[PYTHON]
from sympy import symbols, diff, sin, cos, exp, ln, sqrt, Matrix, simplify
from sympy.abc import x, y, z
from sympy.vector import CoordSys3D, Del

R = CoordSys3D('R')

def curl(F):
    return simplify(Matrix([diff(F[2], y) - diff(F[1], z), diff(F[0], z) - diff(F[2], x), diff(F[1], x) - diff(F[0], y)]))

def div(F):
    return simplify(diff(F[0], x) + diff(F[1], y) + diff(F[2], z))

def grad(F):
    return Matrix([diff(F, x), diff(F, y), diff(F, z)])

def laplacian(F):
    return simplify(div(grad(F)))

def vector_field(F):
    return Matrix([F.subs({x: x, y: y, z: z}) for x, y, z in R])

def scalar_field(F):
    return F.subs({x: x, y: y, z: z})

def scalar_potential(F):
    return simplify(diff(F, x) * x + diff(F, y) * y + diff(F, z) * z)

def vector_potential(F):
    return Matrix([F.subs({x: x, y: y, z: z}) for x, y, z in R])

def scalar_divergence(F):
    return simplify(diff(F.subs({x: x, y: y, z: z}), x) + diff(F.subs({x: x, y: y, z: z}), y) + diff(F.subs({x: x, y: y, z: z}), z))

def vector_divergence(F):
    return simplify(Matrix([diff(F[0].subs({x: x, y: y, z: z}), x) + diff(F[1].subs({x: x, y: y, z: z}), y) + diff(F[2].subs({x: x, y: y, z: z}), z)]))
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.core.power.Pow.base

def base(self):
    return self._args[0]

.sympy.core.power.Pow.exp

def exp(self):
    return self._args[1]

.sympy.diffgeom.diffgeom.covariant_order

def covariant_order(expr, _strict=False):
    if isinstance(expr, Add):
        orders = [covariant_order(e) for e in expr.args]
        if len(set(orders)) != 1:
            raise ValueError('Misformed expression containing form fields of varying order.')
        return orders[0]
    elif isinstance(expr, Mul):
        orders = [covariant_order(e) for e in expr.args]
        not_zero = [o for o in orders if o != 0]
        if len(not_zero) > 1:
            raise ValueError('Misformed expression containing multiplication between forms.')
        return 0 if not not_zero else not_zero[0]
    elif isinstance(expr, Pow):
        if covariant_order(expr.base) or covariant_order(expr.exp):
            raise ValueError('Misformed expression containing a power of a form.')
        return 0
    elif isinstance(expr, Differential):
        return covariant_order(*expr.args) + 1
    elif isinstance(expr, TensorProduct):
        return sum((covariant_order(a) for a in expr.args))
    elif not _strict or expr.atoms(BaseScalarField):
        return 0
    else:
        return -1

.sympy.core.power.Pow.exp

def exp(self):
    return self._args[1]

.sympy.diffgeom.diffgeom.contravariant_order

def contravariant_order(expr, _strict=False):
    if isinstance(expr, Add):
        orders = [contravariant_order(e) for e in expr.args]
        if len(set(orders)) != 1:
            raise ValueError('Misformed expression containing contravariant fields of varying order.')
        return orders[0]
    elif isinstance(expr, Mul):
        orders = [contravariant_order(e) for e in expr.args]
        not_zero = [o for o in orders if o != 0]
        if len(not_zero) > 1:
            raise ValueError('Misformed expression containing multiplication between vectors.')
        return 0 if not not_zero else not_zero[0]
    elif isinstance(expr, Pow):
        if covariant_order(expr.base) or covariant_order(expr.exp):
            raise ValueError('Misformed expression containing a power of a vector.')
        return 0
    elif isinstance(expr, BaseVectorField):
        return 1
    elif isinstance(expr, TensorProduct):
        return sum((contravariant_order(a) for a in expr.args))
    elif not _strict or expr.atoms(BaseScalarField):
        return 0
    else:
        return -1

.sympy.core.power.Pow.base

def base(self):
    return self._args[0]

.sympy.core.power.Pow.exp

def exp(self):
    return self._args[1]

.sympy.diffgeom.diffgeom.covariant_order

def covariant_order(expr, _strict=False):
    if isinstance(expr, Add):
        orders = [covariant_order(e) for e in expr.args]
        if len(set(orders)) != 1:
            raise ValueError('Misformed expression containing form fields of varying order.')
        return orders[0]
    elif isinstance(expr, Mul):
        orders = [covariant_order(e) for e in expr.args]
        not_zero = [o for o in orders if o != 0]
        if len(not_zero) > 1:
            raise ValueError('Misformed expression containing multiplication between forms.')
        return 0 if not not_zero else not_zero[0]
    elif isinstance(expr, Pow):
        if covariant_order(expr.base) or covariant_order(expr.exp):
            raise ValueError('Misformed expression containing a power of a form.')
        return 0
    elif isinstance(expr, Differential):
        return covariant_order(*expr.args) + 1
    elif isinstance(expr, TensorProduct):
        return sum((covariant_order(a) for a in expr.args))
    elif not _strict or expr.atoms(BaseScalarField):
        return 0
    else:
        return -1

.sympy.core.power.Pow.exp

def exp(self):
    return self._args[1]

.sympy.diffgeom.diffgeom.contravariant_order

def contravariant_order(expr, _strict=False):
    if isinstance(expr, Add):
        orders = [contravariant_order(e) for e in expr.args]
        if len(set(orders)) != 1:
            raise ValueError('Misformed expression containing contravariant fields of varying order.')
        return orders[0]
    elif isinstance(expr, Mul):
        orders = [contravariant_order(e) for e in expr.args]
        not_zero = [o for o in orders if o != 0]
        if len(not_zero) > 1:
            raise ValueError('Misformed expression containing multiplication between vectors.')
        return 0 if not not_zero else not_zero[0]
    elif isinstance(expr, Pow):
        if covariant_order(expr.base) or covariant_order(expr.exp):
            raise ValueError('Misformed expression containing a power of a vector.')
        return 0
    elif