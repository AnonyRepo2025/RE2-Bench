
[OUTPUT]
```
{
    "output": "No solver has been written for linear."
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
from __future__ import print_function, division
from sympy.core.add import Add
from sympy.core.compatibility import as_int, is_sequence, range
from sympy.core.exprtools import factor_terms
from sympy.core.function import _mexpand
from sympy.core.mul import Mul
from sympy.core.numbers import Rational
from sympy.core.numbers import igcdex, ilcm, igcd
from sympy.core.power import integer_nthroot, isqrt
from sympy.core.relational import Eq
from sympy.core.singleton import S
from sympy.core.symbol import Symbol, symbols
from sympy.functions.elementary.complexes import sign
from sympy.functions.elementary.integers import floor
from sympy.functions.elementary.miscellaneous import sqrt
from sympy.matrices.dense import MutableDenseMatrix as Matrix
from sympy.ntheory.factor_ import divisors, factorint, multiplicity, perfect_power
from sympy.ntheory.generate import nextprime
from sympy.ntheory.primetest import is_square, isprime
from sympy.ntheory.residue_ntheory import sqrt_mod
from sympy.polys.polyerrors import GeneratorsNeeded
from sympy.polys.polytools import Poly, factor_list
from sympy.simplify.simplify import signsimp
from sympy.solvers.solvers import check_assumptions
from sympy.solvers.solveset import solveset_real
from sympy.utilities import default_sort_key, numbered_symbols
from sympy.utilities.misc import filldedent
from sympy.utilities.iterables import subsets, permute_signs, signed_permutations
from sympy.core.function import count_ops
from sympy.ntheory.continued_fraction import continued_fraction_periodic
from sympy.simplify.simplify import clear_coefficients
from sympy.utilities.iterables import ordered_partitions
__all__ = ['diophantine', 'classify_diop']
diop_known = {'binary_quadratic', 'cubic_thue', 'general_pythagorean', 'general_sum_of_even_powers', 'general_sum_of_squares', 'homogeneous_general_quadratic', 'homogeneous_ternary_quadratic', 'homogeneous_ternary_quadratic_normal', 'inhomogeneous_general_quadratic', 'inhomogeneous_ternary_quadratic', 'linear', 'univariate'}
classify_diop.func_doc = "\n    Helper routine used by diop_solve() to find information about ``eq``.\n\n    Returns a tuple containing the type of the diophantine equation\n    along with the variables (free symbols) and their coefficients.\n    Variables are returned as a list and coefficients are returned\n    as a dict with the key being the respective term and the constant\n    term is keyed to 1. The type is one of the following:\n\n    * %s\n\n    Usage\n    =====\n\n    ``classify_diop(eq)``: Return variables, coefficients and type of the\n    ``eq``.\n\n    Details\n    =======\n\n    ``eq`` should be an expression which is assumed to be zero.\n    ``_dict`` is for internal use: when True (default) a dict is returned,\n    otherwise a defaultdict which supplies 0 for missing keys is returned.\n\n    Examples\n    ========\n\n    >>> from sympy.solvers.diophantine import classify_diop\n    >>> from sympy.abc import x, y, z, w, t\n    >>> classify_diop(4*x + 6*y - 4)\n    ([x, y], {1: -4, x: 4, y: 6}, 'linear')\n    >>> classify_diop(x + 3*y -4*z + 5)\n    ([x, y, z], {1: 5, x: 1, y: 3, z: -4}, 'linear')\n    >>> classify_diop(x**2 + y**2 - x*y + x + 5)\n    ([x, y], {1: 5, x: 1, x**2: 1, y**2: 1, x*y: -1}, 'binary_quadratic')\n    " % '\n    * '.join(sorted(diop_known))
sum_of_powers = power_representation

def diop_solve(eq, param=symbols('t', integer=True)):
    var, coeff, eq_type = classify_diop(eq, _dict=False)
    if eq_type == 'linear':
        return _diop_linear(var, coeff, param)
    elif eq_type == 'binary_quadratic':
        return _diop_quadratic(var, coeff, param)
    elif eq_type == 'homogeneous_ternary_quadratic':
        x_0, y_0, z_0 = _diop_ternary_quadratic(var, coeff)
        return _parametrize_ternary_quadratic((x_0, y_0, z_0), var, coeff)
    elif eq_type == 'homogeneous_ternary_quadratic_normal':
        x_0, y_0, z_0 = _diop_ternary_quadratic_normal(var, coeff)
        return _parametrize_ternary_quadratic((x_0, y_0, z_0), var, coeff)
    elif eq_type == 'general_pythagorean':
        return _diop_general_pythagorean(var, coeff, param)
    elif eq_type == 'univariate':
        return set([(int(i),) for i in solveset_real(eq, var[0]).intersect(S.Integers)])
    elif eq_type == 'general_sum_of_squares':
        return _diop_general_sum_of_squares(var, -int(coeff[1]), limit=S.Infinity)
    elif eq_type == 'general_sum_of_even_powers':
        for k in coeff.keys():
            if k.is_Pow and coeff[k]:
                p = k.exp
        return _diop_general_sum_of_even_powers(var, p, -int(coeff[1]), limit=S.Infinity)
    if eq_type is not None and eq_type not in diop_known:
        raise ValueError(filldedent('\n    Alhough this type of equation was identified, it is not yet\n    handled. It should, however, be listed in `diop_known` at the\n    top of this file. Developers should see comments at the end of\n    `classify_diop`.\n            '))
    else:
        raise NotImplementedError('No solver has been written for %s.' % eq_type)
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sympy.solvers.diophantine.classify_diop

def classify_diop(eq, _dict=True):
    try:
        var = list(eq.free_symbols)
        assert var
    except (AttributeError, AssertionError):
        raise ValueError('equation should have 1 or more free symbols')
    var.sort(key=default_sort_key)
    eq = eq.expand(force=True)
    coeff = eq.as_coefficients_dict()
    if not all((_is_int(c) for c in coeff.values())):
        raise TypeError('Coefficients should be Integers')
    diop_type = None
    total_degree = Poly(eq).total_degree()
    homogeneous = 1 not in coeff
    if total_degree == 1:
        diop_type = 'linear'
    elif len(var) == 1:
        diop_type = 'univari