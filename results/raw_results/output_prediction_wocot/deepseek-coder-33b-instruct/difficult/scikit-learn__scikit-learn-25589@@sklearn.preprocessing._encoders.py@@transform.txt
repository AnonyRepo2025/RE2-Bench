
[OUTPUT]
```
{
    "_shape": [2, 1],
    "maxprint": 1,
    "indices": [0],
    "indptr": [0, 1],
    "data": [1.0]
}
```
[/OUTPUT]
[/EXAMPLE]
[EXAMPLE]
[PYTHON]
import numpy as np
from sklearn.preprocessing import OneHotEncoder

enc = OneHotEncoder(handle_unknown='ignore')
X = [['Male', 1], ['Female', 3], ['Female', 2]]
enc.fit(X)
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sklearn.preprocessing._encoders._BaseEncoder._fit

def _fit(self, X, handle_unknown='error', force_all_finite=True, return_counts=False):
    self._check_feature_names(X, reset=True)
    self._check_n_features(X, reset=True)
    X_list, n_samples, n_features = self._check_X(X, force_all_finite=force_all_finite)
    self.categories_ = [None] * n_features
    self.feature_names_in_ = _get_feature_names(X)
    category_counts = []
    for i in range(n_features):
        try:
            Xi = X_list[i]
            diff, valid_mask = _check_unknown(Xi, None, return_mask=True)
            if not np.all(valid_mask):
                if handle_unknown == 'error':
                    msg = 'Found unknown categories {0} in column {1} during fit'.format(diff, i)
                    raise ValueError(msg)
                else:
                    Xi = Xi[valid_mask]
            categories = _unique(Xi)
            self.categories_[i] = categories
            if return_counts:
                category_counts.append(_get_counts(Xi, categories))
        except TypeError as e:
            raise TypeError(f'Expected the input for feature {i} to be array-like, got {type(Xi).__name__} instead.') from e
    if return_counts:
        return {'n_samples': n_samples, 'category_counts': category_counts}
[/PYTHON]

What will be the output of `fit`, given the following input:
[INPUT]
```
{
    "self": {
        "categories": "auto",
        "sparse": "deprecated",
        "sparse_output": true,
        "dtype": {
            "__repr__": "\"<function __repr__>\"",
            "__hash__": "\"<function __hash__>\"",
            "__str__": "\"<function __str__>\"",
            "__lt__": "\"<function __lt__>\"",
            "__le__": "\"<function __le__>\"",
            "__eq__": "\"<function __eq__>\"",
            "__ne__": "\"<function __ne__>\"",
            "__gt__": "\"<function __gt__>\"",
            "__ge__": "\"<function __ge__>\"",
            "__add__": "\"<function __add__>\"",
            "__radd__": "\"<function __radd__>\"",
            "__sub__": "\"<function __sub__>\"",
            "__rsub__": "\"<function __rsub__>\"",
            "__mul__": "\"<function __mul__>\"",
            "__rmul__": "\"<function __rmul__>\"",
            "__mod__": "\"<function __mod__>\"",
            "__rmod__": "\"<function __rmod__>\"",
            "__divmod__": "\"<function __divmod__>\"",
            "__rdivmod__": "\"<function __rdivmod__>\"",
            "__pow__": "\"<function __pow__>\"",
            "__rpow__": "\"<function __rpow__>\"",
            "__neg__": "\"<function __neg__>\"",
            "__pos__": "\"<function __pos__>\"",
            "__abs__": "\"<function __abs__>\"",
            "__bool__": "\"<function __bool__>\"",
            "__int__": "\"<function __int__>\"",
            "__float__": "\"<function __float__>\"",
            "__floordiv__": "\"<function __floordiv__>\"",
            "__rfloordiv__": "\"<function __rfloordiv__>\"",
            "__truediv__": "\"<function __truediv__>\"",
            "__rtruediv__": "\"<function __rtruediv__>\"",
            "__new__": "\"<function __new__>\"",
            "as_integer_ratio": "\"<function as_integer_ratio>\"",
            "__doc__": null
        },
        "handle_unknown": "ignore",
        "drop": null,
        "min_frequency": null,
        "max_categories": null,
        "feature_name_combiner": "concat",
        "_infrequent_enabled": false,
        "n_features_in_": 1,
        "categories_": null,
        "_drop_idx_after_grouping": null,
        "drop_idx_": null,
        "_n_features_outs": null
    },
    "args": {
        "X": "[['Male', 1], ['Female', 3], ['Female', 2]]"
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "categories_": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "categories_": [['Female', 'Male'], [1, 2, 3]]
}
```
[/OUTPUT]
[/EXAMPLE]
[EXAMPLE]
[PYTHON]
import numpy as np
from sklearn.preprocessing import OneHotEncoder

enc = OneHotEncoder(handle_unknown='ignore')
X = [['Male', 1], ['Female', 3], ['Female', 2]]
enc.fit(X)
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sklearn.preprocessing._encoders._BaseEncoder._fit

def _fit(self, X, handle_unknown='error', force_all_finite=True, return_counts=False):
    self._check_feature_names(X, reset=True)
    self._check_n_features(X, reset=True)
    X_list, n_samples, n_features = self._check_X(X, force_all_finite=force_all_finite)
    self.categories_ = [None] * n_features
    self.feature_names_in_ = _get_feature_names(X)
    category_counts = []
    for i in range(n_features):
        try:
            Xi = X_list[i]
            diff, valid_mask = _check_unknown(Xi, None, return_mask=True)
            if not np.all(valid_mask):
                if handle_unknown == 'error':
                    msg = 'Found unknown categories {0} in column {1} during fit'.format(diff, i)
                    raise ValueError(msg)
                else:
                    Xi = Xi[valid_mask]
            categories = _unique(Xi)
            self.categories_[i] = categories
            if return_counts:
                category_counts.append(_get_counts(Xi, categories))
        except TypeError as e:
            raise TypeError(f'Expected the input for feature {i} to be array-like, got {type(Xi).__name__} instead.') from e
    if return_counts:
        return {'n_samples': n_samples, 'category_counts': category_counts}
[/PYTHON]

What will be the output of `fit`, given the following input:
[