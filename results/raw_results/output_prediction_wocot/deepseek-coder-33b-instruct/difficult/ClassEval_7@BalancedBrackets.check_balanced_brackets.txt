
[OUTPUT]
```
{
    "output": false
}
```
[/OUTPUT]

[PYTHON]
class BinarySearchTree:

    def __init__(self, value):
        self.value = value
        self.left_child = None
        self.right_child = None

    def insert_node(self, value):
        if value < self.value:
            if self.left_child is None:
                self.left_child = BinarySearchTree(value)
            else:
                self.left_child.insert_node(value)
        else:
            if self.right_child is None:
                self.right_child = BinarySearchTree(value)
            else:
                self.right_child.insert_node(value)

    def find_node(self, value):
        if value < self.value:
            if self.left_child is None:
                return False
            return self.left_child.find_node(value)
        elif value > self.value:
            if self.right_child is None:
                return False
            return self.right_child.find_node(value)
        else:
            return True
[/PYTHON]

What will be the output of `find_node`, given the following input:
[INPUT]
```
{
    "self": {
        "value": 10,
        "left_child": {
            "value": 5,
            "left_child": null,
            "right_child": null
        },
        "right_child": {
            "value": 15,
            "left_child": null,
            "right_child": null
        }
    },
    "args": {
        "value": 15
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": true
}
```
[/OUTPUT]

[PYTHON]
class BinaryTree:

    def __init__(self, value):
        self.value = value
        self.left_child = None
        self.right_child = None

    def insert_left(self, value):
        if self.left_child is None:
            self.left_child = BinaryTree(value)
        else:
            new_node = BinaryTree(value)
            new_node.left_child = self.left_child
            self.left_child = new_node

    def insert_right(self, value):
        if self.right_child is None:
            self.right_child = BinaryTree(value)
        else:
            new_node = BinaryTree(value)
            new_node.right_child = self.right_child
            self.right_child = new_node

    def pre_order(self):
        print(self.value)
        if self.left_child:
            self.left_child.pre_order()
        if self.right_child:
            self.right_child.pre_order()
[/PYTHON]

What will be the output of `pre_order`, given the following input:
[INPUT]
```
{
    "self": {
        "value": 1,
        "left_child": {
            "value": 2,
            "left_child": null,
            "right_child": null
        },
        "right_child": {
            "value": 3,
            "left_child": null,
            "right_child": null
        }
    },
    "args": {},
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": "1\n2\n3"
}
```
[/OUTPUT]

[PYTHON]
class BubbleSort:

    def __init__(self, arr):
        self.arr = arr

    def sort(self):
        n = len(self.arr)
        for i in range(n):
            for j in range(0, n - i - 1):
                if self.arr[j] > self.arr[j + 1]:
                    self.arr[j], self.arr[j + 1] = self.arr[j + 1], self.arr[j]
        return self.arr
[/PYTHON]

What will be the output of `sort`, given the following input:
[INPUT]
```
{
    "self": {
        "arr": [64, 34, 25, 12, 22, 11, 90]
    },
    "args": {},
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": [11, 12, 22, 25, 34, 64, 90]
}
```
[/OUTPUT]

[PYTHON]
class CaesarCipher:

    def __init__(self, shift: int = 3):
        self.shift = shift
    
    @classmethod
    def normalize(cls, text: str) -> str:
        return str(text).replace("\r\n", "\n").replace("\r", "\n")

    @classmethod
    def _alpha_index(cls, ch: str) -> int:
        if "A" <= ch <= "Z":
            return ord(ch) - ord("A")
        if "a" <= ch <= "z":
            return ord(ch) - ord("a")
        return -1

    @classmethod
    def _shift_char(cls, ch: str, k: int) -> str:
        idx = cls._alpha_index(ch)
        if idx == -1:
            return ch  # non-letter unchanged
        base = ord("A") if ch.isupper() else ord("a")
        return chr(base + (idx + k) % 26)

    @classmethod
    def _transform(cls, text: str, k: int) -> str:
        text = cls.normalize(text)
        return "".join(cls._shift_char(c, k) for c in text)

    def encode(self, plaintext: str) -> str:
        return self._transform(plaintext, self.shift)

    def decode(self, ciphertext: str) -> str:
        return self._transform(ciphertext, -self.shift)
[/PYTHON]

What will be the output of `decode`, given the following input:
[INPUT]
```
{
    "self": {
        "shift": 5
    },
    "args": {
        "ciphertext": "Mjqqt, Btwqi!"
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": "Hello, World!"
}
```
[/OUTPUT]

[PYTHON]
class CaesarCipher:

    def __init__(self, shift: int = 3):
        self.shift = shift
    
    @classmethod
    def normalize(cls, text: str) -> str:
        return str(text).replace("\r\n", "\n").replace("\r", "\n")

    @classmethod
    def _alpha_index(cls, ch: str) -> int:
        if "A" <= ch <= "Z":
            return ord(ch) - ord("A")
        if "a" <= ch <= "z":
            return ord(ch) - ord("a")
        return -1

    @classmethod
    def _shift_char(cls, ch: str, k: int) -> str:
        idx = cls._alpha_index(ch)
        if idx == -1:
            return ch  # non-letter unchanged
        base = ord("A") if ch.isupper() else ord("a")
        return chr(base + (idx