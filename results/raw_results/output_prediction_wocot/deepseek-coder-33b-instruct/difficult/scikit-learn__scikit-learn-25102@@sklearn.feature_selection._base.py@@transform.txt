
[OUTPUT]
```
{
    "_shape": [2, 5],
    "maxprint": 50,
    "indices": "[0 2 4 6 8]",
    "indptr": "[0 1 2 3 4 5]",
    "data": "[10  1 11  2 12  3 13  4 14  5 15  6 16  7 17  8 18  9 19]"
}
```
[/OUTPUT]
[/EXAMPLE]
[EXAMPLE]
[PYTHON]
import numpy as np
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.utils import check_array
from sklearn.utils.validation import check_is_fitted

class CustomTransformer(BaseEstimator, TransformerMixin):

    def __init__(self, n_components=2):
        self.n_components = n_components

    def fit(self, X, y=None):
        X = check_array(X)
        self.n_features_in_ = X.shape[1]
        return self

    def transform(self, X):
        check_is_fitted(self)
        X = check_array(X)
        if self.n_components <= 0 or self.n_components > X.shape[1]:
            raise ValueError(f'n_components={self.n_components} must be between 1 and n_features={X.shape[1]}, inclusive.')
        return X[:, :self.n_components]
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sklearn.base.BaseEstimator.fit

def fit(self, X, y=None):
    if y is None or isinstance(y, str):
        X = check_array(X)
        return self._fit(X)
    else:
        X, y = check_X_y(X, y, accept_sparse='csr')
        return self._fit(X, y)

.sklearn.base.BaseEstimator._fit

def _fit(self, X, y=None):
    if y is None:
        return self.fit(X)
    else:
        return self.fit(X, y)

.sklearn.base.BaseEstimator.transform

def transform(self, X):
    check_is_fitted(self)
    X = check_array(X)
    return self._transform(X)

.sklearn.base.BaseEstimator._transform

def _transform(self, X):
    return self.transform(X)

.sklearn.utils.validation.check_is_fitted

def check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):
    if msg is None:
        msg = ("This %(name)s instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.")
    if not hasattr(estimator, 'fit'):
        raise TypeError("%s is not an estimator instance." % (estimator))
    if attributes is not None:
        if not isinstance(attributes, (list, tuple, set, frozenset)):
            attributes = [attributes]
        return _check_is_fitted(estimator, attributes, msg=msg, all_or_any=all_or_any)
    if not hasattr(estimator, '__sklearn_is_fitted__'):
        raise TypeError(msg % {'name': type(estimator).__name__})
[/PYTHON]
What will be the output of `fit`, given the following input:
[INPUT]
```
{
    "self": {
        "n_components": 2
    },
    "args": {
        "X": {
            "_shape": [
                10,
                10
            ],
            "maxprint": 50,
            "data": "[10  1 11  2 12  3 13  4 14  5 15  6 16  7 17  8 18  9 19]",
            "indices": "[1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1]",
            "indptr": "[ 0  1  3  5  7  9 11 13 15 17 19]"
        }
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "n_components": XXX,
    "n_features_in_": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "n_components": 2,
    "n_features_in_": 10
}
```
[/OUTPUT]
[/EXAMPLE]
[EXAMPLE]
[PYTHON]
import numpy as np
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.utils import check_array
from sklearn.utils.validation import check_is_fitted

class CustomTransformer(BaseEstimator, TransformerMixin):

    def __init__(self, n_components=2):
        self.n_components = n_components

    def fit(self, X, y=None):
        X = check_array(X)
        self.n_features_in_ = X.shape[1]
        return self

    def transform(self, X):
        check_is_fitted(self)
        X = check_array(X)
        if self.n_components <= 0 or self.n_components > X.shape[1]:
            raise ValueError(f'n_components={self.n_components} must be between 1 and n_features={X.shape[1]}, inclusive.')
        return X[:, :self.n_components]
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sklearn.base.BaseEstimator.fit

def fit(self, X, y=None):
    if y is None or isinstance(y, str):
        X = check_array(X)
        return self._fit(X)
    else:
        X, y = check_X_y(X, y, accept_sparse='csr')
        return self._fit(X, y)

.sklearn.base.BaseEstimator._fit

def _fit(self, X, y=None):
    if y is None:
        return self.fit(X)
    else:
        return self.fit(X, y)

.sklearn.base.BaseEstimator.transform

def transform(self, X):
    check_is_fitted(self)
    X = check_array(X)
    return self._transform(X)

.sklearn.base.BaseEstimator._transform

def _transform(self, X):
    return self.transform(X)

.sklearn.utils.validation.check_is_fitted

def check_is_fitted(estimator, attributes=None, *, msg=None, all_or_any=all):
    if msg is None:
        msg = ("This %(name)s instance is not fitted yet. Call 'fit' with appropriate arguments before using this estimator.")
    if not hasattr(estimator, 'fit'):
        raise TypeError("%s is not an estimator instance." % (estimator))
    if attributes is not None:
        if not isinstance(attributes, (list, tuple, set, frozenset)):
            attributes = [attributes]
        return _check_is_fitted(estimator, attributes, msg=msg, all_or_any=all_or_any)
    if not hasattr(estimator, '__sklearn_is_fitted__'):
        raise TypeError(msg % {'name': type(estimator).__name__})
[/PYTHON]
What will be the output of `transform`, given the following input:
[INPUT]
```
{
    "self": {
        "n_components": 2,
        "n_features_in_": 10
    },
    "args": {
        "X": {
            "_shape": [
                10,