
[OUTPUT]
```
{
    "_shape": [1, 9],
    "maxprint": 9,
    "indices": [0 2 5 9],
    "indptr": [0 1 2 3],
    "data": [1.0 1.0 1.0]
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
import numpy as np
from sklearn.preprocessing import OneHotEncoder
from sklearn.utils import check_array
from sklearn.utils.validation import check_is_fitted

class OneHotEncoder(OneHotEncoder):
    def __init__(self, n_values='auto', categorical_features='all', dtype=np.float64, sparse=True, handle_unknown='error'):
        super().__init__(n_values, categorical_features, dtype, sparse, handle_unknown)

    def fit(self, X, y=None):
        self.fit_transform(X)
        return self

    def _fit_transform(self, X):
        X = check_array(X, dtype=np.int)
        if np.any(X < 0):
            raise ValueError('X needs to contain only non-negative integers.')
        n_samples, n_features = X.shape
        if isinstance(self.n_values, str) and self.n_values == 'auto':
            n_values = np.max(X, axis=0) + 1
        elif isinstance(self.n_values, int):
            if (np.max(X, axis=0) >= self.n_values).any():
                raise ValueError('Feature out of bounds for n_values=%d' % self.n_values)
            n_values = np.empty(n_features, dtype=np.int)
            n_values.fill(self.n_values)
        else:
            try:
                n_values = np.asarray(self.n_values, dtype=int)
            except (ValueError, TypeError):
                raise TypeError("Wrong type for parameter `n_values`. Expected 'auto', int or array of ints, got %r" % type(X))
            if n_values.ndim < 1 or n_values.shape[0] != X.shape[1]:
                raise ValueError('Shape mismatch: if n_values is an array, it has to be of shape (n_features,).')
        self.n_values_ = n_values
        n_values = np.hstack([[0], n_values])
        indices = np.cumsum(n_values)
        self.feature_indices_ = indices
        column_indices = (X + indices[:-1]).ravel()
        row_indices = np.repeat(np.arange(n_samples, dtype=np.int32), n_features)
        data = np.ones(n_samples * n_features)
        out = sparse.coo_matrix((data, (row_indices, column_indices)), shape=(n_samples, indices[-1]), dtype=self.dtype).tocsr()
        if isinstance(self.n_values, str) and self.n_values == 'auto':
            mask = np.array(out.sum(axis=0)).ravel() != 0
            active_features = np.where(mask)[0]
            out = out[:, active_features]
            self.active_features_ = active_features
        return out if self.sparse else out.toarray()

    def fit_transform(self, X, y=None):
        return self._fit_transform(X)

    def _transform(self, X):
        X = check_array(X, dtype=np.int)
        if np.any(X < 0):
            raise ValueError('X needs to contain only non-negative integers.')
        n_samples, n_features = X.shape
        indices = self.feature_indices_
        if n_features != indices.shape[0] - 1:
            raise ValueError('X has different shape than during fitting. Expected %d, got %d.' % (indices.shape[0] - 1, n_features))
        mask = (X < self.n_values_).ravel()
        if np.any(~mask):
            if self.handle_unknown not in ['error', 'ignore']:
                raise ValueError('handle_unknown should be either error or unknown got %s' % self.handle_unknown)
            if self.handle_unknown == 'error':
                raise ValueError('unknown categorical feature present %s during transform.' % X.ravel()[~mask])
        column_indices = (X + indices[:-1]).ravel()[mask]
        row_indices = np.repeat(np.arange(n_samples, dtype=np.int32), n_features)[mask]
        data = np.ones(np.sum(mask))
        out = sparse.coo_matrix((data, (row_indices, column_indices)), shape=(n_samples, indices[-1]), dtype=self.dtype).tocsr()
        if isinstance(self.n_values, str) and self.n_values == 'auto':
            out = out[:, self.active_features_]
        return out if self.sparse else out.toarray()

    def transform(self, X):
        return self._transform(X)
[/PYTHON]

Functions called during the execution:
[PYTHON]
.sklearn.utils.validation.check_array

def check_array(array, accept_sparse=False, dtype='numeric', order=None, copy=False, force_all_finite=True, ensure_2d=True, allow_nd=False, ensure_min_samples=1, ensure_min_features=1, warn_on_dtype=False, estimator=None):
    if accept_sparse is None:
        warnings.warn("Passing 'None' to parameter 'accept_sparse' in methods check_array and check_X_y is deprecated in version 0.19 and will be removed in 0.21. Use 'accept_sparse=False'  instead.", DeprecationWarning)
        accept_sparse = False
    array_orig = array
    dtype_numeric = isinstance(dtype, six.string_types) and dtype == 'numeric'
    dtype_orig = getattr(array, 'dtype', None)
    if not hasattr(dtype_orig, 'kind'):
        dtype_orig = None
    if dtype_numeric:
        if dtype_orig is not None and dtype_orig.kind == 'O':
            dtype = np.float64
        else:
            dtype = None
    if isinstance(dtype, (list, tuple)):
        if dtype_orig is not None and dtype_orig in dtype:
            dtype = None
        else:
            dtype = dtype[0]
    if force_all_finite not in (True, False, 'allow-nan'):
        raise ValueError('force_all_finite should be a bool or "allow-nan". Got {force_all_finite} instead'.format(force_all_finite=force_all_finite))
    if estimator is not None:
        if isinstance(estimator, six.string_types):
            estimator_name = estimator
        else:
            estimator_name = estimator.__class__.__name__
    else:
        estimator_name = 'Estimator'
    context = ' by %s' % estimator_name if estimator is not None else ''
    if sp.issparse(array):
        _ensure_no_complex_data(array)
        array = _ensure_sparse_format(array, accept_sparse, dtype, copy, force_all_finite)
    else:
        with warnings.catch_warnings():
            try:
                warnings.simplefilter('error', ComplexWarning)
                array = np.asarray(array, dtype=dtype, order=order)
            except ComplexWarning:
                raise ValueError('Complex data not supported\n{array}\n'.format(array=array))
        _ensure_no_complex_data(array)
        if ensure_2d:
            if array.ndim == 0:
                raise ValueError('Expected 2D array,