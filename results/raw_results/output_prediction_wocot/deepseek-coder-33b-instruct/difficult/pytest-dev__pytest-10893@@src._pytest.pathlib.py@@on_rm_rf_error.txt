
[OUTPUT]
```
{
    "output": "True"
}
```
[/OUTPUT]
[/PYTHON]

[PYTHON]
def _force_symlink(root, name, target):
    link = root.joinpath(name)
    if link.is_symlink():
        link.unlink()
    link.symlink_to(target)

def _max(iterable, *, default=None):
    iterator = iter(iterable)
    try:
        max_value = next(iterator)
    except StopIteration:
        return default
    for value in iterator:
        if value > max_value:
            max_value = value
    return max_value

def _rm_rf(path: Path) -> None:
    if not path.exists():
        return
    if path.is_file():
        path.unlink()
    else:
        shutil.rmtree(path, ignore_errors=True, onerror=partial(on_rm_rf_error, shutil.rmtree, start_path=path))

def ensure_reset_dir(path: Path) -> None:
    if path.exists():
        _rm_rf(path)
    path.mkdir(parents=True)
[/PYTHON]

What will be the output of `ensure_reset_dir`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "path": "/tmp/pytest-of-root/pytest-0/test_ensure_reset_dir0"
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX        
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": "None"
}
```
[/OUTPUT]
[/PYTHON]

[PYTHON]
def make_numbered_dir_with_cleanup(root, prefix, keep, lock_timeout):
    def cleanup(root, prefix, keep):
        dirs = [d for d in root.iterdir() if d.name.startswith(prefix)]
        dirs.sort(key=lambda d: d.name)
        for d in dirs[:-keep]:
            _rm_rf(d)

    dir = make_numbered_dir(root, prefix)
    cleanup(root, prefix, keep)
    return dir
[/PYTHON]

What will be the output of `make_numbered_dir_with_cleanup`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "root": "/tmp/pytest-of-root/pytest-0",
        "prefix": "test_make_numbered_dir_with_cleanup0",
        "keep": 3,
        "lock_timeout": 259200
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "strpath": XXX        
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_make_numbered_dir_with_cleanup00"
}
```
[/OUTPUT]
[/PYTHON]

[PYTHON]
def get_user():
    return os.getenv("USER")
[/PYTHON]

What will be the output of `get_user`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {},
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "user": XXX        
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "user": "root"
}
```
[/OUTPUT]
[/PYTHON]

[PYTHON]
def find_prefixed(root, prefix):
    for p in root.iterdir():
        if p.name.startswith(prefix):
            yield p
[/PYTHON]

What will be the output of `find_prefixed`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "root": "/tmp/pytest-of-root/pytest-0",
        "prefix": "test_find_prefixed0"
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "paths": [
        XXX
    ]
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "paths": [
        "/tmp/pytest-of-root/pytest-0/test_find_prefixed00"
    ]
}
```
[/OUTPUT]
[/PYTHON]

[PYTHON]
def _force_symlink(root, name, target):
    link = root.joinpath(name)
    if link.is_symlink():
        link.unlink()
    link.symlink_to(target)
[/PYTHON]

What will be the output of `_force_symlink`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "root": "/tmp/pytest-of-root/pytest-0/test_force_symlink0",
        "name": "current",
        "target": "/tmp/pytest-of-root/pytest-0/test_force_symlink0/dir"
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX        
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": "None"
}
```
[/OUTPUT]
[/PYTHON]

[PYTHON]
def _rm_rf(path: Path) -> None:
    if not path.exists():
        return
    if path.is_file():
        path.unlink()
    else:
        shutil.rmtree(path, ignore_errors=True, onerror=partial(on_rm_rf_error, shutil.rmtree, start_path=path))
[/PYTHON]

What will be the output of `_rm_rf`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "path": "/tmp/pytest-of-root/pytest-0/test_rm_rf0"
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX        
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": "None"
}
```
[/OUTPUT]
[/PYTHON]

[PYTHON]
def ensure_reset_dir(path: Path) -> None:
    if path.exists():
        _rm_rf(path)
    path.mkdir(parents=True)
[/PYTHON]

What will be the output of `ensure_reset_dir`, given the following input:
[INPUT]
```
{
    "self": {},
    "args": {
        "path": "/tmp/pytest-of-root/pytest-0/test_ensure_reset_dir0"
    },
    "kwargs": {}
}
```
[/INPUT]

[STRUCTURE]
```
{
    "output": XXX        
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": "None"
}
```
[/OUTPUT]
[/PYTHON]

[PYTHON]
def make_numbered_dir_with_cleanup(root, prefix, keep, lock_timeout):
    def cleanup(root, prefix, keep):
        dirs = [d for d in root.iterdir() if d.name.startswith(prefix)]
        dirs.sort(key=lambda d: d.name)
        for d in dirs[:-keep]:
            _rm_rf(d)

    dir = make_numbered_dir(root, prefix)
    clean