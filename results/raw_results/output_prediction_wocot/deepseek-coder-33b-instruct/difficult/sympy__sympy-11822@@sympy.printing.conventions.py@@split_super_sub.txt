
[OUTPUT]
```
{
    "output": ("alpha", ["+"], ["1"])
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
def _max(iterable, default=None):
    try:
        return max(iterable)
    except ValueError:
        return default

def _force_symlink(root, name, target):
    link = root.joinpath(name)
    if link.is_symlink():
        link.unlink()
    link.symlink_to(target)

def find_prefixed(root, prefix):
    for p in root.iterdir():
        if p.name.startswith(prefix):
            yield p
[/PYTHON]

What will be the output of `make_numbered_dir`, given the following input:
[INPUT]
{
    "self": {
        "_tmppath_factory": {
            "_given_basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
            "_trace": {},
            "_basetemp": null
        }
    },
    "args": {
        "root": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
        "prefix": "world"
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "strpath": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
def ensure_reset_dir(basetemp):
    if basetemp.exists():
        shutil.rmtree(basetemp)
    basetemp.mkdir(parents=True)
[/PYTHON]

What will be the output of `ensure_reset_dir`, given the following input:
[INPUT]
{
    "self": {},
    "args": {
        "basetemp": "/tmp/pytest-of-root/pytest-0/test_mktemp0"
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "output": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": "None"
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
def make_numbered_dir_with_cleanup(root, prefix, keep, lock_timeout):
    with lockfile.LockFile(root.joinpath(".lock")):
        dirs = sorted(find_prefixed(root, prefix), key=lambda p: p.name)
        for old in dirs[:-keep]:
            shutil.rmtree(old)
        return make_numbered_dir(root, prefix)
[/PYTHON]

What will be the output of `make_numbered_dir_with_cleanup`, given the following input:
[INPUT]
{
    "self": {},
    "args": {
        "root": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
        "prefix": "world",
        "keep": 3,
        "lock_timeout": 10
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "strpath": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "strpath": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
def get_user():
    return os.getenv("USER")
[/PYTHON]

What will be the output of `get_user`, given the following input:
[INPUT]
{
    "self": {},
    "args": {},
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "output": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": "root"
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
def parse_num(maybe_num):
    try:
        return int(maybe_num)
    except ValueError:
        return -1
[/PYTHON]

What will be the output of `parse_num`, given the following input:
[INPUT]
{
    "self": {},
    "args": {
        "maybe_num": "123"
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "output": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": 123
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
def extract_suffixes(iter, prefix):
    p_len = len(prefix)
    for p in iter:
        yield p.name[p_len:]
[/PYTHON]

What will be the output of `extract_suffixes`, given the following input:
[INPUT]
{
    "self": {},
    "args": {
        "iter": ["/tmp/pytest-of-root/pytest-0/test_mktemp0/world0", "/tmp/pytest-of-root/pytest-0/test_mktemp0/world1"],
        "prefix": "world"
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "output": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": ["0", "1"]
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
def find_suffixes(root, prefix):
    return extract_suffixes(find_prefixed(root, prefix), prefix)
[/PYTHON]

What will be the output of `find_suffixes`, given the following input:
[INPUT]
{
    "self": {},
    "args": {
        "root": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
        "prefix": "world"
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "output": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": ["0", "1"]
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
def _max(iterable, default=None):
    try:
        return max(iterable)
    except ValueError:
        return default
[/PYTHON]

What will be the output of `_max`, given the following input:
[INPUT]
{
    "self": {},
    "args": {
        "iterable": [1, 2, 3]
    },
    "kwargs": {}
}
[/INPUT]

[STRUCTURE]
```
{ 
    "output": XXX
}
```
[/STRUCTURE]

[OUTPUT]
```
{
    "output": 3
}
```
[/OUTPUT]
[/EXAMPLE]
[PYTHON]
def _force_symlink(root, name, target):
    link = root.joinpath(name)
    if link.is_symlink():
        link.unlink()
    link.symlink_to(target)
[/PYTHON]

What will be the output of `_force_symlink`, given the following input:
[INPUT]
{
    "self": {},
    "args": {
        "root": "/tmp/pytest-of-root/pytest-0/test_mktemp0",
        "name": "current",
        "target": "/tmp/pytest-of-root/pytest-0/test_mktemp0/world0"
    },
    "kwargs": {}
}
[/INPUT]
